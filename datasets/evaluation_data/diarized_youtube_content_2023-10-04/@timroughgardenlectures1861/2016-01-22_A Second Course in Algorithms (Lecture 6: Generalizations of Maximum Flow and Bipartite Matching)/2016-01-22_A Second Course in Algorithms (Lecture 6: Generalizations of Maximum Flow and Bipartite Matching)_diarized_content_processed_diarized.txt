00:00:00.090 - 00:00:08.334, Speaker A: Alright, so two orders of business today. First order of business is to finish the Hungarian algorithm. This is for the minimum cost bipartite perfect matching problem.
00:00:08.334 - 00:00:24.914, Speaker A: So I'll remind you where we left off Tuesday and then finish that up. And then the second half of the lecture, I'm going to give you a survey of some problems which are more general than the ones we've studied so far. Maximum flow and bipartite matching, which also have efficient algorithms along the lines that we've been discussing.
00:00:24.914 - 00:00:42.646, Speaker A: So a few other problems I just want you to know they exist, they're solved using techniques similar to what you've learned so far in this class. All right, so let me page everything back in for you from Tuesday. So what do we do? So we're talking about the min cost perfect matching problem.
00:00:42.646 - 00:00:59.834, Speaker A: And so again, the first thing we did is structural, not algorithmic. We wanted to know how do we know when we're done? How do we know if a perfect matching really is minimum cost? So that motivated an optimality condition. And so the optimality condition says that a given perfect matching is minimum cost if and only if there's no negative cycle.
00:00:59.834 - 00:01:05.534, Speaker A: Let me remind you what a negative cycle is. So it's a bipartite graph. So every cycle in the graph is going to be even.
00:01:05.534 - 00:01:17.170, Speaker A: So first of all, a negative cycle has to be alternating. So every other edge is in the matching, every other edge is out of the matching. That's of course as many edges as you could have from the matching in the cycle.
00:01:17.170 - 00:01:30.354, Speaker A: And then what does it mean to be negative? It means that the edges in the cycle that are in the matching have higher cost than the edges in the cycle which are out of the matching. So here's an example. This four cycle, the pink edges are the matched edges.
00:01:30.354 - 00:01:41.574, Speaker A: The edges in have cost seven, the edges out have cost five. So that would be a negative cycle. It's easy to see that the only way it could be minimum cost is if there's no negative cycle.
00:01:41.574 - 00:02:00.402, Speaker A: If you give me a negative cycle, I can just toggle the edges inside that cycle, I get a new perfect matching. And its cost is strictly less than the one we started with. So it's certainly necessary for optimality that there's no negative cycles, but it's also sufficient that's the hard direction, which is that if there's no negative cycles, then in fact you really are minimum cost.
00:02:00.402 - 00:02:14.306, Speaker A: So we proved that last time. So then we started thinking about, okay, how do we actually come up with an algorithm to compute a min cost matching? Okay, we know what we want the termination condition to be. We know the termination condition should be no negative cycles.
00:02:14.306 - 00:02:40.480, Speaker A: But how do we get there efficiently and following the same strategy that works so well for maximum flow, especially in the push relabel lecture, we're going to have some invariants, which our algorithm maintains at all times, so that those invariants imply the optimality conditions. So this isn't an algorithm, but it's guiding us closer and closer to an algorithm. It reduces the algorithm design problem to just maintain the invariance and compute a perfect matching subject to them.
00:02:40.480 - 00:03:05.458, Speaker A: So what were the invariants that we were going to maintain? So first of all, each vertex has a price, so that's called p of v. This could be positive or negative. And then with respect to prices, every edge has a corresponding reduced cost CP of the edge, which is just the original cost minus the prices of its endpoints.
00:03:05.458 - 00:03:16.154, Speaker A: So that's the reduced cost. Both of our invariants are about these reduced costs. The first one is that just every edge, whether it's in the matching or not, should have non negative reduced cost.
00:03:16.154 - 00:03:28.042, Speaker A: So we don't allow negative reduced costs. Secondly, for the edges that are in the matching, we insist on something stronger, that the reduced cost is actually zero, the minimum possible. Okay, so those edges are called tight.
00:03:28.042 - 00:03:37.018, Speaker A: If you have reduced cost zero, what's the motivation for these invariants? Well, as we proved last time, if you satisfy these invariants, then there's no negative cycle.
00:03:37.114 - 00:03:37.470, Speaker B: Okay?
00:03:37.540 - 00:03:56.070, Speaker A: So what we need to do is compute a perfect matching so that the invariants hold, and then we're going to be done. That's sort of the algorithmic problem we're going to focus on. I also told you Tuesday what sort of the main loop of the algorithm looks like and what are the two different types of updates which are going to happen in each iteration of the main loop.
00:03:56.070 - 00:04:09.494, Speaker A: So obviously we're going to keep looping as long as our matching is not perfect. We're going to keep trying to increase the number of edges in our matching one at a time until we get to a perfect matching. So one good case is if we find a good path.
00:04:09.494 - 00:04:19.962, Speaker A: I'll tell you what that means in a second. But a good path allows you to increase the size of your matching by one without screwing up the invariance. What do you do? You just toggle the edges in the good path.
00:04:19.962 - 00:04:34.340, Speaker A: Okay, more on that in a second. And then if we fail to find a good path, what I'm going to prove to you today is that we'll find what I was calling on Tuesday, a good set. And if you have a good set, then you have this particular update of the prices, which makes progress in a certain sense.
00:04:34.340 - 00:04:44.626, Speaker A: So it should be clear that this can only happen n times. Remember, n is the number of vertices on both sides of this bipartite graph. Perfect matching has n edges.
00:04:44.626 - 00:05:06.670, Speaker A: Each good path augmentation increases the number of edges that happens only n times. It's not obvious, but what I'm going to show you is that this second step, this price update, can only happen n times at most until we find a good path. So this happens at most N times in between each two times this happens, this happens at most N times.
00:05:06.670 - 00:05:13.346, Speaker A: So that'll be an N squared iteration bound. As you'll see, it's not hard to implement each iteration in linear time.
00:05:13.448 - 00:05:14.100, Speaker B: Okay?
00:05:14.630 - 00:05:37.040, Speaker A: So at a high level, that's what we're going to be doing. Any questions about that review? Okay, so let me remind you what a good path is. So it's sort of by definition what allows us to increase our matching size without screwing up the invariance.
00:05:37.040 - 00:05:48.828, Speaker A: And this is sort of the picture you should have in mind. If the pink edge is in the matching, then the blue edge could be a good path. So first of all, both of the two endpoints of the path should be currently unmatched.
00:05:48.924 - 00:05:49.520, Speaker B: Okay?
00:05:49.670 - 00:05:52.116, Speaker A: Secondly, they should be on different sides of the graph.
00:05:52.188 - 00:05:52.376, Speaker B: Okay?
00:05:52.398 - 00:06:03.896, Speaker A: So the starting point is on the left side, the ending point is on the right side. Both are unmatched. So if you think about it, that means the length of this path has to be odd, right? Because it keeps bouncing back and forth between the left and the right hand side.
00:06:03.896 - 00:06:14.444, Speaker A: If it ends up on the right hand side, it has an OD number of hops. The second requirement is that it's alternating. So again the edges alternate being out of or in the matching capital M.
00:06:14.444 - 00:06:32.284, Speaker A: And because remember, both the endpoints are unmatched, definitely that first hop and the last hop are not going to be in the matching. So if you have a nine hop path, you're going to have five edges out of the matching and then four edges in the matching. Finally, all of the edges of the path should be tight, should have zero reduced costs.
00:06:32.284 - 00:06:42.076, Speaker A: What's the motivation there? Well, we want all of the edges on this path to be eligible for membership in the matching. And remember, we have this constraint. Then anybody in the matching better be a tight edge.
00:06:42.208 - 00:06:42.890, Speaker B: Okay?
00:06:43.660 - 00:07:02.920, Speaker A: So if you ever find a good path, then you do that first part of the while loop. So you take the x or the symmetric difference of your current matching and this path. So if you had like this nine hot path, you'd be kicking out four edges, the ones that were already in the matching and in the path.
00:07:02.920 - 00:07:13.452, Speaker A: And then you'd be putting back in five edges the ones in the path which are not in the matching. That would give you a matching with size, strictly bigger, strictly more edges. And you don't screw up the invariants.
00:07:13.452 - 00:07:23.604, Speaker A: Why not? Well, you haven't changed the prices, so you haven't changed the reduced costs. So invariant number one is fine. You've put some new edges in the matching so that could screw up invariant number two.
00:07:23.604 - 00:07:28.132, Speaker A: But by definition all the edges in the path are tight, so that invariant is fine as well.
00:07:28.266 - 00:07:28.950, Speaker B: Okay.
00:07:30.920 - 00:07:53.064, Speaker A: So what I want to talk about, and this is the first kind of new stuff compared to Tuesday is how do we find a good path or how do we do a search for one? Okay, so any questions before I talk about that? So I'm going to show you a linear time algorithm that strives to find a good path and if it fails, it's going to find what we were calling a good set on Tuesday.
00:07:53.192 - 00:07:53.870, Speaker B: Okay?
00:07:56.800 - 00:08:00.584, Speaker A: Clear. All right. And don't be scared.
00:08:00.584 - 00:08:15.860, Speaker A: This is really just going to be like BFS breath for search with a tiny twist, okay? In fact, before I actually describe the algorithm formally, let's just kind of follow our nose. If we just go through an example, I think it'll be obvious what the algorithm has to be. So imagine the following.
00:08:15.860 - 00:08:42.184, Speaker A: So imagine we're at some point in our algorithm, so we have current prices P, and we have a current matching M. So what I'm showing here is the tight edges only, okay? Only the edges with zero reduced cost. The graph may have many more edges.
00:08:42.184 - 00:08:47.160, Speaker A: It might have lots of edges that have strictly positive reduced cost. This is the graph only of the tight edges.
00:08:47.240 - 00:08:47.868, Speaker B: Okay?
00:08:48.034 - 00:09:04.656, Speaker A: So remember, the graph with all of its edges we're assuming has a perfect matching, but that certainly doesn't imply that you have a perfect matching just consisting of tight edges. So like this one clearly does not have a perfect matching because node four is isolated. But this is totally something that might come up in the middle of the algorithm.
00:09:04.656 - 00:09:37.820, Speaker A: Okay, a subgraph of tight edges that looks like this. And maybe this is our current matching, say, of size of three edges matching six of the eight vertices. Okay, so using this as a starting point, we now want to say, okay, how would we search for a good path? Okay, so just to know where we're going, is there a good path? In this example it there isn't.
00:09:37.820 - 00:09:58.352, Speaker A: And sort of one way you could see that is if there were a good path, then you could augment this to a matching with four edges, which would be a perfect matching. But obviously there's no perfect matching just of the tight edges because vertex four doesn't even have any edges incident to it. Okay, so just we're going to be doing a search for a good path.
00:09:58.352 - 00:10:10.740, Speaker A: Clearly this search is going to fail. So we're interested in what happens when this algorithm fails. Okay, so let's just follow our nodes.
00:10:10.740 - 00:10:25.310, Speaker A: What would be kind of like probably the first thing you might try about finding a good path? Well, you know, the two endpoints should be unmatched. Okay, so just pick, say, the first unmatched node from capital V. Okay, so let's say we start here, different color.
00:10:25.310 - 00:10:34.752, Speaker A: So three is unmatched and we're going to do BFS with a twist from node three.
00:10:34.886 - 00:10:35.570, Speaker B: Okay?
00:10:36.180 - 00:10:46.580, Speaker A: The reason we need a twist is because of this condition too. We want to make sure that we find a path which is alternating, so that'll motivate the twist. But first we just start with BFS.
00:10:46.580 - 00:10:54.984, Speaker A: So we just say, okay, and again, we're only searching on the tight edges, remember, because we want a path which is all tight edges. So we only search on the tight edges. We start at three.
00:10:54.984 - 00:10:57.656, Speaker A: We say, who are three's neighbors? Let's go explore them.
00:10:57.838 - 00:10:58.570, Speaker B: Okay.
00:11:00.380 - 00:11:21.148, Speaker A: So level one of the BFS tree, so that's going to be level zero. Level one is just the neighbors of the starting point. Now, what if either two or seven was unmatched? What could we say? We'd be done, right? We'd have a good path.
00:11:21.148 - 00:11:31.116, Speaker A: We'd have a one hop good path, right? So its endpoints are free. The edge is not in the matching, and it's a tight edge because we're only searching on tight edges.
00:11:31.228 - 00:11:31.984, Speaker B: Okay?
00:11:32.182 - 00:11:38.880, Speaker A: So if two or seven is unmatched, we can just stop and return the good path. Remember, we're happy when we find a good path.
00:11:38.960 - 00:11:39.590, Speaker B: Okay?
00:11:40.200 - 00:11:48.232, Speaker A: Now in this example, that's not true, okay? Neither two nor seven is unmatched. They're both matched. So here's where the twist goes.
00:11:48.232 - 00:12:08.832, Speaker A: And again, this is to ensure the alternating property. So in every even level, what we do is we only put the nodes there that were matched to the nodes on the previous level, the vertices in the previous level. So what we're going to do, so because two is matched to one, we're going to put a one here.
00:12:08.832 - 00:12:12.450, Speaker A: And because seven is matched to eight, we're going to put eight here.
00:12:13.380 - 00:12:14.130, Speaker B: Okay?
00:12:16.580 - 00:12:20.610, Speaker A: So conspicuous in its absence is node six.
00:12:21.220 - 00:12:22.064, Speaker B: Okay?
00:12:22.262 - 00:12:36.336, Speaker A: So if I was doing normal, BFS, six would also be a child of two. Okay, why am I not doing that? Because then I would have a path in the tree which was not alternating, where both of the edges in a row were out of the matching. And we want alternation.
00:12:36.336 - 00:12:55.230, Speaker A: Okay, so we do a BFS level, then we just look at who they're matched to, if anybody, we put those at the next level and then we switch back to BFS again. So we just interleave those two different steps. All right, so here well, we get stuck at eight, right? Eight's only neighbor is seven, and we've already seen seven.
00:12:55.230 - 00:13:06.080, Speaker A: One, we're not stuck. So one has two neighbors, two and five, we've already seen two, but we haven't seen five yet. So we put five on level three of the tree.
00:13:06.080 - 00:13:20.890, Speaker A: Now let me ask you, suppose that five was unmatched. That would also be great. We'd also be done, actually, if you think about it.
00:13:20.890 - 00:13:34.938, Speaker A: So it wasn't just like if a level one node was unmatched, we're good. If this level three node is unmatched, we're also good. Why? Because the path in the search tree from that node back to the root is a good path.
00:13:35.114 - 00:13:35.550, Speaker B: Okay?
00:13:35.620 - 00:13:50.598, Speaker A: So by construction, the two endpoints are both unmatched. By construction of the tree, every path in the tree, alternates edges out of it in the matching, and again, the tree only searches tight edges. So if five was unmatched, we'd be done.
00:13:50.598 - 00:13:59.990, Speaker A: We'd have a good path, we'd stop. Now, five is not unmatched, it's matched namely to six. And now at this point we're stuck.
00:13:59.990 - 00:14:11.190, Speaker A: Okay, six's neighbors are two and five, and we've already seen both of them. Okay, so this is where BFS would just sort of stop. Okay, so we failed, we didn't find a good path.
00:14:11.270 - 00:14:11.900, Speaker B: Okay.
00:14:14.210 - 00:14:35.086, Speaker A: So what's the algorithm more formally? So you just grow a tree. Level zero is, let's say, the first unmatched vertex of the left hand side, and then we're going to do something different, as you've seen on the even levels and the OD levels. So for the OD levels.
00:14:35.086 - 00:15:01.100, Speaker A: So the way we create an OD level from the previous even level is just by BFS. So level I for I OD, just do BFS again amongst the tight edges only from level I minus one. Okay? And again, as usual, if you've already seen some vertex in a previous level, you don't include it again, like in normal breadth for search.
00:15:01.100 - 00:15:04.880, Speaker A: And then in an even level.
00:15:08.530 - 00:15:08.846, Speaker B: What.
00:15:08.868 - 00:15:25.310, Speaker A: You put there are the vertices that are matched to vertices in level I minus one. Okay, and then you stop if you ever find unmatched vertex.
00:15:28.370 - 00:15:45.546, Speaker B: And it so.
00:15:45.568 - 00:15:54.518, Speaker A: The algorithm makes sense. Feel like you could code that up in Python easily enough. So before I erase this, couple of announcements.
00:15:54.518 - 00:16:09.060, Speaker A: So exercise set number three, I just posted right before class problem set number one, as you know, is due Tuesday at midnight and you might want to review the course homepage for the late day policy. So there are late days, but they're pretty limited. So have a look at the official course policy.
00:16:09.060 - 00:16:32.662, Speaker A: All right, so is everyone with me so far? So we have this now subroutine that may or may not find a good path. We actually trace through an example where it doesn't. We agree if it ever ends, if it finds it on matched vertex, we have a good path, we're done.
00:16:32.662 - 00:16:42.470, Speaker A: Okay, no problem. So what I have to do now is I have to show if this algorithm gets stuck, stuck, the subroutine gets stuck, we can extract from it some other way of making progress.
00:16:42.630 - 00:16:43.340, Speaker B: Okay?
00:16:43.870 - 00:16:58.340, Speaker A: Everyone clear up to that? Okay, so let's think about in general. So here we have a particular search tree where this algorithm got stuck. Let's think about what a stuck search tree looks like in general.
00:16:58.340 - 00:17:14.082, Speaker A: So here's an important point. It, and this is where we actually use the assumption that it's a bipartite graph. Remember, I promised that has to be important somewhere.
00:17:14.082 - 00:17:43.230, Speaker A: So it comes up in a subtle point right here. So here's the claim. I claim that if you think about any matched edge, okay, so any pink edge either, it's not in your search tree at all, meaning you didn't find either one of the endpoints or both of the endpoints are found and in your search tree.
00:17:43.230 - 00:17:59.794, Speaker A: And moreover, the two endpoints of that matched edge have to appear on consecutive levels, with the first level being an OD level. And you can see that up here, right? The matched edges go from level one to two and from level three to four. The claim is that's going to be true.
00:17:59.794 - 00:18:10.280, Speaker A: Generally, any matched edge with one endpoint in the tree actually has both endpoints in the tree, the first vertex at an OD level and then the other vertex at the next level, which is going to be even.
00:18:23.650 - 00:18:28.320, Speaker B: It. Okay.
00:18:31.170 - 00:19:00.018, Speaker A: So why is this true? Well, so assume you have a matched edge and you hit one of its endpoints. Okay, so consider the first level where you find one of the endpoints of this matched edge. So the big question here is why can't you encounter both endpoints of a matched edge at exactly the same time in the same level? So for example, what if two and seven were actually matched up in that upper right corner? Then this would be false.
00:19:00.018 - 00:19:22.202, Speaker A: Then it wouldn't be true that the endpoints are in consecutive levels, it'd be on the same level. So how can we be sure that there isn't some matched edge between two and seven? Good, so that would give us a triangle, right? If there was an edge between two and seven, we'd have a triangle that's an OD cycle, and bipartite graphs can't have OD cycles.
00:19:22.346 - 00:19:23.086, Speaker B: Okay?
00:19:23.268 - 00:19:28.540, Speaker A: And that's true in general. So if you ever encountered both endpoints of a matched edge in the same level.
