00:00:01.850 - 00:00:02.382, Speaker A: Okay. Hello.
00:00:02.436 - 00:00:09.550, Speaker B: I'm Andrew Lewis Pye. I'm from the London School of Economics. I'm going to be talking about a joint work with Tim Roughgarden from Columbia University.
00:00:09.550 - 00:00:31.000, Speaker B: The topic of our presentation is blockchain security and the way in which security is impacted by basic design choices such as whether the protocol is proof of work or proof of stake. We're focused here on permissionless blockchains. So those are blockchains like bitcoin that anybody can participate in with as many identities as they like.
00:00:31.000 - 00:01:01.690, Speaker B: If you're running a permissionless blockchain, then you have to be able to deal with civil attacks. That means you have to be able to deal with a malicious user, an adversary who tries to cause trouble by running a large number of identities. Generally the way this is done is by having a user's participation be dictated not by the number of identities they use, but rather by their access to some scarce resource.
00:01:01.690 - 00:01:23.890, Speaker B: So if you're running a proof of work protocol, then a user's level of participation will be dictated by their hash rate. If you're running a proof of state protocol, then it'll be your currency balance that matters. If it's a proof of space, protocol is your access to memory capacity, so you have some method of user selection which is dictated by access to a scarce resource.
00:01:26.720 - 00:01:27.084, Speaker A: Okay?
00:01:27.122 - 00:01:56.810, Speaker B: And then the basic question is this are there fundamental ways in which the method of user selection impacts security? So it can be prove, for example, that proof of state protocols can be secure against unbounded network partitions, while proof of work protocols never can be. In fact, we'll see later on, yes we can, that's something we can prove. So here we're going to be focusing on a particular aspect of security, which is the production of what we'll call certificates.
00:01:56.810 - 00:02:17.810, Speaker B: So certificates are sets of messages whose existence provides incontrovertible proof of block confirmation. So Bitcoin doesn't produce certificates because the existence of a certain chain doesn't prove that it couldn't exist. A different and longer incompatible chain.
00:02:17.810 - 00:02:38.810, Speaker B: On the other hand, most BFT style protocols, if implemented in the permissionless setting using proof of stake, they will produce certificates. Algorand, for example. Algorand produces certificates in Algorand, if you see a chain of blocks with all the relevant votes for the blocks in that chain, then you can know that the blocks in that chain are confirmed.
00:02:38.810 - 00:03:11.690, Speaker B: Okay, but is this really a matter of BFT versus longest chain or is there something deeper going on here in terms of the method of user selection? So that's what we're going to be analyzing and we'll see a precise definition of certificates later on. If you want a simple take home headline from this talk, it's this. So, proof of work protocols can't produce certificates, while any proof of state protocol either produces certificates or could be recalibrated tweaks to do so.
00:03:11.690 - 00:03:20.540, Speaker B: What we really mean there is, I say if you take any proof of state protocol if you choose the right notion of confirmation, then it will produce certificates.
00:03:25.100 - 00:03:25.464, Speaker A: Okay?
00:03:25.502 - 00:03:44.690, Speaker B: So that's the simple summary. So what I'm going to do the rest of the talk is to give four results that make those ideas precise. And in fact, the results we give are going to be more general that they're more general in the sense that they don't just apply to proof of work or proof of stake protocols, they apply to permissionless blockchain protocols in a more general sense.
00:03:44.690 - 00:04:09.570, Speaker B: Obviously, if we're going to get theoretical impossibility results of the type I'm going to be talking about in this presentation, then we need a general framework for talking about permissionless blockchain protocols. There are established frameworks for talking about proof of work protocols, but those frameworks don't suffice to simultaneously deal with proof of stake protocols.
00:04:10.150 - 00:04:10.562, Speaker A: Okay?
00:04:10.616 - 00:04:38.590, Speaker B: So in order to get these results, the first thing we need to do is to establish a general framework for talking about proof of work, proof of stake, proof of space, protocols, and so on. And then once we have such a framework, we can give theoretical results establishing the extent to which today's protocols have to look the way they are, give the security guarantees they achieve. Some of those results might already be intuitively known by the community and some won't be.
00:04:38.590 - 00:05:09.502, Speaker B: Either way, we'd argue that formal analysis of this type are relevant to the community for several reasons. So first of all, accurate intuitions of the community can be formally validated with the necessary assumptions clearly spelled out and we'll see at least one example of that later on. Inaccurate intuitions can be exposed as such unexplored areas of the protocol design space can naturally rise to the surface.
00:05:09.502 - 00:05:28.390, Speaker B: We'll see an example of that later on in terms of the recalibration of protocols to produce certificates. Then lastly, new definitions can enhance our language for crispy describing, comparing competing solutions. Again, we'll see an example of that in terms of our new notion certificates.
00:05:28.390 - 00:05:56.004, Speaker B: Yeah, it goes without saying that formal analysis of this kind of played a really pivotal role in developing theory for permissioned because there's consensus protocols. Now we want to do the same for the permissionless case. Okay, so let's go on to discuss, to briefly sketch the framework.
00:05:56.004 - 00:06:10.540, Speaker B: So I'm going to skip the details, I guess to give the basic essentials. So we consider protocols which run relative to a resource pool. So this is a function which signs a resource balance to each user over the protocol execution.
00:06:10.540 - 00:06:46.856, Speaker B: In its most general form, the resource pool is a function R that assigns a resource balance there's some real number to each user at each time slot and possibly relative to a given message state, where you can think of the message state as being the set of messages that's been received by a given user. So the resource pool just assigns a resource balance to each user at each time slot, possibly relative to a given message state. So if we're dealing with a Proof of Work protocol here, obviously the resource balance will be a user's hash rate and this will be independent of the message state.
00:06:46.856 - 00:07:18.790, Speaker B: You just have a hash rate of each time slot. If we're talking about a proof of State protocol, then the resource balance could depend both on the time slot and the message state, okay? Users make requests to broadcast messages such as lots of transactions, and the chance of these requests working will generally depend upon a user's resource balance.
00:07:21.130 - 00:07:21.494, Speaker A: Okay?
00:07:21.532 - 00:07:32.026, Speaker B: And then there are various other differences with standard Proof of Work protocol frameworks, which I won't go into here. Here, though, is a definition which is important for everything else that's coming up.
00:07:32.208 - 00:07:32.614, Speaker A: Okay?
00:07:32.672 - 00:07:53.730, Speaker B: We say we work in the sized setting. If the resource pool is given as a protocol input, we know the resource pool from the start of the Protocol execution. So now with Proof of State Protocols, we do know in advance how the resource balance of a user depends upon the set of messages on set of confirmed blocks.
00:07:53.730 - 00:08:13.370, Speaker B: But we know that from the start of the Protocol execution. So this means we're working in the size setting. That doesn't mean we know in advance which users are going to have lots of currency during the course of the protocol execution because we don't know in advance which blocks of transactions are going to be confirmed.
00:08:13.370 - 00:08:27.118, Speaker B: But we do know what the resource pool is as a function from the start of the Protocol execution. And that means we're working in the size setting with Proof of Work protocols. We don't know in advance how a user's hash rate will vary over time.
00:08:27.118 - 00:08:29.630, Speaker B: So there we're working in the unsized setting.
00:08:35.010 - 00:08:35.374, Speaker A: Okay?
00:08:35.412 - 00:08:53.110, Speaker B: And then the protocol is just a set of instructions to be carried out by non faulty processors. Let me also consider a notion of confirmation which takes any set of received messages. Generally these messages could be of any form, but some of them might be blocks of transactions.
00:08:53.110 - 00:08:57.282, Speaker B: Takes any set of messages and returns a set of confirmed blocks.
00:08:57.346 - 00:08:57.574, Speaker A: Okay?
00:08:57.612 - 00:09:24.830, Speaker B: So the notion of confirmation is the function that tells you when blocks are confirmed. Obviously with Bitcoin, this function takes any set of blocks and it returns those blocks which are at least k deep in the longest chain amongst that set of blocks. So note here that generally different users will have different M's, they might receive different sets of messages, so different blocks might look confirmed from the point of view of different users.
00:09:27.330 - 00:09:27.694, Speaker A: Okay?
00:09:27.732 - 00:09:46.950, Speaker B: And it's important here that we think of the notion of confirmation as at least potentially being separate from the Protocol. So the Protocol tells you how to interact in sending messages such as blocks of transactions, how to go about building chains of blocks and so on. And then the notion of confirmation is separate from that and tells you when blocks are confirmed.
00:09:46.950 - 00:09:59.190, Speaker B: So with Bitcoin, for example, you could consider a block confirmed when it's followed by six blocks. You could consider it confirmed when it's followed by ten blocks. But that doesn't change how you go about building the blockchain.
00:09:59.190 - 00:10:27.600, Speaker B: So the notion of confirmation is separate in some sense, then an input to the protocol, one of the inputs is the security parameter epsilon, which you can think of as bounding, the probability of there being an error as you're carrying out the protocol. We say a protocol is secure if the probability of two incompatible blocks being confirmed is less than epsilon.
00:10:31.910 - 00:10:32.274, Speaker A: Okay?
00:10:32.312 - 00:10:42.440, Speaker B: And then here's the definition of liveness. I won't give the precise definition here, it's just a rough definition. So a protocol is live if the number of confirmed blocks can be relied on to grow over time.
00:10:42.440 - 00:10:58.692, Speaker B: Okay, so next then, let's see the definition of certificates before I give the actual definition. Let's give a definition which is two weeks, first of all. So help popularly explain the actual one.
00:10:58.692 - 00:11:40.100, Speaker B: Okay, so if B block B is confirmed respect to a set of messages, mi of B is in C of M, then we'll call M a subjective certificate for B. The problem with that as a notion of certificates is that if M is a subjective certificate for B, although it might exist some larger set m prime such that B doesn't look confirmed respect to M prime. Right? So we're in Bitcoin here, m could be a chain of blocks, m prime could be a larger set that includes that chain, but also includes a different longer and incompatible chain.
00:11:40.100 - 00:12:05.740, Speaker B: So the M being broadcast isn't proof that B is confirmed with respect to any user. Okay, so then here's the actual definition. We'll say a protocol with notion of confirmation C produces certificates if the following holes are probability greater one minus epsilon when the protocol is run with security parameter epsilon.
00:12:05.740 - 00:12:34.100, Speaker B: So two users will never confirm conflicting blocks, whatever subsets of the total set of broadcasted messages they receive. Okay, so definition saying that from amongst all the broadcast messages, you can't pull out two sets of messages that make incompatible blocks that look confirmed. So basically the idea is if a protocol produces certificates, then subjective certificates constitute proof of confirmation.
00:12:34.100 - 00:13:00.700, Speaker B: So Algorand is an example of a protocol which produces certificates. It designs that it's unlikely that two incompatible blocks will ever be reduced together with appropriate committee signatures verifying confirmation for each. Okay, and this is definition pretty clearly false protocols, so long as they're using a longest chain notion of confirmation, as long as some incompatible chains are being produced.
00:13:00.700 - 00:13:24.390, Speaker B: Okay, and then we're almost ready to state our results. Now we just need a couple more basic definitions. So there are a couple of different assumptions we can make in terms of the reliability of communication, and these two different possibilities here are just completely standard versions from the distributed computing literature.
00:13:24.390 - 00:13:47.610, Speaker B: First of all, in a synchronous setting, we assume there's a known upper bound on how long messages take to be delivered. That's simple. In the partially synchronous setting, we allow then that there might be unbounded network partitions, during which time messages may take any amount of time to be delivered.
00:13:47.610 - 00:13:59.010, Speaker B: This upper bound doesn't always apply, but we only require liveness during periods of synchrony, during sufficiently long periods of synchrony, so I e. When message delivery is reliable.
00:14:05.250 - 00:14:05.614, Speaker A: Okay?
00:14:05.652 - 00:14:20.318, Speaker B: So now let's get into results. So first of all, let's consider the partially synchronous setting, right? So as I just said, that's the setting in which there may be unbounded network partitions. There are two results I want to mention here in this setting.
00:14:20.318 - 00:14:44.502, Speaker B: So the first is this one, right? Protocols can't be both live and secure in the partially synchronous and unsized setting. So if we're working with something like a proof of work protocol, where the resource pool is not given as a protocol input, that is not possible for a blockchain protocol to function in the partially synchronous setting. Now, it's intuitively obvious here that bitcoin isn't secure in a partially synchronous setting.
00:14:44.502 - 00:15:09.720, Speaker B: So if the two sides of a partition continue to grow, obviously the shorter one will be thrown out once the partition ends. The point here is this isn't specific to bitcoin or even to longest chain protocols, right? This is driven fundamentally by the proof of work approach to civil resistance. Okay, so proof of work protocols can't function in the partially synchronous setting.
00:15:09.720 - 00:15:31.430, Speaker B: So far we haven't talked about certificates, though, so why they're relevant? Well, certificates are certainly a sufficient condition for security in the partially synchronous setting, and they're the method by which Algorand Tendermint and all the protocols we know that work in the partially synchronous setting, and that's how they achieve security. What we care about, though, is the security rather than the certificate. Certificates are just a means to an end.
00:15:31.430 - 00:16:06.016, Speaker B: So the question here is, are we missing an important part of the design space? Is there some other way to achieve security in the partially singular setting? Okay, so next theorem here says no, certificates are not only sufficient for security in the partially synchronous setting, they're also necessary. So our new definition, the definition of certificates, allows us to succinctly state what protocols that are secure in the partially synchronous setting, what they have to look like. Okay, so just summing up the two previous results then.
00:16:06.016 - 00:16:13.060, Speaker B: So basically, unsized won't work in the partially synchronous setting, and all size protocols that work, they'll produce certificates.
00:16:17.900 - 00:16:18.360, Speaker A: Okay?
00:16:18.430 - 00:16:40.480, Speaker B: So now let's move on to the synchronous settings is where message delivery is reliable, where we have this known upper bound on how long messages take to be delivered. So we know that bitcoin doesn't produce certificates, but it is secure in the synchronous setting. So the next question is, can proof of work protocols produce certificates in this setting in the synchronous setting.
00:16:40.480 - 00:17:01.168, Speaker B: And the next two theorems say that proof of work protocols can't produce certificates, but modulo certain basic assumptions. All proof of state protocols can be made to produce certificates by choosing the right notion of confirmation. So here's the first, the last two theorems.
00:17:01.168 - 00:17:18.680, Speaker B: So consider the synchronous and unsigned setting. If a protocol is live, then in the presence of a nontrivial adversary, it does not produce certificates. The adversary being nontrivial here just means that it has some non zero resource balance so that it can actually contribute to the protocol.
00:17:20.380 - 00:17:20.744, Speaker A: Okay?
00:17:20.782 - 00:17:25.420, Speaker B: So in particular, then, proof of work protocols do not produce certificates.
00:17:29.150 - 00:17:29.562, Speaker A: Okay?
00:17:29.616 - 00:17:42.510, Speaker B: And then here's our final theorem, which I just state informally here. So consider a permissionless blockchain protocol that operates in the synchronous and size settings. Then there exists a recalibration of the protocol which reduces certificates.
00:17:42.510 - 00:17:50.770, Speaker B: So a protocol being a recalibration of another Hay, basically just means that it's the same protocol, but we use it a different notion of confirmation.
00:17:52.550 - 00:17:52.914, Speaker A: Okay?
00:17:52.952 - 00:18:12.330, Speaker B: So in particular, if we consider proof of stake protocols in the synchronous setting, then we know that some recalibration of the protocol will produce certificates. So even if we consider a longest chain protocol like Snow White, we can adjust the notion of confirmation away from being a longest chain rule so that the protocol produces certificates.
00:18:13.310 - 00:18:13.674, Speaker A: Okay?
00:18:13.712 - 00:18:40.220, Speaker B: So it's worth pointing out here with that example, our research program has led us naturally to explore a nonstandard part of the blockchain design space here in terms of the longest chain protocols that can be made to produce certificates. And this is a good thing, right, because we want to understand the design space as generally as possible, not just through a handful of specific protocols. Okay, so I will stop there, and thanks very much for listening.
