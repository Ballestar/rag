00:00:00.410 - 00:00:57.950, Speaker A: Hi, everyone, and welcome to lecture seven of this lecture series on foundations of blockchains. The goal for today's lecture is to discuss the tendermint protocol, both how it works and what guarantees it offers. Tendermint and its properties are interesting to us for two reasons. So, first of all, just from an academic or scientific perspective, this protocol will prove a matching positive result matching in terms of the amount of fault tolerance matching the impossibility result we saw in lecture six for achieving consensus in the partially synchronous model. We saw last lecture that it's hopeless, you're toast if 33% of the Byzantine nodes or more are Byzantine and tendermint will really show, it'll be an explicit solution for the problem as long as the fraction of Byzantine nodes is less than 33%. Secondly, from a practical perspective, I mean, this protocol is really used. Tendermint is a real blockchain protocol.
00:00:57.950 - 00:01:40.294, Speaker A: So maybe you've heard of, say, cosmos or maybe you've heard of, say, Terra. Those are examples of a couple of blockchains that are really based on this consensus protocol. Okay, so let me just remind you of the context. So the basic model that we're working in to analyze consensus protocol is the partially synchronous model and what it is we want to achieve in the partially synchronous model. So remember, partial synchrony, it's a sweet spot between the synchronous model we studied in lectures two and three and the Asynchronous model we studied in lectures four and five. We liked the synchronous model because it had strong positive results, like the dole of strong protocol. We didn't like it because it just made this very unrealistic assumption about guaranteed message delivery.
00:01:40.294 - 00:02:32.730, Speaker A: The Asynchronous model, we liked how weak the assumptions were, so that any positive result, any protocol that actually works in the Asynchronous model would automatically be interesting and impressive. But unfortunately, we sort of threw out the baby with the bathwater, and there were no good, at least no good deterministic consensus protocols, for example, for Byzantine agreement in the Asynchronous model. That was the famous FLP impossibility result. So that led us to our third and I believe, final model of communication that we're going to study partial synchrony. And the goal here is to really think about how a protocol operates both when under attack and under normal operating conditions. And we're going to identify normal operating conditions with the synchronous model. So there will be some operi known bound delta on the maximum message delay that applies when you're in normal operating conditions, when you're in the synchronous mode.
00:02:32.730 - 00:03:11.574, Speaker A: But then there'll also be an Asynchronous mode, which represents sort of being attacked. And we want to then sort of study how protocols sort of respond and recover after an attack. And so we're studying sort of the minimal model that captures all of that. So it's just going to be like a two phase model. So we start with an Asynchronous phase. So we sort of start under attack in effects, but attacks should eventually end. And so we capture that with this notion of a Global Stabilization Time or GST, so that's this transition time, which is unknown operate has to happen sometime, but we have no idea when a transition time from when we switch from the Asynchronous model to the synchronous model.
00:03:11.574 - 00:04:21.210, Speaker A: And the first goal we'd like is that we'd like to perform very well, like, say, have all of the consistency and liveness properties, safety and liveness properties that we want when you're in normal operating mode, including if an attack just recently completed. So you'd like to get back to normal operation very quickly once the network gets back to normal. Secondly, during an attack, during the Asynchronous phase, we know from the FLP impossibility result, you have to give up on at least one of safety or liveness, but you'd obviously like to give up on as little as possible. And at the moment we're focusing on potentially giving up on liveness during the Asynchronous phase and always retaining safety. So another way of saying this, and let me now sort of specialize the discussion to the consensus problem most relevant to blockchains, namely state machine replication. So what we'd like to see happen is we have our safety condition, which is consistency, that should hold always. Again, consistency means that no two different nodes disagree on the relative order of any pair of transactions that they've committed to their local histories, whereas liveness, which says that submitted transactions do eventually get added to everybody's local histories, liveness should just hold eventually.
00:04:21.210 - 00:05:20.286, Speaker A: Well, eventually here basically means after this Global Stabilization time, after GST. And one of the key things we learned in lecture six is there's a fundamental limit on when we can actually achieve these goals. So consistency always and liveness eventually. Specifically, we showed that if the number of Byzantine nodes is more than a third of the overall total, then in fact no protocol, no matter how clever, it doesn't matter, no protocol is going to be able to satisfy both of these goals. And as we mentioned at the time, if you look at the argument of that proof, it doesn't matter whether there's a trusted setup or not. So this impossibility result holds even under a PKI assumption. So this is a sense in which the partially synchronous model really is more strictly more demanding than the synchronous model, right? So in the synchronous model with PKI, we've got the Doloph strong protocol which can tolerate consolidate state machine replication and tolerate any number of Byzantine nodes.
00:05:20.286 - 00:06:29.516, Speaker A: Whereas in the partially synchronous case we have this threshold of 33%. And again, when you see the number 33%, for example, on the amount of sort of malicious stake, if you see that phrase in various sort of blockchain protocol white papers or discussions, it's literally this impossibility result. Literally, this is the 33% that everybody's talking about. So with this context, we can now properly appreciate the guarantees that this tendermint protocol is going to offer. And again, while the very biggest blockchains, bitcoin and ethereum, they don't use a consensus protocol that resembles tendermint, they use longest chain consensus, which we'll start talking about next lecture in lecture eight. On the other hand, there really are sort of top 20 protocols that are based on tendermint, with sort of Cosmos and Terra being two notable examples. And more generally, if someone wants to sort of build a new layer one solution and doesn't really want to solve consensus themselves, they really just kind of want to use someone else's consensus solution in a plug and play manner.
00:06:29.516 - 00:07:04.056, Speaker A: Tendermint is definitely one of the most popular options. So that's one of the reasons why you see it fairly frequently with sort of up and coming blockchain projects. So let me just say a little bit about the history here. So Tendermint, it is a 21st century protocol. It really was designed with blockchains in mind, unlike all the stuff from the 20th century. But the way the protocol works very strongly resembles some of those protocols from the 1980s. So, for example, we talked about the paper by Dwark Lynch and Stockmeyer that introduced the partially synchronous model.
00:07:04.056 - 00:07:59.260, Speaker A: And as part of that paper, they showed not just sort of impossibility results like the one we talked about last time, but they also gave matching positive results. And so in particular, in that paper, they were studying Byzantine agreement, single shot consensus. But whatever, they gave a protocol that actually does have this fault tolerance that has sort of guaranteed agreement and sort of eventual validity and termination in the partially synchronous model, as long as little F is less than N over three. And tendermint really looks quite a bit like sort of taking a protocol like that from the 1980s and iterating it over and over again. It is not exactly that, let me be clear, but it is not a million miles away from that either. So let's call it a 21st century blockchain protocol that takes very strong inspiration from classical consensus protocols from the 1980s. So tendermints had several iterations.
00:07:59.260 - 00:08:44.164, Speaker A: I think the first one might have been 2014 or so developed by J Kwan. It sort of stabilized roughly around 2018, I believe. And so that's the stabilized version is the one that I'm going to be covering here. And for the 2018 version of the protocol, the authors are listed as Ethan Buchman, Jquan and Zarko Molozovic. All right, so let's dive into how this protocol works, beginning with a summary of some of the high level ideas. So on this slide, I'll highlight three of the high level ideas that go into Tendermint's design. To be honest, with these distributed protocols, really, the devil tends to be in the details.
00:08:44.164 - 00:09:38.940, Speaker A: So these three ideas may seem reasonably natural to you once I describe them, but there's many, many different ways you could turn those ideas into a precisely defined protocol. And to be honest, most of the ways you would try to do it would wind up being buggy like you'd either not satisfy consistency or you'd not satisfy liveness. So we're going to have to write down the protocol quite precisely and we'll do that on the next slide. And then we're also going to want to supplement that description with rather precise proofs of why it's consistent and why it satisfies liveness. So there are certain kinds of problems, including problems in arising computer science where intuition tends to be sort of a good guide. The design of distributed protocols is not one of those cases. So you really should be suspicious of intuition that you have about a distributed protocol if someone's claiming it has certain properties, you really should be demanding a formal proof that it satisfies those properties.
00:09:38.940 - 00:10:41.808, Speaker A: Now happily tendermint, we actually really can provide those proofs as we'll do a little bit later in the lecture. Okay, so high level idea number one is basically to reduce the multi shot consensus problem we care about to state machine replication to reduce it to single shot consensus. So we're basically going to iterate over and over again a protocol that's going to look quite a bit like a Byzantine agreement protocol. And now that we're sort of really talking specifically about blockchain protocols and not more abstractly about consensus, let's stop beating around the bush and let's just sort of admit that the output of each of these Byzantine agreement type computations should be a block, a block that's going to belong to a blockchain. And here by block I just mean some batch of transactions which has been sequenced in some way. Now a node running the tenement protocol, it's only going to be worrying about one of the single shock consensus instances at a time. It's only going to be worried, for example, maybe the node has already figured out what blocks one through eight are.
00:10:41.808 - 00:11:33.998, Speaker A: It's now going to be single mindedly focused on figuring out what's block number nine. So the current block that a node is trying to figure out, we're going to call that a height. Now remember, we're working in the partially synchronous model, which means there will be this asynchronous phase where we may have massive message delays. And so that means that some nodes may make progress much more rapidly than other nodes if they're getting many more of their messages than the other nodes are. So it's totally possible that I'm trying to figure out what block number nine is and someone else has already raced ahead and already knows what block nine is and block ten and is working on block number eleven. So their height would be eleven, my height would be nine. Now when nodes communicate to each other in tendermint, every single message will include, will be annotated with what block that node is trying to figure out.
00:11:33.998 - 00:12:17.306, Speaker A: So if I'm trying to figure out block number nine, every message I send to anybody will sort of report the fact that I'm trying to figure out block number nine. Now, each node will be single mindedly focused on the block it's currently stuck on. So if I'm working on number nine, I'm going to ignore any messages I receive from other nodes about block number seven, which I already figured out, and I'm going to ignore any messages from other nodes about block number eleven, which I don't want to worry about yet. There's one tiny, tiny exception to that, which we'll get to in a second. But basically, if I'm working on block nine, I listen to messages that are also about block nine and I ignore everything else. So in effect, the different single shot consensus instances really don't interact with each other at all. All right, so to explain idea number two, let's zoom into a particular height.
00:12:17.306 - 00:13:26.670, Speaker A: Okay, so let's just think about the nodes that are working on block number nine and exchanging messages about block number nine. Now again, there's going to be this asynchronous phase where messages might be delayed arbitrarily. And so these nodes can try to reach agreement on what block number nine is supposed to be, but they might get stymied by the fact that lots of messages get delayed a lot. And so that means they're going to have to sort of try, try again. After all, eventually Global Stabilization Time GST is going to roll around and then hopefully these repeated attempts to figure out block number nine at that point, if not earlier, at that point, hopefully it should succeed. Now, each attempt to come to agreement on say, block number nine, the attempt is going to resemble pretty strongly some of the Byzantine broadcast protocols that we talked about in previous lectures. So there's going to be a notion of a proposer and that's going to rotate over the rounds, and then a proposer is going to propose a block, and then there's going to be voting on whether or not that should be block number nine or whether it should be something else instead.
00:13:26.670 - 00:14:17.870, Speaker A: Now, as usual, nodes may well be Byzantine, so the proposer for a given round might well be Byzantine and sort of mess everything up. And so that's why we want to use sort of rotating leaders to make sure that reasonably frequently we have an honest node at least kicking off the process of trying to reach agreement. All right, so the final idea, which is sort of where the cleverness lies. Nodes are going to vote on a block that was proposed in one of these attempts. But interestingly, we're going to have not just one round of voting, one stage of voting, but we'll have two stages of voting. Okay, so let me try to sort of explain why there's two stages of voting. So in particular why one stage of voting might not be enough and why maybe if it's like very cleverly designed two stages of voting might in fact be enough.
00:14:17.870 - 00:15:18.524, Speaker A: So it's fine in a consensus protocol to say, oh, take a vote and then make some decision. But what's complicated is different nodes might see different outcomes of this vote and there's really two different forces that could result in different nodes, even different honest nodes just having opposite opinions about whether the vote was a success or a failure. So force number one is that some of the nodes are Byzantine and so they might be deliberately sending inconsistent information out to the honest nodes, right? So they vote for block B one to this set of nodes, they vote for this other block B two to this other set of nodes. So that already causes different honest nodes to have different vote counts. The second thing is that at least in the asynchronous phase, you also have this adversary controlling the message delivery. So maybe even it's an honest node sending out sort of identical votes to everybody, but the message delivery adversary delays half of them and so the recipients don't actually see the honest vote, whereas the other half do see the vote. So those are two different reasons.
00:15:18.524 - 00:16:02.696, Speaker A: Honest nodes will see different outcomes of a voting procedure. So that's the problem, right? So you got to make sure you don't have something like a consistency violation when some nodes think a vote succeeded and some nodes think a vote failed. And if you only have one stage of voting, there's only this binary outcome from a node's perspective, like either a success or it was a failure. If it was a success, presumably you're then going to actually adopt that as block number nine. You're going to write that block, you're going to add that block to your local history because what else do you want? Like the vote succeeded. Meanwhile, if you're one of the nodes where the vote failed, it's hard to imagine what you can do other than just restart the process from the beginning. Move on.
00:16:02.696 - 00:16:50.604, Speaker A: New leader. Maybe you used to have a Byzantine leader, now you have an honest leader and you'll do better. Or maybe you used to be before GST and now next round you'll be after GST, so again you'll do better. But like a no vote sort of says you should sort of start the whole process over. But then of course the problem is if half of the nodes view the vote as a success and they wind up committing a particular block B one to the local histories and the other nodes sort of restart and then possibly with a new block and then agree on that block B two, and then commit that, then you're going to have a consistency violation. So then you're actually going to have different sets of honest nodes disagreeing on what block number nine is supposed to be. So that's the problem with one stage of voting, right? So you only have sort of two possible outcomes, different nodes will see different outcomes and so therefore they won't know what to do.
00:16:50.604 - 00:17:45.596, Speaker A: They won't know whether to sort of restart or to commit. So with two stages of voting, the good news is now, instead of two possible outcomes, you have three possible outcomes, right? So one outcome is that both stages are viewed as a success by a node. Like, there's lots of agreement on some block, there's lots of sort of signatures attesting that's the block that people want. So if both voting stages succeed, again, what else do you want? Right, presumably this is the point at which you're going to say, okay, this really is block number nine. I'm going to add this to my local history. Outcome number two is that even the first sort of stage of voting fails from your perspective, and then you're like, oh, maybe we have a Byzantine leader, maybe we're sort of pre GST, I don't know, but let's sort of start over again and hopefully we'll do better next time. But now you also have this sort of intermediate outcome where a node might see the first stage succeed and then the second stage fail.
00:17:45.596 - 00:18:33.768, Speaker A: And so this gives the node the ability to hedge its bets between whether it's supposed to restart and whether it's supposed to commit. The winner of the first stage of voting to its local history. Basically, it sort of can be in this intermediate state where it's pretty sure what the eventual bloc is going to be and it's sort of locked on a particular block, but at the same time, confronted with overwhelming evidence to the contrary, in the future, it would eventually be willing to switch its block. And so that's the reason for two stages of voting. It's not clear two should be enough, but I hope you concede that it gives the protocol more flexibility by having this third intermediate outcome between the restart and the commit outcomes. So these, in my opinion, are the three main high level ideas that go into the tendermint protocol's design. Again, the devil is in the details.
00:18:33.768 - 00:18:53.440, Speaker A: You really shouldn't feel like you understand how this protocol works until we carefully walk through the pseudocode, which we will do in the next video. But hopefully this gets you oriented. You at least know the overall plan of attack. Okay, but now it's time to actually get into those details. That's what we'll do in the next video. I'll see you there. Bye.
