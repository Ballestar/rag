00:00:00.570 - 00:00:54.160, Speaker A: Hi everyone, and welcome to lecture nine. In this lecture series on foundations of blockchains. In lecture nine, we will finally, for the first time, be leaving the safe confines of the permissioned setting that we've been studying in lectures two through eight in our study of consensus protocols. And it is the permissionless setting which is actually the most relevant one for the most famous public blockchains that you've heard about bitcoin and Ethereum and more. Now, a fundamental issue that comes up in the permissionless setting is something known as civil attacks, which we'll talk about, which necessitates some kind of civil resistance way of sampling nodes to participate in a consensus protocol. And so in this lecture, in lecture nine, we will be talking about one approach to civil resistance, the one that's used in bitcoin and it was used in the original version of the Ethereum protocol, namely proof of work. So let's get started.
00:00:54.160 - 00:02:19.554, Speaker A: So before I start talking about the permissionless setting, let me just sort of remind you what I mean by the permissioned setting that we've been working on in the last large number of lectures. The basic assumption in the permissioned model is that when you deploy the protocol, you know exactly who are the nodes that are going to be running your protocol. And when computer scientists first started studying consensus protocols back in the 1980s, way before blockchains were a gleam in anyone's eye back then for the kinds of applications they had in mind, the permissioned setting made total sense, right? They're thinking about maybe like a big company like IBM trying to sort of replicate a database to have very high uptime. And so maybe instead of putting a database just on one server, you put it on like seven servers that you then deploy all over the world so that if one or two of them fail, you can still sort of serve database queries from the remaining replicas. Then of course, you need a consensus protocol to make sure all the replicas of the database are consistent with each other. In this kind of application, it's totally fine to assume that you know all of the nodes in advance, right? IBM is just going to go out, it's going to buy seven servers, it's going to know those seven servers, and it can deploy some consensus algorithm on each of those servers with each server having full knowledge of the other six servers that it's going to be cooperating with. So that's the permissioned setting, sort of even stronger version of the permission setting is to also make the PKI assumption.
00:02:19.554 - 00:02:51.518, Speaker A: PKI for public key infrastructure. So that's something we've talked about a lot over the recent lectures. For example, that was part of our we used the PKI assumption when we designed the tendermint protocol back in lecture seven. So remember, PKI means it really means two things. So one, it means you're sort of assuming that cryptography exists, like there exists secure digital signature schemes. So let's take that on faith and leave that aside. The other thing you're assuming in the PKI assumption is that somehow all of the nodes know not just the names of the other nodes, but also know the public keys of the other nodes.
00:02:51.518 - 00:03:51.910, Speaker A: So as a node, you know your own private key and then all of the nodes know the corresponding public key in advance of the deployment of the protocol. And in the permission setting, you really don't worry about how this might have happened, how this public key distribution was made, right? In our sort of running example, it's kind of obvious, right? IBM could just create the seven public key private key pairs, give each of the seven machines their own private key, and give each of those nodes a list of the seven public keys of all of the nodes. But in general, in the permission setting, you're just like somehow it became common knowledge to everybody who everybody's public keys are. And then you just use that assumption in the design and analysis of your consensus protocol. Assumptions of this form, remember, are called trusted setup assumptions. In a blockchain context, you also hear sort of different names for what I'm calling the permissions setting. So you might hear about sort of private blockchains that, again, typically means kind of a known set of nodes, sort of that everybody's aware of, identified up front.
00:03:51.910 - 00:04:47.666, Speaker A: You might also hear about a proof of authority blockchain, which really means basically the same thing as what I'm saying here is the permissioned setting. So permissioned consensus protocols are certainly extremely important. On the other hand, we need to recognize that the most famous public blockchains like, say, Bitcoin and Ethereum operate in a very different scenario, which we're going to be calling the permissionless setting. So probably the best way to get sort of a firsthand feel for this permissionless setting is to sort of pause this video right now and go look into what's required to actually become a node that helps run the Bitcoin protocol. If you do that, if you look into it, you'll see that it's actually like a really lightweight process. Really. You just kind of download some software and install it on your commodity laptop, commodity desktop, set it running and before you know it, it's actually going to be one of those nodes sort of participating in running Bitcoin's consensus protocol.
00:04:47.666 - 00:05:37.778, Speaker A: No registration required, you don't need anyone's permission. It's okay that you're joining 13 years after the Bitcoin protocol eventually sort of went up and running. So it's just like a super different setting than these sort of classic 1980s applications of consensus that we've mentioned. So way back in lecture number one, when I encouraged you to think about a blockchain as kind of a computer that lives in the sky, that has no owner, that has no operator, this is sort of what I kind of literally meant by saying no owner or no operator. It's like rather I meant that there were lots, hopefully thousands of operators, nodes that are sort of coordinating through a consensus protocol to collectively simulate a kind of virtual machine that sits on top of the internet. And moreover, you could become one of these nodes yourself at any time if you want it. So that is sort of the dream of permissionless consensus, the dream of this ownerless computer in the sky.
00:05:37.778 - 00:06:32.886, Speaker A: And that in my opinion, is possibly the most radical, most audacious sort of conceit in the original Bitcoin protocol, the idea that you might actually be able to have a consensus protocol with provable guarantees in this crazy permissionless setting where you have no idea who's even running your protocol. All right, so let's be a little bit more precise about what we mean by the permissionless setting. I'm not going to belabor it, but I do want to sort of specify some details here. So first of all, as suggested by the Bitcoin example, there's just going to be sort of an unknown and possibly ever changing set of nodes that are running the consensus protocol at any given moment in time. And if you start thinking about it, this would seem to already throw like a really big wrench into the consensus protocols we've talked about thus far. Like, for example, we've had lots of protocols where we do a round robin rotation through the nodes, for example, as leaders to make block proposals. And notice round robin does not make sense in the permissionless setting.
00:06:32.886 - 00:07:27.014, Speaker A: You have no idea which nodes are running your protocol. How on earth could you do a round robin order amongst them? Second, right, if nodes aren't even aware of which other nodes are running the protocol, I guess sort of point to point communication doesn't really make sense. So we're going to be thinking about nodes communicating with each other and clients communicating with nodes through sort of gossip protocols, if you want to think about it that way, or broadcast channels, if you like. So in particular clients, and here I mean clients in the sense of state machine replication protocols. So clients are not necessarily running the consensus protocol, they're not necessarily running a node, but they're creating transactions that they're then submitting to nodes for inclusion in the blockchain in all of the nodes local histories. So the clients, they're the ones submitting transactions to nodes and they're just going to do that sort of via gossip or via broadcast. And similarly, as we've seen, the nodes generally want to send messages to each other as well, just to make sure that they stay in sync.
00:07:27.014 - 00:08:25.642, Speaker A: And so we're going to again assume that happens not through point to point communication, but rather at least for the honest nodes, it's going to just happen through a broadcast. So I've written down this constraint for the honest nodes, right? So for the Byzantine nodes, you don't really want to make any assumptions about their communication patterns. So Byzantine nodes, if they want, we're going to allow them in our analysis to use point to point communication. In particular, like if a Byzantine node wants to sort of send conflicting information to two different honest nodes, we're going to go ahead and allow the adversary to do that. Now, this assumption, this may not bother you that much, because actually, if you think back to the consensus protocols we've been discussing, like, say, the tendermint protocol in lecture number seven, in part because we weren't optimizing efficiency, just we were keeping things simple. But for the consistency and liveness guarantees, it really was not important that we had the power to do point to point communication. Like in Tendermint, for example, when a node had something to say, like it just formed a new quorum certificate, it would just go ahead and broadcast that to all of the other nodes.
00:08:25.642 - 00:09:06.026, Speaker A: So the protocols we've been designing kind of respect this constraint anyways. So a couple of other comments. So first of all, it is important that both clients and the nodes running the protocol sort of are aware of which broadcast channel they should be sending messages to and listening in on. So you can think of that as sort of part of the trusted setup assumption. So like, along with the protocol code, there's also kind of correct instructions about how to join, for example, the gossip protocol that everybody's using to share information. There's also, of course the question of how do those gossip protocols actually work? And that's a really interesting question. There's really interesting computer science and computer networking that goes into that.
00:09:06.026 - 00:09:36.606, Speaker A: As I said in lecture one, that's kind of a layer zero question. So we're taking layer zero kind of the existence of the internet and sort of reliable communication protocols on top of it. We're taking that on faith in this entire lecture series, right? We're sort of starting with kind of consensus and working our way up from there. So I'm not saying it's trivial at all. In fact, there's still really nice sort of open research questions of how to have super reliable and robust kind of gossip protocols and peer to peer networks. On top of which you can build blockchains, super interesting research direction. It's just not part of our scope in this lecture series.
00:09:36.606 - 00:10:36.934, Speaker A: So we're going to take it on faith as usual that these broadcast channels exist, that they're reliable and that all of the nodes begin the protocol knowing sort of where to send messages and where to listen for messages. So permissionless, consensus, I mean, this is really a key part of the sort of vision of Blockchains, of having this kind of ownerless, no central operator, virtual computer that kind of lives in the sky. So it's super crucial to the vision. It's also not at all clear that this should be possible, that there should exist consensus protocols with provable consistency and liveness guarantees under any kind of reasonable conditions in this very demanding permissionless setting. But this lecture series wouldn't exist if there were not in fact permissionless consensus protocols with provable guarantees. There are we're going to see a few, but we are going to need some additional ideas. And to start down on that road, I mean, let's just begin with kind of like the most obvious idea.
00:10:36.934 - 00:11:20.562, Speaker A: We already have some really nice permissioned consensus protocols. Maybe we can just adapt one of those really easily to the permissionless setting. Or even better, maybe these sort of computer science giants of the 20th century, maybe they inadvertently solved permissionless consensus even though they weren't thinking about blockchains. Well, it turns out that actually those permissioned protocols from the 20th century really are permissioned in the sense that they don't sort of immediately lend themselves to the permissionless setting. They'll still be very useful for us, as we'll see. But if you try to extend them in the most straightforward way, you immediately encounter obstacles in the permissionless setting. So let's just sort of talk through what some of those initial obstacles are and let's talk about it for both of the two main genres of consensus protocols that we've discussed.
00:11:20.562 - 00:12:07.022, Speaker A: BFT type consensus protocols with tendermint being a canonical example and then longest chain consensus protocols that we were talking about last lecture in lecture eight. Let's start with BFT type consensus protocols, like with tendermint from lecture number seven being a canonical example. And you might remember from that protocol's description that a really important part of it was sort of stages of voting. So there was this notion of rounds. Each round would be sort of an attempt to sort of commit to a new block, to honest nodes, local histories. But nodes, they'd proceed cautiously, right? They'd wait until they heard a supermajority of support for a block before committing it. And actually, if you remember, they actually needed to hear a supermajority of support twice in voting stage one and voting stage two before they would go and commit to a block.
00:12:07.022 - 00:12:34.494, Speaker A: So like if there were 100 nodes, you'd wait and made sure that you hear that 67 nodes were kind of in favor of some action before taking the action. But I hope then the issue seems pretty clear, right? Like you were waiting for 67 votes because you knew you were one of 100 nodes. How did you know that? You knew that because you were in the permission setting. Permissionless setting, right, is right there. We have no idea what the node set is. We have no idea what n the number of nodes is. So a node has no idea how many votes it should be waiting for.
00:12:34.494 - 00:13:17.062, Speaker A: It has no idea what is the amount of votes that would constitute a supermajority. So that should seem like a pretty immediate and big obstacle to adapting the BFT type protocols to the permissionless setting. What about longest chain consensus? Like we were discussing in lecture number eight. So remember, longest chain consensus, it proceeds in rounds and each round has a single leader who can unilaterally propose a new block along with its predecessor. And so a crucial part of longest chain consensus is sort of generating this sequence of leaders with one leader per round. In last lecture, in lecture eight, we talked about two ways of generating a leader sequence. One was round robin and the other was selecting a leader uniformly at random from the set of all of the nodes.
00:13:17.062 - 00:14:02.246, Speaker A: But neither of these immediately make sense in the permissionless setting when you don't know the node set or even the number of nodes. You can't round robin through a set of nodes where you don't know who they are. And you can't even choose a node uniformly at random without knowing the denominator the probability, right? If there's 100 nodes you should choose a node with 1% probability. If there's 1000 nodes, you should be choosing any given node with 0.1% probability. So it's not clear how you would implement either of those approaches to generating a sequence of leaders in the permissionless setting. So it turns out there's a common idea that's going to allow us to overcome both of the obstacles and turn both BFT type consensus protocols and longest chain consensus into different flavors of permissionless consensus protocols.
00:14:02.246 - 00:14:39.762, Speaker A: And that idea is going to be random sampling. So if you're thinking to yourself some combination of like random sampling, from which distribution exactly? Or how are you going to randomly sample from a set of nodes, you don't know. Good questions. But for the moment, let's assume we actually could solve this problem. Let's assume we actually did have a reasonable way of sampling a node from the set of all nodes running the protocol. Here's how we would use that random sampling procedure to extend BFT type and longest chain consensus to the permissionless setting. Now, in BFT type consensus, like in the Tendermint protocol, block production is really kind of a cooperative activity.
00:14:39.762 - 00:15:13.520, Speaker A: It is true that in Tendermint, for example, a single node winds up proposing the block that's going to be voted upon in a given round. But that block only gets confirmed if a supermajority of nodes go along with it. So it's really a sort of group effort by lots of nodes to produce blocks and BFT type protocols. And so that means we're going to be randomly sampling not just one node but a whole committee of nodes. Maybe. Think of it as like, I don't know, a set of 100 nodes from the space of say, 10,000 nodes that are running the protocol. We're going to select down 100 nodes who are then going to be running some kind of BFD type protocol amongst themselves.
00:15:13.520 - 00:16:04.446, Speaker A: So this idea is actually used in the wild quite a bit, especially in proof of stake blockchains. We'll talk about that a bit more in lecture number twelve. Some of the parameter choices vary from blockchain to blockchain. Like you could ask how big is the committee size? That's going to be different projects have made different choices around the committee size. You can also ask, how frequently do you do this sampling? So at one extreme you could do it, for example, like every round of tendermint, you could elect a new random committee, or you could elect a random committee that sort of stays in place for a longer period of time, hours or even days. In any case, that's how a random sampling procedure allows you to kind of reduce, in some sense, permissionless consensus to permission to consensus, right? You randomly sample this sort of committee of nodes who are then going to act as if they were in a permissioned protocol. Now, in Longest Chain consensus, it's even easier to see how to do this.
00:16:04.446 - 00:17:06.286, Speaker A: And in fact, we basically talked about this quite a bit in lecture eight. Already. In longest chain consensus, block production is not a cooperative activity, it's an authoritarian activity, right? So whichever node is elected the leader of the round unilaterally proposes a block and that block's predecessor it is not going to be waiting for votes from any of the other nodes. So for Longest Chain, literally, we would just randomly sample a single node at each round and then that would be the leader the block proposer of that round. All right, so I hope that convinces you that if somehow we magically had a way of randomly sampling from this unknown set of nodes, we can then really start imagining how to turn our permission to protocols into permissionless ones. But there's still this question of like, how on earth are you going to do random sampling when you don't even know sort of what the nodes are? And there's a couple of different challenges there, but one really important one I want to highlight right away is something known as civil attacks. To explain, it might be simplest to just think about a Kludgy way you might try to do some version of random sampling.
00:17:06.286 - 00:17:58.818, Speaker A: You could imagine having your consensus protocol and then also just sort of posting kind of publicly kind of a list where anybody can sort of register their node using their public key. So this is going to be the sort of running list of nodes that are running the protocol identified by the public key. And then you can imagine just choosing a public key in the corresponding node uniformly at random from the list of public keys that have been added to your list so far. And probably you already see the problem, right, it's all fine and good to have this list of public keys, but you still have no idea what's the mapping between public keys to nodes. And in particular, unlike in the permissioned setting, where you are guaranteed a one to one correspondence between distinct public keys and distinct nodes in the permissionless setting. For all you know, a single node one machine has generated, I don't know, a thousand different public key, private key pairs. Right? That's trivial to do.
00:17:58.818 - 00:19:00.330, Speaker A: Just type in Sshgen at a Unix prompt and you'll get such a pair and it's running 1000 different copies of whatever the consensus protocol is on that one node masquerading as 1000 different nodes. You'll never be able to tell just from this list of public keys. And so that means I may be one out of 100 nodes running the protocol, physical machines running the protocol. But by generating basically costlessly tons of key pairs for myself, I can make sure that the probability that I get selected, like one of my identities hosted on my node that I get selected is sort of as close to 100% as I want. So in general, in computer science, when someone talks about a civil attack, they usually mean the manipulation of some protocol through the creation of lots of identities. So many sort of part basically a single party masquerading as many civil attacks show up in lots of parts of computer science, not just in blockchains. But I hope it's sort of very obvious why civil attacks are sort of a real danger for any kind of random sampling approach to permissionless consensus.
00:19:00.330 - 00:19:53.290, Speaker A: You might be wondering about the name sort of civil. That comes from the title of a book back from the 1970s which was about a woman who had what at that time people referred to as multiple personality disorder. And so that's why sort of this idea of having multiple IDs all corresponding to the same entity, that's what gave it the name a civil attack. So you may hear, in addition to civil attack, you may hear the idea of civil resistant. So that refers to a system where it can't be manipulated through the creation of sybils or alternatively sybil proof would be a synonym for that. Now, the fact that generating multiple IDs is costless in a permissionless setting, that doesn't mean that random sampling is doomed to fail. It certainly means this really naive approach we're asking people to register by public key that is doomed to fail, but conceivably there could be a civil resistant way of doing random sampling.
00:19:53.290 - 00:20:41.910, Speaker A: And so here when I use the word civil proof, I just mean you cannot manipulate the probability with which you are selected as a leader through the creation of multiple IDs. The probability that you get selected is independent of the number of IDs that you're sort of acting under. Not at all obvious that such a civil proof way of doing random selection should even exist. But some very clever people have actually come up with sybil proof ways of randomly selecting nodes in the permissionless setting. So there's multiple solutions to it. We're going to focus on the two that at least in the year 2022 are the most dominant, namely proof of work, which is the topic of this lecture. And then the other one will be proof of stake, which we'll study at length in lecture number twelve.
00:20:41.910 - 00:21:29.700, Speaker A: So we'll go into it in a lot of detail, but if you just want sort of a one sentence summary of each of these two solutions in proof of work, the idea is to randomly sample a node with probability proportional to their computational power. So the probability is going to be proportional to a quantity that is independent of how many IDs they have. It just basically depends on how powerful their computer is proof of stake, or instead. So here we're going to be thinking specifically about blockchains that have a native cryptocurrency, as many of them do, and we're going to be thinking about nodes being selected with probability proportional to their stake, I. E. The amount of the native currency that they own. And again, so the probability is again going to be proportional to a quantity which does not depend on the number of IDs, just depends on the overall amount of currency that's owned by that particular node.
00:21:29.700 - 00:22:03.824, Speaker A: So we've talked at length about two genres of consensus protocols, right? BFT type consensus and longest chain type consensus. Longest chain consensus. We're going to be talking about two types of civil resistant random sampling mechanisms proof of work and proof of stake. And as it turns out, there's a pretty natural association of these approaches to civil resistance with the two approaches to consensus that we've talked about thus far. It's not a perfect correspondence, but it's pretty good. And this is something that actually really has only become clear to the research community over the last couple of years. So starting with proof of work.
00:22:03.824 - 00:22:40.824, Speaker A: So in a blockchain context, proof of work was first brought in by Nakamoto in the invention of the Bitcoin protocol. And there in Bitcoin, proof of work was paired with longest chain consensus. And what we'll see by the very end of this lecture is that that is not an accident, that proof of work actually just does not work well in conjunction with BFT type consensus algorithms. Nakamoto, given the use of proof of work, Nakamoto in some sense really needed to invent a completely different approach to consensus, namely longest chain consensus. All right, so proof of work, really the story is pretty clear. Basically, if you're going to use proof of work, couple it with longest chain consensus. Do not couple it with BFT type consensus.
00:22:40.824 - 00:23:28.056, Speaker A: I'm not aware of any projects in production that sort of really do couple proof of work with BFT type consensus. And we'll see at the end of this lecture kind of a theorem that really explains formally why now proof of stake, it's a little more nuanced. So in particular, there are major blockchain projects that have been running successfully in the wild for years of both types. There exists proof of stake blockchains that use BFD type consensus. There exists other proof of stake blockchains that use longest chain type consensus. And early days actually more proof of stake blockchains were sort of leaning the longest chain route. But over the last few years, the sense among people building new blockchain protocols is that really BFT type consensus is a much better match for proof of stake than longest chain.
00:23:28.056 - 00:24:10.440, Speaker A: So we're definitely seeing strong movement toward coupling proof of stake with BFT type consensus. That said, when we get to lecture number twelve, we will talk about both. So how to design a proof of stake longest chain protocol as well as BFT type protocols. I do think you'll walk away from that lecture with a sense of why the trend is toward BFT type consensus. I mean, we'll sort of see the hard way that getting longest chain consensus, right, with proof of stake civil resistance, a lot of issues come up. And it's not to say that it's impossible to handle them, but it just gets pretty messy, pretty fast doing a proof of stake longest chain protocol, whereas it's somehow a little more straightforward doing BFT type consensus. But again, that's all sort of forward pointed to lecture number twelve where we talk about that stuff in much more depth.
00:24:10.440 - 00:24:57.204, Speaker A: So there's a very common point of confusion that I want to address. Maybe this is already obvious from the discussion on the last slide, but at the risk of belaboring the point, I still want to talk a little bit more about it, which is that there's really two kind of very distinct concepts that you need to keep clear in your mind, right? So about blockchains one is about the consensus protocol that's used. So we've talked about two types of examples, longest chain consensus and BFT type consensus. And you can talk about consensus protocols in a permissioned or a permissionless setting. Both make sense. And then the second concept, which is really quite different, is a civil resistance mechanism. So proof of work and proof of stake being two prominent examples of approaches to civil resistance.
00:24:57.204 - 00:25:27.100, Speaker A: Generally, you do not talk about civil resistance in the permissioned setting, right? Because there you operate assume that you kind of know who everyone is. You sort of assume away civils just in the definition of the permissioned setting. So civil resistance, you're always talking about the permissionless setting pretty much consensus. You could be talking about either. And really they're completely logically independent concepts. And I'm spelling all this out because it's a very common point of confusion actually in the blockchain world. Here's another way to think about the distinction.
00:25:27.100 - 00:26:18.854, Speaker A: So the consensus protocol part of a blockchain, fundamentally what it's doing is deciding amongst blocks that might have been proposed at various times in the blockchain history, deciding which of the blocks that have been proposed are actually the ones that count, which ones are the ones committed to nodes, local histories, and in what order. So BFT tech consensus or longest chain consensus are. Two ways of making this decision and the way they make that decision is different. Longest chain consensus. Basically, a block is considered committed if it's sort of sufficiently deep on the longest chain, remember we had that security parameter k, which specifies exactly how deep it is. Before you regard a block as finalized BFD consensus. Rather, you're sort of collecting votes and quorum certificates.
00:26:18.854 - 00:27:22.202, Speaker A: So a block there is considered finalized if it is accompanied by a stage two quorum certificate. Okay? So they work very differently, but both fundamentally are deciding among the proposed blocks which are the ones that matter, which are the ones that are actually committed and in what order. All right, so the consensus algorithm, that's really to decide which are the blocks that matter. And that's a decision that obviously any consensus protocol has to make, whether it's permissioned or permissionless a civil resistance mechanism, it's really sort of addressing a different question, which is who has the privilege of proposing these blocks in the first place? So technically, we actually had to solve this problem also when we talked about our permissioned consensus protocols. It's just that in the permission setting, especially with a PKI assumption, this problem is kind of so easy to solve, we didn't really think much about it. For example, think about our discussion of BFT type consensus like the tenderman protocol in lecture seven. We did have to sort of declare in that protocol's description exactly who it was who was allowed to vote on a given block.
00:27:22.202 - 00:28:03.254, Speaker A: It's just that the answer was really simple, namely everybody. And it made sense to say everybody because we were in the permissioned setting. The protocol is born knowing who all of the nodes are. Moreover, with the PKI assumption, we can also sort of associate votes with the node that cast that vote through that node's signature. We also in the tenement protocol's description, had to declare who it was, exactly who had the privilege of proposing a block in the first phase of a round. But once again, in the permissioned and PKI setting, this was not a hard question to answer. We have a known set of nodes, like 100 nodes.
00:28:03.254 - 00:28:45.670, Speaker A: We were assuming a global shared clock, so everybody knows what time it is. Rounds had fixed length, so everybody knows what round it is. So if you're in round 117, all the nodes know automatically that node number 17 is the leader of that round. And any block proposer belonging around 117 better be signed by node number 17. Otherwise it's not a valid block proposal in longest chain consensus. Meanwhile, again, that's where we have sort of one leader per round, where the leader can unilaterally propose both a block and the block's predecessor. And there again we could use, for example, the round robin approach, where in round 117, node number 17 would be given the privilege of proposing the block and the predecessor for that particular round.
00:28:45.670 - 00:29:31.506, Speaker A: So to sum up. In all the consensus protocols that we've discussed so far, there really were sort of two different design decisions. Design decision number one being who is it exactly? Who's able to participate in various ways like propose a block or vote on a block. And then decision number two is given the blocks that have been proposed and given the votes that have been cast on blocks, which of the blocks should be considered finalized, should be considered committed to all of the honest nodes, local histories in the permission setting. Because the first of those problems was kind of so simple, we really didn't talk about it. So we sort of mushed it all together. But in the permissionless setting, all of a sudden this question of like, who is it? Who gets to propose or vote on blocks, that starts seeming much more complicated because we do not have at our disposal tools like round robin.
00:29:31.506 - 00:30:30.502, Speaker A: We cannot do round robin if we don't know what the node set is. Similarly, sampling a node uniformly at random, like, what does that mean if we don't know exactly what the node set is? So in the permissionless setting, all of a sudden these two conceptually distinct design decisions that were always there, they were there already in the permission setting. But in the permissionless setting, both of them require nontrivial solutions. All right, so to really hammer home the fact that these are really different parts of the design of a blockchain protocol, let's actually look at the two different types of consensus that we've discussed. The two different types of civil resistance that we've alluded to. And look at the four combinations of how you might pair them together in an attempt to create a permissionless, consensus, protocol. All right, so organize the discussion in terms of a two by two matrix where we label the columns with a choice of consensus protocol, either longest chain or BFT type, and we label the rows with a choice of civil resistance mechanism, either proof of work or proof of stake.
00:30:30.502 - 00:31:12.266, Speaker A: Now, mind you, you could draw a bigger matrix because there are other approaches to consensus beyond these two. There are other approaches to civil resistance beyond these two. But these are currently the two sort of most commonly used paradigms for consensus and for civil resistance in blockchain protocols. So let's just sort of focus on these four possibilities. So in principle, you could have a blockchain protocol of any of these four types. Any of these four combinations, as I alluded to earlier, proof of work goes along particularly well with longest chain. And then BST type consensus seems to go along particularly well with proof of stake.
00:31:12.266 - 00:31:59.966, Speaker A: So the diagonal entries here are the ones that have sort of the most occupants, at least as of this time of recording. But at least in principle, you could do any of the four. So as a concrete example, we could start with the upper left corner and the canonical example of a proof of work longest chain protocol would be the original blockchain protocol, namely bitcoin. So as I've said before, I view these as the two biggest ideas in Nakamoto's White paper and in the bitcoin protocol, the use of longest chain consensus and the use of proof of work for civil resistance. You do sometimes hear that combination of proof of work plus longest chain. So this upper left quadrant, sometimes that's referred to as Nakamoto consensus. In addition to Bitcoin, the original version of Ethereum also was in this quadrant.
00:31:59.966 - 00:32:42.370, Speaker A: It used proof of work, civil resistance and longest chain consensus. Now, you could in principle use proof of work civil resistance as a method of selecting a random committee to then run a BFT type protocol. But that turns out to be a bad idea. And we'll actually see kind of a formal theorem toward the end of this lecture which explains the sense in which it's a bad idea. Basically, the theorem is going to say that if you try to pull off BFT type consensus using proof of work for civil resistance, you're not going to be able to offer even the most sort of rudimentary, minimal liveness guarantees. That's sort of a deal breaker for a blockchain protocol. And so I'm actually unaware of any blockchain protocol that's ever hit production that use this particular combination.
00:32:42.370 - 00:33:28.530, Speaker A: So moving on to the bottom row, the proof of stake row. So, as I said, increasingly it seems that proof of stake blockchains are being paired with BFT type consensus. There's actually a lot of examples of major blockchain protocols that fit in that lower right quadrant. Maybe just to single out one of them, you'd put solana in that quadrant to finish up with the lower left quadrant. There actually are some major blockchain protocols that have been happily humming along for years that combine proof of stake with longest chain consensus cardano being maybe the most notable example. So this two by two matrix, I think is good to keep in mind when you're examining different so called layer one blockchain protocols. Now, not every single layer one is going to fit into these four boxes.
00:33:28.530 - 00:34:14.058, Speaker A: So for example, some layer ones use consensus protocols you wouldn't really classify as either longest chain or BFT type avalanche being a prominent example. And there's also layer ones which use alternative civil resistance mechanisms. So, for example, there's several projects that use storage as the scarce resource rather than computational power or stake, but nonetheless, a majority of layer one blockchain protocols that are out there. You'll be able to sort of quickly sort of pigeonhole into one of these four boxes, really one of these three boxes. So to wrap up the video, this is something to always keep in mind, that these two things are separate. Any permissionless blockchain protocol really has to deal with both of these two problems. They're separate problems, and they're both nontrivial.
00:34:14.058 - 00:34:56.226, Speaker A: So civil resistance how do you, in a reasonable way, select who gets to propose blocks, who gets to vote on blocks, and then consensus given the blocks that have been proposed and the votes that have been cast, which are the blocks that actually matter, which are the ones that are going to get committed. So, for example, a common rookie mistake is you'll hear people say or write, they'll refer to proof of stake consensus. And as we can see from this taxonomy, that actually doesn't type check right. So if you just say proof of stake, it actually leaves unspecified. What is the approach to consensus? It might be longest chain. It might be a BFT type consensus that's going to differ from project to project. So you would say proof of stake civil resistance, not proof of stake consensus.
00:34:56.226 - 00:35:26.374, Speaker A: You would say longest chain consensus or BFT type consensus. So now that you hopefully have a good bird's eye view of the technical challenges that come up in permissionless consensus protocol design, let's drill down on the upper left entry of this matrix. Nakamoto Consensus. Meaning let's see how to use proof of work. Civil resistance to extend longest chain consensus is from a permission setting to a permissionless setting. We'll start getting into the details of that next video. I'll see you there.
00:35:26.374 - 00:35:26.850, Speaker A: Bye.
