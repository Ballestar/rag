00:00:00.490 - 00:00:16.430, Speaker A: Hi everyone and welcome to this video that accompanies section 21.3 of the book Algorithms Illuminated, part four. This section is a brief introduction to magic boxes in comparison to the problem specific algorithms that we've focused on mostly thus far.
00:00:16.430 - 00:00:36.262, Speaker A: Take the last two problems we looked at. For example, we looked at the traveling salesman problem and we developed the dynamic programming based bellman held carp algorithm to solve solve it faster than exhaustive search. Similarly, for the minimum cost Kpath problem, we developed the very clever color coding algorithm to solve that problem faster than exhaustive search.
00:00:36.262 - 00:01:06.458, Speaker A: So bespoke algorithms like those two are deeply satisfying. You really sort of get into the problem, you understand how to exploit the structure of the problem, and you come up with some provably good algorithm and that's great. But at the same time, whenever you're confronted with a new problem, you should always stop and ask yourself is this problem a special case or thinly disguised version of a problem that I already know how to solve? Now, maybe the answer is no it's not, in which case you're justified to proceed to problem specific algorithm development.
00:01:06.458 - 00:01:23.586, Speaker A: Or even if the answer is yes, technically it is a special case of a more general problem. If the algorithms for the more general problem aren't good enough for your application, then again, you've justified solving specifically the problem that you're looking at. Throughout this book series and these video playlists.
00:01:23.586 - 00:01:50.490, Speaker A: We have on the other hand, seen a number of examples where a problem is simply a special case or thinly disguised version of some other problem that we already know how to solve. Maybe the first example that we ever saw was for computing the median to compute the median of array, it suffices to sort the array and return the middle element. Other reductions we saw was we saw that all pair shortest paths reduces to single source shortest paths by invoking a subroutine for the latter once for each choice of a starting vertex.
00:01:50.490 - 00:02:17.510, Speaker A: Or we saw that the longest common subsequence problem is really just a special case of sequence alignment. So reductions of this type from some problem a that you care about to some problem b that you already know how to solve. They transfer computational tractability from B, the problem you already know how to solve to a the problem you want to solve and which reduces to B, the reductions we've been thinking about thus far.
00:02:17.510 - 00:02:45.246, Speaker A: We've always been reducing a problem to some other problem b that we'd already figured out how to solve ourselves like we'd already figured out how to sort quickly. By the time we were invoking a sorting subroutine to compute the median of an array. On the other hand and this is really sort of the full power of a reduction between two problems a reduction from a problem A to a problem B that's useful even if you yourself have never figured out how to solve problem B efficiently, even if you've never coded up an algorithm for it.
00:02:45.246 - 00:03:00.742, Speaker A: As long as somebody hands you a magic box, think of it as like an inscrutable piece of software written by a bunch of super smart people over many years. They hand you a magic box. If the magic box can reliably solve instances of problem B efficiently, you're good to go.
00:03:00.742 - 00:03:25.766, Speaker A: You can solve your problem A efficiently. Just run the reduction invoking the magic box, the subroutine for problem B whenever you need it. So a magic box probably sounds like pure fantasy, akin to a unicorn or the Fountain of Youth.
00:03:25.766 - 00:03:55.490, Speaker A: Could these inscrutable magic boxes really exist? Well, in the next couple of videos I'm going to tell you about two of the closest approximations out there, namely solvers for mixed integer programming and Satisfiability. So when I say solver, I mean basically in practice. What's an inscrutable piece of software? So usually a very sophisticated algorithm which has been very carefully tuned and expertly implemented and is available for you to use as off the shelf software.
00:03:55.490 - 00:04:12.170, Speaker A: There are two genres of solvers I want to tell you about. In the next video, we'll first discuss mixed integer programming solvers, also called MIP solvers. The other type which we'll discuss in the subsequent video are Sat solvers, where here Sat stands for Satisfiability.
00:04:12.170 - 00:04:22.750, Speaker A: So both MIP and Sat are crazy general problems. Both are expressive enough to capture all of the problems that we've studied in this book series as special cases. So they're very general.
00:04:22.750 - 00:04:46.702, Speaker A: But at the same time, several decades worth of engineering effort and ingenuity have been poured into state of the art mixed integer programming and Satisfiability solvers. And so for this reason, despite the generality of the problem that they're solving, MIP and Satsalvers reliably tackle medium sized instances of NP hard problems in a not that crazy amount of time. So the solver performance varies a lot with the problem and a bunch of other factors.
00:04:46.702 - 00:05:15.722, Speaker A: But just to give you a sense, you might reasonably cross your fingers and hope that for a problem that's naturally encoded as a MIP or a Sat problem that inputs with size in the thousands or if you're lucky, even the tens of thousands, you might be able to solve in less than a day or even faster than that. So in some applications, MIP and Sat solvers are unreasonably effective even for large instances even with input sizes in the millions. So my goals in the next two videos are pretty modest.
00:05:15.722 - 00:05:33.486, Speaker A: I am not going to tell you at all about how these MIP and SATS solvers actually work. That would require an entirely separate course. Rather, I want to prepare you to be an educated client of this cutting edge technology of MIP and Satsolvers for those of you that do want to learn more about implementation details.
00:05:33.486 - 00:06:15.390, Speaker A: So what MIP and Satsolvers look like under the hood? Well, it's a pretty complicated topic but to get started, you might want to do a search for Branch and Bound if you want to learn how mixed integer programming solvers work or conflict driven clause learning if you want to look into the newest generation of Satisfiability solvers. So if we're not going to learn how these solvers work, what are we going to learn? Well, the first thing is, honestly, I just want you to know that these pieces of technology exist and are more or less available at your fingertips. Not enough programmers are aware that we have these semi reliable magic boxes called MIP and Satsolvers, which can be incredibly useful for tackling NP hard problems in real applications.
00:06:15.390 - 00:06:36.578, Speaker A: So the second goal is I want to give you a little bit stronger sense for how general the mixed integer programming and Satisfiability problems are. So I want to show you how some natural NP hard problems can be naturally encoded as special cases that these solvers can handle. Finally, we're only going to spend a relatively short amount of time discussing MIP and Sat solvers.
00:06:36.578 - 00:06:58.254, Speaker A: We'll just be barely scratching the surface. But I do want to give you some pointers if you want to dig deeper and learn more either into the implementation side, as we just discussed what to search on Branch and Bound or CdCl solvers, or if you want to actually put these things to use in your own applications. If you're wondering about what software is out there, how should you get started? We'll touch on that in the next couple of videos as well.
00:06:58.254 - 00:07:19.270, Speaker A: Let me conclude just by trying to clarify what might be some mixed messages you feel like you've been getting from these videos so far. So in the opening sequence, we talked about what does NP hardness mean for the algorithm designer, and we said how you need to compromise. You need to either give up on being exact, on being correct, or you need to sacrifice on running time and run an exponential time.
00:07:19.270 - 00:07:42.566, Speaker A: And on the other hand, here I am telling you that in practice we have these semi reliable magic boxes that can solve empty hard problems, mixed integer programming and Satisfiability in particular, which then cover many other problems also as special cases. So how do we reconcile those two things? Well, the magic boxes for MIP and Sat, I wouldn't call them reliable. I would call them only semi reliable.
00:07:42.566 - 00:07:56.686, Speaker A: So if you're applying a MIP or Sat solver to an NP hard problem in your own application, basically you need to keep your fingers crossed and have a Plan B. Plan B could be something like a fast heuristic algorithm. Have a plan B in case the solver does not work out.
00:07:56.686 - 00:08:11.960, Speaker A: And make no mistake, there will be some instances out there, including fairly small ones, that can bring your solver to its knees. You take what whatever you can get with MB hard problems and the semi reliable magic boxes that are MIP and Sat solvers. They're about as good as it gets.
00:08:11.960 - 00:08:22.180, Speaker A: So in the next video, I want to help you be an educated client of the first of these semirelible magic boxes. Solvers for mixed integer programming. I'll see you there.
