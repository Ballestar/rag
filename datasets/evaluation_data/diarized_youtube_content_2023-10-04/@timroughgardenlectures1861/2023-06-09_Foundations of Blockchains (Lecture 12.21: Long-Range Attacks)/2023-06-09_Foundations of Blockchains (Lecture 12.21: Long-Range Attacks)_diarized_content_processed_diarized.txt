00:00:00.490 - 00:00:13.626, Speaker A: So in this video and the next, I want to spend a little time talking about long range attacks. So this is an attack vector that plagues proof of stake blockchain protocols. That actually is not a problem for proof of work protocols.
00:00:13.626 - 00:00:22.830, Speaker A: And it was identified sort of very early on in discussions around proof of stake as one of the additional challenges which had to be addressed in this alternative approach to civil resistance.
00:00:23.570 - 00:00:24.734, Speaker B: So I'm not going to tell you.
00:00:24.772 - 00:00:32.018, Speaker A: What I mean by a long range attack right now. I will tell you later in this video. But let me begin by sort of setting the stage.
00:00:32.018 - 00:00:40.834, Speaker A: Let's actually do a thought experiment. Let's imagine a sort of new node. So a node that wants to join the party of a long running blockchain consensus protocol.
00:00:40.834 - 00:01:05.598, Speaker A: Maybe it's proof of work, maybe it's proof of stake. Let's think through the trust assumptions that that newly arriving node must make in order to be sure that it's correctly syncing up with the blockchain as it's run thus far. So how would a node go about doing this? Well, I guess the first thing you need is a copy of the protocol software, which would include, for example, a description of the genesis block.
00:01:05.598 - 00:01:33.526, Speaker A: So let's just assume that the node's in a position to get a correct version of the protocol and genesis block. So the first reason to make this assumption is just if we didn't make this assumption, what could we say, right, if we had some node that was running some sort of fake maliciously designed version of a blockchain protocol? Obviously there's not many statements you can make about that node's behavior. A second reason is just that in practice this is reasonably palatable.
00:01:33.526 - 00:02:02.658, Speaker A: So for example, if you wanted to sort of spin up a new Ethereum node, maybe you'd go to the main website for the Ethereum Foundation and get software from there. Needless to say, you'd want to make sure you were interacting with the authentic version of the Ethereum Foundation's website and not some fake website that might be giving you malicious software. If you wanted to kind of be a little more paranoid, be a little more confident, you might want to sort of query multiple sources for links to the software and make sure you got the exact same file from all of them.
00:02:02.658 - 00:02:17.378, Speaker A: And only in that event would you then sort of proceed feeling fairly confident that you're running the correct version of the protocol. So let's assume that that's all taken care of, that you've taken all of the necessary precautions. So you have the correct version of the protocol, you have the correct genesis block.
00:02:17.378 - 00:02:51.410, Speaker A: Obviously, that's not enough to join the party, you need to know the current state of the blockchain protocol, which means you need to know what transactions have been processed up to this point. Now, if you had some trusted source, maybe you could just ask them about sort of the latest state of the blockchain protocol. But if you didn't want to make any other trust assumptions, really what you'd want to do is just be told all the transactions that have ever been processed, you could then replay them yourself, starting from the Genesis block and thereby with no additional trust assumptions, recreate the correct current state of the blockchain protocol.
00:02:51.410 - 00:03:11.894, Speaker A: Now of course, if the same, for example, website that you are already trusting to get the protocol code from, if they actually offer you a download of everything that's ever happened, well then it's kind of you're just trusting the exact same source. Now just for additional information. In practice, the Ethereum Foundation website, for example, is not going to store a copy of all of the blocks that have been finalized.
00:03:11.894 - 00:03:32.350, Speaker A: You're generally going to have to go to other potentially less trusted sources for information on past finalized blocks. So maybe it's going to be block explorers, maybe it's going to be sort of node operators you're able to connect with. Or maybe it's going to be third party services that you're going to pay for them to serve you what they claim are the previous blocks finalized by the protocol.
00:03:32.850 - 00:03:34.510, Speaker B: So we already talked about the idea.
00:03:34.580 - 00:03:51.990, Speaker A: Of requesting the same information from multiple different sources and checking that they all match. We talked about that just to make sure you got the correct version of the protocol code. Probably even more important you do something like that when it comes to learning about the previous finalized blocks because generally those are coming from sources which are a little bit harder to authenticate.
00:03:51.990 - 00:04:09.020, Speaker A: So let's say you ask M different sources. So the bigger the M is, the more paranoid you're being. So for example, the case of M equals one, then you're just going to a single source, presumably that's a source that you're just trusting them, that they're going to give you accurate information.
00:04:09.020 - 00:04:23.280, Speaker A: If you're more paranoid, maybe you take M equal to five. You ask five different sources, you're not necessarily going to assume that all of them are going to tell you accurate information, but you're going to tell you that you're going to assume that at least some or many of them give you accurate information.
00:04:24.050 - 00:04:26.210, Speaker B: So now let's think through how exactly.
00:04:26.280 - 00:04:45.590, Speaker A: You might want to compare answers and sort of how much accuracy you need among your M sources to be confident that you actually are aware of the correct blockchain state. Because the interesting thing here is the answer is going to be different for proof of work than for proof of stake blockchains. We're going to need to make a stronger assumption in the proof of stake case.
00:04:45.590 - 00:04:57.126, Speaker A: So as a baseline, let's start with the proof of work case. So let's think about a Nakamoto Consensus protocol, something like Bitcoin. So suppose you ask your five different sources and you just get like five completely different chains.
00:04:57.126 - 00:05:11.438, Speaker A: I mean, they all have the same genesis block. But imagine even those five different chains have nothing to do with each other otherwise. Well, actually, in the proof of work case, you still have a sort of unequivocal criterion by which you can choose which of the five you should believe.
00:05:11.438 - 00:05:37.746, Speaker A: Because remember, in Nakamoto Consensus, the chain that counts is the one that has the largest amount of work. So remember from our discussion back in lecture number nine, specifically the video about difficulty adjustment in Nakamoto Consensus, because blocks have different difficulties, right, the protocol is maintaining a difficulty threshold which sort of rises and falls with the overall amount of hash rate being devoted to the protocol. Because different blocks have different difficulty thresholds.
00:05:37.746 - 00:05:54.682, Speaker A: You really don't want. When you say follow the longest chain, you don't really mean it in the sense of the number of blocks, because a chain with ten blocks with very high difficulty that presumably should count more than a chain of ten blocks with low difficulty. Much more work went into producing the first of those two chains.
00:05:54.682 - 00:06:24.870, Speaker A: So really the longest chain rule is really the sort of heaviest chain rule. Meaning in Nakamoto Consensus, honest nodes always extend the chain that they know about that has the largest amount of work devoted to it for which the largest number of hashes would have been required to create that chain. So this longest chain rule or this heaviest chain rule this also tells you, right, if five different sources come back to you with five completely unrelated chains chains that share the same genesis block but otherwise have nothing to do with each other.
00:06:24.870 - 00:06:40.362, Speaker A: It tells you which of the five you should actually pay attention to, which is just the one with the largest amount of work. So remember, every block is going to be annotated with the difficulty threshold, so you know the expected amount of work that went into each block. So if I give you a chain of blocks, you know the total amount of work that went into that chain.
00:06:40.362 - 00:06:49.200, Speaker A: So you throw out the four chains that have the smallest amount of work and you just pay attention. You just start extending the one of the five with the largest amount of work.
00:06:49.570 - 00:06:51.086, Speaker B: And so what's cool here is you.
00:06:51.108 - 00:07:10.290, Speaker A: Actually need to make very minimal assumptions about the sort of accuracy of your sources. If even one out of those five sources tells you the correct meaning, the currently heaviest chain in the blockchain protocol, you're good to go. You will immediately start trying to extend the chain that you're supposed to be extending.
00:07:10.290 - 00:07:38.400, Speaker A: You will not be tricked by any of the other four fakers that tried to fool you into extending a chain that had less work instead. Now, obviously, if all five of your sources tell you bogus chains, you will be picking one of those five bogus chains to follow. The good news is, if you later hear about some heavier chain, right? If at some point you have an actual honest source that sort of corrects you, then you can immediately know to switch from the chain you had been following previously to the new heavier one that you heard about.
00:07:38.400 - 00:07:52.450, Speaker A: So that's a very nice property of Nakamoto Consensus. Let's now think about a proof of stake blockchain protocol. For concreteness, let's think about a BFT type protocol, like maybe one that's based on tendermint.
00:07:53.190 - 00:07:55.006, Speaker B: Let's make our sort of usual assumption.
00:07:55.038 - 00:08:18.970, Speaker A: That we make for such protocols that more than two thirds of the stake is controlled by nodes that are honestly following the protocol. And then remember kind of the whole point of tendermint and a sort of very conservative quorum certificate based approach to consensus is that you really cannot have consistency violations assuming that two thirds of the participation is honest. So you're really not expecting to kind of ever see any forks in this protocol.
00:08:19.390 - 00:08:20.778, Speaker B: So what that means is that if.
00:08:20.784 - 00:09:12.410, Speaker A: You think about your five sources that you all ask them about their opinion of sort of what are the blocks that have been finalized thus far at a given block height? They're all going to have to tell you the same thing, right? So any of those M sources that reports a block at block height ten, that's finalized, meaning accompanied by a stage two quorum certificate, any other source that reports a block at height ten, it's also going to have to be that exact same block, right? Because we know from the properties of the consensus protocol, you cannot have some separate block at height ten with a stage two quorum certificate, again assuming that at least two thirds of the participation is honest. So thus, unlike a Nakamoto Consensus, when we might get five chains back that have nothing to do with each other other than sharing a genesis block here, we're just going to get a bunch of chains that are all prefixes of each other, right? So maybe one has ten blocks, another has twelve blocks, but the ten block chain has to be the prefix of the first ten blocks of the twelve blockchain.
00:09:12.830 - 00:09:14.426, Speaker B: And so obviously, if that's what your.
00:09:14.448 - 00:09:23.178, Speaker A: Sources report to you, just a bunch of things that are prefixes of each other, obviously you just want to go for the one with maximal information. So the longest of those five chains.
00:09:23.274 - 00:09:25.760, Speaker B: Everything else is just some prefix of that.
00:09:26.370 - 00:09:43.080, Speaker A: So it kind of seems like we're getting the exact same guarantee for proof of stake that we had for proof of work, right? We just need one of the five sources to tell us the sort of correct longest chain. We're not going to be tricked by the other four because they're just prefixes of that longest chain. So we're going to follow the one source that gave us accurate information.
00:09:44.810 - 00:09:45.158, Speaker B: All right?
00:09:45.164 - 00:09:52.554, Speaker A: So that may sound reasonable, but there's still the question is like, well, okay, well, what if you ask five sources and they're not all prefixes of each other.
00:09:52.592 - 00:09:57.126, Speaker B: What if there actually is a fork? And again, for the extreme case, imagine.
00:09:57.158 - 00:10:20.018, Speaker A: That two of your M sources report to you chains that only have the genesis block in common and otherwise are seemingly independent chains of somehow finalized blocks. Now, your first thought is probably, but wait a minute, how would this ever happen? I thought the whole point of tenderman is that you don't have forks, assuming as usual, at least two thirds honest participation. So it's a fine thought, hold that thought.
00:10:20.018 - 00:10:58.366, Speaker A: That's where long range attacks are actually going to come in, which I'll tell you about on the right half of this slide, maybe a follow up point that comes to mind is like, well, all right, even if for some reason this happened, I mean, wouldn't this sort of trigger slashing conditions? Let's assume that it's a proof stake protocol that is using slashing. Again, the canonical reason to slash is because of this kind of consistency violation, right? To have two different finalized blocks, both at block height number nine, it must be that at least a third of the stake voted on both and then that's something you should be able to slash. But actually, let's assume that not only are there these sort of totally independent chains, but also let's assume neither one references the other at all.
00:10:58.366 - 00:11:11.394, Speaker A: And let's assume, for example, neither one includes any evidence of any double signing. And remember, to trigger slashing, you need on chain evidence of whom to slash and why. So let's suppose each of the branches actually doesn't have any such information.
00:11:11.394 - 00:11:22.920, Speaker A: Again, your thought might be like, well, but why would that be true? Again, hold that thought. Once we talk it through long range attacks, you'll see, like, oh no, actually there are circumstances under which this could happen.
00:11:23.370 - 00:11:25.046, Speaker B: So let's assume for the moment that.
00:11:25.068 - 00:11:48.800, Speaker A: This might actually happen. And let's think through how then would you kind of break ties? How would you decide which of your M sources to believe? And it's kind of tricky, right? Sort of the first thought might be, well, maybe we follow the longest chain, meaning the chain with the largest number of blocks. Unfortunately, that's not going to work and neither is any other sort of tiebreaking rule that you're going to think of.
00:11:49.250 - 00:11:50.686, Speaker B: And the reason has to do with.
00:11:50.708 - 00:12:03.986, Speaker A: This costless simulation property of proof of stake blockchain protocols. That's something we last heard about in part three. In particular, when we were talking about proof of stake longest chain type protocols, we talked about like the nothing at stake attack.
00:12:03.986 - 00:12:24.886, Speaker A: But basically we talked about how stake can be reused. So you can try to extend sort of multiple blocks of a blockchain at the same time, whereas Nakamoto Consensus, you cannot do that, right? Every time you hash the hashes with respect to a particular block and a particular predecessor, any given hash cannot be reused. It's sort of committed to exactly one possible block extension.
00:12:24.886 - 00:12:28.170, Speaker A: Stake, unlike work, can be reused.
00:12:28.670 - 00:12:30.506, Speaker B: So the way the costless simulation sort.
00:12:30.528 - 00:12:39.680, Speaker A: Of rears its ugly head here is just that there's nothing really stopping a node from fabricating a long sequence of blocks as some kind of alternative history.
00:12:40.450 - 00:12:42.126, Speaker B: So, for example, if two of your.
00:12:42.148 - 00:13:04.440, Speaker A: Sources come back with competing chains, one has twelve blocks, the other has 13 blocks, it's hard to really think because of this cost of simulation property, it's hard to think of any reason why the link 13 chain should be automatically more legitimate than the link twelve chain. If one of those is by an attacker, it seems like it may well be the link 13 chain, given that there's no computational barrier from creating it.
00:13:04.810 - 00:13:06.934, Speaker B: So this may all seem a little vague, right?
00:13:06.972 - 00:13:25.230, Speaker A: This discussion of like, stake reuse and costless simulation as opposed to proof of work protocols where you can't reuse hashes and simulation is costly. I think it'll be much more concrete after I walk you through the steps of a canonical long range attack, which is what I'm going to do next on the right half of this slot.
00:13:25.650 - 00:13:27.710, Speaker B: And that long range attack will also.
00:13:27.780 - 00:13:37.070, Speaker A: Explain why we might find ourselves in this predicament where we have these forks we have to resolve despite the fact that we're running a BFT style protocol.
00:13:37.490 - 00:13:38.946, Speaker B: So let me talk through kind of.
00:13:38.968 - 00:13:54.950, Speaker A: The most extreme form of a long range attack that I can think of. I'm doing this just because I think it makes the key points as clear as possible as I'm talking through it. I mean, I'm sure you'll notice along the way kind of modified less extreme versions, but that are based on the exact same ideas.
00:13:54.950 - 00:14:07.174, Speaker A: So think about a proof of stake blockchain protocol for concreteness. Let's say a BFD type protocol based on something like tendermint. And suppose it's been running for like a year without incident.
00:14:07.174 - 00:14:32.450, Speaker A: So certainly with no forks, with no consistency violations, we just have this nice long year's worth of blocks. So to describe this attack, let's focus on the initial set of stakers. So the first time that there's actual kind of block production happening and you have a bunch of public keys with stake amounts locked up in some public staking contract, let's let PK one through PKN be that initial collection of public keys.
00:14:33.110 - 00:14:35.186, Speaker B: Now, as usual, we're certainly thinking that.
00:14:35.208 - 00:14:47.400, Speaker A: At least two thirds of the stake is controlled by honest nodes. Honestly, even feel free to assume that 100% of this sort of initial stake is controlled by honest nodes. But now, furthermore, the blockchain has been running for a year.
00:14:47.400 - 00:15:05.354, Speaker A: I want to assume that all of these initial stakers have kind of gotten bored. They want to sort of focus their energies on other things. So they've unstaked their stake, they've taken it out of the staking contract, and let's suppose that they've cashed out by which I mean they've taken that stake, presumably in the blockchain protocol's native currency.
00:15:05.354 - 00:15:18.050, Speaker A: They've taken that cryptocurrency, they've gone to, let's say, a centralized exchange like coinbase or binance. They've exchanged their cryptocurrency for US dollars. They have moved those US dollars into a bank account.
00:15:18.050 - 00:15:27.314, Speaker A: So if these nodes have cashed out in that way, there is no longer any connection this is one year in, there's no longer any connection between the owners of those public keys and anything.
00:15:27.352 - 00:15:30.206, Speaker B: To do with this blockchain protocol, right?
00:15:30.248 - 00:15:42.218, Speaker A: And there's nothing stopping the owners of these public keys from doing this. I mean, there might have been like a cooldown period involved in their stake, but what's that's going to be? It's going to be, what, two weeks? Maybe it's even two months. The blockchain protocol has been running for a year.
00:15:42.218 - 00:15:49.660, Speaker A: So totally possible that they would have unstaked waited through the cooldown period and cashed out by a year in.
00:15:50.110 - 00:15:51.366, Speaker B: Now the attack begins.
00:15:51.398 - 00:16:04.510, Speaker A: In the next step, we're going to assume that the attacker locates whoever it was who owned these public keys, PK one through PKN, and buys from those parties the corresponding private keys.
00:16:05.090 - 00:16:06.398, Speaker B: Now, your first thought might be like.
00:16:06.404 - 00:16:08.434, Speaker A: Why would anyone ever sell their private key?
00:16:08.472 - 00:16:08.626, Speaker B: Right?
00:16:08.648 - 00:16:20.194, Speaker A: You sell your private key, that person basically becomes you and owns all your assets. Well, remember, we're assuming that the owners of these public keys have all cashed out. They literally have no assets left as part of this blockchain protocol.
00:16:20.194 - 00:16:36.780, Speaker A: So what do they need those private keys for? They don't need them for anything. They may as well sell them even potentially for a very nominal price. An alternative version of this attack is like, why bother with paying anybody for their private keys? Why not just hack them? Why not just compromise the private keys and take them over yourself?
00:16:37.630 - 00:16:39.066, Speaker B: This version of the attack is in.
00:16:39.088 - 00:16:57.060, Speaker A: Some ways sort of even worse. So before the attacker had to cajole the owners of these public keys to sell the corresponding private keys to them, and it's hard to imagine why they would do that unless they'd already unstaked and cashed out. If the attacker can just directly take control of the private keys, it doesn't even matter whether they're cashed out or not.
00:16:57.670 - 00:16:59.458, Speaker B: I think it's debatable which version of.
00:16:59.464 - 00:17:31.740, Speaker A: This attack would be sort of more plausible in practice. It really kind of depends if the owners of these public keys are kind of really good at sort of keeping track of their own private keys, but on the other hand are sort of very greedy, then presumably the economic version of the attack would be easier to pull off. On the other hand, if the owners of these public keys kind of really would never want to sort of deliberately mess up the protocol by selling their private keys, but they're just frankly, not that good at securing their own systems, then maybe the cryptographic version, the sort of theft version of the attack, would be the easier one to pull off.
00:17:31.740 - 00:17:44.880, Speaker A: Now, once the attacker has these private keys, by whatever means, whether by purchase or by theft, once they control all of these private keys, they're now in a position to start growing an alternative blockchain history.
00:17:45.650 - 00:17:46.846, Speaker B: So it's still going to start with.
00:17:46.868 - 00:17:55.620, Speaker A: The same Genesis block, Bnot, but after that, it could be just totally different blocks than the ones that had actually been produced by the honest nodes over the previous year.
00:17:56.150 - 00:17:57.586, Speaker B: And just to be clear, while the.
00:17:57.608 - 00:18:26.350, Speaker A: Original chain of L blocks at the top of this slide was created over a period of a year, because we're in a proof of stake setting, because we have costless simulation and production of a block does not require the solution of a proof of work. Because we're in the proof of stake setting, it does not require the attacker to spend a year generating this alternative chain of the same length of L blocks. It might even take just a mere matter of seconds to create a year's worth of blocks.
00:18:26.350 - 00:18:50.946, Speaker A: Now, your second thought might be, okay, I guess the attacker could create this alternative chain, but kind of wouldn't these shenanigans be obvious from the blocks themselves, right, because blocks have timestamps. So in the first chain, we had maybe one block being produced every 10 seconds over the course of a year. So we had this sort of nicely spaced timestamps, whereas in the second chain, they were all produced in a very compressed time frame.
00:18:50.946 - 00:18:59.926, Speaker A: So they should all have timestamps very close to each other. So that should be a dead giveaway. The problem, of course, is that actually the attacker gets to choose the timestamps.
00:18:59.926 - 00:19:16.778, Speaker A: There's no magical way to force blocks that are published to reflect the true time at which they were produced. There's just an alleged timestamp that comes with each block. Now, a lot of protocols have sort of rules that govern what kinds of timestamp sequences are allowed.
00:19:16.778 - 00:19:40.390, Speaker A: But notice, the attacker in their new chain could literally just copy the exact same set of L timestamps from the first chain, right? So the first chain's timestamps check out. By copying them in the attacker's chain, the timestamps will again check out. So just by inspection of the two chains, you cannot actually tell which was the one generated very quickly in a compressed time frame and which one was the one generated normally.
00:19:40.390 - 00:19:55.462, Speaker A: So that's a canonical example of a long range attack. Put briefly, an attacker who manages to acquire old private keys is in a position to quickly generate long alternative histories. So a couple of comments.
00:19:55.462 - 00:20:47.126, Speaker A: So, first, as I said at the outset, long range attacks are not something you have to worry about in proof of work protocols like Nakamoto Consensus, right? Even if you could somehow steal all of the asics of all of the bitcoin miners in the world, you would still have to replicate all of the work that they've ever done to grow an alternative chain from Genesis that took over as the chain with the most overall work. And again, fundamentally, the reason you're seeing this difference between proof of work and proof of stake protocols concerns the reusability of this scarce resource, right? In proof of work protocols like Nakamoto Consensus, the scarce resource is hash rates. And importantly, anytime anyone does a hash that is devoted to a single block proposal extending a single block, it cannot be reused in any way, whereas stake, as we've now seen a couple of times, can be reused.
00:20:47.158 - 00:20:47.354, Speaker B: Right?
00:20:47.392 - 00:21:10.130, Speaker A: We saw that when we talked about proof of stake longest chain protocols and talked about the nothing at stake problem and how a leader could just sort of in effect mine or try to extend lots of different chains, just reusing the same stake across all of them. And here we're seeing it again where stake at a particular old moment in time basically gets reused in alternative history after some other party acquires all of the relevant private keys.
00:21:11.030 - 00:21:12.626, Speaker B: A second comment is for those of.
00:21:12.648 - 00:21:26.280, Speaker A: You kind of trying to puzzle through why this doesn't somehow contradict the guarantees we proved for protocols like tendermint, which are supposed to not have any forks as long as at least two thirds of the participation is honest.
00:21:27.050 - 00:21:28.466, Speaker B: Well, think about a proof of stake.
00:21:28.498 - 00:22:07.406, Speaker A: BFT type protocol like one that's fundamentally based on tendermint. Presumably to argue consistency, you're going to have to at least assume that at every single moment in time, at least two thirds of the stake at that time is controlled by honest nodes, right? If you have a time window where more than a third of the stake is controlled by Byzantine nodes, that's a time window where you really are vulnerable to forks. So the obvious necessary condition then it would seem for provable consistency, is that for every time slot t of the protocol's existence and again, a time slot of the protocol is meant to sort of map on to some interval of real world time, like a particular interval of 10 seconds.
00:22:07.406 - 00:22:25.740, Speaker A: And it seems that we definitely need that during those 10 seconds we need two thirds of the stake in the staking contract in that time slot to be controlled by honest nodes. What long range attacks show us is that obviously necessary condition is not, in fact, also sufficient. We really need something stronger to be true.
00:22:25.740 - 00:22:49.678, Speaker A: Specifically, if we zoom in on one specific time slot, it must be that not only during the corresponding 10 seconds of real world time should it be the case that two thirds of the stake in the staking contract in that time slot is controlled by honest nodes, but that should also be true at all future moments in time as well. So we're talking about a time slot. It's supposed to correspond to a particular 10 seconds of existence.
00:22:49.678 - 00:23:26.874, Speaker A: But we're actually saying that even at all future points of real world time, it should be the case that if you look back at the stake in the Staking contract at this old time slot, it should be that even later at least two thirds of it is controlled by honest nodes. If you're willing to make that much stronger assumption, which of course rules out nodes cashing out and selling their private keys to Byzantine nodes. If you're willing to make that much stronger assumption, then in fact you can prove that there's not going to be any forks in a world where a realistic world where nodes actually can unstake, they actually can sell their private keys potentially to bad actors, well, then this assumption is violated.
00:23:26.874 - 00:23:49.910, Speaker A: And that's why there's no contradiction in seeing forks in long range attacks. So let's now tie the story on the right half of this slide, sort of back to the left half of the slide, by asking, what are the consequences of long range attacks for the trust assumptions that a newly arriving node in a proof of stake blockchain protocol must make in order to be sure that it's syncing correctly?
00:23:50.650 - 00:23:52.534, Speaker B: And what this long range attack shows.
00:23:52.572 - 00:24:16.602, Speaker A: Us is that absent any additional help, a node cannot distinguish between two competing chains, one of which may be generated by an attacker who bought a bunch of old private keys, the other of which generated sort of on schedule by honest nodes. Without further information, those are going to be indistinguishable to a newly arriving node. And so that in turn implies that the guarantee we got for Nakamoto Consensus.
00:24:16.602 - 00:24:27.970, Speaker A: So this is sort of the statement in blue on the left half of the slide. We're not going to get that same guarantee for proof of stake protocols. Nakamoto Consensus, you can ask five different sources, they can tell you five different things.
00:24:27.970 - 00:24:44.950, Speaker A: You don't care, you know how to break ties among them. You just look at whichever chain took the most work to produce, right? So in proof of stake protocols, if you ask five sources and you get sort of five different chains back, you really have no idea which, if any of them is actually the correct chain you should be following.
00:24:45.450 - 00:24:46.934, Speaker B: The good news is you do still.
00:24:46.972 - 00:25:13.840, Speaker A: Get some version of the guarantee, admittedly with a stronger trust assumption. So for example, if you ask five different sources, hey, what's the sort of current version of the blockchain? If at least three out of those five tell you exactly the same thing, well, it's tempted to then believe the majority. And so as long as in fact a majority of the M sources that you ask report honestly, those are going to be consistent reports and that will in fact be the correct chain to follow.
00:25:14.450 - 00:25:15.982, Speaker B: Now, if this assumption is not true.
00:25:16.036 - 00:25:36.178, Speaker A: If you hear literally five different answers from your five different sources, pretty much the only thing you. Can do is go find some new and better sources. All right, so to conclude, I hope after this video, you one have a sort of strong feel for what long range attacks are, that you understand why it's an attack vector really specific to proof of stake that doesn't come up in proof of work protocols.
00:25:36.178 - 00:25:57.998, Speaker A: And then third, some of the consequences, some of the extra trust assumptions which are forced by these long range attacks. So, having all understood all of those things, in the next video I want to talk about potential strategies for defending against long range attacks, either by something in protocol or by something by some process external to the protocol. So that's coming up next.
00:25:57.998 - 00:25:59.690, Speaker A: I'll see you there. Bye.
