00:00:00.250 - 00:00:21.466, Speaker A: Hi, everyone, and welcome to lecture three in this lecture series on the foundations of Blockchains. So, in the last lecture, lecture two, we covered a famous possibility result. We gave a list of assumptions under which it was possible to solve the SMR problem, the state machine replication problem, and get everything we wanted, specifically getting consistency and liveness.
00:00:21.466 - 00:00:48.790, Speaker A: We did that by reducing state machine replication to the Byzantine broadcast problem, which is a single shot consensus problem. And then we went through the duel of strong protocol, which guarantees validity and agreement for the Byzantine broadcast problem, which, as we saw last lecture, was sufficient to get consistency and liveness for SMR. So beginning with this lecture and continuing for the next few, we're going to switch our focus from possibility results to impossibility results.
00:00:48.790 - 00:01:15.042, Speaker A: So now we're going to be identifying sets of assumptions under which, in fact, there does not exist a good consensus protocol for today's lecture. We'll revisit the Byzantine broadcast problem that we talked about in lecture two, and we will actually show that it is impossible in certain cases that there does not exist any protocol that satisfies both validity and agreement under certain sets of assumptions. So this is a famous impossibility result.
00:01:15.042 - 00:01:23.990, Speaker A: It's definitely part of the canon. It's definitely a good one to know. It's also going to illuminate the interesting role of cryptography in the design of consensus protocols.
00:01:23.990 - 00:02:14.070, Speaker A: Also, as part of the proof, we will introduce two proof techniques which are pretty common in impossibility results in distributed computing the idea of an adversary that performs simulation and the idea of honest nodes being unable to distinguish between different worlds in which different behavior is expected. So impossibility results theory and math, like we've been doing in the last couple lectures, is great for proving positive results, possibility results, like, for example, the rigorous guarantees that we proved for the dole of strong protocol in the previous lecture. But arguably, theory might be even better for impossibility results, for delineating what computers or algorithms or protocols cannot do, actually think about the history of computer science.
00:02:14.070 - 00:02:38.238, Speaker A: Arguably, the first academic computer science paper ever was Alan Turing's 1936 paper that introduced the Turing machine model of computation. In some sense, that was the intellectual birth of computer science as a field. And literally on day zero, like in that very first paper, turing already showed an impossibility result, showed that there is no algorithm solving the Halting problem.
00:02:38.238 - 00:03:10.920, Speaker A: A more modern example would be the development of NP Completeness, which, again, is a theory part of theoretical computer science, which explains why certain problems seem unsolvable by efficient algorithms. So distributed computing is really another part of computer science that is in large part defined by the fact that you can prove interesting impossibility results. And so a lot of the sort of richness of this academic discipline is just the very subtle curvature of the frontier between what can be done and what can't be done depending on exactly what assumptions you make.
00:03:10.920 - 00:03:30.270, Speaker A: Now, before I state the impossibility result that we're going to focus on in this lecture, let me just say a little bit about how you should interpret impossibility results like this, what purpose they serve. The point is not to have some kind of theoretician in an ivory tower, sort of scold somebody that they can't solve some problem. That's not the point at all.
00:03:30.270 - 00:03:54.790, Speaker A: Obviously, it doesn't matter what I write down on these slides or what I tell you, people are not going to stop, for example, building blockchain protocols and putting them out into the world. Rather, the point of appreciating impossibility results is to know why you can't always have everything that you want to be sort of educated about the compromises that are going to be required when you tackle a problem. Like, for example, consensus.
00:03:54.790 - 00:04:22.298, Speaker A: So if you go out there and you compare sort of different leading layer one consensus protocols in the blockchain world, you'll see that each of them has its own weaknesses, right? None of them are perfect. And so you may find yourself thinking it's like, why doesn't some super smart person just come along and just design one protocol to rule them all? One that has all of the good points of the leading protocols and none of the bad points. So theory and impossibility results in particular are going to tell us that that protocol does not exist.
00:04:22.298 - 00:04:35.374, Speaker A: It's not that nobody's been smart enough yet to come up with a protocol without any of these weaknesses. It's that completely fundamentally, there is no escape. Every consensus protocol must have one or more weaknesses.
00:04:35.374 - 00:05:13.178, Speaker A: This gives you the lens through which to evaluate and compare different blockchain protocols and how they make different ways of dealing, of sort of escaping these impossibility results by different assumptions, relaxed guarantees, et cetera. So one great example is in the next couple of lectures, we'll see maybe the most famous impossibility result in distributed computing, the FLP impossibility result on achieving consensus in a fully asynchronous model. And that impossibility result is really going to lead us to the sort of sweet spot model of network communication, which is the most commonly used one when you talk about blockchain protocols, the so called partially synchronous setting.
00:05:13.178 - 00:05:27.054, Speaker A: Now, if I just wrote down the definition of a partially synchronous setting right now, you'd be like, that's super weird. Like, why did you do that? That's not what I want at all. But after we understand the impossibility results over the next couple of lectures, we'll realize that this model is going to be the perfect sweet spot.
00:05:27.054 - 00:05:58.510, Speaker A: On the one hand, your assumptions are weak enough that it forces you to design protocols that really are useful in the real world. On the other hand, you do sort of assume enough that you escape these impossibility results and there really are consensus protocols with provable guarantees, all right? So that's the reason we are spending time on these impossibility results. They tell us when tradeoffs are absolutely unavoidable and then we can understand different consensus protocols as taking different approaches to these necessary trade offs.
00:05:58.510 - 00:06:23.814, Speaker A: All right, so let me tell you the impossibility result that we're actually going to prove in this lecture. So this is another just super classic result from distributed computing, again from the, from the early 1980s when a lot of the foundations of that field were being laid. The result we'll talk about was basically proved originally by P, Shashuk and Lamport.
00:06:23.814 - 00:06:38.480, Speaker A: These are actually the same three authors of the paper we mentioned last lecture that introduced the sort of Byzantine terminology talking about the Byzantine generals coming to agreement in the presence of traders. So same set of authors names in a different order. It is a different paper.
00:06:38.480 - 00:06:53.646, Speaker A: I'm not going to show you the proof from that 1980 paper. I'm going to show you a later sort of slicker proof by FLM. So it's Fisher, lynch and Merrit and what this theorem is going to say, it's going to say Byzantine broadcast.
00:06:53.646 - 00:07:13.282, Speaker A: The same problem that we focused on in lecture two. Byzantine broadcast is actually unsolvable if you have too many Byzantine nodes. So in particular, if at least a third of the nodes are Byzantine, remember n denotes the total number of nodes participating in the protocol.
00:07:13.282 - 00:07:32.686, Speaker A: Little F is our upper bound on how many Byzantine nodes we're trying to protect against. So F at least n over three. That says if it's the case that at least a third of the nodes really are faulty, really are Byzantine and in that case this impossibility result will rule out a correct solution to the Byzantine broadcast problem.
00:07:32.686 - 00:07:57.960, Speaker A: And remember, correctness for Byzantine broadcast means two things. First, there's the safety condition which is agreement which is sort of no matter what, whether or not the sender is Byzantine or honest, it should always be the case that all of the honest nodes conclude the protocol with the exact same output. And then validity is the liveness condition which says that in the event that the sender happens to be honest, not only should all of the honest nodes agree, but they should all agree on whatever the private input of that honest sender was.
00:07:57.960 - 00:08:34.734, Speaker A: All right, so that's the statement. If a third of the nodes or more are Byzantine, then too bad you can't solve Byzantine broadcast in the synchronous model. Now you see that and you should have a question which is like didn't we just in the last lecture actually give a protocol for Byzantine broadcast satisfying validity and agreement no matter what F was? Wasn't that the whole point of the dole of strong protocol? Yes, it is.
00:08:34.734 - 00:08:46.146, Speaker A: So that's a good question. Why doesn't this impossibility result contradict the guarantees we proved for the dole of strong protocol? And it's not that either of the proofs is incorrect. Both of the proofs are correct.
00:08:46.146 - 00:09:02.440, Speaker A: But as you might expect, they're under slightly different sets of assumptions. And so what we're going to see is like the assumptions really matter. In particular the cryptographic assumptions really matter of whether or not you can have highly fault tolerant solution to Byzantine broadcast in the synchronous model.
00:09:02.440 - 00:09:31.530, Speaker A: So what I want you to do when we go through the proof of this result in the next video, I want you to sort of keep this seeming contradiction in mind and it may be hard to spot it in real time, but this is one way to stay focused. In the next video when we do the proof is try to find a step of the proof which really doesn't apply for the dual of strong protocol. The proof will still apply to lots of other stuff, but because there's no contradiction, this result must somehow not apply specifically to the dulof strong protocol.
00:09:31.530 - 00:09:47.154, Speaker A: So see if you can figure out why when we go through the proof and then we'll discuss it in the final video of this lecture. And actually, to be honest, I'm going to assume a couple of things just to make my life easier. So first of all, I'm only going to be thinking about deterministic protocols for Byzantine broadcast randomization.
00:09:47.154 - 00:10:05.446, Speaker A: That would make the arguments more complicated. Randomization doesn't really rescue you from this impossibility result, but let's just prove it for the case of deterministic protocols. And secondly, I'm going to prove it only in what seems like kind of the trivial base case where we have three nodes up to one of which is Byzantine.
00:10:05.446 - 00:10:20.718, Speaker A: So N equals three and F equals one. Notice that is in the regime where this impossibility result claims to hold. And that probably seems like a ridiculously simple case to focus on, but actually the general case, it reduces to the case of just three nodes, one Byzantine one.
00:10:20.718 - 00:10:39.446, Speaker A: So any N, any number of nodes, any number of Byzantine nodes that is at least one third N. Basically you can sort of group the nodes into sort of three different sets and sort of treat them as basically like supernodes and then just sort of piggyback on the proof we're about to give. For the N equals three, F equals one case.
00:10:39.446 - 00:10:54.298, Speaker A: Okay? So that shouldn't be obvious in real time. That's actually a really good homework problem if you want to think that through. So just sort of bear with me through the proof for the N equals three, F equals one case, and then think about how either you could rework the proof for the general NNF case or even better, maybe you.
00:10:54.298 - 00:11:13.934, Speaker A: Could avoid redoing the work and you could somehow reduce the general NNF case with F at least N over three to the case we are about to prove. N equals three, F equals one. All right? So in the rest of this video, sort of in preparation for doing the proof in the next video, I want to sort of give you some intuition behind why some result like this might be true.
00:11:13.934 - 00:11:20.462, Speaker A: And I got to warn you, the intuition is quite vague. The proof we're going to see, it's quite slick. So it does basically encode this intuition.
00:11:20.462 - 00:11:36.600, Speaker A: But there is some distance between them. But still I want to give you some sense of what's driving this. Like why this one third? What's driving that? All right, so think about the case where you have three nodes, ABC, Alice, Bob and Carol.
00:11:36.600 - 00:12:03.250, Speaker A: So I'm going to draw this setup just as a graph with three vertices of the nodes and then three edges. The edges just sort of represent the point to point communication between A and B, B and C and CNA. And the vague intuition is that while if you're an honest node running a protocol in this setup, you might be able to detect that something's awry that some node has been behaving inconsistently, but you're not going to be sure which of the other two nodes it is.
00:12:03.250 - 00:12:11.424, Speaker A: Like, let's say that Alice is the sender. Remember in Byzantine broadcast you have end nodes. One of them, and it's known up front who it is, is the sender.
00:12:11.424 - 00:12:38.040, Speaker A: The sender has a private input that at least if they're honest, they want to sort of communicate to all of the other nodes. So let's sort of play the role of bob this node B and assume that we're honest and we're just trying to actually really satisfy agreement and validity as demanded by the Byzantine broadcast problem. Now, for all we know, the sender is, you know, what do Byzantine senders usually do? They usually send out conflicting information to the other nodes.
00:12:38.040 - 00:13:00.230, Speaker A: So totally possible that a's Byzantine told me, told us one thing and told Carol something else. Now we could compare notes with know, kind of say, hey, what did you hear from Alice? Here's what we heard from Alice. But the problem know, for all we know, Carol is the Byzantine one, right? So maybe the sender's honest and actually sent out consistent information, but Carol's going to make it look like Alice sent out inconsistent information.
00:13:00.230 - 00:13:16.184, Speaker A: So the problem is for know, if we hear conflicting information from Alice and Carol, we really don't know which of them to blame. I mean, if we had sort of three other nodes, we could talk know, maybe we could take a majority vote. Only one would be Byzantine, two would be honest.
00:13:16.184 - 00:13:40.944, Speaker A: That might give us enough information to do a majority vote. But if all we have are these two nodes, we sort of know one is messing around, but we can't figure out who, then it's really not clear how to proceed. Now, if you're really on top of things already at this level of vague intuition, you might be suspicious, you might start having an inkling of why this isn't going to work for the dole of strong protocol in particular, the second of the three things that I wrote down.
00:13:40.944 - 00:13:53.620, Speaker A: If you think about the assumptions we made for the dull of strong protocol, that second step should feel a little fishy to you. If you don't see that yet, that's fine. But that's, again, what you should be keeping in mind as we go through the proof in the next video.
00:13:53.620 - 00:14:09.492, Speaker A: Somehow this proof cannot be sort of applying to dole of strong. What is it about the Dolof Strong protocol and its guarantees that prevent the proof we're about to see from working? So, that's everything I wanted to say in preparation for actually doing the proof. So let's now actually do the proof.
00:14:09.492 - 00:14:16.680, Speaker A: That'll be the point of the next video. It's a very slick, very clever proof. And, again, it's a very kind of famous impossibility result.
00:14:16.680 - 00:14:38.270, Speaker A: So I definitely encourage you to watch the video and sort of appreciate the marvel of the argument. If you feel like skipping that proof, then you should definitely still watch the third video. That's part of this lecture when we discuss at some length why is it that this FLM impossibility result doesn't contradict the Dolov Strong protocol? Okay, so I'll see you in the next video for the proof of this impossibility result.
