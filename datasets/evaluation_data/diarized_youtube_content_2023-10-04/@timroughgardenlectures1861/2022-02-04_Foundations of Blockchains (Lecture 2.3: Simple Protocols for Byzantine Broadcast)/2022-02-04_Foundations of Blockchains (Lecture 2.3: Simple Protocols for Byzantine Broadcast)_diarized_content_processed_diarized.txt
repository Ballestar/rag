00:00:00.410 - 00:00:36.722, Speaker A: Okay, so in the last video we defined the Byzantine broadcast problem, right? So this is where you have end nodes. One of them is a designated sender. The sender has a private input that they want to communicate to everybody else. And a protocol solves Byzantine broadcast. If it satisfies termination, all the honest nodes running the protocol eventually terminate agreement. No matter whether or not the sender is Byzantine or honest, it should always be the case that the honest nodes sort of conclude the protocol with the same value in mind. And moreover, validity states that in the event that the sender is honest, that common value in all the honest nodes mind should indeed be the one that the sender was intending to communicate, intending to broadcast.
00:00:36.722 - 00:01:11.246, Speaker A: What we saw in the last video was that that's actually all we need to solve the SMR problem. State machine replication in the presence of faults under our other assumptions, right? So under assumptions that we're in the synchronous model PKI and the permissioned setting. So now it makes sense to turn our focus squarely on this problem of designing a fault tolerant protocol for the Byzantine broadcast problem. So that's what we're going to start doing in this video. Now I'll give you actually a complete solution to the problem in the next video. That's the dole of strong protocol. If you want to, you can skip this video and move on to that one without loss of continuity.
00:01:11.246 - 00:02:08.866, Speaker A: But to be honest, the main reason I'm covering the dole of strong protocol is not so much because I really want you to know exactly how it works, but really because this is the right gateway to getting a feel for how consensus protocols work, including in sort of more complicated models with weaker assumptions about network reliability. So in that spirit, in the spirit of just building up your muscles, developing intuition about what the challenges are, this video will also serve that purpose very much. All right, so Byzantine broadcast, it's easy if f equals zero, if you're sure that everybody's honest, then basically the sender can just send whatever they have to say to everybody. Everybody can just believe them. But we also saw that even when F equals one, that trivial protocol is not good enough. Because if f equals one, for all we know the sender is Byzantine and sends different information to different nodes. So intuitively, what we're going to need to do to handle the F equals one case in particular, the possibility of a dishonest sender, is the honest nodes are going to have to do some additional cross checking.
00:02:08.866 - 00:02:40.410, Speaker A: They're going to have to compare notes and give each other some information about what they heard from the sender. So here's maybe the simplest possible protocol that makes use of that idea. As always, when we write down a protocol, we mean what it is that honest nodes do. Again, Byzantine nodes, they can just throw out this protocol and do whatever they like. So let's call the first time step t equals zero. And the natural way to start is by having the sender who after all has this private input. They want to communicate sending that value to all of the other nodes.
00:02:40.410 - 00:03:37.230, Speaker A: And remember from lecture one, our default assumption which unless otherwise noted, when one node sends a message to another node, the sender will sign it cryptographically. Remember that we're only trying to solve Byzantine broadcast under the same assumptions we already imposed on state machine replication. So in particular we're assuming that crypto exists in the PKI assumption. So all of the nodes know operi, everybody's public keys. So the next time step, time T equals one, right? So if you have an honest sender who really sent these messages at time zero because we're in the synchronous model at that point, we know all of the nodes have received those messages by the beginning of time step one. And this is the step in which the nodes are going to compare notes. So they're going to basically just tell each other what it is they heard from the sender, okay? So specifically they will be echoing the message the sender sent them and remember, that message was signed by the sender and then when you echo the message, you sign it yourself, right? So you attest to the fact that this is the message that you received from the sender.
00:03:37.230 - 00:04:24.446, Speaker A: All right? So the next time step is going to be the last one t equal two. So at this point the protocol, all of the nodes are going to be responsible for figuring out their final output. So imagine you're an honest node, node number seven, running this protocol, trying to figure out what to output. Sort of two trivial cases. If you're the sender and you're honest, just output V star, right? You know the answer, you knew it up front if you're a non sender but you've only ever seen messages that reference a single value v star output that, why would you ever output anything you've never heard of? So the only hard case is when first of all, you're a non sender and second of all, different messages you've seen refer to different values. Like some of them refer to value v one and some of the others refer to value v two. And now you have to decide which of those two things you want to output and there's various ways you could do that.
00:04:24.446 - 00:05:00.618, Speaker A: But maybe the most natural way would be by majority vote, get to output the value that you've seen the largest number of messages for. So specifically you have one vote from the sender the message they sent you directly. Really, I guess I should say you have at most one vote from the sender, right? Maybe they're a Byzantine and they didn't send you a vote at all. If they send multiple votes, you can just ignore all but the first one. So you have at most one vote from the sender and you have at most one vote from the other n minus two non senders. Again, maybe you have one less because maybe some Byzantine node didn't tell you their vote. But in any case you have this collection of votes up to perhaps N minus one.
00:05:00.618 - 00:05:41.234, Speaker A: And then you just output the most frequently referred to value, the most frequently voted for value. Among those N minus one or less votes there might be a tie, in which case you should just break it in some consistent way. Like for example, for the alphabetically smallest of all of the values that are mentioned. So that's the protocol, right? Pretty simple. I mean, the sender is just supposed to send out their value to everybody and then the non senders compare notes and they resolve any ambiguities that arise from those votes by doing a local majority vote. And I claim that this protocol actually solves the problem in the sense that as long as F is one, there's a most one Byzantine node. In fact, this protocol satisfies both validity and agreement.
00:05:41.234 - 00:06:06.382, Speaker A: And of course, obviously it satisfies termination. It terminates at the end of time. Step Two all right, so let's go ahead and talk through that argument beginning with validity. And to make my life easy, let's just make a mild assumption that there's at least four nodes. So N is at least four f equals one, at most one Byzantine node and at least three honest nodes. Now don't forget the validity condition. Like if there's a Byzantine sender we're totally off the hook.
00:06:06.382 - 00:06:49.518, Speaker A: Validity asks nothing of us. In the event of a Byzantine sender, we only have to worry for validity about the case of an honest sender. So suppose the sender is honest, follows the protocol. That means at times T equals zero it's going to send a vote for its private input v star which because we're in the synchronous model, will be received by all of the non senders at the beginning of time T equals one. Now at time T equals one, all of the non senders compare notes or at least the honest ones, echo to all the other nodes what they heard from the sender. So now we have to argue that every single honest node outputs the correct value, outputs the sender's private input v star. Now remember, we're assuming that the sender is honest.
00:06:49.518 - 00:07:31.742, Speaker A: And so just by definition of the protocol, the sender will of course output its own private input. So we're not worried about the sender. So we only have to worry about an honest node that is a non sender. So one of the non senders may be Byzantine, but N minus two of those are going to be honest non senders. So think about the votes that are going to be collected by an honest non sender. So from the honest sender they're going to get a vote for the sender's private input Vstar and from the other N minus three other honest non senders, they're going to get honest echoes of the honest sender's vote for Vstar. So one vote for Vstar directly from the sender and then N minus three more votes from Vstar from the other honest non center.
00:07:31.742 - 00:07:53.582, Speaker A: So a total of N minus two votes for Vstar. Now there is this one Byzantine node out there somewhere. So who knows what it's doing. So maybe there's one vote where we don't really know what we can say about it, but we have N minus two votes for V star, maybe one vote for something else. N is at least four. So majority vote will save the day and we really will output the correct value V star. So let's move on to agreement.
00:07:53.582 - 00:08:34.750, Speaker A: Now notice when we just talked through the validity case, a part of that is we actually argued agreement in the event that the sender is honest, specifically all the honest nodes agree on the correct private input V star. So all we need to prove is we need to consider the presumably the hard case of agreement when there's a Byzantine sender. Now remember, f equals one there's at most one Byzantine node. So if the sender is Byzantine, it means all of the non senders are honest. So now when we get to time step one, the good news is that only non senders send messages at timestep one and all of the non senders are honest. Remember, we're assuming that the sender is Byzantine and that F equals one. So that means all of the non senders have to be honest.
00:08:34.750 - 00:09:29.326, Speaker A: So that means in time step one everybody will honestly echo whatever message they happen to hear from the Byzantine sender at the beginning of that time step. So what that means is that when we get to time step two at the beginning of that all of the non senders will have in their possession exactly the same information, exactly the same number of votes for every possible value. Basically the N minus one honest non senders just pooled all of their information, all of the messages that they have received from the leader. So because all of those non senders will have exactly the same information, the same number of votes for every value, all of them decide on their final output in the same way by majority vote with consistent tiebreaking. So indeed all the honest non senders will output exactly the same thing which is exactly what is required for agreement. All right, so this is kind of a nice thing, right? We came up with a protocol. It's still pretty simple, it's pretty intuitive.
00:09:29.326 - 00:10:11.410, Speaker A: But at least when there's most one Byzantine node, we have what we want. We have both validity and agreement. Now what's going to be equally instructive is to see why this protocol does not work, is not correct. When F equals two and we have the possibility of two Byzantine nodes, in particular, the possibility of collusion between a Byzantine sender and a Byzantine non sender. So let's see that counterexample in detail in the next slide. So specifically, I want to show you a violation of agreement. So the protocol on the previous slide run verbatim does not satisfy agreement in the case that F equals two.
00:10:11.410 - 00:10:47.320, Speaker A: So here's how it's going to work. So there's n nodes total. Let's assume that N is even for simplicity, there's at most two Byzantine nodes. Let's assume that the sender is Byzantine and also one non sender is Byzantine. And then sort of conceptually in our minds the other N minus two honest nodes. We're going to split into two groups of equal size, of size n over two minus one each. And what this counterexamp is going to make clear is that when you're working with Byzantine faults, you even have to deal with the case where all of the Byzantine nodes are in effect conspiring to ruin your protocol.
00:10:47.320 - 00:11:24.292, Speaker A: And so let's see how that can happen in this particular case. So time step zero, we've got this Byzantine sender, it can do whatever it wants. It's going to do exactly what you would sort of expect it to do. Given that the goal is to sort of break the protocol's agreement, it's going to send inconsistent messages to the honest non senders. In particular, it'll send half of them zeros and half of them ones. Now, this by itself is not sufficient to be a counterexample kind of for the argument that we saw on the previous slide, right? If this was the whole story, this is all that happened, well then all of these magenta non senders, they're all honest. So they're all going to echo the messages that they heard from the sender.
00:11:24.292 - 00:12:10.330, Speaker A: And then at the beginning of time, step two, they're all going to know exactly what votes they got from the sender and they'll know it's equally split half of them for zeros, half of them for ones. They all break ties, a majority vote in exactly the same way, for example, maybe favoring zero over one in the event of a tie. So they're all going to output exactly the same thing. So if this is going to be a counterexample, it has to use the fact that F equals two rather than one and that there's a second Byzantine node which is going to be a non sender. So somehow the non sender has to sort of screw up the fact that all of the honest nodes seem in sync. And here we're going to really see how sort of conspiracy between the Byzantine nodes can be sort of very powerful. So imagine I haven't written what the sender has written has sent to the non sender, right? Because it could be anything.
00:12:10.330 - 00:13:13.400, Speaker A: So let's imagine that the Byzantine sender sends to its comrade the Byzantine non sender. It actually sends it two votes, assigned version, assigned a vote for number zero and assigned a vote for number one. Now if this was an honest non sender it would just throw out the second vote, right? It would just ignore everything but the first vote. But this is a Byzantine non sender so it's going to go ahead and collect both of these votes that the Byzantine sender sent it. Alternatively, instead of the sender just sending signed votes for both zero and one over to that Byzantine nonsender, it can also just send its private key, right? And then the Byzantine nonsender could just make up these signed messages by itself. Point being is that now at the beginning of time, step one, the Byzantine non sender has in its possession both a message signing voting for zero and a message voting for one both signed by the sender. And it's now in a position to again send inconsistent messages to the honest non senders.
00:13:13.400 - 00:14:06.556, Speaker A: So it's going to forward on the vote for zero to the left Blob of honest non senders and it's going to forward on the vote for one to the right Blob of honest nonsenders. So now we see that we really are going to have a violation of agreement, right? Because think about the honest non senders in the left magenta Blob, okay? So they get a total of n minus two votes between the sender and all of the honest nodes and they're going to be equally split n over two minus one votes for zero. N over two minus one votes for one. The tiebreaking vote is the one that comes in from the Byzantine non sender. The Byzantine nonsender sent this particular group a tiebreaking vote of zero. So their majority vote will all conclude with the output zero. Meanwhile, the right magenta Blob again between the sender and the honest nodes they get this equal split n over two minus one votes for both zero and one.
00:14:06.556 - 00:14:42.216, Speaker A: But now the tiebreaking vote coming in from the Byzantine non sender is for one. And so that's going to tip the majority vote and force that right Blob to output one. Which of course is a violation of agreement because we have two sets of honest nodes outputting different things. All right, so a few takeaways from this counterexample. So takeaway number one is just, I hope this has sharpened your intuition. The Byzantine nodes can really do bad stuff by conspiring with each other and a lot of protocols that seem reasonable are actually broken because Byzantine nodes have sort of very clever strategies to exploit it. So that's number one.
00:14:42.216 - 00:15:34.616, Speaker A: Number two is that even if you have a protocol that happens to be correct, right? And we'll definitely see an example coming up next, even if it's actually correct, it may be very difficult to prove convincingly that it's correct again just because the space of sort of strategies for Byzantine nodes is so rich you have to rule out all of them to actually prove correctness of a consensus protocol. Takeaway number three is this is going to sort of segue into the general solution we give in the next video the dilloth, strong protocol. So intuitively, what this example shows us is that one round of cross checking isn't enough. Okay? So if we're going to want to have something that works when f equals two, we're going to need to do more cross checking. And indeed, what we're going to see is that every additional Byzantine node that you want to be able to tolerate is going to lead to one extra round of cross checking. So again, the solution is going to be the dole of strong protocol. We'll cover that in the next video.
00:15:34.616 - 00:15:35.350, Speaker A: I'll see you there.
