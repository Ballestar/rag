00:00:00.410 - 00:00:52.554, Speaker A: So last video we talked about long range attacks, both what they are, why they're really kind of specific to proof of stake protocols and don't come up in proof of work protocols. And also how that forces you into kind of stronger trust assumptions. Specifically when you have a newly arriving node who wants to sync up to the current state of a blockchain protocol. And so just to remind you of the canonical long range attack in one sentence. So basically an attack hacker gets some old private keys, maybe they buy them, maybe they steal them. But anyways, once they're in control of some earlier portion of the blockchain they use that power and the fact that simulation is costless to very quickly generate an alternative blockchain history. Now a reasonable question would be how much should we be worried about these long range attacks? How big a deal is it? And as with so many things reasonable people disagree on this.
00:00:52.554 - 00:01:35.290, Speaker A: Some people worry about it a lot, some people feel satisfied that it's easy enough to handle through kind of ad hoc methods. I think it's far too early to actually know the answer to that question how big a deal these are in practice. So what I want to do in this video is just talk you through the various options that various projects are either using or contemplating. So let's begin with a straw man argument just to sort of kick off the conversation. This first option is really going to be just too strong an assumption to make typically for permissionless blockchain protocol. So specifically it's the assumption that at any moment in time the nodes running the protocol are the same as the original ones. So in other words nodes are online from the beginning of the protocol and never go offline.
00:01:35.290 - 00:02:37.950, Speaker A: So why is this strong assumption helpful? It doesn't really rule out long range attacks, it just makes it relatively easy for nodes to spot them and ignore kind of alternative chains that are being grown by some attacker who's compromised some old private keys, right? Because this assumption basically says you're monitoring the creation of the blockchain in real time. For simplicity, imagine we're in like some kind of synchronous models or some kind of bounded delays. So what you're expecting to see happen is that some time slot T which is going to correspond to some period of real world times, a particular 10 seconds or whatever, you're probably going to see some block get finalized, you're going to hear about it. Then time slot T plus one, you're going to see some other block get finalized, you're going to hear about it. So you're basically just watching time slot by time slot, block by block. You're watching kind of block production play out in real time. And so because of that, again, assuming that at any given moment in time at least two thirds of the participation is honest so you can't have a fork just sort of at a given time step, you're just going to see a single block grown at each time slot.
00:02:37.950 - 00:03:25.054, Speaker A: You could still have an attacker who compromises some keys and then grow some alternative history, but you will be well aware that those are much too late arriving to bother with. It'll be obvious to you that that's not part of the sort of regularly scheduled chain, but rather sort of a late comer which is presumably by some bad actor. So that's what's going on in this first option. By being online all the time, you can monitor the chain and the block production in real time. So you can just sort of spot using your own knowledge of real world time, which of the alternative chains you should ignore. Basically you're sort of tiebreaking by the chain that was formed earliest and because you were continually online, you're in a position to know which blocks were produced earliest. So again, that first option, it's really just a straw man if you think about it.
00:03:25.054 - 00:04:01.846, Speaker A: This is almost like saying assume you're in the permissioned setting. Definitely too strong an assumption to make if you're trying to design a permissionless blockchain protocol. And indeed I'm not aware of any major deployed proof of Stake protocols that sort of rely on option number one. Now option number two, which is going to be a variant of option number one, will start getting us closer to something that's practical, something that actually is used by some of the major proof of Stake protocols. It's not going to be just option two, it's going to be two in conjunction with something like three or four, which I'll get to in due time. But two gets us sort of halfway there. So let's weaken the previous assumption.
00:04:01.846 - 00:05:02.010, Speaker A: Let's allow nodes to go offline, but only for a bounded period of time. So let's say they can go offline, but they better be back online within capital T timesteps or T. Here is a parameter that we get to choose and in fact I would encourage you to think of the parameter T as being basically the same as the cooldown period. So just to jog your memory back from that video way back in part one about staking mechanics, one of the design decisions you make when you're setting up how staking is done in your protocol is often you want to have a warm up period and or a cooldown period, right? So there's going to be a period where someone is actively validating, meaning they're proposing blocks, maybe they're voting on other people's blocks, but in any case they have some influence over what the protocol does. You usually want some period of time both before and after that period of active validation. A sort of warm up period at the beginning, a cool down period at the end, where on the one hand the node can't actually influence what the protocol is doing. But on the other hand the protocol does still control the stake.
00:05:02.010 - 00:05:38.600, Speaker A: All right, so why is this helpful? You're probably wondering also why the connection between the cooldown period and the length of time that we are going to allow nodes to go offline. Well, imagine some Node I goes offline at some time slot T. So it had been online up until that point. It had followed the creation of the blockchain in real time through time slot T. It's aware of what the correct blockchain is at that time. Now, by assumption, Node I has to come back online less than T steps later. So at some time T Prime less than little T plus big T.
00:05:38.600 - 00:06:35.702, Speaker A: So what are we worried about when Node I comes back online? Well, we're worried that there is a long range attack in the meantime. So some attacker purchased a bunch of sort of old private keys and used that power to grow some alternative chain which now confuses Node I when it comes back online. Because the worry is Node I will not be able to figure out what the new tip of the canonical chain is because of some long range attack. So how far back could this long range attack go? How big a fork could the attacker potentially create during this period of time where Node I is offline? Well, so let's look at the private keys that the attacker controls right now, currently at time T Prime, presumably it bought those from people who owned them earlier. Why did those people sell these private keys to the attacker? Well, presumably it's because they no longer had any assets on the blockchain. Presumably it's because they had cashed out by Time T Prime. That's why they were willing to sell by Time T Prime.
00:06:35.702 - 00:07:15.414, Speaker A: That's why the attacker was able to buy by Time T Prime. Here's where the warm up period comes in. If nodes are able to be cashed out by Time T Prime they must have initiated the cooldown process capital T times steps earlier. Remember, the cooldown period is capital T timesteps. So if they were cashed out by time little T prime, they must have started the withdraw, started the process at time little T prime plus minus capital T. And so that means because node I was offline for strictly less than capital t time steps. The sellers of these private keys must have started the cooldown period before.
00:07:15.414 - 00:07:53.806, Speaker A: Strictly before. Node I went offline. And the tip of the canonical chain at that time would be sort of further back, closer to Genesis than the tip of the canonical chain at time T. Now remember, during the Cooldown period, private keys are useless. You can't do any black proposals, you can't do any voting, you can't do anything. The private keys are only useful before the Cooldown period is initiated. So that means at Time T Prime this attacker who's bought up all these private keys, it could only create a fork that starts at time slot t prime minus capital T or earlier.
00:07:53.806 - 00:08:44.370, Speaker A: So whatever alternative fork it is growing it starts growing it before the last block that Node I saw before it went offline. And so that means because Nodei came back online sufficiently quickly, it has enough information to know to ignore the light blue chain, to ignore the attacker chain. Right? Because Node I trusts the previous version of itself. It says, hey, I was online not that long ago, and I knew the tip of the canonical chain at that time, in effect, is trusted information for me because I myself witnessed that tip at that time. T so if I'm seeing some alternative chain that didn't extend that and extended something further back, I know that's a Johnny come lately. I know that cannot have been part of the canonical chain. I know to ignore the light blue chain and instead pay attention only to the magenta chain.
00:08:44.370 - 00:09:35.906, Speaker A: Now how you might be asking is Node I supposed to know what the new longer version of the magenta chain is? Well, someone has to tell Node I that, but only one person has to and no matter how many people try to feed Node I misinformation, it's not going to get tricked. And as long as at least one person tells it about the new magenta chain which you know, extends the block that node I was expecting to be extended as long as it hears about that chain from one person then it's good to go and it can just restart trying to extend the new end of the magenta chain. Also a quick digression. You might remember on that last video we actually talked about two different versions of long range attacks. One version which is the same version we've been talking about here where we think about an attacker purchasing private keys that used to be owned by others. Why were they willing to sell those private keys? Well presumably it's because all their assets have been cashed out of the blockchain protocol. So those private keys are no longer valuable, are valuable to them.
00:09:35.906 - 00:10:36.342, Speaker A: And of course to be cashed out they must have initiated the cooldown period at least capital T time steps ago and it was only before then that they actually had any influence over the protocol and that's sort of key to this argument. The second variant of long range attacks maybe harder to pull off but certainly a nastier version is if the attacker just forgets about this whole purchasing private keys idea and literally just somehow kind of steals takes over private keys that used to be owned by honest nodes. Now, unlike the economic version of the attack where you're presumably only going to be able to purchase private keys from nodes that are cashed out of the protocol and are no longer participating, you might be able to just take over private keys of nodes that are actually actively validating right now. And if you manage to do that, you're going to be able to start creating forks immediately if you control a sufficient amount of stake. All right, so digression aside. Let's go back to focusing on the first version of long range attacks, an attacker that purchases old private keys. The first option was way too strong.
00:10:36.342 - 00:11:39.862, Speaker A: Just assuming that nodes are literally always online, real time monitoring block production. We relaxed that in option two. We allowed nodes to go offline for a bounded period of time and then things should work out well. But then there's still the question of, like, what if once in a while a node goes offline for longer than that? Or more simply, what about a node that just shows up ten years into the blockchain protocol and wants to get started? Well, basically the idea is to just treat a node that's been offline for more than capital T timesteps as if it was just newly joining the protocol. And then all of the discussion from the last video sort of applies directly. Remember in the last video we sort of framed sort of the whole discussion in terms of thinking about a newly arriving node to a permissionless protocol and sort of how do they get sort of up to speed, how do they sync and get the correct current state of the protocol? And we talked there in the last video the difference between proof of work and proof of stake proof of work. If you ask M different sources for advice on what they think the current state of the blockchain is, if at least one of them tells you the right answer, you will then actually be able to identify that and follow along proof of stake.
00:11:39.862 - 00:12:25.290, Speaker A: Unfortunately, it's not enough for just one person to tell you the right blockchain state. You really need a majority to tell you. So if you ask five people, you need not just one of them to tell you the correct answer, but really, three out of the five should tell you the correct answer. Sometimes this is called the phone a friend approach, right? So the special case of M equals one. That's where there's sort of one trusted source from which you can learn the latest blockchain state. Again, more generally, you might want to ask multiple sources, m sources, and look for unanimity among a large number of those sources. If you ever come across the phrase weak subjectivity in the literature or in discussions, this is generally what it's referring to, the sort of stronger trust assumption you need to make if you go offline for longer than the cooldown period.
00:12:25.290 - 00:13:03.398, Speaker A: And this is actually more or less how most proof of stake blockchain protocols handle long range attacks. So proof of stake ethereum in particular more or less works in this way. One obvious question is how to set the parameter capital T. And there's sort of a trade off. On the one hand, bigger capital T's are better because that's being more permissive for allowing nodes to go offline for a period of time. On the other hand, smaller capital T's are more convenient for validators who might want to be able to withdraw their stake in a relatively short period of time. So in practice, you might want to think about capital T, possibly on the order of days, possibly even as large as something like a couple of weeks.
00:13:03.398 - 00:14:02.582, Speaker A: But there is sort of a range of parameter values which, while there's a little inconvenience for a few different stakeholders, it is sort of good enough for practical purposes, at least at the time of this recording. Another question you may have about the phone a friend method is like, where do you get the friend? Who are you supposed to ask? And in particular, you might wonder, can we actually somehow have a technological solution that stands in for this trusted friend? So let's talk about that next. Specifically, let's talk about periodic trusted checkpoints. So here a trusted checkpoint is going to be in the form of a block that's been finalized in some time in the past. And the interpretation is that nodes should ignore any chains that do not include that trusted checkpoint that do not include that particular block. So these trusted checkpoints, they're playing the role of the friend in the phone a friend approach. And you can almost think of them as kind of like updates to the genesis block, right? I mean, everybody knows to ignore any chain that doesn't start from the genesis block.
00:14:02.582 - 00:15:00.090, Speaker A: And so if you have trusted checkpoints that everybody can see, well, then you can further refine that rule to say anyone should ignore any chains that don't include the latest trusted checkpoint. So trusted checkpoints are going to be coming out at some frequency, maybe one per month, maybe one per year, who knows? It's going to depend on the details of the protocol. But in any case, the next question you should have is where are people going to look to find the latest trusted checkpoint? There's a few answers to that question. Let me just mention some of the approaches that people are currently exploring. So first, if you think about a trusted checkpoint as an update to the genesis block, it's natural to say, well, why don't you just get it from the same place that you get the genesis block from normally? Where would that be? Well, that would be from the protocol code itself. So the good news there is you're not really making any stronger trust assumptions than we already were in our assumption that you're running the correct version of the protocol. The bad news is, of course, every new trusted checkpoint actually necessitates an update to the protocol.
00:15:00.090 - 00:16:11.490, Speaker A: So that approach is probably appropriate only for pretty infrequent updates to the trusted checkpoint, like maybe twice a year at the most, maybe even more like once a year or once every couple of years. The second thing you could do is rather than embedding the description of a trusted checkpoint into the protocol code itself, just make it available by the exact same process by which you got the protocol code. So, for example, whatever trusted website you might have used to get a correct version of the protocol, hopefully that exact same source is in addition going to be able to provide you with a description of the latest trusted checkpoint. And this is a pretty tempting approach in practice, right? So while it's maybe not reasonable to expect, say, the Ethereum Foundation to offer a full download of all the blocks that have ever been finalized on their website, certainly just offering a description of the latest trusted checkpoint and then the Ethereum Foundation updates that web page periodically, that doesn't seem so crazy. Technically, you're sort of making a stronger trust assumption because you're trusting a second piece of information. You're trusting the description of the trusted checkpoint in addition to the protocol code. But if you're getting it from the exact same source, maybe that's basically exactly the same trust assumption.
00:16:11.490 - 00:17:03.890, Speaker A: And as we discussed earlier, if you're feeling paranoid, you can do something like look at five different sources and only if all five are sort of unanimous in what they say the lated trusted checkpoint is, only then do you proceed with confidence. That's really the chain you're supposed to be following. If you find these proposals too centralized, so too reliant on a single point of failure. People are also exploring using some other blockchain, like maybe a very secure blockchain, something like Bitcoin, where these trusted checkpoints could be periodically published in this last approach. It's actually a little trickier than it might sound at first. For example, you have to somehow figure out who's allowed to publish these trusted checkpoints to the Bitcoin protocol. And secondly, how do you sort of double check that they're not just fabricating fake checkpoints that aren't the actual state of the blockchain protocol? So there's definitely some issues there.
00:17:03.890 - 00:17:53.490, Speaker A: In principle, you definitely could do this. And this is one approach that current projects are thinking about. So that approach, approach number four, that's probably one of the most common approaches used in practice. The last two, I'll mention number five and number six, those I'd say are a bit more experimental. So the fifth option basically says, why not deal with long range attacks proactively rather than reactively? So rather than just sort of putting some processes in place to notice and recover from long range attacks when they happen, why not try to just prevent them from happening at all? So what does an attacker need to pull off a long range attack? Well, they need old private keys. So the idea here is just ensure that old private keys cannot possibly be useful. So this requires some nontrivial cryptography, which I'm definitely not going to get into here.
00:17:53.490 - 00:19:03.034, Speaker A: But for an analogy, hopefully many of you have used for multifactor authentication, an authenticator app like on your phone, where it's just sort of every 30 seconds or so giving you a different six digit code to use for authentication. You can imagine a version of that where every 30 seconds it's not that there's a new sort of six digit code, it's that there's a new private key with which you should be, for example, signing votes. So speaking of nontrivial cryptography, the final option we're going to discuss would be the use of a verifiable delay function, a VDF specifically, and this is actually sort of reminiscent of Nakamoto Consensus, where a block is valid only if it has a suitable proof of work included in it. Here a block is going to be valid only if the appropriate VDF output is included as part of that block. Now we've seen VDFS before in Lecture Twelve, though it was a while ago, it was back in part two, if you remember. It was the final video where we talked about how could you try to approximate an ideal randomness beacon, which is definitely a nice thing to have, and we talked about trying to do it by crowdsourcing. So by having N different parties submit their own opinions of what the randomness should be.
00:19:03.034 - 00:19:48.642, Speaker A: And we wanted the property that if at least one out of the N parties submitted uniform randomness, then the output of the sort of protocol should also be uniform randomness. And we talked about a two phase protocol and the use of VDFS to make sure that nobody can sort of peek at other people's inputs before deciding on their own. So that was a very different use of VDFS than we're talking about here. It was also in the context sort of of proof of stake blockchains, just because we saw how useful idealized randomness beacons are. But here we're actually using it for a different purpose, defending against long range attacks. So that was a long time ago. So let me just pause and jog your memory, remind you about the three most important properties of Verifiable delay functions.
00:19:48.642 - 00:20:40.454, Speaker A: Basically what we want is we want that computing the function always takes more or less the same amount of time, no matter whether you're just sort of a humble validator or if you're a well funded attacker. So for a concreteness, let's say that we'd like an honest node with sort of reasonable computational power to be able to evaluate a VDF. And at most capital T timesteps here, capital T is a parameter that we get to pick when we sort of set up the VDF. A well funded attacker, even if they try to solve the problem in parallel, they shouldn't be able to get too much of a speed up over what an honest node can do. They shouldn't be able to solve it too much faster than T time steps. So finally, the V, the Verifiability, that just means that if someone tells you the alleged output of a VDF, you can quickly check that that computation was in fact done correctly. Now, if you go back to the VDF video from part two, you'll see it's a little more nuanced than that.
00:20:40.454 - 00:21:19.938, Speaker A: So actually, when you evaluate the VDF, you're going to get not just the VDF output, but also a sort of supporting proof. And then you hand that supporting proof along with the output to the Verifier. And using both the output and the supporting proof, a Verifier can very quickly check that you indeed evaluated the VDF correctly. We also talked back then in part two about some candidate constructions, in particular, repeated squaring in a suitably chosen group. But you can go back and rewatch that video if you're interested. Let's just assume that VDFS exist and see how one might use them to deal with long range attacks. So intuitively, what a VDF accomplishes is it makes simulation all of a sudden not so costless.
00:21:19.938 - 00:22:28.086, Speaker A: If someone wants to fabricate an alternative history that's a long chain of some number, capital L of blocks, what's going to have to solve capital L different VDF computations. Now, a word of caution is it's important you incorporate VDFS into the sort of blockchain protocol in a way that an attacker couldn't just handle these L different VDF computations in parallel. You really wanted to have to do them one by one, for example, because maybe the output of one VDF computation is included as part of the input to the next VDF computation. So this is what I meant when I said you can use VDFS to make the costless simulation we've been seeing in proof of stake protocols at least a little bit more costly. How much more costly? It's going to depend on the quality of the Verifiable delay function that you're using. It's going to depend on exactly how much faster a well funded attacker is going to be able to solve evaluate Bdfs than a humble validator. For example, if the attacker can solve them ten times as quickly as a typical honest node, well, then if it's growing a long alternative chain, it will actually eventually be able to catch up to the main chain.
00:22:28.086 - 00:23:30.346, Speaker A: So the claim is not so much that this makes long range attacks impossible, but it does certainly make them more difficult. So this idea is perhaps not enough on its own, but you could imagine incorporating this idea sort of as part of a multiple layers of defense approach against long range attacks. So speaking now, in early 2023, I would call this an experimental approach, though I think there are signs we might see it going more mainstream in the next couple of years. So to learn more, there's a nice academic paper from 2020 by Deb Connon and Say about a project called PostSat, which is based on this idea. And then also the Chia project uses Verifiable delay functions that's not a proof of stake blockchain protocol but it uses VDFS for some of the same reasons the proof of stake protocols do, including some degree of resistance against long range attacks. So those are some of the options I wanted to talk through about defending against long range attacks. To be honest, at the moment, current practice is pretty simplistic, largely just based on trusted checkpoints.
00:23:30.346 - 00:24:13.002, Speaker A: So some projects just hardwire a trusted checkpoint into the protocol code. Basically every time they do an upgrade to the protocol, they update the description of the latest checkpoint in the protocol code. There are other projects that more just kind of go the trusted website route and then that's where people are supposed to get the latest checkpoints from. I do think we may see quite soon projects that actually do have a decentralized solution, that do rely, for example, on Bitcoin to publish these periodic trusted checkpoints, but we're not quite there yet. So some reasonable people are quite comfortable with current practice, with sort of the attitude. It's like, look, you're already making some degree of trust assumptions to get the correct protocol code. Presumably you didn't just write it from scratch yourself.
00:24:13.002 - 00:25:06.270, Speaker A: So why don't just piggyback on that existing trust assumption to get some additional information, like for example, the latest trusted checkpoint. Other reasonable people actually are not satisfied with current practices and really want to sort of push toward sort of more decentralized, more robust solutions. They might argue something like, look, if you were lying on a trusted website, anyone hacks that website, all of a sudden you've screwed up everything. So as with so many other things around proof of stake blockchain protocol design, lots of open questions. I would say it's an open question right now whether or not long range attacks are sort of just purely academic versus actually being a practically relevant type of attack. For those of you that whose sort of initial reaction is probably just academic, I mean, let me remind you there's been many, many examples of attacks in sort of cryptography distributed systems where they're academic until one day they're not. So it's totally possible that's what's going to happen with long range attacks as well.
00:25:06.270 - 00:25:57.502, Speaker A: And then if they are sort of something serious that we really should worry about, what is the best way forward? And we really just don't at the time of this recording, we just don't know. So it's going to be fascinating over the next few years to see how the evolution of our understanding of these attacks plays out. So that wraps up everything I wanted to say about long range attacks, probably more than you wanted to know. But buckle up because for the last two videos of Lecture Twelve that are coming up next, I'm going to tell you really way more than you wanted to know about comparisons between proof of work and proof of stake approaches to civil resistance. We talked about that a bit in part one, but now that. We know so much more about how proof of stake blockchain protocols work, we're going to be able to have a very detailed nuanced discussion and comparison between those two approaches. So I'm looking forward to it.
00:25:57.502 - 00:25:59.290, Speaker A: Hope I'll see you there. Bye.
