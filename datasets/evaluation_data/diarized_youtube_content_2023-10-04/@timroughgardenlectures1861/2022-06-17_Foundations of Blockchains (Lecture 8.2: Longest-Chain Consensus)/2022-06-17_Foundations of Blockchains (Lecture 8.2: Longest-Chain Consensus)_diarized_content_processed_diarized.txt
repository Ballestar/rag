00:00:00.570 - 00:00:44.470, Speaker A: So let's talk about longest chain consensus. And in this lecture, for continuity, let me tell you about longest chain consensus in the permissioned setting. So with a known set of nodes like we've been working with in the last several lectures, now, mind you, maybe the biggest win you get from longest chain consensus is how gracefully it extends to the permissionless setting, where actually you have no idea what are the node is running the protocol. But don't worry, that's going to be the next order of business. So in lecture nine, we will extend the longest chain consensus protocol that we talk about in this lecture. We'll extend it to the permissionless setting by blending in a second idea, something known as proof of work that we'll be discussing in the next lecture in lecture nine. So a quick side comment.
00:00:44.470 - 00:01:45.518, Speaker A: So let me remind you that a recurring theme in this course is we're going to emphasize principles over protocols. And again, in many treatments of blockchain, what people do is they tell you sort of specifically how one particular protocol works, with Bitcoin being the most frequent example. Now, don't get me wrong, I totally understand how satisfying it is to take a sort of very important piece of software in the world like the Bitcoin protocol and understand in detail kind of step by step how it works. Now, again, my goal is not to teach you how any particular protocol, bitcoin or otherwise works. That said, we will as a byproduct learn how various blockchain protocols work in this lecture series. But I'm really trying to teach you kind of the basic building blocks that we currently have at our disposal from which we can assemble various different blockchain protocols. And if you just study Bitcoin for Bitcoin's sake, you wind up kind of smushing together, conflating a lot of different, really sort of distinct ideas that go into the protocol, ideas that don't necessarily have to be bundled together, that could be mixed and matched with other building blocks in the design space.
00:01:45.518 - 00:02:51.582, Speaker A: So this lecture we're going to focus squarely on one innovation of the Bitcoin protocol, namely its use of longest chain consensus, its embrace of forks, and this in protocol way of resolving the ambiguity that's introduced by forks. And again, this is all super novel, even in the permissioned setting, it's exploring a different part of the design space than any of the previous protocols had done and thereby offers a different set of tradeoffs. Next lecture will isolate a second innovation of the Bitcoin protocol, which is the use of something called proof of work in the context of consensus protocols. And it's this ingredient, this idea, which will allow us to very gracefully extend what we do in this lecture on the permission setting to the permissionless setting where you actually have no idea which nodes are even running the protocol. Now, I'm going to be trying to keep these two conceptually distinct concepts sort of as separate as possible. So on the one hand, given a whole bunch of blocks that have been proposed, how should you in protocol figure out which ones have been confirmed, which ones count? That's what longest chain consensus addresses versus who is it that even gets to propose those blocks in the first place. That's what proof of work solves in a permissionless setting.
00:02:51.582 - 00:03:49.234, Speaker A: So I have to warn you, I'll be able to keep them mostly separate, but they inevitably interact a little bit at the interface, at their edges. So there will be one point in this lecture, and I'll be very explicit when we get to it or the way I describe longest chain consensus and also sort of what an adversary might be able to do to manipulate it. That description will be influenced by the fact that in the next lecture we will be doing the selection of block proposers using a proof of work solution. So two really separate things in your mind, keep them separate. First of all, what's the rule for deciding which transactions actually count given a whole bunch of blocks that have been proposed? That's what longest chain consensus addresses. And then secondly, who is it who gets to propose those blocks in the first place, that's what proof of work addresses the combination of these two things, longest chain consensus with block proposers being selected through a proof of work mechanism. Those are probably the two biggest ideas in the bitcoin protocol.
00:03:49.234 - 00:04:42.070, Speaker A: And sometimes you hear people say Nakamoto Consensus to mean the combination of longest chain consensus with proof of work mechanism for selecting block proposers. All right, so let's really get into it and understand how longest chain consensus works. To be honest, I struggled a bit with trying to figure out the best way to explain longest chain consensus because I kind of want to address a couple of different audiences simultaneously. So maybe some of you out there don't really know much about blockchains or about consensus other than what you've already learned thus far in this lecture series. And of course, we've only been focused thus far on the permissioned setting where you have a known everybody sort of knows the nodes running the protocol in advance. We're also going to be thinking about the PKI setting where all of the nodes, public keys are known to everybody in advance. So that's going to be one audience where you're already kind of attuned to this permissioned plus PKI setting.
00:04:42.070 - 00:05:25.342, Speaker A: And then the second audience is going to be those of you that actually have some familiarity with so called permissionless blockchain protocols, bitcoin and Ethereum being two canonical examples. So these are protocols where you do not have advanced knowledge of who's running the protocol. Rather, any random person can go sort of download a reference client from the web and start running the protocol themselves. So the people running the protocol in a permissionless setting, they're coming and going. And you have no idea who they are, but you'd still like the protocol to retain consensus among the nodes that are running the protocol. So I'm going to basically be addressing both those audiences at the same time. In some sense, the primary focus of this lecture will be on the permissions plus PKI setting.
00:05:25.342 - 00:05:59.934, Speaker A: So if that's what you're comfortable with, then you should just sort of follow sort of the main part of the narrative. There is going to be a fair number of comments that are basically kind of forward pointers to the permissionless consensus protocols that we're going to talk about. In fact, two different genres of permissionless consensus protocols. Proof of work. Protocols, which we'll talk about in detail in Lecture Nine, and also proof of stake protocols, which we'll talk about in detail in Lecture Twelve. So if you don't know what these two phrases mean, if proof of work, proof of stake, civil resistance, if all those concepts mean nothing to you, don't worry about it at all. That's really not a prerequisite for understanding lecture eight.
00:05:59.934 - 00:07:16.662, Speaker A: And like I said, we'll cover those topics in detail in lectures nine and twelve respectively. But so even though I want to emphasize that understanding proof of work or proof of stake is not a prerequisite for understanding the main points of this lecture, I do still want to make a number of comments along the way for viewers who are familiar with some of those concepts. For example, maybe you've studied proof of work blockchains that use longest chain consensus like say, Bitcoin or the original version of Ethereum, or maybe you've even studied some proof of stake protocols that use longest chain consensus, with Cardano and Tazos being two notable examples. So that's the first reason I'll make a number of comments about proof of work and proof of stake blockchains because hopefully those comments will resonate with some viewers that have the relevant experience. There's also a second reason I'm going to actually include lots of forward pointers to our future lectures on permissionless consensus. The reason is that's where you really get the payoff of the novel idea of embracing forks and resolving forks in protocol, where that really pays off is in the permissionless setting. So in particular, the longest chain consensus works particularly well in the synchronous model.
00:07:16.662 - 00:08:26.830, Speaker A: So that was the same sort of relatively strong assumption about the reliability of the communication network that we studied in lectures two and three, where there's an OPERATORI known bound capital Delta on the maximum delay that any message might possibly suffer. And you assume that literally every message ever delivered arrives there within capital Delta timesteps. So like for a protocol over the internet, maybe you'd set capital delta to be the equivalent of 10 seconds and then on a good day in the internet, all of the messages are going to be arriving there within the stated time bound. So we will sort of briefly talk about the partially synchronous model at the very end of lecture eight just to sort of stress test longest chain consensus and see sort of what breaks down when you do have network outages and attacks. But for most of the lecture we're going to be proving kind of positive results about longest chain consensus and those are all going to be in the synchronous model with this bound on message delay. And I have to warn you, when we're talking about the synchronous model and when we're talking about the permissioned version of Longest chain Consensus, given that we're using the PKI assumption, I have to warn you, that version of longest chain consensus synchronous permissioned. PKI.
00:08:26.830 - 00:09:45.158, Speaker A: That's basically a strictly inferior version of a state machine replication protocol that we saw a long time ago. Way back in lecture two. Remember in lecture two, we were also using those three assumptions, permissions synchronous, PKI, we reduced state machine replication to Byzantine broadcast. We showed how to solve Byzantine broadcast using the dole of strong protocol and that satisfied termination agreement and validity even if you had 99% Byzantine nodes, which meant we got a state machine replication protocol satisfying consistency and liveness even if there's 99% Byzantine nodes. And what we're going to get here from longest chain consensus is we're going to get consistency and liveness only when you have at most 49% Byzantine nodes, not 99% like we got in lecture two, but 49%, which is not nothing. That's still an interesting guarantee, but it is that version of longest chain consensus in the permissioned model with PKI is strictly dominated by the one derived from dolev strong. So it's once we pass to the permissionless case and we involve civil resistance mechanisms like proof of work and proof of stake in lectures nine and twelve, then we will be getting fundamentally new protocols that are going to be doing things that no consensus protocols we knew about before will be able to do.
00:09:45.158 - 00:10:59.562, Speaker A: Okay? So that's the sense in which the true payoff of longest chain consensus is in the permissionless case. But again, I really want to sort of tease apart on the one hand this idea of sort of in protocol embracing and resolution of forks versus the quite separate notion of civil resistance which we'll tackle in lectures nine and twelve. So here's what's going to be happening on this slide. On the left part of the slide, I will be writing down the high level pseudocode for how longest chain consensus operates. And so for those of you that are totally new to all of these concepts, I would at least on a first viewing, just focus on the left part of the slide, just get a sense for like as an algorithm, what is it that longest chain consensus is doing now? On the right hand part of the slide I'm going to be writing down a number of assumptions and these will be the assumptions under which longest chain consensus has the properties that we want. Specifically, it's going to have as a state machine replication protocol, it will have consistency and liveness with up to 49% Byzantine nodes. The description on the left is going to be relevant simultaneously for the three different settings I mentioned, the ones sort of written down in magenta at the top of the slide, permission plus BKI, permissionless, proof of work, permissionless, proof of stake.
00:10:59.562 - 00:11:49.082, Speaker A: So the description on the left will be relevant simultaneously for all three of those settings. And then the assumptions I'm going to write down on the right hand part of the slide. I'll make some comments about how you enforce those assumptions with a concrete instantiation of longest chain consensus for each of the three settings the permission setting, the proof of work setting, and the proof of stake setting. So first of all, every longest chain consensus protocol has baked into it a notion of a genesis block. So this is a block that doesn't have any transactions, but it's just sort of hardwired into the protocol so everybody knows where the blockchain is going to start. And so that will immediately bring us to our first assumption, which is really just going to be a trusted setup assumption. So we're not going to enforce this assumption inside the protocol itself because it's actually an assumption about the deployment of the protocol.
00:11:49.082 - 00:12:22.030, Speaker A: Specifically, we will assume that the genesis block b zero that is not chosen by an adversary. So the Byzantine nodes didn't get to choose what it is, nor did Byzantine nodes have advanced knowledge of what the genesis block was going to be. So that's going to be our trusted setup assumption. It's exactly the same for all three of the settings permission, proof of work, proof of stake, whatever. It's just going to be a trusted setup assumption. So we're going to remain silent on why this might be true. We're not going to worry about somehow enforcing it in the concrete implementation of the protocol.
00:12:22.030 - 00:13:07.846, Speaker A: In the same way that we assume that an adversary didn't tamper with the code running the protocol in any of our honest nodes, we're going to be assuming that an adversary wasn't privy to the genesis block in advance. So returning to the pseudocode, the way I'm going to describe longest chain consensus is going to be a notion of rounds and the blockchain is going to grow larger in each round. So the appropriate interpretation of what a round means is going to be different for different settings. So the permission setting versus the proof of work setting versus the proof of stake setting. In the permission setting, you're sort of already familiar with this. We've seen a bunch of protocols where there's a notion of sort of time steps or rounds and for example, nodes take turns as leaders across the rounds. So permissioned and synchronous setting, it's going to mean much the same thing.
00:13:07.846 - 00:13:44.866, Speaker A: We're thinking about a global shared clock. You somehow split time into sort of intervals and each of those intervals is going to correspond to some round. So obviously the amount of time in a round should be long enough to do something interesting. So maybe it's for example, long enough that the nodes can do one invocation of the dole of strong protocol in a given round. The interpretation in proof of stake protocols is going to be basically the same. Typical proof of stake protocols also have a sort of shared notion of time. You sort of split time into time steps, where a time step is such that some particular computation is supposed to happen.
00:13:44.866 - 00:14:46.406, Speaker A: Now, interestingly, in proof of work longest chain protocols like bitcoin, for example, the rounds are not going to correspond to sort of intervals of time except in sort of a very loose average sense. In fact, for those kinds of protocols, bitcoin included, you actually do not need to assume that the nodes have a shared global clock or any reasonable approximation of it, which is pretty remarkable property. So rather, rounds there are defined in a purely event driven way. So if you know a little bit about proof of work, you know that basically people are sort of trying to produce blocks and they need to sort of solve these hard crypto puzzles to earn the privilege of producing a block. And basically whenever some node solves one of those crypto puzzles and sort of gets the keys to produce the next block, we're just going to call that the next round. So in a proof of work context, the rounds just correspond to the events of the nodes successfully solving crypto puzzles and producing blocks. And again, if all this proof of work proof of stake commentary is kind of over your head, don't worry about it.
00:14:46.406 - 00:15:20.978, Speaker A: Just think of round just corresponding to some block of time steps, just like in all the other permissioned protocols that we've discussed thus far. So what is it that happens in a round? Well, the first thing that happens is one of the nodes, and this will sound familiar, one of the nodes is chosen as a leader. So how does this leader get chosen? Well, that really depends on which of these three settings we're talking about. Permissioned versus proof of work versus proof of stake permissioned. You should have a good idea of how this might go. For example, you could just use round robin, right? In the permission synchronous setting there's a global shared clock. Everybody knows what time it is, everybody knows exactly what the nodes are.
00:15:20.978 - 00:16:08.942, Speaker A: So everybody knows, for example, if there's 100 nodes and it's currently time step 107, everybody knows that node number seven is the current leader. At a high level, you should think of what's going on in proof of stake blockchains as being pretty much the same thing that's going on in the permissioned case, except with the leaders chosen each round uniformly at random, rather than using a deterministic round robin order. That's not quite right. It's not quite right that you choose one of the nodes running the protocol uniformly at random. Rather you choose one with probability proportional to their stake. So usually nodes have sort of put some money in escrow on a proof of stake blockchain. And then if you own a 10% amount of the stake that's in escrow across all of the nodes, you're going to have a one in ten chance of being selected as the leader.
00:16:08.942 - 00:16:59.518, Speaker A: There is definitely more nuances there and we'll discuss those in lecture twelve. But high level think of proof of stake is like the permission case, right? Each round corresponds to sort of a time interval and then somehow we'll talk about how this is done in lecture twelve. Somehow one of the nodes is chosen randomly as a leader. The idea in proof of work blockchains is similar except that rather than sampling some node to be the leader with probability proportional to some locked up stake, you select a node with probability proportional to the fraction of the overall computational power that they're contributing to the protocol. We mentioned how you don't really have a notion of time steps in the proof of work case. You just have these would be block producers trying to solve these hard crypto puzzles. And basically, whoever's the first one who solves that hard crypto puzzle, that's going to be by definition the leader of the ensuing round.
00:16:59.518 - 00:17:58.734, Speaker A: So we're going to need a couple of assumptions about this selection of a leader in step two, a of longest chain consensus. And unlike our first assumption, our trusted setup assumption that Nakamoto wasn't mining Bitcoin back in 2004, unlike that assumption, which we just sort of take on faith, these next assumptions is really important that we enforce them in a concrete instantiation of the protocol. So maybe an analogy would help to convey what I mean. So remember like way back in our first lecture or two, we introduced this notion of the ideal signatures assumption, this idea that there should be digital signature schemes so that signatures are unforgivable on messages you haven't seen before, unless you happen to sort of know the appropriate private key. So that was just an assumption. So we said let's assume we can sort of produce unforgivable signatures and now let's look at the cool things we can do. Like we can do the dole of strong protocol for Byzantine broadcast separately.
00:17:58.734 - 00:18:55.106, Speaker A: You then have to say like, okay, but if you really had to implement this protocol, how would you implement it so that that assumption really was true or for all practical purposes true, that signatures were unforgivable. And the answer there is, well, that problem was solved several decades ago. You would use one of the well known secure digital signature schemes like for example, ECDSA. So the next couple of assumptions I write down on the right hand part of this slide, they're really just going to be sort of analogous to the ideal signatures assumption. We will assert them, we will then investigate if they are true, what properties does our protocol have? And then separately in a specific instantiation we'll ask, okay, how do we make sure that those assumptions actually are true? Okay, so assumption number two is that the election of a leader should be verifiable. And I mean that in two senses. So first of all, if you are chosen as the leader of around, you should be able to prove that fact to all of the other nodes running the protocol.
00:18:55.106 - 00:19:49.970, Speaker A: And then conversely, if you're not the leader of a current round, there's no way you should be able to trick the other nodes into thinking that you are the leader of that round. This assumption will mostly take care of itself in the specific instantiations of longest chain consensus. We're going to be looking at like if you're in the permission setting and you have the PKI assumption, this is not a hard assumption to enforce, right? I mean there's already a shared global clock. There's already sort of a globally known set of node names. So everybody knows in advance without any communication which node is the leader of each round, right? If there's 100 nodes and it's round number 107, everybody knows that node seven is the leader of that round. And of course with the PKI assumption everybody knows the public key for node number seven. So whatever node number seven wants to say as the leader of times of round 107, it can just sign it with its private key and everybody else will be fully convinced that those are the appropriate messages.
00:19:49.970 - 00:20:38.098, Speaker A: And similarly, anyone who's not node number seven will not be able to trick anybody into thinking that they were in fact the leader of that round of round 107. It'll turn out that the permissionless cases also sort of work out in a pretty simple way both proof of work and proof of stake. As we'll see when we study those in depth, we'll see that basically being a leader kind of means having a proof that you're a leader. That's almost like the definition of what it means to win this election in step two A. So the next assumption also very important. It needs to be the case that nodes, and in particular Byzantine nodes have no ability to influence the selection of a leader in step two A of the protocol. So this again is an assumption that we're going to sort of in any concrete implementation, we need to make sure that this assumption gets enforced.
00:20:38.098 - 00:21:41.046, Speaker A: Now if we're working in the permissioned setting, this assumption is not a big deal, right? There's a known node set shared global clock. There's this round robin order. Literally the entire sequence of leaders till the rest of time is common knowledge at the start of the protocol. So obviously none of the nodes can manipulate who's the leader when in the permissioned case, much more interesting to talk about the permissionless case, although here honestly proof of work as we'll see in lecture nine and as practiced in for example bitcoin things work out actually in sort of a very simple way. So under something known as the random oracle assumption for cryptographic hash functions that basically says that all of these would be block producers trying to sort of crack a hard crypto puzzle to earn the privilege of producing a block. Basically there's nothing you can do to solve those crypto puzzles other than just randomly guess keep throwing darts at a dartboard until you sort of by luck hit a bullseye. And so from that it follows that there's really no way you can manipulate the probability that you're going to be selected.
00:21:41.046 - 00:22:32.154, Speaker A: You're going to be selected with probability proportional to the number of darts that you throw and there's really nothing else you can do about it. This issue is quite a bit trickier in the proof of stake world and indeed sort of many early proof of stake blockchain designs did not do a good job of enforcing this assumption. Newer designs do do a much better job of enforcing this assumption. Just to give you kind of a sense of why is it harder for a proof of stake than for proof of work? In a proof of work protocol you kind of have this natural external source of randomness. You have all of these, all your nodes are sort of throwing darts at a dartboard. One of them is going to get lucky and hit the bullseye first and then that gets kind of imported into the protocol as the winner of this election as the node gets selected as a leader in step two A. So the state machine replication protocol in some sense isn't really responsible for figuring out who the leader is.
00:22:32.154 - 00:23:47.278, Speaker A: It's almost like this sort of external natural process of people throwing darts tells you who the leader is. Proof of stake blockchains meanwhile, or at least sort of most of the designs are kind of hermetically sealed environments, meaning that all of their computations kind of use only things that are known to the protocol itself get an original code of the protocol and then also a transcript of what's happened in the protocol thus far. There is no external source of randomness, there's no analog of the people outside the protocol throwing darts at the dartboard. And as soon as the protocol is itself responsible for pseudorandomly kind of selecting leaders in step two A, based on the only information it has, which is kind of like the protocol code in the history of the protocol, thus far. All of a sudden you got to start worrying about well, maybe nodes are now going to try to actually kind of manipulate the history of the protocol thus far so that it somehow biases future pseudorandomness in favor of that node. So that's why proof of stake design gets quite tricky around this assumption. Again, there's some cool ideas to deal with this that we'll talk about in lecture twelve, but you do seem to need at least moderately fancy cryptographic primitives in order to enforce this in a proof of stake context.
00:23:47.278 - 00:24:20.938, Speaker A: All right, so going back to the protocol code, let's talk about the last step, step two B. So what is it that a leader gets to do in a given round? R, it gets to create some number of blocks. And here, by a block, as usual, we mean an ordered sequence of transactions. If the wand, the leader can create nothing. If it wants, it can create one block. If it wants, we're going to allow it to create multiple blocks in a given round. However many blocks the leader creates, each of those blocks must specify a predecessor block.
00:24:20.938 - 00:25:04.026, Speaker A: So if you have a block that doesn't have a predecessor specified, or that specifies some nonexistent predecessor, that block doesn't count. All the honest nodes are going to ignore it. So to have any chance of sort of being counted, each block must have a predecessor to some other existing block. If nothing else, it could be the Genesis block. So this is a departure from what we were doing in our BFT type protocols, like, say, Tendermint that we discussed in lecture seven. Remember that, like in Tendermint, assuming that less than a third of the nodes are Byzantine, we really showed you're never going to have two different sort of block number eight. Right? To be finalized, a block needs a supermajority of the votes, and if less than a third of the nodes are Byzantine, you can't get a supermajority on two different blocks for the same height.
00:25:04.026 - 00:25:54.218, Speaker A: So there's only going to be one block number eight, there's only going to be one block number nine, only one block number ten, et cetera. So at that point, you don't need to write down the predecessors, it's obvious what they are. Right? The predecessor of block number nine is block number eight. But in longest chain consensus, remember, we're going to allow forks. So we are going to freely allow there to be multiple blocks that are the potential block number eight, multiple blocks that are the potential block number nine. And as soon as you allow sort of multiple blocks sort of at the same height, now, you really do need explicit backpointers, right? So one of the sort of blocks at height nine needs to specify which of the height eight blocks is the one that it views itself as following. So that concludes the description of the basic protocol, the basic idea of longest chain consensus.
00:25:54.218 - 00:26:54.542, Speaker A: Already, even at this level, we can see that we can fruitfully visualize the data structure being grown as an intree. Intree, meaning a tree in the sense of a graph that's connected in a cyclic that's directed, and where all of the edges are. Directed sort of toward the genesis block. Genesis block acts as the root of this entry. So why do the blocks form an entry? Well, it's just that we can visualize the blocks that have been created as vertices of a graph that have out degree, exactly one, with each vertex having a directed edge directed to the vertex that corresponds to the predecessor block. So you'll notice here in the orange picture I've drawn on the lower left, you can see there's a single arrow pointing out of every single block except for the genesis block which acts as a root. Notice that you can have multiple blocks claiming the same other block as the predecessor, right? So it's true that all of the out degrees are exactly one except for the genesis block, but the in degree could be potentially large.
00:26:54.542 - 00:27:52.174, Speaker A: And you can see in that picture the genesis block as well as one of the other blocks actually has integrity two. So the picture you should have in mind is that when you first fire up this protocol, sort of all there is is b zero, all there is is the genesis block. And then as the protocol continues, rounds keep sort of passing. You have leaders, they create new blocks, you get this sort of tree growing from left to right with all of the newly created blocks pointing back, pointing to the left to whichever block they're claiming as a predecessor. The extremely eagle eyed among you may have noticed that what I've said so far actually doesn't rule out that there might be some weird directed cycle sort of floating around distinct from this orange entry. So this next assumption, assumption four, this is not the most important thing it does, but it will in particular rule out the possibility of any directed cycles in the entry. It really truly will just be a single entry like is written on the bottom left of this slot.
00:27:52.174 - 00:28:46.706, Speaker A: And so this assumption states that every block created in round R must as its predecessor, refer to some block created in a previous round r minus one or less. So this fourth assumption, like the second and third ones, this is something we're going to have to take care to enforce in any concrete implementation of longest chain consensus. It's not obvious from what I've written on this slide so far why a four should be satisfied. Now your first reaction may be, wait a minute, is this really assumption, why isn't this just like true? Why isn't it true that you can't refer to something that doesn't exist yet? But let me point out two things that we would be worried about. Worry number one would be remember that in step two B, we're allowing a Byzantine node to create as many blocks as it wants in a given round. Now, as we'll see, an honest node is supposed to only create a single block in step two B. But Byzantine node can create as many as it wants.
00:28:46.706 - 00:29:27.886, Speaker A: And so in particular it could sort of create a set of round R blocks that point to each other. So that would be a violation of assumption A four. We have to make sure that that's not possible. The other thing we're sort of worried about is the possibility of a Byzantine node kind of delaying its announcements. So like, imagine you had a Byzantine node that was elected the leader at round number 17, and then imagine it kind of didn't send any messages to anybody and it just watched the protocol proceed for ten more rounds up to round like number 27. And then it sort of says, oh, by the way, here are my round 17 blocks. And it specifies as predecessors some of the blocks that were created in the meantime in between rounds 18 and 27.
00:29:27.886 - 00:30:21.282, Speaker A: So that would also be a way that a potential way that a Byzantine node could violate this assumption A four. So those are the two things in our concrete instantiation we have to make sure that Byzantine nodes aren't able to do. So this fourth assumption, to be honest, it's actually not really that hard to enforce in any of the concrete instantiations we're going to be looking at. Like, for example, think about the permission setting and let's also assume the synchronous model and as usual, the PKI assumption. So for example, one trick you can do is you can have blocks expire. So to prevent a Byzantine node from sort of announcing a block well after the round in which it was the leader, you can just have honest nodes ignore any blocks they hear about that belong to rounds considerably before the current time step. You still could have, say, a Byzantine node kind of announcing a whole bunch of blocks in round R on time, but having them sort of point to each other.
00:30:21.282 - 00:31:09.086, Speaker A: So round R blocks claiming other round R blocks as predecessors. But again, honest nodes can just detect that. Remember, we're assuming that blocks are sort of annotated with the round number and signed by the corresponding leader. So all the nodes can see that these round R blocks are pointing to other round R blocks and know to ignore all of them, or maybe all but sort of the earliest one. Proof of stake blockchains use roughly the same circle of ideas to enforce this assumption a four proof of work blockchains. Actually, this assumption just sort of takes care of itself. The reason for that, as we'll see in next lecture, in lecture nine, is that in effect, in proof of work, a node has to specify its predecessor before it's actually notified whether it's the leader of the next round.
00:31:09.086 - 00:32:17.986, Speaker A: So in effect, the winning lottery ticket saying that you are the leader of the next round, the winning lottery ticket has encoded in it which predecessor block you must use. And of course it can only be some block that existed at the time that you entered the lottery. So it would have been something prior to the round in which you are now going to be producing a block. So let me point out an immediate consequence of enforcing this assumption, which is that if we succeed in enforcing a four, we will also wind up enforcing the property that a given leader can only contribute at most one block to any given chain. Right? So why is this true? Well, assumption A four says that if you start from any block in the current entry and trace backward toward the Genesis block, by assumption A four, the round numbers are only going to be strictly decreasing until you get back to the Genesis block, which in some sense is round number zero. So in particular, you cannot have two blocks belonging to a common round R on any given chain. So it's true that a Byzantine node can produce can create multiple blocks in step two B if it's chosen as the leader.
00:32:17.986 - 00:33:00.566, Speaker A: So for example, it could create like a whole bunch of blocks that all sort of point back to exactly the same predecessor. That's totally allowed. It's not going to be able to add more than one block to any particular chain. If it tries to sort of add a whole bunch of a big chain of round R blocks, the honest nodes are going to know to ignore all but for example, the first of those blocks. In proof of work blockchains, you actually get sort of a much stronger property just kind of for free because of how they're implemented, which is, as we said, the winning lottery ticket you get in a proof of work blockchain. It actually includes encoded in it exactly which block you must extend. And not only that, it even encodes exactly which block, like which transactions you must be extending that block with.
00:33:00.566 - 00:33:54.994, Speaker A: So the lottery ticket takes away all your degrees of freedom. In step two B, there's literally only one thing you can do even as a Byzantine node in step two B, if you're using a proof of work blockchain. So if you can only create one block in total, obviously you're only adding most one block to any particular chain in the entry. But I want to emphasize that stronger property is not what is driving the fundamental consistency and liveness guarantees of longest chain consensus. We will prove consistency and liveness assuming only this assumption A four, which I've stated, we will not need the stronger properties you get from for example, Bitcoin and its proof of work civil Resistance mechanism. There are other aspects of proof of work that are useful in various ways. But again I want to emphasize only by crisply articulating exactly which assumptions the analysis requires.
00:33:54.994 - 00:34:42.262, Speaker A: Only through this exercise do we realize fundamentally what it is about Bitcoin that gives it its consistency and liveness guarantees. And now that we understand that it's only these four assumptions, and not for example the stronger assumption that it should be that byzantine node can only create one block in step two B. Now if we wanted to for example, replicate the consistency and liveness properties of bitcoin with a proof of stake implementation of longest chain consensus now we know exactly what we need to do. We need to meet assumptions A one through a four. It is totally fine if we're not able to replicate the stronger property of bitcoin that you can only have one block proposed per round our final assumption, assumption A five. This will have a different character. This will be a temporary assumption for lecture eight.
00:34:42.262 - 00:35:35.586, Speaker A: This is going to be something we're going to relax later. So we're not worried about enforcing this. We're worried about understanding longest chain consensus under assumption A five and then we'll extend all of our conclusions without assumption A five. This assumption is going to be that we're working in what I'm going to call either the instantaneous communication model or I might also call it the super synchronous model. So intuitively in your mind you should think of it that as soon as one honest node knows anything like knows about some block instantaneously all of the other honest nodes know about that exact same block as well. And probably the simplest way to think about this assumption and the reason I sometimes call it the supersynchronous model it's basically like the synchronous model. If we take parameter delta to be equal to zero, if we're thinking about a protocol where every honest node always keeps all of its colleagues up to date, always tells them everything it knows, if there's no message delay then instantaneously.
00:35:35.586 - 00:36:31.786, Speaker A: Once a node learns something, all of the other nodes learn it at exactly the same time. Now you should of course object to this assumption. I mean one objection would just be that it's not very realistic in the real world, delta is not zero. So who am I to say that it is zero? I think an even more sort of powerful objection would be to say wasn't the whole point of state machine replication this problem we've been obsessed with? Wasn't the point to keep a bunch of nodes in sync? Wasn't that like the hard problem? And hasn't this just completely trivialized that hard problem? Now I'm basically just assuming that all of the nodes stay in sync with each other. I mean there's still liveness but consistency, it kind of seems like we've completely trivialized it and that'd be a good comment, that'd be a good criticism. I mean to some extent that is true. We are assuming that any pair of honest nodes at a given moment in time are consistent with each other, have the same local histories of the transactions they view as sort of confirmed or finalized to date.
00:36:31.786 - 00:37:48.338, Speaker A: But consistency also has a second aspect which is sort of consistency with your future self in the sense that we sort of disguised this in our previous discussion by referring to the local history as an append only data structure. So if it's an append only data structure, obviously your transcript right now, your local history right now is a prefix of what it is at any future point. What we're going to see in longest chain consensus is that there's a very real danger of transactions first being regarded as confirmed or finalized and added to the local history, but then because of other things that happened with the protocol getting rolled back so sort of deleting from that data structure. So this consistency with one's future self, this kind of actually really implementing an append only data structure will sometimes call this self consistency, we'll call it finality. And as we'll see, finality is not at all trivialized by this assumption of the instant communication model. It's still actually quite tricky to prove this self consistency, this finality property of longest chain consensus, even in this sort of supersynchronous instant communication model. Now, if we happen to be in this permissioned and synchronous and PKI world, then actually this assumption a five is really just not that big a deal.
00:37:48.338 - 00:39:01.206, Speaker A: It's true delta is not equal to zero, but we can use off the shelf, we can use the dole of strong protocol for Byzantine broadcast to nonetheless, in effect keep all of the honest nodes completely in sync just all the time. If in each round of longest chain consensus the honest nodes run the dole of strong protocol by the agreement property of that protocol, they'll always wind up learning exactly the same stuff at the end of every round. So just kind of as a consequence of that protocol's guarantees honest nodes will stay in sync throughout longest chain consensus. So what's more interesting is the permissionless case and we will then have to go back and sort of revisit this assumption a five and start relaxing it in particular. We'll do that in lecture nine. But let me just tell you right now, all of the guarantees we prove in lecture eight, we'll prove a bunch, all of the guarantees for longest chain consensus carry over to the normal synchronous model with an arbitrary but known bound capital delta on the maximum message delay. What's important for that statement to be true is it should be that the typical length of a round, the amount of time that elapses during around should be reasonably large relative to capital delta, the maximum message delay.
00:39:01.206 - 00:40:18.638, Speaker A: As long as that is true, you get basically exactly the same consistency and liveness guarantees from this lecture more generally in the synchronous model. So we're going to be proving a lot of guarantees about longest chain consensus in this lecture, in lecture eight for the instantaneous communication model. And believe it or not, despite the fact this model seems very extreme, all of the difficult and interesting parts of the proofs of these guarantees will already manifest in this model, in the instantaneous communication model, extending those results to the general synchronous model, it takes some work, got to do some math. But honestly, all of the big ideas, all of the sort of parts of the proof that explain to you why longest chain consensus really works, really satisfies consistency and liveness with 49% Byzantine nodes, all of those ideas are already going to be present here in lecture eight in the instantaneous communication model. So let me say a few words about where these five assumptions are going to wind up showing up in the forthcoming videos. So in this lecture, in lecture eight, we're going to prove a number of sort of appealing guarantees that longest chain consensus has. And our analysis of longest chain consensus is going to be somewhat modular in the sense that we're going to factor the analysis into two parts that can be studied separately.
00:40:18.638 - 00:41:20.550, Speaker A: In the first part, we're going to assume a particular condition holds on the sequence of leaders that get selected in step two A over the course of all of the rounds. So most of our results in lecture eight are going to have the form if the sequence of selected leaders has a particular property, it's going to be a balancedness property. As we'll see, if the leader sequence has a particular property, then we get everything we want and in particular consistency, and liveness as long as there's at most 49% Byzantine nodes. So in this part of the analysis, which is going to start in the fifth video of lecture eight, it's going to be very obvious how we use a couple of these assumptions. So in particular, assumption A four will be very explicit about the role that it plays in the proofs initially in that fifth video, to prove something known as the common prefix property. And it should feel intuitively clear, as we do, that proof that assumption A four is sort of really crucial for longest chain consensus to have the guarantees that we want. So it's really paramount that any concrete implementation of longest chain consensus manages to enforce assumption A four.
00:41:20.550 - 00:42:13.862, Speaker A: In this same part of the analysis of longest chain consensus, again, beginning with the fifth video, I think it should also be clear, it'll be clear how we use assumption A five, the sort of instant communication model. So it should be obvious that the assumption plays a role. I think it will also be clear from the argument that A five is overkill and that actually, basically the same argument should work with maybe sort of a slightly more complicated proof in the general synchronous model. So where you have an arbitrary known upper bound capital delta on the maximum message delay, at least as long as the time that elapses in a single round is large relative to the network delay capital delta. All right, so assumptions A four and A five, it'll be very obvious how we use them. Starting in the fifth video, again, a four is really essential to the argument a five is overkill. You can replace that by just assuming that you're in the sort of regular synchronous model.
00:42:13.862 - 00:43:11.030, Speaker A: It turns out we're also going to use assumption A one in that same part of the analysis. So in the fifth video when we prove the common prefix property, it's pretty subtle where that shows up in the proof. So keep an eye out and see if you can identify in the proof of the common prefix property where it is that we use the assumption that Byzantine nodes do not have advanced knowledge of the genesis block. Now don't forget this part of the analysis is conditional in the sense that we're going to be proving results that have the form. If the sequence of leaders selected in step two A over the course of the rounds, if the sequence of leaders satisfies a particular nice property, it's going to be a balancedness property. If that condition holds, then we get all of these nice consequences like consistency and liveness of longest chain consensus. But that still leaves us to argue that the leader sequence will or sort of is very likely to have this balancedness property.
00:43:11.030 - 00:44:14.374, Speaker A: So that is the subject of the other part of the analysis and it's in this other part of the analysis that assumptions A two and a three are going to play an important role. So the one part of this lecture, lecture eight, where we're going to be doing this other part of the analysis is going to happen in the fourth video. What we're going to show there is that if in each round a leader is selected uniformly at random from all of the nodes running the protocol, if each leader is selected randomly, then with high probability you're going to get a leader sequence that satisfies this nice balancedness property. So with high probability over the random choices of the leaders, we're going to get all of the properties we want like consistency and liveness. So I may not really say much about it, but in that fourth video we will be making the assumptions eight two and a three. We're going to be assuming that the protocol is capable of selecting a leader uniformly at random and there's nothing any of the nodes can do about it. And one reason we won't kind of talk about it much explicitly in that video is in lecture eight we're thinking of longest chain consensus in sort of a permission setting under the PKI assumption.
00:44:14.374 - 00:44:52.060, Speaker A: And as we discussed, assumptions A two and a three are actually pretty easy to enforce if you're in the permissioned PKI assumption. So where we're going to talk much more about assumptions A two and a three is when we talk about permissionless longest chain. So both the proof of work version in lecture nine and the proof of stake version in lecture twelve. At that point we're going to have to be very careful, especially in the proof of stake side. In lecture twelve we're going to have to be very careful to make sure that assumptions a two and a three do actually correctly hold. If we can make sure that a two and a three holds, then we can piggyback on the analysis of random leaders. We're going to do in the fourth video of this lecture of lecture eight.
00:44:52.060 - 00:45:48.790, Speaker A: So now that we understand what longest chain consensus is at a high level, now that we've established the parameters of what nodes can and cannot do in longest chain consensus, let's talk about what the honest nodes are supposed to do. Suppose an honest node finds itself selected as the leader in some round. Now it's responsible for choosing a block and a predecessor. So which block and which predecessor is it supposed to propose? Well, first the node is going to assemble a block, meaning a list of transactions in the usual way. So when a node becomes a leader, it says, okay, what transactions do I know about? Maybe a client told me directly or maybe I heard from some other node. Which transactions do I know about that haven't yet been executed, haven't yet been included in the blockchain and you're just going to produce a block that includes all of those transactions. And what about the predecessor? Well remember, at any given moment a node knows about a collection of blocks that form an intree directed into the genesis block.
00:45:48.790 - 00:46:37.290, Speaker A: So what an honest notice is supposed to do is look at this entry, look at the longest chain, meaning the largest number of hops any node is from the root from the genesis block and add its block to the end of the longest chain. So for example, in this orange entry on the right part of the slide, the longest chain would be three hops long. An honest node would then tack its block onto the end of that longest chain, making it even longer in the picture I've indicated in green where that new block would go if it were proposed by an honest node. Now I'm sure it's occurred to you that an entry might well have more than one longest chain. This one on the slide only has the unique longest chain, but you could have a second chain that also has the same length. And so then we're going to allow nodes to just tiebreak arbitrarily. So pick whichever longest chain you want and stick your block at the end of that.
00:46:37.290 - 00:47:19.206, Speaker A: You could imagine having a more specific tiebreaking rule. You could imagine that honest nodes are supposed to extend of the two ends of the longest chain, the one that they heard about first. You could imagine them tiebreaking randomly. And all of those things are sometimes done in practice. But for the analysis when we're proving consistency and liveness guarantees for longest chain consensus, we don't want to be relying on nodes sort of implementing some possibly delicate tiebreaking procedure. We want liveness and consistency no matter how they tiebreak among competing longest chains. The final thing maybe seems obvious, but it is something a byzantine node could deviate from, which is as an honest node in a round where you're elected the leader and you form a block, you should immediately broadcast that new block to all of the other nodes in the system.
00:47:19.206 - 00:47:51.202, Speaker A: So those are the three kinds of deviations by byzantine nodes that we have to worry about, deviations from honest behavior. As I said, the first one we're not really worried about. I mean maybe byzantine nodes sort of put together empty blocks, whatever. That's fine as long as there's a bunch of honest blocks out there as well. So on the third point totally possible. The byzantine node delays the announcement of some block and predecessor it committed to in some round in which it was selected as the leader. For today, for lecture eight where we focus on liveness and consistency, actually, this power of the adversary is not going to matter.
00:47:51.202 - 00:48:38.994, Speaker A: It's not going to interfere with our ability to get either consistency or liveness. It will make our proofs a little trickier right, because we'll have to handle this sort of more general adversary than an adversary. That's not allowed to delay the announcement of blocks, but it'll turn out to be fine for consistency and liveness. Now, while this power doesn't interfere with liveness or consistency, it actually does interfere with additional properties you might want a longest chain protocol to have. And we'll see that in two lectures in lecture ten when we discuss a famous selfish mining attack. So what selfish mining shows is that in a blockchain that uses block rewards, as for example bitcoin and ethereum do actually, if the block producers are profit maximizing, it may be in their interest to sometimes withhold the announcement of a block that they create. That may seem very counterintuitive, but we'll talk about it at length in lecture ten.
00:48:38.994 - 00:49:16.590, Speaker A: So for this lecture, lecture eight, deviations on this third point only serve to make our proofs of liveness and consistency even stronger in lecture ten. This will actually be a very important part of what we allow the adversary to do. Deviations from the second point. On the other hand, those should be immediately worrying and those will play a big role in this lecture. Why are they worrying? Well, honest nodes are trying to coordinate on a single longest chain. If everybody's honest, the longest chain just going to keep getting longer and longer and longer. On the other hand, if you have byzantine nodes and they extend something other than the longest chain, it's not just that the old longest chain doesn't get longer.
00:49:16.590 - 00:50:06.538, Speaker A: It also may be that they can switch what the longest chain actually is leading to a rollback of transactions, a rollback of blocks. So for example, if you have some number of K rounds in a row, like, say, ten rounds in a row, where you get unlucky and you happen to have a Byzantine leader in each of those ten rounds, they can actually, through deliberate forking, cancel the previous nine blocks that have been added to the longest chain. To see this, consider the following picture. So let little b denote the K to the last block on the current longest chain. So there's K minus one blocks currently after the block little b. So if we now have K dishonest leaders in a row, well, the first one can extend b rather than extending the longest chain. The next one can extend the block produced by the previous dishonest leader and so on, ten times in a row.
00:50:06.538 - 00:51:09.618, Speaker A: So the chain that ends with these Magenta blocks, these K blocks that were added consecutively by a bunch of dishonest leaders that's now the new Longest Chain and the last K Minus One blocks that used to reside on the Longest Chain, the K Minus One blue blocks that are following the Block little b, those are no longer on the Longest Chain. Those are now excluded, that's also sometimes called those blocks are orphaned. This is kind of the extreme case where you have a bunch of dishonest leaders in a row. And so, for example, if you have ten in a row, they cancel the last nine blocks on what used to be the longest chain. But if you think about it, you have exactly this same problem if you ever have a window in time with many more dishonest nodes, dishonest leaders than honest leaders. So, for example, if there's a sequence of 1000 sort of rounds in a row where you have 505 dishonest leaders and 495 honest leaders, so an imbalance of ten, it's again true for exactly the same reason that you can successfully orphan the last nine blocks on the old longest chain. And so that's a good exercise maybe, if you want to think that through.
00:51:09.618 - 00:51:54.106, Speaker A: So to wrap up this video, let me give you sort of three takeaways from this discussion. So takeaway number one is whenever you're looking at a longest chain protocol, you should always regard the last few blocks on the longest chain, the one sort of at the very tip. You should view them as kind of tentative, as not yet confirmed, still under negotiation in effect. So we should consider a block confirmed only if it's one on the longest chain, but sort of also two kind of fairly deeply ensconced on the longest chain. So already having been extended by a number of other blocks, you might be wondering how many blocks, so how many times you have to be extended before it's safe to consider that block to be finalized or confirmed. We'll tackle that sort of head on in the next video. So that's the first takeaway.
00:51:54.106 - 00:52:39.214, Speaker A: Don't sort of take the blocks at the end of the longest chain too seriously. Consider them unconfirmed and. Still under negotiation. The second takeaway is sort of looking ahead to the analysis we want to do in the next video. So presumably we're going to want to prove some kind of guarantee about longest chain consensus of the form. As long as sort of a block has been extended enough times on the longest chain, as long as it's deep enough on the longest chain, then you're safe to consider it finalized or confirmed, it's never going to be rolled back or canceled at any point in the future. And this example illustrates a kind of very basic obstruction to proving guarantees of that form, right? So this example says that whenever you have a sequence of leaders where there's significantly more dishonest leaders than honest leaders, well then some blocks might get rolled back and there's really nothing you can do about it.
00:52:39.214 - 00:53:29.486, Speaker A: So if we're going to prove any kind of guarantee, like once you've been extended ten times you're never going to get rolled back, we have to along the way prove that for some reason you're never going to see a sequence of leaders where you have ten more dishonest leaders than honest leaders. And indeed, when we do the analysis, you will see that is exactly the crucial ingredient. The third and final takeaway is this discussion should convince you that there's no hope of proving anything unless a strict majority of the nodes are honest. So at least 51% of the node should be honest. At most 49% should be Byzantine. For example, imagine 51% of the nodes are Byzantine. Now consider a sequence of sort of 1000 consecutive rounds, okay? We're expecting 510 of those leaders to be Byzantine and 490 of those leaders to be honest.
00:53:29.486 - 00:54:16.462, Speaker A: And if that happens, that means there's an excess of 20 dishonest leaders and they're totally capable of canceling the last 19 blocks on the current longest chain. And of course there's no reason to stop at 1000. You could also go to 10,000, at which point you're going to expect an excess of 200 Byzantine nodes within that window who can then cancel the last 199 blocks on the current longest chain and so on. So if you have a strict majority Byzantine nodes, there's really no hope. The Byzantine nodes ultimately can exert total kind of control over the blocks that get confirmed. So this argument shows that if you ever want to finalize a block, ever, it's definitely a necessary condition that you have at least 51% honest nodes, much less clear as whether that's a sufficient condition. And that's exactly what we'll show over the next several videos.
00:54:16.462 - 00:54:36.100, Speaker A: We'll show that as long as at least 51% of the nodes are honest, then in fact you can eventually regard blocks as confirmed a block that is both on the longest chain and has been extended a sufficiently large number of times. At that point you can be confident that it's not going to be rolled back at any point in the future. So we'll start that analysis in the next video. And I'll see you there.
