00:00:00.730 - 00:00:13.514, Speaker A: Hi everyone and welcome to this video that accompanies section 21.5 of the book algorithms Illuminated part four. This section is a very brief introduction to the world of Satisfiability or Sat solvers.
00:00:13.514 - 00:00:33.350, Speaker A: This is the second genre of semireliable magic box that we'll be discussing. So MIP mix integer programming solvers from the previous video, those are meant for optimization problems where you want optimize some numerical objective function subject to a bunch of constraints. But some problems that come up in applications aren't really optimization problems.
00:00:33.350 - 00:00:53.370, Speaker A: You don't have something you want to optimize, but you do want to know whether or not all of the constraints can be satisfied. That is, you want to know is there a feasible solution? And if so, you'd like to get your grubby little hands on one of those feasible solutions. So problems of that type, sort of feasibility, checking problems, can in many cases naturally be encoded as Satisfiability problems.
00:00:53.370 - 00:00:59.166, Speaker A: So whenever you have one of those problems that naturally lends itself to a Sat formulation, throwing a Sat solver at.
00:00:59.188 - 00:01:00.954, Speaker B: It is probably worth a shot.
00:01:01.082 - 00:01:07.074, Speaker A: Let's get a feel for how this might work through a concrete example. A famous problem we actually haven't talked.
00:01:07.112 - 00:01:09.380, Speaker B: About yet, the graph coloring problem.
00:01:10.710 - 00:01:24.438, Speaker A: The graph coloring problem is actually one of the oldest graph problems of them all. Already in the 19th century this was being studied quite intensively. So the input in the graph coloring problem is going to give you an undirected graph and I'm also going to.
00:01:24.444 - 00:01:27.766, Speaker B: Give you a positive integer, k. The.
00:01:27.788 - 00:01:43.180, Speaker A: Goal then is to color the vertices of this graph with k colors so that no edge is monochromatic. So that for every single edge of the graph, its two endpoints have different colors. That's something known as a k color.
00:01:43.180 - 00:01:51.486, Speaker A: So for example, imagine a graph which is basically a wheel with six spokes. So seven vertices overall the center and.
00:01:51.508 - 00:01:54.510, Speaker B: Then the six ends of the spokes at the perimeter.
00:01:54.930 - 00:02:01.106, Speaker A: Let's consider k equal three. So we're trying to figure out if the graph is three colorable. And you stare at this a little.
00:02:01.128 - 00:02:04.500, Speaker B: Bit and you realize, yes it is.
00:02:05.050 - 00:02:09.634, Speaker A: For example, you can color the middle node yellow, say, and then just alternate.
00:02:09.682 - 00:02:14.360, Speaker B: Two colors around the perimeter, say blue and green.
00:02:18.470 - 00:02:38.934, Speaker A: What you'll notice is that for each of the twelve edges in this graph, the two endpoints of the edge have different colors. That makes this a legal three coloring of the graph. So what if we ask the same question for a wheel with five spokes, is that graph three colorable? It kind of feels intuitively, like it should be only a smaller graph.
00:02:38.934 - 00:02:51.930, Speaker A: So if the first graph was three colorable, maybe this one should be two. In fact, the wheel with five spokes is not three colorable. You actually need four colors to color the wheel with five spokes.
00:02:51.930 - 00:03:03.982, Speaker A: Why is why? Well, the vertex in the middle has to get some color. Let's color it yellow. Once again, notice each of the other five vertices is adjacent to the middle node middle vertex.
00:03:03.982 - 00:03:19.398, Speaker A: So each of the five vertices on the perimeter has to get a color other than yellow. So the only hope then to be three colorable is to use only two colors on the perimeter, say blue and green. But notice we'd have to alternate the colors, otherwise we'd have an edge on.
00:03:19.404 - 00:03:21.990, Speaker B: The perimeter where both endpoints had the same color.
00:03:22.140 - 00:03:43.898, Speaker A: But unfortunately we can try alternating blue and green, but it's not going to work out. We can color for the vertices on the perimeter in that way, but then we're stuck with this fifth vertex. We can't color it blue because of its neighbor to the northeast, we can't color it green because of its neighbor to the south, and we can't color it yellow because it's also connected to that middle vertex.
00:03:43.898 - 00:03:58.858, Speaker A: So we have no choice but to use a fourth color to color that last vertex. And so that's then the graph coloring problem. I give you an unwratched graph, I tell you the number of colors k that you're allowed to use.
00:03:58.858 - 00:04:07.966, Speaker A: And the question is whether or not the graph has a k coloring, whether you can color the edges, color the vertices numbers one through k so that no edge is monochromatic, no edge has.
00:04:07.988 - 00:04:10.110, Speaker B: The same color on both endpoints.
00:04:16.130 - 00:04:22.298, Speaker A: Let me clear up a point of confusion that may have arisen for those of you that watched the videos on the color coding algorithm for computing the.
00:04:22.324 - 00:04:24.350, Speaker B: Minimum cost k path of a graph.
00:04:24.510 - 00:04:36.806, Speaker A: The color coding algorithm, you'll remember it also involved coloring of a graph's vertices. Unlike here where the coloring is part of the problem statements, in our color coding algorithm we used vertex colors just internally to the algorithm that was just.
00:04:36.828 - 00:04:38.950, Speaker B: Part of the color coding technique.
00:04:39.290 - 00:05:00.670, Speaker A: Now, once we colored all of the vertices, we did have this notion of a panchromatic path where all of the vertices have different colors. That sounds sort of like what we're talking about here, but it's different here. We're really just saying each edge should have its endpoints have two different colors, whereas back then we were thinking about k paths and we wanted all vertices of a k path to have k different colors.
00:05:00.670 - 00:05:24.602, Speaker A: So I'd be remiss if I didn't mention at this point what's probably the most famous result in all of graph theory, something known as the four color theorem, which concerns this exact graph coloring problem. It also concerns what are called planar graphs. So a graph is planar if you can draw it on a 2D surface, on a piece of paper so that none of the edges cross, so that edges meet only at common endpoints.
00:05:24.602 - 00:05:25.606, Speaker A: So like if you look at a.
00:05:25.628 - 00:05:28.950, Speaker B: Roadmap that's generally going to be a planar graph.
00:05:29.290 - 00:05:33.654, Speaker A: The four color theorem says that every planar graph can be colored using only.
00:05:33.692 - 00:05:36.626, Speaker B: Four colors every planar graph is four colorable.
00:05:36.818 - 00:05:48.810, Speaker A: Now we see here an example on the bottom right of the slide, the wheel with five spokes. That's a planar graph. We drew it on a piece of paper, and none of the edges are crossing, and we argued that that actually required four colors.
00:05:48.810 - 00:06:09.566, Speaker A: So certainly four colors might be necessary even for very simple planar graphs. So the four color theorem says that that's true, but you will never need five. Historically, interest in the graph coloring problem was motivated in part by an analogous problem about minimizing the number of inks needed to color a map, like a map you'd have in an atlas.
00:06:09.566 - 00:06:21.858, Speaker A: And it turns out an equivalent statement of the four color theorem is that if you've got a map with a bunch of countries, and the countries are contiguous regions, then in fact you only need four colors of ink to color all those countries, so that any pair.
00:06:21.874 - 00:06:25.026, Speaker B: Of countries with a neighboring border have different colors.
00:06:25.218 - 00:06:44.590, Speaker A: I don't want to do a disservice to the graph coloring problem by suggesting that it's purely recreational, because it's not. There are real applications of graph coloring problems. For example, already, if you're just trying to assign classes to K classrooms, that's exactly a graph coloring problem, where you have one vertex per class and you have an edge between each pair of classes that overlap in time.
00:06:44.590 - 00:06:54.466, Speaker A: If you want a really high stakes application of graph coloring problems, we're talking tens of billions of dollars here. Then check out the final sequence of videos on this video playlist for our.
00:06:54.488 - 00:06:57.490, Speaker B: Case study on the FCC incentive auction.
00:06:58.950 - 00:07:19.514, Speaker A: When we talked about mixed integer programming solvers, MIP solvers, we focused on optimization problems, and that's really what they are made for maximizing or minimizing some objective function subject to constraints. So the inherently numerical nature of optimization made it natural to use the formalism of arithmetic. For specifying MIPS, we had this linear constraint, this linear objective function.
00:07:19.514 - 00:07:22.166, Speaker A: Each one was just a sum over the decision variables.
00:07:22.198 - 00:07:25.846, Speaker B: Each decision variable is perhaps multiplied by some scalar.
00:07:26.038 - 00:07:31.358, Speaker A: Now, in other problems where there's not a natural numerical objective function, where you really just kind of care whether or.
00:07:31.364 - 00:07:33.358, Speaker B: Not there's a feasible solution or not.
00:07:33.524 - 00:07:45.730, Speaker A: As in the graph coloring problem. In that case, it's not obvious. Arithmetic is the best formalism to use, and another natural one, especially for computer scientists to think about, is the formalism of logic.
00:07:45.730 - 00:08:05.010, Speaker A: So in that spirit, our decision variables are no longer going to be numbers. Our decision variables are now going to be Boolean variables that can only take on two values, true or false. By a truth assignment, we just mean an assignment of each of the decision variables to one of its two possible values to either true or false.
00:08:05.010 - 00:08:25.210, Speaker A: So if you're working with a collection of N Boolean variables, there's going to be two to the N different truth assignments possible to those variables. Next, we're going to need some constraints, right? Presumably we're only interested in some subset of the truth assignments representing feasible solutions to some problem. So we need a language to specify those constraints.
00:08:25.210 - 00:08:40.260, Speaker A: I should say in the context of sat, you often hear constraints referred to as clauses. So I'll try to stick with constraints just to be consistent with our discussion of MIPS. But I may accidentally say clause, and certainly you'll hear other people say clause for constraint in the context of satisfiability problems.
00:08:40.260 - 00:09:02.134, Speaker A: Anyways, a constraint is going to be some logical formula which constrains which truth assignments are possible. Now it turns out we're going to be able to get away with what seems like a super simple type of constraint we'll eventually learn when we talk about the Cook Levin Theorem quite a bit later. That actually it's sort of without lots of generality to use these constraints.
00:09:02.134 - 00:09:03.306, Speaker A: But they're going to look simple when.
00:09:03.328 - 00:09:04.874, Speaker B: I first show them to you.
00:09:05.072 - 00:09:20.206, Speaker A: The constraints will be restricted to disjunctions of literals. What does that mean? So a literal is something very simple. It's either a decision variable, like xi or the negation of a decision variable, not xi.
00:09:20.206 - 00:09:31.650, Speaker A: So literal is either xi or not xi. So there's two N possible literals. If you have N variables, what's a disjunction? A disjunction is just logical or so x or Y.
00:09:31.650 - 00:09:33.218, Speaker A: That's true if and only if at.
00:09:33.224 - 00:09:35.846, Speaker B: Least one of x or Y is true.
00:09:36.028 - 00:09:54.298, Speaker A: So let me give you an example of a disjunction with three literals x one or not x two or x three. As far as the notation, I don't know if you've seen it before, but you can see there's this little v in between the x one and the not x two in between the not x two and the x three. That v is just the symbol for logical or.
00:09:54.298 - 00:10:01.386, Speaker A: Meanwhile, that upside down L in front of the x two. That just denotes not. So if x two is true, then not x two is false.
00:10:01.386 - 00:10:03.854, Speaker A: If x two is false, then not x two is not.
00:10:03.892 - 00:10:05.440, Speaker B: Not x two is true.
00:10:06.050 - 00:10:15.186, Speaker A: Disjunctions of literals are actually pretty easy going creatures, pretty easy to satisfy. A single disjunction of literals. Like take the three literal example we.
00:10:15.208 - 00:10:16.366, Speaker B: Have on the slide.
00:10:16.558 - 00:10:21.874, Speaker A: This constraint is basically telling us, look, if you want to make me happy, all you got to do is set.
00:10:21.912 - 00:10:25.060, Speaker B: X one to be true. If we do that, it's done.
00:10:25.670 - 00:10:41.594, Speaker A: If we screw that up and we wind up setting x one to false, we can still make amends by setting x two to false. If we do that, the clause will still be happy. If we also mess up that assignment and set x two to be true, well, then we still have a chance to salvage our relationship by setting x three to true.
00:10:41.594 - 00:11:02.446, Speaker A: If we do any of those three things, this constraint will be satisfied. In fact, there is only one way to mess up satisfying this constraint, which is to set each of the variables involved to the opposite value that's being requested by the constraint. So in this case, it would mean if we set x one to false and x two to true and x three to false.
00:11:02.446 - 00:11:16.882, Speaker A: Well then we've really thumbed our nose at this constraint and it's not satisfied. But of the eight possible assignments of truth assignments to x one, x two and x three, seven out of the eight will satisfy the clause. The only one that doesn't is again the one that refuses.
00:11:16.882 - 00:11:33.990, Speaker A: All three of the assignment requests x one to false, x two to true, and x three to false. The same kind of thing is true more generally for disjunctions of any number of literals. So disjunction with k literals is going to be two to the k ways to assign truth values to the k variables that are involved.
00:11:33.990 - 00:11:45.598, Speaker A: Exactly one of them will fail to satisfy the clause if and only if every assignment is the opposite of what is requested by the clause two to the k minus one out of the two to the k assignments will in.
00:11:45.604 - 00:11:47.230, Speaker B: Fact satisfy that clause.
00:11:47.730 - 00:12:05.586, Speaker A: Now, with all the terminology in place, I can state for you formally what is the computational problem known as sat or satisfiability. The input to the problem is a list of boolean decision variables. Let's say there's n of them, x one up to x n, and also a list of some number of constraints.
00:12:05.586 - 00:12:20.454, Speaker A: Let's say there's m constraints and each constraint should be in the format that we specified. It's disjunction of one or more literals. The responsibility then of an algorithm or a solver for sat is to identify a truth assignment.
00:12:20.454 - 00:12:35.866, Speaker A: There's two to the n possible truth assignments and the algorithm needs to find one of them that satisfies each of the m constraints. Or if the instance is unsatisfiable, if in fact no truth assignment satisfies all of the clauses simultaneously, then the algorithm.
00:12:35.898 - 00:12:37.680, Speaker B: Should correctly report that fact.
00:12:38.130 - 00:13:01.474, Speaker A: So that is the famous sat problem. And as we'll learn in the second half of this video playlist, this is a super important problem, one of the most central in all of theoretical computer science. But let's not get ahead of ourselves, right? Because when you first see it, the sat problem, it seems like pretty simple, right? I mean, you've got these decision variables, but they're all boolean.
00:13:01.474 - 00:13:08.530, Speaker A: They can just be true or false, not much to see there. And then you have these constraints. But the constraints are like super simple, just these disjunctions of literals.
00:13:08.530 - 00:13:12.406, Speaker A: And a disjunction of literals is really easy to satisfy, at least if you're.
00:13:12.438 - 00:13:13.914, Speaker B: Just looking at one of them at a time.
00:13:14.032 - 00:13:17.994, Speaker A: So could the sat problem really be general enough to encode other problems that.
00:13:18.032 - 00:13:20.650, Speaker B: Are of interest that we actually would want to solve?
00:13:20.990 - 00:13:37.506, Speaker A: For example, what if we wanted to encode the graph coloring problem as Sat. How would we do that? Because again, like in graph coloring, if we're looking for a k coloring, it actually really feels like we want one variable for each vertex which can take on one of k values, right, each of the possible colors. And in Sat we can't do that.
00:13:37.506 - 00:13:39.186, Speaker A: We're stuck with these Boolean variables that.
00:13:39.208 - 00:13:41.166, Speaker B: Can only take on two different values.
00:13:41.358 - 00:14:16.094, Speaker A: It turns out that with little practice you can encode a surprisingly large number of problems as Satisfiability problems. Actually, in principle, if you allow very fancy encodings, there's even a result that we'll see called the Cook Levin theorem, which says pretty much any problem you're ever going to encounter can in fact be encoded using Satisfiability. But what I mean here is that there's lots of problems that show up in real applications that you might really want to solve, which translate kind of very directly into Satisfiability, so that it's then easy to use the latest and greatest Sat solvers to see how well they do on your problems.
00:14:16.094 - 00:14:42.998, Speaker A: Probably the sort of most classic application of Satsolvers, where they've been used for decades is in verification both of software and in hardware that is looking for bugs. But there's also been some really fun applications just in the last few years. So for example, in 2017, a bunch of cryptography researchers showed how to use Sat solvers to break the previously cryptographically secure hash function sha one.
00:14:42.998 - 00:14:46.466, Speaker A: And then we'll see another example in the case study on the FCC incentive.
00:14:46.498 - 00:14:49.366, Speaker B: Auction in the final videos of this playlist.
00:14:49.558 - 00:15:00.286, Speaker A: So let's get back to graph coloring. So how are we going to encode a graph coloring problem as Satisfiability? All we have to work with is Boolean variables, but it seems like we'd really like to have variables that could.
00:15:00.308 - 00:15:02.058, Speaker B: Take on k different values.
00:15:02.234 - 00:15:22.738, Speaker A: Well, it's going to be a very simple fix. We're just going to have k Boolean variables per vertex corresponding to the k different colors that might be assigned to that vertex. So the intended semantics here is that x sub VI that should be true if the vertex v is assigned the color i.
00:15:22.738 - 00:15:35.354, Speaker A: If it's assigned any other color, then x sub VI should be false. So what about v constraints? Remember, the whole point of the graph coloring problem is that no edge should be monochromatic. No edge should have both of its.
00:15:35.392 - 00:15:38.186, Speaker B: Endpoints receive the same color i.
00:15:38.368 - 00:15:48.198, Speaker A: But you think about it a minute and you realize that type of constraint that translates really easily into a disjunction of literals over these Boolean decision variables.
00:15:48.214 - 00:15:49.518, Speaker B: That we just wrote down.
00:15:49.684 - 00:15:53.518, Speaker A: So suppose there's some edge v comma w, and we're concerned about both the.
00:15:53.524 - 00:15:57.806, Speaker B: Endpoints getting some color i. How would we make sure that doesn't happen?
00:15:57.988 - 00:16:22.902, Speaker A: We can enforce that with one constraint that's a disjunction of two literals, not XVI or not xwi. So this constraint is basically requesting an assignment of false to XVI, and also it's requesting an assignment of False to xwi. So the one way you can make this constraint Not Satisfied is by Setting XVI and xwi both equal to True.
00:16:22.902 - 00:16:34.426, Speaker A: And that exactly corresponds to the case where both endpoints of the Edge have the color I. So when that bad thing happens, this constraint will indeed Not Be satisfied. So the constraint enforces that the two.
00:16:34.448 - 00:16:36.570, Speaker B: Endpoints cannot both get the color I.
00:16:36.720 - 00:16:48.078, Speaker A: Now, for each edge, you need K of these Constraints to rule out each of the k colors. But that's fine. That means at the end of the day, you have k times m constraints of this form, where K is the number of colors and m is the.
00:16:48.084 - 00:16:50.290, Speaker B: Number of edges in the graph.
00:16:51.030 - 00:17:08.390, Speaker A: So with this set of Constraints, we should no longer be worried about any monochromatic edges. Those have been explicitly ruled out by these Constraints. However, we're not quite done, because if you think about it, I mean, one way you could satisfy all of these constraints would be to just set everything to False.
00:17:08.390 - 00:17:19.580, Speaker A: That's not really what we want. That would sort of correspond to not coloring any Vertex anything which is sort of missing the point. So we also want to have a constraint which says that vertices should get a color.
00:17:19.580 - 00:17:40.654, Speaker A: So we enforce this with a second set of constraints. One constraint per vertex v, where we just use a disjunction of K literals and the literals are just the unnegated versions of the K decision variables corresponding to the vertex v. So XV one or XV two or dot, dot, dot, all the way up to Xvk, where.
00:17:40.692 - 00:17:42.854, Speaker B: K is the last of the colors.
00:17:43.002 - 00:17:48.546, Speaker A: So again, there's going to be exactly one way that this clause is not satisfied, and that's if you do the.
00:17:48.568 - 00:17:50.642, Speaker B: Opposite of everything it wanted you to do.
00:17:50.776 - 00:18:10.502, Speaker A: So this constraint is imploring you to set at least one variable to True. The only way to not satisfy it is if all of the variables are false. So that means if you have anything that satisfies both one and two, then every vertex is going to get a Color, or at least one color, and no edge is going to be monochromatic.
00:18:10.566 - 00:18:13.450, Speaker B: Every edge will have different colors at its endpoints.
00:18:13.790 - 00:18:33.706, Speaker A: It is true that if you use only these two families Of Constraints, it does leave open the possibility of a truth assignment that assigns more than one color to a Vertex that is not ruled out. So if that bothers you, you could add a third family of Constraints that enforces that each vertex gets exactly one color. If you want, you can also just stick with these two families of Constraints.
00:18:33.738 - 00:18:34.914, Speaker B: And not worry about it.
00:18:35.032 - 00:18:51.154, Speaker A: Yeah, a Vertex might get more Than one Color, might be more than one of its variables, might Be Set To True. But it doesn't matter, because no matter how you choose one color from among them, and you do that for all of the vertices. You're going to get a k coloring no matter what because there weren't any conflicts between any of the colors assigned to any of the vertices.
00:18:51.154 - 00:18:53.906, Speaker A: So that's fine too. Just only use these and then extract.
00:18:53.938 - 00:18:57.926, Speaker B: A k coloring arbitrarily from a satisfying truth assignment.
00:18:58.118 - 00:19:04.026, Speaker A: So that's how to encode an instance of graph coloring as an instance as Satisfiability. I hope you'll agree that that was.
00:19:04.048 - 00:19:05.786, Speaker B: Actually not very hard.
00:19:05.968 - 00:19:25.166, Speaker A: Moreover, what we've written down on this slide, the collection of variables and this collection of disjunctions of literals, this is exactly the sort of description that can be fed directly into a magic box called a Satisfiability or Sat solver. So to see what I mean, let's just look at a really toy example. Let's just look at sort of a triangle.
00:19:25.166 - 00:19:42.050, Speaker A: So a complete graph on three vertices. And let's look at the encoding, a sat of the question of whether or not the triangle is too colorable. I'm going to show you the file format you would pass to any number of Sat solvers, but for example, minisat, one of the most popular open source solvers.
00:19:42.210 - 00:19:48.150, Speaker B: And so if you invoked minisat with the following input file, it would immediately.
00:19:48.230 - 00:19:51.990, Speaker A: Tell you whether or not the triangle is too colorable.
00:19:52.070 - 00:19:55.062, Speaker B: It's not, of course, so it would return Satisfiable.
00:19:55.206 - 00:20:18.050, Speaker A: So just to sort of explain what is the syntax you're seeing here? The first line of the file warns the solver that the sad instance has six decision variables and nine constraints. The CNF stands for conjunctive normal form and that just indicates that each constraint is in the format we've been talking about a disjunction of literals. The numbers between one and six refer to variables and the hyphen indicates negation.
00:20:18.050 - 00:20:43.306, Speaker A: The first three and the last three variables correspond to the first and the second color respectively. The first three constraints are from our second family specifying that each vertex gets at least one color and the last six constraints correspond to our first family ruling out the two vertices that are connected by an edge get the same color, the zeros are just to mark the ends of constraints. So in any case, that's it.
00:20:43.306 - 00:21:08.830, Speaker A: It's very simple conceptually to encode graph coloring as Satisfiability. We had our decision variables, we had our constraints, and once we have those two things, it's equally straightforward to translate that into a format which you can then just feed directly into one of these magic boxes and see how it does. One thing that's cool about the Satisfiability world compared to the mixed integer programming world is there isn't really a big difference between commercial and noncommercial solvers.
00:21:08.830 - 00:21:35.478, Speaker A: In fact, you may or may not know that all the Sat nerds from around the world gather together every year or two to hold a sort of Sat Olympics Sat competitions. So everybody brings their latest and greatest solvers, everybody brings their hardest and most nastiest instances and they run Olympic style competitions, even going so far as to give out gold, silver, and bronze medals. So this has been going on for a couple of decades.
00:21:35.478 - 00:21:50.334, Speaker A: So if you want to see the current state of the art of Sat solvers, go check out the latest Sat competition. Most of the submitting groups make their solvers open source. If you're feeling lazy, you don't want to go explore the latest and greatest ones.
00:21:50.334 - 00:22:01.250, Speaker A: You just want sort of a quick tip of where to get started. Again, minisat is a pretty reasonable place to start. It combines good performance with ease of use and a permissive license, specifically the MIT license.
00:22:01.250 - 00:22:34.202, Speaker A: And then for those of you who want to up your Sat solving game to the next level, you might want to check out Satisfiability Modulo theories, or Smt solvers. One current example is Microsoft's Z Three Solver, which is also freely available under the MIT license. That brings us to the end of our discussion of Sat solvers and zooming out of semirelible magic boxes and of zooming out even more, of just talking about augmenting your toolbox to help you tackle empty hard problems that come up in your own projects.
00:22:34.202 - 00:22:57.862, Speaker A: We discussed both how to compromise on correctness. We talked about fast heuristic algorithms, both ones with provable guarantees and ones like local search that generally don't have provable guarantees. And then in this chapter, we've now finished discussing ways of compromising on running time and designing algorithms that are exact, that are guaranteed to be correct but will not run quickly all of the time, but hopefully run quickly most of the time.
00:22:57.862 - 00:23:37.074, Speaker A: Here again, we looked at some provable guarantees so algorithms that provably run faster than exhaustive search, the Bellman healthcarp algorithm for the Tsp and the color coding algorithm for finding long paths in a graph. And then we also talked about, again, a couple tools where maybe you don't have those provable guarantees of beating exhaustive search, but they're still super useful in applications a lot of the time, these semi reliable magic boxes known as MIP Solvers and Sat Solvers. At this point, you have reached what I was calling level two expertise early on in the playlist, which is that if someone hands you an NP hard problem, you're going to have a lot of different ideas of how you might.
00:23:37.112 - 00:23:38.290, Speaker B: Make progress on it.
00:23:38.360 - 00:24:00.090, Speaker A: Maybe you use fast heuristic algorithms, maybe you use local search, maybe use dynamic programming, maybe with some randomization. Maybe you use one of these magic boxes, a MIT for Sat Solver. But the point is, you have a lot of things you can try, but that's always assuming someone handed you an empty hard problem that you knew was empty hard, and so you knew you needed to compromise on either correctness or on running time.
00:24:00.090 - 00:24:25.360, Speaker A: But the question still is a problem in the wild doesn't come with, like a label on its forehead telling you that it's NP hard. So how do you know that a problem is MP hard so that you don't waste time trying to come up with an exact polynomial time algorithm for it? That's the subject of the next chapter, chapter 22, where we'll give you simple recipe for proving the problems are NP hard and an awful lot of practice putting that recipe to use. I'll see you there.
