00:00:00.730 - 00:00:24.382, Speaker A: Hi everyone, and welcome to this video that accompanies section 21.4 of the book Algorithms Illuminated, part Four. This section is a brief introduction into one type of semireliable magic box known as a mixed integer programming or MIP solver. So lots of discrete optimization problems, including pretty much everything that we've seen in this book series, can be cast as a special case of a very general.
00:00:24.436 - 00:00:26.722, Speaker B: Problem known as mixed integer programming.
00:00:26.866 - 00:00:49.066, Speaker A: Now, programming here the word has the same anachronistic use that it did when we discussed dynamic programming or that you hear in television programming. So programming here refers to planning, not to coding, as you might expect in the modern day. In any case, whenever you have an NP Heart optimization problem that lends itself naturally to a formulation as a mixed integer program, throwing a MIPS solver at.
00:00:49.088 - 00:00:50.886, Speaker B: It is probably worth a shot.
00:00:50.998 - 00:00:54.638, Speaker A: Let's get an initial feel for how this might work by revisiting an old friend.
00:00:54.724 - 00:00:56.160, Speaker B: The knapsack problem.
00:00:57.650 - 00:01:33.846, Speaker A: So let me remind you the definition of the knapsack problem which we've discussed a few times in the past. So the input comprises two n plus one positive integers. So there are n items, each of which has a value and a size. And then the last of the numbers, capital C, is a knapsack capacity. So for example, here's an example with five items and a knapsack capacity of ten. The goal is to choose a subset of the items. You would like the total value of those items to be as high as possible, but the constraint is that the sum of the sizes of those items.
00:01:33.878 - 00:01:36.250, Speaker B: Should be at most of the knapsack capacity.
00:01:36.750 - 00:01:44.286, Speaker A: The problem specification spells out three things the decisions to be made, the constraints that have to be respected, and the.
00:01:44.308 - 00:01:48.154, Speaker B: Objective function which is to be optimized the decisions.
00:01:48.202 - 00:02:21.082, Speaker A: Well, we need to make a binary decision for each of the n items. For each item I, we need to decide whether it's going to be included in the Napsack in our subset or not. A very convenient way to numerically encode binary decisions is as zero one variables. So that's what we're going to do here. We're going to use xi to denote one if I is included in the subset and zero if I is excluded from the subset. Second, the constraints. Actually in the Napsack problem, there's only the one constraint saying the sum of the chosen items sizes should be a most capital C.
00:02:21.082 - 00:02:41.066, Speaker A: What I want to notice here is that that constraint is actually very easy to express in arithmetic in terms of these decision variables, these XIs that we've introduced. Because an item I is going to contribute its size s sub I to the overall size if it's included, and it will contribute zero to the overall.
00:02:41.098 - 00:02:43.310, Speaker B: Size if it's not included.
00:02:43.730 - 00:02:57.874, Speaker A: So in other words, we can express the total size of the chosen items as a simple sum. So we sum over the items and then a given item contributes SJ times XJ. Notice that's going to be zero if XJ is zero if the item is excluded and it's going to be SJ.
00:02:58.002 - 00:03:00.870, Speaker B: The size of item j if j is included.
00:03:04.840 - 00:03:36.348, Speaker A: The final part of the problem specification is what it is we want what is the objective function. And that's just maximizing the total value of the chosen items. And just like the total size was easy to express as a sum in terms of the XJS, so is the total value. It's just exactly the same sum, except with the SJS replaced by the VJs. So guess what you just saw? Your first mixed integer program, your first MIP. To make sure this is all crystal clear, let me literally spell out what the mixed integer program is for the case of this five item example on.
00:03:36.354 - 00:03:37.900, Speaker B: The right part of the slot.
00:03:39.380 - 00:04:06.952, Speaker A: So let me write the objective function first. So remember, we want to maximize, we want to maximize the total value. And the total value can be expressed as a sum of the decision variables, the XJS each multiplied by the value of the corresponding item. So the first item had value six. So that gives us a six x one as the first term, right? The item contributes six to the value if it's included, zero if it's not included. Second item has value two. Excuse me, value five.
00:04:06.952 - 00:04:38.092, Speaker A: So we get a five x two. Third item has value four. Fourth item has value three and the fifth item has value two. So that's going to be the objective function. So for a given setting of the XJS to zero or one, this just encodes the total value of the chosen items. Then we have the constraints. So now we want to say that the total, the sum of all of the sizes of the included items is at most the knapsack capacity.
00:04:38.092 - 00:05:12.430, Speaker A: So the first item, remember, it has a size of five. So we're going to have an five x one here contributes five to the size if it's included, zero to the size if it's not. And then similarly, second item has size four. Third item has size three. Second 4th item has size two. And last item has size one's. And then finally, let's just record what are these XJS? They are zero or one.
00:05:12.430 - 00:05:17.724, Speaker A: And the zero or one is meant to indicate whether the item is excluded.
00:05:17.772 - 00:05:20.796, Speaker B: Or included in the final subset.
00:05:20.988 - 00:05:46.324, Speaker A: And this simple as it is, this is exactly the sort of description that can be fed directly into a magic box known as a mixed integer programming or MIP solver. So for example, if we wanted to know the answer to this five item instance that we have on this slide, we could use a leading commercial MIP solver like Garobi Optimizer would be one example. And if we wanted to do that, you would literally just invoke the solver.
00:05:46.452 - 00:05:50.276, Speaker B: With the following input file, which you'll.
00:05:50.308 - 00:06:09.536, Speaker A: Notice is literally what we just wrote down on the previous slide in math. You just translate to text file, you feed it into grovi optimizer and in the blink of an eye it will tell you the optimal solution, which in this case turns out to be to setting x one equals zero. The rest of the XJ is equal to one. So you exclude the first item, you.
00:06:09.558 - 00:06:11.090, Speaker B: Take the other four.
00:06:11.700 - 00:07:03.548, Speaker A: So this naturally was just a toy example, just five items. Usually when you're using a MIP solver, you're solving instances that are bigger and for larger instances you're not going to want to type up this input file by hand. You're going to either want to write a program that generates the input file automatically or alternatively just interacts directly with the solver's API. Let's move on to discussing mixed integer programs more generally beyond just the Napsack problem, although I probably owe you a couple of words of explanation before that. First, you might be wondering what is the mixed? What's up with the M in MIP? And mixed refers to the fact that the solvers we're discussing accommodate a mixture of different types of decision variables. So we've only used a binary one so far zero or one. More generally, they can use decision variables that can take on integer values within some range or even real valued variables within some range.
00:07:03.548 - 00:07:07.148, Speaker A: So because you can mix real valued and integer valued variables, that's why they're.
00:07:07.164 - 00:07:08.770, Speaker B: Called mixed integer program.
00:07:09.300 - 00:07:50.044, Speaker A: I should also warn you that what I'm calling MIPS are sometimes called other things. MIPS is definitely a common terminology, but some authors will call these instead integer linear programs. ILPs to emphasize the linear aspect which we'll talk about in just a second. And then some authors just say integer programs IPS and leave off the mix. There's also a really interesting special case of a mixed integer program, which is the special case where there are no integer valued or zero one decision variables, where all the decision variables are real value. So that special type of MIP is known as a linear program or an LP. State of the art solvers work really, really well on linear programs.
00:07:50.044 - 00:07:56.172, Speaker A: In fact, anytime you use a solver to solve a mixed integer program under the hood, the solver is probably solving.
00:07:56.236 - 00:07:58.804, Speaker B: Thousands of linear programs to help it along.
00:07:59.002 - 00:08:16.136, Speaker A: Not coincidentally, it turns out the linear programming problem is polynomial times solvable, while general mixed integer programming is NP heart. So that's still a very powerful and expressive but quite tractable special case of mixed integer programs. Linear programs, the case where all of.
00:08:16.158 - 00:08:18.680, Speaker B: The decision variables are real valued.
00:08:19.020 - 00:08:29.724, Speaker A: So how do you specify a MIP in general? Well, it's really just those same three ingredients that we discussed. You have to identify your decision variables, which decisions are getting made, you have to say what your constraints are, and you have to say what you want.
00:08:29.762 - 00:08:31.150, Speaker B: What'S your objective function?
00:08:31.600 - 00:09:17.336, Speaker A: The one really important restriction is that both the constraints and the objective function should be linear functions of the decision variables. So what does it mean to say that the constraints and objective function are linear in the decision variables? Well, let's go back and look at our Napsack integer program. What you'll notice is that in both the objective function and in the constraints, we have taken some of the decision variables and scaled them by a constant, like six or five or four. And we've also added up the decision variables together, but we haven't done anything else. And so that's exactly what linear means. So, for example, you would not be allowed to have an expression like XJ squared that would be nonlinear. You couldn't have XJ times XK that would be nonlinear.
00:09:17.336 - 00:09:50.000, Speaker A: You couldn't have like one divided by XJ one over XJ. Also nonlinear e to the XJ log of XJ, et cetera. None of those are allowed to show up in a mixed integer program. So both the constraints and the objective function need to be expressible as basically sums over decision variables scaled by constant factors. It is true that the latest and greatest MIP solvers can also accommodate limited types of nonlinearity, like certain quadratic terms, but they typically run much faster when you have just linear constraints and objective functions.
00:09:50.080 - 00:09:51.930, Speaker B: And that's what we'll focus on here.
00:09:54.060 - 00:10:43.720, Speaker A: So now I can formally define for you the mixed integer programming problem. Basically, you've given a description of a myth, and your job is to just find the best solution subject to the constraints. So the objective function being a linear function, all you can do is basically choose what to scale the different decision variables by. So the input just consists of the coefficients of the linear function, so coefficient CJ for each of the decision variables XJ similarly for each constraint. And unlike the knapsack problem, you're perfectly welcome to have more than one constraint in a mixed integer program. So, for each of the m constraints, again, it needs to be linear. So you need to specify the coefficients.
00:10:43.720 - 00:11:19.316, Speaker A: You also need to specify a right hand side for the constraint. So, for example, in the Napsack problem, the CIS become the item values. Remember, those were the coefficients. In the objective function, we only had one constraint, so m was equal to one, and the coefficients for that constraint were equal to the item sizes. Remember, that was the left hand side of the constraint of the inequality, whereas meanwhile, the b, the right hand side is just the knapsack capacity capital c. So, a generic mixed integer program, this is what you get. You're told what the decision variables are and which values they're allowed to take on.
00:11:19.316 - 00:11:34.776, Speaker A: You're told a linear objective function value through the coefficients, and then you're told some number m of constraints, again linear, again specified via their coefficients. So the responsibility of a MIP algorithm of a MIP solver is then just to compute an optimal solution to this.
00:11:34.798 - 00:11:36.600, Speaker B: Very general optimization problem.
00:11:36.750 - 00:12:31.124, Speaker A: So among all of the allowable ways to assign values to the decision variables, among all the ways that respect all of the given constraints, you want to find the one with the best objective function value. So if you're trying to maximize an objective, you want the variable assignment that satisfies all the constraints and has as high an objective function value as possible. So even with this linearity restriction in both the constraints and the objective function can be embarrassingly easy to express. NP Hard Optimization Problems as Mixed Integer Programs so we already saw an example of that when we talked about Napsack and wrote this very simple integer program. Just to elaborate on the point, imagine we had a harder knapsack problem called the two dimensional Napsack problem, where now every item j has as usual, it has its value VJ, it has its size SJ. Suppose it also has a third parameter, a weight WJ. And in addition to the Napsack capacity capital C, suppose there's now an analogous.
00:12:31.172 - 00:12:33.240, Speaker B: Bound on the total weight capital W.
00:12:33.390 - 00:12:49.132, Speaker A: So the goal now in two dimensional Napsack, again you want to maximize the total value of the items that you choose subject to two constraints. First of all, as before, the total size should be, at most, the napsack capacity, capital C. But then also, the total weight of the chosen item should be, at most, the weight bound capital.
00:12:49.196 - 00:12:51.564, Speaker B: W. Now you're a graduate.
00:12:51.612 - 00:13:06.212, Speaker A: Of the algorithms illuminated dynamic programming bootcamp. And you could knock out a dynamic program for the two dimensional knapsack problem without that much trouble. But you could not do it as quickly as you could simply add the second constraint to the mixed energy program.
00:13:06.266 - 00:13:07.604, Speaker B: That we already have.
00:13:07.802 - 00:13:25.836, Speaker A: And it's not just the knapsack problem. So many problems that are familiar to you, like for example, maximum weight independence set, the minimum makespand problem, the maximum coverage problem that we talked about. All of those are really quite easy to encode as mixed integer programs. So those are problems that if you want to try to tackle them with a MIP solver, you should go ahead.
00:13:25.858 - 00:13:27.000, Speaker B: And give it a shot.
00:13:27.160 - 00:14:27.520, Speaker A: Mixed integer programs are also the state of the art for tackling the traveling salesman problem if you want to solve it exactly in practice. Although that application of integer programming is quite a bit more sophisticated than the other examples that I mentioned. If you want to learn more about how to apply MIPS to the traveling salesman problem, I suggest you do a web search on the subtour relaxation. Not only can many problems be naturally encoded as a mixed integer program, in fact many problems can be encoded as a mixed integer program in multiple different ways. And it turns out the choice of formulation can matter a lot. So you can see solver performance vary tremendously, even by an order of magnitude or more depending on which specific formulation you use. That means if your first attempt at tackling a problem using a mixed integer programming solver fails, it doesn't necessarily mean it's the wrong technology, it may just mean you need to experiment with other ways of encoding your problem as a MIP for the solver to have acceptable performance.
00:14:27.520 - 00:14:35.824, Speaker A: So now that you're feeling amped up to apply one of these semirelible magic boxes, one of these MIP solvers, to a problem that you care about, where.
00:14:35.862 - 00:14:37.584, Speaker B: Should you get started?
00:14:37.782 - 00:15:02.136, Speaker A: Well, let me just tell you a little bit about what the state of the art looks like at the time of this recording, which is in the year 2020. Right now there's unfortunately a huge gulf in the performance between commercial and noncommercial solvers. So let me give you recommendations separately for each of those two cases. So these days a majority of experts will tell you that the Garobi Optimizer solver is the most consistently reliable and.
00:15:02.158 - 00:15:03.608, Speaker B: Robust one out there.
00:15:03.774 - 00:15:58.204, Speaker A: If you wanted to choose a runner up, you'd probably choose either CPLEX, which is actually in some ways a precursor to Guerobi Optimizer or FICO Express. So the good news is that if you're associated with a university, if you're a student or your staff at a university, you can obtain free academic licenses for any of these solvers. It is sort of restricted to research and educational use. So for those of you stuck with non commercial solvers, if you ask around for recommendations, here's four of the names that you hear reasonably often. It's kind of an alphabet soup of various acronyms, but anyways, so you can start with the Sipsolver SCIP, CBC Solver, mipscl or the GNU Project is the GNU Linear Programming Kit Glpk. The CBC and Mipscl solvers have more liberal licensing agreements than the other two. The other two are free for non commercial use only.
00:15:58.204 - 00:16:43.032, Speaker A: So another thing you might want to look into if you sort of get serious about these MIPS solvers, is, if you want, you can decouple the tasks of sort of formulating a mixed integer program for your problem and on the other hand sort of syntactically describing the formulation you came up with to a particular solver by specifying your mixed integer program in a high level solver independent modeling language. One good example is the Python based cvxpy. So the cool thing if you do choose to use one of these solver independent modeling languages is you can then experiment easily with all of the solvers supported by that language to figure out which one tends to work the best on the types of inputs that you care about. Your high level specification is just going to get automatically compiled down into whatever.
00:16:43.086 - 00:16:45.320, Speaker B: Format the solver is expecting.
00:16:46.060 - 00:16:56.912, Speaker A: So that wraps up what I wanted to tell you about the semireliable magic boxes known as MIP solvers. There's one other genre of such boxes I want to tell you about Satisfiability Solvers. And that'll be in the next video.
00:16:56.966 - 00:16:58.620, Speaker B: I'll see you there. Bye.
