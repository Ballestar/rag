00:00:00.650 - 00:00:12.298, Speaker A: Hi, everyone, and welcome to this video that accompanies Section 22.5 of the book Algorithms Illuminated, Part Four. This will be the second of our four major NP hardness reductions.
00:00:12.298 - 00:00:26.386, Speaker A: It will again be a reduction from the three sat problem to a graph problem. It's going to be a different graph problem. The directed Hamiltonian path problem, which we saw briefly in the very first chapter when we discussed why computing cycle free shortest paths is NPR.
00:00:26.386 - 00:00:49.318, Speaker A: So let me now remind you about that directed Hamiltonian path problem. The input, naturally, is a directed graph, also two distinguished vertices, so S, which is the starting vertex, and T, which is the destination vertex. And the responsibility of an algorithm for this problem is to return an St Hamiltonian path of the graph.
00:00:49.318 - 00:01:17.140, Speaker A: So it's a path that starts at S, ends at T, and visits every vertex exactly once. Or if the graph doesn't have a St Hamiltonian path, the algorithm should correctly report that fact. In contrast to most of the 19 problems that we're discussing in this chapter, our interest in the directed Hamiltonian path problem, it's less for its direct applications and more for its utility in proving that other problems are NP hard, including, most notably, the traveling salesman problem.
00:01:17.140 - 00:01:39.270, Speaker A: And the main result of this video is going to be a reduction. We're going to be reducing the three set problem to the directed Hamiltonian path problem. So if we're willing to accept the Cook Levin theorem if we're willing to accept that the three set problem is NP hard, by our two step recipe, this shows that the directed Hamiltonian path problem is NP hard, fulfilling a promise I made to you way back in that opening chapter.
00:01:39.270 - 00:02:03.678, Speaker A: When we deduced from the NP hardness of directed Hamiltonian path, the NP hardness of cycle free shortest paths, what's the reduction going to look like? Well, actually, just in the last video, right, we saw a reduction from three sat to a graph problem, the independent set problem. And that may have been surprising at that time. Since threesat doesn't have anything to do with graphs, it would seem it has to do with logic, and independent set has to do with graphs.
00:02:03.678 - 00:02:19.314, Speaker A: Now that we've seen that, however, it should be totally plausible that we could also reduce the three sat problem to other graph problems, perhaps even including the directed Hamiltonian path problem. And we can. Because it's a different problem than independent set, we're going to need a totally different reduction.
00:02:19.314 - 00:02:29.260, Speaker A: Unfortunately, it'll even be a little bit more complicated than the reduction in the previous video. But that's kind of characteristic of how NP hardness proofs work. They tend to be pretty problem specific.
00:02:29.260 - 00:02:47.646, Speaker A: Like last time, we need a plan, right? So we're trying to build this blue box for solving three set. Given a magenta box, that solves the directed Hamiltonian path problem, which means at the end of the day, we're going to have to look at the answer that this magenta box gives us. It's going to tell us whether or not some graph has a Hamiltonian path.
00:02:47.646 - 00:03:19.130, Speaker A: And from its answer, we're going to have to deduce whether our original three set instance was satisfiable or not. So what is our plan for extracting a satisfying truth assignment from a Hamiltonian path of a graph? Well, here we're going to be able to encode truth assignments in an easier way than in the independent set reduction here. We're just going to concoct the graph to force a Hamiltonian path to make a sequence of binary decisions, which will then encode a truth assignment to the original threesat instance.
00:03:19.130 - 00:03:52.070, Speaker A: To see how this might work, let's start with just a simple four vertex diamond graph. You stare at this graph for a little bit and you realize there are exactly two St Hamiltonian paths one that zigzags up to down and one that zigzags down to up. This means that from an St Hamiltonian path in the diamond graph, we can extract, we can think of it as encoding assignment to a single Boolean variable, identifying one zigzag path with true and the other zigzag path with false.
00:03:52.070 - 00:04:08.234, Speaker A: Now, of course, we're encoding a truth assignment not just to one variable, but to N variables. So how are we going to do that? Well, we'll just chain a bunch of these diamond graphs together in a long necklace. Now, any St Hamiltonian path, so it goes from S to T.
00:04:08.234 - 00:04:44.062, Speaker A: It has to traverse every single diamond, and in each diamond it has to make a decision of whether to zigzag down or to zigzag up. So depending on the sequence of decisions that the SD Hamiltonian path makes, we can interpret that as a truth assignment. So, for example, if we identify Zigzagging down and then back up with True in the other direction as false, this Hamiltonian path that I've shown you on the slide, that would correspond to the Truth assignment, that sets the first variable to false, because in the first diamond, the path zigzags up.
00:04:44.062 - 00:04:56.574, Speaker A: And then in the second and third diamonds, because it zigzags down. That's going to be an assignment of true to two other variables x two and x three. That's how we're going to encode truth assignments just with these necklace graphs.
00:04:56.574 - 00:05:17.270, Speaker A: So hopefully that's simple enough. The next step is we need to somehow figure out how to incorporate the constraints in the given threesat instance. Intuitively, we want to somehow modify this graph so that the only St Hamiltonian paths that survive are the ones that correspond to satisfying truth assignments in our original threesat instance.
00:05:17.270 - 00:05:36.970, Speaker A: To see how this might work, let's just add one constraint to the necklace graph with three diamonds that we were just looking at. Let's say we want to encode the constraint not x one or x two or x three. So we're going to add one additional vertex beyond the vertices and the necklace.
00:05:36.970 - 00:06:00.326, Speaker A: This new vertex will correspond to this constraint. And the idea is that we want to set things up so that an St Hamiltonian path can visit this constraint vertex if and only if it's traversing a diamond in the correct direction, in the direction that corresponds to the variable assignment requested by this clause. Let's see how this would work in our simple example.
00:06:00.326 - 00:06:13.926, Speaker A: So in Blue, I've drawn the same necklace graph we had on the previous slide, the same sequence of three diamonds. Okay, I'm lying a little bit. I added a couple extra vertices on the pathways that go up and down within a diamond.
00:06:13.926 - 00:06:29.920, Speaker A: We'll see why I did that in a second. Otherwise, this is exactly the same as what we had on the previous slot, the Blue edges. So now let me show you the new edges we're going to add between the necklace and this new constraint vertex corresponding to the constraint, not x one or x two or x three.
00:06:29.920 - 00:06:57.910, Speaker A: As usual, we can think of this constraint as making three requests. It says, hey, please set x one to be false, or failing that, please set x two to be true. Or failing that, could you at least set x three to be true? And so what we want is we want that in one of these diamonds we can successfully visit this constraint vertex and then resume where we left off if and only if we're traversing the pathway within that diamond in the correct direction, in the requested direction.
00:06:57.910 - 00:07:14.234, Speaker A: So, for example, consider the first diamond corresponding to the variable x one. So this constraint has an opinion about what it wants x one to be, and it wants it to be false. If we do set it to false, remember, we're identifying that with a path that goes Zigzags up through the diamond.
00:07:14.234 - 00:07:40.226, Speaker A: So the path is going to be going up through the first diamond if it corresponds to the requested assignment, x one to be false. So what we're going to do is on the way up through the first diamond, we're going to add an edge to the constraint vertex and then back to that same diamond, allowing a path to just resume where it left off. And now you can see why I added those extra two vertices in the middle of each of the pathways in the diamond.
00:07:40.226 - 00:07:57.194, Speaker A: It was just to make sure we could do this sort of back and forth day trip, if you will, to this constraint vertex. Now we can just add two more edges to each of the second and third diamonds. Now notice this constraint is requesting a true assignment to x two and x three.
00:07:57.194 - 00:08:29.518, Speaker A: So that means if the path is traversing the second or third diamond in the correct direction, meaning from up to down, then again, we want to introduce these edges to just allow this quick trip to and from the new constraint vertex. For example, consider the following green St Hamiltonian path. Notice this st Hamiltonian path goes through each diamond in the downward direction.
00:08:29.518 - 00:08:57.660, Speaker A: So this path we should interpret as encoding the all true truth assignment. Now notice, assigning x one to true does not satisfy the constraint in question, does not meet its variable request, and accordingly, there's no way to visit this new constraint vertex, the black vertex on top from the first diamond without either skipping or visiting twice some vertex. And again we added these extra two vertices in the middle to make sure that this was true.
00:08:57.660 - 00:09:30.610, Speaker A: Assigning x two to true does satisfy the constraint, and this is the reason why the Hamiltonian path in green can take a quick back and forth day trip to the constraint vertex from the second diamond before resuming its downward journey exactly where it left off. Now, because x three's assignment also satisfies the constraint, such a day trip is also possible from the third diamond. But in this particular path, because the constraint vertex had already been visited from the second diamond, there's no reason in fact, you can't visit it from the third one in the Hamiltonian path.
00:09:30.610 - 00:09:47.014, Speaker A: So instead, the st Hamiltonian path just proceeds directly downward in the third diamond and then over to the destination T. There's also a second st Hamiltonian path that corresponds to this exact same truth assignment, the all true truth assignment. And it's just you flip what you do in the second and third diamonds.
00:09:47.014 - 00:10:08.606, Speaker A: So the second Hamiltonian path would go directly downward in the second diamond and then in the third diamond, that's when it would make the day trip over the constraint vertex and then come back and proceed all the way to T. Okay, good. That's how we handle one constraint and sort of change the graph to make sure that st Hamiltonian paths have to correspond to truth assignments that satisfy that constraint.
00:10:08.606 - 00:10:25.206, Speaker A: But what about the rest of the constraints? Well, we can just do exactly the same thing. So if we have a second constraint we want to accommodate, we're just going to add yet another vertex and then connect it to the middles of these diamonds. Now one thing that's a little annoying is we don't want the different constraint vertices to interfere with each other.
00:10:25.206 - 00:10:47.040, Speaker A: So we're going to add a new pair of vertices on these pathways internal to each diamond for each constraint that we have. So rather than having three hops to go up or down as we do with one constraint, now with two constraints, we're going to have five hops up and down. So let me do a little erasing and redrawing so that we can accommodate two constraints at the same time.
00:10:47.040 - 00:11:25.436, Speaker A: So now that we have these expanded diamonds, now with four vertices internal to the middle path in each diamond, we're going to reserve the top two of those four vertices for the first constraint and then the bottom two vertices of each of those is going to be reserved for the second constraint. So let me just redraw the light blue edges we had before interacting with the first constraint vertex, again using just the top pair of vertices internal to each of the paths inside the diamond. And now we'll do exactly the same trick with the second constraint vertex.
00:11:25.436 - 00:11:39.744, Speaker A: So the second constraint is making the opposite assignment request from the first one. So it actually wants x one to be true, x two to be false, x three to be false. So for example, from the first diamond we're going to allow a quick back and forth day trip to the second constraint vertex.
00:11:39.744 - 00:11:59.008, Speaker A: This bottom vertex if and only if it's going downward through that middle path in the first diamond. Remember, downward zigzags correspond to assignments of true. Let me again highlight an st Hamiltonian path for you.
00:11:59.008 - 00:12:17.520, Speaker A: It will again correspond to the all true truth assignment, so it'll go downward in each of the three diamonds. Now, as a Hamiltonian path, it has to visit both of the constraint vertices. So the top constraint, the top vertex, that's just like before, you can take a day trip, a back and forth trip to it from the second diamond or the third diamond.
00:12:17.520 - 00:12:36.844, Speaker A: I'm going to choose here to do it from the second diamond, but you could equally well choose to do it from the third diamond. Now, the bottom constraint vertex for the all true truth assignment, the only assignment we made that makes that second constraint happy is our true assignment to the first variable. For the second and third variables, we actually did the opposite of what this clause wanted.
00:12:36.844 - 00:13:04.182, Speaker A: So the only diamond from which we'll be able to make a back and forth sojourn to this bottom vertex is from the first diamond. So that's what the path is going to do. One possible point of confusion, just because this example is sort of so small.
00:13:04.182 - 00:13:19.594, Speaker A: So we have only three variables and both constraints actually involve all three of the variables. So that's why we have the light blue edges going to and from each of the constraint vertices from each of the three diamonds. Remember, in general, you're going to have N variables and you're going to have like three literals in each constraint.
00:13:19.594 - 00:13:36.850, Speaker A: So actually there will be no light blue edges between most of the diamonds and one of the constraint vertex. There will be at most three diamonds, the ones corresponding to the variables that appear in that constraint. And that's where you'll have a pair of light blue edges for each of those at most three diamonds.
00:13:36.850 - 00:14:17.382, Speaker A: The general reduction, the main result from this video, the reduction from three sat to directed Hamiltonian path, it's going to be literally the same as what is happening in this example, just scaled up to handle any number of variables and any number of constraints. So we're again going to have N diamonds, one diamond for each of our decision variables in the given three set instance, the diamonds will be stuck together in a necklace arranged in a sequence. Each diamond is going to have a path going both up and down internally and we'll subdivide the path a whole bunch of times and then we'll add one vertex for each of the constraints and we'll wire the constraint vertices to and from the diamonds.
00:14:17.382 - 00:14:40.550, Speaker A: So that the only way you can visit a constraint vertex from a diamond is if you're traversing that diamond in the direction corresponding to one of the variable assignment requests made by that constraint. Let me spell that out a little bit more formally. Again, just to be super clear, to triple check the direction of the reduction.
00:14:40.550 - 00:14:50.010, Speaker A: So we're reducing a known NP hard problem, which in our case is threesat. We're reducing it to the target problem. Directed Hamiltonian path threesat is our problem.
00:14:50.010 - 00:15:00.254, Speaker A: A, that's the light blue box we're trying to construct. Directed Hamiltonian path is our problem. B, that's the magenta box that we assume we have access to, so we're building the blue box.
00:15:00.254 - 00:15:18.482, Speaker A: So we're given as input instance two, three set. All we have going for us in trying to solve this instance of three set is that someone gave us a magenta box for the directed Hamiltonian path problem. So to make use of it, I guess we better construct some directed graph from our three set instance that we can feed into the magenta box.
00:15:18.482 - 00:15:42.278, Speaker A: And again, that construction is exactly the one we've done the last slide scaled up to an arbitrary number of variables and constraints. There's going to be n diamond graphs where N is the number of variables in the given three set instance and again they're going to be stuck together. So the rightmost vertex of one diamond is just going to be identified superimposed with the leftmost vertex of the next diamond.
00:15:42.278 - 00:15:57.690, Speaker A: And then there are going to be these paths that go up and down in the middle of the diamond. And if you think about it, we wanted two vertices for each of the constraints. So if there's m constraints, there's going to be two m vertices internally to that upward and downward path inside the diamond.
00:15:57.690 - 00:16:29.290, Speaker A: So that means the path length the number of hops to get from the midpoint of the top of the diamond to the bottom of the diamond, that's going to be two m plus one hops, visiting two m internal vertices along the way. Also, as we saw in the example, there's going to be one additional vertex that we add for each of the m constraints. So if you tally it up, how many vertices are there? Well, so in each of the N diamonds, there's two m internal vertices on the upward downward paths, so that contributes two times N times m vertices.
00:16:29.290 - 00:16:45.600, Speaker A: Then there's the vertices corresponding to the constraints, so that adds another m. And then there's the vertices in each diamond other than the ones internal to the upward downward path. So that's three vertices per diamond, plus then one extra for the destination vertex at the end, the vertex t.
00:16:45.600 - 00:17:04.502, Speaker A: As far as the edge set, we have the edges inside the necklace graph. So that's just like it was on the previous slide, right, so you have an edge from the leftmost vertex of a diamond to its top and its bottom vertices, and from its top and bottom vertices over to its rightmost vertex. And then you have these paths going up and down the middle.
00:17:04.502 - 00:17:16.266, Speaker A: So those are all of the edges inside the necklace. Finally, we need the edges to wire the necklace to and from the constraint vertices. And again, this works just like in the example.
00:17:16.266 - 00:17:48.318, Speaker A: So for a given constraint vertex, it contains some number of variables and it's going to have a pair of blue edges, one going to and one coming from each diamond corresponding to a decision variable that appears in that constraint either positively or negatively. So with a disjunction of three literals, there's going to be six edges, six light blue edges coming out of that constraint vertex, a pair for each of the three variables participating in that constraints. Now, in each of the diamonds we've reserved the jth pair for use by the jth constraints.
00:17:48.318 - 00:18:10.998, Speaker A: And then whether you attach that constraint vertex to the jth pair in one order or the other order, that depends on whether the jth constraint contains the variable xi positively or negatively. If it contains xi positively, then we want it to be possible to visit that constraint vertex going downward through the diamond. So that means you take the top vertex of the pair and you connect that to the constraint vertex.
00:18:10.998 - 00:18:31.346, Speaker A: And then you can come back from the constraint vertex down to the lower vertex of the jth pair, and then you do the opposite if it's the case that the constraint actually includes the literal, not xi phew. So that completes the construction of the directed graph. Probably the most complicated construction of this type that we're going to wind up doing.
00:18:31.346 - 00:18:43.410, Speaker A: But now we used to have a three set instance, now we have a directed graph. This is something we can feed directly into the assumed subroutine for directed Hamiltonian path. I guess we also have to tell the subroutine a starting vertex and a destination vertex.
00:18:43.410 - 00:19:01.786, Speaker A: But you already know what those are, right? The starting vertex is the leftmost of vertex of the first diamond, and the destination vertex is the right most of vertex of the last diamond. To complete the reduction, we have to finish building this light blue box. We have to say what actual solution we return to the three set instance we're responsible for.
00:19:01.786 - 00:19:26.910, Speaker A: So we're going to look at the output of the magenta box of the directed Hamiltonian path subroutine, and from it we have to extract an answer to that three set instance. And again, there's going to be two cases depending on whether we get a Hamiltonian path back or not. So if the subroutine comes back and says, hey, here's a directed st Hamiltonian path of your graph g, well, we know that a Hamiltonian path, it has to traverse all the diamonds in sequence, and it has to traverse them either upward or downward.
00:19:26.910 - 00:19:48.806, Speaker A: So either they visit the top vertex before the bottom vertex, or vice versa. So any Hamiltonian path we can interpret as a truth assignment, and in that case, we will just return that truth assignment as a solution to the three set instance we were given, as we'll see in the proof of correctness on the next slide. In that case, the truth assignment we returned must indeed be a satisfying truth assignment.
00:19:48.806 - 00:20:08.458, Speaker A: So the reduction is going to be correct in that case. On the other hand, totally possible that this directed Hamiltonian path subroutine says, hey, you gave me this directed graph that doesn't even have any SD Hamiltonian paths. In that case, you say, okay, sorry subroutine, and then you report back that the three side instance that you were handed in the first place must be unsatisfiable.
00:20:08.458 - 00:20:32.230, Speaker A: And again, we'll see in the proof of correctness on the next slide that whenever the graph g that we construct has no Hamiltonian path, it must indeed be the case that the original threesat instance was unsatisfiable. So the reduction is going to be correct in that case as well. Moving on to the correctness of the reduction, let me again draw the picture you should have in mind as we go through this proof.
00:20:32.230 - 00:20:44.486, Speaker A: The reduction is from three sat to directed Hamiltonian path. So three sat is our problem. A, it's our known NP hard problem, as per the Cook Levin theorem, and then directed Hamiltonian path.
00:20:44.486 - 00:20:48.646, Speaker A: That's our target problem. That's our problem. B, that we're trying to show is NP hard.
00:20:48.646 - 00:21:11.378, Speaker A: And so basically, we want to show that this reduction, even though it doesn't know in advance whether or not the three side instance it was given is satisfiable or not, it just constructs this graph capital G. The satisfiability status of the three side instance will be reflected in the graph g that it constructs. So given a satisfiable three side instance, this reduction winds up churning out a graph g with a Hamiltonian path.
00:21:11.378 - 00:21:25.498, Speaker A: Conversely, if the given three side instance is not satisfiable, it churns out a graph that does not have a Hamiltonian path. That's what we need to show. Let's start with just a basic observation about the reduction, which just follows by the way that we constructed the graph g.
00:21:25.498 - 00:21:33.754, Speaker A: So G may or may not have a Hamiltonian path. We don't know. But if it has a Hamiltonian path, any Hamiltonian path has to have a restricted form.
00:21:33.754 - 00:21:51.374, Speaker A: It has to look like the Hamiltonian path that we were drawing in the example. So in particular, the path has to go through the diamonds one by one. And each diamond either goes straight up or straight down through the path in the middle, except possibly interrupted by a back and forth day trip to a constraint vertex.
00:21:51.374 - 00:22:22.342, Speaker A: But importantly, you cannot be a Hamiltonian path and do anything other than visit a constraint vertex and come right back. A Hamiltonian path cannot jump from a constraint vertex to a different diamond because then there would be no way for it to resume where it left off in the diamond where it jumps to that constraint vertex in the first place. In other words, Hamiltonian paths can only differ in which direction they traverse a diamond going up versus going down, and exactly where in their journey they make a back and forth trip to a given constraint vertex.
00:22:22.342 - 00:22:37.922, Speaker A: But all Hamiltonian paths have that basic form. Also, as we've seen by construction, we've wired the constraint vertices to the necklace to the diamonds. So that the only way you can get away with visiting a constraint vertex and again, necessarily by just going there and coming straight back.
00:22:37.922 - 00:23:09.114, Speaker A: The only way you can manage that in a Hamiltonian path is from a diamond that you're traversing in the direction which would satisfy one of the assignment requests made by the corresponding constraint. So if the constraint has, say, not x one in it, and you're traversing the first diamond upward, corresponding to an assignment of false to the first variable, then indeed you have the option of going straight to that constraint vertex and back. But if you're traversing that first diamond downward, so in the wrong direction, you're not going to have that option.
00:23:09.114 - 00:23:38.850, Speaker A: And if you're a diamond that doesn't interact with that constraint at all, you're again not going to have the option of visiting that constraint vertex from that particular diamond. What these two things mean for us is that if anyone gives us a Hamiltonian path of the graph g, we're done. We can just immediately extract a satisfying truth assignment from that Hamiltonian path, right? Because this first observation tells us the Hamiltonian path has to have a very restricted form, has to traverse the diamonds in sequence, either upward or downward, interrupted only by these back and forth day trips to the constraint vertices.
00:23:38.850 - 00:23:57.270, Speaker A: At a Hamiltonian path. It has to do exactly one back and forth day trip to each constraint vertex. And by the second observation, the only way you can make one of those back and forth trips is by doing something in a diamond that corresponds to a variable assignment that satisfies the corresponding constraints.
00:23:57.270 - 00:24:08.730, Speaker A: So if you manage to visit all the constraint vertices, then the truth assignment that you're encoding does in fact satisfy all of the constraints. It is a satisfying truth assignment. Those are our basic observations.
00:24:08.730 - 00:24:25.310, Speaker A: Now, again, we need two cases to discuss, correctness, depending on whether or not the given three side instance was satisfiable or not. We want to argue that a reduction does the right thing computes the right solution in either case. So suppose first that the given three side instance is satisfiable.
00:24:25.310 - 00:24:45.398, Speaker A: Well, then, if you think about it, any satisfying truth assignment actually gives rise pretty immediately to a Hamiltonian path in the graph G that we constructed. So one such path traverses each diamond in the direction suggested by the satisfying assignment. So downward in any diamond for a variable set to true and upward for the other diamonds.
00:24:45.398 - 00:25:05.706, Speaker A: And then you take a back and forth day trip to the Jth constraint vertex at the earliest opportunity. So from whatever diamond is the corresponds to the first variable whose assignment satisfies the Jth constraint. By virtue of G having a Hamiltonian path, we know that our assumed subroutine for solving that problem will hand us back on a silver platter.
00:25:05.706 - 00:25:20.114, Speaker A: A Hamiltonian path. It may or may not be the same one that we just talked about, but it'll be some Hamiltonian path, given that there was one to find. And by the last of our observations, given that Hamiltonian path, the reduction extracts from it a satisfying truth assignment.
00:25:20.114 - 00:25:47.306, Speaker A: So the reduction does indeed correctly work when given a satisfiable three set instance. What about when it's given an unsatisfiable three set instance? Well, if the given three set instance is unsatisfiable, then because there's no satisfying truth assignments, you can't have a path from S to T that visits all of the constraint vertices without skipping or visiting twice some vertex. Right? Because if you did have such a path, then by our final observation, you could extract from it a satisfying truth assignment.
00:25:47.306 - 00:26:07.554, Speaker A: But there are no satisfying truth assignments, so that means there are no Hamiltonian paths to be found. Our assumed subroutine will correctly report that fact, and then our reduction, in turn, will correctly report that that three sat instance is unsatisfiable. So that completes the reduction from three sat to the directed Hamiltonian path problem.
00:26:07.554 - 00:26:22.760, Speaker A: Because the three sat problem is empty hard by the Cook Levin theorem, the directed Hamiltonian path problem is as well. Coming up next, we're going to have the big payoff of this video, which is we will finally prove that the traveling salesman problem is NP heart. I'll see you there.
