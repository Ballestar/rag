00:00:00.570 - 00:00:12.938, Speaker A: Hi, everyone, and welcome back to this lecture series on the foundations of blockchains. This is going to be lecture two. So we're going to tackle the state machine replication, or SMR problem that we introduced at the end of last lecture.
00:00:12.938 - 00:00:37.218, Speaker A: We're going to consider a sort of very optimistic model of the underlying communication network known as the synchronous model. And in this synchronous model, we will actually successfully solve the problem. We will do that by reducing it to a subroutine known as Byzantine broadcast and talking through a famous solution to the Byzantine broadcast problem known as the dole of strong protocol.
00:00:37.218 - 00:00:49.302, Speaker A: So let's get started. First, let me just sort of briefly remind you what the SMR or state machine replication problem is and what we want for it. Namely a protocol that satisfies consistency and liveness.
00:00:49.302 - 00:01:20.110, Speaker A: So we have a notion of nodes which are machines that are actually running the consensus protocol in question, and then clients, users of the protocol that are submitting transactions to one or more of the nodes. So for us, transactions would be something like a payment. So a currency transfer or maybe a smart contract function, call clients would correspond to the users of a blockchain protocol like, say, Bitcoin or Ethereum.
00:01:20.110 - 00:01:40.102, Speaker A: And here, nodes would just correspond to what's often called the full nodes running the Bitcoin or Ethereum protocol. So what are nodes doing besides just receiving in transactions from clients? Well, also, each node is responsible for maintaining a locally stored history. Here, when I say history, what I mean is an ordered sequence of transactions.
00:01:40.102 - 00:01:58.490, Speaker A: Now, don't forget, for us, order really matters. So, for example, if we think about two transactions that are currency payments, both trying to spend the same coins, sort of an intended double spend attack, perhaps it really matters which of those two transactions comes first in the history. The first transaction will succeed and the coins will be spent.
00:01:58.490 - 00:02:17.394, Speaker A: When the second transaction comes along, the coins will already be spent and that transaction will fail. So they maintain the transactions that have been executed along with the order in which they have been executed. Each local history is an appendonly data structure, so transactions can get tacked onto the end of the local history, but they are never removed.
00:02:17.394 - 00:02:35.866, Speaker A: So these lists just grow over time as the protocol continues to run. In the last lecture, we mentioned how consensus is really the fundamental problem that any blockchain protocol must solve. But what does it mean to solve the consensus problem? Right, again, if it's a one shot problem like, say, single source, shortest paths or something, it's clear what it means to solve it.
00:02:35.866 - 00:02:58.434, Speaker A: Given a network, you're supposed to compute the shortest path from one vertex to another. But for something which runs forever, like a consensus protocol on all these machines distributed all over the globe, what does a solution mean in the SMR problem? What it's going to mean? It's going to mean a protocol that has two particular properties. And remember, when I say a protocol, what I mean informally is just a piece of code.
00:02:58.434 - 00:03:09.330, Speaker A: It's a piece of code that's going to be event driven. So it's running on a node. And when it for example receives some message from maybe a client or maybe from another node, then this code is going to respond with some actions.
00:03:09.330 - 00:03:22.150, Speaker A: Like for example, the node can maintain local state and it can do local computation on its local states. And maybe it'll also communicate. So in response to a message it just received, maybe it will send a message to various other nodes.
00:03:22.150 - 00:03:38.926, Speaker A: So what are we going to want from our protocol? When would we deem it a solution? So we're going to have one safety property. Remember, a safety property asserts that some bad event literally never occurs. And then we're also going to want to have one liveness property stating that good things eventually occur.
00:03:38.926 - 00:03:56.738, Speaker A: So in our context here, for the SMR problem, the safety property we're interested in is going to be consistency. So for us, the bad event that we're super worried about is that two different nodes disagree on the relative order of two transactions. So for example, two transactions spending the same coins.
00:03:56.738 - 00:04:14.602, Speaker A: What's an epic fail for us. If one node puts one of the two transactions first and another node puts the other transaction first, that is the bad event we want to literally never have happen. So what that means is we want all of the nodes to have identical local histories, same transactions executed in exactly the same order.
00:04:14.602 - 00:04:26.880, Speaker A: Now we can be a little more relaxed than that, right? Because again, remember, maybe these nodes are scattered all over the globe. Maybe there's a node in Siberia that hears about everything 20 seconds later than everybody else. It's okay if you have a node lagging behind.
00:04:26.880 - 00:04:43.122, Speaker A: We're sort of waiting for it to catch up as long as it doesn't disagree on the relative order of a pair of transactions. So in other words, that node in Siberia, maybe their local history is a prefix of everyone else's and that's fine. But we never want to see transactions in opposite orders on two different nodes.
00:04:43.122 - 00:04:54.186, Speaker A: So our second property is liveness stating that good things eventually happen. What for us is a good thing. A good thing is a client has submitted a transaction and that transactionally actually gets added to everybody's local history.
00:04:54.186 - 00:05:09.306, Speaker A: So for any client submitted transaction, we want that to happen eventually. So obviously this limited condition doesn't apply to bogus transactions. Like if clients are supposed to sign transactions and somebody submits one without the signature, maybe that just gets filtered, never gets added to everyone's local histories.
00:05:09.306 - 00:05:30.866, Speaker A: That's fine. What we mean is the transactions that really should be added do eventually get added. So over the next several lectures, the sort of million dollar question for us will be does there or does there not exist a protocol that satisfies these two properties, consistency and liveness? And what we're going to learn is that the answer to that question depends in extremely interesting ways on what assumptions you make.
00:05:30.866 - 00:05:48.906, Speaker A: So we will have several cases where under assumptions, we prove it is possible to have a protocol meeting these two properties. We'll also prove formally that there are other cases where you cannot have a protocol meeting both of these two properties. For example, we'll see that it crucially matters what you assume about the underlying communication network and how reliable it is.
00:05:48.906 - 00:06:18.338, Speaker A: And then we'll see it also really matters how powerful the adversary is or sort of equivalently how many of the nodes running your protocol are compromised versus how many of them are running it in the intended correct way. So the plan both for this lecture and the next several lectures is we're going to first make a bunch of assumptions, really more assumptions than we're comfortable with, but we will at least then make it sort of pretty easy to see that there are protocols satisfying liveness and consistency under all of those assumptions. Then we're going to work hard to relax those assumptions one by one.
00:06:18.338 - 00:06:34.702, Speaker A: That'll give us sort of more complicated, but also more practical and robust solutions to the consensus problem. So let me tell you about the initial four assumptions that will actually make the SMR problem really quite easy. These are the four assumptions we're going to work on relaxing over the next several lectures.
00:06:34.702 - 00:06:53.594, Speaker A: And these are assumptions on top of the two permanent assumptions that I introduced in lecture one. Remember, we're always going to be assuming that the Internet exists so untrusted parties can have at least semi reliable point to point communication. And we're always going to be assuming that cryptography exists so we won't blink an eye about using say, digital signature schemes or cryptographic hash functions.
00:06:53.594 - 00:07:14.210, Speaker A: So the first thing we're going to assume is that we're working in what's called a permissioned setting. And what this means is that the set of nodes responsible for running the protocol is fixed and known upfront at the time the protocol starts. We're going to use little N to denote the number of nodes, the number of machines that are running the protocol.
00:07:14.210 - 00:07:38.302, Speaker A: The nodes have distinct names that everybody knows. So for simplicity, I'll usually just number the nodes one up to N, but maybe you can think of them as being identified by their IP addresses. So when a node sort of spins up and fires up this protocol, it's actually given a list of N minus one IP addresses and basically being told these are the N minus one other IP addresses you should be expecting to hear from, to receive messages from.
00:07:38.302 - 00:08:07.906, Speaker A: And you should feel free to send those other N minus one nodes your own messages as well. Now, pretty much the entire 20th century literature about consensus protocols works in the permissioned setting. And if you remember what we talked about last lecture, the sort of old school applications of the problem like say, you know, replicating a database, it's actually kind of clear why everybody was totally comfortable making this assumption, right? I mean, if you're just trying to do theory to help guide IBM, figure out how many copies of the database it should run, and you just wind up telling them like, buy seven machines, run seven copies.
00:08:07.906 - 00:08:19.638, Speaker A: Obviously you know what that set of seven copies are at the beginning of the protocol. And that's why you hear this terminology about the permissioned setting versus the permissionless setting. Permission setting, basically, you need permission to be one of the nodes participating in the protocol.
00:08:19.638 - 00:08:33.034, Speaker A: In a permissionless protocol like bitcoin or ethereum, anybody can join, anybody can contribute to running that protocol. So we certainly will be relaxing this assumption eventually. In particular, right, we'll be talking about bitcoin and ethereum in some depth.
00:08:33.034 - 00:08:59.746, Speaker A: But it's still really useful to focus on the permission setting for a number of lectures for a few reasons. So first of all, the permissionless setting is only harder, right? So if you haven't figured out how to achieve consensus in the permission setting, or maybe even worse, it's provably impossible to achieve consensus in the permission setting, you're not going to get it in the permissionless setting either under that same set of assumptions. So it makes sense to really tackle the permissionless protocol design problem in two steps.
00:08:59.746 - 00:09:22.042, Speaker A: So first of all, what would you do if it was permissioned, if you did have this sort of static and known set of nodes up front? And then maybe, is there some way you can bootstrap that into a permissionless protocol? Indeed, some of the sort of practical blockchain protocols that are out there very much follow this approach. They basically reduce the permissionless design problem to the permissioned problem. Okay, assumption number two is known as the PKI assumption.
00:09:22.042 - 00:09:37.934, Speaker A: Here, PKI stands for public key infrastructure. So what does this mean? This means, first of all, each node I is going to have its own public key, private key pair that it's generated. Remember, we're assuming the cryptography exists, so we'll be using that in this assumption.
00:09:37.934 - 00:09:51.474, Speaker A: But more strongly, it's not just going to be that every node has a public key and a private key that it knows. We're going to assume that all of the nodes know up front everybody else's public key. So you already know all of the other nodes IP addresses.
00:09:51.474 - 00:10:08.286, Speaker A: That's from assumption one. Now you're going to know their public keys as well. And as a result, any one of these nodes is in a position to verify the signature of any one of the other nodes on some message that they've sent just by running the verification algorithm in the digital signature scheme that we talked about in lecture one.
00:10:08.286 - 00:10:33.494, Speaker A: Running that with the known public key of the alleged sender of a message to you. So PKI is one type of a trusted setup assumption meaning that we're trusting that something happened honestly and correctly before the protocol ever started. So here we're assuming that everybody's public keys got correctly distributed and we're not going to detail how this happened, how these public keys got distributed, we're just going to assume that it happened.
00:10:33.494 - 00:10:53.546, Speaker A: Now of course in practice you can probably already think of ways you might go about approaching distributing a bunch of public keys to everybody. But again, we're just going to take it on faith that that did in fact happen. Now on the one hand, of the four assumptions we're going to put on this slide, PKI is maybe the one that's going to bother us the least and we're not actually going to focus so squarely on trying to relax it.
00:10:53.546 - 00:11:02.586, Speaker A: That said, there are blockchain protocols that don't need this assumption. In fact Bitcoin and Ethereum for example, do not need this assumption. Now they make a different trusted set of assumption.
00:11:02.586 - 00:11:17.230, Speaker A: You have to assume that the protocol designers didn't sort of pre compute the genesis block. We'll say more about that later but they don't need a PKI assumption which is nice. All that said, if the biggest flaw with your protocol is that it requires a public key infrastructure, it's probably a pretty good protocol.
00:11:17.230 - 00:11:34.578, Speaker A: So our third assumption, which is going to be super important in this lecture and also in lecture three, is we're going to make a very optimistic assumption about the behavior of the underlying communication network. And so formally what we're going to do is we're going to assume we're in what's known as the synchronous model. And this is really two different sub assumptions.
00:11:34.578 - 00:11:58.254, Speaker A: So first of all we're going to assume that all of the nodes share some global clock. So all of the nodes have a common knowledge of exactly what time it is at any given moment. And so as a consequence we can sort of break time into intervals, right? Maybe a very conservative interval for best case scenario in the internet would be say a ten second interval and then all of the nodes will just be locally keeping track of which time interval they're in.
00:11:58.254 - 00:12:15.286, Speaker A: And because it's a global shared clock they will all agree on exactly what time interval they're currently in. So this sub assumption maybe we could live with, again, you could maybe start thinking about ways in practice you might sort of approximately satisfy this. The second sub assumption is the one that's going to bother us with how strong it is.
00:12:15.286 - 00:12:40.826, Speaker A: We're going to assume sort of very reliable delivery of information across the communication network. So specifically we'll assume that any message a node sends to another node at some time step T will arrive at the intended recipient by the start of the next time step, by the start of time step T plus one. So for example, if time steps correspond to ten second intervals, we could all agree that we're only going to send messages sort of at the beginning of an interval.
00:12:40.826 - 00:13:10.742, Speaker A: So maybe if it's 20 seconds have passed, I'll send a bunch of messages and the assumption is that all of those will arrive at the intended recipients by the 32nd mark on our clock. So this assumption, maybe it's reasonable under like, best case scenario, if you're using the internet as your communication network, assuming the time interval is something like 10 seconds. But it's certainly not going to be satisfied if you have, say, network outages, which of course we have all the time, or if you have attacks, right? So for example, a denial of service attack.
00:13:10.742 - 00:13:23.750, Speaker A: And remember, with blockchain protocols that are controlling billions of dollars of value, you need to expect attacks. I mean, they really are going to happen. And denial of service attacks really can force messages to get delayed more than, say, 10 seconds.
00:13:23.750 - 00:13:51.570, Speaker A: In the event that a node receives a bunch of different messages from a bunch of different nodes in a single timestep, those messages arrive in some sort of unknown, arbitrary order. So when you're probing the guarantees that blockchain protocols offer, it's very important you don't stop with the synchronous model. So sort of a necessary condition to being a well designed blockchain protocol is that if you happen to be in the synchronous model, if you happen to have very reliable communication, then the protocol should have everything you want.
00:13:51.570 - 00:14:13.674, Speaker A: It should be sort of very efficient, it should have consistency, it should have liveness, et cetera. That's a sanity check because remember, real blockchain protocols that hold a lot of value, they will at some point be operating in an environment where these synchronicity assumptions do not hold. For example, if there's a denial of service attack and in fact, what we're going to see is that in the presence of attacks like that, you actually cannot continue to have it all.
00:14:13.674 - 00:14:22.986, Speaker A: Some of the stuff you have in the synchronous setting must break down. We will see. You cannot actually get both consistency and liveness in the presence of attacks.
00:14:22.986 - 00:14:52.578, Speaker A: You have to give up on one of them. So when you're assessing a blockchain protocol, you have to ask, how does it handle the stress test of a denial of service attack when the synchronicity assumption doesn't hold? Does it give up liveness? Does it give up safety? God forbid? Is it a badly designed one that gives up both? These are the questions you need to ask when you're comparing different consensus protocols. So like I said, we'll spend a couple of lectures in the synchronous model, but then we're going to work hard to really relax this and it's going to take us a while to figure out what is a useful relaxation of this communication assumption.
00:14:52.578 - 00:15:06.170, Speaker A: But we will get there in a couple of lectures. The final assumption I'm going to make is really ridiculous, and we're going to start relaxing it already in about ten minutes. But just for ten minutes or so, let's assume that all of the nodes running the protocol are honest.
00:15:06.170 - 00:15:18.202, Speaker A: And here, honest is actually not a statement about intent. It's really just a statement about behavior. So we're going to assume that all of the nodes, correctly and without bugs and without deviations, run the intended protocol.
00:15:18.202 - 00:15:34.886, Speaker A: So this assumption, it's way too strong, even for those sort of old school applications from the 1980s. This is way too strong, right? If IBM is running seven servers, each with a copy of the database, once in a while, one those servers is going to go down, which would be a violation of the all honest synchronous model. So we'll relax this.
00:15:34.886 - 00:15:49.220, Speaker A: But what I want to do first is just point out, at least under these four assumptions, we can get everything we want with respect to the SMR problem, we can have a consensus protocol that's both consistent and live. So let's see exactly how that works in the next video. See you there.
