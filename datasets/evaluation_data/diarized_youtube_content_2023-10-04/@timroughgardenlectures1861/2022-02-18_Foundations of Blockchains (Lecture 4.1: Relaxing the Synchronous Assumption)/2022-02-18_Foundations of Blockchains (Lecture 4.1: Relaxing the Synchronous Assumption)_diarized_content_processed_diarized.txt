00:00:00.170 - 00:00:18.622, Speaker A: Hi everyone and welcome to lecture four in this lecture series on the foundations of blockchains. So the agenda for today is to introduce you to what's known as the Asynchronous model of communication. So we're going to be studying consensus protocols with much weaker assumptions about the underlying communication network than we had in lectures two and three.
00:00:18.622 - 00:00:40.090, Speaker A: When you'll recall, we were working in the synchronous model with a shared global clock and guaranteed message delivery. So we'll get started on the proof of the FLP Impossibility theorem in the second half of lecture four and then the rest of the proof will actually consume all of lecture five. So this will probably be the longest and most difficult proof that we do at any point in this lecture series.
00:00:40.090 - 00:00:58.538, Speaker A: And it'll actually be a feather in your cap that you watched this proof and hopefully understood. It really puts you in quite rarefied company indeed. If ever you're talking to someone and they're posturing as an expert in consensus, I encourage you to ask them if they know the statement of the FLP Impossibility Theorem.
00:00:58.538 - 00:01:14.318, Speaker A: And of course, if you really want to be hostile, you can ask them if they know anything about the proof, which as we'll see, is not so easy. So just a quick recap to remind us all of the context. So in lecture two, the main point there was to study the Dole of Strong protocol.
00:01:14.318 - 00:01:36.170, Speaker A: So that was a solution to the Byzantine Broadcast problem, satisfying agreement and validity. And from that subroutine for Byzantine broadcast we built a protocol for state machine replication, satisfying consistency and liveness, which is what we wanted all along. Now we did that, however, in lecture two, under four assumptions that we want to work on relaxing.
00:01:36.170 - 00:01:56.930, Speaker A: So assumption number one is that the protocol starts out with a known node set. Again, this node set is common knowledge that these are the only nodes that are permitted to run the protocol and we'll be keeping the permissioned assumption for a couple more lectures, although obviously we eventually want to relax it. That's one of the big innovations of Bitcoin is permissionless consensus.
00:01:56.930 - 00:02:15.640, Speaker A: So the second assumption we looked at was PKI or public key infrastructure. And so that know, first of all, you're assuming that cryptography exists, so you have access to a secure digital signature scheme. So nodes can sign messages in a way that is verifiable by others but also unforgivable by anyone who doesn't have the private key.
00:02:15.640 - 00:02:37.054, Speaker A: But also part of the PKI assumption is that all of the nodes public keys are common knowledge. So again, the protocol is born with the nodes not just knowing about each other and how to communicate with them, like their IP addresses, but also knowing the public keys of all of the other nodes. And what we saw in lecture three was that the PKI assumption was super, super important for Dolov Strong to work.
00:02:37.054 - 00:02:58.270, Speaker A: We actually proved an impossibility result in lecture three showing you probably cannot get the guarantees that Dolofstrong offers without making a trusted setup assumption like PKI. Now it turns out the PKI assumption is actually not going to play a big role in the next couple of lectures. And in particular, the impossibility result we're going to discuss holds whether or not you make a PKI assumption.
00:02:58.270 - 00:03:11.514, Speaker A: So don't worry so much about that assumption for the next couple of lectures. A third assumption that we made in the last couple of lectures and that we'll continue to make is that at least some of the nodes run the protocol honestly. By honest.
00:03:11.514 - 00:03:35.162, Speaker A: That means without any intentional or unintentional deviation from what the protocol prescribes. And we'll use a parameter little F to denote an upper bound on how many nodes cannot be honest, how many nodes might deviate from what the protocol prescribes. And in a blockchain setting, the most appropriate model for sort of a node which is not honest is to assume it's controlled by an attacker.
00:03:35.162 - 00:03:56.018, Speaker A: So something known as a Byzantine node and we basically make no assumptions about the behavior of Byzantine nodes. We might assume something like they can't break cryptography, but they can try to manipulate the protocol in any way that they like. Now notice that sort of the bigger F is the more Byzantine nodes, the fewer the honest nodes, the harder it's going to be to have a consensus protocol.
00:03:56.018 - 00:04:13.310, Speaker A: So for positive results, for protocols, you'd like to have guarantees for the largest possible little F possible. You'd like tolerate as many failures, as many Byzantine nodes as you can. That's what made Dole of strong such an impressive protocol, which is that little F could be anything and it would still offer validity and agreement.
00:04:13.310 - 00:04:45.282, Speaker A: Now, turning that around, when you're talking about impossibility results, as we are here, then the smaller the F, the more impressive the impossibility result. So if you prove that no good consensus protocol exists with 100 Byzantine nodes and someone else proves that you can't even have a good consensus protocol with only ten Byzantine nodes, that second statement is stronger than the first. So impossibility results are more and more impressive as the number of Byzantine nodes F required to force the impossibility gets smaller and smaller.
00:04:45.282 - 00:05:03.910, Speaker A: And remarkably, we'll see that the FLP Impossibility theorem holds even if F equals one, even in the presence of one faulty node. So in that sense, it's the strongest impossibility result you could imagine. The fourth and final assumption, and the one that we're going to work hard on relaxing over these next few lectures was the synchronous model assumption.
00:05:03.910 - 00:05:28.638, Speaker A: And so again, remember that was really sort of two assumptions rolled up into one. Okay, so last week we were assuming that all of the nodes shared a global clock. So there was a global notion of time steps ticking away with every node, sort of being fully aware of which timestep it's currently in secondly, we are assuming guaranteed message delivery, meaning any message sent at a particular time step, little t arrives at the beginning of the next time step.
00:05:28.638 - 00:05:40.470, Speaker A: Little t plus one. Now, the first of these assumptions, a shared global clock maybe we could live with. You could imagine in practice how you might go about at least trying to sort of approximate that assumption.
00:05:40.470 - 00:06:13.906, Speaker A: But the second sub assumption is really just completely unreasonable and really we just can't trust a protocol that relies too heavily on that second assumption, right? Like imagine we're thinking about nodes communicating over the Internet and maybe we try and be generous and set the length of a time step to be, say, a second or two. Now, the good news is that many messages sent over the Internet will in fact arrive in a timely manner within a second or two. On the other hand, as I think all of us have experienced, there are many cases where messages sent do not get delivered in that amount of time where they take quite a bit longer.
00:06:13.906 - 00:06:47.498, Speaker A: And there's a million reasons why this could happen, right? So like maybe the Internet's just a really congested day or part of it is and there's lots of packets getting dropped and so your messages have to be retransmitted multiple times before they're finally received by the intended recipient. Or maybe the BGP routing protocol is having a really bad day and sort of sending your messages in some very strange route to get to the intended destination. Obviously you can have unexpected outages, for example, from your Internet service provider or maybe even big delays are being caused deliberately by a malicious actor.
00:06:47.498 - 00:07:14.870, Speaker A: Maybe the canonical example here would be a denial of service attack. It's like one simple example of a denial of service attack is suppose there's sort of one node on the Internet and you want to basically cut them off from communicating with anybody else. You could, for example, rent a big botnet, have all of the machines in the botnet sort of pummel the target node with data packets so it overwhelms its ability to process incoming traffic and then basically nobody can talk to that node while this attack is ongoing.
00:07:14.870 - 00:07:50.784, Speaker A: All right? So how can we go about sort of relaxing this assumption of guaranteed message delivery by the next time step? Well, maybe the first thing you'd think of is like okay, maybe some messages won't get there the next time step, right? So maybe they'll be delayed ten or even like 100 time steps. So messages get sent, they get delayed by some variable amount somewhere between one and 100. Now, unfortunately, this simple idea is sort of an utter failure as far as relaxing the synchronous model.
00:07:50.784 - 00:08:09.464, Speaker A: So for example, take the dole of strong protocol, right? So in that protocol the leader did something at time zero and then all the other nodes did stuff at times step one, time step two times step three, et cetera. So suppose now I tell you that, oh, messages might get delayed up to 100 time steps. Well, the obvious thing to do is just sort of inflate your notion of time.
00:08:09.464 - 00:08:53.674, Speaker A: So in the dull of strong protocol, instead of having the non senders first act at time one, they're going to act at time t equals 100 to make sure that they heard whatever it is that the sender wanted to tell them. Similarly, the next time nodes act will be at time t equals 200 to make sure that they've had time to receive all of the messages sent at time t equal 100 and so on. Similarly, if you wanted to try to relax the first assumption in the synchronous model of a global shared clock, you could imagine, say, okay, well, maybe nodes clocks aren't perfectly synchronized, but let's assume that there's some maximum sort of drift you can have.
00:08:53.674 - 00:09:17.106, Speaker A: So let's assume that all nodes clocks at all moments in time are at most ten minutes apart from each other. Well, for much the same reasons, this again does not take you out of the synchronous model. So basically, again, by using this sort of time inflation trick, you can show that at least theoretically, at least in principle, having clocks with operatory known bounded drift is equivalent to having a global shared clock.
00:09:17.106 - 00:09:51.830, Speaker A: So that's a good statement for you to think through as an exercise exactly how that time inflation argument would work. So our first attempt of relaxing the synchronous model, having this known bound on maximum message delay, wound up being extremely unsatisfying and really it's sort of for two semirelated reasons. So reason number one is it really didn't force us to address the main issue with communication over the internet that you can have unexpected outages and unexpected attacks.
00:09:51.830 - 00:10:13.018, Speaker A: The second reason it's unsatisfying is we get these very stupid protocols from using this time inflation trick, protocols we really never want to use. So think about dola strong, right? So now all of a sudden nodes are only doing work at time zero and 102 hundred to make sure that they hear all of the messages they need to hear. And if messages are being delivered quite promptly, right, so they're all delivered by time 101.
00:10:13.018 - 00:10:28.820, Speaker A: All of the nodes are going to sit idly for the next 99 time steps just in case some extra message comes in later so that they can then do their work at time t equal 200. And you do not want a real life protocol to have this property, you want a real life protocol. If the network is fetched, the protocol should also be fast.
00:10:28.820 - 00:10:55.020, Speaker A: So that's actually really the basic idea behind what's known as the partially synchronous model, which we'll start talking about in earnest in lecture six and which we'll use to analyze various blockchain protocols. It makes sense to sort of first ask what can we do? Can we have good consensus protocols under no assumptions whatsoever about out message delivery. And that idea now brings us to the definition of the Asynchronous model.
00:10:55.020 - 00:10:55.640, Speaker A: The.
