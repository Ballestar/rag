00:00:00.250 - 00:00:26.470, Speaker A: So let me give you just sort of a brief overview of what we're going to be seeing over the next six lectures, lectures two through seven, which really form a quite coherent unit. So in lecture one, we talked about how the fundamental problem that any blockchain protocol must solve is consensus, right? You're trying to keep a bunch of different machines in sync about the state of the blockchain. For that reason, we want to start studying consensus, really from first principles.
00:00:26.470 - 00:00:45.578, Speaker A: And so the point of these six lectures is to give you a boot camp on sort of a bunch of amazing work that was done in the 1980s, mapping out exactly what consensus protocols can and cannot do. So this is super important material, as I'll elaborate on in the next slide. That's why we're spending so much time on it.
00:00:45.578 - 00:00:56.218, Speaker A: And don't let the fact that it's kind of quote unquote old disturb you. Everything we'll talk about is from the 1980s. In lecture seven, we'll sort of culminate the discussion with a modern blockchain protocol, the tendermint protocol.
00:00:56.218 - 00:01:22.950, Speaker A: But for the most part, all of this stuff will be work from the 1980s. That doesn't mean it's not super important, right? When you study algorithms, you study, for example, dynamic programming and the idea of an NP hard problem, right? Those ideas are also over a half century old, but they very much inform how modern algorithm design works. And so too will this classic material from the 1980s inform us about what we should expect blockchain protocols to be able to achieve.
00:01:22.950 - 00:01:59.598, Speaker A: Now, this will probably be the only part of the lecture series where we talk about ideas from the 20th century, right? It's a lecture series on blockchains, which are a quite recent idea. So the rest of the time we will really be focused on the last fiveish years plus the immediate future. So I should also caution you that despite being kind of at the very beginning of this lecture series, this segment is probably the most hardcore part, actually, of the whole lecture series, we will be seeing several proofs, both of possibility results, meaning we'll talk about some concrete consensus protocols and prove that they have appealing guarantees.
00:01:59.598 - 00:02:16.850, Speaker A: And we'll also see several proofs of impossibility results showing that good consensus protocols do not exist unless certain assumptions are made. So, on the one hand, I really encourage you to spend some quality time with this material. These are super famous results from distributed computing.
00:02:16.850 - 00:02:34.942, Speaker A: A lot of the proofs are super cool, but also, if you sort of get lost along the way here and there, you should not worry about it. That should not discourage you from pushing on for the rest of the lecture series. The rest of the lecture series is also sort of geared toward technical people, for example, people with some computer science training.
00:02:34.942 - 00:02:54.254, Speaker A: But it will not be as proof heavy, it will not be as sort of mathematical as the lectures that are about to come. So now let me just sort of give you kind of a little capsule summary of each of the next six lectures, lectures two through seven. I want to do this for a number of reasons.
00:02:54.254 - 00:03:15.526, Speaker A: So number one, I want to make explicit the logic behind the sequence of lectures we're about to see. So there really will be a story we'll be telling throughout these six lectures, and I want to just make it explicit what that story is going to be right up front. Number two, I want to give kind of a pitch encouraging you to actually spend the time to watch all six of the lectures.
00:03:15.526 - 00:03:32.046, Speaker A: And so I hope telling you about the really cool things you'll learn in them will inspire some of you to do that. So number three, I realize that some of you may want to dabble in classical consensus, sort of watch some, but not all of the videos. And so hopefully these capsule summaries will indicate where you should spend your time.
00:03:32.046 - 00:03:54.406, Speaker A: So which lectures and which parts of which lectures are going to be most valuable to you? Fourth, and finally, I'm not under any delusions, I realize many of you probably the last thing you want to do is spend time talking about math, theorems, proofs, et cetera. And you may just wind up sort of skipping this whole boot camp and moving on to the 21st century part of the lecture series. And that's fine.
00:03:54.406 - 00:04:13.680, Speaker A: But for those of you I at least want to give you a summary of what you're going to be missing. So what are the high level takeaways from these six lectures so that you have that context as you move forward? All right, so let me now tell you what you're going to learn in each of the lectures. And actually, I think the overall narrative will be clearest if I talk about the lectures out of order.
00:04:13.680 - 00:04:41.830, Speaker A: So the culmination of these six lectures is we're going to talk about a real blockchain protocol that's really out there in the wild called the tendermint protocol. Now, if the only blockchains you know about are bitcoin and ethereum, say, you won't have come across tendermint. But if you know about kind of half a dozen layer one blockchain protocols, you probably do know some that are based on Tendermint, cosmos and Terra being two of several examples.
00:04:41.830 - 00:05:03.610, Speaker A: So remember, one of the overarching themes of this lecture series is we want to emphasize principles over protocols. So this will be one of those cases where we really do talk about a specific protocol that's used in the real world, and we talk about exactly how it works. But also, a lot of our interest in the Tendermint protocol will be in the provable guarantees that it enjoys.
00:05:03.610 - 00:05:25.330, Speaker A: Specifically, we'll prove two things about the Tendermint protocol. So first of all, it achieves a property known as consistency, meaning all of the nodes running the protocol stay in sync in a certain precise sense. And further, it satisfies eventual liveness, meaning that transactions that are submitted to the blockchain will eventually get added to everybody's local histories.
00:05:25.330 - 00:05:44.582, Speaker A: So hopefully that sounds pretty cool, like a good use of your time. We're going to learn sort of exactly how a real blockchain protocol works, one that really drives some pretty high profile blockchain projects. But even better than that, we're going to show that that protocol has some appealing provable guarantees.
00:05:44.582 - 00:06:03.914, Speaker A: And through those proofs we'll wind up learning not just how tendermint works, but also why it works the way that it does. So that's going to be lecture seven, but we're going to have to do some work building up to being able to prove these properties of the tendermint protocol. So first of all, consistency and eventual liveness.
00:06:03.914 - 00:06:24.498, Speaker A: Maybe you have an idea what consistency means, maybe about liveness. What does eventual liveness mean? Well, we're going to carry out our analysis of the tenderman protocol in what's known as the partially synchronous model of communication. The basic idea of the partially synchronous model is to think about the operation of a protocol in sort of two different phases.
00:06:24.498 - 00:06:55.620, Speaker A: One phase being normal operations, meaning messages are getting delivered in a reasonable amount of time, but then also in sort of an attack mode where there's either big network outages or there's denial of service attacks or something like that. And the partially synchronous model says, well, you'd like to have really good properties under normal operating conditions, you would like to not break too badly while under attack, and you would also like to recover quickly once an attack ends. So the formal specification of all of that you'll learn in lecture Six as we discuss this partially synchronous model.
00:06:55.620 - 00:07:24.460, Speaker A: So if you're focused on blockchains and you really only want to remember one model of communication, probably the partially synchronous model is the one you want to remember. It's really quite important for the analysis of blockchain protocols. For example, also as part of lecture six, we're going to prove an impossibility result which states that you really need 67% two thirds of the nodes running your protocol, to be honest, in order to get the guarantees that you'd like.
00:07:24.460 - 00:07:47.394, Speaker A: In other words, in the partially synchronous model there's a remarkable threshold at 33%. So you can basically have a good consensus protocol if and only if less than a third of the nodes running the protocol are deviating from it in any way. And you actually see this 33% quoted all the time in the blockchain world in various white papers, for example in ETH 2.0.
00:07:47.394 - 00:08:09.880, Speaker A: So you'll often see protocols that come with the caveat that the protocol's behavior is guaranteed, say, if it's a proof of stake protocol, provided less than a third of the stake is controlled by an attacker, more than two thirds of the stake belongs to nodes. Honestly following the protocol that 33% you see in various white papers. It's literally the same 33% which you're going to learn in lecture six.
00:08:09.880 - 00:08:38.580, Speaker A: The final thing we're going to do in that lecture six is relate our discussion of what's possible and impossible in the partially synchronous model to a famous principle from distributed systems known as the Cap theorem. So, like I said earlier, if you remember only sort of one model of message delivery for the analysis of consensus protocols, partially synchronous model should probably be the one you remember. It's really the one that best articulates the actual trade offs the real life blockchain protocols really have to grapple with.
00:08:38.580 - 00:08:59.560, Speaker A: Now, if I just opened lecture number two with the formal definition of the partially synchronous model, I think most of you would just kind of like, stop the video and sort of forget about it. You'd see, like, I don't know why this instructor is sort of writing down something relatively complicated for something that seems super simple. You're just modeling like, communication in the network upon which a blockchain protocol is running.
00:08:59.560 - 00:09:21.440, Speaker A: And so the right way to understand the partially synchronous model is really as a sort of interpolation or sweet spot between two kind of more obvious models you might write down and start to reason about. One of those called the synchronous model is going to be the subject of lectures two and three. The other sort of polar opposite extreme, the asynchronous model, that'll be the subject of lectures four and five.
00:09:21.440 - 00:09:46.790, Speaker A: So the synchronous model, which we'll be studying in lectures two and three, that's actually a pretty good model of a communication network in sort of times of normal operation. So the formal assumption there is going to be that whenever one node running a protocol sends a message to another node running that protocol, that message will be delivered within some reasonable amount of time. There'll be some bound delta on the number of time steps that can elapse before that message is guaranteed to have been received.
00:09:46.790 - 00:10:11.630, Speaker A: For example, if you're talking about sort of best case operating conditions of the internet, you could probably take that maximum message delay bound delta to be something like a second. Now, the good news about the synchronous model is that there's going to be some consensus protocols with really impressive properties. And so lecture two, we're going to focus on a possibility result, meaning we're actually going to give a protocol from the early 1980s, which we're going to call the dole of strong protocol.
00:10:11.630 - 00:10:44.150, Speaker A: The dole of strong protocol is for a single shot consensus problem known as Byzantine broadcast. And so we'll also see in lecture two how state machine replication, like we talked about in lecture one, that multi shot consensus problem does actually reduce to the single shot Byzantine broadcast problem. So as a consequence of the dull of strong protocol, we will also get state machine replication with all of the properties that we might want and what's really, really remarkable about the dole of strong protocol is that it tolerates an arbitrarily large number of dishonest nodes.
00:10:44.150 - 00:11:07.070, Speaker A: So you could literally have like 100 nodes, 98 of which are trying to confuse the remaining two, the two honest nodes, and they won't be able to do it in this protocol. In the synchronous model, even just these two honest nodes can sort of stay in stink despite the best efforts of these 98 nodes that are trying to mess with them. Now, the bad news about the synchronous model is it's really the assumptions are just too strong about guaranteed message delivery.
00:11:07.070 - 00:11:27.682, Speaker A: They are really not appropriate for protocols that you're going to run on the internet scale, especially not protocols that might be securing billions of dollars and therefore presumably subject to attacks. So you're not likely to see the dole of strong protocol sort of referenced in, say, any blockchain protocol white papers. But it is, first of all, it's a famous protocol.
00:11:27.682 - 00:11:45.870, Speaker A: Second of all, it does show that if you happen to have bounds on message delay, you can kind of do amazing things. And third of all, it'll be a good kind of warm up. We'll get our feet wet with thinking about what a consensus protocol might look like and how much you use things like digital signatures to sort of communicate between different honest nodes.
00:11:45.870 - 00:12:06.526, Speaker A: In lecture three, we're going to see our first impossibility result. So this will actually be another result like the lecture six result, which says that 67% honest nodes is needed. So specifically in lecture three, we'll drill down on one key assumption that the dole of strong protocol makes use of, which is usually called the PKI assumption.
00:12:06.526 - 00:12:28.342, Speaker A: Here, PKI is for public key infrastructure. And so this means you're not only assuming that cryptography exists, right, that anybody has access to a secure digital signature scheme, you're also assuming that prior to the commencement of the protocol, all of the nodes running the protocol have exchanged their public keys. So the protocol sort of wakes up, starts running, and all of the nodes, public keys are common knowledge.
00:12:28.342 - 00:12:55.230, Speaker A: So therefore, if anyone else signs a message, you're in a position to verify that that message really was signed by the sender. So in a blockchain context, the PKI assumption is fairly palatable, but it winds up being really interesting, at least in the synchronous model, to consider what happens without it, without that so called trusted setup. And so that's what this impossibility result in lecture three says, right? So dole of strong using PKI can tolerate any number of dishonest nodes.
00:12:55.230 - 00:13:11.320, Speaker A: If you don't have PKI, we're going to prove in lecture three, you can only tolerate less than a third dishonest nodes. The proof of this result, this impossibility result, is really very slick, very impressive sometimes. It's called the hexagon argument for reasons you'll see.
00:13:11.320 - 00:13:37.300, Speaker A: And so I'd say is for those of you that really like math, and like cool proofs, this might be the number one lecture out of the six you might enjoy. Conversely, if you don't really care about cool proofs then if you were going to skip one of these six lectures I would probably skip lecture number three. Again, it's sort of a famous super interesting result but it's not quite as essential for the rest of this lecture series story as the other five of these six lectures are.
00:13:37.300 - 00:13:56.802, Speaker A: So that's lectures two and three and the main takeaway from the synchronous model is that the good news is you have sort of protocols with amazing guarantees. The bad news is the assumptions are really too strong to model blockchain protocols operating over the internet. So really we're going to have no choice but to try to weaken our assumptions about how the communication network behaves.
00:13:56.802 - 00:14:40.534, Speaker A: That naturally leads us to asking what happens if we assume nothing about the communication network which then is sort of more or less exactly the Asynchronous model. So the good news about the Asynchronous model is that because you're assuming almost nothing about the underlying communication network, any positive result, any consensus protocol you could come up with that actually had any provable guarantees would sort of automatically be super interesting because would have those guarantees even with so little assumptions about how the underlying network works. The problem is going to be the bad news is that we will have thrown out the baby with the bathwater in the sense that there's actually not going to be any good consensus protocols or at least good deterministic consensus protocols in the Asynchronous model.
00:14:40.534 - 00:15:02.502, Speaker A: And so that there is maybe the most famous impossibility result in distributed computing, something known as the FLP impossibility result. And so the proof of this result, this FLP impossibility result, stating that consensus is impossible in the Asynchronous model, that's going to be the hardest proof that we see in any of these six lectures. Probably the hardest proof we're going to see anywhere in the lecture series.
00:15:02.502 - 00:15:13.200, Speaker A: So it's actually going to span both. We'll get started on it in lecture four. There'll be a natural kind of breaking point and then we'll resume in lecture five and finish the complete proof of that very famous result.
00:15:13.200 - 00:15:42.474, Speaker A: So the takeaway from these lectures four and five is thus going to be that the Asynchronous model really you just don't make enough assumptions. I mean you wind up not having any good consensus protocols at all. So apparently we need a third model, maybe slightly less natural, but a third model which is going to sit in between synchronous and asynchronous where the assumptions are weaker than in the synchronous model and therefore more relevant to protocols that operate on internet scale, but on the other hand also have stronger assumptions than in the Asynchronous model.
00:15:42.474 - 00:16:07.906, Speaker A: So that positive results actually exist. So there actually exist protocols, like for example the tendermint protocol that have provable guarantees a final comment just to situate these six lectures in sort of the broader context of the blockchain world. So if you go and look at the different sort of so called layer one protocols that are out there, so blockchain protocols that really take responsibility for consensus themselves as opposed to something that's built on top.
00:16:07.906 - 00:16:32.940, Speaker A: So if you look at the main layer one blockchain protocols, you will notice that most of them, not all of them, but most of them fall into one of two camps. The tendermint protocol is a canonical example of camp number one. And so these protocols really build on sort of the classic consensus protocols that were invented in the 1980s and sort of bring them into the blockchain world.
00:16:32.940 - 00:16:43.630, Speaker A: And you often hear these types of protocols referred to as BFT type consensus protocols. Here. BFT stands for Byzantine fault Tolerance.
00:16:43.630 - 00:17:07.986, Speaker A: And there's a number of examples I mentioned how Tendermint is kind of the type of consensus that's Powering Cosmos and Terra Algorand is another blockchain you might have heard of, which is really sort of BFT style in this sense. Also hot stuff, which is the consensus protocol that Facebook is proposing for their cryptocurrency DM. Also in the spirit of these BFT type protocols.
00:17:07.986 - 00:17:22.554, Speaker A: So there's really a number of interesting protocols that lie in that camp. On the other hand, you probably noticed that I didn't mention the two most famous blockchains of them all, Bitcoin and Ethereum. And indeed they belong to Camp Number Two.
00:17:22.554 - 00:17:39.178, Speaker A: They are not BFT type protocols. They are what are called longest chain protocols. So understanding the protocols in Camp Number Two longest chain protocols like Bitcoin and Ethereum, that's going to be the first order of business after we finish understanding these BFT type protocols.
00:17:39.178 - 00:18:02.520, Speaker A: So we'll get started with longest chain consensus, beginning with lecture eight. So at the conclusion of these six lectures, you will have accomplished two really important things. So number one, you'll have mastered the basic concepts behind one of the two major paradigms for blockchain protocol design to date, these BFT type protocols, which again includes a number of sort of very prominent examples in the blockchain world.
00:18:02.520 - 00:18:54.040, Speaker A: But number two, and maybe even more important, is you will have the mental model and the definitions to be able to understand not only longest chain consensus protocols in an operational sense, like how they work, but you will also be in a position to understand the different sets of tradeoffs that longest chain protocols make compared to BFT type protocols. Like I said earlier, an overarching theme of this lecture series is to emphasize principles over protocols. And so, while we will be learning how various specific protocols like tendermint, bitcoin, ethereum, et cetera work, and we'll learn about examples of these two camps BFT type protocols and longest chain type protocols, what's even more important to remember is sort of the lens through which we can look at these different parts of the design space and assess the different trade offs that they are making.
00:18:54.040 - 00:19:32.978, Speaker A: So for example, you will often see in discussions people talk about how some type of blockchain favors safety and they're referring to BFT type protocols usually when they talk about that, whereas other protocols favor liveness, usually referring to longest chain protocols like Bitcoin and Ethereum. So by mastering the partially synchronous model and the impossibility results therein, you will actually know exactly what people mean when they say that blockchain A favors safety, blockchain B favors liveness. You will also be in a position to really fundamentally understand why different blockchain protocols fail in different ways.
00:19:32.978 - 00:19:42.534, Speaker A: One obvious way a blockchain protocol can fail is it just stops making any progress. Like it just stops doing any work. No sort of further transactions get executed, at least for some period of time.
00:19:42.534 - 00:20:12.286, Speaker A: And that is exactly the way in which protocols in this first camp, BFT type protocols, that's exactly the way in which they fail. So, for example, whenever you hear about like a bug in sort of cosmos, which again is built on tendermint, sort of what winds up happening is that this progress stalls and no new blocks are created. Whereas with longest chain protocols like Bitcoin and Ethereum, if you think about it, you never hear about them stopping like Stalling.
00:20:12.286 - 00:20:24.018, Speaker A: That's not the way in which they apparently fail. Rather, what you hear about are reorganization attacks. You especially see this with sort of kind of less prominent longest chain protocols like, say, Ethereum Classic.
00:20:24.018 - 00:20:43.894, Speaker A: And so here the problem is not that there stops being progress. The progress is that there's sort of like a massive rollback of a bunch of transactions in favor of an entirely different batch of transactions. And the reason you read about BFT type protocols, Stalling, is exactly because they favor safety over liveness.
00:20:43.894 - 00:21:03.442, Speaker A: And the reason you hear about longest chain protocols like, say, Ethereum Classic suffering reorganization attacks is exactly because they favor liveness over safety. So I hope lectures two through seven sound like they're all killer and no filler. I certainly have tried to pack them with super cool results that are well worth your time.
00:21:03.442 - 00:21:08.350, Speaker A: And so I'm very much hoping that I see you next at the beginning of lecture two. Bye.
