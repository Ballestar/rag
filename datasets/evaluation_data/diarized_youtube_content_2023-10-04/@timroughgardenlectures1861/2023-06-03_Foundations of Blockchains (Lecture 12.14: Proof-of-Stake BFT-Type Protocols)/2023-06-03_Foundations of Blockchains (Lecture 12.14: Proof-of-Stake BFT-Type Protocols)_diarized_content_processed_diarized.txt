00:00:00.410 - 00:00:22.394, Speaker A: So this video is the first one belonging to part three of this extremely long lecture twelve on Proof of Stake Blockchain Protocols. Now the last batch of videos, the videos in part two, they covered one critical component of a proof of stake blockchain protocol, which is proof of stake random sampling. So that's a way of doing civil resistant random sampling of one of the nodes running the protocol.
00:00:22.394 - 00:00:42.282, Speaker A: Specifically, there's a smart contract with a list of active validators with the corresponding stake amounts. And we talked through a number of approaches to sampling one of those active validators with probability proportional to the amount of locked up stake. As we saw that seemingly simple problem, right, literally just random sampling from a distribution that the protocol is well aware of.
00:00:42.282 - 00:01:06.466, Speaker A: That seemingly simple problem actually winds up being surprisingly tricky. But having graduated through all those part two videos, we're now sort of familiar with the state of the art of how to go about doing that. Now, here in part three, the focus is going to be sort of building on part two, taking proof of stake, random sampling and coupling it pairing it with one of the consensus protocols that we know and love like.
00:01:06.466 - 00:01:42.880, Speaker A: The BFT type consensus protocols we talked about in lectures one through seven or longest chain consensus, which we talked about in lectures eight and nine. Now in a perfect world, everything would be totally modular and we could literally just paste together solutions to these two problems, right? It'd be great if we could just sort of take our favorite permissioned consensus protocol and then take our favorite method for doing proof of stake random sampling to kind of turn that permissioned protocol into a permissionless protocol through civil resistant random sampling. Now, from a high enough altitude, say 30,000ft, that is actually going to be more or less what we're doing.
00:01:42.880 - 00:02:03.570, Speaker A: But even from somewhat lower altitudes like call it 10,000ft, there's going to be some obvious problems, obvious sort of issues that need to be addressed. And so these part three videos, their goal is exactly to talk through. What are these challenges that come up when you try to paste these two things together and what are the best practices for addressing those challenges?
00:02:04.070 - 00:02:05.346, Speaker B: So the bad news I have for.
00:02:05.368 - 00:02:13.302, Speaker A: You is these videos are going to be not so easy. They're really going to sort of require your focus. We saw permission consensus is already a hard problem.
00:02:13.302 - 00:02:20.166, Speaker A: Okay, we've solved it, but it's already a hard problem. Proof of stake random sampling, that's a hard problem. We've more or less solved it, but it's a hard problem.
00:02:20.166 - 00:02:36.590, Speaker A: And then there's still further hard problems that come up when you try to put these two things together. So these videos here in part three where you really sort of sketch what modern proof of stake blockchain protocols look like, they're going to be a very sophisticated blend of a number of sort of clever computer science ideas.
00:02:37.410 - 00:02:38.638, Speaker B: The good news, which is sort of.
00:02:38.644 - 00:03:07.846, Speaker A: The flip side of the bad news, is that because this is sort of such sophisticated, cutting edge computer science, the set of people who really understand this stuff is really quite small. So if you get through these videos and really understand sort of the main points of them, you will understand the challenges of proof of stake blockchain design better than most people on the planet. So all that said, let's now regard proof of stake random sampling as basically a solved problem using the techniques from part two and think about various consensus protocols we could pair it with.
00:03:07.846 - 00:03:22.490, Speaker A: And it's going to turn out that the challenges that come up and sort of the best practices depend a little bit on whether you're trying to couple it with a BFT type consensus protocol or with the longest chain consensus protocol. So we're going to talk about those separately and we're going to start by talking about BFT type protocols.
00:03:22.830 - 00:03:24.526, Speaker B: There's several reasons to do that to.
00:03:24.548 - 00:03:37.326, Speaker A: Sort of start with BFT type. Number one is it's at least slightly simpler as you'll see a lot of issues come up already with BFT type consensus protocols. But somehow there's like even more when you're worrying about longest chain consensus protocols.
00:03:37.326 - 00:04:11.014, Speaker A: So natural to start with BFT type for that reason. A second reason is that as we've discussed, while earlier vintages of proof of stake blockchain protocols often did take the longest chain approach, increasingly as the years go on, more and more we see proof of stake protocols relying on something other than longest chain consensus, most commonly BFT type consensus. A final reason is that this is really something special about proof of stake random sampling compared to, say, proof of work random sampling, which as we saw in lecture nine, you cannot really productively pair with BFT type consensus.
00:04:11.014 - 00:04:40.306, Speaker A: So only with this migration to proof of stake civil resistance are we able to take advantage of all of the great BFT type consensus protocols that have been developed over the last several decades. As we discussed in that video on Why proof of stake back from part one, that potentially unlocks a number of advantages in terms of performance and also in terms of finality guarantees. So given that sort of proof of stake one of its superpowers is unlocking BFD tech consensus, that's also a natural.
00:04:40.338 - 00:04:44.326, Speaker B: Thing to focus on here in part three. So the plan for these first three.
00:04:44.348 - 00:05:02.326, Speaker A: Videos of part three is to walk you through a sketch of one natural way you might try to pair proof of stake random sampling with BFD type consensus. A couple of caveats before we get started. So first, as we've said many times, different proof of stake blockchain protocols differ in a million little design decisions.
00:05:02.326 - 00:05:15.962, Speaker A: And that's true even amongst the subclass of proof of stake BFT type protocols. So the description I'm going to give you here is not going to map literally onto any specific project. Again, the focus of this lecture series is on principles, not on specific projects.
00:05:15.962 - 00:05:36.502, Speaker A: I would say if you wanted a nearest neighbor to what I'm going to talk about, so it probably most closely resembles the Algorand protocol. The second caveat is the description is going to be somewhat incomplete. So if you wanted sort of a full blown blockchain protocol with provable consistency and liveness, you would need additional details beyond what I'm going to describe here.
00:05:36.502 - 00:06:00.110, Speaker A: So my goal here is really kind of first of all, to at least give you accurate sort of understanding of conceptually how proof of stake BFT type protocols tend to work. And secondly, I want to give you sort of enough detail that the challenges that I view as the most important ones that come up in proof of stake BFT type protocol design, that those challenges sort of become obvious and we're in a position to discuss them in some depth.
00:06:00.530 - 00:06:02.426, Speaker B: So like in our discussions of permission.
00:06:02.458 - 00:06:19.560, Speaker A: Consensus back in lectures two through seven, we're going to assume that there's a shared global clock. So this protocol is going to proceed in rounds. Rounds will correspond to time intervals and we're going to be assuming that all of the nodes can, without any communication, know exactly which round they're in, know exactly sort of what the current time is.
00:06:19.560 - 00:06:31.238, Speaker A: Most proof of stake blockchain protocols do make some assumption of this form. Maybe they allow a little bit of clock drift between different nodes, but basically they assume that all nodes know what time it is and what round they're in.
00:06:31.404 - 00:06:32.758, Speaker B: So as was the case in all.
00:06:32.764 - 00:06:44.498, Speaker A: Of our part two discussion, we're assuming there's going to be some staking contract that's sort of maintained by the blockchain protocol, which has a list of all of the currently active validators, along with the amount of stake they have locked.
00:06:44.534 - 00:06:46.622, Speaker B: Up and throughout this video.
00:06:46.676 - 00:06:55.742, Speaker A: And the next one we're going to make what seems like a totally unreasonable assumption, which is we're going to assume that all of the stake amounts are exactly the same. So for concreteness, let's say that everybody.
00:06:55.876 - 00:06:57.718, Speaker B: Stakes a single coin.
00:06:57.914 - 00:07:22.762, Speaker A: Now don't worry, we will be removing this assumption, not in this video, not in the next video, but in the video after that. The third video of part three is going to be all about how do you extend these ideas to the case of General QIS, believe it or not, and we'll see this really in the next video in detail. There's a lot of issues that come up with stitching together proof of stake random sampling with BFT type consensus, even in the special case where all of the stake amounts are the same.
00:07:22.762 - 00:07:33.230, Speaker A: So let's worry about those first. And once we sort of are clear on how we want to solve those issues, then we'll talk about how to extend these ideas to the case of general QIS.
00:07:33.810 - 00:07:35.374, Speaker B: Now, what we'd like to do is.
00:07:35.412 - 00:07:54.222, Speaker A: Just stand on the shoulders of a permissioned BFT type protocol like, say, tendermint that we discussed in detail in lecture seven. Now, when we talked about tendermint, we were working in the permissions plus PKI setting. But here we do have this list of active validators along with their public keys in the Staking contract.
00:07:54.222 - 00:08:06.550, Speaker A: So we can kind of pretend like we're in the permission setting even though there might be sybils. We can sort of treat the public keys in the Staking contract as the end nodes that we're then going to have run tendermint.
00:08:06.970 - 00:08:08.646, Speaker B: To make that idea work, we need.
00:08:08.668 - 00:08:25.410, Speaker A: To somehow assign roles to the various public keys in the Staking contract, roles that the owners of those keys are supposed to play in the tendermint protocol. So in particular, we're going to need to designate one of those public keys as the leader of a round. So remember, in tendermint, you have these rounds.
00:08:25.410 - 00:08:34.800, Speaker A: Each round has like four stages and each round has a leader node. And in the first stage of a round, the leader node is supposed to, if they're honest, propose a block and send that to everybody else.
00:08:35.330 - 00:08:37.034, Speaker B: So to run a round of tendermint.
00:08:37.082 - 00:08:49.938, Speaker A: We need to somehow choose a leader. And so here the obvious thing to do is to use our part two solutions and use proof of stake random sampling to choose one of these PKIs with probability proportional to the stake who's going to be the block proposer for the next round.
00:08:50.114 - 00:08:51.958, Speaker B: So that's the first reason that we're.
00:08:51.964 - 00:09:08.374, Speaker A: Going to want to use a proof of stake random sampling procedure. It's going to designate which of the public keys acts as the leader, acts as the block proposer when we run one round of a BFT type consensus protocol like the tendermint protocol. Now, there's a second role in tendermint that you need to designate, which is the voters.
00:09:08.374 - 00:09:22.826, Speaker A: So we have to decide which of the public keys are allowed to contribute a vote on blocks when we run a round of the tendermint protocol. Your first thought might be like, well, why not just let them all vote? Right? That's what we did back in lecture seven. We had these N nodes.
00:09:22.826 - 00:09:30.882, Speaker A: Everybody got a vote here. We have these N public keys. Why not give everybody a vote? As we'll see with general stake amounts, you want to weight those votes by the stake amount.
00:09:30.882 - 00:09:56.486, Speaker A: But whatever, why not just let all N owners of the public keys cast votes? So that would be a totally reasonable approach. If you don't have too many active validators, like if N equals 100 or something like that, by all means, just let everybody vote in a BFT type protocol like, say, tendermint. But if you have a lot of active validators, like if N is 10,000 or something like that, that's a little bit much for BFT type consensus protocols to handle.
00:09:56.486 - 00:10:08.346, Speaker A: So if the list of active validators is really big, you have to somehow select a subset of them, a committee if you will, who will be the ones that then vote in an invocation of tendermint.
00:10:08.538 - 00:10:10.286, Speaker B: And you definitely can't just ignore this.
00:10:10.308 - 00:10:31.254, Speaker A: Case of like n equals 10,000 or even bigger, right? There's a couple of reasons why that could happen. The really happy reason would be that just like your blockchain protocol takes off, the native currency is sort of widely adopted and gets sort of very well distributed and you literally have like 10,000 different people that actually really want to contribute to being active validators to your protocol. Obviously you'd like to accommodate that.
00:10:31.254 - 00:10:35.030, Speaker A: Your protocol shouldn't break down just because it gets particularly popular.
00:10:35.610 - 00:10:37.238, Speaker B: The last happy reason, but one you.
00:10:37.244 - 00:11:05.854, Speaker A: Also really have to worry about is, again, civils, right? So maybe there's really actually only 17 different entities that are participating in active validation, but maybe one or more of them are sort of masquerading under lots of different public keys. So that can also kind of artificially, but sort of also undetectably sort of blow up the list of active validators to being quite long to being as large as say, 10,000. So any proof of stake BFT type protocol has to deal with this issue in some form.
00:11:05.854 - 00:11:32.398, Speaker A: Like if you have 10,000 people that want to contribute votes, how do you pick, say, 100 of them that actually can contribute votes? The earliest generations of such protocols usually did pretty simple things like maybe you just sort of declare that the 100 public keys were the largest stake amounts. Maybe you define them to be the ones that are allowed to vote in your BFT type consensus protocol. Here we're going to look at a kind of more modern, more sophisticated approach which instead uses random sampling.
00:11:32.398 - 00:11:42.890, Speaker A: I mean, we're already using random sampling to pick the block proposer, so why not use random sampling also to pick the committee to pick which of the public keys get voting rights when we run the tendermint protocol.
00:11:43.470 - 00:11:44.490, Speaker B: So that's the plan.
00:11:44.560 - 00:12:01.986, Speaker A: And so next we're going to stand on the shoulders of the work we did in part two, our approach to doing proof of stake random sampling. We're going to use the VRF based approach. Remember, VRF stands for verifiable random function and we're going to be evaluating VRFs on a pseudorandum seed derived from the.
00:12:02.008 - 00:12:05.026, Speaker B: Blockchain state in a little more detail.
00:12:05.128 - 00:12:28.970, Speaker A: In each time step for each public key. The owner of that public key in the Staking contract is supposed to be evaluating a VRF using the corresponding private key SK sub i, corresponding to PK sub i. And it's supposed to be evaluating the VRF using that private key on an input which is the concatenation of the round number t with the pseudorandom seed r sub t for that round.
00:12:29.390 - 00:12:30.986, Speaker B: So this should be familiar from those.
00:12:31.008 - 00:12:39.230, Speaker A: Two videos on verifiable random functions that we had in part two. It may be just sort of a brief reminder sort of VRF. It's defined by basically four properties.
00:12:39.230 - 00:13:07.590, Speaker A: So first of all, if you have the right private key you can efficiently compute its output the way that if you have the right private key you can efficiently compute, say, a signature in a digital signature scheme. Secondly, if you don't have the private key and nobody tells you the output of the VRF, then you cannot for all practical purposes figure out what the output is. It's sort of secret to you the same way that if you don't know the private key of a signature scheme you cannot forge signatures for all practical purposes.
00:13:07.590 - 00:13:32.910, Speaker A: And then we have third efficient verifiability. So if someone knows the corresponding public key and is told the alleged VRF output, then they can efficiently verify, efficiently check that in fact the VRF was computed correctly. So you can do that using only the public key and the output of the VRF, much like in a digital signature scheme how you can verify the validity of a signature knowing only the public key.
00:13:32.910 - 00:13:55.830, Speaker A: And then finally the output of the VRF is supposed to be indistinguishable from random. And as we discussed, the simplest way to construct what's something that seems to be a VRF would be to use a digital signature scheme that has unique signatures like we talked about the BLS scheme and then optionally pass the signature through a cryptographic hash function for which you're comfortable making the random oracle assumption.
00:13:56.250 - 00:13:56.646, Speaker B: All right?
00:13:56.668 - 00:14:11.930, Speaker A: So that's to jog your memory what a VRF is. Notice the output of the VRF depends on the private key that you're using. So even though all of the different active validators are evaluating a VRF on exactly the same input, they're going to get different results because they're all using different private keys.
00:14:11.930 - 00:14:50.886, Speaker A: Moving on to the input of that VRF, obviously you should be wondering, well, what is R sub t exactly? And here we're really going to be just sort of using the same ideas we discussed in that video on pseudorandomness beacons. As we discussed back in that video, you have to be very careful about which parts of a blockchain state you use to define a pseudorandum seed r sub t because you want to minimize the manipulation opportunities for block producers. For example, a really bad idea is to have the pseudorandum seed r sub t of a time step depend nontrivially on the transactions in the block produced at the previous time step.
00:14:50.886 - 00:15:03.546, Speaker A: Because then, whoever it is who's proposing a block at the previous time. Step basically gets to pick from among a zillion different options for what r sub t is going to be. So you need r sub t to depend somehow on the current blockchain state.
00:15:03.546 - 00:15:07.040, Speaker A: But you want to be in a very, very limited way.
00:15:07.650 - 00:15:08.878, Speaker B: And we're going to use one of.
00:15:08.884 - 00:15:20.290, Speaker A: The ideas that came up in that previous video, which is we're going to define RSPT as the VRS output I e the credential of whoever proposed the most recent finalized block.
00:15:20.790 - 00:15:22.194, Speaker B: The hope then of course is that.
00:15:22.232 - 00:15:44.778, Speaker A: R sub T, what with being the output of a verifiable random function from some time back, hopefully that's sort of as good as random. Now, if you remember the pseudorandumness beacon video, you'll remember it's actually not quite right. Definitely this is much, much less manipulable than some seed that depends on the transactions in a recent block, but there's still some degree of manipulation possible.
00:15:44.778 - 00:16:03.182, Speaker A: So that'll be one of the issues that we take up in the next video. So in addition to the pseudorandum seed R sub T I've thrown in there as part of the VRF input the current time step little t that's just so that even if for whatever reason, the blockchain state doesn't change, at all in the Timestep. And so R sub t remains the same.
00:16:03.182 - 00:16:08.420, Speaker A: Then, because t gets incremented, you will get a new fresh set of VRF outputs for everybody.
00:16:09.190 - 00:16:10.690, Speaker B: All right, so that's all pretty much.
00:16:10.760 - 00:16:30.490, Speaker A: Taken directly from those two videos on VRF based sampling from part two. And now that we've done that, we're in a position to assign roles to the public keys to play in the tendermint protocol. So both a committee of public keys that have the privilege of voting, then also a single public key that has the privilege of proposing a block.
00:16:30.990 - 00:16:32.426, Speaker B: So first of all, the committee is.
00:16:32.448 - 00:16:49.914, Speaker A: Just going to be defined as all of the public keys with a sufficiently small VRF output. So what do I mean by sufficiently small? Well, that's going to be controlled by some kind of difficulty threshold. Tau sub c here refers to the desired size of a committee.
00:16:49.914 - 00:17:21.146, Speaker A: So maybe C equals 100. Say if you're hoping to have 100 different validators contribute votes in the tendermint protocol. So this parameter, tau sub c, it's going to be a function obviously of the committee size C that you're looking for, but also of the number N of active validators in your Staking contract, right? So like if n equals 10,000 and C equals 100, so you want to choose 100 voters out of 10,000 possibilities, 10,000 active validators in the Staking contract, you would choose tau sub c so that a typical VRF output would have a 1% chance of falling below it.
00:17:21.146 - 00:17:44.746, Speaker A: That would give you an expected committee size of 100. So this definition of a committee makes sense when you're kind of not worrying about civil resistance and you're just assuming that all of the stake amounts are exactly the same, then you want to have a uniform threshold for all of the different registered public keys in general to get civil resistance. It needs to be the case that the bigger your stake, the bigger the likelihood that you get chosen as part of the committee.
00:17:44.746 - 00:17:58.486, Speaker A: So we'll talk about this again in the third video. But when we extend this idea to arbitrary Q, sub I's, you should expect this tau sub C to be multiplied by something that's increasing in the stake amount. So the bigger your stake is, the more likely it is that you're going.
00:17:58.508 - 00:18:00.230, Speaker B: To be passing this threshold.
00:18:01.050 - 00:18:17.126, Speaker A: Now, Committee membership is defined via a private computation, right? So that's what this VRF based approach gives you. It gives you the secrecy property that nobody actually knows that you're on the Committee until you tell them. So when you're running tendermint, when you vote, you need to tell people at the same time that you're on the committee.
00:18:17.126 - 00:18:35.786, Speaker A: They don't automatically know that in advance because they don't know your VRF output, because they don't know your private key. So when you vote, not only will you sign it using your public key, but you'll also include your Credential, which other participants can then verify. And if your Credential is bigger than this threshold, people will ignore your vote.
00:18:35.786 - 00:19:22.030, Speaker A: If it's lower than this threshold, they will count your vote. That hopefully seems natural enough, defining the Committee to just be consisting of the public keys that have relatively small VRF outputs. And given that, why don't I just define the leader? So the public key that has the privilege of proposing a block, why don't I just define that to be the one with the smallest VRF output of all, the one with the minimum Credential? Now, interestingly, if you're the owner of a public key and you compute your VRF output, you know at that point whether or not you're in the committee, right? That's just whether or not your VRF output is less than some sort of known constant tau sub C, you actually don't know at that point whether you are the round's leader or not, right? Because you don't know if there's some other public key that has an even smaller VRF output than yours.
00:19:22.030 - 00:19:40.840, Speaker A: Now, if you somehow magically knew that you were the leader, that you had the smallest Credential, well, it's clear what you'd do, right? You'd make your block proposal. You would include your credential. It would be the smallest Credential that anybody ever sees in that round, and everybody would sort of agree that your block proposal is the one that they should be paying attention to.
00:19:41.370 - 00:19:43.126, Speaker B: Now, in reality, of course, when you.
00:19:43.148 - 00:20:07.850, Speaker A: Evaluate your VRF, maybe you can estimate the likelihood with which you're going to be the leader of that round, but you're just not going to know for sure because it's going to depend on everybody else's VRF outputs, which you don't know. As we'll discuss in the next video, where we take up this and a couple other issues, we're basically going to wind up modifying tendermint pretty minor ways. And nodes may wind up making block proposals even when they're not the leader.
00:20:07.850 - 00:20:12.400, Speaker A: In effect, the protocol is going to identify the leader after the fact.
00:20:13.170 - 00:20:14.914, Speaker B: So intuitively then, at this point, we.
00:20:14.952 - 00:20:44.118, Speaker A: Literally just run tendermint with the node set corresponding to the committee, the public keys with sufficiently small VRF outputs and with this choice of leader, with the block proposer being the public key with a minimum credential. So if you think about it, the real story must be a little bit more complicated than that. Presumably this committee is not just going to be running tendermint forever, right? When we talked about tendermint back in lecture number seven, we were thinking about a fixed set of nodes, fixed once and for all at the beginning of the protocol.
00:20:44.118 - 00:21:08.930, Speaker A: And then you could just say those nodes run the protocol forever. Here the committee is supposed to be a representative group from the active validators, so from the public keys that are in the Staking contract. And remember, we're trying to design a permissionless consensus protocol here, which means that people should be able to enter and exit the Staking contract when they want modulo, a sort of warm up period and a cooldown period.
00:21:08.930 - 00:21:19.320, Speaker A: So if the list of active validators is changing over time, as it should in a permissionless protocol, well, presumably the committee itself will also then need to change over time.
00:21:19.850 - 00:21:22.066, Speaker B: So the committee won't be running tendermint.
00:21:22.098 - 00:21:53.274, Speaker A: Forever, it'll run tendermint for some period of time, after which you're going to refresh the committee in some way. A design decision that then just sort of naturally comes up is kind of how long is a committee supposed to run tendermint for? Or equivalently, how frequently do you want to update the committee? And like so many other things, different proof of stake blockchain protocols take very different approaches here, some only refresh the committee on the order of days. For concreteness, let me write here something that other protocols do, which is to refresh it quite frequently.
00:21:53.274 - 00:22:34.046, Speaker A: So let's say for concreteness, the committee is going to run one round of the tenderman protocol and when the round ends, at that point, the committee is going to get refreshed, in this case, resampled. The hope, of course, is that in one round of tendermint, this committee and leader successfully finalize some new block that may, of course may or may not be true, depending on whether the leader is Byzantine and depending on what's going on with message delays. So do you remember toward the beginning of this video when I said that this example implementation is going to be under specified and that there's more details needed to get provable guarantees like consistency and liveness well? This is kind of one of the main things that I had in mind.
00:22:34.046 - 00:22:41.390, Speaker A: I'm definitely omitting quite a bit of details when I say the committee and the leader run one round of tendermint with the committee then being refreshed.
00:22:41.970 - 00:22:43.486, Speaker B: So a few more details that those.
00:22:43.508 - 00:22:49.214, Speaker A: Of you that remember, at least at a high level, how tendermint works. Remember, tendermint has rounds. Each round has four stages.
00:22:49.214 - 00:23:11.322, Speaker A: Stage one, the leader of the round is supposed to propose a block, then you have these two stages of voting. People are trying to assemble quorum certificates of a supermajority of the votes and so on. And in the happy case where you both kind of are in the synchronous model or you're after global stabilization time in the partially synchronous model and all message delays are delta time units or less.
00:23:11.322 - 00:23:33.710, Speaker A: And moreover, you happen to have an honest node acting as the leader of the round, then here everything just goes like clockwork, everything goes really smoothly. The honest leader proposes the same block to everybody else, those messages arrive on time, everybody votes, the votes arrive on time, everybody assembles the right quorum certificates, everybody finalizes the block that the leader proposed in that first stage.
00:23:34.450 - 00:23:35.922, Speaker B: Now, if you remember a little bit.
00:23:35.976 - 00:23:55.570, Speaker A: About the honestly quite tricky analysis that we did at the tenderman protocol back in lecture seven, you'll remember that rounds don't always run so smoothly. And it's totally possible that at the conclusion of a round, different honest nodes know different things and find themselves in different states. Different honest nodes may know about different quorum certificates.
00:23:55.570 - 00:24:12.678, Speaker A: For example, at the end of a round, different honest, some honest nodes may have finalized a block by the end of a round, while other honest nodes may not have. One reason that might happen is if you were unlucky and got a Byzantine block proposer who then sent conflicting blocks to different honest nodes. Sowing confusion.
00:24:12.678 - 00:24:45.000, Speaker A: A second reason is if you're in the partially synchronous model and you're preglobal stabilization time, so messages can be delayed by an arbitrarily long amount, some nodes just won't have heard about, for example, certain quorum certificates that other nodes do know about. Now, in the tendermint protocol, one of the reasons that it's able to achieve provable consistency and liveness even in the partially synchronous model is that the nodes running the protocol, they don't just kind of reset every single round. If the last round concluded in an unsatisfactory way, they kind of remember where they left off.
00:24:45.000 - 00:25:19.890, Speaker A: So for example, if honest node running the tenement protocol hears about a stage one quorum certificate, say, so, this would be a supermajority of the nodes all agreeing on a common block in the first stage of voting in a round. So if a node hears about a stage one quorum certificate, even if it doesn't finalize any block that round, it's not going to forget about that stage one quorum certificate, it's going to remember it and it's only going to discard it when it has sort of information that it's out of date. Only when confronted with a more recent quorum certificate will discard that stage one quorum certificate that it heard in that round.
00:25:19.890 - 00:25:37.542, Speaker A: And this, if you remember, was actually crucial for arguing the consistency of the tendermint protocol. So briefly, the way that consistency proof worked is you have to show that you'll never finalize. Sort of two different blocks of the same block height, like block height number nine.
00:25:37.542 - 00:25:54.970, Speaker A: So how do you argue that? Well, suppose some honest node finalizes one block at block height number nine. We need to argue that no other honest node ever finalizes any other block at height nine. So by virtue of finalizing this height nine block, it must have been that the honest node had assembled a stage two quorum certificate.
00:25:54.970 - 00:26:14.398, Speaker A: So it heard a supermajority of votes, all supporting this block in the second stage of voting. Now, maybe one third times n of those could have been votes by Byzantine nodes. But the rest, which is more than sort of n over three, where n is the number of nodes, the rest of those votes must have been from honest nodes.
00:26:14.398 - 00:26:33.770, Speaker A: And those honest nodes only would have cast those votes had they known about a stage one quorum certificate at that time. In other words, at the end of this round, where some height nine block gets finalized, it must be the case that more than n over three honest nodes are locked in on that block.
00:26:34.270 - 00:26:35.786, Speaker B: So with those more than n over.
00:26:35.808 - 00:26:51.370, Speaker A: Three honest nodes locked in on that block, that will prevent any other block from ever being finalized at that height. It'll even prevent any other quorum certificate ever being produced for blocks at that height. Right? Any new quorum certificate will require more than two thirds of the votes.
00:26:51.370 - 00:27:06.130, Speaker A: But these locked in honest nodes are not going to be the ones that are providing those votes. They're not going to start voting for something else until they've already seen a supermajority. So there'll never be another quorum certificate for any other block at that height, so no other block will ever be finalized at that height.
00:27:06.130 - 00:27:27.674, Speaker A: And I'm reviewing this proof for you here because I wanted to be obvious that the consistency of the tenderman protocol really relies on some amount of memory from round to round. For example, honest nodes remembering about stage one quorum certificates that they heard about. And that's why it should be clear that this kind of naive idea I wrote at the bottom of this slide is not going to be good enough.
00:27:27.674 - 00:27:46.986, Speaker A: You can't simply refresh the committee completely and sort of wipe the memory clean with every new round of the tendermint protocol. You need to somehow make sure that each committee knows enough about what happened in the past that it can basically simulate what the static set of nodes would be doing in the tendermint protocol. So those are the additional details which I'm going to omit.
00:27:46.986 - 00:27:53.422, Speaker A: That would just be too far out into the weeds for us. We're already quite far out into the weeds. I don't think we need to go any farther.
00:27:53.422 - 00:28:03.800, Speaker A: But if you're interested, I would check out the white papers of various proof of stake BFT type blockchain protocols to see how they do it. And again, Algorand being a natural one to start with.
00:28:04.330 - 00:28:06.006, Speaker B: So that concludes this kind of high.
00:28:06.028 - 00:28:22.650, Speaker A: Level, not totally complete description of how you would pair proof of stake random sampling. Specifically, the VRF based approach based on pseudorandom seeds derived from the blockchain state pair proof of stake random sampling with BFT type consensus. Specifically, here we're talking about the tenement protocol.
00:28:23.150 - 00:28:24.478, Speaker B: So in the next video, I want.
00:28:24.484 - 00:28:41.390, Speaker A: To address a few issues that come up with this attempt to stitch these two things together. So first of all, because we're using VRF based sampling, that effectively means you have a variable number of winners of the lottery. So I want to talk about how the consensus protocol kind of accommodates a variable number of winners.
00:28:41.390 - 00:29:01.394, Speaker A: Secondly, because we're using a pseudorandum seed derived from the blockchain state, it is to some extent not a lot, but to some extent manipulable. So I want to discuss that issue as well. And then third, because we're sampling these committees, we're going to have to somewhat revisit our assumption about how much of the stake is controlled by honest nodes.
00:29:01.394 - 00:29:15.694, Speaker A: So those are the three issues we're going to talk about in the next video and then the video after that. The final one about proof of stake BFT type protocols. We'll talk about general UIs, general stake amounts and the modifications that are needed to this description to accommodate them.
00:29:15.694 - 00:29:17.740, Speaker A: So that's where we're going next. I'll see you there.
