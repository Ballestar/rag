00:00:00.250 - 00:00:15.066, Speaker A: Okay? So in this last video as part of lecture two, I want to prove the properties that we claimed about this famous dole of strong protocol. Specifically that it satisfies both validity and agreements under our working assumptions. Okay? So namely it's a permission setting.
00:00:15.066 - 00:00:25.874, Speaker A: There's a known set of nodes. Everybody knows all of their identities. The PKI or public key infrastructure assumption that in addition to knowing the nodes, you know public keys for all the nodes, the synchronous assumption.
00:00:25.874 - 00:00:46.026, Speaker A: So every message sent in this time step arrives at the beginning of the next time step. And then there's some known bound little f on how many of the nodes are Byzantine. So under those assumptions, the Dolorestrong protocol actually satisfies both validity and agreement and in that sense is a solution to the Byzantine broadcast problem.
00:00:46.026 - 00:01:08.590, Speaker A: Let's start by proving validity. Now remember, validity asks nothing of us in the event that the sender is Byzantine, it only says if it just so happens that the sender is honest, then you want their private input to be accurately communicated to all of the honest non senders. So that's what we need to worry about proving.
00:01:08.590 - 00:01:43.102, Speaker A: We're going to assume an honest sender with a private input V star because it's honest, it's going to follow the protocol and in time step zero, it's going to send messages to everybody else with its private input V star along with its signature. Now, because we're assuming we're in the synchronous model, all of these messages sent out by the honest sender will be received by the recipients by the beginning of time step one. And I claim that that means that actually all of the honest non senders will be convinced of this value V star already at timestep one.
00:01:43.102 - 00:02:14.614, Speaker A: To see that, let me just sort of remind you what is the definition of being convinced? So for a node to be convinced of a particular value in the dole of strong protocol, at some time t it has to receive a message referring to that value signed both by the sender, first by the sender. And also by T minus one other nodes, all of which are distinct from each other, distinct from the sender, and distinct from the recipient of this message of node I. Now at timestep T equal one, this becomes much simpler, right? T minus one equals zero.
00:02:14.614 - 00:02:35.162, Speaker A: So you're going to be convinced of something at timestep one if it's a message signed by the sender with some value. And those are exactly the messages that this honest sender is sending out that everybody receives at time one. So all of the honest non senders, they're going to receive this message directly from the sender signed version with Vstar and it just meets this definition.
00:02:35.162 - 00:03:12.534, Speaker A: Okay? So all of those nodes will be convinced of Vstar already at timestep one, right? And that makes sort of total sense for the intuition of what's a convincing message it's supposed to be. Proof that indeed the sender sent some node a particular value at timestep zero, right? So this is the special case where I'm quite sure that the sender sent somebody a message with value V star because in particular the sender directly sent one to me. So are we done? Kind of seems like it, right? I mean the whole point of validity is an honest sender is supposed to be able to accurately communicate its private value to all the other nodes.
00:03:12.534 - 00:03:33.242, Speaker A: We just have seen that already at timestep one, all of the nodes get convinced of the value V star already by time step one. So anything else we need to show? Actually there is something now that we think about it. Like remember how the final output of a node is computed? So if a node is convinced of exactly one value, they output that value otherwise.
00:03:33.242 - 00:03:46.094, Speaker A: For example, if a node is convinced of two or more values, it outputs perhaps neither of them, but rather a canonical default value bottom. For example, the empty list of transactions. So we are not done in this proof.
00:03:46.094 - 00:04:04.410, Speaker A: It's true that everybody gets convinced of Vstar by time step one. But the concern is that maybe later on some, but not all of the nodes get convinced of a second value. And that would be a disaster because the nodes that do not get convinced of a second value, they would output V star.
00:04:04.410 - 00:04:23.358, Speaker A: The ones that do get convinced of another value are going to output bottom, which in general is not the same thing as V star. So that would be a violation actually of both validity and agreement. So it's not enough to just say that everybody gets convinced of Vstar, we have to also say they never get convinced of any other value.
00:04:23.358 - 00:04:38.680, Speaker A: So let's see why that's true. Here we're going to rely on our ideal signatures assumption that messages are unforgivable. Meaning if you don't know someone's secret key, you can't figure out what their signature is supposed to be on some message that you haven't already seen them sign in the past.
00:04:38.680 - 00:04:57.430, Speaker A: So in particular, no one who doesn't know the private key of the sender can forge messages from the sender. Now let's remember what it takes for a message to be convincing. The second condition for a convincing message that it must be signed first and foremost by the sender.
00:04:57.430 - 00:05:07.518, Speaker A: Okay, now we're proving validity. We're thinking about the case of an honest sender. So this honest sender, it sends out messages signed with the value V star because it's honest.
00:05:07.518 - 00:05:20.158, Speaker A: It never sends out messages with any other value. All of the messages that the sender itself creates are signed versions of Vstar. Furthermore, no one else can forge a message from the sender.
00:05:20.158 - 00:05:37.766, Speaker A: So that means the only messages in circulation at all for the entire protocol are ones signed by the sender, all of which reference the same value V star. So it's impossible to ever get convinced of any message with any other value because you can't. Because one, because the sender never sent a message with that value.
00:05:37.766 - 00:05:51.494, Speaker A: And number two, no one else can forge a message from the sender with that value. And now we're done, right? All of the honest nodes ever only ever get convinced of this one value v star. And as per the protocol description, that means they output v star.
00:05:51.494 - 00:05:56.880, Speaker A: That was the private input of the honest sender. So that's exactly validity for you. Proof is complete.
00:05:56.880 - 00:06:05.570, Speaker A: Let's now move on to agreement. The argument here is a little bit trickier. Not a lot trickier, but a little bit trickier.
00:06:05.570 - 00:06:25.398, Speaker A: Now, in proving validity, we've already established agreement in the case where the sender happens to be honest. I mean in particular the nodes agree on the private input of that honest sender. So really all we have left to prove is the presumably harder case of a Byzantine sender.
00:06:25.398 - 00:07:09.750, Speaker A: The way we're going to prove that all of the honest nodes have the same output is by proving that they all have exactly the same information, are convinced of exactly the same set of values at the protocol's termination. So one way of saying that is that if any honest node I ever at any point in the protocol gets convinced of some value v, then by the end of the protocol, by the end of time step F plus one, it should be the case that all honest nodes are convinced of that value v. So why is this sufficient? Well, it's because the final output of a node is a function only of the values it's convinced of by the end of the protocol, right? So either you're convinced of one value, in which case that's the value you output, or otherwise you output the canonical default value bottom.
00:07:09.750 - 00:07:20.618, Speaker A: So in any case, nodes that are convinced of exactly the same values are going to be outputting exactly the same thing. All right? So now we need to argue two different cases. The first case is the easier one.
00:07:20.618 - 00:07:37.470, Speaker A: And this is when as a node you find out you become convinced of a value early enough that you still have time to notify all of your colleagues. So because time hasn't expired, you're not at the last time step. And because we're in the synchronous model, you know, your messages you send now will get delivered by the next time step.
00:07:37.470 - 00:07:54.390, Speaker A: There's ample time to just sort of let everyone else know. So in particular you're going to take the message that convinced you, message M, and then you're going to sign it. So you'll add your signature as node I and then you will send that out to all of the other nodes, right? That's what honest nodes are supposed to do in the dole of strong protocol.
00:07:54.390 - 00:08:17.454, Speaker A: Now notice if you remember the definition of a convincing message, when an honest node gets convinced of some value, it can convince all the other honest nodes by the next time step. Okay? So specifically, if you get convinced of something at time T by a message that according to this definition has T signatures on it, you can then sort of echo that message, add your signature. Now, it's not going to arrive at the other nodes until time T plus one.
00:08:17.454 - 00:08:34.638, Speaker A: Which does mean if you look at this definition, if you look at that final condition, that's going to be one more signature that better be there for it to be convincing to other nodes. But of course, you added your signature and that's going to be the T plus one distinct signature on this message. So that makes it convincing to any of the other nodes.
00:08:34.638 - 00:08:51.180, Speaker A: Remember, the condition here is that to be convinced, it has to have not just the sender's signature, but the signature of T minus one other distinct nodes who are not you. So when you add your signature, you become the T plus one distinct node. And that's good enough to convince the other honest nodes in the next time step.
00:08:51.180 - 00:09:03.914, Speaker A: All right, so that's the easy case. Let's go on the case two, which is trickier. And this is where you get convinced of a value V only as the game clock expires and goes to zero.
00:09:03.914 - 00:09:13.086, Speaker A: So it's time step F plus one. There is no more future to this protocol. There is no time to tell anybody anything, and you just got convinced of some value V.
00:09:13.086 - 00:09:32.838, Speaker A: And the problem is, how could you possibly know that all of the other honest nodes have also been convinced of V? At this point, you haven't had time to tell them yourself. In fact, your only hope is that you are literally the last node to be hearing about this value. Everybody else either already knew or are finding out about it at the exact same time that you are.
00:09:32.838 - 00:09:48.762, Speaker A: So let's see why that is in fact true. And this will finally explain why we have so many rounds of cross checking why we really needed to take as many as F plus one time steps. So you're a node, it's the last time step.
00:09:48.762 - 00:10:13.458, Speaker A: Timestep F plus one, you get convinced. What does it mean? So how could a message convince you only a time step F plus one of some value? Well, it must have F plus one distinct signatures, right? So the first one by the sender, but then also f other distinct signatures different than yours, right? That's what it means for a message to be convincing. So here's where we use our assumption that the number of Byzantine nodes is at most F.
00:10:13.458 - 00:10:41.180, Speaker A: If we see a message with F plus one signatures by distinct nodes, we know at least one of those signatures was given by an honest node. And so not only must it be the case that one of these signatures must be by an honest node, but it also must have been added at some time step previous to the current one, right? Because again, there is this delay of one before you hear a message. So if you got a message with an honest signature, that honest signature was provided at a previous time step.
00:10:41.180 - 00:11:08.994, Speaker A: And so this is actually great news, right? We're basically back now in case one. So while maybe you only got convinced of this value at the very last time step, so you didn't have time to notify everybody else. You now know that some other honest node, the one that contributed its signature to the message that convinced you some other honest node did in fact get convinced at an earlier time step, not F plus one, but some previous one.
00:11:08.994 - 00:11:24.474, Speaker A: So you didn't have time to notify everybody, but that honest node did. And if you think about it, it must be that honest node only discovered it at timestep F, and you're hearing about it only now. But the good news is you also know that all the other honest nodes are hearing about it now as well.
00:11:24.474 - 00:11:42.474, Speaker A: So you really are among the very last to be convinced of the value V. You can rest assured that all the honest, other honest nodes are convinced of V as well by this point, by the end of the protocol. And that completes the proof that this very clever dole of strong protocol indeed satisfies agreement, right? We had.
00:11:42.474 - 00:11:59.286, Speaker A: Both of our case is it doesn't matter when a node gets convinced of a value, you can rest assured that all the other honest nodes are also convinced of that value by the end of the protocol. Because the final output of each honest node is a function only of the set of values it's convinced of, since all those sets are the same. Everybody's final answers, everybody's outputs are the same as well.
00:11:59.286 - 00:12:11.008, Speaker A: And that's exactly what it means to satisfy agreement. Great. So now that the main theorem from this lecture, from lecture two is in the bag.
00:12:11.008 - 00:12:27.004, Speaker A: We understand that the Dulip strong protocol satisfies validity and agreement. Let me take a step back and just point out a very unusual property of this protocol that concerns the parameter little F. Remember, little F is the upper bound on the maximum number of byzantine nodes that we're trying to protect against.
00:12:27.004 - 00:12:53.988, Speaker A: So let's ask the question what role did little F play in the protocol's description and its analysis? So first of all, little F does play a role and that's sort of evident from the protocol's description because the number of time steps it does is goes up to F plus one. So basically the the length of time required by the protocol is linear in this parameter F. So it's maybe not surprising, right? The more byzantine nodes there are, the harder the situation.
00:12:53.988 - 00:13:18.588, Speaker A: You might expect to have to work harder and indeed that's what happens. So it scales linearly with F, the duration for which the protocol runs. But what about its key properties? What about validity and agreement? What assumptions about Little F did we need in our proofs of those two properties? Well, if you think about it or if you go back and review those proofs, you'll notice we actually didn't make any assumptions about Little F at all.
00:13:18.588 - 00:13:31.920, Speaker A: Those proofs work no matter what little F is. So you could be in a situation where you have two honest nodes and N minus two byzantine nodes and it doesn't matter. The Byzantine nodes still can't get those two different nodes to disagree.
00:13:31.920 - 00:13:54.872, Speaker A: And I want to emphasize this is actually very unusual and this will probably be the only result that we see about consensus protocols which can tolerate sort of basically an arbitrary number of Byzantine nodes. Normally for sort of nice results to be possible, you need a nontrivial upper bound on what F is as we'll see through a sequence of upcoming impossibility results. So that's super cool.
00:13:54.872 - 00:14:08.764, Speaker A: That for the Byzantine broadcast problem, at least under our current assumptions, the synchronous model, PKI, et cetera, it actually doesn't matter what F is. We can get validity and agreement no matter how many Byzantine nodes there are. Very cool.
00:14:08.764 - 00:14:36.432, Speaker A: But to be honest, I do need to remind you why was it we cared about Byzantine broadcast in the first place? Remember? Actually we set out to solve state machine replication, right? We wanted sort of to do consensus over and over and over again and keep a bunch of machines in sync. And then we introduced the Byzantine broadcast problem as sort of a subroutine that was sufficient to implement a good SMR protocol. So we showed that state machine replication reduces to Byzantine broadcast.
00:14:36.432 - 00:15:10.520, Speaker A: That's why we were bothering to solve Byzantine broadcast. So let's now sort of zoom back out a little bit and remember that that's sort of the use case that we're thinking of for Byzantine broadcast sort of embedded in this rotating leaders SMR protocol. And I want you to notice that actually, for state machine replication and this idea of sort of clients sort of doing kind of queries and updates to a bunch of copies of a database or to a blockchain if you're using byzantine broadcast in the context of state machine replication, it probably only makes sense if you have what's called an honest majority.
00:15:10.520 - 00:15:37.720, Speaker A: Okay? So if over half of the nodes are honest, less than 50% of the nodes are Byzantine. So what do I mean by that? Well, I mean, let's actually think about in the presence of faulty nodes, what should clients actually be doing, clients of this protocol? Like, imagine you just want to check the account balance of some account. So you just issue a query to a blockchain or to some node running a blockchain protocol and you're expecting them to respond with an account balance.
00:15:37.720 - 00:15:51.864, Speaker A: On the one hand we have consistency which says that all of the honest nodes stay in sync. So if you ask for the account balance from any one of the honest nodes, you'll get the same answer back. On the other hand, the faulty nodes are Byzantine.
00:15:51.864 - 00:16:11.900, Speaker A: They can do anything, so they can just make up numbers when you ask them about an account balance. So you're going to get different answers from different nodes when you have faulty nodes, potentially. So if strict majority of those nodes are honest, then you can take a majority vote.
00:16:11.900 - 00:16:32.980, Speaker A: You can just ask all of the nodes for an account balance and then the majority answer you know is going to be correct because that's the one that the honest nodes provided. But as soon as you have like a 50 50 split between honest nodes and Byzantine nodes, the Byzantine nodes can sort of coordinate on some completely alternative fictitious history. And now you're issuing these queries.
00:16:32.980 - 00:16:39.580, Speaker A: Half of them say one thing, half of the nodes say another thing. You have no idea which ones are Byzantine. You have no idea who to believe.
00:16:39.580 - 00:16:56.144, Speaker A: So in an SMR context where you really want sort of the transactions to sort of make sense, generally, one is thinking about the F less than N over two. That said, the Byzantine broadcast subroutine does not need that assumption. All right, so that wraps up lecture two.
00:16:56.144 - 00:17:31.244, Speaker A: That's everything I wanted to tell you about the Dole of strong protocol, right? This very strong possibility result showing that at least under the current set of assumptions, permission setting, public key infrastructure and the synchronous model, at least under those assumptions, there's a very strong and sweeping positive result for Byzantine broadcast and therefore for state machine replication. Now, starting with the next lecture, we're going to focus more on impossibility results. This was a possibility result, but really in distributed computing it's defined in large part by the interplay between what you can do, like what we saw today and what you can't do.
00:17:31.244 - 00:17:57.200, Speaker A: So lecture three, the next lecture, we will prove that the public key infrastructure assumption, that trusted setup assumption, is actually essential to achieving the guarantees that dolov strong offers, the guarantees that we just proved. So we'll see in the next lecture the necessity of the PKI assumption. Then starting with lecture four, we're going to really zoom in on this sort of synchronous model assumption that we're not that happy with and we're going to work on relaxing it.
00:17:57.200 - 00:18:17.624, Speaker A: And in possibility results will guide us to identifying a sort of sweet spot model of asynchrony, which on the one hand makes weak enough assumptions that it's sort of good for designing practical protocols, and on the other hand, there's sort of strong enough assumptions you can say meaningful guarantees about those protocols. So that's what's coming up next. I'll see you in lecture three.
00:18:17.624 - 00:18:18.100, Speaker A: Bye.
