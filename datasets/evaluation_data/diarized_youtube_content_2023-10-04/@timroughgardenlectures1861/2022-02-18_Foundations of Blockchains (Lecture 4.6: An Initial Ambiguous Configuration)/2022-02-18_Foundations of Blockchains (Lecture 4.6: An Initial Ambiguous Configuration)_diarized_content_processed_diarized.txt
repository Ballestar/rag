00:00:00.650 - 00:00:32.354, Speaker A: So we've done some of the initial setup for the proof of the FLP impossibility result. We know what configurations are. They're really just snapshots of a protocol's execution to this point. So it encodes nodes, private inputs, the sequences of messages that they've received thus far and the set of outstanding messages that are hanging out in the message pool. We also learned about zero configurations where no matter what the adversary does, all the honest nodes output zero one configuration. No matter what the adversary does, they all output one ambiguous configuration. The adversary has retained control over the output of the protocol.
00:00:32.354 - 00:01:21.874, Speaker A: So depending on the adversary's strategy, it can either force all zeros or it can force all ones. And so, remember, I'm referring to a single adversary, but I really mean an arbitrary conspiracy between any number of Byzantine nodes. We only have one Byzantine node, okay? But so a conspiracy between our Byzantine node and between the adversary who's controlling message delivery. And now what we're trying to show is we're trying to show that this allegedly correct protocol pi might run forever. So we're going to try to exhibit an infinite sequence of configurations along with message deliveries that sort of lead to that sequence of transitions so that you just stay ambiguous forevermore. So the adversary can sort of, for an arbitrarily long period of time, hedge its actions so that both all zeros and all ones are possible outputs of the protocol. That, of course, will contradict the assumption that pi satisfies termination.
00:01:21.874 - 00:01:54.382, Speaker A: That'll complete the contradiction and complete the proof that pi can't possibly exist. Now, we're going to generate this infinite sequence of ambiguous configurations through the teamwork of a Lemma One and a Lemma Two. Lemma One, which we'll prove in this video, is where we get started. So it's going to show an ambiguous configuration from which we can start the sequence. Lemma Two, which we'll only prove later, will show us how to extend a sequence by one additional ambiguous configuration. Applying lemma one to get started. Lemma Two, over and over again generates this arbitrarily long sequence of ambiguous configurations.
00:01:54.382 - 00:02:37.122, Speaker A: All right, so formal statement of Lemma One. There exists a way to get started in an ambiguous configuration. So formally, for any allegedly correct protocol pi that you hand to me deterministic satisfying Byzantine agreement. This lemma will show that I can hand you back an input, meaning a choice of a zero or one as the private input for each of the N nodes. I can hand you back a choice of private inputs such that in the corresponding initial configuration, it's ambiguous. So configurations can get pretty crazy. So, for example, you might eventually have billions of messages hanging out in your message pool.
00:02:37.122 - 00:03:36.070, Speaker A: But initial configurations sort of the configuration when you just sort of boot up the protocol and get it started, those are not so complicated, right? So, for example, we know that no node has yet received any message before the protocol has started, we know the message pool is empty. Okay, well, it's not quite empty. If you remember, we had that sort of that trick where it starts with these N dummy messages so that every node gets an opportunity to speak. But whatever we know what the message pool looks like, it's just these N dummy messages. So the only thing which varies across different initial configurations is what are the private inputs of the nodes? Everything else is exactly the same, no matter what the private inputs are. In other words, there's exactly two to the N possibilities for the initial configuration because there are two to the N ways of assigning a zero or a one as a private input to each of the N nodes. So what this lemma is asserting is that no matter what pi you look at, one of these two to the end configurations will be ambiguous.
00:03:36.070 - 00:04:31.814, Speaker A: It may be a different ambiguous configuration, a different sort of set of private inputs for different protocols pi but given any particular protocol pi, there exists some choice of private inputs so that you start out in an ambiguous configuration. In fact, sort of conveniently, we actually don't have to go searching over all two to the N possible initial configurations. We're going to identify a collection of only N minus one initial configurations such that one of them is guaranteed to be ambiguous. No matter what your protocol is, one of these N minus one inputs will start you out in an ambiguous configuration. So what are these candidate private inputs? Well, we're going to consider only the case where for some integer i, the first inodes all have a private input of one and the last N minus I nodes all have a private input of zero. So a bunch of ones followed by a bunch of zeros. So specifically, we'll use capital X, sub I to denote the configuration.
00:04:31.814 - 00:05:06.278, Speaker A: When the first inodes have the private input one, the last have the private input zero. So the input is all ones, all zeros, the corresponding configuration where also all of the nodes have the empty list of received messages and the message pool only contains the end dummy messages. To start, that configuration is called capital X, sub I. Okay, so a quick aside about proof strategy. All right, so let's remember the Byzantine agreement problem. What makes it hard is really needing to satisfy both validity and agreement and termination. If all you care about is termination and agreement, you definitely can solve Byzantine agreement even in the Asynchronous model.
00:05:06.278 - 00:06:02.042, Speaker A: If you only care about termination and validity, again, you can solve Byzantine agreement even in the Asynchronous model. So if there is an impossibility result to be proved, it must be for the problem where you really require both agreement and validity. And so what that means, if you think about it, is that any correct proof of this FLP impossibility theorem, it better use in the proof that the assumed protocol Pi satisfies both validity and agreement. Any proof? You should sort of try to zoom in on the point and say, AHA, this is where they're using that the protocol Pi satisfies validity. Here's the point where they use that it satisfies agreement. Any proof that doesn't use both of those two assumptions is automatically going to be wrong because there is no impossibility result to be proven if you drop either of those two requirements. So if you think about it, we've actually already used sort of as a sleight of hand, almost the agreement property.
00:06:02.042 - 00:06:43.590, Speaker A: Because when we were classifying configurations we said there's only three things that could happen, right? So either no matter what happens, everybody outputs zero, all the honest nodes output zero or they all output one. Or the adversary still sort of reserves the right to force people to all zeros or all ones, right? So the reason there are only those three kinds of configurations is because agreement guarantees that whatever happens, the final output to the honest nodes agree so they can't be mixed up. So there's only kind of three possible categories we need to consider. We have not yet used validity and we are going to use validity now. And this will be the only time we use it. We will basically throw it out after we make the following observation. Consider the configuration x sub zero.
00:06:43.590 - 00:07:20.338, Speaker A: So suppose we start things off where every single node has a private input of zero. Well, this is exactly the scenario where the validity assumption has bytes. Remember, validity actually requires nothing of a protocol except in the happy case where there's no disagreement amongst the honest nodes initially. But in the all zeros private input there's no disagreement, right? And validity insists that actually the common output of the honest nodes cannot be one, it must be zero. And to be correct, that has to be true no matter what the adversary does. Again, no matter what the Byzantine node is doing, no matter how the messages get delivered. That's what validity means.
00:07:20.338 - 00:08:06.066, Speaker A: So what that means is that x knot is most definitely a zero configuration. Again, a zero configuration means the adversary has no way of preventing all the honest nodes from outputting all zeros. And that is exactly what validity asserts is true of the protocol Pi. By the exact same reasoning, if all of the private inputs are one, that would correspond to the configuration capital x sub N in our notation. If all the private inputs are one, that's got to be a one configuration. Again, by validity, if all the honest nodes have an input of one, all of their outputs also have to be one. And so now what we're going to show is that actually one of the X sub I's must be ambiguous.
00:08:06.066 - 00:08:41.296, Speaker A: So we know it's not x zero, we know it's not x N, but we're going to argue that one of the intermediate x eyes must be an ambiguous configuration. If we can prove this claim, then we're certainly done with the proof of Lemma One. Lemma One just asks for some ambiguous configuration and we're saying one of the XIs will already give that to you. All right? So all we have to do is prove that claim. So let's prove it. So here's the picture I want you to have in mind. Okay, so on the one hand, we have the all zeros input, which by validity we know is a zero configuration.
00:08:41.296 - 00:09:07.752, Speaker A: We have the all ones input, which we know by validity is a one configuration. And I want you to think about flipping bits from zero to one, one at a time, from left to right. Now, in this thought experiment, we're starting with a zero configuration, the all zeros input. So we flip the first bit, change it from zero to one. Maybe it's still a zero configuration. We flip the second bit from a zero to one. Now we're in X two, maybe that's still a zero configuration.
00:09:07.752 - 00:09:53.260, Speaker A: But at some point we will flip a bit, the 17th bit. And for the first time we will transition from a zero initial configuration to something which is not a zero configuration. Because if nothing else, we know then when we flip that very last bit, the Nth bit and we get the all ones input, at that point we will no longer be in a zero configuration. We'll be in a one configuration by validity. So there will be some first coordinate, some first node where when we flip it, we escape from the realm of zero configurations and we're in something else. Maybe we're in a one configuration, maybe we're in ambiguous configuration, but we're no longer in a zero configuration. So call that I the first bit flip that takes you out of the land of zero configurations.
00:09:53.260 - 00:10:48.344, Speaker A: So to complete the proof, all we need to do is show that Xi cannot be a one configuration. Then the only remaining option is that Xi is the ambiguous configuration that we've been hunting for all along in Lemma One. So we'll complete the proof by now arguing directly that Xi must be ambiguous by the choice of I. We know it's not a zero, but we also need to show that it's not a one configuration. So how are we going to show that Xi is ambiguous? Well, let's just sort of kind of explicitly argue why an adversary from that configuration has the option of either forcing all the honest nodes to output zero, or alternatively, if it prefers, it can force all the honest nodes to output one. That, of course, is the definition of an ambiguous configuration. So first of all, starting from Xi, we know that the adversary can force the all ones output.
00:10:48.344 - 00:11:12.228, Speaker A: How do we know that? We know that because we chose I so that Xi is not a zero configuration. So either it's a one configuration. And literally every adversary strategy leads to the all ones output. Or it's ambiguous, but there still is some way that the adversary can force the all ones output. On the other hand, consider the following adversary strategy. And remember, little F is one. So there may be a Byzantine node out there.
00:11:12.228 - 00:12:07.300, Speaker A: And the bad case for the protocol is going to be when that Byzantine node happens to be this node I, the node whose private input being flipped took you from the zero configuration x I minus one to something that was not a zero configuration xi. So suppose I is Byzantine. Now, because we're in the configuration X sub i. This is where node I's true private input is one. So if I was an honest node, what it would be doing is it would be honestly following the protocol Pi fully acknowledging that its private input is one. However, if the node is Byzantine, an alternative thing it could do is follow Pi honestly under the pretense that its private input was actually zero, which it's not. Remember, the private input is one, but the Byzantine node could in effect flip it from one to zero in its mind and then follow Pi honestly.
00:12:07.300 - 00:13:18.262, Speaker A: So what's the point of this adversary strategy? Well, sort of as usual, the adversary's goal is to render two rather distinct scenarios indistinguishable from the perspective of the honest nodes. And so the whole point of this adversary strategy is to ensure exactly that indistinguishability, right? So the private input and the sequences of messages received by an honest node is exactly the same as it would have been had we started in the configuration Xi minus one. Had Node I's private input actually been zero. And all of the nodes followed Pi honestly, because every local node's knowledge is identical in those two scenarios, whether you're an Xi with this adversary strategy or whether you're an Xi minus one, with everybody being honest, because those look identical to every node. Every node outputs exactly the same thing in both cases. Now we certainly know what is the output of the honest nodes. If in fact we start in configuration xi minus one and everybody's honest xi minus one remembers a zero configuration.
00:13:18.262 - 00:13:54.066, Speaker A: And that means no matter what, whether people are honest or not, no matter what, the honest nodes conclude with an output of zero. So in particular, when everybody's honest, all the honest nodes conclude with an output of zero. So we've now exhibited a strategy for the adversary by which it can force the all zeros, starting from the initial configuration xi. And again, that adversary strategy is just the adversary sort of flips its private input in its mind first. So its real private input is a one. The adversary sort of pretends like it's zero and then follows the protocol Pi honestly from there. That's certainly something an adversary could do.
00:13:54.066 - 00:14:28.862, Speaker A: It's certainly a legitimate adversary strategy starting from X sub I so, combining one and two, we conclude that the adversary can either force all ones or can force all zeros. It totally has the power to determine which of those two outcomes occurs. And that's exactly the definition of an ambiguous configuration. So from this, from the fact you can force either all zero or all one, we conclude that Xi is ambiguous. And remember, the whole point of lemma one was to show that some initial configuration is ambiguous. And this is it. So that completes the proof of the claim, which therefore also completes the proof of lemma.
00:14:28.862 - 00:14:47.280, Speaker A: Lemma one is how we get started with this to be infinite sequence of ambiguous configurations. This is a good place to stop. Lecture four. Take a little breather. Starting lecture five, I will show you lemma two, the more notorious lemma and its proof. So I'll see you there.
