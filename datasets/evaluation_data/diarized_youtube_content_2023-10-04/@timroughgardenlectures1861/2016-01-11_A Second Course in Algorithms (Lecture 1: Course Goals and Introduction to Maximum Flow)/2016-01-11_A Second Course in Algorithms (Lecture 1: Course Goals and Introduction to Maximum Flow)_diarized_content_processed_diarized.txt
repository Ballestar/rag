00:00:00.250 - 00:00:38.290, Speaker A: Thank you. So welcome everyone, to CS 261. I think of this class, or in my mind, the title of this class is a second course in algorithms, the natural sequel to 161. The official title in the course book is a little bit different, optimization and algorithm paradigms. So before I do any technical content, let me just open with a few words about what the goals of this course are. So what you can hope to learn if you choose k 261. And so there's really two different goals, two major goals, and course splits roughly 50 50 down the middle with respect to each of these two.
00:00:38.290 - 00:01:47.626, Speaker A: So the first one, which is going to be very much in the spirit of CS 161, the focus will be on algorithms, fast algorithms for fundamental problems, fundamental and well solved problems. And indeed, if we were at a semester school, the first part of 261 would really just be what we would do in weeks eleven through 14 of a semester long version of introduction to algorithms. And so the theme here is out there in the world, there's a collection of fundamental problems that are simultaneously kind of basic and flexible enough to model lots of different applications, but also happily admit fast algorithms for their exact solution. So you saw several of these in 161. So you could think, for example, about the shortest path problem. So what did you learn in 161? You learned the definition of the problem and various variants, maybe negative edge costs or non negative edge costs. You learned some famous algorithms dijkser's algorithm, the bellman ford algorithm, definitely parts of the greatest hits of algorithms.
00:01:47.626 - 00:02:35.886, Speaker A: And hopefully maybe you also got some practice recognizing that certain problems which don't immediately look like a shortest path problem, nevertheless can be solved using the shortest path algorithms. So for example, maybe planning a sequence of decisions over time might have been something that you solved problems of this form that both come up all the time and also have fast algorithms. Those are pretty much the top priorities to cover in a class like that. It's kind of like the number one thing I want to give you before you leave the course. So why? Well, a major skill you can get by taking 261 you couldn't get elsewhere would be you avoid reinventing the wheel. So first of all, you recognize out there in the world the problem you care about really is just something that's already well solved. Once you recognize it.
00:02:35.886 - 00:03:17.802, Speaker A: As such, you have in your toolbox an algorithm you can just code and solve the problem quickly. You don't have to invent a new algorithm from scratch. And again, also a major thing that we'll practice a little more on the homework than in the lectures, but still a skill that I hope you get is the ability to recognize that many problems out there that show up in the real world are really just thinly disguised versions of the basic problems that we focus on. Again, maybe if you saw some examples of that, we'd say shortest path in introduction. Okay, so you already know that shortest path. So obviously we'll be covering other problems, sort of more sophisticated problems. So in the first five weeks, we'll talk about the maximum flow problem.
00:03:17.802 - 00:03:59.366, Speaker A: We'll start on that today. We'll talk about computing graph cuts, which is closely related to the macro problem. We'll talk about computing matchings and graphs. And then this will culminate in the study of linear programming, which is one of the sort of most general problems for which we know algorithms that are efficient both in theory and practice. So we'll talk about algorithms for all these problems and also why you should care about these problems, what kinds of things they model. So the running times won't be quite as blazingly fast as in 161. In one and 161, almost everything winds up being near linear time.
00:03:59.366 - 00:04:54.826, Speaker A: So these won't often be near linear time. They might be, say, quadratic time, but they're still fast enough that generally, if there's a problem that you actually care about and it reduces something on this list, you should be pretty happy because there are off the shelf algorithms which solve them pretty quickly. So that's going to be the gist of the first half of the class. Now, unfortunately, lots of problems that you're likely to bump into in your future career don't actually fall into this collection. So the second course goal is to give you some tools for dealing with problems that, while important, are not so well solved. And we'll look at two categories. Primarily, there's a bunch of different things we want to put over here, but in 261, we'll focus on two things.
00:04:54.826 - 00:05:37.560, Speaker A: So first of all, we'll talk about problems, which are NP hard, meaning problems where we don't think there's any polynomial time algorithm for solving it exactly, unless p equals NP. So you have to do something else. So you have to compromise when you want to solve NP heart problems. So for example, one thing we'll look at is heuristics. And again, this is often how you actually deal with NP heart problems out there in the real world. So we'll say, okay, if you want, what's a principled way to design algorithms? While not guaranteed to always be correct, or at least mostly correct, hopefully almost or all of the time. And so we'll look at a lot of design and analysis techniques for heuristics building, for example, on our work in linear programming in the first half of the course.
00:05:37.560 - 00:06:12.466, Speaker A: The other category of sort of hard to solve exactly problems are so called online algorithms. So this is pretty anachronistic at this point. This is not referring to the Internet. This is not referring to social networks. Online algorithms just means your algorithm is forced to make decisions without knowing the future, or you can think about it without knowing the entire input. So it's almost like it forces you into a greedy type algorithm, even if you wish you could do something smart. And so that comes, as you can imagine, all the time.
00:06:12.466 - 00:06:46.634, Speaker A: You have to design algorithms and make decisions that are important, but you don't really know what's going to happen later. So these problems again come up a lot, and you probably haven't seen about them, anything about them in your previous algorithms courses. 261 is where you learn the basics of that, I guess. One other comment, just about the course, I sort of think of there being two audiences for 261. Both audiences, I think, for me, are very important. I'm very interested in the first audience, some of you. This will be the last algorithms class you've ever taken, so you'll graduate this year or next year without taking any more.
00:06:46.634 - 00:07:26.082, Speaker A: And so for you, I really want to pack the course with essentials. So if I only get ten weeks of your time to tell you sort of algorithms you don't know yet, I think about 261. I think about what are the algorithms that make the cut that are worth telling you about in this last course you're ever going to take on algorithms. On the other hand, there's a second audience. Some of you might be contemplating deeper study of algorithms. So maybe you're thinking about research, or at the very least, maybe you're thinking about other 203 hundred level theory courses. And so for you, I want to give you a little bit of a sense of the cutting edge, so when there's opportunities present themselves, they'll talk about recent developments and the topics we're discussing.
00:07:26.082 - 00:08:08.466, Speaker A: And I want to give you a little bit of a glimpse of what lies in your future if you take more, say, 203 hundred level algorithm courses here at Stanford. So that's the second thing we'll talk a little bit about. So just if I think about sort of where 261 lies in the overall curriculum, I think of it as sort of a gateway to advanced algorithms, at least for the second of the two audiences that I mentioned. Okay. And indeed, so after you, after you're done with 261, you're extremely well equipped to take any of the other 200 or 300 level algorithms courses that we teach at Stanford. And now there's a bunch of them. Actually 261.
00:08:08.466 - 00:08:51.906, Speaker A: It also sort of interpolates, I think, between just the pace and the difficulty of 161 and what you can expect to see in courses, either other 260 something courses or 300 level courses. So it's definitely going to be a faster pace than 161, but definitely not as fast as when I teach 300 level courses. I sort of have this mental model for the typical student in each of these classes. So when I teach 161, that's required for all majors. So I look out there in the audience, and my baseline assumption is that a constant fraction of the students would rather not be there and maybe even hate math. And I try to give them a great course despite the fact that that's kind of the type of science that's fine. 261, I assume you want to be here.
00:08:51.906 - 00:09:20.234, Speaker A: I think of this as a self selecting group. I think of I'm talking to a science of people who like algorithms and want to know more about it. I'm not going to assume that you necessarily love math, but I think I am going to assume that you don't hate math. Sort of how I think of this class through interlevel classes. I'm thinking more about people who really want to do research. PhD students and undergraduate master's students that are thinking of going on for grad school. So that's sort of another level of sort of depth and sophistication that I'm a student, so that's where I'm coming from in 261.
00:09:20.234 - 00:09:54.198, Speaker A: That's sort of how I think about this class. All right, so pause for questions in a second. But I'm sure one question that's on many of your minds is, so what do you have to do? Deliverable. Let me first mention a non deliverable. So every week is going to be an exercise set. It's going to be posted usually on Thursday or Friday, and it will cover, it'll be related to the two lectures that just happened earlier in that week. And these are not to be turned in.
00:09:54.198 - 00:10:31.054, Speaker A: We will not grade them if you turn in any solutions. So the point of the exercise sets, it's really a framework for you. It gives you sort of a litmus test for whether or not you're understanding what's going on in the 261 language. So if you can answer those exercise set problems, then you're in good shape, and if not, then, well, they're not turned in. So just talk to us in office hours. We're happy to just walk you through the solutions for anything that doesn't. Now, as far as incentives to actually look at it, to actually do the exercise sets, the final exam, I'm going to promise you at least 50% of it will be drawn either directly or will be minor variants of these problems that show up on the exercise set.
00:10:31.054 - 00:10:55.398, Speaker A: Questions? Okay. So it's what I think is really important for you to take away from the lecture. So no coincidence. It's also what I'm going to be testing at the end of the class. So that's a non deliverable. So what are you graded on? There's going to be four problem sets, so that'll be 75% of the grade. So these are to be done in groups, groups of up to three, and only one write up per group.
00:10:55.398 - 00:11:25.726, Speaker A: Okay. So you can split up the problems amongst you, or what I'd recommend is at least two people work on your problem so you can exchange ideas and collaborate. So a few goals for the problem sets. So one thing I'm trying to do is just basically give you a way to think long and hard about algorithms outside of class, which is really kind of the experience of learning algorithms. You probably already saw this some in CS 161. Tough problems you just got to think about for a long time to crack them. But in doing so afterwards, you feel like you're a little smart.
00:11:25.726 - 00:11:50.874, Speaker A: So I want to sort of give you that experience through the problem sets. I want to give you an opportunity to collaborate with other students, which, especially in a class like this, for these kinds of problems. I think it's really fun, actually, to cooperatively solve these problems. And then third, through the problem sets, I'll be able to supplement, complement the material that I do in lectures. So you'll actually learn new cool results through the problem sets. For that reason, they're pretty challenging. You can't sort of learn stuff for free.
00:11:50.874 - 00:12:07.218, Speaker A: It takes some work. So you're going to have two weeks to do them. They'll go out every Tuesday. Starting next week, there'll be two weeks to turn them in. So budget some time for that. I think most of you will find them challenging, interesting, I hope the challenging. And there is a late day policy.
00:12:07.218 - 00:12:39.818, Speaker A: I'm not going to talk about it in class. It's up there on the website, which again is live at Csduceel Stanford. That's the first thing. And then I alluded to a final. So the final will be in class, three hour exam at the time specified by the registrar. And this is very different from the problem set in particular. The final question is going to be much easier than the problem set question, as reflecting the fact is an in class exam, you don't have two weeks to do it.
00:12:39.818 - 00:13:18.934, Speaker A: And the goal is also quite different, right? So whereas here you're really going to be building and extending the lecture material for the final. I'm really just making sure that you've mastered the most basic and useful concepts that we teach in 261. So it'll all be stuff that you saw in lecture. If you sort of understood all the lectures, it should be really quite easy. In fact, last year I actually got complaints on my evalves, but the final was too easy, which is, I don't know if you know my reputation, CS 161, but never had that complaint. And again, as I've said, at least 50% of it, you already know what the questions are. They'll be drawn from the from the exercise and then that's it.
00:13:18.934 - 00:13:47.764, Speaker A: That's the extent of the deliverables. Any questions. So there's no textbook, but I will be posting lecture notes. I write the lecture notes after I give the lecture. So this should be up on the web generally within a week of when the lecture occurs. So that'll be the primary source. I'll post other resources as needed.
00:13:47.764 - 00:14:44.790, Speaker A: And again, as I mentioned, the videos will be taped and up on YouTube within a couple of days after the lecture. So if you want to rewatch one or if you're out of town or something, or sick for one, you can catch up. All right, then let's go ahead and start our first topic, maximum flow problem. This is a stone cold classic algorithm strokes. It's been around for over a half century, so it's very easy to understand intuitively. Let me first just kind of give you a sense for it through an example. Then I'll give you the formal definition.
00:14:44.790 - 00:15:22.030, Speaker A: So it's a problem in graphs or networks. So I'm going to draw a picture which is going to look a lot like the pictures we drew back when you studied shortest paths, although the semantics are going to be different. So we have a directed graph. You can also look at maximum flow and undirected graphs. I'll ask you to explore that in the first exercise set. But for lecture, let's just think about directed graphs. Each edge has a number attached to it, and the meaning of that is the edge's capacity.
00:15:22.030 - 00:16:25.590, Speaker A: So that's the amount of stuff that the edge can carry in some sense. And the Maxwell problem is all about understanding how much stuff can you push through the network from s, which is called the source vertex, to T, which is called the simple vertex. So for example, in this network it's clear or if you think about a little bit actually, let me ask you to think about a little bit, even though I haven't defined the problem formally. So just informally, if these numbers represent how much stuff an edge can carry, what would be your guess about how much stuff you could push from SVP? So I heard of you five, which is a good answer. So here'd be a way you could push five units. You send two units on the upper two hop path, two units on the bottom two hop path, and then a fifth unit on the zigzag path. And the amount of stuff you're pushing across any edge is at most its capacity.
00:16:25.590 - 00:17:24.220, Speaker A: We are sending three units of flow here, two units of flow here, three units of flow here, two units of flow here, and one unit of flow here. So the point is, all of those purple numbers are most of white numbers. So how do we know we can't send more than five units, though? Is that obvious? This is a way to get five, so it shows we can get at least five. Can we possibly get more than we could? And it's actually kind of obvious to see why, which is just look at the source vertex s. We can only pump five units out of the source so that's the total capacity outgoing from the source. So five is the best case scenario we can actually. So that's sort of the gist of the maximum flow problem.
00:17:24.220 - 00:18:05.670, Speaker A: Let me define a little bit more formally. So given as input a directed graph. So vertices b directed edges e, again max flow. The algorithms we'll talk about also work in undirected graphs with minor modifications. As you'll think about there's a source vertex sink, vertex p and a capacity. And for simplicity let's think of the capacity as integers. So an integral capacity UE for all edges.
00:18:05.670 - 00:18:47.270, Speaker A: So just like a picture of this. So that's the input. Now what are the feasible solutions? What are the objects that an algorithm is allowed to output? Well, they're going to be flows in the picture I described flows by drawing these paths. But for algorithms it turns out to be much better. You just think about sort of the superposition of the paths and think about these purple numbers. Remember these purple numbers are what's the total amount of stuff being sent on a particular edge. So we're going to work with these flows on edges.
00:18:47.270 - 00:19:29.774, Speaker A: So what is a flow? You assign a non negative number to every edge. And again in this example these non negative numbers correspond to the 3212 and three. Those are the non negative numbers I'm talking about. And to be a flow you have to satisfy two types of constraints. So subject to, so first of all there are capacity constraints. You can't send more stuff on an edge than it has capacity. So the way you write that is just SV amount of flow is the most of the capacity for all edges.
00:19:29.774 - 00:20:08.026, Speaker A: So again those are capacity constraints. And then the other thing we need is we need what are called conservation constraints. So if you look at any vertex v other than the special source and the special sink, it better be the case that the amount of flow going in is the same as the amount of flow going out. What I mean by the amount of flow going into the vertex v is just what you think. I look at all of the edges that enter v. I sum up the total amount of stuff that any of them carry flow out. I just look at the outgoing edges and again I sum up the flow outgoing.
00:20:08.026 - 00:20:38.226, Speaker A: It just says the total flow coming into these should be the same as the total flow going out. For example here, take a vertex like this one. So we have three units of flow going from s to this vertex. So three units go in, three units also go out. It split two on this edge and one on this edge. But still the total flow out is three, which is the total flow. So that by definition is a flow, just a non negative number on each edge that meets the capacity and conservation constraints.
00:20:38.226 - 00:21:07.150, Speaker A: So if you have an output number satisfying it feasible solution, of course you could just set everything to zero, it would be a feasible solution. Not so interesting. So we actually want a particular flow. The goal is to amongst all flows maximize the flow value what the flow value? It's just the total amount of stuff going out of the source.
