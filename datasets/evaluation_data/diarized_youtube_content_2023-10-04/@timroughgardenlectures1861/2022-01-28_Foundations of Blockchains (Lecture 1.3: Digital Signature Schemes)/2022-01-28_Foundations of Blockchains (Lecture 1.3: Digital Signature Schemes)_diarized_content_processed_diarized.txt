00:00:00.570 - 00:00:09.946, Speaker A: So in this video we're going to start getting a little bit more technical, a little bit more formal. We're going to be building up to start discussing consensus protocols in earnest.
00:00:10.058 - 00:00:11.920, Speaker B: Next lecture in lecture two.
00:00:12.290 - 00:00:50.310, Speaker A: So first of all, what do we even mean by consensus? So that's actually a subtle question and we'll have to be careful about it. But let me just tell you what I mean just very informally by consensus. So consensus is roughly going to mean keeping a bunch of machines in sync. And in this context machines are often referred to as nodes. And I encourage you to think of these nodes as just machines that are scattered all over the globe communicating with each other over the internet. So two things are going to make consensus quite nontrivial to achieve. So first of all, there's a certain unreliability of a communication network like the Internet.
00:00:50.310 - 00:01:20.994, Speaker A: You're going to have unexpected network delays, network outages, maybe even sort of malicious attacks like denial of service attacks. And then the second thing that makes consensus hard is we don't want to assume that every node is correctly running the intended protocol. So maybe some nodes have sort of an out of date or buggy version of the protocol. Maybe some nodes are actually even controlled by a malicious actor who's trying to subvert the protocol. So we want to keep these machines all over the globe in sync, despite the fact that you might have network.
00:01:21.042 - 00:01:24.150, Speaker B: Unreliability and you might even have malicious attacks.
00:01:24.490 - 00:02:05.330, Speaker A: So here's the plan over these lectures for understanding the consensus problem. We're going to start at the beginning of lecture number two. We're going to pile on so many assumptions that it will become clear how to achieve consensus. We'll almost sort of trivialize the problem. Then as we go on future lectures beyond lecture two, we'll start relaxing those assumptions one by one, thereby getting more and more realistic versions of the consensus problem, requiring more and more ideas to actually achieve consensus. There will however, be two assumptions that we never relax. Two permanent assumptions that will just stand throughout the entire lecture series, both of which happily, are quite easy to stomach.
00:02:05.330 - 00:02:31.546, Speaker A: So first of all, as I was saying when we were talking about layer zero in the blockchain stack, we're going to take as given that the internet exists, the two untrusted parties can communicate with each other as long as they know each other's IP address. We're not going to assume the Internet's perfect. There's going to be delays outages, possible dos attacks, but we will assume we can build on top of the Internet. The second thing we're going to assume, and which we'll drill down on the rest of this slide, is we're going.
00:02:31.568 - 00:02:34.510, Speaker B: To assume that we can use cryptography.
00:02:34.930 - 00:03:00.994, Speaker A: So cryptography, obviously it's a huge field. There's tons and tons of cryptographic tools that have been implemented. There's even more that have been at least constructed in theory the good news is in these lectures we're going to need kind of the bare minimum of tools from cryptography. So for the most part, we're going to need only two things. First of all, we're going to need the existence of cryptographic hash functions. That's something we won't talk about in this lecture, but we'll talk about it at length later, especially in the context.
00:03:01.042 - 00:03:02.374, Speaker B: Of proof of work.
00:03:02.572 - 00:03:36.898, Speaker A: And then the thing which we will talk about right now, we will assume the existence of digital signature schemes. So what do I mean by a digital signature scheme? Well, intuitively it's just like it sounds, right? We all know what it means to sort of sign a document sort of in real life with pen and paper. So we just want some analogous way to add your signature to documents that are digital. Now formally the way we define a digital signature scheme is through three algorithms, a key generation algorithm, assigning algorithm, and a verification algorithm. So let me say a little bit about each of those three algorithms in.
00:03:36.904 - 00:03:37.860, Speaker B: A little more detail.
00:03:38.710 - 00:04:13.674, Speaker A: So the key generation algorithm is of course responsible for, wait for it, generating keys, and in particular a pair of keys, a public key and a secret key which are intimately related. So the way I'm going to sort of write this algorithm is I'm going to think of it as taking as input a random seed, so just some random number plucked from the sky. And then in return as output, it gives you a pair of keys, a public key, which as the name would suggest, is meant to be broadcast to the world, and a secret key, which as the name would suggest, you're meant to sort of keep secret and not tell anyone else at all.
00:04:13.712 - 00:04:15.518, Speaker B: And we'll see why in a second.
00:04:15.684 - 00:04:37.178, Speaker A: Now, in practice, often the key generation algorithm actually takes nothing as input. It just generates its own random seed internally and then hands you on a silver platter your public key secret key pair. So for example, at a typical Unix command line, if you just type in SSH keygen with no arguments, you'll get back a public key secret key pair. So this is just off the shelf.
00:04:37.214 - 00:04:39.720, Speaker B: Technology available at the command line.
00:04:40.890 - 00:05:29.186, Speaker A: So what can you do with a secret key? What can you do with a public key? Well, you can sign and verify respectively. So let's start by being precise about the signing algorithm. So the signing algorithm takes two inputs, right? So it needs to know what you want to sign so that's the message that'd be like a document and also it needs to know who's signing it and the who here is specified by this secret key. So given a message to be signed and given a secret key with which to sign it, that signing algorithm produces the signature. So it hands you back the same message. The message is there in the clear, but tacked onto the end is a signature which is meant to authenticate the fact that the owner of the secret key was in fact the one who signed that message. So signatures are really just kind of annotations on messages.
00:05:29.186 - 00:06:05.982, Speaker A: They're just sort of a little bit extra added at the end. So a key point about this signing algorithm and about digital signatures in general is that the signature that you generate depends on the message that you want to sign. Notice both the message and the identity of the person are inputs to the signing algorithm and its output. The signature depends on both of those two inputs. And this is different than real life, than physical signatures. If I'm assigning a document physically with a pen on paper, my signature is independent of the contents of that document. That's how signatures normally work.
00:06:05.982 - 00:06:59.390, Speaker A: Now, in the digital realm, of course, that would never work because there'd be a simple copy and paste attack. If I wanted to pretend that I was you, all I need to do is go find one message that you had signed and I would copy and paste your signature on any other message I want, making it look like you signed it, when really you had no intention of doing so. So to have any hope of working in the digital world, it's absolutely essential that the signature depends not just of course, on the identity of the signer, but also on the content of the message being signed. Finally, we have the verification algorithm whose responsibility is to check whether or not an alleged signature actually is valid. Now, for a verification algorithm to carry out this task, it's of course going to need to know the message in question. It of course needs to know the alleged signature that it's trying to check. And then it also needs to know who it is who supposedly generated this signature.
00:06:59.390 - 00:07:37.802, Speaker A: And so in the signing algorithm, identity is indicated by the secret key. In the verification algorithm, it's going to be indicated by the corresponding public key. So these are the three inputs to the verification algorithm, the message that was supposedly signed, the supposed signature, and the identity of the person who supposedly signed it identified by their public key. The output of the verification algorithm is just a simple yes or no. So it's supposed to say yes. If indeed someone possessing the secret key corresponding to the given public key would generate the given signature on the given message. That means the signature is authentic.
00:07:37.802 - 00:07:51.310, Speaker A: It really was signed by the person who knows the secret key corresponding to the public key or the algorithm report no if that's not the case. So if in fact signing this message with the corresponding secret key would generate a different signature than the one provided.
00:07:51.390 - 00:07:54.100, Speaker B: Then the verification algorithm will tell you no.
00:07:54.470 - 00:08:43.266, Speaker A: So notice the secret key is used for signing, the public key is used for verification. Both the secret key and the public key are sort of identifying the same person, but the secret key is supposed to be known only to that person, which makes sense because we want only that person to be able to generate signatures. On the other hand, we'd like anybody to be able to verify the authenticity of our signatures. And so that's why we want the verification algorithm to need only the public key. And then if we publish the public key on the Internet, it means anybody can verify using the verification algorithm any message that we sign. So if you haven't encountered previously digital signature schemes, it may seem kind of magical, and actually, to be honest, it still seems kind of magical to me, but we've had construction of them practical constructions since the late 1970s. Okay, so this is really just kind.
00:08:43.288 - 00:08:46.274, Speaker B: Of off the shelf technology, I should.
00:08:46.312 - 00:09:21.134, Speaker A: Say a little bit about what it means for a digital signature scheme to be secure. So in all of these lectures, we'll make a sort of extreme assumption. It's still a very close approximation to reality, but a sort of extreme assumption that signatures are ideal. So for us, this is basically going to be assuming that forgeries are impossible. So the only way you could ever generate a signature on a message that would be verified by a given public key is if you actually knew the corresponding secret key. You couldn't magically figure out what the signing algorithm would output if you didn't know what the secret key is. So let me just write don't know.
00:09:21.134 - 00:09:32.238, Speaker A: Secret key implies impossible to generate a valid message. Plus SIG here. By valid, I mean something that would be accepted by the verification algorithm if you fed in the public key corresponding.
00:09:32.254 - 00:09:33.794, Speaker B: To this unknown secret key.
00:09:33.912 - 00:09:50.986, Speaker A: So this assumption of ideal signatures, it's a close approximation of reality, at least if you use a properly implemented digital signature scheme and a sufficiently long key length. But as a theoretician, I do feel obliged to point out that strictly speaking, this assumption is false. This is not satisfied unless you make.
00:09:51.008 - 00:09:52.870, Speaker B: Some mild extra assumption.
00:09:53.030 - 00:10:10.570, Speaker A: So why is it false? Well, I mean, in principle, I could brute force your secret key, for example. So what do I mean? So maybe I see one signature you did on one message. There was some message where you signed it using the signing algorithm and using your secret key. And then I see the signature that was generated.
00:10:10.650 - 00:10:12.320, Speaker B: I don't know your secret key, though.
00:10:12.770 - 00:11:04.394, Speaker A: Well, now, again, I could brute force it so I could just enumerate over every possible sort of string of bits that your secret key possibly could be. I'd keep feeding it into the signing algorithm. At some point, the output of the signing algorithm will agree with the signature that I saw that you generated. At that point, I've guessed your secret key correctly, and now I can just use it to sign future messages as if I was you without your permission. Okay, so in principle, it's not true that you can't forge messages without being explicitly told the secret key. But still, like, we're not worried about this brute force attack, right? I mean, as long as the key length is sufficiently long, like, imagine it was a 512 bit key, say, then this brute force attack is going to have to enumerate through two to the 512 different possibilities, which is a ridiculous amount. It's more than the estimated number of atoms in the universe.
00:11:04.394 - 00:11:05.319, Speaker A: So no one's ever going to be.
00:11:05.319 - 00:11:07.490, Speaker B: Able to complete that computation.
00:11:08.390 - 00:11:39.340, Speaker A: So in order to make this assumption actually true, at the very least, we're going to have to bound the computational power of a potential attacker. We can be quite liberal. We can give it, say, an arbitrarily large polynomial number of operations here, polynomial and the length of the key. But the brute force attack takes an exponential number of tries. So polynomial computation is not going to be good enough to execute the brute force attack. All right, so this is an additional mild assumption that we need to make, right, that basically adversaries don't have infinite computing power.
00:11:39.790 - 00:11:42.620, Speaker B: They just have polynomialally bounded computing power.
00:11:43.070 - 00:12:16.230, Speaker A: While we're on this topic, actually, I should mention that in a digital signature scheme, these three algorithms, you, of course want them to actually be efficient. So someone with a bounded amount of computational power should be able to carry out each of these three algorithms. Good. So I guess we're done, right? We just sort of say that everybody has polynomially bounded computation, which is a pretty modest assumption, and then we're done, because that's not enough computation to pull off the brute force attack. Well, there's another issue, right, which is who said that an adversary can only.
00:12:16.300 - 00:12:18.530, Speaker B: Resort to brute force search attacks?
00:12:18.690 - 00:13:26.026, Speaker A: If an adversary had some very clever algorithm for reverse engineering a secret key without doing brute force search, it would certainly use that instead. And remember, if you've studied some computer science, you've seen lots of examples of computational problems where the obvious brute force search approach was unimplementable, took exponential time, but there was some super clever computational shortcut that solved it very quickly. Take, like, the shortest path problem, right? So, like, a network can have an exponential number of paths from a source to a destination. Yet dejkstra's algorithm somehow cleverly just sifts through the exponential number of possibilities in near linear time and computes the shortest path. So what strikes fear in our hearts is the prospect of there being a similar computational shortcut for the problem of reverse engineering a secret key, having seen a number of messages signed with that secret key. And this is the reason why computational complexity assumptions sort of always enter the picture when you're talking about the security of cryptographic schemes. You have to somehow assume that there aren't, that these shortcut algorithms don't exist, which fundamentally is a computational complexity assumption.
00:13:26.026 - 00:14:06.678, Speaker A: Now, different digital signature schemes make different complexity assumptions to justify their security. For the schemes that are most common in a blockchain context, what's important is the computational hardness of the discrete log. A discrete logarithm problem not important. You know what that is if you haven't seen it before. It's basically, I give you a group element g raised to some exponent x, and you want to try to figure out what x was knowing only g to the x. And the assumption is that there's no shortcut algorithm for that discrete log problem. And what you can prove is that under that assumption, assuming there's no efficient algorithm for discrete log, in fact, there's no efficient algorithm for reverse engineering a secret key from a collection of messages.
00:14:06.694 - 00:14:09.050, Speaker B: That have been signed with that secret.
00:14:09.470 - 00:15:14.370, Speaker A: Okay, so to review, we see we need to assume that the adversary has polynomially bounded computation. We see that we need to make complexity assumptions to rule out any shortcut algorithm much faster than brute force search for reverse engineering a secret key. And actually, technically, we need one more kind of assumption, which is we need to allow a potentially very small probability that the scheme is broken, right? Because even a polynomially bounded adversary, they can't do brute force search, but they could still guess a few times. They could write down a random number, hope it's your secret key, you know, sign a message they saw you signed earlier. If their random guess fed into the signing algorithm happens to generate the same signature that you generated, the adversary is like, whoa, I just magically guessed the secret key, and now I can just sort of forge messages from that person forever more. Now, again, this is not something we're actually worried about, because if the key length is decently long, the probability that you would magically guess a secret key is exponentially small. It's just basically zero.
00:15:14.370 - 00:15:36.918, Speaker A: But technically it's nonzero. So summarizing. Now, we understand the sense in which this sort of ideal signatures assumption, strictly speaking, is false. But this discussion also tells us exactly how would we modify it to make it a little bit weaker, but basically the same. But so they would actually become true, right? So the formal security statement for a.
00:15:36.924 - 00:15:40.122, Speaker B: Digital signature scheme would then be under.
00:15:40.176 - 00:16:39.180, Speaker A: Suitable complexity assumptions, like assuming that there's no polynomial time algorithm for solving the discrete logarithm problem. Under that assumption, it would be the case that no polynomially bounded adversary, meaning the amount of computational time that they have, is the most polynomial in our key length. Under the complexity assumptions, no polynomially bounded adversary would have more than a non negligible probability of reverse engineering a secret key from a collection of messages that had been signed with that secret key. So that's going to be the formal security statement. We're not actually going to use that statement. We're going to just stick with the ideal signatures assumption because it's a close approximation of reality and it simplifies our life in a lot of other respects. But I did just want to clear my conscience and let you know that this is false and also let you know what is the closely related version of the statement that's actually true.
00:16:39.180 - 00:17:00.274, Speaker A: And as I said, since the late 1970s, constructions have been known of digital signature schemes that do satisfy this type of security guarantee. We're not going to talk at all about how those schemes are constructed in this lecture series, but I encourage you to look in a cryptography book or check out a cryptography MOOC, which would.
00:17:00.312 - 00:17:02.690, Speaker B: Explain exactly that exactly what the construction.
00:17:03.270 - 00:17:37.294, Speaker A: Digital signature schemes are used all over the place in a blockchain context. I mean, typical blockchain protocols involve a lot of communication between a bunch of nodes that don't necessarily trust each other. And so digital signatures are essential for sort of knowing the authenticity of a message. So for example, if I'm Node A and some Node B tries to convince me that oh, Node C said this other thing earlier, I'm going to say like, well, show me Node C's signature on that messages. On that message, I'm not just going to believe you Node B about what you say that Node C said, show me the signature and then I'll believe.
00:17:37.332 - 00:17:39.520, Speaker B: That Node C said that message.
00:17:40.210 - 00:18:16.242, Speaker A: And indeed, when we start talking about consensus protocols, beginning in lecture number two throughout this lecture series, unless I say otherwise, just by default, assume that every single message sent by some node A to some other node B is in fact signed by node A. So every message in one of our protocols is going to be by default signed by the sender. So that wraps up everything I wanted to say, at least for now, about cryptography and specifically digital signature schemes. So in the next video, we'll start introducing some of the vocabulary necessary to discuss the correctness of consensus protocols, specifically consistency and liveness.
00:18:16.306 - 00:18:17.970, Speaker B: I'll see you there. Bye.
