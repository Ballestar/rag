00:00:00.330 - 00:00:20.026, Speaker A: All right, so all of lecture two has been building up to this point. What I now want to show you is a general solution to Byzantine broadcast, which again, by our reduction, gives a general solution to state machine replication, a general solution to Byzantine broadcast under our standing assumption. So under the assumption of a permission setting.
00:00:20.026 - 00:00:51.418, Speaker A: So a known set of nodes, PKI, so nodes at public keys that are common knowledge, and the synchronous model, that nodes have a global shared clock and that messages sent in one time step arrive at the beginning of the next time step. And so this protocol, which is called the Dolev Strong protocol, after its inventors back in 1983, we will see satisfies both validity and agreement under these assumptions. So before I dive into the description of this protocol, let me say a few words about why I'm spending some time on it.
00:00:51.418 - 00:01:04.062, Speaker A: Because I'll be honest, if you go read various blockchain protocol white papers, you're not going to see mentions generally of the Dolof Strong protocol. And there's a couple of reasons for that. So one is its reliance on the synchronous model.
00:01:04.062 - 00:01:18.738, Speaker A: And when we describe it, you'll see that it really does depend on this idea that messages have bounded delay, that you can guarantee that they arrive by the next time step. The real world is not really the synchronous model if you're communicating over the Internet. So that's one issue.
00:01:18.738 - 00:01:31.190, Speaker A: Another issue is that it's kind of slow. So as we mentioned in the last lecture, we're going to basically need one extra round of cross checking for each additional faulty node that we want to tolerate. So that's sort of more rounds than you'd like to use.
00:01:31.190 - 00:01:52.062, Speaker A: All right? So you may not see this referenced in various white papers that you may read. However, it's still really worth spending time on for a couple of reasons, right? So number one, frankly, it's just one of the greatest hits of distributed computing. And at least personally, it's almost like you go to a museum and you admire some famous work of art and you're like, cool, I experienced this kind of famous work of art.
00:01:52.062 - 00:02:00.738, Speaker A: And so same thing with algorithms and results in computer science. If something is kind of part of the canon, it's just nice to see it once in your life. So that's one reason.
00:02:00.738 - 00:02:22.902, Speaker A: Another reason is, frankly, it doesn't take that long. I mean, the protocol description is short as we'll see, the proofs of validity and agreement are clever but short, so we can do this in a reasonable amount of time. And third, I really think it would be pedagogically unsound to jump straight into the relatively complicated protocols which form the basis of some actual real world blockchain protocols.
00:02:22.902 - 00:02:52.562, Speaker A: Much more sensible, I think, is to slowly build up your intuition about the challenges and techniques available for consensus protocols by making the setting successively more difficult. So I wanted to spend some time now in the relatively safe confines of the synchronous model, let you get comfortable with it and then we can move on to climbing the next mountaintop of trying to have consensus protocols even with much weaker assumptions about the communication network. So that's why we're doing what we're doing.
00:02:52.562 - 00:03:11.270, Speaker A: Now let me go ahead and jump into the description of the dole of strong protocol. Actually I need one definition first I'll write down the definition on this slide and then the protocol description on the next slide before I write down that definition which to be honest is a little bit of a mouthful. Let me give you some intuition about sort of the strategy in this protocol.
00:03:11.270 - 00:03:36.426, Speaker A: So one thing we built intuition for in our toy examples with f equals one, f equals two, et cetera, is that it seems like the hard case is when you have a Byzantine sender. It's true when you have an honest sender you got to make sure you satisfy validity. But it kind of feels like the real danger in Byzantine broadcast is that a Byzantine sender maybe in cahoots with various Byzantine non senders tricks the honest non senders into disagreeing.
00:03:36.426 - 00:03:55.154, Speaker A: So we want to make sure that that doesn't happen. So the approach for the honest non senders in the Dole of strong protocol is basically they want to catch a Byzantine sender red handed. So they're going to compare notes and basically they're going to look for evidence that in fact the sender sent out inconsistent messages.
00:03:55.154 - 00:04:13.918, Speaker A: And if all of the honest nodes can convince themselves of that fact that the sender behaved inconsistently, they can conclude that the sender was in fact Byzantine. And if they know that the sender is Byzantine they no longer care about validity, they no longer worry about what private input that sender might have had. All they need to do is agree.
00:04:13.918 - 00:04:33.682, Speaker A: And so if they all know that the sender is Byzantine they can all default to some canonical output value, for example the empty list of transactions. So this definition is basically going to correspond to a node figuring out that the sender sent a particular value to some other node in the past. So that's the rough idea.
00:04:33.682 - 00:04:45.810, Speaker A: But let me really give you the precise definition. So it's a definition of a node. I being convinced of a value V at a particular time step t in the protocol.
00:04:45.810 - 00:05:04.460, Speaker A: Now the way a node is going to get convinced is by receiving a sort of convincing message. So a message is going to be convincing if it satisfies three different properties. Property one, obviously the message should include a vote for v that should be the value referenced in this message.
00:05:04.460 - 00:05:26.650, Speaker A: Secondly, the only possible convincing messages are those signed by the sender. Now a message may be signed by multiple nodes but in particular the very first signature that belongs to this message should belong to the sender. Because remember this node is really just trying to figure out what were the messages that the sender sent out at time T equals zero and were they consistent or were they inconsistent.
00:05:26.650 - 00:05:37.422, Speaker A: That's what it's trying to figure out. So it's only interested in messages that the sender might have sent out at time T equals zero. That's just going to be a value with that sender's signature.
00:05:37.422 - 00:05:49.846, Speaker A: Anything else it's just happy to ignore. Finally, the node is going to be looking for attestations by other nodes as well. And the number of attestations it wants is going to depend on what time step you're in.
00:05:49.846 - 00:06:06.560, Speaker A: So node I is really looking for a total of T different nodes to vouch for this message. The sender, that's going to be the first signature. But it also wants to see T minus one signatures by other nodes, all distinct from each other, all distinct from the sender and all distinct from this node i.
00:06:06.560 - 00:06:28.386, Speaker A: So for example, if I'm node number seven and it's time step three and I receive a message which is signed first of all by the sender, second of all by node number 23 and third of all by node number 29, then I will be convinced of the payload of this message. Whatever value is referenced in this message, I will be convinced of it at this time. All right.
00:06:28.386 - 00:06:37.046, Speaker A: So with this definition in hand, I can now describe to you in one slide the dole of strong protocol. So again, what it takes for a message to be convincing. It references a value.
00:06:37.046 - 00:06:55.630, Speaker A: It should be signed first by the sender, should then be signed by T minus one other nodes different from the node receiving the message. If all of those conditions hold, then node I is like, okay, I guess I believe now that the sender actually sent a message with value V to some other node at time T equals zero. Okay, so that's the takeaway from this definition.
00:06:55.630 - 00:07:06.684, Speaker A: Moving on to the protocol description. And again, remember always this is the protocol run by the honest nodes. Business nodes can be doing whatever.
00:07:06.684 - 00:07:21.836, Speaker A: So with time T equals zero, really no surprises. What we expect an honest sender to do is just tell all the other nodes what its private input is, as usual signing it. Then we come to the multiple rounds of cross checking.
00:07:21.836 - 00:07:32.784, Speaker A: And again, with every additional faulty node that we want tolerate, we're going to need one extra round in particular. The last time step is going to be timestep F plus one. At that point the protocol will halt.
00:07:32.784 - 00:07:50.300, Speaker A: All the nodes will be responsible for computing an output at that time. Remember this makes sense to write down the expression f plus one in the protocol description because we assume that the bound of the number of Byzantine nodes, the parameter little F, we assume that is known up front. So that's something the protocol can reference.
00:07:50.300 - 00:08:11.884, Speaker A: So what happens in one of these time steps? Well, basically if a node has just received a convincing message, if it becomes newly convinced of some value v, it basically wants to tell the world about it. So it wants to then go around and convince all of the other nodes as well. Okay, so we have all these time steps with all of the nodes doing cross checking and trying to convince each other of various values.
00:08:11.884 - 00:08:48.440, Speaker A: But at some point the timer goes off and timestep F plus one comes along and the honest nodes are responsible for sort of figuring out what to output. So how do they do that? Well, remember the rough intuition behind these convincing messages, right? So nodes are basically trying to gather evidence for themselves about the different values that the leader might have sent out at time t equals zero because they're looking for evidence that the sender acted inconsistently. So in particular, if at the end of this protocol some node has been convinced of more than one value, it interprets that as evidence that indeed the sender was inconsistent, was Byzantine.
00:08:48.440 - 00:09:05.680, Speaker A: And again, in this case we're off the hook with validity. The honest node can stop worrying about what some private input might have been and can output a canonical value, which I'm just going to denote by bottom which you can think of as the empty list of transactions. So that's what happens if a node gets convinced of two or more values.
00:09:05.680 - 00:09:20.388, Speaker A: Now, there's also the case, if you think about it like a Byzantine sender could just never send anything. So it's conceivable that the protocol could end with an honest node being convinced of no value at all. In which case, again, we can just default to say, bottom the empty list of transactions.
00:09:20.388 - 00:09:32.748, Speaker A: The final case where you're convinced of one and only one value. Well, seems like that's the case where you should output that value, right? And that's exactly how the final answers are computed. And that is it.
00:09:32.748 - 00:09:46.832, Speaker A: That is the description of the Dolev strong protocol. When F equals one, when there's at most one Byzantine node, this becomes somewhat similar to the last protocol that we were looking at, still a little bit different. That protocol sort of figured out the outputs using a majority vote here.
00:09:46.832 - 00:10:03.380, Speaker A: Basically, either you're uniquely convinced of a value in which case that's your output, or if not you output a canonical default value, but fairly similar in the F equals one case. But this is well defined for any value of F. You just have one additional round where nodes try to convince each other of various values.
00:10:03.380 - 00:10:17.260, Speaker A: So don't let the short length of this protocol description fool you. It's really a very clever protocol and I think you'll particularly appreciate that if you look at the next video where we prove the properties of this protocol. For now, let me just state them.
00:10:17.260 - 00:10:31.280, Speaker A: In fact the dull of strong protocol under our assumptions permissioned PKI and the synchronous model. The dull of strong protocol does indeed satisfy the two properties that we want. It does indeed satisfy validity and agreements.
00:10:31.280 - 00:10:41.952, Speaker A: The protocol also obviously satisfies termination. It's guaranteed to stop after that last time step time step f plus one. Okay, so that's definitely something you want to know.
00:10:41.952 - 00:10:58.344, Speaker A: Doloph strong protocol is a solution to Byzantine broadcast in the sense that it satisfies validity and agreement with Byzantine faults as long as you're in the synchronous permission setting with public key infrastructure. Now, in the next video, we're going to go through the proofs of this. I encourage you to watch it.
00:10:58.344 - 00:11:02.260, Speaker A: They're clever, short and sweet. So I'll see you there. Bye.
