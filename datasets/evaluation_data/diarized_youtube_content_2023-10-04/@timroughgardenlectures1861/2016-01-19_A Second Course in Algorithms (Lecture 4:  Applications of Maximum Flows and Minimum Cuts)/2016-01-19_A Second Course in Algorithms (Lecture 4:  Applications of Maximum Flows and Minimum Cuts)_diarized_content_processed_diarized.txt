00:00:00.490 - 00:00:36.546, Speaker A: Okay. So exercise set number two is going to be posted later today. And then the plan for today is I'm going to remind you about the St minimum cut problem and the fact that we know how to solve that efficiently. And then the bulk of the lecture is going to be about an application to a problem in image segmentation computer vision. And then hopefully we'll have time to talk a little bit about bipartite matching at the end of the lecture as well. But before I do any of these new topics, I do owe you one proof from Tuesday. So this one key Lemma, which I didn't prove, which was essential for our analysis of the push relabel algorithm.
00:00:36.546 - 00:01:17.646, Speaker A: You'll recall that what we did is we derived the cubic running time bound O of N cubed where n is the number of vertices four push relabel. Assuming this key Lemma, what does the key Lemma say? It says, well, suppose you have a preflow in a graph. So remember a preflow that's we've relaxed the conservation constraints. A vertex might have more flow coming in than it has coming out, and that's known as its excess. So Suppose You Have A Preflow F. Look At The Residual Graph g sub F. If There's A Vertex That Has Excess positive Excess, so The Flow In strictly Bigger Than The Flow Out, then It Asserts That There Must Be A Path in The Current Residual Graph from this Vertex with XSV Back To The Source.
00:01:17.646 - 00:01:46.558, Speaker A: S okay, so that's what the lemma says. Let me remind you briefly how we use this. This was really the thin end of the wedge for our analysis. We were sort of off to the races once we had this. So the first thing we did is we used this to just argue that no vertex's height could grow too large. The reason for that is, well, the source by our invariant is always anchored at height n. We have this invariant that says that edges in the residual graph can only go downhill at most one at a time.
00:01:46.558 - 00:02:11.874, Speaker A: So if you have a path from a vertex to the source in the residual graph and the source is stuck at n, it means that you started at most O of n. So it bounded the maximum height of any vertex at any time of O of N. There's only N vertices. Every relabel bumps up a height. So that gave us the quadratic running time bound on the number of relabels. We then piggybacked on that bound to prove bound on the number of pushes. We did that in two cases.
00:02:11.874 - 00:02:42.734, Speaker A: So first we talked about saturating pushes. That's where you have a vertex with excess. You push as much flow as you can on an arc and the bottleneck is the edge. So saturating push, you saturate that outgoing edge, that edge drops out of the residual graph. And we argued that for any given edge, if you zoom in and look at two consecutive times, that you have a saturating push in the same direction, on the same edge. That can only happen if you have at least a couple of relabels of both endpoints in between. Since any vertex can only be relabeled o of n times, any edge can only have a saturating push o of n times.
00:02:42.734 - 00:03:09.298, Speaker A: That gives us an o of MN bound on the number of saturating pushes even better than the N cube that we were looking for. Finally we bounded. Non saturating pushes. Remember what this means. This means that you have a vertex with excess. You push as much flow as you can, and the bottleneck is actually the vertex, so you have plenty of capacity, but you zero out the excess. And so this is the part of the proof where we use the fact that we always process the vertex with excess with the highest height.
00:03:09.298 - 00:03:30.970, Speaker A: How do we use it? Well, we argue. Suppose you have a non saturating push at some vertex. It has height like twelve. And so it's the biggest one. So anything else with excess has height? Twelve or less, just by our choice of the vertex. If we have a non saturating push, its excess becomes zero by definition. And then the key point is that it will never become positive again until there's a relabel.
00:03:30.970 - 00:03:55.426, Speaker A: Why not? Well, where could it get excess from? Somebody would have to push to this vertex. But we only push downhill, so it'd have to be from some vertex with height 13 or higher. But none of those vertices have any excess by the choice of the vertex v. So that's why, given the key lemma oh, sorry. I should say that then that means that you can only have O of NAN nonsaturating pushes between any pair of relabels. There's only N squared relabeled. So only N cubed.
00:03:55.426 - 00:04:17.566, Speaker A: Non saturating pushes. So that's the analysis recap. So let's prove this. Let's prove the lemma. So hopefully the lemma is pretty intuitive, right? So somehow you have this pre flow and you have positive excess at some vertex v. And so somehow this excess flow had to have gotten there somehow, and at some point it came from S. So the thinking is you should just be able to go back.
00:04:17.566 - 00:04:48.178, Speaker A: So that's good intuition. That's good motivation for why you might state this as a conjecture. But it's not a proof. And I do feel like I owe you a proof. So fix a preflow f and the proof? It's not too long, and it sort of resembles an argument we did back in lecture number two when we were proving the max flow Min cut theorem. One of our steps in that proof said oh, well, if we have a maximum flow, we can exhibit a cut with exactly the same value. That was part of our proof.
00:04:48.178 - 00:05:45.162, Speaker A: So this will look a little bit like that. So Define A Subset of vertices capital A, as if you look at the original graph and you look at the current preflow, basically do your favorite graph search, BFS, DFS, whatever, from the source s on edges that carry flow, positive flow, okay? And see how far you get. Call that set a. So v reachable from s on edges e of the original graph with Fe positive. Okay, so you see how far you can get, maybe you can get to everybody who knows. All right, so this is the second example of sort of the reachability trick. In a proof that we saw in lecture number two, we did something similar.
00:05:45.162 - 00:06:12.546, Speaker A: We did breadth first search or depth first search out of the source for the analysis. And there we were going in the residual network until we got stuck. So here we're actually looking at edges that carry positive flow in the original network until we get stuck. Okay, so let b denote the other vertices. Let me point out that the source is definitely not in B, okay? The source can certainly reach itself. So the source is in A, not in B.
00:06:12.648 - 00:06:13.300, Speaker B: Okay?
00:06:13.910 - 00:07:02.610, Speaker A: All right, so what's the point of this set? Where did I pull this out of? Well, suppose there's a vertex in A, okay, so there's a sequence of edges from S to v, all of which carry positive flow. Well then what does the residual graph look like? For each of those edges that's carrying positive flow, there's a reverse arc with positive residual capacity. So if you can get from S to V in the original graph on edges that carry flow, you can get from V to s. Sorry, if you can get from S to V in the original graph on edges that carry flow, you can get from V to S in the residual graph by following the reverse arcs. And that's what we're trying to do. We're trying to say that all vertices with excess have to have paths in the residual network back to the source. So the Lemma is claiming that every single vertex with positive excess is a member of A.
00:07:02.610 - 00:07:06.274, Speaker A: Nothing with excess should be a member of B. That's what we have to prove.
00:07:06.402 - 00:07:07.080, Speaker B: Okay.
00:07:09.690 - 00:08:09.290, Speaker A: Okay, so how do we do this? Well, again, sort of a similar trick to lecture number two. We're going to sum up the difference between the flow in and the flow out, okay? This time for all of the vertices in b. What can you tell me about each term of this sum? It could be zero. What else could it be? Remember, we have a flow and not a preflow. We have a preflow and not necessarily a flow. So if it's not zero, it could only be only be negative, right? So the flow in is allowed to exceed the flow out. Okay, so this is going to be non positive.
00:08:09.290 - 00:08:17.322, Speaker A: I'm using the fact here that s is not a member of B.
00:08:17.456 - 00:08:17.802, Speaker B: Okay?
00:08:17.856 - 00:08:23.898, Speaker A: So in a preflow, the source is the one vertex which is allowed to have more flow going out than coming in.
00:08:24.064 - 00:08:24.780, Speaker B: Okay?
00:08:26.270 - 00:09:01.506, Speaker A: All right. So now like in lecture number two, what we want to do is we want to think about this sum in a different way, not as a sum over vertices, but as a sum over edges. So let me draw sort of a picture that you've seen before. So imagine you have g, and imagine over here you have the set b, and over here you have the set a. So whenever you partition a vertex set into two pieces in a directed graph, you get four categories of edges. You get edges that go internally to b, edges that go internally to a, arcs that go from b to a, and arcs that go backward from a to b. Every edge is of one of those four types.
00:09:01.506 - 00:09:44.600, Speaker A: And just like lecture two, we can ask how much does each of those types of edges contribute to this sum? And the answer is the same. So let me just remind you briefly, this is a sum over the vertices in b. So if the edge doesn't interact with b at all, then it doesn't matter, okay? It has nothing to do with this sum. If an edge is entirely inside b, both endpoints are in b, then that flow amount will contribute once positively and once negatively. So it'll contribute positively for the outgoing flow of the tail of the vertex into the incoming flow on the head of the vertex head of the edge. Excuse me, anything that goes from b to a that's going to contribute positively once. Anything going from A back to b that's going to contribute negatively once.
00:09:44.600 - 00:10:26.034, Speaker A: So when the dust settles, this is just the sum of the flow on edges going out of b minus. The flow on edges going back into b. Remind you this notation I used this last week. So delta plus, delta minus, that means the edges sticking out of and sticking into respectively, the set of vertices b. So these are the delta plus edges here. These are the delta minus edges here. So as promised, things sticking out contribute once positively.
00:10:26.034 - 00:10:28.850, Speaker A: Things sticking back in contribute once negatively.
00:10:29.010 - 00:10:29.720, Speaker B: Okay?
00:10:30.970 - 00:11:11.460, Speaker A: All right, so let me say something pretty uncontroversial about these guys. So these are non negative. That's a requirement of a preflow, no big deal. Here's what's interesting. I claim the flow on any edge sticking into b has to be zero. The flow on any edge sticking into b has to be zero. Why? Well, if it sticks into b, it sticks out of a.
00:11:11.460 - 00:11:37.482, Speaker A: How do we define a he said, well, do reachability on edges that carry flow until you get stuck. So if this edge sticking out of a had positive flow, we wouldn't have gotten stuck, right? A would be bigger. Our graph search would have go ahead and traverse this edge. Okay, so by virtue of getting stuck at a searching along flow carrying edges, it must be the case that anything going from right to left has to be flow zero.
00:11:37.616 - 00:11:38.300, Speaker B: Okay?
00:11:39.970 - 00:11:47.550, Speaker A: All right, so that means of course, that this whole sum is non negative.
00:11:48.130 - 00:11:48.880, Speaker B: Okay?
00:11:50.370 - 00:12:05.950, Speaker A: So we've derived two things about exactly the same quantity, okay? We've written in two different ways. First of all, we argued that it's non positive, and in fact, every single term of this sum has to be non positive, other than we argued that the thing has to be non negative.
00:12:06.110 - 00:12:06.866, Speaker B: Okay?
00:12:07.048 - 00:12:16.598, Speaker A: So the only way both of those can be true is if this sum is zero. And given that this is non positive term by term, the only way this can be zero is if every single term is zero.
00:12:16.764 - 00:12:17.480, Speaker B: Okay?
00:12:20.110 - 00:12:54.480, Speaker A: So putting all this together, we get that for all vertices of b, flow in equals flow out. In other words, every vertex with positive excess has to be in a, cannot be in b. And again, remember, if you're in a, that means there's a flow carrying path from s to v, so there's a reverse path in the residual network from v to s, which is what we were supposed to prove. All right, any questions?
00:12:54.890 - 00:12:55.640, Speaker B: It.
00:13:07.690 - 00:13:32.890, Speaker A: All right. So that wraps up business from last lecture push relabel. And in fact, that's the last maximum flow algorithm we're going to talk about in CS 261. I could talk until the cows come home about maximum flow algorithms. There are dozens and dozens of different algorithms. There's even been a couple of big breakthroughs just in the last couple of years, which is not normal in the 21st century. Typical year, nobody says anything really new about maximum flow.
00:13:32.890 - 00:14:18.558, Speaker A: Last couple of years have actually been sort of different. So maybe I'll say a little bit more if there's time in some future lecture. So you could have a whole class on max flow algorithms if a CS 261, I think four is probably enough. And so I want to move on to applications of maximum flow. How do you put these algorithms to use? And then I want to move on to other important problems, which you should also know good algorithms for. So the rest of this lecture is about given a fast algorithm for maximum flow as a subroutine, which we now have. How can you piggyback on that to solve other problems you might care about? So this is a good point just to sort of remind you about why the lecture material is what it is.
00:14:18.558 - 00:14:58.106, Speaker A: Why do we study these algorithms, study these problems? So, first of all, the algorithms we've studied. So number one is, I think when you want to develop intuition about some nontrivial computational problem like maximum flow, for most of us, the easiest way to understand the problem is to actually think about algorithms that solve the problem. And so that was the whole point of starting with Ford fulkerson the algorithm is easy enough to understand, and through it we define residual networks. We get a feel for what the maximum flow problem is like. Another reason I sort of tell you all these specific algorithms is because some of them are just part of the canon, part of the greatest hits of algorithms all time. So I'd put Edmunds, Carp, dinnick, and push relabel all in that category. So it's just kind of cool, right, to know how they work.
00:14:58.106 - 00:15:23.678, Speaker A: And then the last of those algorithms, I mean, all of them are reasonably efficient if you implement them well. But push relabel again, is typically blazingly fast in practice. So it's actually a great starting point if you really need to solve maximum flow yourself in your future work. I'm not saying you can't do better at all, but it does really, really well. So it's a great starting point. All right, but why study that's great. So if you want to understand max flow, you should study these algorithms.
00:15:23.678 - 00:16:04.634, Speaker A: But why do you want to understand max flow? Okay, and so I said this before, I'll say it again. Like all central algorithmic problems, first of all, just in its own right, it literally models things that we care about. You can imagine traffic in transportation networks, oil going through pipes. You can imagine data packets to communication networks. They all sort of obviously map onto a max flow type setup. And this will be more the point of this lecture is lots of problems turn out to just be thinly disguised versions of maximum flow, and this takes maybe a little bit of practice to get used to. And I think, frankly, one of the sort of most useful skills I can impart to you in CS 261 is giving you the ability to recognize when the tools from this class are going to be useful.
00:16:04.634 - 00:16:44.480, Speaker A: So we're sort of moving into a part where that's what we focus on. All right? And I should say there's going to be lots more examples on the exercise sets and the problem sets, because I really think this is one of the skills that you're most likely to actually put to use yourself sometime after the class. Okay? So next up is going to be one of these sort of much less obvious applications of maximum flow. Actually, it's going to be an application of the minimum cut problem, which we also know how to solve. It's an application in computer vision. So we talked about min cuts, made a cameo in lecture number two when we approved the max flow min cut theorem, and we saw an algorithm. But let me just remind you because it was pretty fast.
00:16:44.480 - 00:17:34.970, Speaker A: So what is the problem? First of all, the mincut problem, the input. Same kind of input as in max flow. So a network, a source, a sync edge capacities, what's the goal? I e. What's a min cut? So you want to compute the st cut a comma B. So remember, this is just a partition of the vertex set s should be in A, t should be in B, that minimizes the capacity of the cut. What's the capacity of a cut? Well, it's the sum of the capacities of the edges that stick out. So delta plus A, edges that stick out of the set A, the source side of the cut, and you look at their capacity.
00:17:34.970 - 00:18:16.680, Speaker A: Okay, so importantly, edges that stick back into the source side of the cut do not contribute to the capacity of the cut. So it's really capacity outgoing is the definition. Okay, so that's the Min cut problem. And let me remind you of something. We noted this in passing, but actually this is just like a really good thing for you to remember for as long as you can. This is one of those sort of if you've taken 261, this is kind of obvious, and if you haven't taken 261, you'd have no idea what I was talking about. So st Min cut reduces to max flow in linear time.
00:18:19.610 - 00:18:22.590, Speaker B: And okay, so.
00:18:22.660 - 00:18:33.740, Speaker A: Given that we know how to solve max flow, we actually know how to solve Min cut. We saw this as a byproduct, actually, of one of our proofs of correctness. And it was the same thing I alluded to earlier. We had this proof in lecture two which showed oh, well.
