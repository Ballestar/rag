00:00:00.650 - 00:00:12.458, Speaker A: Hi everyone and welcome to this video that accompanies section 24.3 of the book Algorithms Illuminated, part four. This is a section about feasibility checking in the FCC incentive auction.
00:00:12.458 - 00:00:35.142, Speaker A: So in the last video, we developed a greedy heuristic algorithm for the value maximization problem. So packing the most valuable stations on the air on a given number of channels subject to no interference between them. What we saw is that in each loop of that greedy algorithm, we needed to do a feasibility check, which basically boiled down to a graph coloring problem, which of course is an NP hard problem.
00:00:35.142 - 00:01:06.926, Speaker A: But one takeaway from that video is that if we only had a magic box that could perform feasibility checking for us, then we could actually run that greedy algorithm and hopefully, at least after carefully tuning those station specific multipliers reliably generate solutions with total value close to the maximum possible. Now, it's fine to talk about magic boxes, but our dreams of magic boxes have already been thwarted once in this case study. Remember that the original value maximization problem was too tough for the latest and greatest mixed integer programming solvers.
00:01:06.926 - 00:01:38.202, Speaker A: So I understand if you ask why should we expect to do any better this time? Well, what we've got going for us is that the subroutine required by that FCC greedy algorithm, it's only responsible for feasibility checking. So given a graph figuring out whether or not it's k colorable, whereas before we were talking about the optimization problem, which would correspond to, I give you a graph, and among all of the k colorable subgraphs of that graph, find me the one that has the total value. So that's a harder problem.
00:01:38.202 - 00:02:17.560, Speaker A: So that raises the hope that for the easier, if still NP hard, the easier feasibility checking problem, maybe we could have a magic box even though we were not able to have a semirelible magic box for the harder optimization problem. And this Pivot from thinking about optimization as we did at the beginning, to thinking about feasibility checking as we are now, given that we're committed to this greedy approach to the value maximization problem, that Pivot suggests changing the language and technology that we're using. So moving away from the arithmetic and mixed integer programming solvers that we started with and moving to the language of logic and Satisfiability solvers instead.
00:02:17.560 - 00:02:32.450, Speaker A: Now, the first time we encountered the graph coloring problem, it was in that video talking about Satisfiability solvers. And in that video we showed how you could encode the graph coloring problem. How to encode checking whether or not a graph is K colorable as an instance of Satisfiability.
00:02:32.450 - 00:02:43.966, Speaker A: So that formulation is immediately relevant here in the FCC incentive options. Let me just remind you about that formulation first. What is it we're trying to encode? It's an instance of graph coloring.
00:02:43.966 - 00:02:55.566, Speaker A: So we're given an undirected graph g and number of colors k. We want to encode this as Satisfiability. So let me remind you the ingredients in a Satisfiability instance.
00:02:55.566 - 00:03:05.826, Speaker A: So, first of all, you've got decision variables, and they're super simple decision variables. They're forced to be Boolean, so they can only take on the values true or false. And then the other ingredient is constraints.
00:03:05.826 - 00:03:37.086, Speaker A: And again, the constraints are forced to be super simple, just these disjunctions of literals, where a disjunction just means logical or and a literal just means either a decision variable or its negation. Now, at first it may seem like an awkward marriage graph coloring with Satisfiability because with graph coloring, it seems like what you really want is not a Boolean variable, but a k valued variable for each vertex, specifying which color it is assigned. Whereas in Satisfiability, we're stuck with these simple true false variables.
00:03:37.086 - 00:03:54.198, Speaker A: But you might recall there's a very simple fix, which is for each vertex, we're not going to have just one decision variable, but k decision variables. So we'll have one decision variable per vertex v and per color i. And the intended semantics of that variable are that XVI should be equal to true.
00:03:54.198 - 00:04:09.974, Speaker A: In a truth assignment, that should mean that the vertex v receives the color i. If it receives any other color, then XVI should be false. So for the first set of constraints, we're going to have k constraints for each edge of the input graph.
00:04:09.974 - 00:04:27.850, Speaker A: So suppose there's an edge between the vertices U and V. We're going to have k constraints where the it constraint rules out both U and V getting the color i. And then if we have k of those constraints, one per color together, those k constraints will force U and V to get different colors.
00:04:27.850 - 00:04:48.066, Speaker A: It will be ruled out that they get the same color. How do we do that? Well, for a given edge UV and a given color i, we just have the constraint not XVI or not Xui. Remember, when you have a disjunction of literals, there's only one way to fail to satisfy them, which is when you do the opposite of every single one of their variable assignment requests.
00:04:48.066 - 00:05:09.550, Speaker A: So this constraint is asking us to set either Xui or XVI to false. The way to not satisfy it is to set both of those to true, and that corresponds exactly to coloring both U and V the color i. So this first family of constraints prevents any pair of endpoints from being assigned to the same color, exactly what we want in graph coloring.
00:05:09.550 - 00:05:27.106, Speaker A: Now, that can't be the whole story, because it's actually very easy to satisfy all of these constraints. Namely, if you just set every single variable to false, these constraints are all going to be satisfied. Meaning, if you don't color the vertices anything, you're not worried about an edge having two endpoints that are the same color.
00:05:27.106 - 00:05:46.890, Speaker A: So we need another set of constraints to force each vertex to get a color. So we want to rule out that for a vertex v, all k of the decision variables XV one up to Xvk, they should not all be false. So that's just this disjunction of XV one or XV two or dot dot dot Xvk.
00:05:46.890 - 00:06:07.998, Speaker A: These constraints do leave open the possibility that more than one of these variables will be set equal to true corresponding to a vertex receiving more than one color. But in that case, no matter how you pick one of the colors assigned to each of the vertices, you're going to get a k coloring. Because this first family of constraints rules out conflicts between any of the colors.
00:06:07.998 - 00:06:26.760, Speaker A: Assigned to a vertex U and any of the colors assigned to a vertex V. Alternatively, if it bothers you that more than one of these variables might be set equal to true, we can add an additional third family of constraints that rule out a given vertex V being given simultaneously. Two different colors, I and J.
00:06:26.760 - 00:06:47.220, Speaker A: And that is it. That is the entire encoding of the graph coloring problem as an instance of Satisfiability. And as we saw back in that video on Satsolvers, this is exactly the kind of format you can just feed into the latest and greatest Satsolvers and see how well they do.
00:06:47.220 - 00:07:08.914, Speaker A: Now, in the actual FCC incentive auction, the feasibility checking subroutine which it needed, it was basically a graph coloring problem, but not exactly a graph coloring problem. There are a couple of twists I want to tell you about on this slide, which we're going to need to then incorporate into our Satisfiability formulation. This also goes back and involves dropping the second of our four assumptions.
00:07:08.914 - 00:07:19.500, Speaker A: From our four simplifying assumptions, we already dropped the first one. Remember, our first assumption was the ridiculous assumption that there's only one channel for all stations to go on. Now we have k channels where k might be 23.
00:07:19.500 - 00:07:39.790, Speaker A: Our second simplifying assumption was that there was a very easy test to know whether or not there was interference between two stations. Namely, we've been assuming that two stations interfere if and only if they are assigned to the same channel and their broadcast areas overlap to first order. That explains most of what's going on with interference, but there's some complications.
00:07:39.790 - 00:08:04.902, Speaker A: So depending on the exact pair of stations and the exact pair of channels, sometimes it's also not kosher to assign overlapping stations adjacent channels like channel 14 and channel 15. So in some cases for some pairs of stations, you need a gap of at least two between the different channels that they get. And unfortunately, it's actually pretty idiosyncratic exactly which pairs of stations and which pairs of channels are going to lead to interference.
00:08:04.902 - 00:08:39.560, Speaker A: So the way this was handled in the FCC incentive auction, this problem of figuring out who would interfere with whom on which pairs of channels, that was outsourced to a different team, and that team had to work pretty hard. They compiled this list and the list said exactly for each pair of stations, which pair of channel assignments were forbidden, which channel pair assignments would create interference. And that list, while not easy to compile once it had been put together and passed over to the team responsible for building the feasibility checking, very, very easy to incorporate into the Satisfiability formulation that we've already been using.
00:08:39.560 - 00:09:05.722, Speaker A: Specifically, let's remember the first family of constraints. In the basic Satisfiability formulation, one of those constraints has the form not Xui or not XVI. What does a constraint like that accomplish? It makes sure that it is not the case that station U is assigned channel I and also station V is assigned channel I.
00:09:05.722 - 00:09:41.682, Speaker A: But if you think about it, that exact same constraint makes perfect sense if instead of I and I, you have in J for two different channels, I and J. So for example, the constraint not x U comma 14 or not x V comma 15, that would preclude assigning station U to channel 14, while also assigning station V to the adjacent channel 15. So given that this other group was compiling this list of forbidden pairs of channel assignments for each pair of stations while they had to work pretty hard to put together that list, it translates immediately into the Satisfiability formulation.
00:09:41.682 - 00:10:05.038, Speaker A: For each line item in their list, you literally just have one constraint of this form with two literals ruling out that that particular pair of stations receives that particular pair of channel assignments. So that's how we get rid of that second of the four simplifying assumptions, we started with this very simple assumption of when it is that two stations interfere. It's actually quite complicated, but can be compiled into this list.
00:10:05.038 - 00:10:28.470, Speaker A: And it's that complicated list that we actually use in the real Satisfiability formulation. Now, there's one other twist I want to tell you about on this slide, which is in a graph coloring instance, any vertex can receive any of the k colors, and that's actually not quite right in the application. In the FCC incentive auction, it was not the case that all of the television stations were eligible for all of the possible 23 channels.
00:10:28.470 - 00:10:54.170, Speaker A: Why not? Well, for example, stations that bordered Mexico could not be assigned to a channel that would interfere with an existing station on the Mexican side of the border. The second Wrinkle is even easier to accommodate. In our Satisfiability formulation, all we need to do is whenever there's a station V which is forbidden from receiving some channel I, we just omit that decision variable XVI from the formulation.
00:10:54.170 - 00:11:23.942, Speaker A: So there's no opportunity to assign that station the channel I, and that's it. The fact that it was so easy to tweak our basic Satisfability formulation of the graph coloring problem to accommodate these quirky side constraints that showed up in this particular application, that's actually illustrating what's sort of a general principle not always true, but often true, which is that often semirelible magic boxes like MIP and Satsolvers. They can be more flexible than an algorithm which is designed specifically for the particular problem at hand.
00:11:23.942 - 00:12:07.398, Speaker A: It's often easy to sort of tweak a MIP or Sat formulation to accommodate side constraints as we've done here, whereas sometimes adding side constraints can kind of really screw up a problem specific algorithm and force you to go back to the drawing board and sort of think again about how to design the algorithm. At this point, I've told you everything you need to know about the definition of the feasibility checking problem, which really did have to be solved by the FCC incentive auction. It's almost a graph coloring problem, but not quite because of the side constraints that we mentioned on the previous slide.
00:12:07.398 - 00:12:44.580, Speaker A: So let's give this feasibility checking problem its own name, the repacking problem. So something we mentioned back when we were discussing tuning those station specific multipliers those betas of V's, using representative instances, we discussed how actually a lot of aspects of the repacking problem were known in advance. So, for example, known in advance is all the possible television stations that you might have to be dealing with.
00:12:44.580 - 00:13:06.344, Speaker A: That's a few thousand. For each of those stations, you know exactly which of the 23 channels that station can be assigned to, what it's eligible for. And furthermore, because of this list of pairwise interference constraints that this other team developed, you also know in advance, for each pair of stations u and V, exactly which pairs of channel assignments they're allowed to receive.
00:13:06.344 - 00:13:22.288, Speaker A: So, for example, maybe they could receive any pair of channels as long as the two channels were separated by at least one channel in between. All that stuff is known in advance. So I encourage you to think of that as just really being baked into the algorithm rather than part of the input per se.
00:13:22.288 - 00:13:45.572, Speaker A: But something you don't know in advance is exactly what is the sequence of repacking instances that are going to show up as you do your single pass over the stations in the FCC greedy algorithm. Because the set of stations that you're checking the feasibility for, that's going to depend on what happened in all of your previous feasibility checking problems. So that's really an input to the problem in the sense that we've meant all throughout this video playlist.
00:13:45.572 - 00:14:16.496, Speaker A: In real time, the algorithm is going to be given a subset of stations and is responsible for figuring out if it can be repacked or not. Given a set of stations in real time, what the algorithm has to do is figure out whether they can all be on the air at the same time. That is, is it possible to assign each one a channel and the channel it's assigned should be one of the ones it's eligible for? So a channel in the set capital C sub V, so that all of the pairwise constraints are respected, so that for every pair of stations U and V.
00:14:16.496 - 00:14:39.172, Speaker A: Their pair of channel assignments is one of the permitted ones, one of the ones in capital P sub UV. If there is such an assignment, if the stations can indeed all be repacked without interference using K channels, then the algorithm's responsibility is to return an assignment with that property. If there isn't, then the algorithm's responsibility is to correctly report that the set of stations is unpackable.
00:14:39.172 - 00:14:57.964, Speaker A: That is, there's no way to put them all on the air without interference. This repacking problem is exactly what the FCC greedy algorithm is responsible for solving in each of its loop iterations. So how are we going to do it? Well, as we've seen, we can formulate it as Satisfiability.
00:14:57.964 - 00:15:28.980, Speaker A: And whenever you have a feasibility checking question like this one that naturally is encoded as Satisfiability, you should try throwing the latest and greatest sad solvers at it and see how they do. All right, so how big are the problem instances? Well, again, we're talking about thousands of stations, tens of thousands of interference constraints. And given that we have 23 channels, after you go through that Satisfability formulation that we just talked about, we're talking about Sat instances that have tens of thousands of decision variables and over a million constraints.
00:15:28.980 - 00:15:35.632, Speaker A: So that's pretty big. That's a pretty big instance of Satisfiability. Tens of thousands of decision variables, over a million constraints.
00:15:35.632 - 00:15:49.376, Speaker A: Still, if nothing else, just to sort of draw a line in the sand to calibrate yourself, you could throw the latest and greatest Sat solvers at them and see how they do. And they did pretty well. Still pretty impressive given how big the Sat instances were.
00:15:49.376 - 00:16:06.592, Speaker A: But pretty frequently, the off the self solvers from the latest Sat competition needed ten minutes or more to solve the representative repacking instances. And that actually wasn't good enough for the FCC. The FCC had some very ambitious algorithmic aspirations.
00:16:06.592 - 00:16:42.210, Speaker A: They wanted to solve the repacking problem not in ten minutes or more, but in 1 minute or less, which again, is pretty crazy when you have tens of thousands of variables and over a million constraints. So one of the reasons why they didn't have much time to solve a repacking problem, you've already seen, which is that you're not just solving a repacking problem once, and that FCC greedy algorithm, you're solving one in each iteration. And there were thousands of iterations we'll see in the next video, when we talk about implementing the FCC greedy algorithm as a descending clock auction, we'll see that actually, the real number of instances of repacking that had to be solved was more like 100,000.
00:16:42.210 - 00:16:56.710, Speaker A: So that's why the time budget that the FCC was willing to grant was so small. That also partially explains why the auction took so long to run. It took many months to complete because you had to solve 100,000 repacking instances along the way.
00:16:56.710 - 00:17:17.230, Speaker A: So how do we close this gap between how far we've gotten and what we need? Between the ten plus minutes that the latest and greatest off the shelf sat solvers need to solve these problems and the 1 minute that we're shooting for? Well, to do better, we're going to have to throw the kitchen sink at the problem. That's coming up next.
