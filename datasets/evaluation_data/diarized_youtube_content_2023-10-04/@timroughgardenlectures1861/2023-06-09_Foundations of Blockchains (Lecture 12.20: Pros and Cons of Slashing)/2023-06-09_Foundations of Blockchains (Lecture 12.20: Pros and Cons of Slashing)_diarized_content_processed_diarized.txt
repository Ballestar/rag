00:00:00.170 - 00:00:13.374, Speaker A: So with this video we're going to start on part four of lecture Twelve. And I'm sure some of you will breathe a sigh of relief when I tell you that this is not going to be as technical as parts two and three. You've made it part you've made it past the really hard part of lecture Twelve.
00:00:13.374 - 00:00:32.230, Speaker A: Here in part four. There are several topics I want to cover slashing in this video, long range attacks in the next two videos, and a careful comparison of proof of work and proof of stake in the two videos after that. And there is a lot of actual content here, there's a lot of stuff to discuss, but again, not quite as technical as the last couple of parts.
00:00:32.230 - 00:00:49.994, Speaker A: Now slashing, we actually talked a little bit about all the way back in part one, if you remember that video, about sort of why proof of stake, where we talked about three of the main potential advantages of using proof of stake rather than proof of work. And slashing was one of those. Back in part one, we didn't know that much about how proof of stake blockchain protocols worked.
00:00:49.994 - 00:01:09.490, Speaker A: So there's only so much we could say about how slashing would work and sort of the challenges that come up when you try to implement it. Now that we've made it through all of the last batch of videos and we know a lot more about how proof of stake blockchain protocols typically work, we can now discuss slashing in a very concrete way. We've mentioned the high level idea of slashing several times in the past.
00:01:09.490 - 00:01:52.830, Speaker A: Basically, if there are validators that the protocol notices is deviating from intended behavior, then the protocol surgically confiscates the stake or part of the stake of those deviating validators. So to pull this off, we're going to assume that the proof of stake protocol has two properties. So first of all, you remember when we talked about staking mechanics, one of the sort of design parameters there was do you have a warm up and or a cooldown period for staking? So is there a period of time after and before active validation where the protocol still has control of your stake? And for slashing you really want some kind of cooldown period so that you have time to notice if a node has done something wrong and meanwhile you still have control of its stake or in a position to slash.
00:01:52.830 - 00:02:27.190, Speaker A: And second, we're going to assume, as we kind of have all along and is true for all of the deployed proof of stake protocols, that the stakes in the staking contract are denominated in the protocol's native currency rather than some external currency. So remember, a blockchain protocol's native currency is exactly the currency that's in a position to create and destroy and that's what it's doing here. You could in principle imagine a proof of stake protocol where the staking was denominated in some external currency like a virtual representation of a US dollar held in a bank somewhere.
00:02:27.190 - 00:02:40.320, Speaker A: But if you think about it, the protocol is only in a position to destroy the virtual representation on its own chain. It's not in a position to actually reach out and destroy the US dollar that lives in a bank somewhere. So it's really not the same thing.
00:02:40.320 - 00:02:56.542, Speaker A: We're going to talk about two very different approaches to slashing. First, let's talk about kind of like the very ad hoc approach which is really just doing it manually through something known as a hard fork. So we talked a bit about hard forks back in that video about sort of why proof of stake.
00:02:56.542 - 00:03:22.510, Speaker A: And basically you can think of it as like a reboot of the protocol with some upgraded version of the protocol that potentially has new rules. Now, any kind of hard fork, whether it's for slashing purposes or any other reason, can be quite difficult to pull off. You really have to somehow using out of protocol means convince all of the validators that are running the protocol to switch to the new version of the protocol software, the new version of the protocol's rules.
00:03:22.510 - 00:03:41.060, Speaker A: So in practice, this generally requires sort of a large scale coordination building consensus among the various stakeholders in the protocol and in particular the nodes that are running it. And here when I say consensus, I don't mean it in the sense of a consensus protocol like dole of strong. I mean it in the more colloquial kind of social sense of the word.
00:03:41.060 - 00:03:50.582, Speaker A: So hard forks are never that easy to pull off. That said, they have been pulled off numerous times by major blockchain protocols over the years. So it's definitely something that can happen.
00:03:50.582 - 00:04:06.650, Speaker A: And now when you have a hard fork, you can basically change the protocol's rules in arbitrary ways. So to implement slashing, you can in effect add extra rules which say, by the way, what you would think would be the funds associated with these particular accounts. These are the accounts of the misbehaving validators you want to slash.
00:04:06.650 - 00:04:15.870, Speaker A: Actually, the new rule is that currency doesn't count. So that currency has kind of been taken out of circulation. Anytime they try to spend it, you just ignore those transactions.
00:04:15.870 - 00:04:29.166, Speaker A: So a couple of comments about this. So first of all, we think of the slashing as being done to the bad guys, which hopefully means kind of validators, where there's some smoking gun that they are trying to mess up the protocol. The hope would be those are the only kinds of slashing events.
00:04:29.166 - 00:04:48.230, Speaker A: You're going to be able to build this large scale scale consensus around to actually pull off the hard fork. But that's no guarantee, right? So if there's a culture of hard forks to slash stakes, you could sort of imagine maybe that same procedure being used for any number of different reasons. So it's definitely kind of an avenue that can be abused.
00:04:48.230 - 00:05:12.510, Speaker A: So this type of slashing through a hard fork, it should really be thought of as sort of a last resort, a sort of nuclear option, something which hopefully you actually never have to do. And if you do have to do it, you have to do it very infrequently. The second comment is that even this kind of very ad hoc form of slashing accomplishes something you really just could not do in a proof of work protocol, something like Nakamoto Consensus.
00:05:12.510 - 00:05:29.926, Speaker A: The reason a proof of stake protocol is in a position to confiscate funds is exactly because that protocol controls those funds. In a proof of work protocol, you would like to surgically take away asics, take away hash rates from anybody who's trying to manipulate the protocol. But obviously the protocol is not in a position to do that.
00:05:29.926 - 00:05:49.530, Speaker A: The asics are external to the protocol. It can't just magically reach out and sort of confiscate those asics. There is kind of a version of this, we talked about this back in part one, a kind of scorched earth version that you could do in a proof of work protocol, which is you could do a hard fork and you could, for example, change the cryptographic hash function.
00:05:49.530 - 00:05:54.960, Speaker A: For example, maybe it used to be shot 256. There's a lot of other options. You could change it to one of those other options.
00:05:54.960 - 00:06:15.700, Speaker A: Now, asics, right, the as stands for application specific. And so asics used for proof of work mining are specific to the particular cryptographic hash function used, which means if you change that cryptographic hash function, all of those asics become useless. So in a sense, you've confiscated people's asics away from them.
00:06:15.700 - 00:06:34.970, Speaker A: The big difference, of course, is that in proof of stake, you can do confiscation surgically. You can take away stake from some participants and not others. Changing the cryptographic hash function, I call it scorched earth because basically it kills everybody's asics, whether they're someone trying to manipulate the protocol or someone who's just been honestly running it for the last decade.
00:06:34.970 - 00:07:09.830, Speaker A: Frankly, it's not even clear that this helps recover from sort of takeovers of a protocol like a 51% attack, right? I mean, if you have an attacker who's sufficiently motivated and well funded that they can capture 51% of the hash rate running a Nakamoto Consensus protocol even when there's already an incumbent pool of lots of hash rate honestly. Running the protocol. Well, once you kind of do the scorched dirt and all the Asics go away, maybe that exact same very motivated and well funded attacker is going to be able to capture 51% of, say, the GPUs that are put to the protocol after all of the Asics become useless.
00:07:09.830 - 00:07:34.114, Speaker A: So that's the first version of slashing, which is basically done through out of protocol coordination. The second version is a very different approach, which is you just do slashing programmatically, so the blockchain protocol will just take care of the slashing on its own. So intuitively we want to design the code of the blockchain protocol so that when it notices some notice sort of deviating, that automatically triggers the confiscation of its stake.
00:07:34.114 - 00:07:55.914, Speaker A: But if you think about it, for this to make sense, actually a couple of tricky things have to be true. So the first prerequisite for this to even make sense is the protocol has to be able to somehow notice that there is a deviation happening. If you think about it, as we've sort of been going through our consensus protocols, we have seen certain types of deviations where there's really just kind of a smoking gun.
00:07:55.914 - 00:08:14.262, Speaker A: There's irrefutable evidence that some node deviated from the intended behavior. For example, when we talked about the tendermint protocol, we talked through why it is sort of provably correct. It has consistency and liveness in the partially synchronous model as long as at least two thirds of the nodes running it are running it correctly.
00:08:14.262 - 00:08:41.486, Speaker A: But what if less than two thirds of the nodes running tendermint are running it honestly? Well, then the protocol is vulnerable to consistency violations. It is possible that at the same block height, like block height number nine, two different blocks will both get finalized. But we also know that the only way that that can happen is it has to be that at least a third of the nodes voted for both of those different height number nine blocks.
00:08:41.486 - 00:08:57.430, Speaker A: And that is something that no honest node will ever do. Right? If you look at the protocol description, an honest node votes exactly once in any voting stage. So at least the third of the nodes that contributed votes to both of the conflicting blocks, they are then provably deviating from the protocol.
00:08:57.430 - 00:09:13.174, Speaker A: So that's an example of a detectable deviation in a BFT type protocol. If you ever contribute votes for two different blocks, and remember, you have to sign all of your votes, those two signatures for two different blocks of the same block height, that's evidence. That's irrefutable evidence that you deviated from the protocol.
00:09:13.174 - 00:09:43.830, Speaker A: So what about a longest chain consensus protocol? Well, there remember, we proceed in rounds and each round has a leader and the leader is the one who proposes a block. And in longest chain consensus, if you're honest, if you're following the protocol correctly, you are going to be proposing only one block for a given round in which your leader. So if anyone can find two blocks that you proposed in the same round, and again, remember you're responsible for signing what the blocks were, then that again is irrefutable evidence that you deviated from the protocol.
00:09:43.830 - 00:09:56.806, Speaker A: Right in here. By different blocks I could mean either different blocks with the same predecessor in different transactions or I could mean different blocks with different predecessors. I guess I should clarify when I'm talking about longest chain consensus here, I'm talking about the proof of stake version.
00:09:56.806 - 00:10:03.930, Speaker A: You'll remember back in Nakamoto Consensus as a leader. You simply couldn't deviate in this way. You simply could not just by the way that the proof of work works.
00:10:03.930 - 00:10:19.966, Speaker A: You could not actually propose more than one block in the same round. But with proof of stake protocols, as we saw in the last few videos, you can and in particular we had like that nothing at stake problem where a leader proposes blocks kind of all over the blockchain. Here we see that that's a detectable deviation.
00:10:19.966 - 00:10:34.706, Speaker A: There'd be two different blocks signed by the same person corresponding to the same lottery ticket. So those are two deviations where the deviator really does not have any plausible deniability. Okay? Maybe you were sort of accidentally running a sort of buggy version of the software.
00:10:34.706 - 00:10:46.358, Speaker A: That'd be sort of too bad for you. But if you put that aside, the only reason that this evidence would exist is if you did in fact deviate from the protocol. So the third example I want to talk about is actually a little bit trickier.
00:10:46.358 - 00:11:09.220, Speaker A: It's actually a sort of more aggressive form of slashing, which therefore carries other risks, right? So in our first example, talking about tendermint, we focused on a failure of consistency. That's not the only way a consensus protocol can fail, right? It can also fail liveness. So one idea would be to try to sort of detect if nodes are deliberately messing with the protocol's liveness property.
00:11:09.220 - 00:11:32.810, Speaker A: How would it be doing that? Well, there's sort of various ways, but for example, you could withhold block proposals whenever it's your responsibility to do it. You can also withhold votes in a BFT type protocol when it's your responsibility to cast one. Now, is this a type of deviation that a blockchain protocol is in a position to detect automatically? And the answer to that question is a little unclear.
00:11:32.810 - 00:12:05.822, Speaker A: So first of all, in order to detect such a deviation, presumably the protocol would have to know who it was, meaning what public key was supposed to be proposing a block or was supposed to be voting in a round of tendermit. So whether or not the protocol can do that is going to depend on how the block proposer and voters are chosen. For example, if you're using verifiable random functions, which is sort of the main technique that we've sort of used as a case study in parts two and parts three of this lecture, the whole point of the VRF based sampling method is secrecy.
00:12:05.822 - 00:12:27.190, Speaker A: It's that nobody knows who's a winner, who's a block proposer, who's on a committee until that person chooses to disclose that fact. So if you're using this specific style of VRF based sampling, then this deviation is not detectable, at least not if you implement the protocol in the obvious way. Right? There's always plausible deniability.
00:12:27.190 - 00:12:36.846, Speaker A: Maybe the reason I didn't propose a block, it's not because I'm Byzantine. It's because I wasn't actually a leader. It's because my credential was not sufficiently small you can imagine trying to get around this.
00:12:36.846 - 00:13:00.230, Speaker A: Like maybe every single node has to report their credentials so that you could actually verify that they're not supposed to be proposing a block or that they're not on the committee. But then you're back to what we're trying to get away from with ERF based random sampling, which was having all of the validators sort of contribute to every single part of the protocol. So high level just really not a good combination with the VRF based sampling that we talked about in the last couple of parts of this lecture.
00:13:00.230 - 00:13:16.826, Speaker A: So there are proof of stake protocols that do slash based on these types of deviations. In fact, proof of stake ethereum does so. So needless to say, in those protocols there is some advanced predictability of who's to both be proposing blocks, who's Tobos will be voting and so on.
00:13:16.826 - 00:13:38.610, Speaker A: That's sort of a necessary condition for implementing slashing on this type of deviation in a sort of practical way. So specifically in proof of stake ethereum, the phrase used for this types of slashing is an inactivity leak. So basically, if the blockchain protocol sort of stalls and stops finalizing new blocks, then validators are going to start losing some of their stake for that lack of progress.
00:13:38.610 - 00:14:13.370, Speaker A: The second complication, and this is why I referred to this as a more aggressive form of slashing, is that actually nodes kind of do have plausible deniability with these kinds of violations, right? Because they could just say, look, I'm not a Byzantine node, don't slash me. It's the network that's Byzantine, right? Like imagine we're in the partially synchronous model, we're before global stabilization time and this node's messages just got delayed so long that the protocol assumed that it never broadcasted them in the first place. And the problems don't stop there, right? Imagine say, a proof of stake BFD type protocol.
00:14:13.370 - 00:14:37.794, Speaker A: So this is going to be one where you're probably going to be proposing, you're responsible for proposing blocks only fairly infrequently, but you might be responsible for voting quite frequently. And imagine it's a protocol where in an effort to deter these types of attacks against liveness slashes validators that are not voting when they're supposed to be voting. So for the protocol to be in a position to do that, somehow these votes must be recorded on chain.
00:14:37.794 - 00:14:53.798, Speaker A: They must be recorded along with, for example, transactions and added to the running blockchain state. Well, so you're voting pretty frequently. Who is it who's in a position to record your votes so that the blockchain protocol can see it? Well, that's the other validators.
00:14:53.798 - 00:15:17.454, Speaker A: So if the other validators choose to produce blocks but deliberately exclude your votes, well, then again, you might wind up triggering this slashing condition and losing some of your stake despite the fact you really were honestly following the protocol. So that's why I call this a trickier example. Unlike the first two examples, there really is not irrefutable evidence that a node deliberately misbehaved.
00:15:17.454 - 00:15:50.010, Speaker A: There are alternative explanations consistent with honest behavior, right? Either problems with the network or problems with the other validators. So for that reason, a lot of proof of stake blockchain protocols, even ones that do use slashing, will stop short of slashing these kinds of apparent violations just because you can't really be sure that it's not an honest validator that you're slashing. Interestingly, proof of stake ethereum actually does slash for missing block proposals and votes that you're supposed to be casting.
00:15:50.010 - 00:16:19.400, Speaker A: So as far as the problem with network outages, ethereum in effect, know, that's your problem, right? Basically, if you're going to be a validator, make sure you have good enough and robust enough network connectivity that you can get your block proposals and your votes in on time. The censoring validators problem, that's a more serious problem, right? So validator is not in a position to stop other validators from censoring it. So there the ethereum protocol actually has some additional complexity, additional logic and incentives to deter validators from censoring each other in this way.
00:16:19.400 - 00:16:55.306, Speaker A: All right, so that whole discussion actually already illustrates what's going to be requirement number two, which is not only must it be that deviations are detectable in principle, but it must also be there's sufficient information recorded on chain, recorded alongside all of the transactions that enables the protocol to notice that there's been a violation. So think, for example, about some newly arriving validator, right? So think about a proof of stake blockchain protocol that's been humming along for like seven years, but it's permissionless, so anybody can join at any time. So some new node wants to sort of become a validator.
00:16:55.306 - 00:17:07.986, Speaker A: It doesn't want to trust anybody. So what it's going to do? It's going to go back to Genesis and replay the seven years of stuff that's happened over the course of the protocol's existence. It's going to do that so it can correctly compute the current state.
00:17:07.986 - 00:17:24.620, Speaker A: Now, the current state includes in particular balances for everybody who has an account in that protocol. And so in particular, you need to know whether people got slashed, right? So you need to know not just kind of who transferred money to whom and all that kind of stuff. You need to know whether the protocol took away some stuff from anybody as well.
00:17:24.620 - 00:18:01.430, Speaker A: So for our first two examples of detectable deviations, hopefully it's at least conceptually pretty clear what should be recorded sort of on chain for the rest of time so that later nodes can figure out what the violations were and who got slashed. If you're talking about tendermint, for example, and somebody voting for two different blocks in the same voting stage, then somehow on chain you want to sort of record both of those signed votes, signatures corresponding to the exact same public key. In the case of longest chain consensus, you again want to record sort of the two signatures both by the same leader proposing two different blocks in the same round.
00:18:01.430 - 00:18:16.262, Speaker A: For the third trickier example, it's actually not going to be the presence of something as part of the blockchain state that tells a sort of newly arriving node about slashing events. It's going to be the absence of information recorded on chain. It'll be missing block proposals and missing votes.
00:18:16.262 - 00:18:41.010, Speaker A: And again, this is only going to make sense if you're not doing something like our VRF based sampling approach from parts two and three, but you're doing instead a way of sampling where you know at the time who it is who's supposed to be proposing a block, who's supposed to be voting. So those are two requirements you need for this programmatic slashing to even make sense. So first of all, you should be thinking about a deviation which at least is detectable in principle.
00:18:41.010 - 00:19:07.770, Speaker A: And then secondly, you need to have sufficient evidence on chain either explicitly or implicitly so that it's detectable not just in principle, but detectable automatically by the protocol itself. All right, so I've told you about two different approaches to slashing doing it in an ad hoc way, just kind of through hard forks or doing it programmatically, meaning the protocol does it automatically itself. Which is better? Really depends who you ask.
00:19:07.770 - 00:19:28.674, Speaker A: This is very much an ongoing debate, speaking now in early 2023 about whether proof of stake blockchain protocols should or should not use programmatic slashing. Different major proof of stake blockchain protocols have just approached this question in different ways. Ethereum famously has always had slashing as part of their vision of what a proof of stake blockchain protocol should look like.
00:19:28.674 - 00:19:53.926, Speaker A: That was true many, many years before they actually switched over and launched a proof of stake blockchain protocol. But actually a majority of the other major proof of stake blockchain protocols actually do not use in protocol slashing. Now, most of those protocols do still use incentives to try to get nodes to follow the protocol correctly, generally in the form of staking rewards which are granted only if you appear to have followed the protocol correctly.
00:19:53.926 - 00:20:10.154, Speaker A: So for example, if you went offline for a long time in one of these proof of stake blockchain protocols, you'll typically forego the staking reward you would have otherwise received. So as usual, I'm not really interested in taking sides here. I really just want to hopefully clarify the different points of discussion.
00:20:10.154 - 00:20:21.410, Speaker A: So in other words, I think it's reasonable people have decided that in protocol slashing is worth it. I want to tell you their arguments. I think other also reasonable people have decided in protocol slashing is not worth it.
00:20:21.410 - 00:20:47.526, Speaker A: And so I want to tell you their counterarguments as well. So let's start with the main arguments by the proponents from slashing. Now, to be clear here, I'm speaking about the benefits of in protocol slashing above and beyond just the generic benefits of any proof of stake protocol right? Any proof of stake protocol using version one or version two, either hard fork or programmatic slashing, you can do something you can't do with a proof of work blockchain protocol.
00:20:47.526 - 00:21:26.726, Speaker A: You can surgically target who you want to punish economically. So the question here is just about between proof of stake protocols that use version one and now let's talk about the benefits of proof of stake protocols that use version two. So the first typical argument would go if you're trying to incentivize nodes like validators to correctly run your protocol, why restrict yourself to a carrot? Why not use a stick also? So if you're already kind of giving rewards, maybe even printing money to do so, why not also use the part of the design space where you take it away as well? So by carrot here I mean rewards that the protocol doles out to validators running it.
00:21:26.726 - 00:21:39.450, Speaker A: And here stick, I mean the slashing, right? And the carrots have been there kind of forever. They've been there since the bitcoin protocol and its block rewards. But it's really kind of proof of stake that enables you to have the option of this stick.
00:21:39.450 - 00:22:06.510, Speaker A: So thus far when we talk about sort of the benefits of the stick, we've mostly actually been focusing on kind of the extreme case of like a bad actor. It's some malicious actor who's wellfunded and wants to mess with the protocol, you know, like cause a consistency violation in order to execute a double spend. And as we discussed, right, the stick gives a strong economic deterrent from trying to mount such an attack, right? Mounting such an attack requires, for example, a lot of double voting in a BFT type protocol which would result in the slashing of a whole bunch of stake.
00:22:06.510 - 00:22:39.994, Speaker A: There's also a second kind of more mild effect, but which I still think is potentially practically quite useful, which concerns validators that are not malicious but maybe prone to being a little bit lazy and having a stick, even maybe a small stick might be able to motivate a typical node operator to just sort of do a better job at it. So for example, if you're trying to upgrade the protocol so you make some improvements, some new features, you want all of the nodes running the protocol to switch to the new version of it already with the staking rewards. There's some incentive to do that so that you keep getting your staking rewards.
00:22:39.994 - 00:23:09.078, Speaker A: But somehow if you don't upgrade, if your stake actually starts getting slowly drained over time, then you're probably really motivated sort of to keep up with the times and make sure you're running the latest and greatest version of the protocol. A second benefit of programmatic slashing is that if you do suffer an attack so suppose you're in a BFT type protocol and someone does actually double spend and cause a consistency violation. It's not just that they experience a strong economic cost because stake is taken away from them.
00:23:09.078 - 00:23:37.230, Speaker A: But also because of the reduced stake and the new distribution of the relative stake, you actually have the potential to just recover automatically in protocol from a 51% style attack. So for example, if you imagine an attacker in a BFT type protocol who controls 34% of the stake and then carries out a double spend forces a consistency violation, well then all of that attacker's stake is going to get slashed. And now all of a sudden it has 0% of the stake.
00:23:37.230 - 00:24:00.620, Speaker A: So if it wants to double spend again in the future, it needs to sort of reacquire 34% of the remaining stake in order to carry out that second attack. And importantly, this recovery would just, it would not involve anything external to the protocol. It would be much different than the kind of messy process of trying to sort of coordinate all of the nodes running the protocol to pull off a hard fork for example.
00:24:00.620 - 00:24:17.914, Speaker A: So that should all sound pretty cool. So you might be wondering why doesn't just every proof of stake blockchain protocol use programmatic slashing? So let's talk about some of the counterarguments that people make. So the first three drawbacks I'm going to mention, I think they're not really up for debate.
00:24:17.914 - 00:24:43.778, Speaker A: I think everybody would agree that programmatic slashing does have these sort of three issues with it definitely going to be debate over how important those issues are, but I think the fact that they exist relatively uncontroversial. First one is just that programmatic slashing means a more complex blockchain protocol. So for example, to have programmatic slashing you need evidence of misbehavior recorded on chain.
00:24:43.778 - 00:25:11.760, Speaker A: So you need some kind of logic by which validators can include that evidence pointing out that other validators have misbehaved. And then also the protocol has to be in a position to actually verify that that evidence is in fact what it's purported to be as opposed to just framing some other validator in order to get it slashed. And then kind of an automatic consequence of additional protocol complexity is you kind of inevitably wind up picking up some additional attack vectors that you have to think about.
00:25:11.760 - 00:25:40.774, Speaker A: So a good example here came up in our discussion on the left, lower left part of the slide when we're talking about that third sort of trickier example of an offense, sort of a liveness violation that you might want to try to slash. And so that would presumably involve somehow recording votes on chain and sort of slashing validators that haven't contributed votes when they were responsible for doing so. And as discussed there, that gave rise to an additional attack vector.
00:25:40.774 - 00:25:59.680, Speaker A: All of a sudden validators were in a position to punish other validators by deliberately refusing to include other validators votes in the blocks that they're adding to the blockchain. And as we discussed, the Ethereum protocol has to have some additional logic to deter validators from doing censoring in this. Way.
00:25:59.680 - 00:26:25.560, Speaker A: The third point you hear about a lot. And rightly so. I think it is a quite important point, which is no matter how careful you are with your slashing conditions, if there are conditions under which you slash someone for what you think is misbehavior in practice, it just seems like there's inevitably, reasonable people might I don't want to say through no fault of their own, but certainly through no malice, might wind up triggering those conditions as well.
00:26:25.560 - 00:26:38.826, Speaker A: And you can imagine a number of reasons why this might happen. I mean, one particularly tricky one came up when we in our discussion in the lower left part of the slide, when we talked about trying to slash for sort of missing votes or missing block proposals. We discussed there.
00:26:38.826 - 00:27:00.130, Speaker A: That even a perfectly honest node, which is literally just trying to do the best it can. If it has a severe enough network outage, it's going to wind up getting slashed for inactivity, for missing votes. And even if it's trying to do the right thing, if other Validators choose to keep its votes off, if it refuses to include its votes in the blocks that they're creating, again, this honest Validator is going to wind up getting slashed.
00:27:00.130 - 00:27:18.770, Speaker A: Now, one response there would be, yeah, okay, but that's only if you choose to do this more aggressive kind of programmatic slashing where you don't have this irrefutable evidence. Like in the third of our three examples. In the first two examples, you might say there there's a smoking gun, right? Someone literally just signed two different blocks at the same block height, for example, or in the same round.
00:27:18.770 - 00:27:34.460, Speaker A: Clearly they could never have done that were they a well intended Validator. But again, in practice, this isn't quite true. And indeed, even in proof of stake ethereum, there have been examples of Validators getting slashed despite really trying to do the right thing.
00:27:34.460 - 00:27:57.970, Speaker A: Sort of the short version of the story there is because ethereum punishes you for inactivity and so if your computer goes down, you're going to lose some of your stake. That's a natural motivation to sort of replicate, to run not just one machine, but sort of two machines so the second one can take over if the first one fails. But if you don't do that carefully, it can be that both of those machines wind up signing different blocks with the same key.
00:27:57.970 - 00:28:28.286, Speaker A: Don't get me wrong, there's ways to sort of set up two machines so that that doesn't happen. But one straightforward way of implementing this idea actually led two people signing different blocks at the same sort of round with the same public key, which then, even though they were just trying to not have the inactivity slashing, they wound up suffering the double vote slashing instead. Now, again, a potential response here would be, look, incompetent validators are not our problem, right? Even if you're well intended, if you can't actually execute well then that's on you.
00:28:28.286 - 00:28:38.062, Speaker A: I think that's a reasonable position. I don't think it's the only reasonable position. Let me conclude with two more points to add to the counterarguments pile.
00:28:38.062 - 00:28:51.346, Speaker A: And unlike the first three, these two points, it's not actually clear these two points are true. It's something you hear a lot by people who argue against programmatic slashing and maybe they're true, but I think it's less obviously true than the first three. So the two points are related.
00:28:51.346 - 00:29:16.250, Speaker A: So the first point thinks about sort of day to day operations of the blockchain protocol. And the second point thinks about exceptional situations. And sort of the viewpoint here is that, look, if you have a healthy proof of stake blockchain protocol, like it's well designed and the native currency actually has meaningful economic value outside of the protocol, you're not really expecting consistency violations like double spend attacks as a daily occurrence.
00:29:16.250 - 00:29:41.080, Speaker A: And so the idea there is that maybe for day to day operation under normal conditions, rewards should be enough and the stick penalties would be overkill because again, remember, I mean, pretty much all the proof of stake blockchain protocols have staking rewards. And if you misbehave like you go offline for too long, you will be foregoing your staking rewards. So there's certainly still even without programmatic slashing incentives to do the right thing.
00:29:41.080 - 00:30:17.890, Speaker A: But here the natural counterargument would be like, okay, fine, but if you can pull off a double spend for a sufficiently valuable transaction, that's a huge benefit to the attacker. And if the only result is that you sort of forego some staking rewards for some period, that might not be enough economic cost to actually outweigh the benefits you got from carrying out the attack. So the counterargument there would be if attacks can be sufficiently valuable, then just withheld staking rewards is insufficient and you really would want some punishment above and beyond just the opportunity cost of otherwise getting staking rewards.
00:30:17.890 - 00:30:39.278, Speaker A: So the other related point is that if you think of rewards as being sufficient for day to day operations, okay, maybe you're going to have these exceptional circumstances where some super well funded and motivated attacker gets like 34% of the stake and actually enacts a double spend. But the thinking is that that should be so rare. Just handle that using version number one of slashing.
00:30:39.278 - 00:31:09.842, Speaker A: Handle that using kind of this ad hoc coordination reboot process. I mean, in some sense you can even kind of think of the version number one of slashing as more general than version number two. Assuming of course you can solve this kind of tricky large scale coordination problem to kind of pull off the reboot in a new state, right? Because in protocol slashing version number two, that's like an opera commitment to exactly what is going to be punished and what the punishment is going to be.
00:31:09.842 - 00:31:27.640, Speaker A: And if you're doing version number one, if you're rebooting kind of in a new state. Certainly one option for your new state is to say, let's pretend like we had the specific form of programmatic slashing. Let's look at what this new state would have been and now let's just reboot pretending like that is the new state.
00:31:27.640 - 00:31:49.562, Speaker A: So with social slashing, meaning version number one, you can simulate any programmatic slashing you might have implemented or you can do anything else. Now, obviously this is not something you'd want to be doing every day, right? This is kind of a major reboot of the protocol. The vision is this should be happening maybe once every few years, maybe once every few decades.
00:31:49.562 - 00:32:30.298, Speaker A: And indeed, kind of people who argue against in protocol slashing, they might even say by embracing slashing as sort of being automatic, it's almost like you're envisioning a world where consistency violations or double spend attacks are going to be common. Like all of a sudden that's part of the day to day operations of the protocol that you need to worry about. They might further argue that if it's not an extremely unusual occurrence for someone to capture a healthy portion of the stake, if it's actually easy for someone to capture a lot of the stake, well, then your blockchain protocol actually has sort of much bigger problems, right? So for example, if an attacker can capture 67% of the stake, well, then they can basically take over the protocol and do whatever they want.
00:32:30.298 - 00:32:48.434, Speaker A: You really have no option for in protocol recovery. And at that point, the only option is to have a hard fork and have a different version of the protocol where you've removed the attacker and they're 67% of the stake. So I think that's a reasonable line of argument that should definitely be considered a counterargument to that.
00:32:48.434 - 00:33:20.166, Speaker A: Counterargument would sort of sort of focus on this social slashing process, this kind of large scale consensus, because it's really delicate, it's a little scary if you think about it, just sort of out of protocol, sort of rebooting with some in effect, arbitrary new state. Like the potential for abuse there is high. In particular, you might be worried that either it's super difficult to achieve large scale coordination, in which case you're not actually going to be able to do this recovery by building consensus outside of the protocol or it's going to be much too easy to do that and then it's going to be abused.
00:33:20.166 - 00:33:41.042, Speaker A: It's going to be some kind of rule by mob type situation. So proponents of in protocol slashing might argue that it's just too dangerous to kind of outsource when and whom to slash to this messy kind of large scale coordination process. They would argue much better to just be like super clear up front.
00:33:41.042 - 00:33:57.202, Speaker A: These are the conditions under which slashing happens and this is exactly who gets slashed and by how much. Rather than allowing that to be sort of decided in the heat of the moment by the broader community, again, there's no right answer here. I think these are both reasonable sides of the debate.
00:33:57.202 - 00:34:11.946, Speaker A: So think about it. Think about which side you find yourself agreeing with more. So, as with so many aspects of the blockchain protocol design space, there's an open question here about which is better to do slashing in protocol or not.
00:34:11.946 - 00:34:29.362, Speaker A: It's not clear there's one right answer to that question. I mean, it could be protocols designed for certain purposes should do in protocol slashing those designed for other purposes should not. But at the moment, we really have no guidance about given a protocol and given your sort of intended user base, whether this is, on balance, a good idea or not.
00:34:29.362 - 00:34:48.120, Speaker A: So, again, as with so many other things, it's going to be fascinating as the years roll on, as we get more data about how these different major proof of Stake blockchain protocols function. So we're going to be running the experiment. We have all these competing designs, and over the years to come, we're going to see which ones thrive the most.
00:34:48.120 - 00:35:00.438, Speaker A: So that wraps up everything I wanted to say about Slashing. Next couple of videos are going to be about something called long range attacks. And so this is really an attack vector that's specific to proof of Stake protocols.
00:35:00.438 - 00:35:24.506, Speaker A: It's something you do not have to worry about with proof of work protocols. And that's because it's a consequence of the Costless simulation that we've mentioned a couple of times in proof of Stake protocols, the idea that a node or a validator can very quickly fabricate a long alternative history. Long range attacks is one particular attack vector making use of those long alternative fabricated histories.
00:35:24.506 - 00:35:27.970, Speaker A: So that's what's coming up next. I'll see you there. Bye.
