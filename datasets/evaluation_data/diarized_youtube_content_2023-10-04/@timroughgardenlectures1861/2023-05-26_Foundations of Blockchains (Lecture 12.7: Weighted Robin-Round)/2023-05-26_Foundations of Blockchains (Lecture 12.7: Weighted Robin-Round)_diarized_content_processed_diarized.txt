00:00:00.330 - 00:00:00.526, Speaker A: All right.
00:00:00.548 - 00:00:15.946, Speaker B: So this video begins part two of lecture Twelve. Remember that we concluded part one by really sort of isolating one of the key challenges in the design of proof of stake blockchain protocols, which is that, you know, if you're given a list of active validators right, encoded. In some smart contract.
00:00:15.946 - 00:00:41.802, Speaker B: You're given a list of N public keys, all with the corresponding stake amounts, and you want to randomly sample a public key from that list with probability proportional to stake. That turns out to be a surprisingly tricky problem. And one of the main reasons for that is that in proof of stake protocols, it would seem, unless you're willing to trust some third party to supply randomness because you don't have an external process like mining generating randomness for you.
00:00:41.802 - 00:01:01.390, Speaker B: You have to generate randomness kind of internally just really just based on the blockchain state itself which opens up a new attacked vector by which block producers perhaps could manipulate the blockchain state and thereby manipulate the randomness and thereby manipulate the probability with which different public keys might be selected as a leader.
00:01:02.290 - 00:01:03.486, Speaker A: So what I want to do in.
00:01:03.508 - 00:01:17.970, Speaker B: This opening video of part two is just give you a really quick and dirty solution which roughly approximates sampling from this list proportional to stake. And it is a solution that has been used somewhat successfully in practice, namely weighted round robin.
00:01:28.690 - 00:01:29.850, Speaker A: So the idea is we're going to.
00:01:29.860 - 00:01:48.114, Speaker B: Reframe the problem a little bit. Rather than thinking about sort of sampling from this list just one at a time with probability proportional to stake, let's actually think about just generating a whole batch of samples all at once. So let's think about a procedure and maybe whenever you invoke it, it gives you back a sequence of like 10,000 samples.
00:01:48.114 - 00:02:02.860, Speaker B: So it gives you a list of 10,000 public keys. Each public key in that list is going to be one of PK one PK two up to PKN, so it's going to be one of the active validators. A given active validator may occur many times amongst this sequence of 10,000.
00:02:02.860 - 00:02:25.250, Speaker B: Now, obviously, we want this sequence to reflect the stake amounts to reflect the Q submis. So we're going to ask that the sequence have near proportional representation. So for example, if there's some public key that controls 1% of the overall amount of stake, then that public key should appear roughly 100 times in the list of 10,000 public keys.
00:02:26.390 - 00:02:27.826, Speaker A: So notice if we go back to.
00:02:27.848 - 00:02:52.540, Speaker B: Our original goal of actually randomly sampling a single public key from this list. If you had such a procedure and you invoked it 10,000 times with high probability, you'd get this sort of roughly proportional representation property, right? So if something had a 1% chance of being selected each time and you did 10,000 invocations of the procedure, you would expect it to be the output roughly 100 times plus minus a little bit.
00:02:53.230 - 00:02:55.070, Speaker A: So here we're sort of relaxing the problem.
00:02:55.140 - 00:03:10.530, Speaker B: We're not going to insist that we get IID samples one by one from the state distribution, just batches of public keys that more or less, in some statistical sense, look like what you would have gotten typically if you were doing IID sampling from the stake distribution.
00:03:11.510 - 00:03:13.842, Speaker A: So I'll fill in some more details next.
00:03:13.896 - 00:03:36.886, Speaker B: But let me just say, while this simplistic approach wait around robin, it has some big issues as we'll discuss, this is probably the simplest approach to selecting leaders in a proof of stake blockchain, which is not horribly broken. And indeed, some pretty successful proof of chain blockchains use something very much like this. Typically, their proof of stake protocol has been earlier vintage, maybe you think 2016 to 2018.
00:03:36.886 - 00:03:44.700, Speaker B: Most of the more recent proof of stake blockchains do things that are more sophisticated. But if you need a quick and dirty solution, this is a reasonable starting point.
00:03:45.390 - 00:03:46.718, Speaker A: Now, let me just fill in a.
00:03:46.724 - 00:03:59.318, Speaker B: Little bit more of the details. What do I mean by weighted round, Robin? So we're going to be considering batches of rounds. I'm going to call those epics, and there's going to be some parameter capital N, which controls how many rounds are in an epic.
00:03:59.318 - 00:04:02.020, Speaker B: So that would be like 10,000 in our running example.
00:04:02.870 - 00:04:04.306, Speaker A: And here when I say round, I.
00:04:04.328 - 00:04:20.920, Speaker B: Mean it in the same sense as, for example, in a longest chain consensus protocol, where you have one leader per round proposing a block. Or I mean it in the same sense as like in Tendermint back in lecture number seven, where in each round there's kind of the four stages. The first stage, you have a leader who's proposing a block for everybody else to vote on.
00:04:21.450 - 00:04:23.094, Speaker A: And at the start of each epic.
00:04:23.142 - 00:04:32.010, Speaker B: The protocol somehow specifies a sequence of capital and leaders with roughly proportional representation of all of the public keys of the active validators.
00:04:32.590 - 00:04:34.398, Speaker A: And you can imagine various ways a.
00:04:34.404 - 00:04:43.950, Speaker B: Protocol might derive this sequence from the list of active validators and their stakes. Some approaches are just very simple and deterministic.
00:04:44.690 - 00:04:46.018, Speaker A: So, for example, if you had a.
00:04:46.024 - 00:05:03.250, Speaker B: List of three active validators, A, B and C with stake amounts two, one and two, well, then you could have a leader sequence that really just picks A twice, then picks B once, then picks C twice, and then starts all over again.
00:05:08.050 - 00:05:09.678, Speaker A: Now, if N is a multiple of.
00:05:09.684 - 00:05:26.082, Speaker B: Five, you're going to get perfectly proportional representation, right? Exactly 40% A's, 20% B's, 40% C's. If it's not a multiple of five, you're going to have a little bit of overrepresentation of the A's and a little bit of underrepresentation of the C's. But whatever, it's basically still 40 2040.
00:05:26.082 - 00:05:40.754, Speaker B: As long as N is reasonably large. You can also imagine adding on sort of more bells and whistles. Like you could start with a simple deterministic leader sequence like this one, and then apply some kind of shuffle, some kind of pseudorandomily defined permutation.
00:05:40.754 - 00:05:46.380, Speaker B: So that would move all of the letters around, but it would preserve the proportional representation property.
00:05:47.630 - 00:05:49.386, Speaker A: So I hope that's sufficient detail that.
00:05:49.408 - 00:06:02.990, Speaker B: You now feel like you have a pretty solid grasp on what I mean by weighted round robin and the sense in which that's a sort of solution of sorts to sampling from the stake distribution. So let's talk about the pros and cons of weighted round robin.
00:06:03.490 - 00:06:05.102, Speaker A: The main piece of good news is.
00:06:05.156 - 00:06:20.440, Speaker B: That it is simple. It's going to be relatively simple to implement correctly and debug. You're not going to need to understand or use any fancy cryptography and it's very easy to explain to everybody exactly what the solution is.
00:06:20.440 - 00:06:46.554, Speaker B: On the flip side, probably the biggest issue with weighted round robin and just in general, sort of picking this batch of leaders all at once is basically everybody winds up knowing who the leaders are going to be way in advance. Now, how far in advance is going to depend on how long an epic is just in terms of sort of wall clock time. That's going to depend on the choice of capital N and the frequency with which blocks are created by the protocol.
00:06:46.554 - 00:07:02.420, Speaker B: But you want to think of an epic length, certainly in the minutes and potentially in the hours or even in the days. So that's some fairly healthy advanced notice. If you're curious about who's going to be the leader five minutes from now, typically with this design, everybody's going to know the answer to that question.
00:07:02.420 - 00:07:25.850, Speaker B: Now you might ask is it really such a big deal that leaders are known minutes or even hours in advance? Like, so what? To some extent that's kind of an open question. But there's definitely things you'd be worried about with the identity of leaders being revealed well in advance, in that you'd worry about bad actors trying to somehow influence future leaders.
00:07:26.590 - 00:07:28.362, Speaker A: So for example, think about a bad.
00:07:28.416 - 00:07:42.374, Speaker B: Actor who wants to kind of destroy the liveness of a blockchain protocol. So it wants to make sure that no blocks get published, or if any block does get published, it doesn't have any transactions in it. And now normally we say, okay, well, let's assume that this attacker is sort of bounded.
00:07:42.374 - 00:08:05.206, Speaker B: Like it has less than a third, it controls less than a third of the blocks being produced. And then, yeah, it can sort of produce empty blocks in its share of the slots, but still more than two thirds of the slots are going to have blocks by honest nodes and everything should be good. But here the problem is even if the adversary controls no nodes at all itself, even if it doesn't actually run a validator but it can know in advance who block proposals are going to be in the future.
00:08:05.206 - 00:08:14.790, Speaker B: Well, then maybe it sort of seeks out those block producers. Maybe it threatens them, so it coerces them into sort of missing their turn. Or publishing an empty block.
00:08:14.790 - 00:08:46.266, Speaker B: Maybe the bad actor bribes them, says, hey, I'll pay you an extra $100 if you publish a block without any transactions. Or maybe that bad actor launches a denial of service attack, so just makes sure that the leader is unable to connect to the rest of the network during the round at which they're the leader, which has the effect of them skipping their slot. So a couple comments about the perils of leaders being predictable.
00:08:46.266 - 00:09:08.326, Speaker B: Well, in advance, I've framed it as a bug. Some blockchain protocols actually treat it at least partially as a feature as well to enable sort of better coordination and optimization amongst honest Validators. For example, if you're an honest Validator and you're not the leader, but you've heard about some transactions and you think other people maybe haven't heard about, there's no need to broadcast those transactions to everybody.
00:09:08.326 - 00:09:48.334, Speaker B: You can just forward them to the node that you know will be the next leader that you know will be assembling the next block. A second comment is you could imagine scenarios where maybe these threats aren't so worrisome coercion, bribery and dos attacks, if you think about maybe like a semi permissioned blockchain protocol. So what do I mean by that? Well, so imagine you have a Validator set and maybe you don't trust the Validators per se, but maybe you at least know that the Validators are kind of big entities, well funded, with significant reputations that would be damaged if bad things happened in this protocol.
00:09:48.462 - 00:09:48.706, Speaker A: Right?
00:09:48.728 - 00:10:13.290, Speaker B: Well, so then you could trust them to probably have good defenses against denial service attacks because they're kind of big, sophisticated Validators, and given their reputation at stake, you might hope they would not be that susceptible to kind of bribery or coercion. So in that kind of setting, or actually, you don't think these drawbacks of predictability are that big a deal, you might really just want to use way to drown Robin. It might actually be like a really good solution given its simplicity.
00:10:13.290 - 00:10:38.750, Speaker B: But what about the truly permissionless case? Like, what if we don't want to assume that a Validator has the resources to fend off serious denial of service attacks? Is there some way we can do proof of stake sampling in a different, more sophisticated way so that a leader becomes known only at the moment in time at which it's going to be issuing its block proposal and not in advance?
00:10:45.630 - 00:10:47.466, Speaker A: So answering that question is going to.
00:10:47.488 - 00:10:56.642, Speaker B: Take us on a fun journey. You over the next few videos into randomness of beacons and also verifiable random functions. So that's what's coming up next.
00:10:56.776 - 00:10:58.430, Speaker A: I'll see you there. Bye.
