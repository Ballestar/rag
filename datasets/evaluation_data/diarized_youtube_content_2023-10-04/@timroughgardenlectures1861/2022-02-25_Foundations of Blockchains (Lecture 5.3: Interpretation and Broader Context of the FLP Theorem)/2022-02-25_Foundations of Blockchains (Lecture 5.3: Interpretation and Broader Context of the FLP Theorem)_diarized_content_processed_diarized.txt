00:00:00.570 - 00:00:47.366, Speaker A: So congratulations. You've survived the really not very easy proof of the famous FLP impossibility results. And again, this puts you in fairly rarefied company. Not that many people outside of distributed computing experts have really studied these proofs. And now you have. So let me wrap up this lecture, lecture five, just by making a couple comments about that theorem, the FLP impossibility result and how to interpret it, and then also some reflections, I'd say, overall on lectures two through five before we sort of move on to sort of the partially synchronous model in the next lecture and trying to conquer other mountaintops. So first, let me reiterate something I've said a couple of times already, which is that the point of an impossibility result like this, it's not to discourage anybody from trying to come up with really cool consensus protocols or really cool blockchain protocols.
00:00:47.366 - 00:01:25.666, Speaker A: That's not the point at all. Rather, this impossibility result educates. It tells you that you can't necessarily have every single thing that you want out of your protocol. You have to make choices, you have to make compromises. Now this FLP impossibility result, it actually tells us something extremely fundamental, a super important trade off that you must make if you're going to design a blockchain or other type of consensus protocol. So specifically, while the FLP result, I mean, it's stated for byzantine agreement the single shot consensus problem. But if you think about it, I mean, it also implies impossibility of multi shot consensus.
00:01:25.666 - 00:02:25.734, Speaker A: So if you think about the state machine replication problem, the SMR problem, where we wanted to sort of have a bunch of nodes and keep them in sync, meaning they always have identical local histories, that's consistency. But we also wanted liveness that when there are transactions that can be added, eventually they should be added. So the FLP impossibility result says in the Asynchronous model, we cannot accomplish state machine replication with both consistency and liveness. One of them must be given up. And in fact, if you wanted to put together a taxonomy of the major layer one blockchain protocols today, really a top order node in classifying different blockchain protocols would be in the presence of asynchrony. Do they compromise on consistency or do they compromise on liveness longest chain protocols, so called Nakamoto Consensus, like Bitcoin and Ethereum, they when there's asynchrony actually favor liveness over consistency. They may lose consistency if you have very long message delays.
00:02:25.734 - 00:03:26.382, Speaker A: Many other blockchain protocols, most of the newer generation layer ones make the opposite trade off, favoring safety, favoring consistency over liveness. And so without the background provided by these lectures, you might look over the landscape of layer one blockchain protocols and be like, why doesn't some smart person just sort of put together a protocol that rules them all? That even in the presence of Asynchrony, enjoys both consistency and liveness? And the FLP result tells us, no, it's not that no one's been smart enough yet. It's not that. We just need to wait a few more years and there'll be some innovation where we get everything we want. Fundamentally, no matter what technical advances happen over the hundreds of years to come, there will never be a consensus protocol guaranteed to satisfy both consistency and liveness in the Asynchronous setting. You must give up on one of them. A second reason impossibility results like this are super important is they clarify which assumptions matter.
00:03:26.382 - 00:04:29.854, Speaker A: So in lectures two and three, we learned that in some cases, the public key infrastructure, or PKI assumption really matters. What you can accomplish, at least in the synchronous model, is fundamentally different. Consensus protocols are fundamentally more powerful if you can pull off the trusted setup assumption with common knowledge public keys. So the takeaway from those two lectures was that cryptography matters for consensus and trusted setups matter for consensus. Here in lectures four and five, what we've learned is that network reliability really matters for consensus. And there's things you can accomplish when you have guaranteed message delivery bounds on the maximum message delay that you fundamentally cannot achieve if you don't make that assumption, if you have sort of unbounded message delays. So my next point will sort of lead directly into what we'll discuss in lecture six, the partially synchronous model, which is that impossibility results like FLP impossibility, they really guide us toward sort of the right, sweet spot model for reasoning about things like consensus protocols.
00:04:29.854 - 00:05:16.894, Speaker A: They guide us to definitions that we would not come up with were it not for the impossibility result. Now, toward the beginning of lecture six, I'm going to write down a formal definition of this partially synchronous model. And if I just pulled that out of a hat like at the beginning of lecture two, I would lose all credibility with you, right? I'd write that down and you'd be like, this is confusing. Why is it so complicated? This is very unnatural. It just wouldn't seem like the right thing to write down had you not already gone through all of the work that we have to get to this point. And indeed, the culmination of sort of walking through the possibility results and the synchronous model and the impossibility results and the Asynchronous model, the culmination of all that discussion will be this sweet spot, partially synchronous model that we'll talk about next lecture. And that's really probably the most important model for reasoning about blockchain protocols.
00:05:16.894 - 00:06:00.766, Speaker A: And it would have been hard to come up with that definition had we not been illuminated by the FLP impossibility result. Finally, I have to concede I'm trained as a theoretician. I'm a theoretical computer scientist. And the two proofs we just saw in lectures three through five. So both this FLP impossibility result and also the earlier impossibility result for the synchronous model without PKI, that was the hexagon proof with the simulation argument, if you remember. I just think these proofs are super cool and in general in any field. While I think it makes a lot of sense to keep your eyes kind of squarely focused on the future, I also think it's really important to celebrate the past, especially when the past is so practically relevant as the results we've just been talking about.
00:06:00.766 - 00:06:32.850, Speaker A: So these impossibility results, they definitely belong to the Canon. They're amongst sort of the greatest hits of computer science, just as many people find it spiritually nourishing to go look at fine works of art. Perhaps, at least for a subset of you, you get a similar feeling by sort of going through these brilliant proofs by the computer scientists who have come before us. That wraps up our discussion of the Asynchronous model and the FLP impossibility results. I'll see you in lecture six for a discussion of the partially synchronous model and the tendermint protocol.
