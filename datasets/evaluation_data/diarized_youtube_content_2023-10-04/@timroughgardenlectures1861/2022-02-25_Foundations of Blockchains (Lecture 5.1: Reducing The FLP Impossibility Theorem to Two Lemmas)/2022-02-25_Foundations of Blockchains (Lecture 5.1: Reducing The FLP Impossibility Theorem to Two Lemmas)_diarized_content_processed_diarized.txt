00:00:00.490 - 00:00:20.186, Speaker A: Hi everyone, and welcome to lecture five in this lecture series on the foundations of blockchains. So we're going to continue the topic of lecture four. We're going to keep talking about the Asynchronous model and we're going to finish the proof of this very famous impossibility result, the FLP Impossibility Theorem by Fisher, lynch and Patterson.
00:00:20.186 - 00:00:32.246, Speaker A: Before we get into it, let me just sort of, you know, jog your memory for the key concepts that we learned in lecture four. So first of all, we introduced the Asynchronous model. Again, we're trying to be sort of the polar opposite of the synchronous model.
00:00:32.246 - 00:00:45.926, Speaker A: We throw out our shared global clock. We throw out having sort of any guaranteed delivery of messages other than the minimal requirement that every message sent must eventually be delivered. The formal model, remember, is purely event driven.
00:00:45.926 - 00:00:57.102, Speaker A: There's no notion of time. So there's just this message pool, capital M, which just keeps track of all the messages that have been sent but not yet received. And then messages are delivered in a completely arbitrary order.
00:00:57.102 - 00:01:17.074, Speaker A: So it's convenient to think about it as if it's controlled by an adversary, someone who wants to mess up our consensus protocol. So at each iteration of this while loop, an arbitrary or adversarially chosen message from the message pool is chosen to be delivered to its intended recipient. And then as a node, once you receive a message, you can then respond with further messages.
00:01:17.074 - 00:01:31.530, Speaker A: So you can add messages to the message pool upon receipt of some message. The FLP impossibility result concerns a consensus problem known as Byzantine agreement. So this gets added to our list of consensus problems.
00:01:31.530 - 00:01:43.238, Speaker A: We had state machine replication, or SMR, which was multi shot consensus. We had Byzantine broadcast, which was single shot consensus. When you have a distinguished sender and now we have Byzantine agreement where it's, again, single shot consensus.
00:01:43.238 - 00:01:49.402, Speaker A: But there's no distinguished sender. Rather, all of the nodes have a private input. And again, you always want to terminate.
00:01:49.402 - 00:02:03.774, Speaker A: You always want to agree no matter what. And then validity is the liveness type condition which says in the happy event that none of the honest nodes disagree at the beginning I e. All of the honest nodes have exactly the same input that should also be exactly the same output.
00:02:03.774 - 00:02:27.412, Speaker A: So if all of them have zeros as input, all of them should output zero at the end of the protocol. And so while the FLP theorem is stated for Byzantine agreement, it also implies the impossibility of Byzantine broadcast or state machine replication in the Asynchronous model. So what the FLP theorem says is that Byzantine agreement is impossible in the Asynchronous model.
00:02:27.412 - 00:02:37.880, Speaker A: And in fact that's true even when little f equals one, even if there's only one Byzantine node. Or as I said last time, I'm actually even underselling the statement a little bit. You don't even need a Byzantine node.
00:02:37.880 - 00:03:02.184, Speaker A: All you need is the threats of some node at some point crashing and going down a so called crash failure. So even with at most one crash failure, even then Byzantine agreement is impossible in the Asynchronous model via deterministic protocols. Now, the proof plan is to proceed by contradiction.
00:03:02.184 - 00:03:18.976, Speaker A: So we're assuming that there's some allegedly correct Byzantine agreement protocol pi. We want to derive a contradiction. Basically, our plan is to show that by virtue of satisfying validity and agreement upon termination, it must be the case that there are cases in which the protocol never terminates.
00:03:18.976 - 00:03:46.440, Speaker A: So it is possible that the nodes have private inputs and there is a possible sequence of message deliveries so that in fact the protocol never halts at all, which of course is a contradiction to termination. And then the precise way we're going to show that this allegedly correct protocol pi might run forever is to exhibit an infinite sequence of ambiguous configurations. So remember, by configuration we just mean sort of a snapshot of the current state of the protocol so that encodes what it is each of the nodes knows.
00:03:46.440 - 00:04:01.676, Speaker A: And each node knows its own private input as well as the sequence of messages it has received. A node does not know the private inputs of other nodes, nor does it know the messages that have been received by other nodes. Also encoded in the configuration is the message pool.
00:04:01.676 - 00:04:24.436, Speaker A: So what are the messages that still need to be delivered? So that's what we mean by configuration. It's just like saving the state of the protocol at a particular point. Whenever a message is delivered, we transition from one configuration to another, right? We take a message out of the pool, we add it to the sequence of messages received by that recipient, and then we add whatever messages it wants to send back into the pool.
00:04:24.436 - 00:04:44.800, Speaker A: So we can think about a sequence of message deliveries as a path in a big, potentially infinite directed graph. A graph in which the vertices or configurations and the directed edges correspond to state transitions. Now, because an adversary controls message delivery, that adversary is basically controlling how we walk through this graph.
00:04:44.800 - 00:05:00.996, Speaker A: We then classified configurations into three categories. We said, well, first of all, there might be a situation where the final output of the honest nodes is a foregone conclusion. We may get to a point where no matter what the adversary does, all of the honest nodes are going to output zero.
00:05:00.996 - 00:05:28.040, Speaker A: So that's a zero configuration. If no matter what the adversary does, the inevitable output of the honest nodes is all ones, we call that a one configuration and then the rest are ambiguous configurations. And again, because pi satisfies agreement and we know that all of the honest nodes are always going to output the same thing, the only remaining possibility, this ambiguous configuration, the only remaining possibility is that the adversary still has control over which of the two possible outcomes occurs.
00:05:28.040 - 00:05:48.100, Speaker A: So there exists an adversary strategy that forces the all zeros output and there exists a different adversary strategy that forces the all ones output. So that's an ambiguous configuration and we're trying to exhibit an infinite path through that graph that comprises only ambiguous configurations. That's how we're going to show that Pi could run forever.
00:05:48.100 - 00:06:16.488, Speaker A: The way we exhibit this sequence of ambiguous configurations is we have two lemmas working for us, lemma one and lemma two, sort of playing roles kind of analogous to a base case and an inductive step in a proof by induction. So lemma one, which we proved last time in lecture four, lemma one tells us how to get started. So there's two to the N, different private sequences of private inputs that the nodes could have if we're working with just zeros and ones, a binary choice for each of the N nodes.
00:06:16.488 - 00:06:29.996, Speaker A: So two to the N possibilities. So that's two to the N, different initial configurations. And then one says that whatever the protocol Pi may be, it promises that at least one of those two to the N configurations will in fact be ambiguous.
00:06:29.996 - 00:06:41.590, Speaker A: So that is the point at which we're going to start our sequence. It gives us a choice of private input. So we start out with the adversary having control over whether the final output is all zeros or whether the final output is all ones.
00:06:41.590 - 00:06:52.436, Speaker A: So to prove lemma one we thought about the following thought experiment. So we thought about sort of the case where all of the nodes have private input zero. So sort of the all zeros string as the input.
00:06:52.436 - 00:07:14.608, Speaker A: And then we thought about flipping the bits one by one from left to right so slowly making more of the node's inputs being equal to one. Now this is the part of the proof where we use the Pi is assumed to satisfy validity. Validity says that if all of the honest nodes for example, have the common input zero, then no matter what the adversary does, it needs to be the case that the honest nodes all output zero.
00:07:14.608 - 00:07:42.090, Speaker A: Validity is that exact guarantee rephrased in this sort of new terminology that says that the initial configuration when everybody's a zero, that has to be a zero configuration by definition no matter what the adversary does, it's a foregone conclusion that all of the honest nodes will output zero. Appealing to validity. Once again, if we have the all ones input then we know that's a one configuration, no matter what the adversary does, validity guarantees that the honest nodes will output all output one.
00:07:42.090 - 00:08:07.644, Speaker A: And so what that means is that in this thought experiment where you're flipping the zeros to one one at a time, there will be some coordinate, there will be some node when you flip its input from a zero to a one. And all of a sudden, you switch from the initial configuration being a zero configuration to not being a zero configuration. Because if nothing else when you flip the very last bit you're guaranteed to get to a one configuration.
00:08:07.644 - 00:08:24.804, Speaker A: So we basically started flipping zeros to ones. We fast forwarded to the first point at which a bit flip resulted in an initial configuration which was not a zero configuration. Now there's two possibilities it could be a one configuration which isn't very helpful for us or it could be an ambiguous configuration which is exactly what we're looking for.
00:08:24.804 - 00:08:47.544, Speaker A: That could be then our starting point. So to complete the proof then what we needed to show is that this first configuration which was not a zero configuration, call it x sub I we just had to show it actually is ambiguous, it's not a one configuration. So we wanted to argue that there's no way you can go directly from a zero configuration to a one configuration merely by flipping the private input bit of a single node.
00:08:47.544 - 00:09:02.076, Speaker A: That's what we're trying to show is impossible. That the only way you can go from a zero configuration to a one configuration is by going through at least one ambiguous configuration on root. So we then completed the proof by just arguing directly that Xi is ambiguous.
00:09:02.076 - 00:09:29.860, Speaker A: We sort of argued that there is an adversary strategy that forces a one all ones there's a different adversary strategy that forces all honest nodes to output zero and that's exactly the definition of ambiguous configuration. So where do those two adversary strategies come from? Well, one of them we inherit immediately just from the fact that Xi we chose this I so that Xi is not a zero configuration. So maybe it's a one configuration and every adversary strategy leads to the all ones output.
00:09:29.860 - 00:10:00.912, Speaker A: But if not that, then it's an ambiguous configuration and there exists at least one adversary strategy that forces the all one's output. So by virtue of not being a zero configuration there must be an adversary strategy that forces the all one's output but there's also a different adversary strategy that forces the all zeros output. So specifically the bad case is when this node I so the node whose private input bit sort of flipped whether you were in a zero configuration or not if that's controlled by an adversary.
00:10:00.912 - 00:10:28.060, Speaker A: So if node I is Byzantine because if node I is Byzantine, one strategy that the adversary can do is it can just flip the bit in its mind. Okay, so its true private input bit is a one, but it can say, let me pretend like it's zero and then follow Pi honestly as if its private input was zero even though it's actually one. And the point is, this adversary strategy then makes it indistinguishable to all of the honest nodes whether they actually started in the configuration xi minus one.
00:10:28.060 - 00:10:54.144, Speaker A: So whether node I was actually honest and really had a private input bit of zero or whether they started in Xi and I was adversarial and lied about what its private bit actually is. So because all honest nodes can't distinguish between those two cases, in both cases they know exactly the same things, they have the same private input, they see exactly the same sequence of messages. The output of all the honest nodes also has to be identical in both of those two cases.
00:10:54.144 - 00:11:08.168, Speaker A: So that means that with this particular adversary strategy, I being Byzantine, pretending like its input bit is the opposite of what it was, that has to lead to an all zero outcome. So there's our adversary strategy forcing all zeros. We already had one forcing all ones.
00:11:08.168 - 00:11:19.420, Speaker A: So that proves directly that Xi must be ambiguous. And that was exactly the point of Lemma One, that there exists a way, no matter what pi is, there's some way of setting those private input bits. So you start out ambiguous.
00:11:19.420 - 00:11:36.480, Speaker A: And that brings us up to date with everything we covered in lecture Four. Just a quick recap. So now let's move on to the notorious Lemma Two, which is fairly similar to Lemma One, but it's definitely a little bit trickier.
00:11:36.480 - 00:11:55.236, Speaker A: Remember the point of Lemma Two, it's acting like an inductive step. So given a sequence of ambiguous configurations, lemma Two will tell us how to make it a longer sequence of ambiguous configurations. And so then we'll have theorem because we apply Lemma One to get the first ambiguous configuration, we apply Lemma Two over and over again to get the rest of the sequence.
00:11:55.236 - 00:12:05.336, Speaker A: But actually there is sort of a subtle point. And so when I write down the statement of Lemma Two, it might not be quite the statement that you were expecting. So we'll talk about that shortly.
00:12:05.336 - 00:12:24.588, Speaker A: So Lemma Two, as you'd expect, one of the things you start with is an ambiguous configuration. So this is the ending point of your sequence thus far, the one that you want to extend further. But in addition to this sort of ambiguous configuration that we want to extend, we're also in Lemma Two going to choose a message in the message pool.
00:12:24.588 - 00:12:41.016, Speaker A: So remember, a configuration encodes what nodes know and it also encodes all of the outstanding messages. So it makes sense to say we choose a message in the message pool as it's encoded in the configuration C sub I. Now, there could be a billion messages in the message pool in the configuration C sub I.
00:12:41.016 - 00:13:03.840, Speaker A: But this Lemma Two, we're going to insist that it works no matter which of those billion messages you single out. So what do I mean by work? What's going to be the conclusion of Lema Two? Well, it's going to promise us a transition sequence, meaning a sequence of message deliveries taking you from one configuration to another. So a finite sequence of configurations with two properties.
00:13:03.840 - 00:13:35.320, Speaker A: So first of all, the very last message delivered in this possibly long sequence will be the delivery of the message in question, r comma m. Secondly, after that last delivery, the delivery Of The Message R Comma M, you Find Yourself In An Ambiguous Configuration. So another way of saying this is lemma two guarantees that there is a way to eventually deliver the message in question r comma m while remaining in an ambiguous configuration.
00:13:35.320 - 00:13:43.420, Speaker A: So you can think about lemma two in terms of the following picture. Okay, so we have our given configuration. CI ambiguous.
00:13:43.420 - 00:14:07.492, Speaker A: At the end of the day, after the delivery of all of these messages, concluding with R comma m, we're going to wind up in another ambiguous configuration which we'll call CI plus one. The final step of the sequence is the delivery of the message r comma m and so the configuration just before that, let's call it CI prime. Totally possible that CI and CI Prime are exactly the same.
00:14:07.492 - 00:14:21.944, Speaker A: But it's also totally possible there's some super long sequence of message deliveries in between. So maybe a billion messages get delivered to take you from CI eventually to CI Prime. And then, at the very last hop of the sequence, you deliver RM to get to CI plus one.
00:14:21.944 - 00:14:31.580, Speaker A: Now, this is a good point for a quick sanity check, right? So we're looking at this long sequence. We start in an ambiguous configuration. We end it in ambiguous configuration.
00:14:31.580 - 00:14:54.736, Speaker A: What can you say about the configurations in between? Are they also ambiguous? Or could they be zero configurations? One configurations? Or it's impossible to know. What can you say about those intermediate configurations? Well, I mean, think about it, right? So suppose you're in a zero configuration. That means you're going to output zero no matter what.
00:14:54.736 - 00:15:06.560, Speaker A: The honest nodes will output zero no matter what. So no matter what message gets delivered, you're going to be in another zero configuration, right? It'll still be the case that no matter what happens, everybody outputs zeros. So once a zero configuration, always a zero configuration.
00:15:06.560 - 00:15:27.432, Speaker A: Similarly, once a one configuration, always a one configuration. And so what that means is you can never transition from a zero or a one configuration to an ambiguous configuration. So if anyone ever shows you an ambiguous configuration, you immediately know that all of the steps you took to get there were also via ambiguous configurations.
00:15:27.432 - 00:15:46.956, Speaker A: So, yes, indeed, all of the intermediate configurations in the sequence must themselves be ambiguous. Like I said, I'm not surprised if this Lemma Two feels a little more complicated than the one you thought I was going to write down because I said we really wanted a Lema Two to just sort of extend the ambiguous sequence. So you might have been expecting a statement of Lema Two.
00:15:46.956 - 00:15:58.820, Speaker A: That was something like given an ambiguous configuration, c sub I. There exists some way to extend it. Right? So there exists a message in the message pool whose delivery leads you to another ambiguous configuration.
00:15:58.820 - 00:16:15.400, Speaker A: So in particular, you're probably wondering, like, why single out this one message? Who cares about r comma m? Like, why Single Out some arbitrary message from CI's message pool. Well, so here's the subtle point. So, remember, in the Asynchronous model, we assume almost nothing about message delivery.
00:16:15.400 - 00:16:36.560, Speaker A: But we do assume one little thing, which is that every message sent eventually gets delivered after a finite period of time. And if we're not careful about how we extend this sequence of ambiguous configurations, we may wind up violating that requirement. We may wind up sort of leaving some message in the message pool forever.
00:16:36.560 - 00:17:07.804, Speaker A: So, I mean, for example, imagine you had a protocol where sort of as we discussed, imagine we had a protocol where every time a node receives a message, it sends one or more messages, one of those messages being a dummy message back to itself to make sure it gets another opportunity to speak in the future. Well, then, if we're not careful, we could just have this ambiguous sequence where we literally just keep delivering node number seven's dummy message back to itself over and over and over again, leaving all of the other messages in the pool forever. Okay? So that's not what we want.
00:17:07.804 - 00:17:24.496, Speaker A: And that doesn't actually satisfy the Asynchronous model. And so that's the reason we have this slightly more complicated version of Lemma Two. Singling out the message R comma m will allow us to ensure eventual delivery of every message as is required for the adversary in the Asynchronous model.
00:17:24.496 - 00:17:41.206, Speaker A: So that point will become much clearer when I show you on the next slide how Lemma One and Lemma Two in tandem actually do imply the FLP Impossibility theorem. So let's go do that next. So we've already proved lemma one.
00:17:41.206 - 00:17:47.562, Speaker A: We're going to prove lemma two. But for this slide, just take it on faith that Lemma Two is, in fact correct. Far from obvious that it's true.
00:17:47.562 - 00:17:54.618, Speaker A: Okay, but it is. Let's now see how those two lemmas work as a team to prove the FLP Impossibility result. And again, the intuition is clear.
00:17:54.618 - 00:18:03.626, Speaker A: You invoke lemma one to get started. You invoke Lemo Two over and over again to extend. But there is again, this subtle point about eventual message delivery.
00:18:03.626 - 00:18:08.862, Speaker A: So let's see exactly how that works. No prizes for guessing the first step. Right, we need to start the sequence.
00:18:08.862 - 00:18:17.234, Speaker A: Lemma One tells us where to start the sequence. So we'll just use C zero to denote the ambiguous initial configuration that is promised to us by Lemma One. Okay, so we fix some protocol.
00:18:17.234 - 00:18:34.060, Speaker A: Pi. Lemma One guarantees a setting of the private inputs so that we start out ambiguous. So how are we going to extend the sequence to find a state CI plus one from CI? So we're going to be able to use Lima Two to sort of get the best of two worlds, in a way.
00:18:34.060 - 00:19:02.142, Speaker A: So first, imagine that you wanted to focus on this guaranteed message delivery property. You wanted to make sure that no message gets starved forever. And let's say you didn't actually care about the remaining ambiguous part? Well, that would not be a hard problem to solve, right? You could just use first in, first out, or FIFO message delivery, meaning that sort of at every iteration of that, while loop that defines the Asynchronous model, you would always be delivering the message that was the oldest.
00:19:02.142 - 00:19:24.522, Speaker A: So of all the messages in the message pool, the first one that was added to the message pool, notice this does guarantee a finite delay before a message is delivered. It might be big, right? So like maybe when a message gets sent, the message pool already has 1 billion messages in it. But still, the only messages that are going to be sent before you are those billion messages, nothing else.
00:19:24.522 - 00:19:47.018, Speaker A: So a billion steps from now, in fact, that message will get delivered. So if all you want is guaranteed message delivery, first in, first out is already good enough. So why don't we just use first in, first out message delivery in this proof in limit two? Well, the issue is that it might be that the oldest message in the pool would actually resolve your ambiguity.
00:19:47.018 - 00:19:57.386, Speaker A: It would actually transition you from your current ambiguous configuration to a configuration that's either a zero or a one. And that we don't want. Remember, we want this infinite sequence of ambiguous configurations.
00:19:57.386 - 00:20:17.414, Speaker A: We want to stay ambiguous the whole time. So the worry is that somehow the immediate delivery of the oldest message in the pool would get rid of the ambiguity. And so the whole point of this sort of sequence, the whole point of the way Lemit Two is phrased is it says that, well, it may be that right now delivering this old message would resolve the ambiguity.
00:20:17.414 - 00:20:48.338, Speaker A: But if you deliver some number of other messages first, then all of a sudden you can safely deliver this oldest message while retaining ambiguity. So precisely, here's how we sort of basically get the same properties as first in, first out, while also through Lemma Two retaining ambiguity all along. So to figure out what to do from CI, we do indeed look at the oldest message in CI's message pool, the first of all of those messages to have been inserted into it.
00:20:48.338 - 00:21:06.214, Speaker A: Now, we don't necessarily want to just immediately deliver this message because it might take us to a zero or a one configuration, but here's where we can use Lemma Two. So Lemma Two promises us some sequence of other message deliveries and that then culminates with this message, leading us to an ambiguous configuration. So that's what we're going to do next from CI.
00:21:06.214 - 00:21:38.390, Speaker A: We're just going to do exactly what Lemma Two recommends to us, given that we're starting at C sub I, and given that R comma m is the message we eventually want to make sure gets delivered. Now, Lemma Two assures us that the configuration we wind up in CI plus one after the delivery of the message r comma m possibly after the delivery of a bunch of other messages, we wind up in this ambiguous configuration, CI plus one. So if we keep applying Lema Two over and over again, we're just going to get this infinite sequence of ambiguous configurations c zero, C one, C two, C three, dot, dot, dot.
00:21:38.390 - 00:22:07.640, Speaker A: You may notice sort of what I'm doing is actually slightly different than the proof plan I told you about. Sort of at the outset, when I first said, let's exhibit an infinite sequence of ambiguous configurations, you were probably thinking there'd be a single message delivery going from C zero to C One, a single message delivery going from C One to C Two, et cetera. So we're going from here, c zero to C One through an application of Lemma Two, from C One to C Two through another application of Lemma Two, et cetera.
00:22:07.640 - 00:22:20.956, Speaker A: Every application of Lemma 2 may deliver more than one message in between. So there may be a long sequence of message deliveries between a CI and a CI plus one. But so what? I mean, you tackle all of these sequences together, what do you get? You get a sequence.
00:22:20.956 - 00:22:34.768, Speaker A: All of the CIS C zero, C one, C two, et cetera, are all ambiguous. And everything in between has to also be ambiguous, right? Because the only way you can keeping ambiguity is you keep it all along. Right? Ambiguity only ever gets resolved.
00:22:34.768 - 00:22:44.868, Speaker A: It never gets introduced. Okay, great. So limit one and limit two repeatedly applied gives us this arbitrarily long sequence of ambiguous configurations.
00:22:44.868 - 00:23:18.316, Speaker A: But remember, we do have to worry about meeting the constraint that's required of the adversary in the asynchronous model, namely that every sent message eventually gets delivered. And so what I want to argue now is that this is a close enough approximation to first in, first out message delivery, FIFO delivery that we do, in fact, get a guaranteed bound or every message is, in fact, delivered within a finite number of steps. So think about an arbitrary message that gets sent at some point in this particular trajectory of the protocol pi.
00:23:18.316 - 00:23:30.208, Speaker A: So along this infinite sequence of ambiguous configurations, consider a message R comma m. All right, so let's suppose this is sent at or before some configuration C sub I. Maybe I is like 17.
00:23:30.208 - 00:23:49.176, Speaker A: Okay? So leading up to configuration C 17, this message r comma m gets sent, meaning it gets added to the current message pool. Let's suppose that at the time this message gets added to the message pool, there were already 99 messages in the pool. So this was the 100th message at that point in the pool.
00:23:49.176 - 00:24:15.664, Speaker A: So this is great news for us. Why? It means that within 100 applications of Lemma Two, starting from configuration C 17, within 100 further applications of Lemma Two, this message r comma m is guaranteed to be delivered. Why? Because every time we apply Lemma Two, we use the oldest message in the pool, and there are only 99 messages older than R comma m in the pool.
00:24:15.664 - 00:24:32.490, Speaker A: Each application of Lema Two will deliver at least one of those 99 messages. So after 99, if not fewer applications, R comma m will be the last one in the pool, and then the next application of lemma Two will deliver. That the oldest remaining message.
00:24:32.490 - 00:24:48.800, Speaker A: So let me write that as guaranteeing that the message will be delivered at or before the configuration C sub I, plus I'm writing the cardinality of capital M. So what I mean by that is just the size of the message pool. Immediately after this message, R comma m was added to it.
00:24:48.800 - 00:25:00.340, Speaker A: So in our numerical example, that's 100. So I was 17, and the cardinality of capital M would be 100. So it guaranteed delivery at or before the ambiguous configuration C sub 117.
00:25:00.340 - 00:25:28.860, Speaker A: Now, it is possible that some message R comma m gets delivered earlier than this, because, remember, every application of lemma Two might deliver a whole bunch of messages en route to delivery the one it's really tasked with delivering. So, totally possible R comma m winds up being useful in an earlier application of Lemma Two for the intermediate sequence. But if nothing else, after those 100 applications of Lemma Two, at that point, it's guaranteed that that message at some point was delivered.
00:25:28.860 - 00:25:43.756, Speaker A: So that concludes this part of the argument. Again, we have not proved Lemma Two, and it is not at all obvious we still have to do that. But at this point, you should agree with me that given that we've proved Lemma One, the fact that there exists a way of setting the private input.
00:25:43.756 - 00:26:19.512, Speaker A: So you start in an ambiguous configuration and taking on faith that we're going to prove Lemma Two, that given an ambiguous configuration and a message you really, really want to deliver, there exists a sequence of intermediate messages following which you can deliver the target message while retaining ambiguity. If we can prove that Lemma Two, then Lemma One and Lemma Two working together do indeed show FLP impossibility. So the point being, the only task we have remaining for us is proving Lemma Two exhibiting these sequences of intermediate deliveries that guarantee ambiguity after the delivery of a target message.
00:26:19.512 - 00:26:24.100, Speaker A: So we will do the proof of Lemma Two in the next video, and I'll see you there. Bye.
