00:00:08.730 - 00:00:17.946, Speaker A: Thank you all for coming. Today we're going to talk about symbolic mev extraction or MAV extraction. My name is Georgios, I'm CTO and partner at Paradigm.
00:00:17.946 - 00:00:33.560, Speaker A: We're a venture capital firm with our hands deep in crypto. So I'm not a searcher. This is being practical and this is more so to stir up a discussion rather than say this is the best way to extract mev and take it as you wish.
00:00:33.560 - 00:01:29.162, Speaker A: The whole talk is centered around this question of we have very solid techniques on proving software security and how well can we apply this to the domain of MAV extraction to actually make money? And maybe just to give some background, which I'm sure many people in this group are familiar with the state of mev searching more or less. The main categories are these we have Arbitrage of various kinds, we have backgrounding and Sandwiching have liquidations and then the so called long tail which turns out to be really long and there's like a lot of categories of mev to be extracted. And the software stack of a searcher roughly looks like a bunch of nodes to be able to access the state and to be able to access the mempool, a bot for each integration that you want to have.
00:01:29.162 - 00:01:53.854, Speaker A: Typically that bot has full knowledge of the app that it's extracting and we'll call that white box simulation for this conversation. And then it has stuff like getting your transaction on chain either via a PGA or via Flashbots or Blocks route or whatever else and finally observability. So we're focusing here which is like only a very small part of the broader stack.
00:01:53.854 - 00:02:10.086, Speaker A: So this ties back to my original point. Now looking at the black white gray box analogy, we can see that on black box you have no knowledge of what's going on in your system. On gray box you have some.
00:02:10.086 - 00:02:25.782, Speaker A: On white box, you know everything. And how this manifests in mev extraction techniques? When you're white box mev extracting, you know fully how an app works. Maybe sometimes you rewrite it in native code, even for performance.
00:02:25.782 - 00:02:42.010, Speaker A: A lot of people do that. For example, for uniswap, instead of going to the AVM, they take the reserve values and they take the reserve values and they trade data from the call data and they run it from their own rust implementation or whatever. But that requires a lot of maintenance.
00:02:42.010 - 00:02:57.894, Speaker A: However, it is very reliable and fast. Now black box, we can think of it as that you define some properties and you throw things at it and maybe it gives you something back that works, maybe it doesn't. So it's unclear how reliable it is.
00:02:57.894 - 00:03:27.440, Speaker A: And the black box techniques are for example, Fuzzing, where you throw data at the binary until it crashes. You don't know anything about the binary, just throw information at it and the fuzzer gives you back something that says this input crashed the binary. Now gray box is similar to black box, but with an extra feedback loop that as it's executing things, it's gaining some information about how the system works and feeds that in back to your solving system.
00:03:27.440 - 00:04:17.280, Speaker A: So going from the very white box style mev extraction, where you know everything like Arbitrage and liquidations, we can then go to somewhat black box style MAV extraction, which is in the generalized front runners domain. And Dan Robinson and I wrote an article about this called Ethereum's Dark Forest, which kind of talks about this beast in the mempool, which the moment there is a transaction that can make money anywhere, where that transaction exists in the subtraces of a call, the bot goes in, it copies that subtrace and goes and executes it. So now, this is a very dangerous kind of front runner, because it means that anytime you need to execute a white hat, for example, because you found a vulnerability, like my colleague Sam Citizen finds every day.
00:04:17.280 - 00:04:27.154, Speaker A: And if you get frontrun and you were going to save a lot of money. And that money goes to a bot that didn't even know that this was a hack. Obviously it's a problem.
00:04:27.154 - 00:04:50.074, Speaker A: So these bots can cover a lot of categories. And typically how they work is that they had defined some conditions in the client where they say, was the storage slot changed from value A to value B. If this and that happened, then copy this subtrace and maybe replace the message sender with my address or something in that area.
00:04:50.074 - 00:05:19.682, Speaker A: But it's all rough permutations of that technique. And usually, or really anytime they don't discover new MV opportunities, they're literally a copy trader, a very, very smart copy trader. And so the question now that we have some context is that can we not know what we're digging for? Sort of like how mining in proof of work works, where you just keep hashing and hashing and hashing and you don't really know what you're doing, you just do a dumb problem.
00:05:19.682 - 00:05:39.366, Speaker A: So is there some mapping of this problem to mev extraction? And mev extraction starts to look a lot more like mining if it becomes independent of what the problem is. So to do that, let's talk a bit about property based testing. So there's two kinds of testing, roughly.
00:05:39.366 - 00:05:55.374, Speaker A: There's integration tests too, but not relevant for this conversation. Unit testing, we say, okay, this is my scenario. Let my input be x equals five, run two, multiply by X, you get some output and you check it against what you would expect multiplication to do.
00:05:55.374 - 00:06:03.102, Speaker A: So here it would be ten. Whereas property based testing, you never define your input. You say, this is what I want to hold.
00:06:03.102 - 00:06:14.514, Speaker A: No inputs X-Y-Z and many, many inputs are going to be chosen. And for every one of these inputs, this property must hold. So let's say you're testing the commutative property.
00:06:14.514 - 00:06:26.146, Speaker A: It will throw a bunch of x values and Y values and z values. And we check that parentheses, commutative property obviously hold. And there's two ways to use property based testing.
00:06:26.146 - 00:06:45.098, Speaker A: And you see this like the first usage, you see it used a lot by developers. The second usage, you see it used a lot by auditors. So when developers are mating their code, they're writing property tests, at least some developers do, to ensure that the code is working as expected beyond trivial scenarios.
00:06:45.098 - 00:07:02.338, Speaker A: And an obvious example of when this would be useful is like division by zero. So you've written a test where you've written some code where it's undefined over zero or there's some rounding error and you just didn't have a good input for it and you couldn't observe the rounding error. And then it hits you in prod, then you have a problem.
00:07:02.338 - 00:07:13.334, Speaker A: So that's the defensive use aggressively and you will see this a lot by trail of bits with their tool. Like kidna. Whenever they do an audit they will say okay, this is how I want my math to look like.
00:07:13.334 - 00:07:33.214, Speaker A: They write the math, they translate the mathematical properties that are supposed to be there and then they run it over a property based tool called Echidna. And what it does is that it finds you a counterargument, the minimal counterargument to be clear, which breaks that property. Now things start to make a bit more sense.
00:07:33.214 - 00:08:04.998, Speaker A: We have a property, the property here is about security. But maybe we can transform this property on can I make money? So let's start to make this more interesting. So instead of saying that the property is this commutative or division works, which it's obvious, what about saying let's say that we define the property called is the contract solvent or does the contract have a never decreasing ETH balance? And that's your property.
00:08:04.998 - 00:08:17.722, Speaker A: So think that if you want to make money, you want to find the condition so that the contract does not lose money. So you want to break the property that the contract is secure. So whenever you want to do something, you have to write the inversion of it.
00:08:17.722 - 00:08:33.162, Speaker A: And how you would do mev extraction for that is that you would monitor every new smart contract gets deployed. You would get the contract, you would parse the bytecode, you would get all. So you never have access to solidity or the Abi or the source tree or whatever, this index tree.
00:08:33.162 - 00:08:45.726, Speaker A: You just have bytecode. And it's very important because we're talking about zero knowledge about the shape of the application in a way. So you can get all of its function signatures from the jump table.
00:08:45.726 - 00:08:59.318, Speaker A: And what you can do is that you will start throwing random function calls at it and random with an asterisk, which I will refine in a bit. So I take a contract I call function A with some argument. I check the property.
00:08:59.318 - 00:09:26.830, Speaker A: The property says has the contract lost money? If it has lost money, return me the input or the sequence of calls that caused the contract to lose money. And I don't do this one or ten times, you do this hundreds of thousands of times over multiple depth calls. So not only do I do one call, I do 1234 or five consecutive calls because obviously the vulnerability of the MAV opportunity, it might not be on a single function call, it might be on a series of function calls.
00:09:26.830 - 00:09:44.658, Speaker A: And so you do that and ideally you can find some argument that breaks the property and then you submit the transactions and you make money. Sounds great. Now how are we going to choose the inputs? Clearly the input space is gigantic.
00:09:44.658 - 00:10:10.762, Speaker A: Many functions, many arguments, many iterations what do. So here's where we get to the topic of the discussion, which is symbolic execution. So in symbolic execution, you take a concrete problem and instead of solving it for the values that were given to it, instead you translate it into a bunch of constraints, some restrictions, some rules that need to be followed.
00:10:10.762 - 00:10:33.042, Speaker A: And then you will use some Smt solver, which I always forget what Smt solver stands for, to be honest. And you use the Smt solver to find inputs which satisfy or not satisfy these constraints. And in security you use that to prove, formally prove that the program is secure.
00:10:33.042 - 00:11:05.102, Speaker A: But if it's not secure, the solver will spit out the inputs that broke it. And just to give a bit more of a visual example, and I appreciate the patience because the slides are very heavy on text, imagine that you have this kind of function over on the left which says I have a function, it takes x and y, sorry, I have a function foo which always doubles. And then I also have a test which makes assigned z to foo, has a conditional check and has another conditional check and if both branches are taken, it errors.
00:11:05.102 - 00:11:34.554, Speaker A: So in the concrete case, the test that we would write, it would be test me over inputs x two, y equals three or whatever, you would run it, you'd pass, you would say I'm good. Obviously that does not cover everything. If you're doing fuzzing or property based testing, instead of x and two x equals two and y equals three, it would say x equals random, y equals random, run it, execute it and run it 100,000 times.
00:11:34.554 - 00:11:51.920, Speaker A: And ideally the property always holds. Now, on the symbolic case, what you have is that you have the state and the constraints and there's various ways to call this which might be more accurate. But again, this is not like 100% my expertise, so bear with me.
00:11:51.920 - 00:12:17.878, Speaker A: In this case, the state variables, which in this case would be x, y and z and z, you will see that is always defined as two multiplied by y in this case, because z equals foo. And then the constraints that you get is that anytime you hit a conditional statement, reality splits into two. It's almost like a tree of all possible states.
00:12:17.878 - 00:12:36.830, Speaker A: And in the one case the branch was taken, in the other case the branch was not taken. So the inputs, they're not concrete, they're symbolic, they're abstract, they do not exist until a later point in time. And this means that you can simultaneously explore multiple future realities without collapsing it into one.
00:12:36.830 - 00:12:56.850, Speaker A: And if Tyrone was here, he would say this is like quantum computing. So once you have translated the program to the constraints, then you feed it to Z three or CCV three or whatever other solver you're using and the solver will output true or false along with the inputs required. Now, this is great.
00:12:56.850 - 00:13:34.762, Speaker A: Obviously this is a trivial example for more complex examples, it takes more time. That's why it gets back to my original point around is it theoretical, is it practical? And now taking it on the AVM context and on the right side here you can see what I mean about all the possible futures, that it never collapses, it it just keeps them all simultaneously in reality until it fits them to the solver, which does the collapse. So you use a symbolic EVM, you feed it some bytecode and anytime it encounters some kind of opcode or some input that it can do abstractly, symbolically, it will split reality.
00:13:34.762 - 00:13:47.378, Speaker A: So let's say there's an if condition, it will split into two. Now there's restrictions, for example, in for loops, you cannot do that. You cannot symbolically execute a for loop because it does infinite state explosion.
00:13:47.378 - 00:14:12.686, Speaker A: So you need to constrain it in some way and as a coder here a lot of the problems that we see in translating concrete to abstract representations for symbolic execution. You see them in Snarks when you try to translate a normal program to a constraint program for usage. In approved examples of this kind of software are many.
00:14:12.686 - 00:14:26.594, Speaker A: My personal favorites are Hevm and Pacala. But there's also mithril by consensus, manticore, by trail of bits and probably others. So now we have all the pieces, like containing how we can use this to make money.
00:14:26.594 - 00:14:53.894, Speaker A: So basically to take the property based symbolic, the property based mev extraction, we take it and we lift it from simple randomness to something that's actual more structured. So you monitor new contracts, you symbolically execute multiple EVM transactions, same thing as before. You take many transactions, you take many functions, many different, but this time you don't take many arguments because the arguments, they get chosen by the solver.
00:14:53.894 - 00:15:10.910, Speaker A: At the end you send the solver, hopefully the solver returns and you're good. Now, the insight here is that the solver effectively learns the structure of the problem as it receives the constraints. Like the constraints express the structure of the problem.
00:15:10.910 - 00:15:48.902, Speaker A: So intuitively you can think that the random fuzzing, it doesn't know what the hell it's doing, it's just throwing inputs whereas this, it translates the program into constraints and the constraints guide the solver on where to go. Extra context here Z Three and the other solvers, they use multiple heuristics under the hood to effectively explore all the possible states. So here what we've seen in production with this is that Sam found a zero day in Etherscan Rip and he built a CTF puzzle which he called Pinball.
00:15:48.902 - 00:16:14.130, Speaker A: Now, the Pinball game, it was used to illustrate the zero day. So it had a backdoor, which you would insta win, but it had a literal Pinball game with controls in Solidity where you feed it byte streams and depending on what byte stream you feed it, you play Pinball and you gain points. Now, some people tried to solve it manually, but this guy said, all right, let me express it in properties.
00:16:14.130 - 00:16:33.420, Speaker A: So he literally said, and I'm not going to go through the code, but you can go to the link and see it yourself. He literally said Require score less than 5000. And when you say to the prover require score less than 5000, it will find you an input which gets you score over 5000.
00:16:33.420 - 00:16:47.038, Speaker A: So you can keep doing that until you get more high scores. Now, obviously, the more complex the state, the more deep the state of the program that you want to get, the more time the solver takes to solve. And maybe it doesn't terminate ever.
00:16:47.038 - 00:17:08.870, Speaker A: So you need to thread that needle. Another thing, that Leo, who is probably the smartest formal verification guy I talked to right now, he wrote a symbolic execution engine, limited, granted, but in Solidity. So it's a good testament of solidity can do really great things if you give it the love it deserves.
00:17:08.870 - 00:17:33.790, Speaker A: Now, I don't know if the slide is okay, but basically there's a big yeah, I don't know, but I like the meme. What's next? We have symbolic MAV extraction. Can we do fast symbolic MAV extraction? So I'm building a tool called Foundry, which is a testing framework.
00:17:33.790 - 00:18:02.182, Speaker A: It does not have symbolic execution yet inspired by Daptools, which had an Hevm, which lets you do what the guy did on Pinball. Ideally, we're building a new symbolic rust engine which can be used or will ideally be used in Foundry to be able to do symbolic execution. Now, because it would be built in a modular way, if you're a searcher, you could probably import the library and try doing it yourself.
00:18:02.182 - 00:18:10.470, Speaker A: We'll let you know. David Terry, dubhub engineer. He's building an EVM specific smt solver.
00:18:10.470 - 00:18:27.242, Speaker A: Basically, the thesis being that yes, Z Three good, but the same time Z Three generic. So what if we made a specific solver, like an application specific solver? We don't know if this will work, but it's an interesting venue. Again, research, open ended, et cetera.
00:18:27.242 - 00:18:51.858, Speaker A: Now, another crazy idea, which I have no idea if it's also possible, is that because solvers are very heuristic based, maybe we could train an RNN via reinforcement, learning to learn all the heuristics from the solver. So the process would be feed program, the solver, feed program to the neural net. Neural net loses, solver wins, neural net adjusts.
00:18:51.858 - 00:19:14.430, Speaker A: Over time, neural net has learned all the heuristics, and because the neural net, ideally it's high dimensionality, it can generalize to a few more cases than the solver. And because the neural net uses only linear operations and it's like, fully parallelizable over GPUs and whatever, it would probably yield us non significant performance improvements. DBD, if anyone wants to do this, please come talk to me.
00:19:14.430 - 00:19:43.302, Speaker A: And the final idea, which might be a LARP, is that if the problem ends up indeed being very structured and literally you're effectively doing, like, mev mining by literally crunching through the solvers, maybe it makes sense to eventually move on to hardware specialization, FPGAs, Asics, whatever. It's also likely that this is just like a bad rabbit hole and it's a bad idea and it's a waste of time. That's about it.
00:19:43.302 - 00:19:57.500, Speaker A: I don't know if I have time for questions, but happy to take any if I do. Five minutes? How many? Five. Okay.
00:19:57.500 - 00:20:00.140, Speaker A: Yeah.
00:20:05.470 - 00:20:16.254, Speaker B: Hi. Yeah, can you go back one slide, please? Yeah. So this kind of work obviously has happened, some of it in the sat world.
00:20:16.254 - 00:20:21.586, Speaker B: I build a sat sober. They're called sat modulo theories, actually. That's Smt, since you had trouble with that.
00:20:21.608 - 00:20:22.820, Speaker A: Thank you. Thank you.
00:20:23.990 - 00:20:42.060, Speaker B: And training models to help the heuristics of sat solvers or Smt solvers is I mean, I personally spent maybe wasted three years of my life on yeah. So it's possible. And there are burks out there partially by me and others.
00:20:42.060 - 00:20:51.414, Speaker B: And the ASIC part, usually what they do is they start at FPGA. Right. So you want to do an FPGA first.
00:20:51.414 - 00:21:17.730, Speaker B: And there have been tries, but it's extremely difficult to change the computational model to fit this new thing. So there's actually a new work by one of the masters of the south field called Armin Vierre on GPUs, which is also a different computational architecture. And it is interesting and it is to some extent competitive, but I wouldn't say it's extremely competitive, but it's not being used right now.
00:21:17.730 - 00:21:28.770, Speaker B: And I also personally worked on lifting some of the things to GPU. And yeah, FPGA is really hard, but it's possible. It's just you have to throw a lot of money at it because it's complicated.
00:21:28.850 - 00:21:48.894, Speaker A: Yeah. And another point would be I haven't studied at all how the memory access patterns look like. So whenever you want to use hardware, you cannot have frequent random memory accesses because you get a lot of the speed up by loading all the data on the GPU on the FPGA card and then just using the high bandwidth memory there.
00:21:48.894 - 00:21:52.286, Speaker A: Whereas if you go on chip off chip, you waste a lot of time.
00:21:52.468 - 00:21:59.634, Speaker B: Yeah, so that's what I meant by yeah, the memory access patterns are so different and Caching is very different and not going to go there.
00:21:59.672 - 00:22:12.480, Speaker A: Yeah. Anyone else? All right. Nobody understood anything or everybody understood everything.
00:22:12.480 - 00:22:21.868, Speaker A: Victor. Hey.
00:22:21.954 - 00:22:37.250, Speaker C: Great presentation. So my understanding is that it's really arbitrary in terms of which contracts you can go after. But when you think about it from a MAV perspective, would this be more applicable towards DeFi or NFTs or it doesn't really matter.
00:22:37.860 - 00:22:54.228, Speaker A: The whole idea of this is that you can extract the longest of the longest tails without knowing what it is. So I would say that's where it finds great application. Whereas structured problems like DeFi applications, they benefit a lot from the white box approach.
00:22:54.228 - 00:23:01.880, Speaker A: So I would consider it like this is how you explore more of the map rather than how you dig very deep on one part of the map.
00:23:04.160 - 00:23:29.300, Speaker C: If I can ask you, follow on, is it possible to structure the system in such a way that there is? Because here it kind of tries to find the answer. So it's not just like exploring it's like digging holes, essentially and pulling out treasure. Is there a way to structure this so that it does a better job of predicting without doing as much work, like which areas to focus on? So then you could do the white box thing versus actually digging for treasure.
00:23:31.480 - 00:23:43.204, Speaker A: So you can provide advice to the solver as a user of it. So you have a very abstract problem. So as you discover it, you can do mixes of the technique.
00:23:43.204 - 00:24:00.460, Speaker A: So in specific cases, like in DeFi, for example, you can say symbolically execute this, but when you see this condition, do that and it shortcuts a lot of the effort. It's effectively like if the solver has this many heuristics, you add a couple more yourself. And this is called concolic execution.
00:24:00.460 - 00:24:05.850, Speaker A: Do we have time for one more?
00:24:08.460 - 00:24:16.744, Speaker B: I can see quite clearly how this lends itself to the study of one single contract. But what do you guys do? Or have you thought about how to go across contract calls?
00:24:16.792 - 00:24:30.948, Speaker A: With this technique, you do not symbolically execute the cross contract call. The external address is always concrete. You could but the problem here is that there is state blow up.
00:24:30.948 - 00:24:51.510, Speaker A: Because if reality splits every time, you can imagine that if you give an arbitrary address with an arbitrary function selector, you immediately are in infinite future realities. All right, I see a hand. Yeah.
00:24:57.430 - 00:25:01.460, Speaker C: Hi. Thanks. Is there any way to protect from this if you are?
00:25:03.370 - 00:25:12.646, Speaker A: I don't know. I mean, what are you protecting from design applications that expose less mev, as.
00:25:12.668 - 00:25:20.490, Speaker C: In, like, if I submit a long tail alpha strategy, will you guys just immediately extract that or in principle?
00:25:21.630 - 00:25:27.086, Speaker A: I don't know. Cool, thanks. It's okay to say, I don't know.
00:25:27.086 - 00:25:36.734, Speaker A: I hope it's hi, I had a question.
00:25:36.852 - 00:25:39.070, Speaker B: Does this work with only static opportunities.
00:25:39.150 - 00:25:51.102, Speaker A: Where you're like, just there's a contract that's vulnerable to some kind of interaction that wastes money. And if you want to do a Slomic arbitrage, it's harder to find it. No, I think you can do it for arbitrage.
00:25:51.102 - 00:26:15.450, Speaker A: You can say, what is that? I mean, you could do it for arbitrage, but there is no point because you run a closed form algorithm for arbitrage. Again, it's a very structured problem, arbitrage, which benefits a lot from white box approaches. So think that you're an engineer, you have a toolkit, right? Code is a tool.
00:26:15.450 - 00:26:47.600, Speaker A: So for specific use case, you have specific tools. And in this use case, if you're going for the long tail, which seems to be getting more popular as searchers are getting outcompeted by the few overlords of mev, so maybe the thesis would be that this gets more popular as more people get squeezed out, right? Thank you all. Great questions.
00:26:47.600 - 00:27:02.420, Speaker A: Bump, bumping close.
