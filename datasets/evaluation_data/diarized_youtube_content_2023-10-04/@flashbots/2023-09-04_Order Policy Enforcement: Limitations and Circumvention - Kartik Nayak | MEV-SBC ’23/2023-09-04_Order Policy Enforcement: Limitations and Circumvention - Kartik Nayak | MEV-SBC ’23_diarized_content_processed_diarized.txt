00:00:04.010 - 00:00:10.282, Speaker A: So thank you for inviting me. I'm very happy to be here. So today I'm going to be talking about order, policy enforcement limitations and circumvention.
00:00:10.282 - 00:00:29.106, Speaker A: So this is joint work with Lee Arthur Sahist who is in the audience over here. Luca, Aditya and Francesco, some of who are in the audience over here, and Fan at Yale. So the problem of state machine replication is one where a group of parties agree on sequence of transactions submitted by external clients.
00:00:29.106 - 00:00:37.618, Speaker A: And there are two key properties that you're looking for. One is safety and liveness. Safety says that any two non faulty parties do not agree on a different sequence of transactions.
00:00:37.618 - 00:01:00.666, Speaker A: And Liveness says that a transaction proposed by a client will be eventually executed by every non faulty party. So in this system, when transactions come in one at a time, at some point these parties decide to agree and output one block of transactions. And based on the order over here in this block, they ordered this gray transaction, followed by yellow and so on and so forth.
00:01:00.666 - 00:01:39.286, Speaker A: And similarly, they'll do so for the next batch of transactions as well. So if you looked at the animation closely, you would have seen that the arrival times of these colors were gray, followed by yellow, followed by blue, front by red. And at some intuitive level, if that is what happened and let's say it happened at all parties, then this ordering can be considered construed as okay or fair, right? But what if there is this modified ordering where let's say the red transaction was ordered before the blue one? Is this modified ordering okay? Is it fair and well, at a high level, the answer to this question is it depends.
00:01:39.286 - 00:02:01.086, Speaker A: It depends on the application. One way to think about this question is are the reordered transactions entirely independent of one another? For instance, if we have, let's say, party A making a transaction, sending a transaction to party B and party X, sending a transaction to party Y, these are entirely independent. They relate to independent objects.
00:02:01.086 - 00:02:17.222, Speaker A: So if you reorder, perhaps it's okay. It gets a little hairier if these transactions are dependent on one another. And over here, you have transactions generated by different honest clients that are dependent on one another.
00:02:17.222 - 00:02:28.700, Speaker A: But let's say they were generated without knowing the other one. And let's say they arrived at approximately the same time. And if you reorder, it's perhaps a little hairier on whether it's okay or not, whether it's fair or not.
00:02:28.700 - 00:02:54.930, Speaker A: But what most people do agree is that if this red transaction was created or generated after seeing this blue one, then that can be problematic because this is what is referred to as front running attack. And over here, the red transaction can actually yield monetary benefits to an adversary. And the set of parties can actually earn a lot of money by doing so, by introducing this transaction after the blue transaction.
00:02:54.930 - 00:03:07.142, Speaker A: So front running is one such attack. There are many other attacks such as Sandwiching and Censoring that are already well known today. So reordering is a problem.
00:03:07.142 - 00:03:22.006, Speaker A: And this has been recognized in the past four or five years or so. And there have been approaches to actually address this question. There have been two independent lines of work that I'm going to touch upon for this order policy enforcement.
00:03:22.006 - 00:03:39.262, Speaker A: And both of these lines of work are data independent. That is, when they order these transactions, they do not look at the content of the transaction, they just look at the metadata. The first line of work is on order fairness, where transactions are ordered based on arrival times, for instance.
00:03:39.262 - 00:04:00.620, Speaker A: So equitas themis CMSV are examples of this approach. And over here, the goal is to ensure correct ordering based on the times at which these transactions are received. For instance, if a transaction, transaction A arrives at all parties before transaction B, then A will be ordered before transaction B.
00:04:00.620 - 00:04:27.774, Speaker A: So you never get into the situation of asking, hey, are these reordered transactions independent or not? The second line of work is called content is what we call content oblivious ordering. And over here, you're trying to hide user transactions until they are ordered and then you reveal them. So you're attempting to prevent adversary ordering because when this ordering happens, the adversary does not know the content of the transaction.
00:04:27.774 - 00:04:52.102, Speaker A: So they may still have access to metadata to order them. And in this line of reasoning that we spoke about earlier, you're specifically trying to attack that last line where you're trying to say an adversary cannot order based off of by looking at a previous transaction. So both of these approaches attempt to get order policy enforcement.
00:04:52.102 - 00:05:25.918, Speaker A: The question is, well, do they prevent reordering attacks? Right? So at a first glance, you would say, well, isn't that the goal of these protocols? Well, the question is it depends. So over here in all of these protocols, correctness relies on a majority of the parties being honest. And if you think back, the reason why adversaries wanted to reorder was because of rationality, where they wanted to reorder and earn some monetary gains.
00:05:25.918 - 00:05:41.362, Speaker A: So there's a fundamental mismatch in the model in which the attack exists and these protocols work. So the question we want to really ask is are these protocols secure when all parties are rational? Or perhaps when all parties are rational. And then there are some Byzantine parties.
00:05:41.362 - 00:05:52.086, Speaker A: But we will look at the easier one where when all parties are rational. And this is what we're going to focus on today. So the rest of the talk would be comprised of two parts.
00:05:52.086 - 00:06:22.738, Speaker A: The first one is one where we are going to talk about these order policy enforcement protocols and show that they do not give you what they claim to give you when these parties are indeed rational. And second, we'll talk about approaches to circumvent this impossibility. Okay, so to talk about known op protocols and an impossibility for these known op protocols, we will first talk about a framework that captures them, and then we'll talk about the impossibility for this framework.
00:06:22.738 - 00:06:52.990, Speaker A: And to explain the framework, I'll start off with a simple example within the framework, which is a content oblivious ordering protocol called Threshold Encryption Based Content WBS Ordering. So this is the underlying so this is the technique used by Furvio, as well as Shutterized Beacon Chain, where there is an initialization step where you run a DKG protocol, where a public key and multiple these different secret keys skis are generated. And each of these parties have their own skis.
00:06:52.990 - 00:07:17.170, Speaker A: And when a user wants to submit a transaction, they can just encrypt this transaction using this public key and send it to the system. And there can be many other such transactions that are submitted, and eventually these parties would get on and order this transaction, order these transactions. So the ordering policy over here can be arbitrary because all of the transactions that they receive are encrypted.
00:07:17.170 - 00:07:39.614, Speaker A: And once this ordering has happened and once this is committed, for instance, then these parties engage in a process to reveal these transactions. They decrypt these transactions using secret keys. So the crux of the reasoning is that you're ordering without seeing the content, so it's fine to order them in any order.
00:07:39.614 - 00:08:20.438, Speaker A: Okay? So in particular, even if you have this red adversarial transaction that came in, even if the red transaction is before the yellow transaction, it's okay because the adversary could not see the yellow transaction when it was ordered. So more generally, it turns out that all of these protocols in both of these classes can be captured by a similar set of steps where there's an initialization, where you're setting public and private parameters, and then there's a transaction submission step where user submits transactions. And in the framework, we can have this process to be interactive or non interactive.
00:08:20.438 - 00:08:39.042, Speaker A: It can be to all the parties involved or to some subset of these parties. So we require that the users are ephemeral. And what that means is that you can engage in this interactive step, for instance, to submit transactions, but once you do, at that point, the users go away.
00:08:39.042 - 00:09:01.034, Speaker A: They are not required to come back and participate in the protocol. And finally, these parties can capture some local state, for example, the time at which these transactions were received. So once sufficiently many transactions are submitted, at some point the underlying consensus protocol would say, okay, it's now time to order.
00:09:01.034 - 00:09:17.680, Speaker A: At that point, an ordering protocol is executed. So if you're running a fair ordering protocol, this is where the ordering portion of fair ordering happens. For other protocols, like Content WS ordering, you can perform a random ordering or arbitrary ordering over here.
00:09:17.680 - 00:09:33.074, Speaker A: And finally, there's an optional step which is not performed by fair ordering protocols. And this is the transaction revealed step. So this is the general structure for the framework, and there are two additional constraints that I will mention.
00:09:33.074 - 00:10:07.440, Speaker A: So the first one is a binding property, which says that a transaction executed by the protocol is the one that is submitted to it. So if you think about it, this is like a constraint that should hold for every protocol, right? If I say I'm going to buy 50 tokens of A, I'm indeed buying 50 tokens of A, the protocol should not execute sell 50 tokens of A, right? But at the same time, I'm mentioning this because I'm going to revisit this property at a later point. And second, we assume that between after ordering and before revealing the state of the transaction does not change.
00:10:07.440 - 00:10:27.320, Speaker A: So, in terms of the actual number of bits, that is, you have the ability to run reveal if you want at any point in time. And this specifically rules out protocols that use time lock encryption. And finally, I'll mention again that we are assuming ephemerality of clients, that is, once they submit, they go away.
00:10:27.320 - 00:11:03.866, Speaker A: So, so far as these constraints hold and protocols are in this framework, what we argue is that if these protocols can be attacked, then they will be attacked. In particular, if there's a protocol Pi, which is following this ope framework, enforcing a data independent policy, P, run by a set of rational parties, then for a given input, if there exists a way to reorder transactions and earn a higher utility by not satisfying P, then Pi will not follow P. Okay? So the third constraint over here is fairly imprecise.
00:11:03.866 - 00:11:24.920, Speaker A: So let me make it a little more precise. Yet it'll still be a little informal, where let's say your input order was T one through TL. And for this input stream, let's say among all the possible ways of ordering it, let's say for the parties, TSEC is the ordering that yields the maximum utility, U.
00:11:24.920 - 00:11:57.906, Speaker A: Okay? And let's say there exists another sequence, TSEC prime, that can be obtained by reordering these transactions, t one through TL in such a way that it is not satisfying P for the original stream, but it is still satisfying the policy for some input stream. And in that input stream, you have a higher utility, higher than U. In that case, even if you are in the first world, you would actually output TSEC prime, and that is Pi will not follow P.
00:11:57.906 - 00:12:28.250, Speaker A: And this function extract that you see over here is the mev extraction function that you're thinking about intuitively. So the crux of the argument over here is in two phases. First is to define an attack protocol where there is an attack algorithm run by all parties using this te, and then showing that even if this attack is performed, no one can say that this attack fails.
00:12:28.250 - 00:12:54.130, Speaker A: This attack was actually performed. So our attack algorithm is run by all parties using a te where they first reveal all of the transactions within the te, and then they run this extraction function, which can be a composition of all possible extraction functions that we know of. And then within the Te, they replay these extracted functions and order them and publish this new state as if a different set of transactions were submitted.
00:12:54.130 - 00:13:28.160, Speaker A: And then we can show that an attack world that I just described is very similar to a different world, a world two, where the input stream was very different and an okay output or a valid output for this policy, p was TSEC Prime. And over there, since you can get a higher utility and you cannot identify that world one was never the real world, that is why you can still have utility U Prime. And that is why parties are okay to attack in world one.
00:13:28.160 - 00:13:44.222, Speaker A: So with that, let me move on to the next part of my talk. So there is this impossibility result. How do we circumvent it? There are two ways of circumventing the impossibility, and this is based off of the two constraints that we laid out earlier.
00:13:44.222 - 00:14:04.810, Speaker A: One is ephemerality of clients, and second is the binding property. Relaxing? Each of these properties individually can yield protocols that circumvent this impossibility. So let's go with the first one, where we require the clients to stay until their transaction has been added or committed to the chain.
00:14:04.810 - 00:14:30.978, Speaker A: So in such a situation, the protocol is really simple, right? The client submits a commitment to the transaction, and you reveal the transaction content only after it has been committed. Since an adversary can never see the transaction content, of course it cannot attack or reveal based on the content of the transaction. A drawback over here is it requires the clients to be online, which is cumbersome for the clients one.
00:14:30.978 - 00:14:52.230, Speaker A: And at the same time, clients tend to be fickle. So it's not good for the protocol either. One way around this is to use tes to escrow this information, where let's say parties are holding these tes and they will reveal only if this content or a commitment has actually been committed.
00:14:52.230 - 00:15:25.438, Speaker A: So this is one approach. The other more interesting approach from an idea standpoint, is this relaxing the binding property where we ask this question what if the transaction submitted by the user is not guaranteed to be the one that is committed and executed? I think going back to the example I gave, what if my transaction says buy 50 tokens of A? And actually what happens is what gets executed can perhaps be sell 50 tokens of A. So that can be problematic.
00:15:25.438 - 00:15:46.890, Speaker A: But let's say that does not happen in most cases, and in particular, so far as most parties are rational or a specific subset of parties are rational, that wouldn't happen. So at that point, we are relaxing this property to be rational binding. Where this binding property holds so far as some subset of parties or stakeholders are rational.
00:15:46.890 - 00:16:09.460, Speaker A: In that case, what we show is that you can create a protocol where you can ensure that sandwiching attacks do not happen in AMMS. This is like a specific subset for a given application. But let's try to understand what sandwich attacks are and how we can relax this binding property in this case.
00:16:09.460 - 00:16:52.698, Speaker A: So in AMMS, you can trade one quantity for another, and the rate of exchange that you get depends on the availability of supply of the good that you're buying, right? So your transaction can be buy Y tokens of A for X tokens of B, and there can be a slippage parameter. So this Y for X is something that the user decides based on the state of the system, which can change a little bit between the user submitting the transaction and it executing, because of which it provides the slippage. Parameter which says that I'm willing to tolerate up to getting one minus s times y worth of tokens instead of all of the y tokens.
00:16:52.698 - 00:17:25.340, Speaker A: And this is something that an attacker can exploit using a sandwich attack, where before executing this user's transaction, the attacker executes a different transaction that reduces the supply of A and it reduces enough so that the user exactly gets one minus S times Y. And then the user's transaction is executed at an inferior price. And then the attacker will sell this transaction, will execute a reverse transaction, where in the process, it will earn some additional tokens in terms of B.
00:17:25.340 - 00:18:18.394, Speaker A: So the question is, what if some information was withheld from these attackers and they do not know the polarity of their transactions? So what if instead of buy A, the transaction was indeed sell A? At that point, attackers would lose money by performing this attack and users would obtain a price that is much better than what they were initially anticipated. So the idea is, if in some situations you can gain some money, can the user actually use this to incentivize some party to actually hide the polarity? And this is the party that we call a flipper in our protocol. And we want to incentivize this flipper, which is a designated party among the set of parties, and we want to incentivize this flipper to confuse the rest of the parties so that the flipper can earn a lot of money.
00:18:18.394 - 00:18:32.014, Speaker A: So we are trying to create a separation between the set of parties that exist. So to explain this bit, I'm going to go fast, but I'm going to do it in two parts. First, I'm going to assume that this flipper is honest and show how everything works.
00:18:32.014 - 00:19:01.100, Speaker A: And then we'll talk about how to incentivize the flipper. So if we have an honest flipper, the protocol can simply be the following, right? When you create a transaction, let's say you have a buy transaction, you first toss a coin. If this coin says zero, then I'll actually sign and share this buy transaction with all of the parties instead of this coin is one, then even if I want to buy, I'm actually going to send a sell transaction to everyone.
00:19:01.100 - 00:19:33.410, Speaker A: Okay? And in addition, so that the flipper knows the truth, I'm going to share an unsigned bit with the flipper. So intuitively, the reason why this bit is not signed is because the flipper is eventually it's going to be rational and you do not want the flipper to collude with the rest of them. So now that you have, you can run any content oblivious ordering protocol and the only addition that you would have is the flipper will reveal this bit b after the transaction is committed.
00:19:33.410 - 00:19:42.360, Speaker A: At this point, it turns out that you can make two guarantees. First is correctness. If you have an honest flipper, it will always reveal the correct bit.
00:19:42.360 - 00:19:53.210, Speaker A: So I wanted to buy transaction even though on the chain it is a sell. After the flipper reveals this bit, it would again turn into a buy. So a correct transaction would be executed.
00:19:53.210 - 00:20:17.060, Speaker A: And second, the gains over here for an attacker depends on its ability to correctly guess the polarity of the transaction. So if it's able to guess the transaction polarity correctly, it would have gains, otherwise it would not. So if it's like a 50 50 chance, then the adversary does not have any gains over here.
00:20:17.060 - 00:20:59.550, Speaker A: So the last bit over here is how do I incentivize this flipper to do the right thing? So the first thing it needs to be incentivized to do is that the flipper needs to be incentivized to not reveal the correct bit to the other parties that is not collude with the other parties. And for that we create a separate transaction where in situations where the user gains some money and the other party guesses incorrectly, at that point, the flipper would earn some money in the process. And the second part is if the flipper cheats in the sense that an incorrect transaction is executed and the eventual bid that is revealed is incorrect, the flipper needs to be held accountable.
00:20:59.550 - 00:21:20.920, Speaker A: And over there, there is a penalty mechanism that we introduce to make this happen. So I'll mention that this is an interesting idea, but this is still a work in progress because there are some caveats over here. For example, if I'm switching from a buy to a sell and if I actually do not have that many transactions, it may not work.
00:21:20.920 - 00:21:39.130, Speaker A: So I think this is an idea that we are very much exploring right now. So to conclude, we spoke about two things. One is data independent ope protocols that follow the framework are not secure when all of these parties are rational.
00:21:39.130 - 00:21:50.526, Speaker A: And second, we spoke about two ways to circumvent this concern. One is relaxing the ephemerality of clients and second is relaxing the binding requirement for a transaction. Thank you.
00:21:50.526 - 00:21:52.080, Speaker A: And I'd be happy to take questions.
00:22:03.570 - 00:22:25.194, Speaker B: Great presentation, by the way. How do you discern that the flipper was honest after the events occur? Because you presented in the earlier part of the talk that it's hard to discern at times if honest parties alienate out of rationality. So how do you actually determine that a flipper flipped, I guess, on the protocol to penalize them.
00:22:25.312 - 00:22:53.860, Speaker A: So I think the reason why I introduced honesty is just so that it becomes easier to understand the scheme over here. In the protocol itself, we are not requiring the flipper to be honest. So in the end, the flipper essentially makes a promise to the user that I will send in the correct bit and using that promise, the user can come back and at any point in time two weeks from now, penalize the flipper and say, slash so much amount of money because the flipper has lied at a later point.
00:22:53.860 - 00:23:00.440, Speaker A: So the flipper is kind of making a commitment only to the user to say that I'm going to do the right thing.
00:23:02.870 - 00:23:11.618, Speaker C: Good question. Wouldn't you have to pay the flipper at least as much as the sandwich attack was worth? Because otherwise they could just shift strategy and sandwich you.
00:23:11.784 - 00:23:12.690, Speaker A: Sorry, come again?
00:23:12.760 - 00:23:19.654, Speaker C: So if the flipper is rational, right, like, wouldn't you have to pay the flipper at least as much as a sandwich stock would have cost you?
00:23:19.852 - 00:23:45.786, Speaker A: So it turns out that if you change the polarity of the transaction, you can earn a lot more in the other direction under some parameters and then you can give the balance. So let's say the exchange rate was Y for X, right? So the user can still get Y for X. And there is the other side of the gain because of the user is not paying out off of its pocket the set of attackers who attacked.
00:23:45.786 - 00:23:49.246, Speaker A: They are going to lose money and that is going to go to the flipper, right?
00:23:49.268 - 00:24:10.178, Speaker C: But this assumes that you don't change strategy because you know that this is going to happen, right? So you'd probably reduce the amount you would sandwich such that you would not get that profit on average. So essentially what it means is at the end of the day, I think you'd still have to pay the flipper roughly the amount that you expect to get sandwiched by. Otherwise they would just do the same attack if they were rational.
00:24:10.178 - 00:24:28.910, Speaker C: The point is you have to pay the flipper at least as much as they would earn by performing the attack. Otherwise they would just do it because we're assuming that they're rational, right? They would just shift the strategy. So I guess I don't know how to square these two things.
00:24:28.910 - 00:24:30.686, Speaker C: Does that make sense? I don't know about sure.
00:24:30.708 - 00:24:32.026, Speaker A: I think maybe let's set off mine.
00:24:32.058 - 00:24:45.700, Speaker D: Okay, two questions. One, do what do you call it? Does the AMM require integration with the flipper? Is there some kind of specific handling that they need to set up.
00:24:47.030 - 00:25:03.750, Speaker A: So over here, from a protocol standpoint, after the transaction is committed, you need the Flipper to send in a bit. So in that sense, there is something that is required, because even after the transaction is committed, the Flipper needs to provide an input, and that is a transaction that would be output.
00:25:03.910 - 00:25:29.618, Speaker D: And then, secondly, it seems that somebody who is malicious could always say or mess with the polarity. So it's kind of like a denial of service or censorship. Is there some kind of strong incentive to prevent that? Just mainly, like, if you see large transactions happening, it could seem very cheap to attack the network that way or attack the AMM that way.
00:25:29.704 - 00:25:39.230, Speaker A: Sure. I think that is exactly what we're giving up to circumvent the impossibility over here. So I think a Byzantine Flipper can indeed do something incorrect.
00:25:39.230 - 00:25:44.360, Speaker A: It would be penalized, but it can perform such an attack. Thanks.
00:25:46.810 - 00:25:56.490, Speaker C: How is a flipper selected? Is it a permissionless role or is it predetermined? Is there any reputation for continuing to be a Flipper longer term?
00:25:57.790 - 00:26:15.610, Speaker A: So we do not specify how to do it. But one reasonable thing could be if you're running a content oblivious ordering protocol, there is a reveal phase. And during this reveal phase, whoever is proposing the block, that is the party that can act as the Flipper.
00:26:15.610 - 00:26:25.600, Speaker A: It kind of makes sense to do it that way, because at that point, you're not waiting for an input from someone else. Thank you.
