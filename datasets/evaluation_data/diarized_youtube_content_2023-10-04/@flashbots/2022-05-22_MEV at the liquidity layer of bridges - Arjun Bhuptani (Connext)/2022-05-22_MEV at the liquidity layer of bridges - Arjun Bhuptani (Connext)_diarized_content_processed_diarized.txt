00:00:10.490 - 00:00:13.886, Speaker A: Hi, everyone. My name is Arjun. I'm one of the founders of Connect.
00:00:13.886 - 00:00:35.270, Speaker A: This talk is about cross chain mev at the liquidity layer. What it's really about is how to or how not to build a cross chain dex. So unfortunately, I got front ran by James on that one, MAV it again before I start this talk, I think the reasonable disclaimer here is that it's super early.
00:00:35.270 - 00:00:50.714, Speaker A: This is actually probably the first time in any formal setting that people have talked about crosschain Mev. We have all individually talked about it separately and thought about it in our rooms by ourselves. And it's very unclear at this stage what that collection of thoughts will lead to.
00:00:50.714 - 00:01:44.190, Speaker A: So rather than try to impose some sort of taxonomy, I decided with this talk to have much more of a thought experiment approach, which is, I'm going to try to take this theoretical problem of how do you build a cross chain dex and just try to examine what it looks like to attack the system from an mev perspective based on the type of construction that you have. So, first question, how do you build a crosschain AMM or crosschain dex? I think the first thing about this is that the notion of a cross chain dex or crosschain AMM means different things to different people because there's actually several different ways to build this. And so instead of doing that, I'm going to change that question into how do you go from X asset on one chain to Y asset on another chain? It's just a much easier problem to think about effectively and ideally without ridiculous changes in pricing.
00:01:44.190 - 00:02:10.294, Speaker A: Now, when most people think about this, the first thing that they think of is just an existing AMM construction where you have one pool of each asset and then you just have instead of having all of that happen on a single chain, you have one pool of each asset on each chain. Of course, this makes sense, right? Because you're like, I don't want to minimize capital usage. I want to make sure that I don't end up with duplicate assets on every single chain that I have to now deal with.
00:02:10.294 - 00:02:43.054, Speaker A: But this also has some problems because you're making some very important assumptions about distributed systems and about cross chain communication here, which, as we'll see, are kind of bad. So the big assumption here is that with AMM pricing, you are taking the price or the state of a pool on one chain. Or I guess if consider that this is on a single chain, the state of a pool in one asset at a certain time, and then the state of a pool of another asset at the same time, and you're using those two things together to determine your price.
00:02:43.054 - 00:03:06.150, Speaker A: So in the cross chain case, you're taking your X pool state S zero at the initial time you're pushing it across chains, and then by the time it gets across chains. You now have the state of pool s zero x s zero at time t one, which means it has taken some time for this message to go across chains. Of course, because blockchains are quantized, it will take at least one block.
00:03:06.150 - 00:03:20.780, Speaker A: And as we know now, you have the wrong state on the receiving chain. And of course that data is garbage, or in this case, a very small Poop. I couldn't figure out how to resize this.
00:03:20.780 - 00:03:40.530, Speaker A: Why is that a problem? Everybody has seen this graph and at this point it's been beaten to death. But this is the best kind of like straw man example that we can come up with in an X y equals k AMM curve. Your assumption, of course, is that K mathematically is a constant.
00:03:40.530 - 00:04:01.610, Speaker A: This assumption is kind of violated in this case because you have the state of your initial liquidity pool at a certain time and the state of your second liquidity pool on the receiving chain at a different time. And you're mashing these two things together. And now it's no longer clear whether your K is actually a constant.
00:04:01.610 - 00:04:24.420, Speaker A: And this is actually compounded by Yaboy Mev Bandit, who may try to manipulate the prices of these different or manipulate the sizes of these different pools to create something that looks like this. This is obviously garbage. You don't want this to happen to your AMM curve because more confusion along pricing means more opportunities to extract value.
00:04:24.420 - 00:04:58.810, Speaker A: So what can you do about this? Well, a lot of chains, a lot of different kinds of cross chain bridge approaches try to take the approach of having an Oracle off chain. So now you have, instead of trying to synchronize all of the state of these two pools on a single chain, you try to synchronize them off chain. Now in this case, what you're basically doing is having this Oracle entirely storing the data for all of the pools at all of the times and then pushing in the pricing into your liquidity pool into the receiving chain contract.
00:04:58.810 - 00:05:08.026, Speaker A: How you do this is slightly different. In some cases I have two of these slides. In some cases this could be a more kind of decentralized network.
00:05:08.026 - 00:05:21.342, Speaker A: But in the simplest possible case, it's coinbase. I think the problem with this approach, of course, is that you are introducing a massive amount of trust. You are basically saying that everything associated with this system now exists off chain.
00:05:21.342 - 00:05:31.122, Speaker A: Decentralizing things off chain is a giant pain and it's ideal to avoid it if you can. And so generally we consider this to not be a great approach. Of course, there's some exceptions.
00:05:31.122 - 00:05:56.154, Speaker A: People are doing some interesting things with decentralized order books, but I'm going to leave it at that because I only have a certain amount of time. Can you actually sync the state of these things against each other with onchain pricing like you kind of want to with DEXes today. Unfortunately, turns out you can't because this is a two party distributed system and anybody who is in distributed systems knows two party distributed systems are awful and they don't actually have a solution.
00:05:56.154 - 00:06:05.026, Speaker A: There's no way to synchronize state between two parties in a distributed system. And this is called the two Generals problem. You can formally prove that this is not possible.
00:06:05.026 - 00:06:30.634, Speaker A: So shit. What about the other approach that James suggested? What happens when you have a bridge to Dex or Dex to bridge or a bridge to Dex to bridge approach? I've chosen to only show the bridge to Dex to bridge approach here because it's the most kind of complex one. But of course, much of this applies to the approaches, other approaches as well.
00:06:30.634 - 00:06:44.110, Speaker A: Now, in this case it's kind of nice because you don't have state synchrony across chains. You have individual pairs of AMMS with their own individual on chain pricing on each separate chain. And what you're pushing around is the asset itself.
00:06:44.110 - 00:06:57.694, Speaker A: Instead, Hop does this, we kind of do this. And there's a bunch of other projects that kind of are starting to think about this. Now, of course, as James mentioned, this five X is your potential mev attack scenario.
00:06:57.694 - 00:07:25.178, Speaker A: So let's just ignore that for now and we'll get to that at the end. The cool thing about this, and I think this is me just being liking dynamic equilibrium systems, is that you have this kind of system where the thing that keeps pricing in check across chains is not some mechanism, some on chain mechanism where you're guaranteeing that the pricing has to be the same, but just market effects. You're just assuming that people will arbitrage the system.
00:07:25.178 - 00:07:49.182, Speaker A: Any sort of opportunity that exists between these two assets can be arbitraged away to the point where these prices actually make sense against one another. Now of course, this is not always the case and this is where things get kind of complicated. What happens if it costs either a lot of time or a lot of money to arbitrage these two systems? Well, now, the variance between the two systems, I couldn't figure out a better way to represent this than to just put little dollar signs everywhere.
00:07:49.182 - 00:08:06.550, Speaker A: But the variance between these two systems changes very dramatically. This happens in Prod and it actually happened last year with the Matic token because the Polygon bridge. So Matic Token is the only token on the Polygon Bridge that actually requires the full seven day exit window.
00:08:06.550 - 00:08:23.126, Speaker A: And so there was a period of time last year where the difference in price between Maddox on Polygon and then on Ethereum was like over ten to 20%. It was kind of wild. And no one was actually able to arbitrage this thing because there was just no capacity to bring that liquidity over fast enough.
00:08:23.126 - 00:08:50.818, Speaker A: So eventually it got arbed away. But that was only because a bunch of exchanges added support for Matic really quickly to try to close the loop on this complex, not what you want. This actually gets even more complex when you think about, again, yaboy, and this is where we get into the five X mev case where of course you have the mev associated with doing this swap on each chain individually because each of these things are their own individual AMMS.
00:08:50.818 - 00:09:10.006, Speaker A: But now you also have to think about what happens when someone sees the initial transaction and then sees that you are making a bridge transaction to your receiving chain. And now on the receiving chain, you're planning to do another AMM swap. Well, whoever is trying to front run this attack now has however long it takes for the message to go across the bridge.
00:09:10.006 - 00:09:20.286, Speaker A: And then of course also however long it takes for you to do the secondary transaction on the receiving chain, which is also kind of shit. Now, there are ways to deal with this. James touched on this.
00:09:20.286 - 00:09:42.342, Speaker A: This is something that we've explored as well, which is you hide the transaction information. So you could basically do the AMM swap on the sending chain and then have call data that is encrypted and hashed and you emit the encrypted data in an event. And then you require that whoever's kind of completing the transaction on the receiving chain decrypts the data prior to submitting it.
00:09:42.342 - 00:10:00.922, Speaker A: It's really complicated as well. But there are ways to potentially shield the data that is going over the bridge and that limits the risk to just two places where you can brief front ran. And of course that means you're only being front ran in the ways that you are already being front ran.
00:10:00.922 - 00:10:14.880, Speaker A: Hooray mev and crosschain stuff is really terrible. It's a much darker, much more forest DeForest. And that's why I said that this is still super early.
00:10:14.880 - 00:10:47.658, Speaker A: If you guys are interested in this topic, definitely come talk to me. But I think in general, there's a huge space to make a mark on research in this right now because nobody really understands it. So what can we derive from this set of ideas that we went through in this talk? Not any sort of formal structure whatsoever, but we can see that some types of construction constructions for crosschain applications yield worse types of mev state synchronization is bad.
00:10:47.658 - 00:10:58.894, Speaker A: You should really never try to do that. It's fundamentally not actually possible. And so if you try to do that, you end up in kind of weird situations, which I'm pretty sure there are a couple of production AMMS out there that are doing this.
00:10:58.894 - 00:11:09.170, Speaker A: I'm pretty sure Synapse is doing this. And if they're not doing that, then they're doing completely off chain pricing, which is super custodial. But if they're doing this on chain, I'm reasonably sure that's why they have extremely high slippage.
00:11:09.170 - 00:11:37.574, Speaker A: Don't do this. Conclusion number two, this core model we've been talking about was around DEXes, but you can actually extend this to any sort of application where you're thinking about liquidity across different systems because the pricing of that liquidity still matters. So even if you're not dealing with a Dex and you're dealing with like, cross chain Aave, if you create situations where you're borrowing on one chain and lending on another and I don't just mean that from a user experience perspective, but I mean that from an actual contracts liquidity pool perspective.
00:11:37.574 - 00:12:08.630, Speaker A: Synchronizing the state of your pools across chains now introduces variance in the size of those pools, which means now your protocol is sometimes potentially operating as a credit protocol, which is bad. So now you have to actually increase the amount of gap between the borrowable funds and the amount of liquidity in your system because you have to account for this and you have to think about the possible. Like you have to set limits on the max amount that can be borrowed on a certain chain because you have to hedge against this risk.
00:12:08.630 - 00:12:46.162, Speaker A: Could this mean we end up in a world where rather than having fragmented liquidity pools across chains, which by which I mean you have one pool on each chain, you end up in a lower capital efficiency scenario where you actually have replicated instances of DeFi protocols and then just synchronize via arbitrage between them? Probably at this time, the only other approach that we've been able to think of is, like, having semaphores in your liquidity pools, which is really not what you want to do. Basically that means you have locks on your liquidity pool, so you end up fragmenting inside of your liquidity pool. You fragment subsections of it.
00:12:46.162 - 00:13:01.190, Speaker A: This is how Stargate works, for instance, which is incredibly complicated. And that complexity leads to more edge cases and potentially more mev. And then, of course, last conclusion, it's still early squared.
00:13:01.190 - 00:13:16.490, Speaker A: Again, if you have any ideas about this or even an interest in this, help us, help this community try to understand it better. It's so, so early, and it's a big open problem, and there are tons and tons of people who will fund your research. Cool.
00:13:16.490 - 00:13:38.204, Speaker A: That's my talk. Thanks everyone. Do I have time for Durant questions? Wow, that must have been a guitar.
00:13:38.204 - 00:13:38.850, Speaker A: Okay.
00:13:48.680 - 00:14:04.920, Speaker B: Hi. It's not super related, I guess, but the previous guy talked about atomic swaps and how they're not feasible because he didn't like them, because there's denial of money attacks and stuff like that. Do you have anything to say on atomic swaps?
00:14:05.500 - 00:14:22.812, Speaker A: Yeah, for context, james and I work really closely together. Connects actually builds on top of Nomad, so we're sort of like a liquidity layer that sits on top of them. And then we also allow for a lot of like we mitigate some of the trade offs of Nomad, and Nomad mitigates some of the trade offs of our current stuff.
00:14:22.812 - 00:14:42.180, Speaker A: The way that our current stuff works is using Atomic. Like, okay, the way that we approach it is that we decided not to deal with pricing at all in our Atomic swaps, and they're always one to one assets. And so you're not really doing like a cross chain Dex in any way, but we're basically doing one to one assets across chains and then swap on an AMM.
00:14:42.180 - 00:14:54.916, Speaker A: And that does seem to constrain a lot of the risk quite a bit. At the same time, the user experience is shit. That's a big part of the reason why we're doing a network upgrade to use Nomad instead of using our current system.
00:14:54.916 - 00:15:33.200, Speaker A: Because even in the best possible case and we've really gone out of our way to optimize the shit out of this, it's like even in the best possible case, you're still assuming that the user is able to, one, be live to sign a message or produce some sort of proof on the receiving chain to unlock their funds. And in some cases with some chains that transaction can take like ages because just got stuck somewhere. And two, you're also assuming that the person who is executing basically like facilitating the swap, who is the liquidity provider of that swap, will stay live between the time at which the user decided to work with them and they did the transaction on chain.
00:15:33.200 - 00:15:55.460, Speaker A: Now, initially we were like okay, that's not that bad. In the optimistic case, it's like two minutes, two minutes of aliveness condition. Not too bad, right? And we were thinking maybe we can do slashing conditions to penalize routers that go live or our connector routers being our nodes that go offline between the time at which they committed to making a transaction and then doing the on chain transaction.
00:15:55.460 - 00:16:10.944, Speaker A: As it turns out, even two minutes of liveness is really, really bad as you get to larger and larger numbers of transactions. That edge case that was like 0.1% starts happening once or twice a day and it's a horrible user experience each time.
00:16:10.944 - 00:16:26.820, Speaker A: So I think that's the general reason that people have moved away from pure atomic swap models is that you just end up in these kinds of sticky situations around liquidity lockups and signatures and off chain dependencies that people just want to avoid.
00:16:33.140 - 00:16:38.784, Speaker C: Hello. Hi. So my name is Azfar so I'm going to see if I try if I understand this correctly.
00:16:38.784 - 00:16:55.130, Speaker C: So Connect uses routers that exist on different chains, right, providing liquidity. So my question is, is it possible for these routers that exist on different chains to be their own mev actors whenever they see this bridging happening?
00:16:57.280 - 00:17:20.736, Speaker A: Yes, I think anybody in the system could be an mev actor. I think routers. So with the way that our old system works, it is possible for routers to get some amount of market information prior to the rest of basically information asymmetry, which is bad because that's how you create a select group.
00:17:20.736 - 00:17:30.980, Speaker A: Of actors that is really benefiting from this in the new system that no longer exists. Now everyone has information symmetry about how easy it is to front run. So it's slightly better.
00:17:30.980 - 00:17:44.090, Speaker A: But of course it's still map vulnerable. Again, no solutions here, only problems. I think we have time for one more question.
00:17:44.090 - 00:17:53.380, Speaker A: Cool. Awesome. Thanks everyone.
00:17:53.380 - 00:17:58.470, Speaker A: If you have any other questions or think of anything, come find me. I'll be around. Thanks a lot.
00:17:58.470 - 00:18:13.050, Speaker A: Clipping shipping close.
