00:00:09.290 - 00:00:11.818, Speaker A: Yeah. Thanks for coming, guys. I know this is a last presentation.
00:00:11.818 - 00:00:18.910, Speaker A: You know what they say, save the best for last. So this is my talk. Don't reinvent the GEF wheel.
00:00:18.910 - 00:00:27.800, Speaker A: I know there was very technical, technical speech before me, so this will be the complete opposite. It's very be untechnical. So I hope you guys enjoy it.
00:00:27.800 - 00:00:35.858, Speaker A: So, yes, I am library ethereum virtual machine. I'm a couple of things. I'm a mempool inspector.
00:00:35.858 - 00:00:47.020, Speaker A: I'm a sandwich connoisseur. And I'm kind of here mainly because I kind of wanted a free ticket to mev day, which is why I'm on stage right now. Yeah.
00:00:47.020 - 00:00:58.634, Speaker A: So I don't really claim to know everything. I know some of the giants. I'm standing on the shoulders of the giants.
00:00:58.634 - 00:01:02.506, Speaker A: The GEF creators are here. I know the forge creators are here. I use those tools.
00:01:02.506 - 00:01:09.074, Speaker A: I'm a humble searcher. I don't claim to know anything. So if you see anything wrong, you can honk at me if you want.
00:01:09.074 - 00:01:16.760, Speaker A: Or if you guys are in Amsterdam these days, you can do the bicycles. I got rang by a lot of the bicycles. You can also do that if you guys are up for that.
00:01:16.760 - 00:01:29.898, Speaker A: Yeah, I guess. Before we start, I would like to talk about something pretty serious. Let's talk some numbers here, I guess.
00:01:29.898 - 00:01:57.150, Speaker A: How many euros worth of mev has been extracted? Does anyone have an idea? Like, since the inception of Flashbots, does anyone have any idea? €800 million? Yeah? Anyone else? No? Okay, well, it's a little bit off. It's actually €550,000,000 total extracted mev. And you can get that from Explore.
00:01:57.150 - 00:02:01.762, Speaker A: Flashbots. Net. And I know there's a couple of Americans out there.
00:02:01.762 - 00:02:10.150, Speaker A: The mic look like a funny symbol, the Euro symbol. So I'll kind of convert it to empirical units for you, which is roughly about 0.6 of an Andre.
00:02:10.150 - 00:02:18.620, Speaker A: Well, that's a current market. Current. Today's exchange rate might differ.
00:02:18.620 - 00:02:44.058, Speaker A: I'm also very confident that approximately 100% of the mev extracted are being extracted by people who are not in this room right now. I mean, why else would you guys listen to my talk if you guys could extract it? Right? I think that's because this is like the average perception. This is the perception of the average mev searcher.
00:02:44.058 - 00:03:28.700, Speaker A: I know this is like a huge brain dump, so I'm going to let you guys read that for a couple of seconds while I take a sip of water and unironically it. Kind of fits into the previous slides, the previous presentation, which was incredible, by the way, I did not understand any of the Greek symbols. Can everyone read the text on it? We good? Okay, just making sure.
00:03:28.700 - 00:03:48.480, Speaker A: The previous slide basically gave you a glimpse into what people think is the average mev searcher. But this is in reality, a lot of mev searchers like to make things that just works enough. And this is my favorite example.
00:03:48.480 - 00:04:01.694, Speaker A: It's a manual calculator. It checks both of your numbers and checks the operator, and it pre computes the result and it prints it for you. I also like to highlight the number of lines.
00:04:01.694 - 00:04:30.010, Speaker A: That's 20,000 lines right there for a calculator, like a very simple calculator. This is actually not really far from reality, as my favorite Twitter friend here togat PvP, actually has his first Mev bot, which is about actually, originally about 16K lines, was printing money in one file, I might add. So this is actually there's a very stark contrast between reality and perception.
00:04:30.010 - 00:04:54.480, Speaker A: Just want to point it out there. So a lot of you might be asking, why are you here today? Why are you showing me all these slides? Well, I've been getting a lot of DMs on the Bluebird app asking me to share my mev knowledge. And if I share it correctly, if I share it and they're able to profit, they'll share half the profits to me, which is incredibly generous.
00:04:54.480 - 00:05:10.260, Speaker A: So today I'm going to teach everyone how to get a real job, which is doing mev. If you can't describe your jobs in three words, I'm sorry to say, but you have a bullshit job, my friend. I do mev.
00:05:10.260 - 00:05:25.400, Speaker A: That's the correct and real job. In the words of Gavin Wood, give me GEF or give me def. GEF is the standard choice for mev extraction.
00:05:25.400 - 00:05:36.556, Speaker A: GEF loves mev. Even the official flashboard client, Mev GEF, is fought from the Go ethereum. And if you look at the Mev GEF client, you would see that I made a PR.
00:05:36.556 - 00:05:46.412, Speaker A: I pushed the request. So I'm actually a contributor to Mev GEF. In fact, I even wanted to be the community manager for Flashports, but I got rejected.
00:05:46.412 - 00:06:01.424, Speaker A: So if anyone out there is hiring for community managers, I'm just saying I'm on the market. So, yeah, these are the three features from GEF that I've found really helpful. State overrides tracer and GraphQL.
00:06:01.424 - 00:06:10.500, Speaker A: And we'll kind of go through them bit by bit. They've helped me tremendously in my journey of mee searching. Went from zero to hero.
00:06:10.500 - 00:06:19.172, Speaker A: Managed to land from zero bundles to a couple bundles. Yeah, it's very, very useful, and we'll get to it. So state overwrites.
00:06:19.172 - 00:06:38.876, Speaker A: What is it? Why do I care? Why does it matter? In fact, something really interesting was I met a guest developer the other day who wrote I think he wrote the State Override features, and he was shocked to hear that I was actually using it because he said, nobody uses that. Why do you use that? So here, I'm just letting it get a little cena. I think his name was Cena.
00:06:38.876 - 00:07:15.788, Speaker A: I have a slide just on State Overrides just for you. So I guess the most common problem that occurs for searches is, like, how do you test your new contracts in production? Because I think it's a lot easier on L two S because you don't need a factor in gas deployment costs. So if you've made your smart contract and your bot logic, how do you test your new smart contract? Because it's really hard to replicate the production environment when an ARB opportunity comes.
00:07:15.788 - 00:07:41.110, Speaker A: How do you actually test it? How do you actually do the whole integration test between your bot logic, the smart contract, and the bunt and the transaction, the mempool? How do you combine those and how do you test that in real time? That's actually really hot. And we're all really familiar with Vitalik's law, which is the closer you are to deploying a contract, the higher the gas fees shoot up. So state overrides help you avoid that.
00:07:41.110 - 00:08:04.330, Speaker A: So an EF call, which is an RPC method in GEF, it allows you to execute a new message. It's basically used as a view only method. But in some situations, like the univ three quota, it's like a little hack where you can call mutable functions, but you call it a view only method to kind of extract out a value.
00:08:04.330 - 00:08:28.450, Speaker A: So that's essentially eve call, it does a call, a view only call. But you can do it on mutable functions, it's just that it's not recommended. So for example, if I did an if call to this transfer function which returns success, I can kind of simulate that on main net to see if it will return a successful transfer.
00:08:28.450 - 00:08:43.656, Speaker A: That's assuming that you're following the ERC 20 standard because if you're USDT, you don't really return anything. So this wouldn't work if you're trying to simulate it for USDT. So this is how you would sort of use it, use the RPC function.
00:08:43.656 - 00:09:07.420, Speaker A: You do an e call, you supply like some kind of contract payload, some kind of data that you encoded abi encoded data from know, the usual. But what people don't realize is that with E call you can actually add there is actually a couple you can actually add a third object. The second object is a block number, which is by default latest.
00:09:07.420 - 00:09:29.076, Speaker A: But on the third parameter you can have this object called known as a state overwrite set, where you can overwrite certain features in you can overwrite certain state. So for example, you can overwrite the balance of a contract or an account, you can overwrite the nons of an account, you can overwrite the code of an account. You can overwrite the state.
00:09:29.076 - 00:09:50.632, Speaker A: When I say state, I mean like the storage values, like the key mapping, the raw storage values. Like when you read from I think it's levels DB or something, when you read from levels DB, like what's the raw value in there? And you can specify a state difference, which is a very subtle difference. It's basically to override the individual slots, whereas the state would overwrite all slots.
00:09:50.632 - 00:10:06.484, Speaker A: So just keep that in mind. So this would be an example on how we would use it. We supply the original payload and then we give the latest block and we add in our state override method right here.
00:10:06.484 - 00:10:44.136, Speaker A: And if you can see here, what we're specifying here is essentially on the address 42 we would like to deploy a new contract bytecode deployed bytecode that we would like the code to be that and we would like the state difference at slot zero to be our EF account address. And the reason why we do that is because maybe your contract has some kind of ownership checking which on a lot of contracts would be the owner object will be on slot zero. So here we're saying that on address 42 we have a new contract which could be the contract you're testing or the contract you haven't deployed.
00:10:44.136 - 00:11:12.330, Speaker A: And for the state differences we would like these state differences to be applied so you can overwrite the state as you do e call. And this is incredibly useful because when you're testing your contracts as or your new contracts alongside with your bot logic or your new bot logic with your contracts, you're doing this in a very mutable manner and you can kind of see what values it return. I'm assuming your functions return values by the way, if it doesn't return values and it doesn't revert, it might be slightly different but in this case it does.
00:11:12.330 - 00:11:37.240, Speaker A: You can basically, I would say hot deploy it for every call you make. So it's a lot cheaper to kind of test new contracts. The second thing I would like to talk about is the JavaScript tracer which I found really handy, very handy, especially when we're dealing with poisonous tokens.
00:11:37.240 - 00:12:06.032, Speaker A: Does anyone here remember salmonella? Yes? Okay, great. Well, I didn't get wrecked but a lot of other people got wrecked. So how salmonella worked in a nutshell is that they tried to change the production environment so they would like to override the transfer function so that it would slightly differ in the production environment, in the test environment.
00:12:06.032 - 00:12:23.460, Speaker A: And so one way you could do that is by checking the mine of the block. So for example, if the mine of the block was hard hat's testnet coinbase or mainnet coinbase account, then you would transfer it. So in the searches simulation it would be successful and it would fire off the bundle.
00:12:23.460 - 00:12:46.160, Speaker A: But if it were to be mined on the mainnet, this slight logic statement wouldn't be valid and so the transfer function would actually not be executed. So that's kind of poisonous token in a nutshell where they try and kind of create this delta between a production environment and your testing environment. So try and find little nuances there.
00:12:46.160 - 00:13:13.720, Speaker A: So test and prod guys, test and prod. So I hope this isn't too small but what you can do is you can actually use a RPC method, also known as debug trace call, and apply a custom JavaScript tracer. As you can see here, I'm basically checking the opcodes of each of the opcodes and I'm basically seeing, hey, if the opcode is coinbase difficulty number of origin.
00:13:13.720 - 00:13:48.564, Speaker A: It looks a bit suspicious because why does an ERC 20 transfer function need to read from block coinbase from the coinbase? Why does it need to use the coinbase opcode? Why does it need the difficulty opcode? Why does it need the block number of code? Why does it need a TX origin of code? It's just a little bit suspicious and so we can kind of return, we can kind of do a really quick trace over and then kind of pop it out and tell us, hey, these are the suspicious opcodes. And from that we can kind of infer that this could be a poisonous token or it could not be a poisonous token. But yeah, you do debug trace call.
00:13:48.564 - 00:14:23.040, Speaker A: The parameters are all the same from to some kind of encoded function data, which is usually your custom arbitrage function. And yeah, you just supply this JavaScript tracer. I would love to show you guys a lot more a deeper dive into the tracer, but unfortunately the documentation is huge and it's very confusing and I've been trying to put less code on slides, but unfortunately I didn't really think too much in advance.
00:14:23.040 - 00:14:38.068, Speaker A: So the third section I would like to talk about is GraphQL. I'm not sure if anybody in here knows that GEF actually has an inbuilt GraphQL. Does anybody know about that? Yes, a couple of people.
00:14:38.068 - 00:14:49.530, Speaker A: That's great. Yeah, since EIP 1767, which has been out, I think since 2020, GEF has actually GraphQL built in. You guys can check it out right there.
00:14:49.530 - 00:15:10.364, Speaker A: And you actually have to run GEF with a few additional parameters http and GraphQL to make sure the GraphQL library actually runs. Yeah, but using GraphQL is actually really simple. This is entirely in JavaScript.
00:15:10.364 - 00:15:37.396, Speaker A: I apologize, by the way, I know a lot of rust spans out here, but it is what it is. And so you can kind of specify, for example, in this request, I'm actually trying to get out the reserve values from univ two pairs from Sushi WEF and uniwef. So I'm trying to extract out the reserve values from the latest block.
00:15:37.396 - 00:16:11.060, Speaker A: It might not seem like much, but using this method you can actually extract out a lot of the reserves in one call, which is very handy, very handy, especially if you're calculating arbitrage opportunities or backbone running opportunities between like 50K pairs or something. As they previously mentioned, you want to be able to continuously update it. The GraphQL interface is actually a lot more powerful than this one, but I find myself coming back to extracting out the storage slots using this method.
00:16:11.060 - 00:16:37.160, Speaker A: So, yeah, there is an inbuilt GraphQL interface for you guys to play around with. A little bit of parting advice if I have, is that programming socks plus ten intelligence to anyone who uses them is very comfortable speaking from experience. It's very underrated, but just want to bring that to light.
00:16:37.160 - 00:16:43.324, Speaker A: You even can buy the C programming book together? Yeah, that's it. That's my slides. It's all the five minute mark.
00:16:43.324 - 00:17:01.810, Speaker A: I think I rushed to it a little bit. Any questions? No. Okay, great.
00:17:01.810 - 00:17:24.400, Speaker A: Breaking close.
