00:00:00.090 - 00:00:13.550, Speaker A: Hey everyone, good afternoon back. I was here this morning talk about mevboost generally. Now I will talk about this builder role in particular and I think it goes really well with what Quintus was just saying where, you know, there is this issue of builder centralization.
00:00:13.550 - 00:00:26.982, Speaker A: It's very important to keep an eye on that. But, you know, sort of assuming that we can manage the externalities of the situation. There's like a bunch of cool stuff that this new abstraction can give us.
00:00:26.982 - 00:00:57.098, Speaker A: So I want to talk a little bit about that today and hopefully just get you excited about this as its own problem and see some of the cool things we can do here. So obviously the question is like, what are we building? And while we're building these mev aware blocks, right? So in particular you're going to get order flow from some people and you need to craft this block in a way that perhaps maximizes the value extracted. If it's mev, maybe as you'll see later in the talk, there's other things you could imagine you want to try to optimize or maximize.
00:00:57.098 - 00:01:07.330, Speaker A: But yeah, for sure this is what we're doing right there's. These users here, they want to do something to the chain. They produce transactions after using some software like Wallets or DApps.
00:01:07.330 - 00:01:26.886, Speaker A: In the mev context, you then have searchers who try to craft bundles of transactions that for example, emit some value they can collect. Those all go to a builder in this sort of world we're moving to. And the builders themselves are making complete blocks rather than just partial blocks as searchers would do.
00:01:26.886 - 00:01:38.902, Speaker A: And yeah, then of course that all has to get to a validator. Who's the one with the power to actually include it on chain or not. Why would we care? Well, there's a number of reasons.
00:01:38.902 - 00:01:50.366, Speaker A: Here's four really sort of high level ones. The first one is just like, we have this nice interface now to preserve validator decentralization. And this is like the core idea behind PBS, I think at this point.
00:01:50.366 - 00:02:03.074, Speaker A: You guys have heard about this plenty today, but I'll just touch on it super briefly. Another one is just like it's a fun optimization problem. We'll talk a bit about what we're actually trying to do when we build blocks and how that breaks down.
00:02:03.074 - 00:02:19.062, Speaker A: If you like these types of more CS theoretical problems, then you'll find a bunch of little fun tasks here. It provides this really cool abstraction layer. And I'll jump into a myriad of use cases that use this fact that the protocol only lets us do so many things.
00:02:19.062 - 00:02:52.370, Speaker A: This builder now serves as almost this wrapper around it to support a lot more use cases than we could get out of the box and then ultimately see previous talk. We want there to be this very healthy builder market to keep the role itself decentralized. So yeah, just really briefly, right, this is one of the first things I laid out was this interface and really what it does is this it puts this kind of hard barrier in between the proposers the validators in the network and everyone else.
00:02:52.370 - 00:03:10.470, Speaker A: You can imagine there's this mev maelstrom or Storm that's happening out there in the world and the protocol needs to be protected in some sense. This is what PBS does. Another thing I mentioned was building again is this very fun optimization problem.
00:03:10.470 - 00:03:25.706, Speaker A: So what do I mean by this? The way to think about it is that there's like a certain number like you have some inputs to this problem. You want to build a block. What are you putting in the block? These transactions, there's now like a series of constraints.
00:03:25.706 - 00:03:34.750, Speaker A: One of them is just that the block only has so much gas, right? So here I said there's like T available gas. So there's this blue block. It only has this much in the limit.
00:03:34.750 - 00:03:57.858, Speaker A: You then go to your mem pool, whether this is like again public or private, wherever you're sort of getting your quote order flow from. These transactions take gas and they have different amounts of gas they require. And the thing now is you basically have to say, okay, I have to place some transactions into my block up to the limit and I may have more transactions than I have room to put in the block.
00:03:57.858 - 00:04:11.200, Speaker A: So I have to then pick. So that's like sort of one thing to optimize for. And I just threw out this constraint here that if there's, like, A, B and C Gas across these three transactions, they cannot exceed the block Gas limit T.
00:04:11.200 - 00:04:42.482, Speaker A: But there are more constraints because not only do you need to figure out, okay, I have this much gas, and this sort of pool of transactions demand this much gas. I also want to optimize, for example, the value or the revenue that the block provides. So then you can say, okay, based on possible arrangements of transactions that I can generate, how much value does that provide to whoever builds the block? Whoever processes the block.
00:04:42.482 - 00:05:02.650, Speaker A: All the different pieces in this whole supply chain over here, right? So this is something else. We have the scoring function for each block is like, okay, if I execute this one it pays maybe X way, this other one pays Y way. Which do I prefer? Subject again to the fact that I only have so much gas per block.
00:05:02.650 - 00:05:38.790, Speaker A: It even gets a bit more tricky because at least in Ethereum, let's say, right as you go to build the next block in the chain, you have what I'll just call here probabilistic execution. And what I mean is that Ethereum runs ahead of some sort of finality and so you could for example, have a fork in the chain where now you as a builder have to decide, okay, I've observed the network along with everyone else. I see there are two possible heads which one do I pick? I can run my local fork choice and say, oh, this block B is on this fork with 60% of the weight versus block A with 40% of the weight.
00:05:38.790 - 00:06:10.980, Speaker A: And so now the question is like, can I use that information to my knowledge? And one thing you might want to do is say, okay, because of that I want to allocate resources building block B versus block A in this like 60 40 ratio, something like this. So not only are you trying to say, okay, at the block level, what are my transactions, how many can I fit in the block subject to the constraint that I want to find the most valuable block, but also I may not exactly know what block I'm building. So fun stuff.
00:06:10.980 - 00:06:25.574, Speaker A: And just to throw out a little bit of formality here, this in general, it's an instance of what we call the bin packing problem. And this is just from Wikipedia. You can go to the page to learn more.
00:06:25.574 - 00:06:53.364, Speaker A: But essentially, yeah, the setting is that you have some bin, let's say, of fixed size and you have many objects of different sizes and you want to pack the bin in a way that maximizes some constraint. For example, the value that would come out of the, out of the bin, or in this case, out of the block. So we talked about again this fact that there's this abstraction.
00:06:53.364 - 00:07:08.904, Speaker A: It gives us this nice firewall effect. It also gives us this very fun self contained optimization problem. If we like to program as a user, you might care a lot more about this set of things where it provides what we're going to call account abstraction.
00:07:08.904 - 00:07:35.824, Speaker A: So there's actually a pretty rich history of this idea in Ethereum. And the idea is that Ethereum today gives you this interface where you can sign with a particular signature scheme and then interact with the EVM. But there's lots of other things you might imagine and the full like, okay, for example, you can imagine abstracting away the type of signature scheme that you use, or is a signature even the way in which you authorize like a transaction to execute.
00:07:35.824 - 00:07:57.500, Speaker A: Right? And if you follow this to the end of the line of thinking, you get to this notion of smart contract wallets. There's some EIPS in the space EIP 3074 that would basically add some opcodes to give you building blocks to do this type of thing. More recent EIP four, three, seven, kind of does it off chain and ends up settling it inside the EVM.
00:07:57.500 - 00:08:19.600, Speaker A: Anyway, lots of cool stuff. And there's many things that people would want that fall into this bucket that they just can't do today because the protocol is like fixed for some notion of fixed. So I'll run through some examples here, again, as examples of this idea of abstracting what the protocol provides.
00:08:19.600 - 00:08:35.352, Speaker A: Yeah, so a big one people would like is like gas sponsorships. And this is where I could almost say I want to execute some order on Uniswap. Let's say, rather than pay the Gas for the computation or for the transaction, someone else pays it.
00:08:35.352 - 00:08:47.160, Speaker A: And there's not a really streamlined way to do this within the protocol, but builders could do this pretty trivially. Another one. This is what I was kind of using as my Motivating example, was custom authorization schemes.
00:08:47.160 - 00:09:03.644, Speaker A: So you can imagine, like, before we even begin EVM execution, you need to have some multi SIG situation, not just, for example, ECDSA, that's what we use today. So you could generalize that another one event triggered transactions. You might have heard of the Ethereum alarm clock.
00:09:03.644 - 00:09:26.740, Speaker A: And basically the idea is just like, rather than me have to sit and wait for, I don't know, the base fee to fall to a certain point, I can just say, hey, builder, here's my order. When the base fee is at a point that I think is reasonable, go ahead and execute this on Chain for me. This next one, if you saw Vitalik's talk this morning, he talked about this builder pre confirmations.
00:09:26.740 - 00:09:44.460, Speaker A: And this is pretty cool because in Ethereum, we're at a different point in the tradeo space where you're not necessarily going to get confirmed within 100 milliseconds. Instead, blocks come a little bit more slowly than that. But it would still be nice to provide this UX to people that I can click some buttons on.
00:09:44.460 - 00:09:53.920, Speaker A: Again, the uniswap page. Or, like, ave or compound. Pick your favorite DFI application, I can click some buttons and fairly immediately know that my transaction will be on chain.
00:09:53.920 - 00:10:12.132, Speaker A: This example came from talking with Quintus, who was just speaking. So builder cancellations kind of on the other end of this UX here where it's like, okay, I can either get confirmed early, I could also get canceled early. Right now you have to overwrite a transaction with this Gas game.
00:10:12.132 - 00:10:26.940, Speaker A: And I'm sure if you try to do this in MetaMask, it doesn't work. And you're like, why is this so frustrating? Because builders have this sort of off chain view of what goes into the block. They can do this, and they can have arbitrary protocols for letting you do this as a user.
00:10:26.940 - 00:10:49.364, Speaker A: This next one is pretty cool. Also, like, I think a whole talk in and of itself, but essentially mev rebates. And it's this idea of like, okay, if I'm using one of these DeFi applications and I make a transaction that has some mev, someone like, say, a searcher can extract the mev, but then also they need some way to send some of that value back to me.
00:10:49.364 - 00:11:02.760, Speaker A: Maybe most of it, maybe all of it. Again, whole talk in itself. But this is something you can imagine builders facilitating that otherwise might be really hard to do, just using the EVM and the base protocol.
00:11:02.760 - 00:11:24.940, Speaker A: Another idea that I haven't really thought through as much as I would like, but essentially some kind of off chain mev smoothing. So like the stuff that we had two talks ago, I believe, around how do we take the mev that is on chain and smear it back across the validator set. This notion is mev smoothing.
00:11:24.940 - 00:11:37.570, Speaker A: And again, you could imagine having the mev come into some pool that's controlled by a builder you trust that does the same thing. Right. Another one, I'm going to call it values based building.
00:11:37.570 - 00:12:01.980, Speaker A: By this I mean, rather than just bias for optimize for the most valuable block, you could optimize for a block that again, has something else to optimize for. For example, people toss the idea around of having blocks that there's no front running. So you could imagine I'm a builder and I just claim I will never include a transaction that front runs you as a user.
00:12:01.980 - 00:12:24.492, Speaker A: This would be one value you could imagine a lot more. Another one, again, related in this category is we'll call it MEB protection schemes. And if you're familiar with the idea of threshold encryption, the idea is that basically your transaction is committed to before it is executed and it's done in a way that no one knows until it's executed.
00:12:24.492 - 00:12:56.826, Speaker A: So, yeah, builders could do this as well, again, in an off chain fashion, something like that. We might have to think of some of the details, but the point being is you should have a takeaway from this, which is that there's this rich layer of expressive sort of functionality that the builder can provide just because of its place in the protocol as a player compared to others. Another important bit was builder decentralization.
00:12:56.826 - 00:13:15.966, Speaker A: So again, this is the idea just to encourage healthy competition. Again, see the previous talk around why we want this, what could go wrong if we don't have it? The key thing here, I think, is we want to keep the barrier to entry as low as possible. So anything we can do towards that front is super exciting.
00:13:15.966 - 00:13:42.940, Speaker A: There's a lot more to say about sort of distributing or decentralizing the actual builder. And I'll just point you to Vitalok's talk this morning because that's kind of everything he talked about around distributing, order, flow, builder capacities, all these things. And yeah, I'll just finish now by trying to paint a very sort of speculative picture or a gesture around what we could do.
00:13:42.940 - 00:14:09.610, Speaker A: There's some cool projects I've seen lately and I'll just bring them to your attention, I think I can say at the frontier of mebux. So it's just like people talk about, and this really is the whole point, if we go back to this bit for a second, our handy MEB supply chain photo. So we've heard of people talk a lot today about this builder, the validator or the proposer and their interaction.
00:14:09.610 - 00:14:34.580, Speaker A: We've perhaps spent less time, at least in aggregate, talking about things higher up the stack, more all the way up from searchers to wallets to users. And this to me I think is where we'll see a lot of exciting developments in the next coming years really is just like all the sophistication will flow up this chain. So I'll just finish by pointing out some projects in that space.
00:14:34.580 - 00:14:54.490, Speaker A: One of them being like Calswap. The idea with Calswap is this protocol where essentially it's an exchange and orders are batched ahead of time. If there are matching orders before you settle to chain, you basically just execute them off chain and then all that goes to chain is like the minimal amount to actually execute the full block.
00:14:54.490 - 00:15:13.086, Speaker A: There's no way to do this for example with Uniswap today because there's just no way to do this batching function, at least in a way that doesn't leak a bunch of user information. Consequently mev another one is like rook. I think these to be called keeper dow and it's like a similar idea where they essentially have a private mempool.
00:15:13.086 - 00:15:44.860, Speaker A: They have trusted searchers and these searchers can then extract the mev but then directly provide these mev rebates I was talking about. There's this e three search post again kind of elaborating this idea of this like mev capturing AMM all in the van of what I've been talking about. I did want to call out this talk by Adrian Brink who's around here somewhere and he has this notion of intent centric design that I think they use to inspire a lot of the design decisions in Noma, which is a project he's working on.
00:15:44.860 - 00:16:06.386, Speaker A: I think the framing is really cool and you should check it out and the idea with this is like actually this is probably helpful. It all comes back to the supply chain. So again, the key here is with this intent centric design is looking at the users and what they're actually trying to do.
00:16:06.386 - 00:16:43.006, Speaker A: And rather than even worry with transactions or protocols or whatever, it's just like how do we take what users want to do and sort of reconcile it or settle it in a way that maximizes, you know, calsop has these agents called solvers, which is generally an idea in this framing as well. And so you want to take up everyone in their intents and then only after you've done this very intense sort of preference negotiation computation end up with transactions that would even go on chain in the first place. It's what I said here.
00:16:43.006 - 00:16:57.286, Speaker A: By doing so we can demand minimal value extraction by other players in the ecosystem and have maximal value capture for users of these systems. Sounds pretty cool. And then we'll probably have some really cool crypto economics to make it all actually work.
00:16:57.286 - 00:17:17.866, Speaker A: So very exciting space to look out for generally. And that's it. I'll just plug another project I'm working on, mevrs, which contains a lot of these hopefully easy to use tools for off the shelf building and things like that.
00:17:17.866 - 00:17:26.426, Speaker A: It's like pretty early days for this, but if you are interested in this kind of stuff, please go there or reach out. This is me on Twitter at R. Alex Stokes.
00:17:26.426 - 00:17:31.040, Speaker A: And yeah, I think that's all I have for now and happy to take a few questions.
00:17:39.270 - 00:17:49.102, Speaker B: Thanks, Alex. That was great. I love this exploration of the expressivity that's enabled by block building, which Stefan in particular talked a lot at the beginning of all of this.
00:17:49.102 - 00:18:06.902, Speaker B: But now it seems like so much of the dialogue, including today, is just all max profit. And so I'm trying to figure out how do you square the circle between some of the creative ideas that are expressed here and then the earlier ideas which are like, you got to enforce max profit. Anything other than max profit is not great for the network.
00:18:06.902 - 00:18:09.020, Speaker B: So I was curious if you could comment on that.
00:18:09.870 - 00:18:28.226, Speaker A: Users own their order flow, so I think we have to make it very clear to the people using these systems that they decide what happens if there's an overly extractive, say, fork of uniswap. And yeah, sure. Let's say, for example, that uniswap has these nice mev rebates and there's some fork that does not have that right.
00:18:28.226 - 00:18:44.920, Speaker A: If it becomes known that users are sort of let's just say there's more extraction in the other case than the other one, then I assume if people know that, they would choose to use the one that's like to their interest. So I think that's like a key piece of the puzzle that gets overlooked there.
00:18:46.010 - 00:18:47.074, Speaker B: User choice.
00:18:47.202 - 00:19:02.800, Speaker A: Yeah, we like forking in blockchains, same ideal.
