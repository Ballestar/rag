00:00:09.370 - 00:00:23.434, Speaker A: So tackling mev with cryptography, I'm very optimistic that we're going to lean towards the utopia rather than Dystopia. So two part talk. The first part is going to focus on consensus mev.
00:00:23.434 - 00:00:53.920, Speaker A: Basically mev leaks that stem from inefficiencies of the consensus layer and then also talk about how transaction encryption can really help potentially with application layer mev. Okay, so for consensus mev a few months ago I just realized it's all mev and it always has been. And I've kind of put on my mev goggles and I kind of want to give you the tools to see how a lot of the problems we have in consensus are actually just mev problems.
00:00:53.920 - 00:01:15.854, Speaker A: So one of the things that we're working on is a secret single leader election. And the problem with public proposals when you do public elections is that you can do DDoSing. So you have these two slots and they both have mev, one unit of mev and another unit of mev.
00:01:15.854 - 00:01:42.534, Speaker A: And if you're the proposer in slot two and you're an attacker, you can go DDoS the proposer at slot one. If that proposer's IP address is public, which it currently is on the beacon chain, which is bad, and then basically the attacker can get twice as much mev. So I'm expecting roughly $1,000 worth of mev at every single block post merge.
00:01:42.534 - 00:02:04.462, Speaker A: And so, if you can do like a one dollars denial of service attack on the proposal before you, you make 1000 times your money. And I expect some people to some extractors to try and do that. And you can try and even do that with several slots in advance and make even, basically steal even more mev.
00:02:04.462 - 00:02:17.854, Speaker A: So that's dos based mev. And then another component of secret single leader election is the single. And I just want to explain why this is important in the context of mev.
00:02:17.854 - 00:02:35.422, Speaker A: Because imagine that you have two proposers, proposer one and proposer two that kind of have this precedence list. So proposer one has precedence over proposer two, et cetera. So if proposer one doesn't propose a block, then proposer two can come in.
00:02:35.422 - 00:02:56.150, Speaker A: Well, this is problematic because let's assume that the same person, an attacker controls both proposer one and proposer two. Then this is how the attack goes. Proposer two publishes a block at the expected time well enough in advance for all the attesters to be able to see the block.
00:02:56.150 - 00:03:31.274, Speaker A: But then a few seconds later proposer one publishes another block, this time with more mev. But because it was published kind of late, it's possible that the attesters won't see it on time and therefore it might not make it on chain. But in the case where it does make it on chain, then basically the attacker has these few seconds of edge to get to extract more mev because the more time you have, then the more transactions come in and you kind of have blocks with more mev.
00:03:31.274 - 00:03:53.042, Speaker A: So that's called a time buying attack where you buy a few seconds worth. So chains like DEFINITY and kind of got it wrong, at least in hindsight in my opinion. Okay, so secretly the election, how does it work? Because I did have the word cryptography in the title.
00:03:53.042 - 00:04:26.450, Speaker A: So very, very briefly, we have these trackers which are basically ways for validators to have a commitment on chain and this commitment to get shuffled around in such a way that they can track the commitment but no one else can track the commitment. And then we use these commitments to select the next proposal. So we have this stirring function where every proposer can kind of stir and add some entropy.
00:04:26.450 - 00:04:47.774, Speaker A: Then we do a bunch of stirs and if one of the stirs is kind of honest, then we have plenty of entropy. And you see the blue block here is basically the commitment of the validator. And you have the validator.
00:04:47.774 - 00:05:11.706, Speaker A: One can track his commitment over time. And the way that this is implemented concretely is you have basically a pair of points. This is an epic curve point, the generator, and basically you have the secret which is embedded and then you just multiply the tracker with a random scalar and that's how you add in the entropy.
00:05:11.706 - 00:05:32.438, Speaker A: Okay, that's most of the cryptography for this talk. Okay, so what about randomness? How does mev come into play with randomness? So the way that we do randomness today is with Randall. The way it works is that we have an epoch which is made of 32 slots, slot zero to slot 31.
00:05:32.438 - 00:05:48.246, Speaker A: And at each slot, the proposer is invited to reveal a secret they've committed to at the time of registration. So there's kind of secret zero all the way up to secret 31. And because they have the option to basically they can not reveal.
00:05:48.246 - 00:06:08.190, Speaker A: So it could be kind of the empty reveal the empty set there. So every proposer either reveals or does not reveal their secret. You hash everything and then you get the randomness for the next epochs to sample the next proposers.
00:06:08.190 - 00:06:26.642, Speaker A: But the problem here is that the very last proposer basically can choose between two random outputs. Randall outputs. You can either reveal and get the green output or not reveal and get the blue output.
00:06:26.642 - 00:06:58.606, Speaker A: And this is bad because it means that they could choose which random number they want, which gives them the most mev. Now, how can changing the randomness give you more mev? Well, one reason is that you just might have more validator slots if you choose green as opposed to blue. It's possible that you have the knowledge, for example, that there's going to be an NFT AirDrop at a specific slot, which is going to be extremely valuable from an mev standpoint.
00:06:58.606 - 00:07:27.690, Speaker A: And it might be that the blue randomness will give you access to this really valuable slot. Or it could be, for example, that one of the randomness will give you access to these later slots in an epoch because basically the latest lots are more valuable than the prior slots because they give you more control over the randomness. So you can use control over randomness to get even more control over randomness.
00:07:27.690 - 00:08:01.350, Speaker A: And the way that we solve this, one thing to mention here is that it's not necessarily the last proposer who just voluntarily chooses to not reveal because he's malicious. But it could be that the last proposer is honest and intends to reveal but is being DDoS by someone else who likes the randomness at this point in time. So basically by an attacker who likes the blue randomness.
00:08:01.350 - 00:08:23.518, Speaker A: And so here, this is kind of a good example where mevs, this systemic issue is not very well contained. You have different mev leaks which interact with each other in very subtle ways and kind of compound on each other in some cases. Okay, so we have the delay function.
00:08:23.518 - 00:08:58.490, Speaker A: And the idea of the delay function is that it's a function which takes time to compute and we're actually going to use the output of the delay function as the source of randomness, not the input. And the reason is that by the time the output is made public is known to the world it was too late for these validators, these proposers to reveal or not reveal. Okay, another problem with layer one mev is chain reorgs.
00:08:58.490 - 00:09:13.520, Speaker A: So this is very simple. We have some mev as one represented by the cache icon here. And the proposal at slot two says I want this mev for myself.
00:09:13.520 - 00:09:36.502, Speaker A: What I'm going to try and do is build on the parent kind of rewriting history. And this is called a time banded attack. Right now one of the things that we want to do on the beacon chain is completely remove time band attacks from the equation and here's kind of how we will get there.
00:09:36.502 - 00:09:46.626, Speaker A: So the idea is to use BLS aggregation. So what we have today is per epoch finality. So we have hundreds of thousands of validators.
00:09:46.626 - 00:10:27.794, Speaker A: We have so many validators that we kind of split them up across the whole epoch from slot zero to 31. So we have roughly right now 11,000 validators per slot and each validator will make an attestation, will make a vote for the block in the slot. And the question that we can ask ourselves and basically once we've reached the end of the epoch everyone had an opportunity to vote and everyone having the opportunity to vote is what allows finality.
00:10:27.794 - 00:10:52.094, Speaker A: So we need at least two thirds of the validators to be doing these attestations to get finality. Now the question we can ask ourselves is can we get a per slot finality also known as single slot finality. And what we would need to do that is basically have all validators sign at the same time and kind of aggregate them all at the same time.
00:10:52.094 - 00:11:27.106, Speaker A: And the power of aggregable BLS signatures is that you can take hundreds of thousands of signatures, you can aggregate them all very quickly, and the cost of verifying them on chain is fairly small. And we actually believe that we can get to this single slot finality point where we just completely remove time banded attacks like small detail. Here there's actually two slots, right? So in order to get finality, there's these two steps.
00:11:27.106 - 00:11:44.560, Speaker A: Step number one is justification, second step is finality. So kind of under the hood there's two kind of beacon chain slots, beacon slots, but these would correspond to only one EVM slot. So only one state transition change at the EVM level.
00:11:44.560 - 00:12:03.102, Speaker A: Okay, what is another source of mev that comes from layer one? And basically it's the fact that the layer one is not scaling. And so there's a lot of overflow, which means that there's kind of this demand for these other layer ones. And then you need to build bridges.
00:12:03.102 - 00:12:31.600, Speaker A: And these bridges kind of inherently bring a lot of friction and mev. So what are some of the kind of the constraints, fundamental limits of bridging between layer one and layer one is you don't have this nice synchrony, so you don't have the same slot durations, the same slot boundaries, the same settlement times, like this nice atomicity. But the other problem is that you don't have shared security.
00:12:31.600 - 00:12:43.946, Speaker A: And so you have different social governance. You have independent 51% attack vectors. And there's some things that are fundamentally you fundamentally can't do, like data availability sampling.
00:12:43.946 - 00:13:00.246, Speaker A: You can't have one layer one do data availability sampling on another layer one. And all of these inefficiencies kind of lead to cross layer one mev. And so the question is, can we remove cross layer one mev? And my thesis that yes, we can remove it.
00:13:00.246 - 00:13:27.360, Speaker A: And the way that we remove it is with roll ups and shared security. So the idea of shared security is that you have this very large layer one data availability, and then on top of it, you just put a bunch of roll ups. And in order to achieve this dream of shared security, you have to do quite a bit of work cryptographically, you have to look at polynomial commitments, snarks and all.
00:13:27.360 - 00:14:08.806, Speaker A: So here the way that what we want is not just shared security, but we want this really scalable shared security. And here again, this is kind of my belief that we're basically going to go from the current TPS of, well, the current situation of ten TPS to 10 million TPS. And the way that we get there is that we have 3100 x opportunities to scale largely with to a large extent, thanks to cryptography.
00:14:08.806 - 00:14:43.330, Speaker A: So we have roll ups, which give us 100 x, sharding gives us another 100 x, and Nielsen's Law, which is basically just Morse law for bandwidth, which gives us another 100 x. Okay, I only have four minutes left and I really do want to talk about this second part because it might be more relevant for those who are not so much interested in the layer one. So here my thesis, is that to a very large degree we can mitigate application layer mev with encryption.
00:14:43.330 - 00:15:03.390, Speaker A: And in the history of cryptography, it kind of started with encryption and for a long time blockchains have ignored encryption. We've been using hashing, we've been using signatures, we've been using zero knowledge proofs and all sorts of stuff. But we have kind of ignored encryption and I think it's going to be the big return of encryption.
00:15:03.390 - 00:15:41.980, Speaker A: So the thesis that I have is that in the medium term future, most transactions are going to go through this lifecycle. So transactions will be encrypted off chain and then on chain they will be included, decrypted and executed. And by having these transactions be encrypted prior to inclusion on chain will make it basically very hard or impossible to front run because the front runner doesn't have the information that they need to do the front running.
00:15:41.980 - 00:15:54.110, Speaker A: But one of the key problems here is the decryption step. That is the kind of the most complicated one. And specifically what we need is we need some form of guaranteed decryption.
00:15:54.110 - 00:16:16.866, Speaker A: We somehow need the decryption to automatically decrypt itself once it's been included on chain. And you can't have commit reveal because that gives you like a free option. And so what are the forms of guaranteed decryption that exist in cryptography? So one is threshold decryption where you're basically trusting a committee to do the decryption of the transactions.
00:16:16.866 - 00:16:48.030, Speaker A: There's this other thing called delay decryption where fancy cryptography allows you to automatically decrypt transactions after, let's say, 10 seconds or a minute. And then there's the most powerful tool of all which is called kind of witness decryption, where you provide some sort of cryptographic proof. It can be any proof, any snark, and that will allow you to decrypt your transaction.
00:16:48.030 - 00:17:15.026, Speaker A: And one of the exciting things here is that from a user experience standpoint, all of this encryption stuff won't change, at least in theory, it could not change the user experience. Everything could be done in a single EVM slot. And so this is how I kind of see the end game at the consensus layer in terms of infrastructure that could be provided.
00:17:15.026 - 00:17:34.058, Speaker A: So there's this single EVM slot which is kind of what we're used to today. And then kind of behind the scenes there's stuff happening with multiple beacon slots. And basically we can shove a lot of ideas that help with mev.
00:17:34.058 - 00:17:46.202, Speaker A: We can shove proposal builder separation. So that there's these two stages where we have proposal blocks and builder blocks. And we also have here the two stages of finality.
00:17:46.202 - 00:17:57.346, Speaker A: So first we finalize proposal blocks, then we finalize builder blocks. All of that takes four slots. And then in this final beacon slot we have automatic decryption.
00:17:57.346 - 00:18:15.978, Speaker A: For example, with witness decryption triggered by the finality of the builder block and we execute. And from a UX standpoint, you don't realize that there's multiple blocks or additional latency. Now, there's a lot of devil into the detail to actually pulling that off.
00:18:15.978 - 00:18:29.550, Speaker A: One of the complications is that you need to encrypt the metadata. You also need to potentially do other things. And here you need to bring in the big guns like homomorphic encryption or fully homomorphic encryption.
00:18:29.550 - 00:18:38.060, Speaker A: I don't have time today, but there is a 1 hour and a half talk where I go into the details on YouTube. That's it. Thank you.
