00:00:03.130 - 00:00:23.790, Speaker A: I'm James and I wouldn't really call myself a researcher, so I'm not sure why I'm here. I'm an engineer, and because I'm an engineer, I set up a tiny URL because I know none of you can see the screen, because I'm thinking about the world around me like an engineer does. So you can all get the slides@tinyurl.com,
00:00:23.790 - 00:00:37.080, Speaker A: slash, press choice. So if you want to follow along on a place you can see it, go for it. So I'm going to talk about Med Wallet, which is one of my side projects right now.
00:00:37.080 - 00:00:50.846, Speaker A: Medwallet is not really an order flow option or research concept. It's deployed on mainnet because I like deploying things to mainnet. So you can go out and interact with this today.
00:00:50.846 - 00:01:15.300, Speaker A: It's been there since like, mid January. So what is mev wallet? Mev Wallet is a way to get your transactions to hit the mempool and pay less in fees and get better execution and faster execution. So a typical transaction goes from the user to the mempool to the chain and from the chain to the contract that you're trying to interact with.
00:01:15.300 - 00:01:35.162, Speaker A: So the actual thing that happens, though, is a typical transaction on its way to uniswap, takes a little detour through the searchers and then through the sandwich and then to the EOA and then to uniswap. And so you end up giving away a lot of your money to searchers. Mev Wallet is an attempt to just shortcut this whole process.
00:01:35.162 - 00:01:54.874, Speaker A: If we're giving away money to searchers in order to get on chain, let's just give away money to searchers in order to get on chain. So we shortcut around the mempool, we go directly to the searchers, they're responsible for bundling it, and we put some new stuff in the wallet contract to help with this. So why mev? Wallet.
00:01:54.874 - 00:02:17.606, Speaker A: Why do we want to do this? Block construction is a market, but it's actually two markets. Before Flashbots, it was annual market where the higher tips were at the top of the block and the lower tips were at the bottom of the block. Now the high mev is at the top of the block, the low mev is in the middle, the high tips are in the middle and the low tips are at the bottom.
00:02:17.606 - 00:02:35.502, Speaker A: So when you're adding mev to a transaction on purpose or accidentally, you're participating in a secondary block based market. You're paying your mev in order to be at the top of the block. And it's accomplished through this roundabout method of going to a searcher and the searcher paying a bundle and the bundle going into the block right at the top.
00:02:35.502 - 00:02:55.662, Speaker A: And the more mev you have, the earlier in the block your transaction is because the searcher ensures that is the case. So where does your uniswap transaction go? It goes right at the top of the block because the searcher is taking everything from you and you're paying the minor tip in addition to that. So you're way overpaying for your transaction.
00:02:55.662 - 00:03:10.810, Speaker A: You don't need to be right at the top of the block, you want to be somewhere in the middle. You don't need to be paying a tip if you're also paying mev because the searcher pays the tip for you. So Mev Wallet helps you adjust where in the block your transaction falls and how much you pay for it.
00:03:10.810 - 00:03:29.070, Speaker A: And it does this by preventing you from paying any tip at all and you just pay mev instead. So how does it do this? A standard transaction is like two data value tip. An Mev transaction is two data value explicit mev.
00:03:29.070 - 00:03:59.050, Speaker A: We call it explicit mev because I'm just creating a bunch of mev for no reason, because I want to, because I want to do it in my transaction, because I want to be somewhere in the top of the block, I don't want to be in the bottom of the block. So explicit mev is a way to opt into the better block space market, the one that's more predictable and gets you a better execution, like better point in the block. So we compare this tip that's paid to the proposer as part of a fee to the explicit mev.
00:03:59.050 - 00:04:24.186, Speaker A: So we also every transaction has some amount of zero or more implicit mev when I interact with uniswap. If I'm paying very high, if I'm doing a large trade with high slippage, there's a shit ton of mev generated. So if I'm doing 100 E on a bad trade in uniswap, I might be generating five E of mev just implicit in the trade that I want to do and that's my right as a user.
00:04:24.186 - 00:04:36.462, Speaker A: I can burn my money to the ground if I want to. So what does Mev Wallet add to this? Well, you might pay like 0.1 or zero one priority fee for this transaction.
00:04:36.462 - 00:04:57.658, Speaker A: If you're in the normal block space market, you're still going to get searchered, you're still going to get sandwiched, you're going to end up in the mev block space market instead, accidentally, and you're going to end up overpaying. So if we're generating five ETH of mev and we're paying a 0.1 E tip to the block producer, that's a really shitty execution price.
00:04:57.658 - 00:05:12.590, Speaker A: What Mev Wallet lets you do is specify that you're going to pay a negative 4.5 E tip to the searcher. You're going to force them to provide you four and a half E before they get access to your Mev from your uniswap trade.
00:05:12.590 - 00:05:33.782, Speaker A: So they have to preemptively rebate the mev that you are giving them. And this lets you manually adjust where in the block your transaction is going to fall by adjusting how much mev you're creating. So the total block inclusion on this bad uniswap is like 5.1
00:05:33.782 - 00:05:58.858, Speaker A: E if you're using the legacy tip system and half an E if you're using mev to do the tipping and you're going to get again, a better spot in the block and a better execution price because you're not using the EIP 1559 tipping market. So mev TX processing is a smart contract wallet. So it's actually very straightforward.
00:05:58.858 - 00:06:13.474, Speaker A: You go through the searcher funding, which know they have to preemptively rebate you your mev, so they have to put it up front, which they can do with Flash Minting. It's really easy. Then we go into TX validation, we want to check that the user signed this TX, that kind of stuff.
00:06:13.474 - 00:06:34.966, Speaker A: TX execution, dispatch the trade uniswap, get the results, and then we do the fee settlement. That's where the searcher finally gets access to the value that you promised to pay them via the mev and via the explicit mev. So searcher funding, we actually let the searcher provide the ETH value for your ETH transaction.
00:06:34.966 - 00:07:02.494, Speaker A: So when I say I want to make a transaction with five E, I don't need to have ETH in order to do that. I can force the searcher to provide it for me seamlessly, and then I can do whatever I want with it, as long as by the end of the transaction I can pay back that searcher so I can do my own atomic ARBs this way, using the searcher's flash Minted money. So in TX validation, we did a couple extra things that you can't do with normal transactions.
00:07:02.494 - 00:07:19.730, Speaker A: Mev transactions can be locked to specific time ranges, so not before, not after. Mev transactions will always pay like a normal transaction, a maximum base fee, but they will always pay exactly that base fee. They will never pay more than that base fee.
00:07:19.730 - 00:07:31.950, Speaker A: And that base fee isn't paid to the block producer, it's paid to the searcher who pays the block producer on your behalf. And then TX execution is as normal for a contract wallet. Except this sounds weird until you get it.
00:07:31.950 - 00:07:55.662, Speaker A: In a normal contract wallet, you would not revert if your internal call reverted because that would prevent payment logic from executing and would prevent the relayer from getting paid for forwarding your transaction. It's the way that users control relayers in a standard smart contract wallet. In mev wallet, searchers already don't include reverting transactions, so we just make it revert.
00:07:55.662 - 00:08:26.194, Speaker A: And any reverting transaction won't go on chain because no search will include it. So yeah, you get to for free remove a dos vector from smart contract wallets and again pay a better execution price, get higher in the block, get better overall DX execution, and then fee settlement occurs after the execution. This just tallies up what was the actual gas used, what's the base fee? And what's the additional tip? If the sum of that is positive, it goes to the searcher via medwex.
00:08:26.194 - 00:08:42.050, Speaker A: If the sum of that's negative, it goes to the user via medweck. You can actually end up paying a negative TX fee if you generate enough implicit mev to complete the offset execution. So you can get paid to transact as long as you're hemorrhaging mev value somewhere.
00:08:42.050 - 00:08:56.070, Speaker A: So suppose generate five transactions, very mev friend. Yes. Suppose you're generating like 10,000 USDC of mev.
00:08:56.070 - 00:09:19.520, Speaker A: You can implicitly swap all of that for e because you will end up in a situation where the net ETH movement after the transaction is from the searcher to the user. So it's an implicit trade with the searcher of their ETH for my 10,000 USDC in mev. It doesn't make sense.
00:09:19.520 - 00:09:51.458, Speaker A: Well, I will add enough negative mev that the sum of the explicit mev and the gas payment and the tip is negative. So I will reclaim ETH for the USDC mev that I created. So mev wallet is built on mevweh, which is a west ten fork that AIDS in allocating mev and block production.
00:09:51.458 - 00:10:06.770, Speaker A: So mevwef allows you to explicitly add mev to a block. There's a variable called mev and it goes up. So during the prep phase, the searcher can flash mint mevweth.
00:10:06.770 - 00:10:52.550, Speaker A: They can supply that to the mev wallet, do the whole execution of the user, what the user wanted, which will produce explicit mev in mevwe. They can then use that to replay the flash loan that they just took and they can close out by taking their earnings less the flash loan left their payment to the builder. So every searcher action has this open step, any number of bundles and then a closed step that you're letting people no, the searcher is taking user transactions, building the bundles, and then the searcher opens and closes by interacting with mevweb.
00:10:52.550 - 00:11:17.510, Speaker A: So that's where their earnings from each bundle accumulate and that's where they take their earnings at the end of a set of bundles. So it looks kind of like this is the searcher is going to do their prep, they're going to execute any number of bundles and the mev is going to rise progressively until they close out. So because all mev accumulates in the same slot in state, it's very gas and storage efficient.
00:11:17.510 - 00:11:36.490, Speaker A: And because each searcher's process is exactly the same, we can abstract this to building. So a builder will take a set of bundles from a searcher that includes the searcher's opening close and it'll sawtooth the mev up over the course of the block till the builder closes out at the end of the block. By claiming all unclaimed mev.
00:11:36.490 - 00:12:04.174, Speaker A: It seems like it would be space for transient storage. It would be a great use case for transient storage. However, why is this better? It lets the user searcher builder proposer whoever use a common communicationless coordination channel for mev payments.
00:12:04.174 - 00:12:21.050, Speaker A: If they're all using the same state slot to communicate this mev, they don't need to communicate with each other via RPC or whatever. They just need to pass the bundles around and simulate the bundle to see what the net change in free mev in the system is. These are all happening in one transaction.
00:12:21.050 - 00:12:49.010, Speaker A: It could happen in one transaction, but it doesn't have to happen in one transaction. Well, the storage savings is because I'm not transacting with 37 different searcher addresses over the course of 37 transactions. Because as it is, each searcher does independent payments all over the place in order to net out and pay the builder and whatever are there savings from because there's multiple transactions.
00:12:49.010 - 00:13:07.880, Speaker A: Where do the savings come from? The savings come from touching fewer state slots in a new transaction. Does that matter? It doesn't have to be in a new transaction, right, if it's in the same transaction. And the other answer is that you can shortcut it in your building and searching process.
00:13:07.880 - 00:13:33.546, Speaker A: You can shortcut it in rest and shave latency off of your simulation process. Do you have any tooling for helping users select the appropriate amount of negative explicit mev? I am building a real time bidding RPC, which I should have a prototype out of this week. So the idea is a user submits it to several searchers receives best bids.
00:13:33.546 - 00:14:03.110, Speaker A: The difficulty here is that a bid explodes on a specific bundle change, like when the searcher changes their local state the bid explodes or when it touches some state that the transaction also touches in its local half built bundle. So in order to do this, you have to do it like a real time bidding system. You have to do it within seconds or fractions of seconds because otherwise the bid will no longer be good because the searcher's local state will have changed.
00:14:03.110 - 00:14:16.110, Speaker A: If you could just start really negative and have very short expiry intervals. Yeah, so you can Dutch auction it using the time lock mechanism by pre signing a bunch of stuff. But users hate pre signing multiple transactions.
00:14:16.110 - 00:14:32.130, Speaker A: You could also implement the Dutch auction and like a delegate all library that the wallet delegates to for validation. But I haven't done those things yet. We do have a pre signing Dutch auction already in the rough lib, you can just build a Dutch auction.
00:14:32.130 - 00:14:45.000, Speaker A: Yeah, well, that's what I said. You can build a delegate call Dutch auction for validation because it supports delegate call. You can do any arbitrary logic you want, just like not to say or something else.
00:14:45.000 - 00:14:54.330, Speaker A: So that's the whole thing. You can go to Blunt Instruments on GitHub. You can hit me up on Twitter.
00:14:54.330 - 00:15:00.022, Speaker A: I am building this real time auction thing. It should be fine. We'll have prototypes out soon.
00:15:00.022 - 00:15:26.130, Speaker A: Getting people to run it is a different question. Why are my transactions creating all those? I mean, maybe you should just not interact with or maybe you should just not try to make that NFP or whatever. Potentially.
00:15:26.130 - 00:16:08.318, Speaker A: Yeah, but my God given right to burn my money if I want any other questions. This is really for one transaction. I think that aggregating a bunch of transactions together is best done by searchers and builders who are economically specialized in that like a jump when you're getting an Mev quote.
00:16:08.318 - 00:16:44.030, Speaker A: The Mev exists only in a specific state of the EVM, so every time the searcher's EVM state changes, it means their bid may change as well. And so there's a very short time for the searcher user back and forth process to occur, because any other user's transaction may invalidate every other user's bid. So the maximum possible amount of time a bid is good for is one slot, and the minimum possible amount of time is as fast as the searcher is adding other transactions that are bundled.
00:16:44.030 - 00:16:58.670, Speaker A: This is why you have to do a real time auction. There cannot be a commit reveal strategy here. You can't go to chain multiple times in the workbook.
00:16:58.670 - 00:17:37.470, Speaker A: It sounds kind of like ad options to me, like page load ad options, which are pretty well understood, as Turing will tell you. Kind of, yes, known in the central, central input when people time real time bidding for ad auctions is not a central limit order book. It's actually getting real time bids from the advertisers who is closer.
00:17:37.470 - 00:18:04.470, Speaker A: What's that? So, if you're a searcher running like a quoting service like this, and accepting user things, you need to get your latency to users as fast as possible. And again, bids explode every time. So you might end up going back and forth with several bids with the same user within a single block.
00:18:04.470 - 00:18:16.038, Speaker A: Cool. The only bid you give is, like, a numerical value. You're not saying specifically, how do I achieve that value, right? Yeah.
00:18:16.038 - 00:18:18.930, Speaker A: This is the tip at which I will append this to my bundle.
