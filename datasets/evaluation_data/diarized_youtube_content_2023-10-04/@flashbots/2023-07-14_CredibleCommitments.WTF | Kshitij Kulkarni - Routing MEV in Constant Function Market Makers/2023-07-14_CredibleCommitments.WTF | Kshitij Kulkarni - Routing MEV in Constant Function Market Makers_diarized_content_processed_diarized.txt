00:00:02.650 - 00:00:12.958, Speaker A: Okay, sounds good. Great. Well, yeah, thank you so much for the invitation and for this event.
00:00:12.958 - 00:00:44.966, Speaker A: My name is Shithidj, I am a PhD student at Berkeley and today I'm going to be talking about some work on understanding the incentives of users and mev searchers in these decentralized exchanges known as constant function market makers. And this is work with Theo Diamondis from MIT and Tarun Shitra from Gond. So I was told that this should be sort of an interactive session.
00:00:44.966 - 00:01:32.440, Speaker A: So I think I've prepared about maybe like 30 or so minutes of slides and then we can sort of talk about, we can discuss more sort of interactively. So the basic idea I'm going to be trying to convey in this talk is that users that interact with decentralized exchanges often face some kind of a routing problem when they want to route their trade across sort of a network of decentralized exchanges. So there's many blockchains, there's many, many DEXes that trade pairs across these chains and users want to figure out what sort of optimal paths on these decentralized exchanges look like.
00:01:32.440 - 00:02:18.730, Speaker A: I'm going to be trying to sort of draw out this analogy between these exchanges and sort of the literature on congestion games which also seeks to sort of model these routing problems. So what I'll do first is I'll just do a very brief and quick introduction to constant function market makers. I suspect a lot of people in the audience already sort of know this, but just to put everyone on the same page then I'll talk about this kind of mev known as Sandwich Attacks and then I'll introduce this model of what we're calling routing Mev which introduces this sort of congestion, game like structure to analyze user behavior.
00:02:18.730 - 00:02:53.060, Speaker A: Cool. Why do we have sort of automated market makers or decentralized exchanges? The basic reason is because it's hard to find prices for assets, for pairs of assets. So normally in traditional financial world, the way that you find prices for assets is by asking two people how much is one willing to buy, how much is one willing to sell at? And this leads to your sort of usual notion of an order book.
00:02:53.060 - 00:03:15.580, Speaker A: But the problem with this is that first of all, there needs to be some sort of trusted third party that keeps a list of who's willing to buy and who's willing to sell. And then of course the price is determined when the bids cross into the AFTs. But the presence of this trusted third party is something that we don't like.
00:03:15.580 - 00:03:46.786, Speaker A: And so people introduce sort of this idea which is let's just use a simple formula to determine asset prices. And the way this formula is going to work, or the way this contract is going to work is it's going to pool two kinds of assets, say A and B, or like apples and oranges, or like bitcoin and ethereum into reserves. And the price is then going to be determined by the relative scarcity of the two assets in this contract.
00:03:46.786 - 00:04:16.362, Speaker A: So if A has fewer reserves than B, then make a more expensive relative to B according to some formula. There's a generalization of this idea to something called a constant function market maker. It sort of formalizes this notion of how expensive an asset A is relative to B using this function called a trading function or an invariant.
00:04:16.362 - 00:04:56.090, Speaker A: So what this function does, it takes in the current assets, the reserves of the current assets and evaluates a function of those two assets. And then a trade that comes into this exchange or this contract is going to be considered sort of valid if it respects this invariance condition, right? If it respects the condition that the value of this function at the reserves before the trade should equal the value of the reserves, the value of the function at the reserves after the trade. So if I remove however much I'm paying out from the contract or however much the user is providing to the contract, the function should be equal.
00:04:56.090 - 00:05:18.138, Speaker A: Of course, the output value in this case is implicitly determined by this formula. And one of the most popular exchanges is Uniswap. And it has a very simple formula which is just.
00:05:18.138 - 00:05:38.600, Speaker A: It takes the product of the reserves and sets it equal to a constant, and you can compute all sorts of things that you want about this. You can compute the marginal price of a trade, you can compute the output of a trade for any given input size. And so this is sort of a canonical example of what one of these exchanges look like.
00:05:38.600 - 00:06:10.770, Speaker A: And of course I don't need to convince anyone here that people are using these markets a lot. So this is actually data from last year, but trillions of dollars of value have sort of traded through these exchanges. Okay? So now let's sort of try to set up sort of what the game is here, what the game theory here kind of looks like, which is we're going to start with a constant function market maker with some initial reserves.
00:06:10.770 - 00:06:55.170, Speaker A: And the idea is that a user, so if you look at it from the user's perspective, the user that's submitting a trade into this contract doesn't really know what price they're going to get because of uncertainty in the transaction ordering that they're facing as a user, right? So user is like, I'm going to submit my transaction. Of course, this contract is publicly quoting a price at any given time so you can see what the price is, but the user actually doesn't know what price they're going to get because they don't know which order they're going to be in the block. So they face this uncertainty and to get around this uncertainty.
00:06:55.170 - 00:07:31.950, Speaker A: So what we're going to do is sorry, before that, let me just talk a little bit about what the user sort of flow looks like here anyway. So the users are going to submit transactions. These transactions are going to land up in a Mem pool and in sort of a world where there was sort of no malicious agents out into the world, these transactions would just then be sent to the validator and they would just be processed in some order and they'd be added to the block.
00:07:31.950 - 00:08:07.154, Speaker A: But that's not the world we live in. So in the world we live in, this transaction Mempool gives the ability for searchers to actually compute adversarial traits that they could put in along with the transactions in the Mempool and send them to the validator and ask the validator to include these other additional transactions into the block. And these additional transactions are known as Sandwich attacks and they're sort of an example of this kind of extractable value in these systems.
00:08:07.154 - 00:09:11.818, Speaker A: So formally what's going to happen is the searcher is going to see the state of the Mempool, he's going to compute some trade delta S, he's going to compute some bids and he's going to pay the validator a bid and he's going to say, hey, include my transaction. So the focus of this talk is going to be on this quantity Delta S and how can we compute this quantity, how can we balance this quantity and what are the implications of this quantity specifically for routing problems in these exchanges? So coming back to this transaction uncertainty, this ordering uncertainty that the user faces, the way that sort of these exchanges get around this is they say, hey, the user should not only submit a transaction, but he should also submit what's called a slippage limit. And the purpose of the slippage limit is to in some sense give the user the ability to bound how much price impact they're willing to take from the other transactions in the block.
00:09:11.818 - 00:09:39.986, Speaker A: So it's giving the user the ability to express kind of a preference that says I'm willing to accept no worse than this amount of price impact. And by price impact we mean one could literally mean in terms of price. So there's this price function which if you give me a contract function fee, I could compute the marginal price of any given trade by looking at the partial derivatives of this function taking their ratio.
00:09:39.986 - 00:10:06.138, Speaker A: Or I can have slippage limits that are directly specified in the output amount that I get from the contract, which is I think how uniswap actually implements their slippage limit. So the slippage limit just says I'm willing to accept no less than one minus ada times the nominal output that I see from the network, right? So I see some initial price. So if there was no price impact, I would be seeing some price and some implied output.
00:10:06.138 - 00:10:37.506, Speaker A: I'm willing to accept no less than one minus ada of that. Okay? So now we have sort of this setting in which the user has specified a minimum amount that they're willing to take. And the job of the sandwich attacker or the searcher who's going to look at all these trades is to basically force this price impact to be kind of tight, right? Or to force this bound to be kind of tight.
00:10:37.506 - 00:11:03.674, Speaker A: So the searcher is going to basically notice that there are some trades that have been submitted into the BEM pool that has the property that I can basically put a trade behind that user's trade called delta sand. And then I can force the price effect to be exactly tight. That is, the residual amount that the user gets after delta sand is exactly equal to one minus ada times g of delta.
00:11:03.674 - 00:11:41.790, Speaker A: So I can compute such a delta sand that forces this to be tight. In which case you're basically giving the user the worst case price impact that they're willing to take or the worst case output that they're willing to accept. And now so what is the sandwich attack? A sandwich attack is like a triple in which the first leg of the sandwich attack I kind of explain how the sandwicher calculates it, which is via this sort of equation that sets the amount the user receives after the sandwicher's trade equal to the minimum amount they're willing to receive from the contract.
00:11:41.790 - 00:12:08.710, Speaker A: And then the user trade happens and then the sandwicher is going to sell back the risk that they took. And the idea is that this should result in a profit. So basically his profit is going to be however much he sold back minus however much, you know, he provided into the nylon.
00:12:08.710 - 00:12:30.498, Speaker A: And so once again, I don't need to convince anyone that sandwich attacks are a problem. So here is a sort of a data set of sandwich attacks. Over the last 30 days on Ethereum think something like $9 million have been extracted from users.
00:12:30.498 - 00:13:21.362, Speaker A: Most of the sandwiches tend to be within less than $10 but there's a lot of them very high frequency and maybe low impact kind of extractable value. This has been happening on Ethereum for a while. Before I go into the model of how users are going to route, I'll just say that these functions, these output functions, these price functions are usually pretty nice in the sense that we usually have some kind of bound on the maximum and minimum output for a given trade and we also usually have bounds for the price impact of a trade.
00:13:21.362 - 00:13:49.874, Speaker A: So that's given here by these constants kappa, Mu, alpha and beta. And the point is that we're going to be able to basically bound the sandwich impact, the price impact of a sandwich attack as a function of these constants. And the kind of interesting thing I'll note here is that the profitability of a sandwich attack is sort of going to depend on more than just sort of the pure price impact.
00:13:49.874 - 00:14:14.122, Speaker A: There's going to be sort of a liquidity term that comes up as well. So it's going to be sort of a function of all of these constants and we can make this formal. The idea is that you basically get what you'd expect, which is that the size of the Sandwich attack is something that is like a constant that depends on the user's slippage limit times the trade size.
00:14:14.122 - 00:14:29.810, Speaker A: So that roughly makes sense. If the user is specifying sort of a really bad slippage limit, then you should be able to sandwich them more. And you also can get sort of bounds on the profit from the Sandwich attack as a function of all of these constants.
00:14:29.810 - 00:15:16.180, Speaker A: Okay, so now let's talk about this routing problem, right? So we've introduced Sandwich attacks or why they're a problem. Users in these decentralized exchanges, they often want to route, as I said, they often want to route their trades through sort of a network of cod structure markets. That is, every CfMM is going to trade some asset pair and then you're sort of going to want to route your trade through a bunch of different asset pairs to get some destination sort of asset that you want.
00:15:16.180 - 00:15:59.402, Speaker A: And in this sort of routing setting there's like a way to compare what I'm going to be calling selfish routing of these trades with something that was defined sort of a year or two ago, which is optimal routing under the presence of Sandwich attacks on this network. And so we're going to rely on game theory models that are very similar to sort of congestion games, the congestion games literature. What do I mean by selfish and what do I mean by optimal? So let's just take a very simple example of this two asset, two exchange kind of network.
00:15:59.402 - 00:16:18.750, Speaker A: And this is a stylized example from Pagoo's network and congestion. So what is this network? So this network is you have two assets, A and B and you have two exchanges. The first exchange is nothing other than uniswap, right? So this is just I'm trading on uniswap on this first exchange.
00:16:18.750 - 00:16:25.590, Speaker A: The second exchange is just going to be a constant price. Market makers, they're just going to quote a constant price all the time. So it's just going to be linear output.
00:16:25.590 - 00:17:15.750, Speaker A: And now what I want to do is I want to sort of say, okay, what if a central planner, like someone like a coordinator was able to route trades across this network? Coordinator is able to look at the trade that comes in to this network and say, hey, I want to optimally route this trade across the network. And what do I mean by optimally? Optimally to maximize the net output from the network. Okay, and you can think of this trade, this trade delta that I'm talking about as some aggregate of a bunch of users trade, right? So it's like a bunch of individuals have submitted trades into this network and now they want to sort of maximize the total output that the central planner wants to maximize the total output that they get from the network.
00:17:15.750 - 00:18:06.630, Speaker A: And so you can write down sort of an optimization problem that does this. So all I'm doing is I'm maximizing the output from the first CfMM, the output from the second CfMM, subject to some feasibility constraints that just say the trades on the two edges have to be equal to the trades. Like the trade that came in and it was shown by anjaris at all in 2022 that this problem and this entire class of problems of optimal routing on this class of constant function market makers is a convex problem and in fact admits sort of a solution in which the optimal route is the one that equalizes the marginal prices across the path.
00:18:06.630 - 00:18:33.310, Speaker A: So the way to optimally route is to say is to set the price on edge one equal to the price on edge two at the optimal trade. And this is sort of a very general thing that holds for basically all kinds of networks and all kinds of trading functions. Okay, so this is what the central planner would want.
00:18:33.310 - 00:19:09.030, Speaker A: Now let's think about what does the user want, the individual user that has submitted a trade into this network. And what that user kind of wants is to maximize her share of the output from the network or in some sense like her prorata share, like the amount that she's being paid out from her share of the trade that went into the network. And this kind of leads to a natural notion of an equilibrium or a selfish kind of equilibrium on this network, which is that the average price across these paths should be equal.
00:19:09.030 - 00:19:34.930, Speaker A: And so what do I mean by average price? I would say I look at the total output that I received from the path and I normalize it by the input that I receive. This is some sense, this is like the prorata amount that the user is receiving out of like every infinite decimal user is receiving out of the network for her share of the trade. This is a notion of equilibrium.
00:19:34.930 - 00:20:05.198, Speaker A: And so let's see what this implies in this very simple notebook. So before I show some sort of simulations and plots, one additional thing I want to say is when there is a sandwich attacker on, say, one of this network, on one of these edges, say, on Uniswap, we can actually modify the output that the user is going to get to account for the loss due to the sandwich attacker. And here is just an explicit example for what that looks like.
00:20:05.198 - 00:20:37.074, Speaker A: For uniswap or uniswap you can explicitly compute the sandwich attack and you can write down what the modified output function g one send is as a function of the sandwich. So whenever there's a sandwich attacker we'll be sort of modifying, we'll be sort of using this modified version of the output function and note that this is actually a function of ada, right? This is a function of the user's slippage parameter. So in some sense the slippage parameter is acting as like the strategy of the user.
00:20:37.074 - 00:21:07.342, Speaker A: The strategy is like I supply a slippage limit, the sandwich attacker gives me an optimal sandwich in response to this. And now I'm going to reason through my equilibrium notion as a function of my slippage, the linear sort of output function. And then this is uniswap.
00:21:07.342 - 00:21:15.070, Speaker A: So this is uniswap. This bold line is uniswap with no sandwiches. This is just nominal uniswap.
00:21:15.070 - 00:21:42.670, Speaker A: And as you can see, as you expect, as you start increasing the slippage limit, sort of this curve is going to start shifting down and it's going to get sort of worse and worse for that path. But now let's try to see what our equilibrium notion is saying. So I remember our equilibrium said the user is going to maximize her pro auto share of the output from the network, which means equalizing the average prices across the path.
00:21:42.670 - 00:22:19.094, Speaker A: And as you can see, the place where this actually happens under no sandwiching. So if you see when there's no sandwiching, the place where this actually happens is when all of the flow is basically kind of being routed on the top path. So basically everyone's going to take you to swap, right? And this equilibrium sort of shifting as you change the slippage limit because the user is sort of responding to how much they're probably going to get sandwiched on G.
00:22:19.094 - 00:22:42.282, Speaker A: One, one thing I will note is this ability to reason through the output function is like a very strong assumption. We're saying that the user is actually able to reason about how much they are getting optimally sandwiched for a particular value of slippage. And there's actually a very strong sort of cognitive assumption to place on the user.
00:22:42.282 - 00:23:11.160, Speaker A: One can imagine sort of relaxing this kind of thing to hey, the user has actually got some data that they're learning from in an online sort of fashion and they're going to sort of do this estimation procedure to figure out how much they should put on a given path. And that is like, I think some interesting future direction. Okay, so let's just see how the equilibrium and the optimum look.
00:23:11.160 - 00:23:34.530, Speaker A: The first thing I'll note is the optimal routing problem says you shouldn't actually place all of your flow on the first edge, right? So you should actually split your flow somehow roughly 50 50. And initially these two are like very far apart. So initially the optimal routing problem, like when there's no sandwicher, there's no slippage, the user is just not specifying any slippage.
00:23:34.530 - 00:24:25.438, Speaker A: These are very far apart and then the equilibrium sort of starts shifting, equilibrium starts shifting down as you modify the slippage limit. So let's now generalize this idea slightly to the next most interesting network in congestion games, which is this brace network. And the point that I'm going to try to convey here is actually sort of counterintuitively that the presence of this sandwich attacker on this network, say on this middle link between C and D can actually improve sort of the price of anarchy of this network.
00:24:25.438 - 00:25:01.426, Speaker A: Which is like a weird kind of thing to think about, which is like and what I mean by price of anarchy here is the output under the equilibrium, this selfish notion of equilibrium and the output under the optimal routing. And the reason I think this might make sense for those who have done congestion game stuff is the sandwiched attacker is effectively acting as a tax, right? He's acting as a, he's taxing this edge. He's increasing the price or the cost for the user sun's edge.
00:25:01.426 - 00:25:27.634, Speaker A: And we know from congestion games that taxes can actually help reduce the price of anarchy. It's not exactly the optimal tax in this case because it's not like a marginal cost tax or anything like that, but it is a tax on this network. What we're going to show is that this can actually help, this can help in the price of anarchy measure.
00:25:27.634 - 00:25:47.142, Speaker A: So you can reduce the tendency of users to do selfish things. Okay? So once again we can write down the optimal routing problem. In this case it's more involved because now we have to account for these flow conservation constraints along the path.
00:25:47.142 - 00:26:03.470, Speaker A: But once again it is convex. We can solve this to optimality. And the selfish equilibrium here, the selfish routing equilibrium is again a little bit more involved but it's basically the same idea.
00:26:03.470 - 00:26:23.554, Speaker A: Now instead of looking over these edges, I'm going to look over paths because I remember I said the average price across the paths has to be equal because that's the pro rider share that the user is receiving. And so you can write down the equilibrium condition. These lambdas are nothing other than the outputs that you're receiving from the intermediate nodes, from the intermediate CFMS.
00:26:23.554 - 00:26:49.930, Speaker A: And alpha one, alpha two, alpha three are the fractions of the trade that are routed on path one, two and three. Okay? And so now let's look at what happens. So initially the equilibrium output, which is all the way down here in red, is like very far removed from the optimal output.
00:26:49.930 - 00:27:27.770, Speaker A: And then what's going to happen is as the slippage sort of goes up, remember again, the user is like reasoning through the output function. The slippage is going to sort of force the users to trade more and more sort of on all three paths and the equilibrium is going to sort of move towards optimality. And we can visualize this again in price of anarchy terms, which is again the ratio of the output under equilibrium to the output under or rather the output under optimality to the output under equilibrium.
00:27:27.770 - 00:28:04.898, Speaker A: So we get this basically reduction of price of anarchy as slippage tolerance goes up and eventually they just converge. Okay? So this is sort of my last slide. But one thing I'll say is you can generalize this kind of idea to sort of arbitrary networks of Cfmms by using sort of those bounds that I showed on the price impact functions and output functions to come up with these price of Anarchy bounds globally for this entire class of Cfmms.
00:28:04.898 - 00:28:44.366, Speaker A: And then the idea is that these sandwich attackers can actually act as coordinating agents to tax users away from selfish equilibrium. Kind of a question I have is what other places because the analogy to congestion games and routing problems is very clear here. Where else does this kind of have this feature that an extractable kind of value is acting in some sense? You might not be happy with how they're doing the taxation and coordinating, you might not be happy with where the taxes are going, but locally they're sort of doing this coordination.
00:28:44.366 - 00:29:07.290, Speaker A: And of course, there's this question of how do you actually learn these parameters as a user if you're in this network and you're participating over time, which is, again, interesting future direction, but I think that's my last slide, and I'll stop there. And if we have any, I think it'd be nice to sort of have some interactive parts.
00:29:07.870 - 00:29:08.330, Speaker B: Hello?
00:29:08.400 - 00:29:09.258, Speaker A: Can you hear me?
00:29:09.344 - 00:29:14.640, Speaker B: Hi. Very nice talk. Actually, I have somewhat of a technical question.
00:29:14.640 - 00:29:36.580, Speaker B: So yeah, you produce this reduction to congestion games. What is the resulting cost function along those edges? So is it like some sort of polynomial cost function or any other properties that you talked a bit about? I think some sort of ellipsis constants, but I was just curious if it belongs in some other prestudied class.
00:29:37.270 - 00:30:07.130, Speaker A: Can you use the microphone? Can you hear me okay? Yeah. The price functions for these constant function market makers and also the output functions typically have these at least local sort of linear bounds. The output functions are like concave functions.
00:30:07.130 - 00:30:31.030, Speaker A: But I think in congestion games usually we're usually dealing with functions that have particular kinds of growth rates and stuff like that. In usual congestion games we have these functions that are like one plus x to the four or something like this. We don't have it pinned down that specifically.
00:30:31.030 - 00:30:56.426, Speaker A: And the way that you get the Price of Anarchy bounced are actually like using this sort of general technology of these Lambda Muveness. I guess the only real assumptions you have about these functions is that these capital G functions are like concave functions. They have local linear bounds.
00:30:56.426 - 00:31:16.740, Speaker A: You can assume they have sometimes they have one sided sort of sharper quadratic bounds as well. But yeah, I don't think it's as pinned down as in conjunction games where we're typically dealing with one form of a function like one plus x to the fourth or one plus x to the alpha or something.
00:31:18.090 - 00:31:19.080, Speaker B: Thank you.
00:31:20.410 - 00:31:29.750, Speaker C: Hi, I also have a question. Yeah, nice talk. In regard to the Braze paradox results.
00:31:29.750 - 00:31:56.370, Speaker C: Am I thinking about? It right that you kind of need there to be four distinct assets that are in the trading pool for those vertices to make sense, and that you also need a trader to be willing to trade from A to C and then from C to D. And then I'm also right that sandwiches cannot help for a pair trading pool.
00:31:58.470 - 00:32:10.920, Speaker A: Yeah, I think that's right. You got just some weird setting. Okay, awesome.
00:32:10.920 - 00:32:38.542, Speaker A: There are four distinct assets here, ABC and D where the input asset and the output asset are A and B respectively. And then each of these are like these are the available paths to the user? Basically, yes. And I think it's correct that if you just have a sandwich attacker on a single edge and you're only allowed to trade between that edge, then there's no hope.
00:32:38.542 - 00:32:49.540, Speaker A: Right, because there's basically that sandwich attacker strictly I mean the equilibrium and the optimum there is just to trade on that edge and the sandwich attacker is going to strictly degrade both of them at the same time.
00:32:50.550 - 00:32:51.540, Speaker B: Thank you.
00:32:53.030 - 00:32:53.442, Speaker A: Hi.
00:32:53.496 - 00:33:17.882, Speaker B: Thanks. So I have two small questions. The first one is a bit more practical, but have you thought about including more practical things like fees into your model and how would that affect the routing? Because if you have to use multiple routes then you're going to pay more fees and that's going to probably impact it.
00:33:17.882 - 00:33:28.430, Speaker B: And then the second one was a bit more general, but I was curious if you thought about other ways to tax users and redistribute these taxes.
00:33:35.960 - 00:33:53.180, Speaker A: Yeah, perfect. I think regarding the fees question, maybe I'm wrong, but I think this paper by Anjaris et al. Actually considers the routing problem, the optimal routing problem with fees.
00:33:53.180 - 00:34:30.920, Speaker A: I think so maybe I'm missing it, but yeah, I think the optimal routing problem with fees should not be too much harder because you sort of just get the presence of these factors that are hitting the trade inside the trade, like g one of some gamma times lambda one and that kind of stuff. As far as how it affects this equilibrium notion, I'm not sure. And I think that is actually, I think, a pretty interesting direction.
00:34:30.920 - 00:34:51.520, Speaker A: Effectively it's going to act kind of like a tax again, right? It's going to act like another additional cost that the user has to pay on particular edges. And if the fees are different across different paths, then the user might prefer one path to the other just because of the difference in the fees. So it might actually meaningfully shift the equilibrium.
00:34:51.520 - 00:34:58.050, Speaker A: Sorry, I just forgot your second question. Would you mind repeating it?
00:34:59.540 - 00:35:09.172, Speaker B: Thanks. No, the second question was about different ways of taxing users and redistributing these taxes, right?
00:35:09.306 - 00:35:30.588, Speaker A: Yeah, different ways of taxing. I think these fees are in some sense like an explicitly specified tax and the sandwich attacker is kind of like implicitly or you just know that these. Agents are out in the world and they might tax you at any given time.
00:35:30.588 - 00:35:55.652, Speaker A: So I think those are like the two kinds of taxes in my head. And I think redistribution is a very interesting question because yeah, right. If it so happens that all of this excess value that's captured in this example, all of this excess value that's captured by the sandwich attacker simply goes to the searcher, that probably is not like a good way of redistributing it.
00:35:55.652 - 00:36:29.570, Speaker A: I mean, it might be better if it went to either there's arguments people have made, arguments like, oh, it should go to the validators in the network, or it should go back to the users, or it should sit in some box that's like, untouched and then at the end of day, we should just burn all of them or something like that. So yeah, I don't have any concrete things to say about that but I do think it probably makes sense to either redistribute it back to the network or the users in some meaningful way.
00:36:31.300 - 00:36:32.290, Speaker B: Thank you.
00:36:36.180 - 00:37:18.300, Speaker C: Okay, yeah, I think that should be all of the questions. But additionally I also want to hear you about kind of leading how long is the next step? Okay yeah I want to hear you a bit about how does this example of constant function maker congestion games relate to the broader blushing as a commitment device study. What are some of the ways that you have seen of the past studies? How can we use our studies of commitment devices to help mitigate such problems such as mev? Such as congestion games?
00:37:20.960 - 00:37:50.660, Speaker A: Yeah the example here kind of shows that again, this is a very stylized example. This is like the first pass synthesis. It kind of shows that the presence of these what we think of as adversarial agents that are purely like profit extractors or something like this is in fact helping to coordinate users away from these selfish equilibrium.
00:37:50.660 - 00:38:45.130, Speaker A: And the degree to which you might want that I guess we can debate. But I think something that's quite interesting is and I mean again people in congestion games land have tried thinking about this as well which is how can you kind of get decentralized kind of control of systems like this without having to explicitly specify what actions you're going to take to deconflict these users in the system? Can you set up incentives for these searchers that sort of allow them to locally resolve these sort of bad equilibrium that users end up in? And I think that's a very interesting thing but again that's kind of vague in my head at the moment. It's not clear how you would set up what kinds of incentives you'd set up for them.
00:38:45.130 - 00:39:14.790, Speaker A: But it does seem like these agents are kind of a resource that can be used to do certain kinds of this kind of decongestion deconfliction kind of thing. But yeah, I'd have to think more about that. But yeah, as a first pass, it does seem like there's something that can be done to, again, do, like, decentralized control of the system.
00:39:17.670 - 00:39:24.658, Speaker C: Okay, thanks. I think that should wrap up this session. Thank you.
00:39:24.658 - 00:39:28.254, Speaker C: And yeah, we should do a round of applause.
00:39:28.302 - 00:39:33.300, Speaker A: I don't know if we can do cool. Thank you.
00:39:36.020 - 00:39:47.624, Speaker C: Okay. And the next session is going to be a panel with Georgio Sent, Vincent, Giorgio Still. Yeah.
00:39:47.624 - 00:39:50.310, Speaker C: It's going to be a bit hard because Mike said.
