00:00:03.370 - 00:00:35.750, Speaker A: I'm going to talk about private searching on private transactions, this stuff I've been working on the recent weeks. So let's jump right into it. What do I mean by private searching on private transactions? I assume that users want to receive kickbacks on the mev they generate but they still want keep their transactions secret and at the same time searchers want to keep their intellectual property secret, right? They don't want to reveal their searching strategies to competitors.
00:00:35.750 - 00:01:05.314, Speaker A: So the question is can we have both, is this possible? Can searchers generate front running and or back running transactions under these conditions? Since we're in the area of private computing here, like an obvious first step is SGX and when I say SGX here, I use it synonymously for trusted execution environment. So I'm just using SGX. So very simple setting here.
00:01:05.314 - 00:01:26.130, Speaker A: User the user's input is a transaction, the input to an enclave. The searcher inputs a program within the SJX enclave. The runs a program that takes the searcher program and executes it upon the transaction and it outputs a signed transaction signed background that is sent to the builder.
00:01:26.130 - 00:01:49.018, Speaker A: So that sounds great, but there is a catch to that, right? The catch is like covert channels and quickly explain what covert channels are because it's a very niche topic and hardly anyone knows about it. So covert channels are ways to secretly convey information. Like in order to do that they piggyback on so called overt channels.
00:01:49.018 - 00:02:09.590, Speaker A: And if you're coming from telecommunications background, you can also think of COVID channels as a way to secretly modulate information on an existing carrier signal. It's a bit of abstract. Most people understand it when you compare covert channels to side channels because people are usually aware of what side channels are.
00:02:09.590 - 00:02:29.574, Speaker A: It's just a difference in an attacker model. So with side channels, the attacker aims to extract information but the attacker does that by observing, let's say for example from outside the system. For example, there's an algorithm running and the attacker can observe the power consumption.
00:02:29.574 - 00:02:44.078, Speaker A: I think that's a very classic example. But with COVID channels the attacker has the same goal so to extract the information but it additionally has support from inside the system. So there's basically a colluder.
00:02:44.078 - 00:03:10.140, Speaker A: You can also see why there's a stronger attack here. How does that relate to the SGX thing? Well, if I think about it, what are potential over channels here? Like the signed background, right? This is the output. Can the searcher program manipulate the signed background? Well, obviously yes.
00:03:10.140 - 00:03:32.910, Speaker A: The program could be as simple as saying well, take the user input and this is the output. So in order to protect against that, we could encrypt another over channel would be network communication. The searcher program could be as simple as saying well, open a network connection to a host, take the user transaction and send it over to the network.
00:03:32.910 - 00:03:46.630, Speaker A: So we need to filter that. But it gets tricky if you think over channels in terms of CPU and memory of the host system. I think Andrew Miller had a similar point here.
00:03:46.630 - 00:04:10.780, Speaker A: So how can we ensure that the searcher program does not encode secret information in CPU or memory access or usage patterns? You can think of, let's say, encoding information in how much CPU is used. Let's say you're using CPU for 1 second to encode a one, or for 2 seconds to code a zero and leak information that way. And that is very hard to protect against.
00:04:10.780 - 00:04:33.598, Speaker A: So there's different ways on how to go about this. Well, this seems to be a trade off, right? Like how expressive should the searcher program be versus the existence of information leakage or covert channels? We can start with a fully expressive program, search a program, then check is there a covert channel? Yes. Restricted.
00:04:33.598 - 00:04:37.590, Speaker A: Say we don't allow network communication. Is there still a covert channel?
00:04:37.660 - 00:04:37.942, Speaker B: Yes.
00:04:37.996 - 00:04:47.362, Speaker A: Okay, I don't know. We prevent for loops, let's say. But there's always the question, is there any leakage left? We could go the other way around.
00:04:47.362 - 00:05:10.640, Speaker A: Say we start like a fully restrictive program and ask the question is it useful? Right? So if the searcher program can't do anything, it's obviously useless. So we say, okay, let's allow additions, for example, is it useful? Well, probably not. The question is, at what point is it useful enough? It's also hard to say.
00:05:10.640 - 00:05:36.038, Speaker A: Or we could start somewhere in the middle between in the expressiveness level. The question is then where should we go from there? What we decided to do is to start with MPC, because MPC, interestingly, guarantees that the parties cannot learn anything but the output of the function. So there are no covert channels there.
00:05:36.038 - 00:06:03.390, Speaker A: As a general statement, what is MPC? It allows multiple parties to jointly compute a public function while keeping their inputs secret. So this is a good start to explore the design space. Going back to the original question, like secrets searching on secret transactions, how would this look with MPC? So instead of using SGX, we now have like an MPC back running protocol.
00:06:03.390 - 00:06:14.770, Speaker A: We don't know yet what this would look like. And again, we have the user input a transaction, searcher input a program, and the output is a signed back running transaction. We just don't know.
00:06:14.770 - 00:06:36.570, Speaker A: The question is what is the back running protocol or how does it work and what is the searcher program? And we started experimenting in the MP speeds framework. It's a general MPC framework. And I'm going to quickly present the current state of the proof of concept.
00:06:36.570 - 00:06:54.082, Speaker A: So first thing, what does the searcher program look like? It turns out like a searcher language can be pretty simple. So the searcher program can just consist of a list of constants, a list of computing instructions. And computing instructions are very simple.
00:06:54.082 - 00:07:06.274, Speaker A: So it's addition, subtraction, multiplication, V square root. That's not super simple, but still it's relatively simple instruction. But note that there are no loops and there is no branching.
00:07:06.274 - 00:07:21.914, Speaker A: We cannot allow that. There's a couple of comparison instructions and a list of references for the populating the back running transaction. So what does the back running protocol here this middle thing.
00:07:21.914 - 00:07:40.670, Speaker A: What does the back running protocol look like? Turns out this is simplified python like code. But it's just to highlight how it works on a high level. We have like a protocol internal storage.
00:07:40.670 - 00:07:56.840, Speaker A: If you think about what a transaction is, it's just RLP encoded data. So the first thing is to decode the data, make it and populate the storage with that. Second step is take the constants from the searcher, populate the storage with that.
00:07:56.840 - 00:08:20.300, Speaker A: Next step, take the searcher's computations, execute the computations one by one on the storage, and then run the comparisons. So the searcher provides a couple of comparisons. And note here that there is a success variable and all of the comparisons must be true in order for the success variable to remain true.
00:08:20.300 - 00:08:41.362, Speaker A: Then in the end, the back running transaction gets populated. I think the interesting part here is that in the end, back running transaction is sent to the builder if and only if all of the comparisons were true. So this is a very abstract introduction of how the proof of concept works.
00:08:41.362 - 00:08:50.502, Speaker A: We can walk through an example. I guess this makes it a bit easier to understand. So this is an example with a real world transaction from last month.
00:08:50.502 - 00:09:05.962, Speaker A: A user sold 3.75 E for USDT on the uniswap v two pool. So first step for the protocol would be to decode the transaction and populate the storage so you can see the non SCAS limit, whatever.
00:09:05.962 - 00:09:26.610, Speaker A: So that's the entire transaction. In the second step, the protocol loads the constants from this provided by the searcher. There's a couple of I won't go into all the details, but constants for the comparison, for the back running amount and for the back running transaction.
00:09:26.610 - 00:09:52.730, Speaker A: What is important to note here is that the searcher also provides on chain information. For example, here it's the number of we tokens in the pool at that point in time or the number of USDT tokens at that point in time. And I think it's a fair assumption because the searcher already knows for its strategy, like what on chain information is needed.
00:09:52.730 - 00:10:08.880, Speaker A: And we can expect the searcher to provide exactly that information. So there's no need for the back running protocol to query the EVM or the ethereum p to peer network for additional information. We can just assume the searcher to provide that information.
00:10:08.880 - 00:10:33.810, Speaker A: But what is the strategy now for the searcher? Right, the searcher wants to back run a uniswap trade. The searcher kind of knows that in this particular trade, a user sold ETH to the pool. So the size of the pool increased and took out USDT from the pool.
00:10:33.810 - 00:10:41.714, Speaker A: So this slightly affected the price. Obviously the searcher knows that. So the price of ETH went down slightly.
00:10:41.714 - 00:11:08.222, Speaker A: So the question for the searcher is what is the amount I can put in in order to move the price up again to a certain target price. And you can use the formula like I'm not going to go into the details of the formula but it's important to note here there's just like a couple of simple computations. You have a couple of multiplications and additions like a division and the square root.
00:11:08.222 - 00:11:53.434, Speaker A: And all the information is either provided by the searcher so the fee of the uniswap market, the target price, the precision is like the number of decimals for the we token or it can be computed from the onchain information provided by the searcher and the user's transaction. For example, the y is the amount of ETH in the uniswap v two pool after the user's trade and then that can be computed by the amount of ETH in the pool before the trade plus the amount that the user put in minus the fee. So all of this can be computed obviously very important for the searches.
00:11:53.434 - 00:12:11.494, Speaker A: Also like is the background profitable? So this is also part of the strategy. So this is like on a high level the strategy like we implemented in the proof of concept. How does this look like in this searcher language? So this is not nice to read and this is just a snippet only going to explain the first line here.
00:12:11.494 - 00:12:25.174, Speaker A: So this is like 4229. So this reference is just the fourth item in the storage. Two references, a multiplication and 29 is the 29th item in the storage.
00:12:25.174 - 00:13:14.854, Speaker A: So fourth item is the amount the value in the user transaction multiplied by the in this case searcher provided constant the fee and this is like step by step the backRunning protocol can execute the computations provided by the searcher. Obviously it's important that the searcher wants to send the back running transaction if and only if the user transaction actually is selling e for USDT because the strategy the computations provided is really targeted for that and if the background is profitable. So there's a couple of comparisons like it works similar way if you look at the first line, this free 423 is third storage item.
00:13:14.854 - 00:13:36.340, Speaker A: This is the two address of the user transaction. Four in this case is the equal operator and 23 is the uniswap v two router address that was provided by the searcher as a constant. Just a couple of comparisons probably the last line is also an important one is the background profit greater than zero.
00:13:36.340 - 00:13:53.282, Speaker A: So if all those transactions, all those comparisons are true then the back running transactions is created. Creating the back running transaction is actually the simplest part of that. It is just a list of references to storage.
00:13:53.282 - 00:14:03.146, Speaker A: So let's say that it's 40. This is the FORTEST element in the storage. This is non, then you have the gas limit, gas price and so on.
00:14:03.146 - 00:14:15.950, Speaker A: And these items are like the values are taken from storage RLP encoded. This is the back running transaction. So this is the proof of concept.
00:14:15.950 - 00:14:41.206, Speaker A: There's a couple of open questions with that. First of all, is the searcher language expressive enough to be useful? My gut feeling is yes, but I'm also not a searcher, so input on that is highly appreciated. You could also see the searcher language is very low level and this is very cumbersome and error prone to work with.
00:14:41.206 - 00:15:25.414, Speaker A: So what should a high level language look like that compiles down to this low level language? And also, how can we make this practical? I mean, this proof of concept implemented in the MP speeds framework on the single transaction, a single searcher strategy takes in the strongest security model, takes like 40 hours to compute and a couple of hundred gigabytes of back and forth communication. So this is nowhere practical. How to make this practical? Right, recall, like we started experimenting with MPC because we needed to restrict the expressiveness of the searchers program.
00:15:25.414 - 00:15:51.680, Speaker A: And now we arrived at the design that is restricted and hopefully expressive enough. So can we use that and now implement it using SGX and create a practical solution? Probably. We also need to emulate some NPC like behavior, like execute all branches have constant time functions, but maybe that's a way forward.
00:15:51.680 - 00:16:16.446, Speaker A: Another way would be to go for application specific NPC or with homomorphic encryption. Why is that? If you zoom out a bit and the proof of concept design basically has three phases, right? This extract the data from the user transaction. This could happen on the user machine.
00:16:16.446 - 00:16:29.430, Speaker A: So this is easy. The user could use that and encrypt it, send it over to the searcher. Then the searcher does a couple of computations on the extracted data and some constants that sounds exactly like homomorphic encryption.
00:16:29.430 - 00:16:51.040, Speaker A: And if you think about it, we only need to support very limited operations. So maybe partially homomorphic encryption is sufficient. And if it is, then we have partially homomorphic encryption schemes with reasonable performance that exist already today.
00:16:51.040 - 00:17:05.300, Speaker A: For me, a big open question is we also need to enforce certain conditions under which the back running transaction is revealed. And I have no clue how to do that in a practical way. So if you have ideas, go ahead, share it.
00:17:05.300 - 00:17:31.280, Speaker A: So that's it the takeaways from this talk. If it's just the two takeaways, covert channels are referred to SJX deployments and they should be considered. And private searching on private transactions may be possible, even though they're not obviously not practical at the moment.
00:17:31.280 - 00:17:34.480, Speaker A: Any questions?
00:17:37.090 - 00:17:39.630, Speaker C: Wow. Thank you Robert, for this talk. Very interesting.
00:17:39.630 - 00:17:55.540, Speaker C: For me, I didn't appreciate the covered channels for SGX. I guess I don't completely understand how covered channels are addressed in the MPC case. Go ahead.
00:17:56.010 - 00:18:02.760, Speaker A: Yeah. For me, before I started with playing around with MPC. I had the same question.
00:18:02.760 - 00:18:20.720, Speaker A: The fun thing is, for me the insight was they're just not an issue with MPC. They just don't occur. They're already by their because by design you cannot leak information.
00:18:23.890 - 00:18:35.998, Speaker C: Well, a very simple MPC is just the constant function that returns all the inputs without doing any operation and that leaks everything, leaks the whole input.
00:18:36.174 - 00:18:42.530, Speaker A: So that would have okay, sorry, it doesn't leak any information apart from the output.
00:18:45.430 - 00:18:46.180, Speaker C: Right.
00:18:49.830 - 00:19:17.642, Speaker B: When writing an MP speeds program, you still kind of have the problem that you have to do. If you have an array and you want to do an index into that array that depends on some data, like an input dependent lookup you're forced to either do a linear scan through the whole array, which costs a lot, or leak something by publishing which value in the index you want to do and doing some kind of interaction like that. So you either need to take this performance penalty or try to you could use an oram within an MPC.
00:19:17.642 - 00:19:26.260, Speaker B: That's like one of the things that the cryptography theory relies on. Sometimes the same problem seems to show up anyway.
00:19:27.190 - 00:19:33.700, Speaker A: Right, but this is how the proof of concept works. So it uses like the storage is like an Orim and it works on that.
00:19:38.170 - 00:20:03.360, Speaker B: Could you also do any distinction between covert channel and a side channel? I think that they're different and to me the difference is kind of addressed by remote Attestation, at least in the SGX setting. Because if a covert channel would be built into the code, it should be visible to auditors looking at the source code to be able to check. And at least with remote Attestation, you have that option.
00:20:03.360 - 00:20:18.900, Speaker B: And then if you check that the code only does linear scans in SGX, just like you would have to with MPC, you'd be getting the same guarantee that it's not leaking a channel because it is doing a data independent access.
00:20:20.310 - 00:20:45.690, Speaker A: I think that the tricky question is can the input to your program that runs within SGX, can the input to the program change the program execution flow in such a way that it leaks information? And sure, if you analyze the program and you make sure that this is not the case, I totally agree. I just think it's an analysis that's very hard to conduct.
00:20:46.270 - 00:21:24.040, Speaker C: I guess my question on the MPC was how can you guarantee that the program will output something which is expected? Let's say the program is a builder program which builds a block. What if instead of building a block, it just outputs just the input transactions? Or maybe in some cases, let's say in 99% of the case, it outputs a block like the expected output. But then if mev is over, let's say 1000, if it just leaks all the transactions and then the attacker can just front run.
00:21:25.770 - 00:21:44.458, Speaker A: I guess that's an issue just maybe I should have clarified like the scope for the proof of concept is just a user search interface, right? So the output is sent to the builder and the builder could see everything in clear text. And in this case, I don't bother with that. The builder is assumed to be trusted.
00:21:44.458 - 00:22:10.840, Speaker A: So let's say the searcher leaks the user transaction, it can leak to the builder and the builder is trusted in this setting. So I didn't go any further than beyond this user search interface strategy remains private among the user and searcher, but not among the output is then shared with the builder and the builder can see everything well, can see the output. Okay.
00:22:11.690 - 00:22:19.414, Speaker C: The searcher does not get access to the output, only the builder in the ping tab. Yeah, I see.
00:22:19.612 - 00:22:22.966, Speaker A: But the builder is trusted, right? The builder could act upon the information.
00:22:23.148 - 00:22:26.180, Speaker C: Okay, understood. So.
