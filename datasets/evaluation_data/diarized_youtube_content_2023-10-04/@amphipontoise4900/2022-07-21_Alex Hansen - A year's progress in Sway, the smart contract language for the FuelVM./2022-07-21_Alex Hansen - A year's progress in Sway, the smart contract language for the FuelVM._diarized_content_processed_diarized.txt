00:00:07.600 - 00:00:30.940, Speaker A: All right, cool. Hello everybody. We're going to go ahead and get started in conversation. All right? So let's all quick say a quick prayer for the single air conditioning unit in this room. Let's hope that that one stays going. My name is Alex. I'm here with fuel labs.
00:00:30.940 - 00:01:12.312, Speaker A: We gave a predecessor talk to this last year, one room over at the same conference. At that talk essentially announced, we announced the Sway programming language. We announced that's what we were going to be working on. And I am going to pull up the speaker notes right over here. And this talk is going to be a little bit of an update, a status update on what we've been doing over the past year, what promises we were able to keep and the progress that we've made. Sort of a state of the union of the Sway language. Also a little bit of a victory lap because we actually were able to keep pretty much all of the promises that we made last year.
00:01:12.312 - 00:01:51.940, Speaker A: So I'm going to go ahead and go over here. So what has been going on since last year? So last year Fuel as an effort was very small, had very little public notoriety yet besides John's Tweets basically. And we announced this smart contract development language called Sway. We drew a lot of comparisons to Solidity because that's obviously the other big smart contract development language in the room. And we kind of said, hey, this is the state of the union with smart contract development. But we think that with modern programming language theory you can do a whole lot better. We can have a lot more safety, we can have a lot more security and we can have a lot more ease of use.
00:01:51.940 - 00:02:17.150, Speaker A: And that was essentially our mission statement with Sway. So at this time last year we had about two to five PRS a week. Small group of contributors, the language barely existed. There was like a parser, some notion of a type system, but not very much. The syntax was still very wishy washy. We hadn't totally nailed all of that down yet and we had yet to run a single functional smart contract. It was all hypothetical, we were all specifying everything.
00:02:17.150 - 00:03:05.560, Speaker A: So one year later, now what do we have? So we have about five to 15 contributions per day with 53 total contributors to the repository. Those are external, internal, people who are parts of the Fuel organization, people who aren't. It's an open source project, you're welcome to check it out. In addition, we have applications being developed in Sway. So we've gone from, hey, we're going to build this compiler, it's going to be nice, we have a lot of aspirations to actual contracts being deployed and used in one year, which we're quite proud of. In addition, we have a robust tooling surrounding Sway that we'll talk about in a little bit and we also have built up quite a community there's a Discord channel with a few hundred people, last time I checked, at maybe 500 or so. We got a lot of external contributions on GitHub.
00:03:05.560 - 00:03:25.890, Speaker A: And what's really crazy is people are starting to recognize the lightning bolt when we walk around here. That was not happening a year ago. Cool. So going to give a quick overview of this talk. So this is not going to be a super technical talk. We're not going to dive in and develop a contract or anything like that. This is going to be sort of an update on the project.
00:03:25.890 - 00:04:01.020, Speaker A: There was a workshop earlier today in Sway like how to develop a smart contract. We also have tutorials, online discord Channel documentation. If you're interested in any of that, please just let me know after the fact. After this talk, we'll go ahead and get you hooked up with some of our community people who will help you get started. So we're going to start off with some of the technical stuff, some of the technical promises that we were actually able to keep. So there are three examples of some stuff that we talked about last year. So this is ripped straight from a slide last year.
00:04:01.020 - 00:04:22.070, Speaker A: You'll see, at the top we have some Solidity, an example of a contract declaration with some storage, some state variables. And at the bottom is what we thought we would have storage looking like last year. This is not what we ended up with, but this is kind of what we hypothesized it. So that's where we were at. That was our AB comparison. Like this is what you write now. This is what it's going to look like.
00:04:22.070 - 00:04:49.900, Speaker A: We also had an idea of a contract Abi. So you declare your abi. It's an abstract interface. You implement your Abi for your contract and that's essentially how you define a smart contract. This was what we thought we would do last year. In addition, Solidity has a notion of View functions, pure functions, et cetera. We thought we'd have some syntax that was similar where you declare view and you could use that in your API.
00:04:49.900 - 00:05:09.664, Speaker A: So this was all pseudocode last year. So what's really cool about this talk is that we're not going to show pseudocode anymore. This is actual functional Sway, part of our test suite. It's one of our basic test contracts. It's an incrementer contract. So you deploy this contract and then anytime you call it, you can increment it by a certain amount. It's a very basic contract.
00:05:09.664 - 00:05:36.024, Speaker A: It's one of our test contracts. But what's cool and the excitement that I hope is coming across is that it's fully functional working contract that's deployed in our language, which we've only been working on for a year. Kind of my baby. So I'm a little proud of it. So let's go ahead and break this down. So of those three things that I just talked about, we had the Abi declarations, we had view pure functions. And we had the Abi syntax.
00:05:36.024 - 00:06:02.340, Speaker A: So I have to stay over here because of the camera, but I'm going to point, and I hope you guys can see where I'm pointing, unless there's a laser. Does this have a laser? Same way? No. Okay. Is this one better? Okay. So at the top you have your Contract Storage declared. That's the first thing that changed. So now you declare your contract Storage, and it is essentially a global variable that is stateful in between executions of your contract.
00:06:02.340 - 00:06:38.044, Speaker A: You'll see that we've adopted Rust's annotation syntax. So I'm going to hop over here and point this out. That is something we took from Rust, which is a language that a lot of our syntax is inspired by. It's a pretty simple notion and it's also extensible, so you can annotate other aspects as well. But this just says this function will read and write to Contract Storage. The writing is here, the reading is here, and the bottom function, which just lets you get the current value of the counter, is only a read function. So once again, this is where we ended up at with those notions.
00:06:38.044 - 00:07:11.908, Speaker A: We're really proud of this. We think this is a very clean way of writing a contract, and we think there's a lot of improvements to be had when you write a contract like this instead of in Solidity. Another thing that we promised another thing that we promised was Structs and enums. So some of you may be familiar with C style enums or Structs and Solidity and stuff like that. What we mean here is sum and product types. So who here has familiarity with these terms? Quick show of hands. Sum and product types.
00:07:11.908 - 00:07:48.100, Speaker A: Okay, it seems like the room is pretty knowledgeable, so we don't need to go too deep into this. But essentially an enum is an enumeration of potential values. So it could be this, it could be this, it could be this. Whereas a structure is a grouping of data. So it has this field and this field, and this field, solidity has Structs. If you're familiar with JavaScript, JavaScript object is a product type. So what we were able to deliver on this and the fact that we have robust sum types with generics, which we'll get into in a second, leads to a lot more safety and expressiveness than you would have in the Solidity program.
00:07:48.100 - 00:08:10.060, Speaker A: So this is a really trivial example. OOH, I can point like this. So over here on the left, we have a generic structure. This is just a very basic example where you have a wrapper type. This just kind of shows some of our Rust inspired generic syntax and Struct instantiation. So this is more just to get you familiar with the syntax. Over here we have a declaration of an enum.
00:08:10.060 - 00:08:29.540, Speaker A: So these parentheses are what's called the unit type or the empty tuple. It's a type that has only one value. It can only ever have one value. It's usually used to signify nothingness. It's zero sized. It doesn't have any size in the compiler or in the bytecode. So what this means is there's an enum that can have five potential colors.
00:08:29.540 - 00:09:08.080, Speaker A: One of them is represented with zero size. So what this essentially has an overhead of one U 64, one number to keep track of which size it is. And our enum Instantiation syntax is down here. So this is a really trivial example. Let's go ahead and take a look at what we've been able to accomplish with this notion that you wouldn't see in, for example, the Solidity Standard Library. We'll talk about this more in a moment. We have our own standard library in development, and one of the biggest things that makes it safer is so if anybody's ever used Rust or Haskell or anything like that, this is a really common notion.
00:09:08.080 - 00:09:42.108, Speaker A: So it's a generic type and can have two variants. It's either, okay, there was no errors or there was an error and you throw an error. So what does this actually mean in practice? So this is our EC recover function in our Standard library. We're not going to dig into it, we're not going to go into the details here, so don't worry about that. But I want you to pay attention to the function signature here on line 15. So does anybody know what the behavior of EC recover is? In solidity, if the recovery fails, you get all zeros. Yeah.
00:09:42.108 - 00:10:27.050, Speaker A: So does anybody see any problems with that? If you get all zeros back from your EC recover function, like from a programmer's ergonomic perspective, well, it doesn't give you any information about the failure. That's definitely true, but also it's up to you, the programmer, to kind of know that behavior. You have to read the documentation, which is always good practice. But what's important is that your tool knew that it failed and it did not force you to handle a failure. Right? Like, let's say you're transferring coins. You have to pull check that wasn't zero every single time, and there will be no compiler, there will be nothing to tell you that you messed that up, and there's no reason for that. Modern programming language theory is so much further beyond that.
00:10:27.050 - 00:11:12.376, Speaker A: I mean, extremely unlikely somebody could get the keys to the zero address and take all your assets or something, I don't know. But what's more likely is that you would have asset loss, right? Like, you would send it off, maybe somebody could never recover it. But just because as a programmer you failed to check and that's kind of like buying a car without a seatbelt, that's not really something that should be acceptable today. We know how to handle these situations. So our UC recover function in our Standard Library will return a descriptive error of what exactly went wrong if it does fail or return. Okay, if you were able to recover the public key. When you use this function, it does not return just the key.
00:11:12.376 - 00:11:53.264, Speaker A: It doesn't throw an exception, it returns a result. So if you're familiar with some types, it's either the successful value or the error. So this is already cutting down these kinds of things in our standard library functions is already cutting down the rough edges. If you're just now learning how to write smart contracts, there's hundreds of these rough edges that you just kind of have to know through going through the school of hard knocks. Okay, so we're just going to take one more quick look. I'll go a little bit more quickly through this one. As seems like the room is pretty familiar with some types, but I was just going to go over how expressive you can be with combining sum and product types.
00:11:53.264 - 00:12:18.300, Speaker A: So up here is what you would call a product type. The reason for that is it's a structure with two fields, a and B. Both of these are numbers. They are U 64s sticker. For anybody who can tell me how many potential values of a U 64 there are. Anybody? Okay, it is, yes. Cool.
00:12:18.300 - 00:12:51.076, Speaker A: So it's two to the 64. And so this is called a product type because let's say you have two to the 64 potential values of A, two to the 64 potential values of B. So the product of those two numbers is the amount of potential values for my struct. Bit of word salad, we still here. Okay, so that's a product type and a sum type. Here the unit. Well, you add them instead of multiply them.
00:12:51.076 - 00:13:22.572, Speaker A: So variant one is the unit type. It can only ever have one potential value. Variant two, as we've covered, could have two to the 64 potential values. And then variant three, which is my struct, has that product type that we calculated. So this is the total number of potential values of this enum. So you can get really expressive in instantiating these enums and you can represent all kinds of cool things with static type safety. To access values inside of them, we have match statements.
00:13:22.572 - 00:13:43.112, Speaker A: So this is something that we talked about last time, match statements with exhaustiveness checking. So Solidity doesn't have switch case statements. You just have to do nested. Ifs there's no exhaustivity checking, let's say you're iterating over. Potential magic number error codes. You have to remember to check every single error code. This is just not a secure system.
00:13:43.112 - 00:14:13.840, Speaker A: This is not a secure way to write code. We have better tools than this. So there's this underscore down here, which means any other case. So the way to read this, it says, okay, based on what the variant Y is, we're going to perform different behavior. So we know Y here is variant two. So if Y is a variant two, we're going to take the value Y out of it and return it from the main function, otherwise we're just going to return ten. This is a total dummy function contrived for the sake of this example.
00:14:13.840 - 00:15:03.452, Speaker A: But that's that match syntax and that's how you would get the values out from inside of an enum. This is just how crazy you can go with destructuring and structuring. So to access interior values, you can either just use the dot syntax and access fields, but also you can completely destructure a type if you're familiar with JavaScript. If you've ever destructured an object in JavaScript where you put the object structure on the left hand side and you pull the values out, we won't go too far into that. But essentially what we're trying to say is we have extremely ergonomic syntax pulled from kind of the latest and greatest of the most popular programming languages to access complicated data structures and make them safe. Because at the end of the day, we want it to be safe, but we also want things to be ergonomic. So our type system is strong and static.
00:15:03.452 - 00:15:21.636, Speaker A: Those are two adjectives that would typically be used to describe this type of type system. The technical term is that we use an algorithm called Hindley Milner. It's used in languages like Rust. It's used in Haskell. It has type inference. It's a very intuitive type system. You're probably very familiar with it.
00:15:21.636 - 00:16:15.080, Speaker A: If you use it, you can annotate types, but also you can allow them to be inferenced. It also supports generics, which I hinted about earlier, which allows you to write code parametrically over multiple types. So that's some of the language things that we promised last year that we actually delivered on and delivered on in a big way, we're going to move on from the language itself to kind of the surrounding tooling around the language. So yeah, I still have some time. So part of our vision is not just to have an ergonomic and complete language. We also are trying to build out an entire ecosystem, a full stack where you can deploy safe contracts with auditability, security performance. And we want it to feel like you don't have to pull any strings, you don't have to go through any personal hardships to deploy a contract.
00:16:15.080 - 00:16:44.236, Speaker A: And so to support this vision, we're shipping Sway with a robust set of tooling around it. So we have a lot of other things, but I'm just going to go ahead and go through these really quick. We have a rust SDK and a TypeScript SDK. They're used for orchestrating and deploying contracts programmatically. So if you say have an app and you need to deploy contracts on the fly or interact with contracts, we have an SDK for interacting with the node and the language. And testing. We have fork, which stands for fuel.
00:16:44.236 - 00:17:20.492, Speaker A: Orchestrator. If you're familiar with Rust, it's like Cargo. If you're familiar with JavaScript, it's kind of like NPM, but better. It handles dependency management, plugins formatting, the block explorer, all sorts of things. Building dependency management, which I already said, module resolution, lock files, all those great things. We have a Block Explorer plugin, we have a canonical formatter with configurability, by the way, some other fuel people are up here and the guy who wrote the formatter is here. And Emily wrote all of the match expression and pattern matching, which is really yeah.
00:17:20.492 - 00:18:00.600, Speaker A: And then we have a language server for Vs code or just any language server protocol. We have a Vs code plugin which consumes the language server and we have a lot more than just that. But this is some of the tooling that we're deploying alongside Sway. So if you've ever written in fluidity, first of all, the ecosystem kind of changes every couple of years and you need to figure out what the latest and greatest is. Are you using hard hat? Are you using foundry? Are you testing with this testing framework or this one or whatever? We have a canonical way where everything works together. Everybody building this stuff is all friends, we're all in the same group chats and we're all making sure that we'reusing code when possible to provide the most seamless experience. Another thing we take really seriously is compiler user experience.
00:18:00.600 - 00:18:38.436, Speaker A: So we talked about this last time. Solidity errors are not the best in sense that they don't always lead you to knowing exactly what's wrong. There's different ways. Maybe it doesn't actually point you to the part of the code that's actually broken, or maybe the error message is not fully descriptive, but we take this problem very seriously and obviously this is a pretty trivial error. But what I'd like to show here is that we use the same error renderer that Rust does. So we always try to have descriptive and direct error messages that point directly to the problem. So an example of that, let's go ahead and take a look at a quick code example.
00:18:38.436 - 00:18:58.070, Speaker A: Does anybody see any logic flaws with this piece of code? It is not exhaustive. Yes, that is correct. So x, this is obviously silly. X is five. We all know that. Pretend you don't know that. X could be anything, it could be any integer.
00:18:58.070 - 00:19:40.758, Speaker A: Why are we only checking if it's one or seven? Right? Like if you don't have exhaustivity checking, what you'll do is you'll progress past this match statement and you'll never know. This is something the compiler can check though. And what you'll get is a pretty descriptive error message. So this is one that we're kind of proud of, which calculates all of the ranges that you've missed in your match statement, all the ranges that you've missed in your match statement, and what you need to do to fix them. So obviously we've only checked for one and seven, but we still have the minimum U 64 value, which is zero to zero, two to six, and eight to the maximum value. Shout out to Emily for writing that whole algorithm. She's right here.
00:19:40.758 - 00:20:13.274, Speaker A: Okay. This also works for enums. So for example, if you did an EC recover and you did not check the error case, this is what would happen. So this is what we mean by safety in a practical sense. So now we're going to get to kind of the exciting stuff. I've got five minutes left, so we'll just swing through this. The most exciting thing for me as the person who typed maketer and created the project in the beginning and to see it grow over time is the fact that I'm no longer code reviewing the compiler.
00:20:13.274 - 00:20:40.582, Speaker A: I'm code reviewing applications that are written in Sway. Like the extension is SW instead of Rs, which is it just blows my mind. So this is the part that I'm really excited about. We have been building applications in Sway, some internal to our organization with a lot of our oversight and some completely external. This is our uniswap clone. It's on a DevNet. You can go there and you can get some test ETH.
00:20:40.582 - 00:21:15.734, Speaker A: It'll just drop it into your wallet and then you can mess around with it. You can pay attention to the transaction speed, which is something that the fuel node is very good at. Parallel transactions. Not the topic of this talk, but that's a test full stack application, totally open source. If you ever would like to check out what's going on. There another application obviously that we're building is our standard library which is we're quite proud of it. It has a lot of the tools from Solidity, but in our opinion in a safer and more sensible way, that one is also growing by the day.
00:21:15.734 - 00:21:48.670, Speaker A: We have all sorts of contract primitives and cryptographic primitives that we're still building out. In addition to that, we have an escrow application, we have auctions, we have Dow voting, we have a fundraiser, we have a multi SIG wallet and we have a lot more applications that are still in development. And these are complete projects written in Sway. Some of them have front ends. They're really robust applications and yeah, we'd be really excited if you were able to check them out. So what's next? Some of the things that are on the Sway roadmap are we're going to be working on optimization. Our bytecode size is kind of big right now.
00:21:48.670 - 00:22:17.306, Speaker A: Obviously build the MVP and then optimize. We're going to be building out more applications. We're going to be working on a macro system which is something we promised last year that we have not developed yet. But most excitingly, and maybe like the most exciting piece of alpha from this talk is that we're beginning to work on an EVM backend. So instead of just having to develop for fuel, you'll be able to write Sway for the EVM. We're really excited about that. That's going to be a long project.
00:22:17.306 - 00:23:01.110, Speaker A: Hopefully we can continue the trend of announcing something at one ECC and having it done by the next one, but we'll see. So that's really exciting. Before we get to questions, since I only have two minutes, I just want to announce that we're also starting a grant program. So if you would like to build an application in Sway on Fuel or just in Sway on the EVM in like a year or something, and you would like to be a part receive fund for it, this QR code takes you to a Google form. We're giving out grants anywhere from $10,000 to $150,000 to develop applications. I'll go ahead and leave that QR code up while I use, I guess, my last, like, 30 seconds for if there are any questions. So yes.
00:23:01.180 - 00:23:04.200, Speaker B: Does anyone have any question?
00:23:08.830 - 00:23:10.990, Speaker C: Does sue support generics?
00:23:11.490 - 00:23:13.774, Speaker A: Yeah, it has full support for generics. Yeah.
00:23:13.892 - 00:23:21.860, Speaker C: Okay. I was wondering, you said you have, like, support for IDE integration, right?
00:23:22.550 - 00:23:23.646, Speaker A: We have a language server.
00:23:23.678 - 00:23:32.930, Speaker C: Yeah. How much of this framework is the same as the compiler?
00:23:33.830 - 00:23:44.138, Speaker A: We reuse a lot of the code, so the language server imports a whole lot of code from the compiler. And we do that on purpose, right? To make sure it's consistent. Yeah.
00:23:44.224 - 00:23:44.860, Speaker C: Okay.
00:23:49.710 - 00:23:50.860, Speaker A: Hot up here.
00:23:52.030 - 00:24:14.562, Speaker B: Thank you. Thanks, Alex, for the presentation. I have a question about error handling mechanism here. You mentioned about Reynolds, and we can use this way we can have them exceptions throughout. So can we define the different type of the exceptions and we can catch them?
00:24:14.696 - 00:24:52.110, Speaker A: Yeah. So there's no exceptions in the sense that you just throw things in a bork control flow, but there are error types that you can define yourself using enums. You declare the errors. I can show you a couple of examples of that both in Rust and Sway. But if you want to just crash the whole program and revert, because sometimes in a smart contract, you just want to revert, there's also a standard library function which just aborts control flow. This is an old code example, but we essentially have a function called revert which just immediately stops the transaction and reverts. And at that point you can pass out an error code which could be an enum, and our SDK will decode that and tell you the specific error message.
00:24:52.260 - 00:25:09.140, Speaker B: Okay. Another quick question is about your enum. Okay. In your previous code, in our example, and we have the three different variables, and then should be the size of this enum. It should be the largest size. So is that added up together or is it just two?
00:25:10.810 - 00:25:17.714, Speaker A: You add these three together and that's the total domain, the total cardinality of this enum.
00:25:17.842 - 00:25:19.400, Speaker B: Okay, thanks.
00:25:25.870 - 00:25:27.414, Speaker A: Okay, last one.
00:25:27.552 - 00:25:47.762, Speaker C: Yes. Your language is obviously inspired by Rust, but you do have some specific keywords that are related to blockchain. Do you ever think about not having them as explicit keywords, explicit syntax, or maybe something that looks more like I know derives, for example, for content?
00:25:47.816 - 00:26:13.580, Speaker A: Yeah. So kind of like writing for Solana or something, where it's like Rust primarily with attributes and things like that. Because our whole thing is to have the most integrated and kind of bespoke experience possible. We want it to feel really like the tool should be built for the job. Right. And we could jump through some hoops to make it such that you could use vanilla Rust with some annotations and stuff like that. But the reality is it wouldn't be as clean of a user experience.
00:26:13.580 - 00:26:53.060, Speaker A: Things like declaring contract storage in the top of a contract, which is somewhere in here. Yeah. Things like this. Yes, it's a concession for blockchain development, but that's because we want to be building the best possible language for smart contract development. There are plenty of other general purpose languages, and that's not really a fight that we're here to fight. We want to build the best possible thing for smart contracts, and because of that yeah, we're going to have that's. I think one of the best things about Solidity is that it was built for making smart contracts, and that's why it's so popular, because you're going to use the tool that was designed for the job.
00:26:53.060 - 00:27:05.510, Speaker A: So if we were to try to completely step away from that and make, like, a complete Rust clone, it wouldn't be a tool for the job. Does that make sense? Yeah. Okay, that was the last question. Thank you all for coming and listening.
