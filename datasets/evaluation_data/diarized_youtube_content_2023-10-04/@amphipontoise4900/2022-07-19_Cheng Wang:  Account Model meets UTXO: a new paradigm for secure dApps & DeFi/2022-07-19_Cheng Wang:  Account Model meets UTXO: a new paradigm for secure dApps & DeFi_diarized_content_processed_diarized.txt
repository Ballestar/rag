00:00:06.990 - 00:00:07.700, Speaker A: Thank you.
00:00:09.270 - 00:00:33.660, Speaker B: Okay, great. Hello everyone. Sorry for the delay. Today I'm going to talk something about security from a different angle. Normally you don't see probably such topics. It's going to be a bit technical, but please feel free to ask late for questions. Topic is about the count model of meets UTXO model.
00:00:33.660 - 00:01:14.310, Speaker B: As engineer, we're probably very familiar with these two models in the blockchain world. But today I'm going to do how to leverage both for better security. First, a bit about myself. I'm the founder and core developer of RFU. RFU is a new Sharded blockchain combining account model and UTX model. The Sharding is operational in production mending launched since last year and it's working really well in production. And my background is in 2015.
00:01:14.310 - 00:02:11.862, Speaker B: I proposed the first linen time I think presenting consensus algorithm and I research about number three and the consensus algorithm in the universities. So my background seems to be very relevant to Blockchain. Now let's get back to the topic security. Security is one of the most interesting topic right now for all of the applications on blockchain, especially for DeFi, we have seen almost like big hikes almost every month. It has been like people have trying to kind of solve this problem for a long time. But still right now solidity auditing is time consuming and expensive. Even though that's we kind of recommend every project to do auditing.
00:02:11.862 - 00:02:53.650, Speaker B: But you see on the list right on the right, like a lot of projects, is not audited the efforts people have tried to improve the situation. There are a lot of such kind of efforts. The first very natural movement is to improve the tool chain and to recommend best practice for all the D apps. But this comes with some cost. The first thing is the learning curve is really getting much, much deeper. Especially right now. A lot of project, they use assembly language to optimize the gas fee.
00:02:53.650 - 00:03:40.230, Speaker B: It's getting chicken chicken. And it's very hard to scale the development of the apps because you need to learn a lot to write a secure D app. There are some approaches, more solo approaches to improve the situation like introducing new transaction model, new virtual machine, new contract languages. I'm sure that you have seen a lot of these trials in the past. This approach sounds like more kind of try to solve the root cause of the issue. But it comes with a cost as well. Like bootstrapping is hard, you need to educate people about the new infrastructure, new stack.
00:03:40.230 - 00:04:52.970, Speaker B: But for long run it's great because if you see the evolution of programming language, we start with assembly, we start with C, but after 30 years probably we have Rust and it took many years to make Rust mature enough for production. I think it's going to be the same for Blockchain. We're going to see bets transaction model bet VM and bet languages. Especially I want to mention in this huge category there's one thing I really think is very promising is to leverage the UTXO model for security reasons. First bits recall of account model and the UTXO model. Account model is basically if you see the blockchain as a huge state machine, the transactions actually have direct access to the state. The transaction can modify the state of the for example, the Oracle modify the state of uniswap contract to store the information of the price of the pair.
00:04:52.970 - 00:06:03.460, Speaker B: And you take some of these completely different model, you can see somehow like the pure function in programming language, each transaction is a function that consumes input and generates output. And there's no side effect, which means usually baits security. In this case sad effects is usually very hard to deal with. So like this is not perfect model in the world. Here is a short list of the comparison of boss models. So account model is the biggest advantages as we have seen from the EVM ecosystem is that it's very friendly for developers because it's very close to how we write code. In general it's expressive and flexible, you can build very powerful applications on top of it, it has a small transaction size.
00:06:03.460 - 00:06:58.954, Speaker B: But the problem is the state is very mutable. Mutability is a big issue, a very challenging issue in general for programming, especially for crypto. Even if one of the operation that's muted states is not really tested or is not really taken care of, it can be really a problem. By default the security is lower and another issue is account model is hard to execute in parallel. But on the other hand, UTXO has some advantages. The UTXO like bitcoin all of the output, they are owned directly by the users. It's more kind of decentralized if you compare to account models basically your token is controlled by the contract.
00:06:58.954 - 00:07:56.440, Speaker B: For example the ERC 20 token, all of the states are in the contract. So Udexo by default have this security advantage. And another thing is the model is very kind of explicit about the input and output of the transaction. This enables a lot of room for verification. For example, you can check directly the input and output balance of the UTXO transaction without executing it and you can double check it, you can check it in execution, you can check it just for the transaction and it enables beta parallelism and scalability. This is because it's immutable but this talk is about security so I'm not going to deaf in that topic. But UTXO has some other issues.
00:07:56.440 - 00:08:38.958, Speaker B: The most well known one is the concurrency issue of UTXO model. Probably you guys have heard about it a lot about this issue, about UTXO model. Another issue is like you need to learn new programming model. It's a bit like if you program it with C or even rust and now you kind of need to learn haskell a little bit so that's a huge paradigm shift. It's a bit tricky. So simply speaking, account model is very convenient for computation. It's very close to the model we use every day.
00:08:38.958 - 00:09:18.194, Speaker B: And the UTX model is good for securing digital assets. As we have seen on Bitcoin, there's no on chain attack on this model. So RFU, as a new blockchain, we try to combine the strengths of both models. Try to improve the by default security of the blockchain. How do we do it? Actually, the idea is simple is we basically decompose the account model into two parts. The first part is asset. The second part is contract states.
00:09:18.194 - 00:10:01.722, Speaker B: Right? Now, for example, if you see the ERC 20 token implementation like both the assets and the contract states, they are based on the storage of the EVM. We went a step further. We tried to use UTXO model to model the assets or the token in the blockchain. So Token is face class citizen in our protocol. You don't need to introduce any extra standards for it. And it's UTXO based. It means users have full control of all of the outputs.
00:10:01.722 - 00:11:02.494, Speaker B: Even though if the contract is exploited, you still own the token because it's locked by your wallet. Because we combine both together, we don't have the concurrency issues that happen to other UTEX and model blockchain and also still deaf friendly. We spend a lot of effort to focus on the dev experience on our blockchain. Now let's dive a bit more deeper into the execution of the virtual machine. This is usually the most tricky part we built for. In order to execute this new transaction model, we built a brand new virtual machine with a lot of security considerations. First, why a new virtual machine not EVM? I think there are two important reasons.
00:11:02.494 - 00:12:02.754, Speaker B: The first thing is we are really a new model. It's a bit hard to just modify EVM and use it for all the apps. The second reason is we totally believe that a new virtual machine can provide much more security benefits. Our virtual machine is a stack based virtual machine like JFM and WASM for safety, reliability and performance because it's based on UTX model. So execution follows the input output paradigm. This greatly mitigate the risk of unseen external costs. Why it is like this? If you are a little bit familiar with the attacks on DeFi, usually you see like attacks they kind of use the composability crazy, right? They wrap a lot of operations contractor calls in one single transaction.
00:12:02.754 - 00:12:46.340, Speaker B: But usually for normal users you never see this. Normal users is always like do some simple operations. So here actually the transaction model or execution model gives a lot of advantages for the attackers. But with this input and output paradigm is basically the room. The advantage for attacks is much lesser and basically we try to make the attacks and normal users, they are kind of stand at the same line. And because of input output paradigm, fresh long is not available by design. This is a very controversial design.
00:12:46.340 - 00:13:17.680, Speaker B: Fresh loan is not totally biased. It has some good use cases as well. But at the same time it's used for almost all the attacks on chain attacks. So in our case it's not available. This is going to mitigate a lot of the attacks. Probably this could encourage a lot of more like white hikers instead of people use flash loan just to attack the protocol. And we introduced a built in asset permission system for contract cost.
00:13:17.680 - 00:14:19.070, Speaker B: So I guess you're all familiar with, ERC, 20 token, that you can kind of approve tokens, but it's not really user friendly because you need to kind of have one transaction do that in advance and usually for the sake of user experience, you just approve unlimited amount of token for the applications and that is kind of very dangerous in some cases. But in our case we have a built in assets permission system for it. It's more fine grind. We also have a lot of typical improvements like type checking, overflow, underflow checking stuff. So by default you have all of these security guarantees. You don't need to kind of import libraries for it. It's going to kind of make the dev experience much nicer.
00:14:19.070 - 00:15:35.370, Speaker B: Lastly, it's very important thing is we don't have low level support for Map data structure with subcontracts. Instead, these are some very technical details I'm not going to dab deep into, but I want to mention here is here because Map data structure is usually used to store a lot of personalized data. For example, for the ERC 20 token you have the balance of all of the holders or the owners of the token. If the contract can be compromised, it might have direct access to the balances, right? They can modify, they can steal the coins in some cases, but in our case it's not possible by default. So that's the overview of the design. We have a lot of security considerations and next great topic I want to talk about is minor extractable value on our protocol. This has been like very hot topic in the past year or since the DeFi boom.
00:15:35.370 - 00:16:31.222, Speaker B: There's no ideal solution for it, but it's very different on autofield. This mev search space is very different from EVM. So first the transaction model is based on input and output, so the execution is more fine ground. As I explained earlier, this means the sandwich attack on chain Oracle manipulation is not possible in a single transaction. As you know, as long as you have enough gas, you can do almost everything on EBM. This is how typically attacks try to attack a protocol. And because of this finger and transaction execution model, the arbitrary usually requires multiple transactions.
00:16:31.222 - 00:17:08.200, Speaker B: It means in the past you do it in one transaction to attack the protocol. But here you need to do multiple transactions and this means you might compete with others. For example, if you need two transactions to finish your attack, you prepare the first one and submit the first one. And then for the second one, the other attacks or me researchers, they might see it, they would like to compete with you. So this makes the attacks a bit more risky and it's good. The third thing is Flash loan is not available. So MBB is going to be tricky here.
00:17:08.200 - 00:17:57.670, Speaker B: Basically kind of make the status kind of don't have enough advantage over the normal users. And we also introduce random execution into the virtual machine. So it means the people submit the transactions based on the gas fee. If your gas fee is higher, your transaction will be including the block with high priority. But there's no guarantee that your transaction will be executed before others. The auction is based on gas fee, but the execution is not random. Of course the manners, they have the power to manipulate it, but for normal people attacks, it's going to be tricky.
00:17:57.670 - 00:18:47.990, Speaker B: Yeah, we don't solve it. As we all know, MBB is a tricky question. You cannot really solve it on chain as far as I know, unless you try to put a lot of very heavy primitives into the protocol. Yeah, so far we have been talking about very low label details. Now let's go to a bit high level and to see how developers can leverage this new protocol or new platform to write secure contracts by default. We propose a new domain DSL language for this purpose. Why we introduce a new language? Because first, as I mentioned that the model and the virtual machine is different.
00:18:47.990 - 00:19:31.430, Speaker B: It's hard to use the existing ones. And we also want to make the language, make sure the language to be as simple as possible and people don't need to learn a lot of things or actually for the apps, a lot of features of a language is not really useful. Yeah, the language try to have low level VM details and try to enforce good practice by default. Yeah, this is just trivial stuff. And also we have the built in syntax for Assets permission. This is very unique to us. So on the right side of the slides we have a simple smart contractor for Dex.
00:19:31.430 - 00:20:23.666, Speaker B: It's very simple but it has something very unique. Here you can see the annotation and this part is our ISO permission system. So here it is. How do we kind of integrate the ISO permission system into the language? On the first cell of the table you can use annotations to specify if your function will use Assets or not, what kind of assets you are going to use. And on the second cell is about is a user that tries to invoke the function with Predefined, with Assets, with tokens. So the virtual machine will check if it's allowed or not. If it's not, then it will just exit.
00:20:23.666 - 00:21:44.240, Speaker B: We also have some functions for this. So in the last sale I want to mention is that because of this permission system the reentrancy is not possible for it's not possible by default. If you want to reent the same contract in the same transaction, it's not allowed by default. So here is a very well known security issues or list for solidity by Security Boulevard. It's a bit outdated but it's the best I can find so first re engines here say that this is solved by our asset permission system the input out of paradigm it's solved very nicely with other new features the second one unchecked external core this will terminate on exception. The rest is basically solved directly with the virtual machine given the time limits, I'm not going to dive into the details but you can take picture if you want. So here's the summary of the security we propose a new paradigm that combines icon model and the UTEX model.
00:21:44.240 - 00:22:44.500, Speaker B: The new paradigm creates a lot of more room for verification for defense and by default security is much higher and especially by default the default astro security is much higher because every token is in utexo and we have some improvements on the account model as well. On a side note, I want to mention that our virtual machine is really very efficient, lightweight. Here's an example of a warm hole bridge contract. Our virtual machine is like one kilobytes, and on EVM is 10, sonar is one megabytes. And this is great for virtual machine execution. And it also use a lot of less computation the less I o. So even if we just use this new virtual machine it's going to improve the scalability by a lot.
00:22:44.500 - 00:24:10.522, Speaker B: Yeah, so that's basically the main part of the talk about security and last I want to talk a little bit about our project we started in 2017 we want to build a new shadow blockchain based on a new algorithm called Brockfrow. It was founded before the DeFi bomb. We did not expect this model to be really a great model for better security on chain but after several years research we found that actually our new model and new virtual machine actually improves a lot of things scalability, security, decentralization, et cetera. Yeah, we are right now focused on improving the protocol so if you are interested in the work and especially if you are developers, please feel free to check out our GitHub, try to look at the codes and try to read some of the articles on our blog. I'm pretty sure that if you are engineering you're going to be very interested in it. Thank you. Thank you Cheng for this great presentation.
00:24:10.522 - 00:24:13.200, Speaker B: We have time for one or two questions.
00:24:19.250 - 00:24:37.750, Speaker A: I have a question like in the classic UTXO model you have an issue where on each transaction you have to put all your assets in the transaction so as you have more assets, your transaction uses more and more energy. Does this paradigm solve it or do you have here?
00:24:37.820 - 00:24:38.710, Speaker B: The glass?
00:24:39.050 - 00:24:45.420, Speaker A: If you have, I don't know, like 1000 NFTs, do you need to put them in all the inputs every time?
00:24:46.030 - 00:25:12.746, Speaker B: Yeah. So here we have some constraints on the number of inputs. So it's a design that you try to be it's a trade off here if you want to support a lot of inputs in one transaction or if you don't want to support it. We want to be more conservative on this. So we have a limit on the number of inputs. I think it's around 128. But you can do things in parallel.
00:25:12.746 - 00:25:28.738, Speaker B: In UTXO model, if you want to distribute, like, more than ten k UTXO, you just prepare the transaction in parallel and submit to the network in parallel. So the latency is not an issue and you still get the high throughput. Okay, that's it.
00:25:28.824 - 00:25:29.700, Speaker A: Thank you.
00:25:37.410 - 00:25:41.300, Speaker B: Thanks. So I think we're done. Thanks again, Chang.
