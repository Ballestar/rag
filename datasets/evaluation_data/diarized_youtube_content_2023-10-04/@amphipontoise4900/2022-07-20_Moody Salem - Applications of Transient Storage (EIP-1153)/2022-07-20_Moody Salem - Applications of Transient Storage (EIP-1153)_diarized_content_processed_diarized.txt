00:00:17.790 - 00:00:30.290, Speaker A: Everyone, thanks for coming to my late evening talk on applications of transient storage. My name is moody. I'm an advisor at Uniswap labs.
00:00:30.290 - 00:00:42.090, Speaker A: Just quick intro, worked at Uniswap for two years, developed Uniswap V three, and now I'm an advisor here, always up for Smash Bros. So come find me or table tennis.
00:00:43.230 - 00:00:44.554, Speaker B: And so my goal of this talk.
00:00:44.592 - 00:01:00.766, Speaker C: Is just to convince everyone that transient storage is more than just a gas optimization. So transient storage is sort of a different way of using storage. And so let's get into that with a background, what it is and how it's used today.
00:01:00.766 - 00:01:27.850, Speaker C: And then we're going to go through a little story of building a marketplace protocol just to get an idea of how this helps you improve the protocols you're building. First things first is you probably already do use transient storage. And really it's just when you're using a storage slot by writing a non zero value and then writing it back to zero before the end of the transaction.
00:01:27.850 - 00:01:41.262, Speaker C: So the most common use case is reentrancy locks. And oftentimes you'll see a modifier lock which does locked equals true, underscore locked equals false. That's the most common use case.
00:01:41.262 - 00:01:45.994, Speaker C: And most people already use it. We use it as well for constructing.
00:01:46.042 - 00:01:50.366, Speaker B: Units, swap pools, use it for out.
00:01:50.388 - 00:02:12.070, Speaker C: Blocks like L Two, roll ups like Arbitrage. And so there's a lot of use cases in the ecosystem today. And the reason it has a special classification is because when you do this zero to non zero to zero rate, you actually get a refund from the EVM, a gas refund.
00:02:12.070 - 00:02:29.186, Speaker C: So let's get into the usages. The first one I talk about, reentrancy locks look like this. What they do is prevent reentrancy, which causes a huge fraction of all smart contract vulnerabilities.
00:02:29.186 - 00:02:37.674, Speaker C: So you've probably already seen this. So this prevents reentrance. Another usage which we use is a little more esoteric.
00:02:37.674 - 00:02:55.170, Speaker C: Most people don't use it. We use it to basically make a code hash of a Uniswap pool a constant, which makes it cheaper to compute the address of a pool on chain, significantly cheaper. And so the deployer will set some parameters for the constructor arguments.
00:02:55.170 - 00:03:07.850, Speaker C: We'll deploy the pool and then we'll delete those parameters from storage. And so that's an example of a transient storage use. Here's another usage not at Uniswap, it's the Arbitram outbox.
00:03:07.850 - 00:04:01.610, Speaker C: So what they'll do is when they're executing a transaction sent from L Two to L one, they'll put the context of the L two transaction in storage, make the L two to l one call, and then they'll delete this from storage. And so this surfaces the L two context to the L one transaction without making any assumptions on the interface of the contract that's being called. So transient storage is already in the EVM, so why do we need an EIP? What's the difference? So there's some issues with the current approach, and the biggest one the most recent one is that refunds are now capped as of the London hard fork to 20% of all the gas used in a transaction.
00:04:01.610 - 00:04:19.946, Speaker C: So if you go over that cap for a refund, you basically pay 20K gas for something that's not ever writing to storage. And it's really just 32 bytes of memory. So that's way more expensive than actual Mstore and M load.
00:04:19.946 - 00:04:32.670, Speaker C: And the context for that is gas token, getting rid of gas token and block sizability. So there are good reasons for doing that. Also, storage refunds are not given on revert.
00:04:32.670 - 00:04:54.090, Speaker C: So if you write a slot and then you write it back to zero and then you revert, you don't even get the refund. So there's a lot of gas wasted there which never writes to disk. And a really important distinction is that with regular storage, you can't avoid reading the original zero value from disk.
00:04:54.090 - 00:05:27.234, Speaker C: So even though in your contract, you know that locked is always false when someone enters your contract, and always false when they successfully exit or revert, the node still has to read from the tree to get the value zero. So it's a wasted S load and wasted reads always. And probably the most important one is that and underemphasized the storage refund logic is really complicated.
00:05:27.234 - 00:05:57.632, Speaker C: And I was actually working on a slide to describe exactly how much gas in a store would cost, and I had to go through like four different EIPS which refer to each other, and I couldn't even figure it out, so I ended up discarding that slide. But yeah, it's really hard for a developer, if you show them a piece of code to understand how much gas a particular piece of code will cost if it touches storage. So that's where Eiplm 53 comes in.
00:05:57.632 - 00:06:03.436, Speaker C: It brings two new opcodes. One of them is T load. The other is TStore.
00:06:03.436 - 00:06:22.760, Speaker C: They behave exactly the same as S Load and S Store, except they only persist within a single transaction. And so because of that, they never have to read from disk, and they never have to write to disk, which are the most expensive operations for a node. And so they can be priced much cheaper.
00:06:22.760 - 00:06:43.520, Speaker C: But they do have to be a little bit more expensive than memory because they still have to revert, just like S Store and S Load deal with reverts. Yeah. So here's a visualization from the Ethereum Magicians thread by Pascal.
00:06:43.520 - 00:07:10.792, Speaker C: And the important thing to gather from this is that transient storage is a lot more like machine state than persistent storage. And, yeah, another way to think of it is it's like a transaction persistent memory region for contracts. And so going back to those previous use cases, they're all just way cheaper now.
00:07:10.792 - 00:07:39.916, Speaker C: You don't have to read the original value from storage, and you don't have to deal with refunds, so you don't have to worry about how much gas the transaction is spending, whether you're going to get the full refund, which you often wouldn't in the case of uniswap v. Two. So we actually did a little trick here where instead of doing rights and that's because the refund for doing that is a little bit smaller.
00:07:39.916 - 00:08:06.660, Speaker C: But the drawback is now you're just wasting 32 bytes on every pool for no reason, and plus you're wasting all those reads. So, yeah, that's sort of the background. But I want to make the argument that it doesn't just improve these existing use cases because it's so much cheaper and so much more accessible.
00:08:06.660 - 00:08:18.540, Speaker C: You can create smart contracts with new patterns. And we're going to go through that with this next story. So let's say we're designing a marketplace contract.
00:08:18.540 - 00:08:36.150, Speaker C: Customers can buy items for fixed prices, customers can sell items for fixed prices. And you can imagine it's something like seaport, but maybe just like fixed prices on every NFT. So version one might look something like this.
00:08:36.150 - 00:08:48.792, Speaker C: You have a function on the contract called Buy, a function on the contract called Sell. And when you call Buy, you receive the item you have to send the payment for item one. When you call Buy, you have to do the same thing again.
00:08:48.792 - 00:09:00.076, Speaker C: And when you call Sell, you transfer the item and receive payment. And so this is a little naive because you're doing extra calls, extra transfers. It's just more expensive than it needs to be.
00:09:00.076 - 00:09:30.516, Speaker C: So you might want to do something like batching all your buys and then batching all your sells. And so you might refactor and make it look like this, where you allow the user to specify multiple items they want to buy and then they have to send the net payment and then multiple items they want to sell and receive net payment. But let's say the user wants to buy item one and two and then sell item three to partly pay for it.
00:09:30.516 - 00:09:50.424, Speaker C: This doesn't work very well for that because they have to put up front all the money for Buy or call sell before buy. So it imposes some restrictions. So what you do is you design this new method, execute orders, which takes some list of arbitrary operations with their own arguments.
00:09:50.424 - 00:10:05.760, Speaker C: Buy one, buy two, sell three, sell four. And so within this method, you only have to deal with the net amount that you have to pay or that you're being paid. And so this works.
00:10:05.760 - 00:10:40.232, Speaker C: But what if pricing is dynamic? Or like, what if the user has to respond to the price they get when they buy two, or they want to sell three and then only sell four if the result of some contract call is true? Or like, if they don't have enough to buy one and two by only selling three, the user will want to impose their own logic in between these contract calls. And so that makes this a little bit difficult to work with. And there are ways you can solve this by adding different kind of operations.
00:10:40.232 - 00:11:17.876, Speaker C: Let's say in between your buy and sell you have another call to another contract to do some additional logic or conditional sells. But you're getting into more and more complex designs which are very hard to work with and you're going to have to deal with encoding this very complex order on chain and off chain. So when we think about these types of orders is they're sort of like opcodes with arguments and you're designing a virtual machine which is your protocol with these biopcodes sell, opcodes, conditional cell, et cetera.
00:11:17.876 - 00:11:44.140, Speaker C: And it's really hard to design the perfect VM, which is the whole reason we have EIPS. So yeah, instead of trying to design the perfect execute order function, there's this alternate design where you enforce contract level invariance. So you can call into this lock function, the customer will get a callback and you can do the buys and sells.
00:11:44.140 - 00:12:01.136, Speaker C: You can do anything you want within the context of the EVM. You can call arbitrary contracts and then at the end all you have to do is pay the differences and transfer the items that you owe the contract. And the way the contract remembers in between these different calls, how much you owe.
00:12:01.136 - 00:12:21.336, Speaker C: It is the buys and sells and then it checks the invariance in transient storage at the end. So this allows the user the full freedom of the EVM to do any actions they want within the context of the lock as long as they meet the invariance of the marketplace. So here's an easy way to think about talking about it.
00:12:21.336 - 00:12:26.300, Speaker C: You can call it the till pattern. It acts sort of as a cash register. So it's like a till.
00:12:26.300 - 00:12:40.768, Speaker C: You check the total value in the till and you can also think of it, you can remember it because you're deferring all the validation till the end. So it's kind of like until the user is done interacting with your contracts. And yeah, here's the current state of it.
00:12:40.768 - 00:12:51.936, Speaker C: It's being implemented by Uniswap Labs mostly, but they're working with contractors. Mark Tynewite kicked it off with he's from Optimism at East Denver at a hackathon. He started the ethereum.
00:12:51.936 - 00:13:00.472, Speaker C: JSVM Get this completed fork another line of progress. So we're making a lot of progress towards it. Hari, call out to Hari today.
00:13:00.472 - 00:13:19.630, Speaker C: He just implemented the assembly opcodes in Solidity and you can test against it today if you just use a particular hard hat package version. So yeah, please add your use cases to the thread and here's some additional links. Any questions?
00:13:22.820 - 00:13:29.760, Speaker B: If there's any question, don't hesitate to ask. Question.
00:13:41.650 - 00:14:07.350, Speaker C: Is there any current estimated timeline? Yeah, so it's definitely not going with the merge, obviously. Shanghai, I think probably will be maybe early mid next year. I don't know if anyone really knows, but we're trying to get it to be CFI for Shanghai but there's a little bit of pushback just because of priorities.
00:14:07.350 - 00:14:28.900, Speaker C: So mid next year. cheapers and storage and more expensive than memory. Do you have any number on the gas cost of these opcodes? Yeah, so right now, it's priced at 100 gas, and both of them are 100 gas each.
00:14:28.900 - 00:14:50.490, Speaker C: And we did some testing with infuria to make sure that it didn't pose a threat to Dossing. Any of the clients caveat? It remix, so I don't know. It may be a little too cheap right now, but we haven't gotten to final numbers.
00:14:54.400 - 00:14:59.510, Speaker B: Any more questions? It.
00:15:02.840 - 00:15:03.830, Speaker C: Thank you.
