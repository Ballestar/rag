00:00:05.610 - 00:00:37.370, Speaker A: So, hi everybody. Sorry. Don't worry. Okay, we go. Okay. So, hi everybody. My name is Pat.
00:00:37.370 - 00:01:21.080, Speaker A: I am the co founder of the trust. So, hi everybody. My name is Pascal. I am the co founder of the Et Trust Company. I am also a researcher in Gonical called Telecom Paris in sacle. Close to Paris. And the subject of this talk is a crypto terminal for trusted Ethereum transaction.
00:01:21.080 - 00:02:57.050, Speaker A: So, two words about the Ether trust. Ether was a supposed medium for light transportation and it was proven by the beginning of the 20th century that this medium didn't exist. And so this was a starting point for the theory of relativity and that's from that scam the word the name of the company Ethertrust, which means trust for digital. So, Ethertrust's vision is to improve privacy and security of the internet, including blockchain and internet of things by enabling through standards companion software, gritters and more creative use of secure element supporting crypto processors. You all have secure element in your pocket, you have secure element in your bank card, you have secure element in your SIM card, you have secure element in the electronic passport. So basically, Etrus design software secure by secure elements about trust for Ethereum, we believe that key storage and signature trust are key features for the development of Ethereum services. Basically, in Ethereum you have what is called a private key.
00:02:57.050 - 00:04:16.690, Speaker A: This private key is a 32 byte random value so easy to generate. From this value you generate a public key and from that you generate your address, your Ethereum address. So each time you want to exchange crypto money or to push some data to smart contracts, you need to build a transaction. And this transaction is signed by your private key. And it means that this is really a pillar for the development of secure service over Ethereum. Therefore, we design and publish these technologies and algorithms in order to get integrity insurance for software and hardware involved in transaction signatures process. And so basically, the idea of the crypto terminals is to design some things similar to payment terminals used in a banking system.
00:04:16.690 - 00:04:57.730, Speaker A: Every day when you do a payment you use a bank smart card. But in this smart card you have a key which are not exactly the key used by Ethereum, but you have key. And the difference is that this key are the property of the bank. You have a Pin code and you use a dual form factor for authentication but you don't know the key. And this is a real main difference with blockchain and Ethereum is that in Ethereum you are the owner of the key. So this key is under your control. That's the first point.
00:04:57.730 - 00:06:15.252, Speaker A: The second point is that you cannot use your bank card directly from a PC or your mobile phone. You have to use what is called a payment terminals. And these payment terminals is not the property of the merchant. It is in fact the property of the banks and so the security of this device, these devices are designed according to Fintech standard and so the situation again is very different in Ethereum because we have no standards to do that. So the idea we have is to first of all a crypto terminal is not a wallet, it is something that is used by wallets. So basically a crypto terminal is a cold device which is connected to OD device like PC or mobile and in this device you have the connected part which is the wallet. So we use removable smart cards which are used for secure key storage and trusted signatures computing and we design the crypto terminal.
00:06:15.252 - 00:07:31.600, Speaker A: The crypto terminal is dedicated to smart cards management. You see it's a touchscreen, there is a keyboard and a display. Basically from a security point of view it's firewalls between a smart card which is called device and connected device such as PC or mobile that are the device with a TCP stack and internet connectivity. And last function is to provide communication. So we support two mode of communication first is a serial USB for PC and also for Android which are supporting OTG which means USB for embedded device. And finally, contrary to what we was thinking at the beginning from the security point of view we had the support of Bluetooth because iPhone is not supporting OTG. So it means you need Bluetooth in order to communicate with iPhone.
00:07:31.600 - 00:09:10.064, Speaker A: And so now for the development we choose to support open software architectures. Everybody means what is open software? It means you have the code source for everything but also we have in mind that behind the classical call you have all the calls dealing with the input output for the keyboard, for the smart card readers and so on. And so we decide also to base the development on open hardware and for that we choose Arduino platform which is quite common because you have a lot of library and many ways to get open source software and a community working around that. You have many form factors for the crypto terminal I say this is the one basic one just for development to check. So you have basically this board with the mine processor which is at emiga 25 60 you are there the USB chip which is chia 340. Then you have this plug which is used for serial programming SPI port and this is quite important for us because part of our security model is based on bar metal architectures. Then you have this smart card socket and basically you see it's five wires that's as connected to the device in which you plug your smart card.
00:09:10.064 - 00:09:56.488, Speaker A: There is a touchscreen 320 multiply by 484 pixel square for the resolution you have this Bluetooth low energy module with HCC 25 41. We choose this one because it's possibly to totally flash its content and from the security PT point of it's very important when you are using Bluetooth to know that you are using the right software for Bluetooth. And then this is the smart cards we use. More precisely, we use a Java card. Java card is something standard. It means you flash it in a software written in Java and so it means you have the choice of the manufacturers. And at last, but not at least is the Usbsp programmer which is a device, it's a flashing device.
00:09:56.488 - 00:10:49.180, Speaker A: It is open both for hardware and software. And so it's mean you are able also to flash software in it. And there you see this device which is let's say some things for development or test but it's not really some things very practical. But you see that we plug the screen on the board, we plug the smart card socket on the board and then we have with some Y, you have the Bluetooth low energy module but obviously it was the design also board for use and practical use. So this is our board. You see is there the mine processor, you see the SPI port which is used for flashing the mine processors. You see there the connectors for the touch frames and the smart card socket.
00:10:49.180 - 00:11:36.540, Speaker A: And inserted in the smart card socket a Java card. And on the bottom side you see the Bluetooth low energy momo module. Then we use a 3D printing to design a case and a cover. You put the board in the case, you put the IPS touch rim in the COVID and you use some glue to fix the sinks. And you have some things that works which is you see a 15 millimeter height and about credit card form factor. And so this is the structure of the software. So we use Bar metal architectures.
00:11:36.540 - 00:12:17.608, Speaker A: That means that for security reason we want to flash everything. So it's possible through the SPI port and the SPI programmer to flash the software for the mine processors. From that we reflash the software for the Bluetooth low energy processor and you see there the security mount. So on the security month you don't have the control of the Java cardos which is owned by the manufacturer of the component. But obviously you can flash your cryptocurrency firmware. So you have the chops of the manufacturers and there you see the SP programmer. In this programmer we have a permanent software which is the bootloader.
00:12:17.608 - 00:13:12.248, Speaker A: And from this bootloader which is Samsung Gopano, obviously we download the firmware and what we call the software probe which is used to prove the authenticity of the bootloader. I will give a detail later. So you see in and there you see the crypto terminal I previously described which is there. Okay, now this we are inside the software, there is a set of library. First you have this library which is used for the management of the Java card. You have some elliptic curve library required for example by specific stuff used by Ethereum like recovery. And you have this Ethereum lib which is used to build the Ethereum transaction.
00:13:12.248 - 00:14:16.012, Speaker A: You have the library obviously for the touch frame which is over there. And we have this loader library which is used to push software in the Bluetooth low energy module and more processing inside the software. We have two modes to deal with the crypto terminal. One is based on the key and so you have menu management and it means you can perform operation in a cold mode, generating key, setting key and so on. And you have also command parser, you have also a way to receive command over the communication interface. And you have this central entity which is a common parser and which is the central firewall of that. Let's say when you receive command in this software, we implement the way and the interface, the way to process the command that interact with the smart card and also the way to interact with the user for Acknowledgment.
00:14:16.012 - 00:15:14.550, Speaker A: So this is a central part of the security model from the security point of view there you see this SPI, the programmer firmware that can be flashed through USB and PC interface. And also you see the way to flash the Bluetooth low energy module. We have two kind of command over the serial communication. It's command ASCII encoded for let's say to be usable by a human user. So it's simple line command so you can deal with the Pin entering. So if you have a command to enter Pin in user mode or administration mode, you will have a lot of commands in order to compute key, set key and so on. You have this command for example, that give you the ethereum address of a particular key.
00:15:14.550 - 00:16:08.164, Speaker A: You can sign transaction in line that's been connected to a device or offline that's been not connected to a device. In that case, it means that the crypto terminal works like flash memory if you want. It's a kind of secure flash memory that transport things to sign. You can also this kind of command are used to generate Ethereum transaction. So you can duplicate smart cards, give more detail emulator, you can check the integrity of the Cpmware. This is very important security features. You can check the smart card integrity and authenticity and you can get kind of ID for this card.
00:16:08.164 - 00:17:11.892, Speaker A: And you have also a lot of ISO 70 816 command which has the interface with the Java card. You can verify Pin for user administrators and also you can generate keys and perform signatures. And you see there that you can put a certificate in the Java card and so you can read this certificate. And so if you go on the Play store from Google, you can download an application, a free application which has been designed in order to interact with the crypto terminal. And what do this application, it sign every files store on Android mobile and it push these signatures over the Ethereum blockchain. So there you see the activation of the bluetooth. You can only activate obviously for security rather than bluetooth from the crypto terminals.
00:17:11.892 - 00:18:34.176, Speaker A: Then you see that when you send this through the serial links over bluetooth, when you send the user command, this trig pin entering from the user on the crypto terminal. And there you see the commands that push a command with a key index and some data and amount and recipient on Ethereum. Then you see the acknowledgement of this transaction by the user. This is a certificate from Mmer, some track and you see there the data content, the recipient, the amount and we ask the user if he want to confirm and sign this transaction with other smart cards. Okay, and now I'm going to talk about the security fruits we want to cover with the crypto terminals. What we did, so we address the key storage and signature streets. So what we did for many years is that we did survey of what happened of the act and attack and street against the blockchain wallet.
00:18:34.176 - 00:19:29.184, Speaker A: That means each time we see an act or seen a conference, some things we try to study the hack and to find what was the main reason of this attack. And from that we identify a set of attack. And after you will see that in the design of the crypto terminal, we try to develop countermozer in order to avoid this kind of cyberattack. First attack. First fleet is a lack of tamper resistant storage and side channel attack able to recover cryptographic key at runtime. This is a very common attack when wallet, blockchain wallet don't use a secure element. So it means if you don't have a secure element, we know that it's impossible to enforce a secret by software.
00:19:29.184 - 00:20:19.960, Speaker A: So it means you need some piece of hardware in order to protect your key fritz. Number two is supply chain attack targeting malware injection or firmware malicious modification. Today supply chain attack are something very common not only for blockchain wallet but also for quite all kind of software. You read that every day in the press. You see that you have a supply chain attack and it's with somebody because you buy the device through internet with a complex and open distribution system. So somebody is able to modify the firmware of your crypto terminals and so to inject a malware and in order to keep your key fruit. Number three is software integrity is not checked and this is very common.
00:20:19.960 - 00:21:44.268, Speaker A: I give you a very classical example. What doesn't exist today in most device and notably for blockchain wallet, typically a bootloader check embedded firmware integrity that you want to learn on, but you have no proof of integrity of the bootloader. So through supply chain attack, somebody may modify your bootloader and thereafter if your bootloader is corrupted, it's a kind of what is called for other system rootkit and it means there is no way for you to detect that the system is corrupted. Fruit number four is a pin code or password act. If you enter this pin or password from the keyboard of classical terminals like device like PC or mobile then you can use for example kilogue or something else. Number five is misuse of the device from laptop or mobile running toys or one or one. So it means you have something bad on your terminals and these terminals and this malware try to take the control of your crypto terminals and fruit number six is cloning of gaming device clone with equivalent features include identifunction targeting, cryptographic, key recovery and it's also something important from industrial property point of view you may have clone.
00:21:44.268 - 00:22:23.656, Speaker A: And so we develop a technique in order to physically identify the clone. So now we are going to talk about this technique. So we have eight quantum users that can be applied to the crypto terminals. Number one is a secure element, it's a Java card. We have a high security level ranging for el five plus to el six plus given the fact that according to the common criteria standard, the maximum security level is el seven. So this secure element prevent side channel attack. You have also multiple manufacturers.
00:22:23.656 - 00:23:39.060, Speaker A: That means that according to the national policy, security company policy and whatever you can choose your smart cards manufacturers and firmware is written in Java card language. It means run everywhere or quite everywhere and we use removable smart card that can be it means that you have no sensitive data when you have no smart cards in your crypto terminals. Security number quantum measure number two is smart card screen detection. How do you know that you are using a greening smart card contrafate card memory in the back door. This is called the evil mind attack. This means somebody substitute a good card by a bad card and so in this bad card we have a backdoor and you can recover all the key you generate and so on and for that when the software starts in the smart card it generates a peer of public and private key. We don't know the private key but somebody generates a certificate for example Etrus, it could be another certification authority but somebody generates a certificate and stores the certificate in the Java card.
00:23:39.060 - 00:24:56.816, Speaker A: So what do the crypto terminals? Obviously you can do that by pressing a key or using a dedicated command which is called check. He reads the public key of the Java card, then he reads the certificate and then he send a random to the Java card which is signed by the private key and this and tell you that the test is okay or not. So you can check if the Java card is correct or not. Freak number three is Java card content attestation this is something very particular because contrary to your banking card we want to duplicate two smart cards because you want to put a smart card in a safe place so it's for backup. I remember I visit a company that was developing a wallet based on biometric and then simply forget at the beginning to backup the content of the device which is, from the user point of view, something crazy. It's very secure, but only for 1D device. So we have a command on the crypto terminals to duplicate a smart card and from the user point of view, it's nice to have an insurance that the cryptographic content of two smart cards are the same.
00:24:56.816 - 00:25:38.808, Speaker A: That's why we have dedicated procedures that in fact proves that the content of two smart cards is the same. So the crypto terminal send a random to the Java card. The Java card made a hash finger or print of all the cryptographic stuff and return this value sign with the random. And you see there you have this ash which is their display on the crypto terminal. And this hash is used in order to prove that two smart cards have the same content. It's useful when you want to retrieve and deal with your backup. Number four is a crypto terminal is an application firewalls.
00:25:38.808 - 00:26:55.380, Speaker A: It means how do you know that a malware running in PC or mobile is not using the smart card? It means that in fact, each time we want, each time we have critical operation like Pin entering signature generation, we ask to the user the acknowledgment of this operation. So if something is wrong on your terminal, you will see a lot of message and obviously if you do that again, the software integrity of the crypto terminal is something very important. That's why we put a strong effort in order to prove the integrity of the terminal software without cryptography. So we use Bar metal architectures. Number five, how do you know that your crypto terminal is running the right software? We have some discussion. There's a scientific advisor in Ethertus which is living in California, so he created several companies and we had a lot of discussion about what can use the user trust. And we arrived at the fact that one way that you can give trust to the user is that the user is able to reflash everything in the crypto terminal because he do it by M.
00:26:55.380 - 00:27:40.950, Speaker A: So we are able, as I say before, just see, to flash the mine processor. So there is no bootloader in the mine processor because we don't trust the bootloader except under center assumption. We can flash the bluetooth mine processor up to 256. We can also flash the flasher itself which is used to flash the mine processor. And in this flasher we have a two kilobyte bootloader which is resident and I will explain later how we check that the bootloader is not corrupted. So bar method is an important piece of trust for user. Number six is firmware authentication code.
00:27:40.950 - 00:28:38.052, Speaker A: So this is something very important and even if you flash the terminals, how do you know that the firmware are the right firmware? For example, you don't want to flash it every time and so on. And how can you prove firmware authenticity for the mine processor, for the bluetooth module and for the programming module? For that we developed a remote attestation function which is core. It's published on samdraft and paper. It's called the timestamped. BMAC. And remote attestation function is a sequence of insufficient which compute a fingerprint that we say hash over a set of memory, including the code of this proverb in a way that the Mac will be wrong or the computation will be slower. If memory content are modified, it means if somebody do some things it will increase the computing time.
00:28:38.052 - 00:29:29.408, Speaker A: So the computing time is part of the algorithm also. So we call authentication the exor between the Mac and the computing time and we have performance about one millisecond per kilobytes. That's to say in order to get an attestation on your mind processors it will take three minutes if you want full coverage. So there you see what is called a seed. Could be it's my birthday, it's an integral number less than 2 billion. You enter the seed and then the remote test station compute a Mac that you see there a Mac here you see the computing time in unit of 64 cycles, let's say four microsecond. And if it means on every crypto terminal you will find the same given the same seed, you will find the same computing time and you will find the same Mac.
00:29:29.408 - 00:30:25.688, Speaker A: And there you see what is called the authentication code which is the GZA of part of the Mac and the computing type. And you get this authentication code. So you can go on the ether trust server for example that generate permanently authentication code or you can after you did that generate your own seed and so you have your own authentication code. So you can have authentication given by the company or given by yourself. And some detail about this algorithm it's called timestamp objective Mac. So basically we compute hash over all the memory flash SRAM square prom but we compute it according to epsodom random order which is fixed by a permutation and given memory size of m we have for the current algorithm we use about m cube four permutations. That means a lot.
00:30:25.688 - 00:31:24.090, Speaker A: And you see there the generation of the authentication code, some detail of the mat we use for permutation what is called modular exponentiation. It's something very safe using for defiant manic change for example. So it's known to have a good run on this and there you see something very interesting that was not expected at the beginning. You see that the computing time Routely speaking has a normal distribution depending of the permutation. It means that you have for each permutation a given computing time and that's where this algorithm works nice. And if you have a huge amount of memory, then you have quite a single computing time permutation less memory. You have some computing time are duplicated and you see there is a mat and I'll say number seven.
00:31:24.090 - 00:32:08.104, Speaker A: Number seven means it's about a static and dynamic puff. We want to detect hardware clone because we believe that it's very important today to protect the industrial property, national property and so on. So we want to be able to detect hardware clone. So how to do that? To do that we use something called SRAM puff. And puff means physical unclonable function and it means what you have in your processor. You have a static ram. And when you power up the static ram upon borrowing up Samsel content take always a fixed value, either one or zero.
00:32:08.104 - 00:32:56.756, Speaker A: And from expiry motor point of view we find that about you have a generally about 90% of the SRAM cells take a fixed value for the SRAM. And it means you can have a SRAM profile which is used on an ID for a given D device. And we'll use another sync which is called the flipping bit. Due to some capacitance it's electrical effect, some puff bit may switch from one always one to zero, always zero or always zero and to always one depending on the rising time for the power up. And this effect is called a flipping bit. It has been discovered I would say three, four years ago by American researchers. And how to collect this SRAM puff.
00:32:56.756 - 00:33:26.508, Speaker A: We download a memory probe, we power up the crypto terminals with no rising time. And after we dump the SRAM content. And there you see the result of that for number of time. Let's say 250. You see in green the point always see at one in yellow the point always seen at zero in red what is called the flipping bit. It's a kind of minusy for the component. It cannot be emulated.
00:33:26.508 - 00:33:58.136, Speaker A: It's a dynamic effect. And then you see, you see there the mine processor and the SRAM inside the mine processors. And then you see the programming flash Sessor and you see this SRAM. And this is a kind of ID card. I give you an example there. This is for the programming token. There you have a reference profile for device number one with 250 measures.
00:33:58.136 - 00:34:45.464, Speaker A: So you see that in white you have the noisy point, the point that sometimes has one and the other to zero. There you see another reference profile. And in the middle you see in red the Mitch match point that are about 50%. So this show you that this profile app pseudo you unique and are quite different if you use so we can use that in order to identify physically the device. So the mine processors and the processor used by the flashing token. And this is an example of dynamic SRAM puff authentication. So this is the ID, the ID of the memory for the mine processor, you see the flipping bit in red, then you have a way to estimate it.
00:34:45.464 - 00:35:55.564, Speaker A: What is the threshold tension voltage for the flipping bit. And you see that this filament occurs at very low voltage and this is quite important below half volts because it means that the processor is not working when this effect occur. So there is no digital way to detect flipping bit and that's why it's dynamical. You cannot buy a processor even if you know the memory profile, you cannot emulate them. So there's what I call this is a Fertie power app called AIS for slow and it means we use a very low slope slow slop until let's say, alvolt and then a fast flot fast slot. And then you see the second signal which is we just start with a fast rising time and you see them. For these signals we don't create flipping bits, but for these other signals we create flipping bits.
00:35:55.564 - 00:37:14.380, Speaker A: So if we randomly use this kind of furtive powering app signals, we can dynamically authenticate a device from the puff without a way for the processor to have to use a copy, even if they know the profile, it will be defeated by this method. And this is our last, but at least countermeasure, which is a program token as a root of trust, as I say before. Except it for the Java card where you have the operating system in the Java card. We have not permanent software in the crypto terminal for the mine processor and the bluetooth module, but we need a flashing device in order to flash the device. So we need to have some trust about this device. And in this device we have a permanent software which is a bootloader. The issue we have, as I say before, with a bootloader, that a bootloader is some things from a security very confusing because usually you have some crypto inside the bootloader and so the bootloader check the firmware but if the bootloader is corrected, then you have no more shield against hacking.
00:37:14.380 - 00:38:48.830, Speaker A: And so thanks to this bootloader, we download what we call an integrity probe. An integrity probe is something that just execute a remote attestation algorithm like I described it before and the result which is a five digit authentication code is displayed by two blinking lead. Can do other way, but this is really the cheapest way is to display this result by these two lead and when you have checked the authenticity on the bootloader after wise you can download the firmware which is required by this flasher for Windows interaction and driver. And that's it. I am down. So I'm open to questions, if any. Ledger nano so ledger is a sponsor as a wallet we have some act, we did a lot of works around some act and this was some idea come from the act.
00:38:48.830 - 00:39:36.910, Speaker A: So you have some contamina in Ledger. But let's say security principles are different. Ledger is using. A bootloader and you have some security failures in the bootloader. It's difficult because a bootloader is something magic and if somebody corrupts the bootloader then you can inject whatever firmware you want in the device but you use a secure event. Okay, but which criteria are met with all your criteria you listen except the bootloader. I believe 1234 there is a secure event, okay, but it's not bomb at all.
00:39:36.910 - 00:40:50.780, Speaker A: And the idea of the clone is something quite new because we want really to have something that can be trusted and also some data cannot give you because it's too technical. We do specific stuff on the firmware. We download and this came from the ID came from act that has been performed by a guy on ledger. And so again we tried to find why it was possible to do that. So we performed special operation also on the firmware we have other countermeasure but I know the time to detail everything. How would you compare the key card to your approach? Or if you're familiar with key card keycard I don't know if you want the issue the DNA of ether trust is securement. So when you use a secure element, the issue is not the secure element, it's the terminals, the device that is manipulated the secure element.
00:40:50.780 - 00:41:52.440, Speaker A: So it means if you have a key card it's nice. But if you send command to the key card from something that has been corrupted then you lose a lot of benefit, quite all the benefit of the securement. So what is difficult when you use a secure event? The difficulty is that the security month itself is something very secure but it has a human user, it has a device user. So if you've put some malware in the device then you lose all the security models. For example, if you go to see the bank and say I want to use SmartCast with my PC and mobile and whatever, they will say, you know, you need some things trusted, some things that is in conformity with the phantex townstander and this is really the main difficulties you have. And it's people that don't like the secure elements. They say that it's not sufficient because at the end you have a software that is using these secure elements.
00:41:52.440 - 00:42:51.724, Speaker A: So even if you have this chunk less security level il six plus in the secure element is not enough. And maybe it's dangerous for the user because you give to the user the illusion that it's magic and it is not. That's why we take so much precaution with the use of and you also see this kind of things which is very important the fact that you can prove that your smart card is an authentic one. This is very important because you can really for example, you have a key card and you just write key card on smart cards or whatever and you give this card to the user and just evil minor attack, and this happened every day. There's an attack again, ledger, and simply it's a wrong ledger device. And that's it. This is quite simple to do that, and that's why we avoid that.
00:42:51.724 - 00:43:31.416, Speaker A: And I believe that what is great with the remote Attestation is that really you have a way to authenticate a software. And this is not using cryptography. It's very important. Not you use cryptography, because cryptography is a shield that can give you the ID that you are secure because you have some key, but you are not able to check if this is the right software and the right key inside the device. So for the user point of view, this is confusing. You say, oh, we have a lot of security because it's based on cryptography, but you don't know if the software is a right or not. That's why we believe that remote Attestation is something very important.
00:43:31.416 - 00:44:01.300, Speaker A: But you cannot use remote attestation everywhere because you have to have an infinite number of security code, and that means that you cannot store that is the principle of this security contaminant. You cannot store all the authentication code in the device. So it's finite. You lose. Any last question? Thanks. Thanks.
