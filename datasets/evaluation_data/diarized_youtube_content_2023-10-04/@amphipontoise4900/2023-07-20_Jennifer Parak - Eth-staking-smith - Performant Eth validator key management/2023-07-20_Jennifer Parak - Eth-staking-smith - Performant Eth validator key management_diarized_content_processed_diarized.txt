00:00:13.210 - 00:00:14.382, Speaker A: Testing. Testing. Yeah.
00:00:14.382 - 00:00:20.030, Speaker A: Hello. Hey. So today I want to talk to you about keys.
00:00:20.030 - 00:00:41.290, Speaker A: Specifically, I will tell you about E Staking Smith. That's our key generation tool that we built and open sourced earlier this year. And along the way, I also kind of want to demystify Ethereum keys and whatever is involved in the whole Ethereum validator lifecycle.
00:00:41.290 - 00:00:48.854, Speaker A: A quick introduction about myself. I'm Jennifer. I'm engineering manager of our staking product opus.
00:00:48.854 - 00:01:00.160, Speaker A: And I work for Course One. We're a Staking provider and we run Validators for over 50 networks. And I would say Staking is kind of a thing.
00:01:00.160 - 00:01:10.558, Speaker A: And most recently, we launched Opus. As I said, it's a validator as a service Staking API. And we also built a cute portal.
00:01:10.558 - 00:01:24.360, Speaker A: I'll show you some screenshots. And it's kind of targeted for institution Wales and we want to roll it out for retail as well. But let me first tell you why we decided to build our own key generation tool.
00:01:24.360 - 00:01:47.280, Speaker A: So, very early on, when we started working on automating our validator infrastructure, we turned to other tools that we found open source. So the most famous one is the Staking Deposit CLI. It's a really cool CLI targeted at solar stickers, so you can use it for generating keys and deposit data.
00:01:47.280 - 00:02:17.366, Speaker A: But there was a couple of things that didn't work out for us, especially when creating keys on a larger scale. So those points were like we found it a bit difficult to integrate and package the CLI in a rust backend. What the Staking CLI also does, basically, it outputs the private keys as an encrypted format, the so called key store, and writes those files on disk that wasn't super suitable to our use case.
00:02:17.366 - 00:02:55.266, Speaker A: So basically, we forked the project, made some customizations, and in this process we found that it was sometimes challenging to upstream the changes coming from the open source project. And finally, as I mentioned, because the Staking Deposit CLI wrote this file on disk, it was slowing down our key generation process a little bit and it would have required us to make some infrastructure workaround to ensure security. So in one of our company white hackathons, the Ethereum team actually decided to tackle this problem and we created an MVP to improve our key generation process.
00:02:55.266 - 00:03:06.230, Speaker A: And this was the birth of E Stackingsmith. Now, let me dive a little bit more into the kind of improvements that we found. So the next slide will get a little nerdy.
00:03:06.230 - 00:03:21.606, Speaker A: So to avoid kind of heavy lifting and to avoid having to write everything from scratch, we're interfacing Lighthouse Account Manager. So Lighthouse is an ethereum consensus client. It's also written in rust and open source.
00:03:21.606 - 00:03:38.180, Speaker A: So that was really convenient for us to use. And the Account Manager is basically a binary that you can use to generate your keys. So essentially, we optimized it in such a way that all the operations are done in memory and the key material is never written on the file system.
00:03:38.180 - 00:03:57.880, Speaker A: We use E Stakingsmith basically as a library in a rust backend. So that basically reduced code complexity by a lot for us. And as I mentioned before, Staking Deposit CLI, what it does when it generates your private key, it outputs it as an encrypted format, the so called key store.
00:03:57.880 - 00:04:20.954, Speaker A: And I already mentioned it's not really suitable for our use case and we kind of noticed that by avoiding to generating this key store, we actually sped up the whole key generation process by 98%. So that was a major kind of performance improvement for us. Now, I said already we use E Staking Smith as a library in a rust backend.
00:04:20.954 - 00:04:37.058, Speaker A: You can also choose to use it as a CLI. And if you really need to have a keystore generated, of course E Staking Smith also does that for you. And during development we actually found some tiny improvement you can make by default.
00:04:37.058 - 00:04:56.026, Speaker A: The Staking Deposit CLI will use a key derivation function which is called Script and that's super secure. Now, we found if you use a different key generation function which is called PB Keydf two, you can optimize a little bit for speed. And I know like everything is software engineering, everything is a trade off.
00:04:56.026 - 00:05:09.882, Speaker A: So if you want to have more security, you can choose Script. If you want to optimize for speed, you can use a different key derivation function. So earlier this year we published a blog article.
00:05:09.882 - 00:05:16.414, Speaker A: You can find it on our website. If you want further information about E Staking Smith. Also the project is open source.
00:05:16.414 - 00:05:32.214, Speaker A: We accept PRS. So if you have any feedback also you can reach out to me on Twitter. Yeah, I think one also takeaway I had from this whole project is we do a couple of hackathons, like company wide hackathons in a year.
00:05:32.214 - 00:05:55.786, Speaker A: And if you have talented engineers in your company, I would sometimes give them the freedom to work on something that's outside of the roadmap because I'm always amazed what really comes out of these hackathons. Again, one of these was E Staking Smith and I'm super happy because it improved a lot for us, for our validator infrastructure. Now, this was kind of like an introduction to E Staking Smith.
00:05:55.786 - 00:06:17.946, Speaker A: And what I kind of want to do now is walk you through the cycle of the Ethereum Valley data and then kind of zoom in where all the keys are generated and what you actually do with those keys. So this is kind of like an overview and again, I will jump into each of these steps to give you more details. Now, the first step, of course, is the key generation.
00:06:17.946 - 00:06:27.986, Speaker A: You can't have a validator without keys. And the second step is actually this famous deposit that you have to make. You have to pay 32 E per validator.
00:06:27.986 - 00:06:41.660, Speaker A: And when you make the deposit, I think by now you all know, the validator doesn't become active straight away, there is a validator queue that you join. It has famously become quite long. We'll dive into this as well a little bit.
00:06:41.660 - 00:06:56.290, Speaker A: But then once your validator goes past this queue and it's active, it has to perform some duties. So these duties are, if you perform them well, you get some rewards. And finally, I'm not sure why you would want to, but you could exit your validator.
00:06:56.290 - 00:07:09.414, Speaker A: So if you do that, you get basically your deposit back. Now let's jump into the Use case where you want to create a validator. So you could use Opus, our platform.
00:07:09.414 - 00:07:15.842, Speaker A: And then you just go there. You connect your wallet. You have to have at least 32 E and some for gas.
00:07:15.842 - 00:07:28.570, Speaker A: And what you do, you provide our back end with two addresses. The first important address is the withdrawal address. So this is where you will receive your reward and it's also where you receive your deposit back.
00:07:28.570 - 00:07:40.330, Speaker A: And the second address that you provide is the fee recipient. And that's where you get your priority fees and mev rewards. Now you've connected your wallet and you click the button Confirm and Stake.
00:07:40.330 - 00:07:53.886, Speaker A: And there's quite a lot that happens in the background, right? So this is where E Staking Smith comes into play. So E Staking Smith will generate all the key material and deposit data. Let's first look into the keys.
00:07:53.886 - 00:08:08.442, Speaker A: So E Staking Smith uses some randomness to generate an unpredictable seed and converts it into a 24 word mnemonic phrase. This is not something we've made up. This is according to the BIP 39 standard.
00:08:08.442 - 00:08:38.978, Speaker A: And then from this mnemonic, you can actually, in theory, generate multiple keys, right? And actually this mnemonic phrase you want to also store safely because you can use it to regenerate the keys if they get lost. Now, based on the seed, we generate a BLS, public private signing key. Pair BLS is a cryptographic signature scheme which was introduced with the move to proof of stake and has some really neat properties that we'll explore further down the line.
00:08:38.978 - 00:08:51.990, Speaker A: Now it's called signing key because this key will sign off any validator duty that you perform. We'll also look into this a little bit. So first look at the public key.
00:08:51.990 - 00:09:13.450, Speaker A: So this is basically the identity of your validator. So if you're looking for your validator on the beacon chain, you will always use the public key. Now, I won't go into basically this public private key encryption a lot, but there's something I want to highlight because it gives us some really neat properties.
00:09:13.450 - 00:09:38.374, Speaker A: Okay, so I'll walk you through this already. If you have your private key, this like, white key on the top, and you sign a message, you output a signature, and then someone else can go through this verification process. So given the public key that everyone can find on the beacon chain, the message and the signature, it's really easy to verify that the public key signed exactly that message.
00:09:38.374 - 00:10:03.562, Speaker A: So the cool thing that we get here is that we verify that the message wasn't tampered with and we also verify that the sender signed exactly that message. Now, I already said before, one kind of important input that we receive is Rd like withdrawal credentials. So essentially, this is the address you provide us.
00:10:03.562 - 00:10:15.060, Speaker A: And then whenever you want to exit your validator, you will get the deposit back there. And this is also the address where you get your rewards. Of course, if this address is wrong, there's basically nothing you can do.
00:10:15.060 - 00:10:33.526, Speaker A: And something you maybe see here, like we generated the signing key and you provide us with the withdrawal key. So that means you, with the withdrawal key have ownership of the stake that you put in and we own the signing key and store it safely. That means we can manage the stake for you.
00:10:33.526 - 00:10:57.050, Speaker A: And essentially, this is how such a noncustodial staking service is even possible. Now that we have both, basically both keys, we can generate this deposit data of 32 E. And in the next step so basically, when this whole process is ready, opus will open up your wallet and then you will sign a transaction.
00:10:57.050 - 00:11:08.754, Speaker A: Basically, this is a transaction to the EFT deposit contract. And this is now the step where we register this validator. Let me zoom in a little bit what this deposit data really means.
00:11:08.754 - 00:11:21.746, Speaker A: So essentially, we need to tell the Ethereum network that we want to run a validator. So the first thing you see here is our public key. Again, I said the public keys are the identity of our validator.
00:11:21.746 - 00:11:36.234, Speaker A: The second one is the withdrawal credentials. Again, now we need to basically register our validator and say if this is exited, this is where I want to first have my rewards and then also my deposit back. And the third field, now this is the interesting one.
00:11:36.234 - 00:11:58.670, Speaker A: This is where I walked you through how the signature process works. So what we're doing here essentially is the message that we're signing is the public key and the withdrawal credentials and we're signing this with the private key. So what's really interesting here is in this deposit registration process, we're proving ownership of this public key on registration.
00:11:58.670 - 00:12:15.030, Speaker A: And this is to avoid that anyone can pick any public key. Now the last field, essentially the deposit data route routes, you'll find them a lot on a beacon chain. They're kind of a cryptographic digest just know in this field.
00:12:15.030 - 00:12:25.738, Speaker A: And it's important to verify correctness of the inputs. Now, if we kind of like look at this on a higher level. So this process actually has three important functions for us.
00:12:25.738 - 00:12:58.738, Speaker A: So it offers civil resistance because if validators running a validator was for free, people like attackers could flood the network, right? We also provide accountability because we're registering our validator with the public key and we're signing it. With the private signing key we're basically providing accountability and then thirdly, it aligns incentives, right? If I pay my deposit, I also want to protect this deposit. So I want to make sure the validator runs well and performs its duties.
00:12:58.738 - 00:13:17.098, Speaker A: So I get rewards though if I misbehave, this validator would get slashed. Now let's come to the interesting part. Once we made the deposit successfully, everything is picked up by the theorem network and the validator now joins the activation queue.
00:13:17.098 - 00:13:47.938, Speaker A: I already teased a little bit it has become more famous this day because with the rising demand of Ethereum staking also the size of the queue increased. There is a good reason to have such a queue, right? The reason is we want to ensure stability in a validator set instead of letting validators come in and out. This would really create a lot of instability and the way the Ethereum network deals with it is their so called Churn limit.
00:13:47.938 - 00:14:06.154, Speaker A: The Churn limit is basically the amount of validators that are allowed to join the queue per epoch. Now, as you can see, I took the screenshot two days ago. I think it's like at the moment it should be around 36 days and from the point of deposit until your validator becomes active.
00:14:06.154 - 00:14:30.226, Speaker A: So if you want to run a validator this is really annoying because it's quite a long time so you could say hey, let's just increase the Churn limit. But the downside here of course is there are also risks involved with just increasing the validator set. Like a really big validator set could kind of lead to a risk of reorgs.
00:14:30.226 - 00:14:52.846, Speaker A: There's also a heavy load on the validator client. We recently saw Ethereum having some finality issues and this was also kind of due to having a lot of activations coming in. So you really need to be careful which kind of configuration you're tweaking and there's a lot of talks I read now how to deal with the validator set.
00:14:52.846 - 00:15:22.006, Speaker A: In the long run you want to reduce the side of the set and not having grow infinitely but this is a completely other talk that I won't get into. Now in the next step, while we're waiting, we can actually set up the validator infrastructure since the move to proof of stake, what you need is basically you need to run an execution client and a consensus client. I won't get into too much detail here.
00:15:22.006 - 00:16:06.306, Speaker A: My colleague and I, we gave a workshop at Defcon last year where we basically walked through the whole Ethereum consensus protocol and then also ran a demo how you can spin up a validator on testnet. There's also actually if you watch closely, there will be a blog article by my colleague Maxim Coolish who will also he's writing about kind of the key management also the risks involved of running a validator as well as how we mitigate it in our infrastructure. Now keywise what you need to know here when we set up the Validators, basically we load the public private key pair into the Validator configuration and also configure the fee recipient that was provided earlier.
00:16:06.306 - 00:16:22.410, Speaker A: So maybe you noticed also like E stackingsmith doesn't actually generate this P recipient. So this is something that we receive. Now once our Validator is active, we can perform our Validator duties and finally get some rewards.
00:16:22.410 - 00:16:41.562, Speaker A: So I want to kind of like zoom in here again. What are the Validated duties and where do our keys get involved here? So I've mentioned now a couple of times the fee recipient. If you propose a block, this is what everyone's really keen about, right? You will receive mev rewards and priority fees.
00:16:41.562 - 00:17:05.910, Speaker A: So priority fees are if you send a transaction, you can add a tip so your transaction gets picked first. And when a Validator proposes a block, they're actually like signing this with a private signing key. And due to the signature that is generated here, other Validators can again know immediately which Validator proposed which block.
00:17:05.910 - 00:17:20.890, Speaker A: Now actually, most of the rewards are accrued by the Attestations. So every epoch, every Validator gets the chance to basically share the view of the world. So attestations serve as votes from Validators.
00:17:20.890 - 00:17:49.154, Speaker A: So basically they vote for the most recent justified block and the first block in the current epoch. And by combining all these Attestations, like all these votes from all participating Validators, the network can finally reach consensus about the state of the blockchain. Now Attestations are also propagated across the network, though if we propagated them individually, there would be a lot of load on the network.
00:17:49.154 - 00:18:16.590, Speaker A: So there's something neat we can do. We're aggregating these Attestations from Validators and this is actually where these Pls signatures, the cryptographic signature scheme that we're using, comes in really handy. So what we can do with BLS is we actually aggregate these signatures over the same message and that could be thousands of signatures and these can actually be checked in just one verification operation.
00:18:16.590 - 00:18:39.570, Speaker A: What's also really cool if we aggregate this signature, it actually always stays the same size, 96 bytes. And this is really a massive gain in scalability and that's why the ethereum consensus is even feasible. Now, due to the collection of all the signatures, we can easily check which Validator has published her at the station.
00:18:39.570 - 00:18:51.094, Speaker A: And obviously if you publish her at the station, then you receive a reward. Basically another duty that we have to fulfill is the sync committee. That happens more rarely.
00:18:51.094 - 00:19:10.554, Speaker A: Basically what you do, if you're a member of the sync committee, you continuously sign a block header that is the new head of the chain at each slot. Now these were kind of introduced so light clients can quickly determine the head of the chain. But again, this happens fairly rarely.
00:19:10.554 - 00:19:20.690, Speaker A: So I think the rewards are quite favorable. Now let's look at the other side of the coin. What happens if you do not perform your validator duties.
00:19:20.690 - 00:19:44.134, Speaker A: So again, something that could happen is you fail to propose your block. So that leads to a lot of opportunity costs. Now something more tragic, like the big risk, actually, if you by accident run two validators with the same key, that could be like, due to the bug in your infrastructure, this could lead to double signing.
00:19:44.134 - 00:19:57.146, Speaker A: And let me just kind of explain. Basically, I already said if you propose a block, you sign it. If you propose two different blocks and you propagate them to the network, you're essentially proposing two contradicting blocks.
00:19:57.146 - 00:20:03.842, Speaker A: And that could lead to double signing, which leads to slashing. So I think double signing has been talked about a lot. Actually.
00:20:03.842 - 00:20:35.286, Speaker A: One example I wanted to bring up is if you're running mev Boost, essentially you're like, outsourcing the block building and the relayer usually forces you to sign the block. And this is so you give the relayer basically a commitment. And the reason why this works is because if you now fell back to your local block building and you signed a different block and propagated to the network, this essentially is then you would be double signing and that could lead to slashing.
00:20:35.286 - 00:20:58.900, Speaker A: So this is why this whole kind of chain at the moment works similarly to the Attestations you can be missing at the stations, which is not super crucial. Like your validator can be, there can be some downtime. But obviously, what could also happen if you're running a validator with the same key, two validators with the same key, this could lead to double voting, which is also a slashable event.
00:20:58.900 - 00:21:23.910, Speaker A: And now onto the sync committee. So there's actually no slashing involved, but you could fail to publish your designed head of the chain. So basically the sync committee, this means that we're really relying on the sync committee being honest onto the final, like, the end of the lifecycle of our validator.
00:21:23.910 - 00:21:41.386, Speaker A: So that's actually, like a question we receive a lot. So now we're now making it to the end of all the states. So what if you want to exit your validators because maybe you want to receive your deposit back? Essentially what you have to do, like, very similar to kind of the previous pattern.
00:21:41.386 - 00:22:04.920, Speaker A: So maybe, I think by now you kind of understand this process. We need to sign an exit message and we sign it with a private signing key and then we publish it to the beacon chain, essentially. Now, a question that we get a lot is, well, what happens if Opus API is down? Like, how can I extend my validator? This is because Chorus One owns the signing key.
00:22:04.920 - 00:22:20.378, Speaker A: Now, what you could do to kind of work around this problem is when you create your Validator, you could already generate this signed exit. We could generate this signed exit transaction for you, though. This is like very sensitive information.
00:22:20.378 - 00:22:34.260, Speaker A: If someone gets hold of it. They could just take it and publish it onto the chain. Obviously, you would still get your withdrawal to your address, but obviously with this long queue, this is still painful if your Validator exits if you don't want it to.
00:22:34.260 - 00:22:52.966, Speaker A: Here, you already see there's like a dependency on whoever is running your Validator infrastructure and owns your signing key. There's actually a proposal coming up by the Ethereum Foundation. So they're proposing that this exit message can actually also be signed by the withdrawal key.
00:22:52.966 - 00:23:20.174, Speaker A: And if this is the case, then non custodial services kind of like you're more independent because that means that with your withdrawal key that you own, you could sign this exit message and propagate it to the beacon node yourself. For me, it basically means I can delete a bunch of code. Maybe I add a feature to Eftaking Smith where you can just generate the signed exit transaction with your withdrawal key and yeah, happy days.
00:23:20.174 - 00:23:29.234, Speaker A: You can exit your Validator anytime now. I hope this was somewhat helpful for you. Again.
00:23:29.234 - 00:23:37.522, Speaker A: My name is Jennifer. You can add me on message me on Twitter, message me on Telegram if you have any more questions. Yeah, thanks a lot.
00:23:37.522 - 00:23:38.160, Speaker A: I'm also around.
