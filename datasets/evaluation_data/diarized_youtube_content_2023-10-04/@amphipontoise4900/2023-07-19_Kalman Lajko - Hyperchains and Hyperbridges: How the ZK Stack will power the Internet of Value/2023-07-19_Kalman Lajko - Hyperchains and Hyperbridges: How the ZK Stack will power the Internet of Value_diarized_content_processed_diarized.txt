00:00:15.050 - 00:00:34.658, Speaker A: Hey everybody, I'm Kamin Lutchko from ZK Singh and like to talk to you about hyperchains and hyperbridges. So first we'll cover what hyperbridges actually are and then we'll look at this different ecosystem architectures that are possible using hyperchains. So the first one is proof aggregation, the second one is layer freeze.
00:00:34.658 - 00:00:56.314, Speaker A: So fractal scaling when you put layers on top of other layers and then we'll cover layer degradation. This is actually a combination of simple proof aggregation and layer freeze and has the benefits of both. And then we'll look at a simple add on which allows instantaneous messaging between different hyperchains, but in a trusted manner.
00:00:56.314 - 00:01:11.858, Speaker A: So this last solution will not be trustless, but let's first cover hyperbridges. So, scaling has always been a problem with blockchains. Bitcoin does around seven TPS, Ethereum does twelve, Visa does 2000.
00:01:11.858 - 00:01:33.686, Speaker A: And if we truly want to bring crypto to the whole world, we'll need to do hundreds of thousands, maybe millions of TPS. And the only way to achieve this is horizontal scalability. Horizontal scalability means that you should be able to spin up new chains to serve new traffic and connect with other existing chains in the ecosystem.
00:01:33.686 - 00:01:55.010, Speaker A: Similarly to how you can spin up new servers to serve new traffic to your website. Now, both Cosmos and Polkadot have been attempts at horizontal scalability, but ultimately they do not scale as their bridging solutions are not trustless. And it is very hard to build actually trustless bridges.
00:01:55.010 - 00:02:08.870, Speaker A: But using ZK Roll ups this is possible. Using ZK roll ups. Trustless bridges are possible because ZK roll ups verify execution using cryptography.
00:02:08.870 - 00:02:36.270, Speaker A: The bridges are governed alongside the chains, so there's no possibility of an external bridge hack. The governance mechanism of the chain takes care of it and ultimately the chains cannot hard fork. If the proof is settled on layer one, then the state of the chain is settled and other chains can now use that state to verify the transactions that they receive from that other chain.
00:02:36.270 - 00:02:55.998, Speaker A: And this is where hyperbridges come in. So, hyperbridges allow value transfer and messaging between different HyperChain in this ecosystem. So how does hyperbridging work? There will be a layer one shared bridge and two hyperchains which do the messaging.
00:02:55.998 - 00:03:07.480, Speaker A: The transaction is initiated on the sending chain. If you are sending assets to another chain, then these assets are burned. Then the sending chain spoof settles down to L one.
00:03:07.480 - 00:03:17.050, Speaker A: Here a route of all messages is updated. This route corresponds to all the transactions sent in the ecosystem. So updating this route is not expensive.
00:03:17.050 - 00:03:35.950, Speaker A: After this, the destination HyperChain can import this message route via its consensus mechanism. And a relayer will have to relay the transaction from the sending chain to the destination chain. This relayer will also relay a merkel proof connecting the transaction to the message route.
00:03:35.950 - 00:03:51.570, Speaker A: And this merkel proof is verified on the destination chain. Once the transaction is verified, it can be executed. In our case, this means that the asset is minted on the destination chain.
00:03:51.570 - 00:04:12.490, Speaker A: And in this way the asset is passed from the ascending chain to the destination chain without going through L One. And finally, the destination chain settles its proof down to L One and settles its imported message route. And this is when this imported message route is verified, so that's hyper bridging.
00:04:12.490 - 00:04:38.694, Speaker A: And using hyperbridging it is possible to connect this ecosystem of hyperchains and horizontal scalability is finally achieved. Anybody will be able to spin up their hyperbridge using the ZK stack, join this ecosystem and trustlessly message with other hyperchains in the ecosystem. And messaging will be cheap as it does not go through L.
00:04:38.694 - 00:04:50.902, Speaker A: One, but it is ultimately verified by it. So those are the basics. Now let's get into the bit more complicated part about different ecosystem architectures.
00:04:50.902 - 00:05:05.946, Speaker A: So Vitalik wrote a great post about this. What kind of layer freeze makes sense? And from it I quote there's clearly an important role to be played by layers of some kind. There's clearly an important function of proof aggregation that needs to be filled somehow.
00:05:05.946 - 00:05:23.710, Speaker A: I suspect more sophisticated and simpler constructions such as those described in this post will start to have a bigger role to play as the layer two scaling ecosystem matures. So he mentions three things layers. Layers are great because you can settle on a higher layer quickly and cheaply.
00:05:23.710 - 00:05:36.870, Speaker A: And this allows fast messaging. Proof aggregation. Proof aggregation allows scale because multiple proofs can be aggregated and settled in a single proof on layer one or a layer two.
00:05:36.870 - 00:06:00.334, Speaker A: And also more sophisticated constructions are also possible. But before we look into these constructions, I'll just warn that for all constructions, sovereignty is preserved. For example, for if you launch your layer three, it will always be possible to quit the layer two that you're settling on and become your own independent layer two.
00:06:00.334 - 00:06:22.630, Speaker A: So we think that this is particularly important for the community of all hyperchains, for each community to have its preserve its sovereignty, and of course the provers and everything is open source. So each HyperChain will be able to prove and settle to L One independently. So the first construction is proof aggregation.
00:06:22.630 - 00:06:42.026, Speaker A: Proof aggregation is each HyperChain creates its proofs independently and these proofs are aggregated into a single proof and settled on L One together. This is great because this is truly scalable. Any number of HyperChain proofs can be aggregated.
00:06:42.026 - 00:06:53.274, Speaker A: But the downside of this is that it does not allow fast messaging. To save costs. This common proof will be settled on L One maybe every 30 minutes to an hour.
00:06:53.274 - 00:07:10.230, Speaker A: This is different in different ecosystems. And messaging is only possible after the proof is settled. So until the proof is settled in that 30 minutes time frame, it will not be possible to import the message route on the destination chain.
00:07:10.230 - 00:07:27.738, Speaker A: And this is where layering and layer freeze come in. Layer freeze do allow fast messaging because you can settle your Layer Freeze proof on the layer two. And this is the same high probability process that we saw before, but it's on a layer two now.
00:07:27.738 - 00:07:55.454, Speaker A: And this makes fast messaging possible. This also uses proof aggregation in the background because the layer two's blocks are proved first independently and these are aggregated into a single proof and settled on L One together. Now, the downside of this is there are due two downside.
00:07:55.454 - 00:08:08.034, Speaker A: The first is that because all transactions go through the layer two, this is not scalable. The layer two is also a virtual machine that needs to process the proofs. So in itself it's not scalable.
00:08:08.034 - 00:08:17.030, Speaker A: And the second is that the layer two will also have its normal users. It will also need a mempool. It will need long term storage.
00:08:17.030 - 00:08:29.022, Speaker A: So it will ultimately need its own consensus mechanism and validator set. And currently in Ethereum, all roll ups are centralized. So validators only exist for Ethereum itself.
00:08:29.022 - 00:08:55.430, Speaker A: But in the long term, when we'll have multiple hyperchains, there'll be considerable validator fragmentation between the different hyperchains, and this will cause security risks. So layer freeze also cause validator fragmentation. So can these two problems be solved scalability and validator fragmentation while still preserving fast messaging? And the answer is yes.
00:08:55.430 - 00:09:17.758, Speaker A: Using Layer Aggregation, we simply have to remove the virtual machine from the layer two and create a specialized layer two that is only used for the layer settling of the layer freeze. And for messaging, the message route should still be imported from here and settle. The different hyperchains should still settle here.
00:09:17.758 - 00:09:40.114, Speaker A: And this specialized proof will still need its consensus mechanism because the different hyperchains will need to settle here before they settle to L One. And this will have fast messaging. It is scalable because a specialized proof can settle any number of hyperchains.
00:09:40.114 - 00:09:58.534, Speaker A: And because it will not process user transactions and it will not need its own long term storage. It will only need a lightweight consensus mechanism that does not lead to validator fragmentation. So if we compare the free solutions, simple aggregation does not allow fast messaging.
00:09:58.534 - 00:10:08.442, Speaker A: It does scale. It does not need a full consensus mechanism and it does not lead to security fragmentation. L three S do allow fast messaging.
00:10:08.442 - 00:10:20.590, Speaker A: They do not scale. The L Two needs a full consensus mechanism and it does lead to security fragmentation. And layer aggregation does allow fast messaging.
00:10:20.590 - 00:10:27.190, Speaker A: It does scale. It only needs a lightweight consensus. And so it does not lead to security fragmentation.
00:10:27.190 - 00:10:38.238, Speaker A: So that was the core of my talk. Now we'll talk about a few more add ons. For example, instantaneous messaging.
00:10:38.238 - 00:10:50.622, Speaker A: Instantaneous messaging is also possible between roll ups. But for this, the message route has to be imported before it is proven. Now proving times are coming down.
00:10:50.622 - 00:11:24.230, Speaker A: So using our new proof system Boojom, which only requires 16GB of GPU Ram, these will be very quick, maybe in a couple of seconds. But to save cost settlement time is the main consideration for importing the message route. But the message route can be imported before but it needs to be calculated correctly and this will require some sort of economic guarantees such as some sort of staking mechanism by the validators.
00:11:24.230 - 00:11:49.278, Speaker A: Ultimately, however, this solution is not secure because if a message route is incorrect then the destination hyperchains will have to revert. So this will not be used by a very large number of roll ups, only by smaller community of roll ups that really trust each other. So in conclusion, we'll have the layer one.
00:11:49.278 - 00:12:21.780, Speaker A: This will host the shared bridge where all the hyperchains will settle their proofs and the shared proofs and the layer aggregator will settle the layer diggrator will settle the proofs of the hyperchains and smaller communities of hyperchains can have trust zones between them that can have instantaneous messaging. Thank you very much and I'd love to answer your questions that are not related to Airdrops. Thank you.
00:12:21.780 - 00:12:43.420, Speaker A: Thank you very much.
