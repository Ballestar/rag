00:00:17.050 - 00:00:21.434, Speaker A: Hello everyone. My name is Tokirl. I do research at scroll.
00:00:21.434 - 00:00:43.942, Speaker A: You might have seen me on Twitter arguing about the definite of a roll up from time to time. And today we're going to be talking about multiverifiers as a hedge against validating bridge implementation vulnerabilities. So you might have heard about roll ups and you probably also heard that they're quite complex, as you can see from this screenshot.
00:00:43.942 - 00:01:02.998, Speaker A: And because they're complex, there are certain things that are missing and certain things that are slow to being added. And just as an example of some moving parts that you have in a roll up construction, you have a sequencer, you have approver. I'm talking about a ZK rollup.
00:01:02.998 - 00:01:38.170, Speaker A: There's a Zkvm circuit for Zkvm ZK rollups, there's Bridging mechanics, there's on chain verifier and there are loads more things and they're all complex and they're difficult to audit and they're difficult to ensure that they're working correctly. So there have been a few solutions proposed to minimize the vulnerabilities. So you might have heard of multi provers Vitalik did a talk last year about it and Justin Drake also made a proposal about how to implement multiprovers.
00:01:38.170 - 00:01:56.366, Speaker A: So the idea is quite simple. A multiproover is a system that utilizes two or more distinct proving systems to enforce the validity. So basically, for example, you can have a halo two based zero knowledge proof and a MIPS based fraud proofs.
00:01:56.366 - 00:02:11.026, Speaker A: And if both of them agree on the same state, then that's it. You are almost guaranteed that there are no vulnerabilities in one of those systems. Another example, you can even have three different proof systems.
00:02:11.026 - 00:02:27.802, Speaker A: So you can have a Stark based serial knowledge proof, you can have an HGX based proof and you can have valid comedy. And for example, you can also do where if two out of three agree, then the state route is accepted as valid. So here's an example how it works.
00:02:27.802 - 00:02:49.438, Speaker A: So in a traditional roll up, you submit a batch, a CK roll up, might I add, and then you submit a proof and that's it, that's how it works. And in a case where you have a multiprover, the way it would work is you submit a batch, you submit proof one and you submit proof two. And if both of them agree, then you continue submitting the batches.
00:02:49.438 - 00:03:08.486, Speaker A: If not, the roll up stops. And there are, depending on a specific implementation, you have different mechanics of how to handle the discrepancy. So essentially, if there's a disagreement between two proofs, an external Security Council can arbitrate and pick the one that they think is correct.
00:03:08.486 - 00:03:19.350, Speaker A: There are other ways you can also do it, but that's the prevalent opinion of how you should do it. So that's on the prover side. But what about smart contracts? They're also complex.
00:03:19.350 - 00:03:43.010, Speaker A: And as this never ending list shows us, there's a never ending list of hacks that happens because of smart contract bugs and vulnerabilities. So how do we solve that? That's where multivarifiers come in. So what is a multivarifier? A multiverifier is a system that utilizes two or more distinct validating bridge implementations to enforce validity.
00:03:43.010 - 00:04:09.958, Speaker A: So the reason why you would do it is to protect against implementation bugs. And the two implementations should share the storage and should also be gas efficient because let's say if it's very expensive to have two implementations, users are likely going to choose the protocol that has only one bridge because it's just cheaper for them to use. So the difference has to be negligible.
00:04:09.958 - 00:04:25.018, Speaker A: And the multivarifier consists of three different parts. So there's an entry point contract that I'll explain later. There's verifier Solidity, which is Bridge implementation and solidity.
00:04:25.018 - 00:04:35.402, Speaker A: And then there's Verifier Viper, which is an implementation in Viper. You can also use other languages like Half or Fee or whatever. But for this example, let's assume that it's Solidity and Viper.
00:04:35.402 - 00:04:54.090, Speaker A: So what is an entry point? Entry point is the publicly accessible API. So essentially, if the user or the sequencer or the prover wants to interact with the contract, they do it through the entry point. So they can't access the Verifier Solidity or verify Viper directly.
00:04:54.090 - 00:05:15.742, Speaker A: It handles communication with verifier solidity and Verifier wiper. So basically, the user sends, for example, an L one to an L two message to the entry point contract, and then it calls the Verifier Solidity and Verifier Wiper, respectively. And it's the only one that has the privilege to write to the storage.
00:05:15.742 - 00:05:30.710, Speaker A: So the Verifier Solidity and Verifier Wiper can only store things in memory. They cannot actually write to storage. And the main purpose of this contract is to verify the consistency of values returned by the two implementations.
00:05:30.710 - 00:05:42.934, Speaker A: So now for Verifier Solidity, it's a solidity implementation of the validating bridge logic. It doesn't have permission to write, but it has permission to read from storage. Same as with Viper.
00:05:42.934 - 00:05:54.430, Speaker A: The only difference is you use Viper instead of Solidity. So how it works, so you have an entry point contract. Let's say I, as a user, submit a batch.
00:05:54.430 - 00:06:15.694, Speaker A: Once the batch is submitted, the entry point contract requests one of the contracts. So the way they implement it is one has to be a driving bridge and the other has to be the one that basically returns the values that are checked against each other. So in this case, for example, Solidity is the driving bridge.
00:06:15.694 - 00:06:28.742, Speaker A: So you would send a request to process the submission of the batch. Then the verify Solidity returns the values that need to be written to the storage. Then the same is done with the Viper contract.
00:06:28.742 - 00:06:49.306, Speaker A: You send the request to process the submission, and the Viper contract returns the values that need to be checked against the request that were sent by Solidity to process the storage. And if both of them agree, great, we continue. And the same happens with approve after the batch is processed.
00:06:49.306 - 00:07:08.840, Speaker A: So you ask the solidity Verifier to process the submission and then it returns the values that need to be written to the storage. You do the same with wiper, blah blah blah blah blah blah. And basically if they agree, then perfect, we have a finalized block or a batch or whatever you want to call it.
00:07:08.840 - 00:07:24.314, Speaker A: And again, the same with multiprovers. If there's a disagreement between the two, there is an external Security Council that can just pick whichever one is correct. You can do it in other ways as well.
00:07:24.314 - 00:08:03.654, Speaker A: Again, but we'll just copy the prevalent idea on the multipriover side. And you can also combine the multiprovers and essentially get a system that just drastically decreases the possibility of implementational bugs, because you need to have identical bugs in both systems on either the prover or the Verifier side, which is unlikely to happen. And the likeliest vulnerability that you're still going to have is some vulnerability on the specification level.
00:08:03.654 - 00:08:22.798, Speaker A: So for example, when you define the bridge functionality, you forget a certain check, sanity check that needs to be implemented. And basically that is used to hack because having two implementation doesn't protect against that because you'll just copy the same specification. That's it for my talk.
00:08:22.798 - 00:08:26.320, Speaker A: Thank you very much. And if you have any questions, feel free to ask.
00:08:36.940 - 00:08:45.640, Speaker B: Hello. So my question is this is purely to prevent a technical.
00:08:47.580 - 00:08:48.136, Speaker A: How do you.
00:08:48.158 - 00:08:50.330, Speaker B: Say, a problem in the smart contract, right?
00:08:51.100 - 00:08:54.344, Speaker A: Yes. So it's purely to prevent an accidental.
00:08:54.392 - 00:08:57.836, Speaker B: Bug in the implementation of the smart contract. That's what I mean. Yeah.
00:08:57.836 - 00:09:01.310, Speaker B: Okay. And is this already used in some kind of products?
00:09:02.020 - 00:09:39.908, Speaker A: Not really, as far as I know. I feel like there are a few people who are discussing it and I also talked about it with Vitalik and I feel like people underestimate the attack vector on the smart contract side. So for example, a lot of people talk about multi provers, et cetera, but because multi provers are more complex, there are fewer people that can actually exploit a bug on the prover side, whereas smart contracts are much more accessible to people and a lot more people know solidity.
00:09:39.908 - 00:09:54.016, Speaker A: So it's more likely that people are going to discover some sort of bug on the Smart contract side. So this allows you to have it, but as far as I know, nobody has implemented it. So it's still a theoretical thing.
00:09:54.198 - 00:09:55.376, Speaker B: Okay, thank you.
00:09:55.478 - 00:09:56.370, Speaker A: Thank you.
00:10:01.860 - 00:10:12.404, Speaker C: So different Ckevms have different gas fees, hash functions, et cetera. How can you prove use different provers if the EVMs are different?
00:10:12.602 - 00:10:29.370, Speaker A: So you can implement two different provers that follow the same state transition function. So let's say you can have a theory. So what we're working at the moment at scroll is what is I showed here sorry, let me just get back.
00:10:29.370 - 00:10:56.670, Speaker A: Yeah, this one. So what we're implementing at the moment is an SGX based prover. So essentially you just implement the same state transition function that you have on the Snark based prover side and you implement it inside SGX and you have a second prover.
00:10:56.670 - 00:11:19.830, Speaker A: And in this case it's one of the few use cases where SGX actually makes sense and it doesn't really affect your security because it's purely additive. So if it fails, you cannot steal money or anything. As long as there's not the same bug on the Snark proofer side, the only thing that it can do is it can just hold the chain until the Security Council picks the correct proof.
00:11:19.830 - 00:11:34.140, Speaker A: I guess that's it then. Thank you very much.
