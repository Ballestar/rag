00:00:20.170 - 00:00:20.622, Speaker A: Cool.
00:00:20.756 - 00:00:31.550, Speaker B: So hi, everyone. I'm Joel, co founder of Three Box Labs. And today I'm going to be talking about kind of some of the insights we've learned along the way as we've been building Three Box.
00:00:31.550 - 00:00:39.470, Speaker B: And now take it off. Oh, great. And now ceramic network.
00:00:39.470 - 00:00:55.538, Speaker B: And really what the focus of this bucket is kind of primitives for creating mutable content on Web Three. And I'll go into kind of what that means. So what I'm going to be talking about today is crypto data.
00:00:55.538 - 00:01:20.478, Speaker B: And crypto data might not be like super well defined yet, but I think it's actually a concept that's going to be really important for the Web Three movement. And so there are some simple examples of what crypto data could be, some kind of early examples. So, like file an ICF, you put data in there, you get a hash, and you can like, when you retrieve the data based on the hash, you can verify that you get the correct data.
00:01:20.478 - 00:01:44.054, Speaker B: The contract on Ethereum is, of course, crypto data, and you can verify the state of the contract, but it kind of requires you to sync all of the history of all contracts on Ethereum. So it's kind of very heavy to verify that data. A JWT is just like a JSON object that contains some signatures and that's also like cryptographically.
00:01:44.054 - 00:02:00.830, Speaker B: Verifiable so all of these are kind of simple examples of crypto data. But really what I desire, I think what we also desire is types of crypto data that can be objects, that can be mutable, have a permanent Identifier.
00:02:01.410 - 00:02:02.862, Speaker A: And change over time.
00:02:02.996 - 00:02:04.894, Speaker B: So we want these to kind of.
00:02:05.012 - 00:02:06.160, Speaker A: Also be.
00:02:14.970 - 00:02:25.560, Speaker B: In the entire world just to verify one piece of information that I care about in my application. I think if we can make these crypto data objects real.
00:02:28.910 - 00:02:52.346, Speaker A: If we can make these crypto data objects real, we can actually essentially make the entire Internet verifiable. All right, so in order to kind of understand how we can get to something like this, I think we need to look at the history of peer to peer cryptographic data protocols. So actually, we're going to start looking at one of the early protocols, BitTorrent.
00:02:52.346 - 00:03:14.280, Speaker A: So in BitTorrent, you basically have this concept of a torrent file that describes some piece of data. And once you have the torrent file, you can connect to trackers where you can find the other peers in the network. And there was a problem, though, early in the BitTorrent protocol that these torrent files was super huge.
00:03:14.280 - 00:03:40.042, Speaker A: So it took a lot of power to host a site that had all of these torrents. But the maintainers of the BitTorrent protocol created a new concept called a magnet link, which is essentially just a hash of the torrent file. And so you get this kind of cryptographic Identifier, which you can use in the peer to peer network to look up other peers that know about the torrent file, get the torrent file.
00:03:40.042 - 00:04:12.678, Speaker A: Once you have the torrent file, you connect to the trackers, gives you the data about which peers have information about the file you're getting. So you're essentially going from a hash to a piece of data or a file, which is very similar to how IPFS works as well. But you still have a problem with BitTorrent that you have a problem with BitTorrent and so you have this hashes that goes to files, but you don't have any mutability.
00:04:12.678 - 00:04:41.970, Speaker A: So you have the same thing in IPFS where, okay, I can cryptographically verify the data, but I can't really change the content. And that's the reason why sites like the Pirate Bay was needed for torrents because they needed like a centralized site to keep track of the things. If you could mutate torrent and change them over time, you wouldn't need a centralized site like Pirate Pay and other sites.
00:04:41.970 - 00:05:04.454, Speaker A: But interestingly about BitTorrent is actually works really well. It scales well purely from a technical perspective and you can actually stream content similarly to what you could at Netflix. So the technology works kind of well for static files, but we need mutability.
00:05:04.454 - 00:05:29.166, Speaker A: So there was actually an innovation that I think most of you are very familiar with that came after BitTorrent and that's Bitcoin and Ethereum. So essentially this concept of a blockchain where you have blocks that links back in any kind of linked list fashion. And so in Bitcoin, the state that's maintained is to all of the unspent transactions.
00:05:29.166 - 00:05:48.790, Speaker A: So if you're building an application, there's not really super much interesting stuff you can do with that. But Ethereum introduced the concept of a state tree so we can actually keep track of various types of state of different smart contracts. And now we have this way of having immutable state over time.
00:05:48.790 - 00:06:19.106, Speaker A: But the problem still is if I want to know the state of my contract in my application, I need to also verify the state of all other contracts in the blockchain. So you kind of have this limitation. So now once we have this examples of BitTorrent and blockchain, where do we go next? So I think in order to understand that, we need to look a little bit deeper at kind of the data structures of blockchains and generally other protocols as well.
00:06:19.106 - 00:06:39.500, Speaker A: And that's merklize data. So the canonical kind of example you'll find of this is the merkel tree, right? And you have blocks of data, you take hashes of them, recursively until you get to a root. And as that, you can represent a bunch of transactions or represent the file system or stuff like that.
00:06:39.500 - 00:07:07.374, Speaker A: But what if you want to mutate the data? Then you need to essentially update this merklized dag. And so the example to the left here is essentially what happens in Git where you have a tree of the file system and then you make a patch. So like you go from XS to YS, and then you add this node e, and then you have to basically mutate part of the tree, but you can still point back to the old part of the tree.
00:07:07.374 - 00:07:23.426, Speaker A: So you kind of get this nice way of mutability without kind of losing track of history. And IPLD is essentially the data layer of IPFS. And so IPLD allows you to represent any type of merkel data structure.
00:07:23.426 - 00:08:04.862, Speaker A: So you can represent, of course, like, IPFS file system, but also git, and you can even represent bitcoin blockchain and the ethereum blockchain inside of IPLD. All right, so once we have this primitive of mercurialized data, we still have the problem of like, okay, how do I keep track of what's the latest update? What's the latest tip of this data structure? And of course, there are a bunch of different approaches to this problem, and I'll kind of categorize them in two different parts. One, and this is kind of like a generalization, I won't go into details on these things, but I think these two categories are kind of nice to describe the two approaches.
00:08:04.862 - 00:08:20.202, Speaker A: So one is the public key based one. So you basically have a mutable pointer that is a public key. And then where the pointer points to, you use the private key and basically sign a message that contains the latest hash of the root of the thing you're pointing to.
00:08:20.202 - 00:08:30.766, Speaker A: And then you kind of also include a nons. So you can see what's the most recent update. And so IPNs works this way.
00:08:30.766 - 00:08:53.714, Speaker A: You can point to any type of data inside of IPFS. Similarly, that HyperCore and secure scuttlebot also works on this kind of one public key approach. There's also a more kind of sophisticated approach, which is using some kind of state machine to govern the state transitions that your merklized data structures go through.
00:08:53.714 - 00:09:13.658, Speaker A: And so some examples of this are Textile Query, Phishing, Orbitb, and essentially you have this append only data structure that's signed by some key. So some type of transitions are valid, some are not. And from that, you kind of reduce the state.
00:09:13.658 - 00:09:27.514, Speaker A: But in both of these approaches, there's a problem. And it turns out this problem is really important if you're building like, an identity system. And it's also important to if you want to care about opsic.
00:09:27.514 - 00:10:01.746, Speaker A: So if you want to do good key management, you periodically want to rotate keys, or if you want to keep a list of people that are in a message group, for example, you want to be able to remove someone, and you don't want them to be able to sheet and come back into the group again. And so why can't these state based systems do that? Well, let me describe kind of the problem. So here we have this merklized data structure.
00:10:01.746 - 00:10:48.520, Speaker A: So you see, at the bottom, we kind of have the genesis signed by the first public key, and then in the middle we rotate from public key one to public key two and that's also signed by the first public key and now only like public key two can make updates. So this seems kind of well and good. Well, no, because if someone steals my first public key and they can basically create an alternative history that includes and points to a previous record before I signed the rotation and someone as, like, an outside observer that looks at this data structure has no way of knowing which of these two branches of history is the canonical history.
00:10:48.520 - 00:11:06.250, Speaker A: And, and all of the systems I described above have this problem. There's no way to know which key and which branch of history is the canonical one. So how do we solve this? Well, we essentially use a property of the blockchain called the proof of publication.
00:11:06.250 - 00:11:41.020, Speaker A: So once I rotate the keys, I add, take the hash of the update, put that on chain and now I essentially have a proof that this update happened at some specific point in time. And if someone gets a hold of my first public key they will be able to create it on alternative branch but they won't be able to go back in time and put something on the blockchain earlier. So now we can actually know as an outside observer which branch of history is the canonical branch of history.
00:11:41.020 - 00:12:18.834, Speaker A: And there's actually like another interesting property of doing key revocation in this way and it's actually important to identity and reputation protocols and that's that you can't actually sell identities. So if you're using a proxy contract on Ethereum or you're using various types of reputation on chain, you'll always be able to kind of trade the identity, like give someone else right and access to that. But here in this example, alice is going to try to sell her identity to Bob and we'll see what happens.
00:12:18.834 - 00:12:36.694, Speaker A: So Bob is like, hey, I gave you ten Ether for all the reputation you built up. So Alice makes some updates with public key one, that's her reputation and then she rotates to publicy two, which Bob owns and she gets money from Bob. And now once she got the ETH from Bob, she's kind of sneaky.
00:12:36.694 - 00:12:59.330, Speaker A: So she publishes before she made the rotation, she actually created an alternative branch in before that she didn't tell anyone about. And once she got the money from Bob, she publishes that and gets her identity back. So this makes it essentially impossible to trade identities.
00:12:59.330 - 00:13:29.238, Speaker A: And the nice thing about this is even if Alice was like, okay, I'm going to be honest and actually sell my identity, bob wouldn't trust her because he can't know that she hasn't hidden this information. And I think this is really important for a bunch of various type of use cases in identity where we actually don't want people to just like betray building a reputation and selling it off to other people. All right, so all of this stuff that we learned.
00:13:29.238 - 00:13:55.810, Speaker A: We at three box labs basically incorporated into a protocol called Ceramic. And so Ceramic basically takes this proof of publication system and this merklized data structure and puts it into something we call Ceramic streams. And a stream is essentially just a crypto data object that's mutable and that's scalable because you don't need to verify the history of all other data objects.
00:13:55.810 - 00:14:18.934, Speaker A: So you get like this audible commit log of commits are either signed or anchored into a blockchain and based when you sync a stream, you basically verify all of the events that happen and you can process the latest date. And the access control is of course like cryptographically controlled. And we're using DIDs, which is short for decentralized Identifiers.
00:14:18.934 - 00:14:46.360, Speaker A: And this is like a W three C standard that's actually getting some adoption in various kind of crypto ecosystems. So the ad standard is nice because we can have Identifiers that are described on ethereum or polka dot or any type of blockchain and they can still be kind of interoperable. So with these streams we get mutable Identifiers, stream IDs that you can use and look up the latest state of an object.
00:14:46.360 - 00:15:18.682, Speaker A: And you can do this essentially because you only need to verify the history of one particular stream and not like the entire network of data. And so since we saw before that there was a bunch of protocols that took different approaches to mutable data, we figured that we needed like an abstraction layer to deal with different approaches to how you build these crypto data objects. And that's what we call stream types.
00:15:18.682 - 00:15:43.666, Speaker A: So it basically allows you to put custom state transition logic and also like custom conflict resolution logic in case there's like a conflict in the log. So for example, you might want to have a log that is allowed to branch and merge under some constraints. And just before I kind of jump into what we can build with this type of primitive, I want to talk about some future improvements for the Ceramic protocol.
00:15:43.666 - 00:16:10.110, Speaker A: So right now you need to run a ceramic node in order to trustlessly verify these crypto data objects are correct. And obviously that might be easy for some people, but for most users it's kind of very difficult to run an always online node. So we want to add a crypto economic incentive protocol that allows you to basically pay a set of validators to keep track of the state for you of your streams.
00:16:10.110 - 00:16:38.546, Speaker A: The other very important thing is privacy. And so by default, streams in Ceramic are public but it's easy to add confidentiality, basically just encrypting the updates that you add to the data structure. But the information that would still be public if you have confidentiality is the kind of linking of the list and the signatures by the user.
00:16:38.546 - 00:16:59.034, Speaker A: And in order to make this private, there are some approaches that's been taken already by textile, for example, they encrypt a layer on top of the linked data. But this essentially requires you to trust some third party that is allowed to decrypt that metadata information and keep track of the state. So we're not super happy with that because it's not fully trustless.
00:16:59.034 - 00:17:36.762, Speaker A: So we're looking into various ways of, like, maybe you can have a group of streams and then create a serial knowledge proof that this update was part of this group of streams, but without revealing exactly which stream is being updated. But that's still something we're kind of researching and looking into. All right, so I think what can we enable once we have this kind of tiny primitive for crypto data objects? What can we achieve and what can we build with this? And I kind of like to phrase this as the sovereign web, basically a piece of the Internet where we have as users, full control over the data that we create.
00:17:36.762 - 00:17:54.670, Speaker A: And that data can flow between different applications and between it's not locked into any jurisdiction or application. And we can also see how we relate to other people and how we've interacted with other people. So there's basically three aspects that I want to highlight.
00:17:54.670 - 00:18:15.090, Speaker A: Identity is built in. So in the Internet today, any data that you have, you have some data source that gives it, and like Facebook. And you can't really trust that the data that comes from their server is actually the post that your friend made is actually like a post that you made it's just like you trust Facebook.
00:18:15.090 - 00:18:37.902, Speaker A: That that's the case. But in the case of building on this crypto data primitives, we can verifiably know because the identity is built into the system and crypto data is borderless. And this essentially means not only like, nation state borders, but borders between boundaries, between organizations and companies.
00:18:37.902 - 00:18:58.980, Speaker A: We can actually start having this concept of open source data that's owned and controlled by whoever created it and kind of replicatable by anyone that cares about it. And the last thing is we can create a linked data graph. And so this is kind of like a concept that has been explored in the past.
00:18:58.980 - 00:19:12.090, Speaker A: There's been like, various groups. I think one of the most prominent ones is the Semantic Web group in W three C. And they basically had this vision of like, okay, right now we have the Internet that's like HTP pages that link to each other.
00:19:12.090 - 00:19:39.566, Speaker A: But what if we can not only use the HTP or sorry, the HTML pages that link to each other? The HTML pages are kind of the view layer of the internet. And what if we can actually link the data layer instead? So we have hyperlinks between the data objects. But I think one of the problems they ran into with that project is that hyperlinks using HTP points to servers that can go offline, they can disappear, they can get censored.
00:19:39.566 - 00:20:07.434, Speaker A: And so you can't really build solid structures on top of that and rely on things working well. And so the only places where this kind of worked is like larger organizations like Facebook and Google because they can essentially trust themselves to keep the data around. But the nice thing is, if you create these crypto data objects in ceramic and use stream IDs as links, you can link to whatever content you like.
00:20:07.434 - 00:20:20.670, Speaker A: I can link to a thing you created, but then back that up myself. So the data is not pointing to any location, it's pointing to actual data and the mutations on that data. So we can create a really solid structure for this kind of link data graphs.
00:20:20.670 - 00:20:54.394, Speaker A: And while this is possible to do in IPFS in IPFS, if I link to something, I link to a static thing, and there's no way if I want to link to your thing, I want to be able to link to the latest version of whatever you did not use, like a past version and then have no way of knowing about what the new thing is. So I'll jump into kind of some specific things that we're excited about people building. So we actually created a framework on top of ceramic for kind of identity data.
00:20:54.394 - 00:21:19.598, Speaker A: And this kind of builds on insights that we had from working with the Uport team and then working with the early kind of three box prototype. So IDX is a data structure or framework for storing data with the user. And essentially in this example here, users have their own index of their own data and then a developer can come in and create definitions.
00:21:19.598 - 00:21:42.940, Speaker A: And here in this example, a developer creates a basic profile and it has a schema that describes it's, a JSON schema that describes what the structure of the data needs to conform to. And so when user one and user two comes to the application at various times, they will have the same definition ID. So there's like a semantic mapping from what the data is, but they have their own record that describes what the content is.
00:21:42.940 - 00:22:20.070, Speaker A: And the nice thing about this is like if developer two comes along and says like, hey, this basic profile seems really useful, they can use that definition ID and pull that data into their application so you get this kind of composability of user centric data. Another interesting thing that you can build on ceramic is kind of managing data flows using NFTs. So a very simplest and crudeest example of what you can do is like, the creator of an NFT can have a stream and so they can mutate and update the artwork over time.
00:22:20.070 - 00:22:45.946, Speaker A: But I think more interestingly, I mentioned before that the cryptographic access control for ceramic streams is based on DIDs. And so we actually thought about this a lot and created an NFT Did method. So like an identity that's based on an NFT and that basically works by the current owner of the NFT is the one that's allowed to sign and decrypt things on behalf of that identity.
00:22:45.946 - 00:23:26.460, Speaker A: So you can imagine something like CryptoPunks, you have a forum where you can sign in with your CryptoPunk and basically author things on behalf of your punk and even send encrypted messages to other CryptoPunks. So I think that type of use case is really cool but I think more kind of long term and interesting things could be like say this NFT represents a physical art piece or like some kind of physical resource. I can create a ceramic stream that you put information about the current state of this piece of physical art and like okay, this has been reworked or something.
00:23:26.460 - 00:23:51.650, Speaker A: So you can keep not only the history of who owned it, but the history of what's happened to the thing over time. And the last thing I'm kind of really excited about is decentralized coordination. So we all kind of know about Dows and the way we kind of use smart contracts to do treasury management.
00:23:51.650 - 00:24:36.510, Speaker A: But Dows kind of have ended up doing okay on chain for the most important treasury management stuff and keeping track of all of their NFTs and tokens. But do every other coordination aspect off chain, and that often is stored on some centralized server where the owner of that server could potentially rewrite the history of who said what and really screw with the Dow if something goes wrong. But there are some tools that build really interesting things like Snapshot allows you to vote off chain coordinate allows you to assign kind of value and signal about who did what in work period.
00:24:36.510 - 00:25:14.526, Speaker A: Source Cred allows you to track kind of contributions on GitHub and forums into a token distribution mechanism. But all these kind of have this problem of things being manipulatable when they're off chain. And so you can actually take this type of system and remodel them on top of this kind of crypto data world where we have verifiability and I can verify the state of things without trusting a third party to not screw with the governance process.
00:25:14.526 - 00:25:58.410, Speaker A: And so Boardroom is actually an example that started doing this on top of ceramic already they have this feature for comments and ideations where you can ideate on some proposal and the things you post in there will actually be auditable and assignable to your Ethereum address and you can view that over time. Another nice thing about doing this is you might have a bunch of assets for a governance protocol that you keep in a hardware wallet but you might want to interact with a more kind of hot wallet when you're just writing comments and whatnot. So what I talked about before IDX allows you to link multiple Ethereum addresses to one did one identity.
00:25:58.410 - 00:26:38.402, Speaker A: So you can control not only the data of one address but the data of multiple addresses with one identity and then you can kind of have better OpSec for how you manage your keys for your valuable governance tokens. All right, so I hope you all kind of learned a bunch about crypto data and how you can use it and excited about to see what kind of stuff can be built on top of Ceramic. If you want to learn more, you can go to Ceramic Network or more easily go to Threeboxlabs.com.
00:26:38.402 - 00:26:59.500, Speaker A: And we have links to the Ceramic documentation and the IDX documentation. All right, thanks everyone. I think we might have some time for questions.
00:26:59.500 - 00:27:02.220, Speaker A: Yeah. All right.
00:27:04.590 - 00:27:08.560, Speaker B: What are you actually getting permissions to?
00:27:09.410 - 00:27:40.678, Speaker A: So right now, a stream in Ceramic only can have one controller, and that's a did. So you're actually just granting permission or that grants permission for the did to make updates and change the history. We have kind of lower level tools for encrypting data to DIDs, and so you can use them to put confidential updates into the stream, but we want to add a layer to make that much easier to deal with.
00:27:40.678 - 00:27:43.974, Speaker A: This kind of more privacy preserving encryption.
00:27:44.022 - 00:27:51.770, Speaker B: Stuff, access to the underlying data as opposed to the stream updates. How does that manage? How does it permission?
00:27:55.540 - 00:28:09.930, Speaker A: So right now, the data structure that's implemented in Ceramic is just like an append only log. And so it's just like a bunch of these commits that are signed and each commit contains JSON patch. And then we reduce that to a JSON object.
00:28:09.930 - 00:28:23.256, Speaker A: In the future, we want to use something more sophisticated like Hampt Hash rate map trees that allows you to have very large scalable kind of key value stores.
00:28:23.448 - 00:28:24.188, Speaker B: Thank you.
00:28:24.274 - 00:28:24.910, Speaker A: Yeah.
00:28:25.600 - 00:28:28.030, Speaker B: How fast do they access the data?
00:28:29.360 - 00:28:47.356, Speaker A: So it kind of depends. So right now in Ceramic, the longer the stream is, the longer it takes, of course, to verify everything. So if you access it through the peer to peer network, it might take some time, similar to how it takes time to verify the entire blockchain.
00:28:47.356 - 00:29:05.470, Speaker A: Of course it will be much faster since you're only dealing with one piece of data rather than like all data. But if you have a node that pins the stream, then accessing the data from that node is of course, very fast. Yeah.
00:29:05.470 - 00:29:35.970, Speaker A: So we're actually in the process of migrating profiles from threebox over to Ceramic and IDX. And so creating a new definition in IDX and adding the new properties that you want to have is the best way to extend the profile. And then you also have this kind of semantic descriptor object of what your properties that you add what they are.
00:29:35.970 - 00:29:57.778, Speaker A: Any last questions? All right, cool. Thanks, all. Yeah.
00:29:57.864 - 00:30:19.320, Speaker B: You control your process smart wallet or like podcast wallet? Yeah. In order to do that in an easy way, you need to kind of create a specific dad method for that wallet. We're actually working with Nosa Safe to do this for Safe, and we have a specific.
