00:00:09.490 - 00:00:12.226, Speaker A: Okay. Hi everyone. My name is Jannik.
00:00:12.226 - 00:00:27.970, Speaker A: Thank you all for coming despite it being very late and also very hot in this room. I'm here to talk about rolling shutter. It's a front running and mev protection mechanism rollout.
00:00:27.970 - 00:00:46.340, Speaker A: And I want to first start by talking a little bit about mev, what it is and if it's bad or not and we want to do with it and then talk about our solution to that. So what's mev? It's an abbreviation. It stands for minor or maximal extractable value.
00:00:46.340 - 00:01:09.160, Speaker A: And it basically means the profit that a block producer can make by optimizing how they build their blocks because they have some options there, they can choose which transactions to include and which notes to include, how to order them. And also they have to set some other parameters like that timestamp and the parent block. And this can influence and it does influence how much money they make.
00:01:09.160 - 00:01:21.082, Speaker A: And yeah, one more thing about the block producer. It's called minor or it used to be called Miner Extractable Value. But in different protocols, this entity has a different name.
00:01:21.082 - 00:01:36.814, Speaker A: So in proof of stake blockchains, it's usually the validator in roll ups, it's a sequencer, but it's basically all the same. It applies to all these protocols. Examples for these are, for example, arbitrage.
00:01:36.814 - 00:01:52.226, Speaker A: These are the most common ones. Arbitrage means you have two exchanges, two DEXes. They trade the same token but with different prices, which means you can buy on the one where the token is cheap and sell at the one where it's expensive and make a risk free profit.
00:01:52.226 - 00:02:04.950, Speaker A: Anyone can do that. But the block producer is basically first in line. They get the prime spot and that's why it's a form of mev.
00:02:04.950 - 00:02:23.680, Speaker A: Another example is liquidations. Liquidations are kind of bounties that are paid by DeFi protocols in order to make that protocol work. So once a condition is met, anyone can call a function and basically they get paid for it.
00:02:23.680 - 00:02:34.446, Speaker A: And again, anyone can call this, but the block producer is first. So again, a form of Mev next sandwiching. Now it gets a little bit more complicated.
00:02:34.446 - 00:02:59.770, Speaker A: We have a user transaction and for example, this transaction sells a token, which means it influences the price of the token. The miner now gets that transaction and they see there is the sale transaction. So what they can do is they can sell the transaction before the user transaction and buy it afterwards and basically do arbitrage based on the price change introduced by this transaction.
00:02:59.770 - 00:03:06.010, Speaker A: Yeah, that's sandwiching. And lastly, censorship. That's very easy.
00:03:06.010 - 00:03:25.860, Speaker A: The block producer simply ignores a transaction because, for example, they get paid by another entity. So now the question is, is this good? Is it bad? And it turns out this is actually a pretty difficult question to answer and to come up with a clear solution to that. But I think for these four examples, it's very simple.
00:03:25.860 - 00:03:42.086, Speaker A: Arbitrage and liquidations I think are generally considered good by most people because they are tools that protocols use. So without arbitrage, without liquidations, many default protocols, including decentralized exchanges, wouldn't work. So we want to have these protocols.
00:03:42.086 - 00:03:59.342, Speaker A: So mev is here useful, we want to have it sandwiching. And censorship on the other hand, are clearly bad. So censorship is pretty obvious and sandwiching is bad because the user who wants to trade something, they get a worse price.
00:03:59.342 - 00:04:21.800, Speaker A: So it basically reduces utility for the users of the protocol. So this we don't want. What our solution aims to do now is we want to fight these types of Mev that are clearly Bad, like censorship and sandwiching, but we still want to allow for arbitration liquidation to happen.
00:04:21.800 - 00:04:58.590, Speaker A: And we want these type mev to be extracted and we want to also have these types of mev extracted in an efficient manner because there are some mev protection mechanisms that make these kinds of mev extraction inefficient and that's bad for everyone because it will be extracted. But for example, simply gas prices get higher, block space is used less efficiently. So our solution in theory can be applied everywhere in most protocols that have some sort of block production mechanism.
00:04:58.590 - 00:05:19.750, Speaker A: But we do focus on roll ups and the reason for that is that there's many reasons. The first one is that we think the majority of mev will be on roll ups in the future simply because the majority of users will be on roll ups. Another reason is that roll up protocols are still new and relatively easy to modify.
00:05:19.750 - 00:05:54.050, Speaker A: So the protocols are not fixed yet, all the roll up teams are still implementing them, whereas layer one protocols, they are already established and they are much more conservative with changes they want to introduce. So therefore it's much easier for us to talk, to, roll up, implementers and try to convince them to work with us. And lastly, most roll ups have a single sequencer which makes our protocol much easier to implement, as we will see later.
00:05:54.050 - 00:06:19.690, Speaker A: So therefore, what we decided to do is build this rolling shutter or mechanism that I will describe in a second and we build it as kind of a plugin that can be integrated into almost any roll up. So how does it work? Basically we allow users to encrypt their transactions, then they send the encrypted transactions to the sequencer. The sequencer will select them, order them and put them into a batch.
00:06:19.690 - 00:06:38.878, Speaker A: And only once they have been included in a batch, then they will be decrypted and executed. Now, this still means that the sequence has a lot of power, the block producer has a lot of power, they still can order however they like, they can still ignore transactions, but they don't have a lot of insight into these transactions. They don't know what they do because they're encrypted.
00:06:38.878 - 00:06:57.558, Speaker A: So they can front run, they can censor, but they can't do so effectively. So in the end, they won't do it. But these other kinds of MV, like Arbitrage and liquidations, that's still perfectly accessible because they can still order however they like.
00:06:57.558 - 00:07:14.350, Speaker A: And that's like a little image that illustrates how it will work. We produce a batch, after the batch is there, we produce the key, then the next batch, then the next key, and so on. And whenever we have a key, we can execute, that's the general principle.
00:07:14.350 - 00:07:28.050, Speaker A: The naive way to do that would be to allow the users to choose the key to encrypt and then ask them later to reveal the key. Unfortunately, that's not a good idea for two reasons. First of all, it's pretty bad.
00:07:28.050 - 00:07:44.166, Speaker A: UX users, if they want to only send one transaction, they have to send two. They have to first encrypt and then later have to provide the decryption key. And even more difficult or more dangerous, they have the option to not reveal the key.
00:07:44.166 - 00:07:54.570, Speaker A: And this gives them basically a free option. And that makes it very difficult for many protocols to live on a blockchain like this. So we don't want to deal with that.
00:07:54.570 - 00:08:08.030, Speaker A: Therefore, our solution here is to have a committee. So this committee, we call it the keepers, their job is to provide encryption keys and decryption keys. So they first provide the encryption key, give it to everyone.
00:08:08.030 - 00:08:31.160, Speaker A: Users can now encrypt their transactions. And later, once they see that the block producers produce their block, only then they will provide the decryption key. And this solves this free option problem, because the user is not involved anymore for the decryption and they can't choose to not reveal, but they also don't have to do it themselves.
00:08:31.160 - 00:08:43.498, Speaker A: It's a committee. We could use a single entity that would be pretty bad because we would have to trust them to do their job properly for this committee. We only have to assume that a threshold of them are honest and online.
00:08:43.498 - 00:08:55.274, Speaker A: So, for example, two thirds of them could be 200 nodes. So I think this is a good security assumption that's justified. They run a DKG protocol.
00:08:55.274 - 00:09:13.250, Speaker A: The problem with DKG protocols, they're pretty well established, but the problem is they usually have a quadratic overhead. So all these members have to talk to each other to produce a key. And that's very inefficient, especially if you want to have more keepers.
00:09:13.250 - 00:09:31.914, Speaker A: And we want to produce these keys very frequently, right? We want to produce batches like every five to 10 seconds so that people don't have to wait for so long for their transactions to be decrypted and executed. So this is used a lot, this communication. So we try to avoid that as much as possible.
00:09:31.914 - 00:09:52.298, Speaker A: So the solution we came up with, together with some researchers from a university, we split this up, we split this up in a quadratic setup phase. Produce kind of a round or kind of a master key, or we call it the eon key. And then for each batch we only need linear rounds.
00:09:52.298 - 00:10:05.300, Speaker A: So for each of these rounds, each keeper only has to send a single message. So this is now maximally efficient and makes our protocol work with lots of keepers. So very secure system.
00:10:05.300 - 00:10:41.390, Speaker A: The transactions, they pretty much look like normal Ethereum transactions. They have a receiver, a call data, like the function they want to call a gas limit, gas price, a non, a signature and ideally we would encrypt everything. But unfortunately that's not easy to do because the block producer who who selects these transactions, they need to know that they will be paid, so they will need to know that they will get a transaction fee from the users.
00:10:41.390 - 00:11:13.254, Speaker A: But if everything is encrypted, they can't really verify that there's actually a sender that has money. So what we do instead is we have a plain text envelope so all the fields that are related to gas payments are public but the important fields like what the transaction does and who is called and who sends money to whom, all of this is encrypted. Now the sequencing step, as I said earlier, we call that there's still a broad producer that orders and can order however they like.
00:11:13.254 - 00:11:41.554, Speaker A: We call this entity that does it, the Collater. But it will be basically the same as the sequencer, just a different name because it's two different pieces of software and their job is to produce these batches, commit to them, including of course the ordered list of transactions. But in addition to that, they also commit on the block number and the timestamp, all this context under which a transaction is executed because this can also be in theory can be used to front run.
00:11:41.554 - 00:11:58.546, Speaker A: So they also finalize that before transactions are decrypted and eventually these transactions are then passed to the sequencer. Here's how the architecture of the system looks like. As I said, we want to build a plugin that can be integrated into roll ups.
00:11:58.546 - 00:12:21.802, Speaker A: So what we build here is on the left we build the keepers and the Collater. It's two pieces of software. But then rollers already have software for the sequencer and they usually have like a state transition logic and the only changes that they now have to make to integrate with us is they have to provide an interface with which our Collater can talk to the sequencer.
00:12:21.802 - 00:12:30.818, Speaker A: That's pretty simple. And they have to adjust their state transition logic to execute our encrypted batches. Also not a big change.
00:12:30.818 - 00:12:57.994, Speaker A: So in theory also in practice, this should not be too difficult and all the complexity is basically covered in the left part in the software that we provide there are things that can go wrong. Of course some of them are cryptographically provable, some of them not. But we should apparently I don't have too much time anymore so maybe we can talk if you're interested in that.
00:12:57.994 - 00:13:03.340, Speaker A: It's already pretty detailed. We can know about this later. Maybe you can ask a question about it.
00:13:03.340 - 00:13:24.418, Speaker A: But there's one more thing I want to mention because that's pretty cool. This threshold technology that we use, it can also be used for other stuff. And one thing we work on with snapshot together is we're trying to use it to make voting more secure, more fair.
00:13:24.418 - 00:13:46.490, Speaker A: So usually in votes, in Dao votes, you all the time see what votes are sent, and the people who vote last have more information than the people who vote early. And we can prevent this using shutter by encrypting votes and only reveal them when the vote is over. So that's pretty cool and excited to see this pretty soon, hopefully.
00:13:46.490 - 00:13:52.960, Speaker A: Yeah, that's all from me. Do you have questions?
00:14:01.860 - 00:14:12.336, Speaker B: Yeah, I have a question on the last slide. Is it automatic that you have to reveal what it was after the vote is over, or can you keep them forever? Encrypted?
00:14:12.528 - 00:14:31.492, Speaker A: So the people who have to reveal are these keepers that I mentioned earlier. So it's a committee, it's not the users, not the people who vote, also not the project or whatever. Who does the vote? It's the keepers, and only a subset of them is necessary.
00:14:31.492 - 00:14:39.608, Speaker A: So only like two thirds of them are necessary. So we think that it's in practice not possible to stop a vote from being rebuilt.
00:14:39.704 - 00:14:50.800, Speaker B: Okay, so it can't be like you can't say what the results of the votes were without knowing how much each person voted.
00:14:52.980 - 00:14:58.370, Speaker A: No, you can't decrypt and then you can't hide it.
00:15:03.910 - 00:15:15.570, Speaker C: Thank you. You mentioned something about the keepers sharing the keys among them. Doesn't it mean that if there's one row keeper, then the keys are compromised?
00:15:17.430 - 00:15:43.550, Speaker A: No, because we have this threshold assumption only, we only need two effects of the keeper. So as long as certain number, as long as these are honest, they can reconstruct the shared secret, similar to secret sharing, where you don't need information from every member, but if some are offline, you can just ignore them and use the information that others have to reconstruct the secret.
00:15:48.290 - 00:15:52.414, Speaker B: Okay. No questions, no more. Thank you.
00:15:52.414 - 00:15:54.060, Speaker B: Thanks. Thank.
