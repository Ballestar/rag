00:00:06.010 - 00:00:07.920, Speaker A: Cool. Hello. Welcome everyone.
00:00:07.920 - 00:00:18.400, Speaker A: My name is Felix Lorpold. I'm here giving the talk that actually my colleague Nick was supposed to give. So apologies if it's not as smooth or rounded as he would have given it.
00:00:18.400 - 00:00:46.118, Speaker A: And in particular, we are going to talk today about, ERC or EIP 1271 and how we can leverage the smart contract order signature concept for building all kinds of really cool use cases on cow protocol. I hope you guys are roughly familiar with Cow Protocol. We are a MetaDex aggregator where users place orders just by signing off chain messages.
00:00:46.118 - 00:01:08.814, Speaker A: And then those off chain messages get batched together and sent off to a network of solvers that compete for that order flow and try. To find the best possible solution for the user orders, matching them together in what we call coincidence of wants whereas the name Cow protocol comes from and protecting users from mev and giving a significantly better user experience. But that's kind of the background.
00:01:08.814 - 00:01:28.258, Speaker A: Happy to talk also at the booth over the advantages of cow swap. In particular today, this talk will cover really ERC 1271 smart contract signatures. And we'll first cover a little bit the basics how cow protocol orders work usually and why this doesn't really work for smart contracts.
00:01:28.258 - 00:01:52.794, Speaker A: We'll then talk about the easy case of smart contracts that just want to place trades on cowswap and then go one step further where we explore this concept of smart orders. So even more than just placing a boring old limit order, smart contracts can actually place really cool and advanced concepts. And there is a little demo at the end and there's some code in the GitHub repository if you're willing to hack.
00:01:52.794 - 00:02:06.594, Speaker A: We have a $5,000 bounty on the best integration of a smart contract order into cow protocol for this hackathon. So might be worth your time to check out this repo at the end and start hacking. So let's begin with the basics.
00:02:06.594 - 00:02:20.146, Speaker A: How do orders in Cow protocol work? Here you can see the general struct that describes an order. It's really like what you would expect when you're making a trade. You have to specify a sell token, a buy token.
00:02:20.146 - 00:02:26.426, Speaker A: You can send the proceeds to some other receiver. You have a sell amount and a buy amount. That's basically your limit price.
00:02:26.426 - 00:02:34.938, Speaker A: You have an expiry date, you have a fee. It can be a sell or a buy token. So you have a bunch of fields that represent an order on cow protocol.
00:02:34.938 - 00:03:08.194, Speaker A: And then the way that it normally works with externally owned accounts with your MetaMask is that the order that you are willing to sign gets hashed according to the EIP. I think 712 is the EIP gets hashed into a typed order hash. And then you, with your externally owned account, can go ahead and consign this commitment to the order that you're willing to place.
00:03:08.194 - 00:03:30.542, Speaker A: And the way that signatures work with externally owned accounts is by using some fancy math elliptical curve cryptography. You don't have to really understand it in detail, but basically you're taking two points on the curve and then have your private and your public key. And with your private key, you can basically prove that you're in possession of that private key without revealing it.
00:03:30.542 - 00:03:51.078, Speaker A: And what ends up being generated is this triple RSV. It also doesn't really matter what this specifically means, just there is a way of how externally owned accounts can use their private key to attest that they are actually willing to make this trade. Now, the problem is that smart contracts cannot do that because smart contracts on Ethereum don't have a private key.
00:03:51.078 - 00:04:00.170, Speaker A: So they cannot do any ECDSA. They cannot sign an order given elliptic curve signatures. So another signature scheme is needed.
00:04:00.170 - 00:04:15.038, Speaker A: And that's why the Ethereum community has created what is known as EIP 1271. I think Nick is really strict on that. It's technically an ERC and not an EIP because it doesn't need any protocol changes.
00:04:15.038 - 00:04:43.510, Speaker A: But the basic way that smart contracts can prove that they are okay with something happening, the way that they prove that they are validating a signature is by just implementing this very simple method is valid signature. And that method takes a bytes 32 hash. This is basically the order hash we saw on slide three or four and then an arbitrary byte array of what can be interpreted as a signature.
00:04:43.510 - 00:05:07.918, Speaker A: And that byte array can really be anything. It can be some EOA signature that maybe is the owner of the smart contract or maybe a delegate of the smart contract that is signing the hash on the smart contract's behalf. It could be just more information that the smart contract needs to then maybe check an oracle or check some other state to decide if it's actually willing to accept the hash that is being passed into.
00:05:07.918 - 00:05:24.674, Speaker A: But basically what you can think of this off is a boolean response. Am I okay with this hash or am I not okay with this hash? Now, the return type is not boolean. It's some magic bytes four value which has some detailed history of why it's not just a boolean, but you can think of it.
00:05:24.674 - 00:05:49.770, Speaker A: It's a method that says yes or no. Given a hash. Is the smart contract okay executing this signature? And so, yeah, basically if we go back to the order struct, we again take our concrete order that we want to sign, we compute the hash, and then the thing that gets passed into our smart contract is we basically invoke signer is valid signature with that hash and whatever we decide to pass in as a signature.
00:05:49.770 - 00:06:17.826, Speaker A: And so how do smart contract wallets implement this? So, for example, Argent or Nosisafe, pick your favorite smart contract wallet. They don't have private keys, so they also need to implement ERC 1271. And the implementation can be specific to each individual wallet some wallets might use a might require the user to first send a transaction that says I am attesting that this hash is okay.
00:06:17.826 - 00:06:40.218, Speaker A: So you might think of it as like a bitmap that for each hash you have a is signed or is not signed and then is valid signatures just checks for the hash if the bit is set to yes. You could also just blindly trust signatures from certain domains. So you could say if a certain, I guess member of an ENS community or whatever has signed this, then I'm okay with it.
00:06:40.218 - 00:06:55.534, Speaker A: Or the way that the nose is safe. And I also think Arjun does it is you could because Smart contracts usually have an owner, they have multiple signers. You could just use those signers as delegates and verify the signatures by just checking.
00:06:55.534 - 00:07:12.258, Speaker A: Have enough signers, have enough EOAS that own the Smart contract wallet signed for the hash. And this is, for example, how the Nosisafe does it so concretely because Nosasafe is also a project very close to our hearts. We care a lot about having Kelswap work nicely with Nosasafe.
00:07:12.258 - 00:07:48.558, Speaker A: The way that the signature verification on their end works is, again, you have this order Struct that gets compressed into a hash that you need to sign. And then the safe interface has like a certain again named Struct for its signatures, where then each owner can basically use their externally owned account to create a good old 712 like a good old EOA signature, a good old Ecdsh signature. And then what the safe does, it basically waits for enough owners to have created their own individual signatures.
00:07:48.558 - 00:08:08.230, Speaker A: So, if you have a three out of five safe, for example, you need to collect signatures from at least three owners. You concatenate all those three signatures together and then the safe will say is valid signature true? If enough signers have signed for that hash. So this is again just a recap of how it works for the safe.
00:08:08.230 - 00:08:21.862, Speaker A: You collect all the signatures, you encode them into bytes, you concatenate them together. Inside is valid signature, it just deconcate them and then checks for each signature. Are you an owner? If so, increment the count of owners that have signed.
00:08:21.862 - 00:08:39.410, Speaker A: And if at the end the number of signatures that have been signed by owners is greater than the threshold is valid signature returns true. And this works in cowswap. Nick implemented a little script that you can use to actually place these gasless orders from your Nosusafe already today.
00:08:39.410 - 00:08:53.560, Speaker A: Here's a proof on gurley that this works. So you can actually use Nosisafe today to place gasless or without having to pay gas orders into cowswap. And that's already quite cool.
00:08:53.560 - 00:09:11.722, Speaker A: That's a very good use case of ERC 1271. But there's even a sorry, yeah, go ahead. So it's gasless because you can use your EOA to just sign the message and hand that message off to cowswap and then cowswap will pay for the gas.
00:09:11.722 - 00:09:37.090, Speaker A: Basically you're just transferring the hat. So you basically sign with your EOA that you want your smart contract, your signosisafe to trade one Ether for $1,300. And then you send this message off chain to our API, and our API will then send it to the solvers and the solvers will take it and settle it on chain and they will still take some fee from your sell amount.
00:09:37.090 - 00:09:52.070, Speaker A: So it's not that you can trade on cowswap and don't pay anything, right? Like you will still pay whatever the gas would be in ETH, but in US dollars from your sell amount. It just means your EOA doesn't need to have any ETH in it. You can just use the signature.
00:09:52.070 - 00:10:22.850, Speaker A: You don't need to fund your EA. Okay, so this is already pretty cool to use your safe with a gasless manner to do trades, but then the real power comes when we I don't know how Nick planned to have this climax, but in the beginning you had dex, then you had dex aggregators, then you had cowswap as the MetaDex aggregators. And today we're going to introduce smart orders, the next paradigm in this crazy climax.
00:10:22.850 - 00:10:40.946, Speaker A: Okay, so the idea of smart orders is that you implement ERC 1271, similar how you just saw that the safe does it, but you can do it with arbitrary logic. You don't actually have to check that there is some signer that has signed for it using an EOA. You can theoretically use arbitrary logic.
00:10:40.946 - 00:11:09.650, Speaker A: You can check an oracle that you want to investigate that basically you're always okay to trade if the price is better than what chainlink reports or some other logic that is completely independent of any actual EOA signature. And so the way that these smart orders usually work is you create a smart contract, you deposit some tokens into it and then that smart contract implements this is valid signature method in some way or the other. So yeah, you have custom on chain logic and that's it.
00:11:09.650 - 00:11:24.902, Speaker A: And so one example that we're going to go through today in this workshop is a good after time order. Good after time orders only become valid after a certain timestamp. So you can basically place an order today that becomes valid tomorrow, and you could place the second one today that becomes valid the day after.
00:11:24.902 - 00:11:44.426, Speaker A: And so you could use good after time orders to implement something like a daily cost average strategy, for example. And right now in the very native cow protocol order format, this is not supported. We have an expiry date valid to, but we don't have a field valid from and so it would require to change the native cow order format.
00:11:44.426 - 00:12:01.246, Speaker A: It would require to update the contracts. And so it's very painful to add this to cow protocol in its current form, but you can just write a smart contract order that basically implements this behavior. And the way you would do that is you just implement is valid signature in a way that it checks what is the current block timestamp.
00:12:01.246 - 00:12:26.010, Speaker A: And when that block timestamp is past a certain target block, you say is valid signature true? And if it's not, you say no, it's not yet valid. And so you can place this order into the order book. The order book will constantly try to check is this order now valid or not? And once it becomes valid, it will automatically take it into the current batch and ship it to the solvers and it will get matched automatically.
00:12:26.010 - 00:12:41.262, Speaker A: So let's walk over the code. We'll also see it in real life in a minute, but let's just walk over the code that's required here. So this is like the construct for a good after time order, but at this point it doesn't do much.
00:12:41.262 - 00:12:55.794, Speaker A: At this point it just takes in the constructor an order hash that you want to be executing. And then if is valid signature just checks that. Whatever the settlement contract is trying to execute is actually the thing that we have pre signed here.
00:12:55.794 - 00:13:07.686, Speaker A: So this is not yet doing good after time. This is just the very basic format. You basically say here is an order hash that I'm okay executing and then as valid signature just checks that we are indeed executing that.
00:13:07.686 - 00:13:22.958, Speaker A: So now let's add cancellation. Because with good after time, you also don't know, maybe the price changes a lot from today to tomorrow and your order might no longer be satisfying its limit price. So you might need a way to actually cancel this order and get your funds back out.
00:13:22.958 - 00:13:48.934, Speaker A: So here's just some random scaffolding or some small scaffolding to allow the owner of that contract to regain the tokens that they have deposited into it. And then this is actually the part that adds the good after time into the smart contract. So we add this valid from field, we set it in the constructor saying that this order is only valid after a certain maturity date.
00:13:48.934 - 00:14:02.040, Speaker A: And then in the is valid from implementation, we just check that block timestamp is past valid from. If that's not the case, we revert. And if it's the case, we set this magic value, which basically means we return true.
00:14:02.040 - 00:14:31.362, Speaker A: The other thing we need to remember is that the smart contract needs to have the the Cow Protocol settlement contract approved. So the way that Cow Protocol works is it needs an approval from whoever is authoring the trade so that it can actually take the sell tokens from the author of the trade and then send it back the buy tokens. So we need to set an approval and then we're good to go.
00:14:31.362 - 00:14:39.270, Speaker A: This is the entire code. I think it's like 30 or 35 lines of smart contract code. And you have a good after time order implemented.
00:14:39.270 - 00:15:03.754, Speaker A: The one thing that we added here is a factory. Because right now every user that wants to implement a good after time order needs to deploy their own instance of that order. And so Nick also built a small factory contract that anyone can now call with basically a raw order struct and some salt just to make it not replayable.
00:15:03.754 - 00:15:31.206, Speaker A: And then that factory contract will actually deploy the actual good after time contract and also do the transfer of the in amounts and basically return the order ID that has been created. Not super important. You don't have to implement this if you want to use smart orders you could just deploy every order again and again and maybe some orders don't need to be deployed if you're looking into building an AMM or so, you just need to deploy it once.
00:15:31.206 - 00:15:44.970, Speaker A: But if you have something that every user would have to redeploy, maybe a factory contract makes sense. All the code is in this GitHub repo. We don't have to really go through it in depth but yeah, so this is then the general flow.
00:15:44.970 - 00:16:04.130, Speaker A: The trader would approve the good after time factory contract call the place function which then does all the magic. Basically creates this good after time order instance, transfers all the tokens in, sets the valid from parameter and the order is ready. Then we just have to wait for the timestamp to be reached.
00:16:04.130 - 00:16:24.214, Speaker A: So this okay yeah, this is then the last step that is needed right now. Our back end doesn't automatically identify when an order is placed on chain so you also have to tell our back end separately. Hey, there exists an order.
00:16:24.214 - 00:16:36.954, Speaker A: Please start tracking this order and please start checking. Once this order become valid, start settling it. We are working towards making this step obsolete and just having an event emitted inside the smart contract that our backend can automatically pick up.
00:16:36.954 - 00:16:55.170, Speaker A: But right now you still need to call our API. Here's how it will hopefully very soon look like you don't have to call our API anymore. Then you just emit an event and our backend will automatically pick up that there's a new order in the system that needs to be tracked.
00:16:55.170 - 00:17:07.730, Speaker A: Okay, I think this is maybe now good for a demo. Yeah, this should be demo time now. So we have the repository here.
00:17:07.730 - 00:17:32.762, Speaker A: I had to clone it just because it was made for Rinkabee and Rinkabee doesn't work anymore so now it's made for girly. So if you check out my GitHub and check for the Depcon 2022 smart orders repo, there is README with the four steps you have to run. But basically what we are going to run is the place order script which does exactly what we discussed.
00:17:32.762 - 00:17:55.810, Speaker A: So in this repo you will find the good after time in the contracts repository here you'll find the good after time orders which has all the smart contract code that we showed. I'm happy to talk about the details of that also at the booth, if you have specific questions. And then what we're going to do right now is we're going to place one of these orders.
00:17:55.810 - 00:18:22.540, Speaker A: We're going to sell wet and we're going to buy cow on Gurley and we're going to set the field valid from to be starting now plus two minutes. So basically when we place this order, it won't be valid, but two minutes later it will become valid. Can I customize? Yeah, you can fork from it.
00:18:22.540 - 00:18:28.458, Speaker A: You can start from scratch. This is just one example. I have a few more examples on the last slide.
00:18:28.458 - 00:18:38.930, Speaker A: But basically and we can also use the remaining time to brainstorm some ideas. I really think there's like an endless amount of design space that you can do with this. Anything that's basically expressible in solidity.
00:18:38.930 - 00:19:05.420, Speaker A: Okay, so we're going to place an order using some old account that I have that is going to create an instance of this good after time order. And then the script is going to print out the order ID of the good after time order so we can track it in our Cow Explorer. Okay, so this is the order and we should check the time 153.
00:19:05.420 - 00:19:24.266, Speaker A: So in here we can check the order. It's open, but it won't match right away because it's not yet valid. In fact, we can actually check our API and we can see that right now the auction is empty.
00:19:24.266 - 00:19:42.470, Speaker A: So that there's right now no orders that are allowed to be settled. And this is because Is Valid signature returns reverts in the current state because the block time hasn't advanced far enough yet. And so now we need to kill a minute and a half of time to see this become valid.
00:19:42.470 - 00:20:09.022, Speaker A: Yeah. So the back end basically has a set of orders that attracts and it just checks. Are these orders valid? Like, do the order creators have enough balance? Have they given allowance? In this smart contract order case, is the Is Valid signature, does it return? True? And so it builds periodically.
00:20:09.022 - 00:20:35.450, Speaker A: Every 15 seconds, it builds an auction with all the valid orders that are currently in the system and sends it off to this network of solvers who would then go ahead and try to settle the current batch and the solvers return back kind of their proposal of how they would settle the batch. And then the backend decides basically measures what is the best solution in terms of price improvement for the user. And the one that had the biggest price improvement gets the right to then execute that settlement on chain.
00:20:35.450 - 00:20:47.054, Speaker A: And so let's start looking at the API. In a few seconds we should start seeing the order here because it will have become there it is. So this is our order.
00:20:47.054 - 00:21:15.446, Speaker A: It's now valid so solvers can start trying to figure out how to settle it and then hopefully this will turn into a filled very soon suspense. Whoo. 15 seconds.
00:21:15.446 - 00:21:26.506, Speaker A: Never felt so long no. Yeah, it hasn't filled. This ERC is five years old.
00:21:26.506 - 00:21:38.254, Speaker A: It just got finalized last this year or so. It had some minor changes, really annoying minor changes, which made it not backwards compatible, but still didn't change fundamentally. But it got finalized this year.
00:21:38.254 - 00:21:51.110, Speaker A: So we're now pretty certain that this is going to last for the future. And yeah, so basically here now, we can see the order got filled, we got a nice surplus. This is like how normal cowswap orders would work.
00:21:51.110 - 00:22:04.138, Speaker A: But yeah, basically you had this logic that made it good after time. Here's some other cool ideas. And just like just the tip of the iceberg of what we could implement with it.
00:22:04.138 - 00:22:23.418, Speaker A: Stop loss orders is one other example. So stop loss orders means you're not buying when a certain minimum price or sorry, you're not buying, you're not buying. So well, no, but you can always place it.
00:22:23.418 - 00:22:33.374, Speaker A: Basically, normally you're selling ETH when the price goes up, right? You're saying, I want to sell Ether when it's like at 1500. That's a normal limit sell order. A stop loss order would be, I want to exit my ETH position.
00:22:33.374 - 00:22:51.398, Speaker A: I want to sell ETH if it goes below 1000 because then I think we're all doomed and we go to zero. So stop loss orders allows you to basically take the other side of like, cut your losses and exit if you feel like, oh, now we're about to go to zero. And so you could use an on chain, Oracle, say chainlink or something, to check what is the current price.
00:22:51.398 - 00:23:17.760, Speaker A: Of course, some trust in that price Oracle needs to be considered in the design and then decide, I say is valid signature? Yes, if the price is below that. And then I'm basically trying to exit my position and cut my losses. Advanced good after time use cases would be this daily cost average or time weighted average pricing, where you basically allow, for example, a Dow to sell or buy tokens little by little over the course of a month.
00:23:17.760 - 00:23:35.542, Speaker A: But you can also think of other cool ideas. You could, for example, implement an AMM in a smart contract order, where the smart contract has two balances, two tokens and then a constant. And you just allow trades as long as X times Y is still larger or equal to K.
00:23:35.542 - 00:24:02.350, Speaker A: And this way you've built an AMM into cowswap, which gets settled at the same uniform clearing prices as all the other users. So you would have built an AMM that can actually capture surplus from trades, unlike uniswap, where basically you get settled exactly on your X times Y equals K curve. In cowswap, you would have AMMS that can actually capture price improvement and capture surplus.
00:24:02.350 - 00:24:30.840, Speaker A: But yeah, basically most of these smart contracts don't require any special integration. If the thing that you are expressing becomes a little bit too complex, you might also have to talk to one of those solvers so that they can actually understand what do I have to do in order to activate the smart contract order? But for the vast majority of use cases you don't even need that. You basically just have this on chain contract that follows ERC 1271 and it will just work out of the box.
00:24:30.840 - 00:24:52.270, Speaker A: So this is kind of the wrap up of the talk. I will go to the references. The first thing that we talked about of how to place gasless orders using Nosisafe is in the safe cow order repo from Nick and then the adjusted smart good after time order prototype is in my GitHub repository.
00:24:52.270 - 00:25:03.600, Speaker A: And yeah, if you have any more questions as well, let's talk at the booth. And I think we have maybe a few minutes for questions. Yeah, maybe like I don't know, one or two questions if you have anything at the top of your head.
00:25:03.600 - 00:25:40.406, Speaker A: But yeah, I mean Cowswap's main value proposition is that it protects you from mev. So basically a keeper you have to pay the keeper some fee that it basically takes your order and then it might take it still at your limit price. You're not guaranteed in the keeper system necessarily that you're getting price improvement.
00:25:40.406 - 00:26:02.358, Speaker A: Whereas on Cowswap you have everyone that is in the batch gets the same uniform clearing price and by virtue of having the solver competition and the more price improvements a solver give to you the more likely it is that they win. You have this guarantee that there's actually somebody fighting for you getting the best price. But basically there's other concepts as well.
00:26:02.358 - 00:26:20.086, Speaker A: We personally think that or we as a company think that cowswap is a very good way for DAOs to easily of course, somebody has to write this dow DCA order, but then it can be reused by many dows over and over again. And the dao can just say, okay, we want to build a position over the next month. Let's do it automatically.
00:26:20.086 - 00:26:33.742, Speaker A: Whereas right now you have to build this. I looked at Buntec did a very nice example of such a keeper contract but you basically have to customize it for your company. You then have to find some flashboards miner or some searcher to actually execute it for you.
00:26:33.742 - 00:26:52.670, Speaker A: So I think there's some user experience benefits and then also this idea of benefiting from other retail traders that might take the other side. So basically if you were urine and you wanted to do a buyback of YFI tokens you shouldn't be doing necessarily the buyback against uniswap. You can just absorb sell pressure.
00:26:52.670 - 00:27:07.314, Speaker A: Whenever a user wants to sell a YFI, why don't you just buy it as a solver? So these are some of the ideas. Cool. We are on the upper floor in the corner on the left.
00:27:07.314 - 00:27:31.500, Speaker A: We'll have people on the booth most of the time and happy to also help people that are interested in hacking this. We have again two bounties. $5,000 for the best smart order or smart contract order integration, and then another $5,000 for the best UI integration built on cowswap can be combined, of course, if you build a really nice smart contract order with a UI, then, of course, you can also have both Bounties, which are $5,000 each.
00:27:31.500 - 00:27:35.960, Speaker A: And yeah, happy hacking and hope to see you around. Thank you.
