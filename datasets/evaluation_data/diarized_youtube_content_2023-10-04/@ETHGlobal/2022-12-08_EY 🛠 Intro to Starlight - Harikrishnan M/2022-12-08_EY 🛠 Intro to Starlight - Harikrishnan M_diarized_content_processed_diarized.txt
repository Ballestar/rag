00:00:06.330 - 00:00:10.862, Speaker A: Hi. Good afternoon. I am Hari from EY Blockchain Research and Development Team.
00:00:10.862 - 00:00:34.440, Speaker A: Today I'm going to be talking about Starlight, one of our R D products. It's a ZK compiler which allows solidary developers to generate privacy preserving applications without knowing much about ZKP or much what cryptography go behind the scenes. Before I get started, I want to just quickly explain what evidence and what evidence in blockchain space, basically.
00:00:34.440 - 00:00:50.330, Speaker A: So we have been building a lot of blockchain products over the past few years, and we are fully focused and open and vocal about our support for public blockchains. And everything we build is on public blockchain. And not just any public blockchain, but specifically on Ethereum.
00:00:50.330 - 00:01:18.550, Speaker A: Global blockchain leader Paul Brody has recently taken a chair seat at Ethereum Foundation. So that kind of shows the collaboration and commitment we have with Ethereum Foundation, ethereum ecosystem. Now, if you work in a firm like Know, many people ask me, know, what does Evi have to do with a public blockchain? And a lot of our clients are banks and accounting firms and enterprises who doesn't want to put their data into public blockchain.
00:01:18.550 - 00:01:33.670, Speaker A: And very rarely that we get a use case. Like, for example, you could have an ESG use case where somebody wants just one enterprise, want to create a carbon offset, and they just want to create some NFT tokens and put it in the blockchain. And that's fine for them because they don't want privacy.
00:01:33.670 - 00:01:51.306, Speaker A: But more often than not, privacy is a very important factor for enterprises to use public blockchain. So most of the work that we do in our R D team is based on creating privacy tools to build on Ethereum. And in our privacy suit, we have two solutions.
00:01:51.306 - 00:02:02.050, Speaker A: One is nightfall. Nightfall is a ZK optimistic roll up solution. On lie two, we have already joined with polygon, and it's already in testing beta version.
00:02:02.050 - 00:02:38.266, Speaker A: It allows you to transfer your ERC 20, ERC seven to one W, one double five, whatever it is under privacy. So that's one bit of the puzzle, right? You can transfer privacy, you can transfer data in private. The second bit is, and this is the most important and mostly neglected one is what about the business logic? What about when you want to create a business logic in privacy? Or in other words, what if you want Ethereum to understand privacy, right? Ethereum's brain is smart contract and smart contracts doesn't really understand privacy.
00:02:38.266 - 00:02:49.474, Speaker A: Everything you put around the smart contract is public, and anybody can see it. And a lot of companies don't want the data to be put in public. For example, your age, medical records or your business agreements, you don't want them to be in.
00:02:49.474 - 00:03:05.814, Speaker A: And the difficult part is it's not like a ZK rollup solution where you're just transferring a token. It's very customized and it's very specific to the use case. So you can't really quickly have a tool where you can just put it in and then you create a private network out of it.
00:03:05.814 - 00:03:25.438, Speaker A: But Starlight aims to kind of solve these problems. Another problem that we ran into when people came up, a lot of clients came up to us and asking for privacy to be included in the solution. It took a lot of time for us to educate our developers on what Zkpe is, how to use this, what elliptic curve is, what the points are, and all these things.
00:03:25.438 - 00:03:35.214, Speaker A: So out of all this frustration is what Starlight was born. Starlight kind of tries to solve all these issues. It removes the learning time.
00:03:35.214 - 00:03:48.662, Speaker A: It takes all the burden off developers. All we do is, all we do is a pretty trimble three steps and you can take your normal smart contract and you can have a fully private smart contract ready. So I'll explain the three simple steps, which are pretty easy.
00:03:48.662 - 00:04:09.814, Speaker A: First step is write your solidity smart contract, which you already know, right? So step one is check. Step two is you add certain decorators into the smart contracts. And what I mean by decorators are like decorators are like your keywords that you use in a normal programming language, like private, protected or anything which the ZK compiler or the Starlight compiler understands.
00:04:09.814 - 00:04:25.086, Speaker A: Here we have three decorators which our smart contract understands, compiler understands, and based on the use case, you have to choose which decorator you have to use. Third step, my favorite, and the easy one is just to run the Zapify. It does everything for you.
00:04:25.086 - 00:04:41.190, Speaker A: It creates a complete zero knowledge application with circuits, with the shield contract and all the backend containers as well ready for you. So you don't have to really worry about what goes behind the scenes, what happens, how to build a circuit, and what are the commitments to be used. Everything is done in the back end for you.
00:04:41.190 - 00:04:55.722, Speaker A: This is pretty easy if you're use case. There are a lot of use cases where this can be applied. Now that's it's pretty easy to use, right? We can start using, but let's open the COVID a little bit and understand what happens under the hood here.
00:04:55.722 - 00:05:13.034, Speaker A: Okay? So in Starlight, when you run the Zapify command, three steps happen. First step is pass, then transform, and then generate in pass. And this is how the compiler basically works in Pass, what we do is we take the solidity contract, which is decorated now we kind of split them into two halves.
00:05:13.034 - 00:05:25.986, Speaker A: The first half contains a contract and then we have these decorators. The mapping between the two still remains. And now we take the solidity contract and we convert it into an Abstract Syntax tree or basically into its JSON form of the code itself.
00:05:25.986 - 00:05:37.138, Speaker A: All programming languages have this AST, which you can have. Now this AST is a pure solid AST to which we kind of add back the decorators we splitted previously. That's what happens in the first stage.
00:05:37.138 - 00:05:51.814, Speaker A: So you do the passing. Eventually you will get an AST, which is the normal solidity code plus a little bit of what the decorators were added. Now in step two is the transformation where we take this ASD and we convert it into three different abstract syntax trees.
00:05:51.814 - 00:06:00.762, Speaker A: One is for generating your circuits, which is for your zero knowledge proof generation and stuff. Second is for your smart contract. Smart contract basically does the onchain verification of proofs.
00:06:00.762 - 00:06:14.674, Speaker A: And then we have the third orchestration AST, which is for the backend containers and testing. Now, once we have the three ASTS ready, then we do the reverse of what we did in the first step. That is we take the ASD and then we create the code from it.
00:06:14.674 - 00:06:31.122, Speaker A: We create the zero knowledge code from the circuit AST we create a Shield smart contract from smart contract AST and we create kind of an orchestration code which kind of connects all these things together. Now that's it. So we get the AP with these three steps.
00:06:31.122 - 00:06:48.986, Speaker A: Now, so I spoke about the decorators and how these decorators are right? So now let's just look at how the transpiler works. So you can assign that you have a variable, unsigned variable X and that you want to kind of keep secret in your smart contract. It could be your age, it could be a phone number, it could be anything that you want to hide from your Shield.
00:06:48.986 - 00:06:53.422, Speaker A: Contracts, hide from the public. Now you add a decorator. Secret is one of the decorators that we have.
00:06:53.422 - 00:07:01.038, Speaker A: Unfortunately we couldn't use Private because private is already used. So Secret is a decorator that we have. And then that's the second step where we kind of decorated.
00:07:01.038 - 00:07:09.686, Speaker A: Third step is running Zapify. Once you run Zapify, it creates everything that's on the outside. Zap is kind of short form for zero knowledge application.
00:07:09.686 - 00:07:24.614, Speaker A: It contains the contracts circuits and the backend containers. Circuits are basically building Socrates in Starlight and these circuits contain your private public input and your information and your kind of the code as well. Contracts contracts is a Shield contract.
00:07:24.614 - 00:07:33.718, Speaker A: It's not really your smart contract. The Shield contract is for your on chain verification. The only thing that happens on chain is your verification of your commitments.
00:07:33.718 - 00:07:49.438, Speaker A: And in the backend containers we have a blockchain client which could be your Gynash geth or anything that you can just configure and connect like you try and connect anyways. Socrates is the backend that we use to create, generate proofs and to kind of do the setup. We have timber.
00:07:49.438 - 00:08:09.820, Speaker A: Timber is another excellent product by our EY team. It's a merkel tree which stores commitment in a very efficient way, so that you don't really have to pass through too much or you have to reveal the commitment to what it is. And then finally we have a testing infrastructure which is ready where you can deploy to different testnets in ethereum and see how it works.
00:08:09.820 - 00:08:33.866, Speaker A: Now, I spoke about a lot about decorators, so let's see them now. Right, the first decorator is Secret, secret as it names that if you want to keep a variable as secret, if you want to keep a variable confidential from the information, you call it secret. Now, you can have it for state variables, you can have it for function parameters, we intend to add it for functions.
00:08:33.866 - 00:08:58.874, Speaker A: But basically whenever you want to have a variable that has to be kept in the circuit which has to be in private state, you name it a secret. Now, once you focus on the right side here and the yellow bits so here you have an unsigned integer x which is kept as secret and also a function parameter y in the function add which is secret. Now, what you're basically doing is adding x into x plus y and I'll get to known in a bit.
00:08:58.874 - 00:09:12.502, Speaker A: But this is what basically does. Then the next step we have something called known known. So now we can do the contract.
00:09:12.502 - 00:09:26.210, Speaker A: Right now it depends upon we have the state variables and all but what's the use of it if we can't modify it, if we can't use it a lot. So that's where the other two decorators come in. The first one is called known.
00:09:26.210 - 00:09:45.560, Speaker A: Known is when only the owner of that particular smart contract, owner of that nullifier can edit it. Now the second one is Unknown, where anybody can basically edit the data. Now I'll get a bit more in detail into how the known works and it's important to know how the commitment structure of known and unknown works here.
00:09:45.560 - 00:10:03.050, Speaker A: So when you say a known, what it basically means is that only the owner of that particular commitment should be able to edit the data. Only the owner of the particular commitment should be able to increment the data x plus y. When somebody else tries to know it, the zero knowledge application kind of throws an error.
00:10:03.050 - 00:10:17.198, Speaker A: So for a non to work for somebody to call the non function you have to submit a couple of proofs. The first one is the proof of knowledge of the existence of the old commitment. This is done without really revealing the commitment by using the timber tree.
00:10:17.198 - 00:10:34.930, Speaker A: Second is providing the knowledge of secret key. Knowledge of secret key is basically related to what the public key is and you just have to kind of authenticate who you are. And then once you do that, you have to nullify the commitment which means that you have to kind of delete that commitment from database and then you add the new commitment.
00:10:34.930 - 00:10:51.226, Speaker A: So that's what known does. It's pretty easy because you only have one state every time you delete the previous commitment and you have only one commitment. Unknown is a bit different and there are a lot of use cases when you want a lot of people to kind of many people to kind of edit into your secret information.
00:10:51.226 - 00:11:22.502, Speaker A: For example, your balances where you want people who want to transfer you money but you don't want them to debit from your account, right? So you want the credit to be given by everyone but the debit to be only by one person. This is the case where multiple people are trying to edit a particular secret variable at certain situations and that's when we use unknown. What unknown does is it creates something called partition variables or partition commitments where you don't have just one single state.
00:11:22.502 - 00:11:45.530, Speaker A: In previous state we had only one state and we kind of delete the state and we override it with a new state. In this one in unknown statement we have a lot of part commitments and these part commitments come together and kind of summation of it is what the whole value is on the example, as you can see, balances is something that is kept as unknown. So anybody who's holding the balances, anybody can transfer to my balance.
00:11:45.530 - 00:11:58.980, Speaker A: So if somebody who's a sender here it debits from his account and from the unknown. The unknown balances is actually of the recipient so it's not his own account. But with unknown you can kind of edit his secret seat as well.
00:11:58.980 - 00:12:15.382, Speaker A: Next one. It's important to know the commitment structure a little bit the commitment the first thing that holds is the state variable ID. Now, Solidity has this state variable ID in itself which is a unique ID that is given to each variable then is a state value.
00:12:15.382 - 00:12:31.254, Speaker A: State value is the value that it holds. It could be a number, it could be a string or anything and then the public key of the honor and we have a solve to kind of award duplicate commitments or commitments that have duplicates. It's pretty easy for a normal state variable because we have a state variable ID that is unique.
00:12:31.254 - 00:12:56.574, Speaker A: Now, it's a bit tricky when you have mappings or when you have arrays where you can have one stateable ID and there are a lot of elements that related to it. In this case, what we do is we take the mapping key, we take something called a mapping key which could be your address, which could be the array index and then that is replaced instead of the state variable ID. So it's basically a hash of the state variable ID and the mapping key that's the first input.
00:12:56.574 - 00:13:13.926, Speaker A: The rest of the three inputs are pretty same. I'll give you an example here of a developer use case and what really happens now we have a secret mapping here of an address to an answer integer which is the invoice of the people that they are. And then we have two functions add invoice and pay invoice.
00:13:13.926 - 00:13:37.586, Speaker A: What add invoice basically does is that you can add invoice someone's account and then pay invoice is you can pay off somebody whoever you're ordering it. Now in this case, basically when you call the add invoice API, what happens is it checks for the commitments in the database for this particular honor that we have. For example, if you want to add invoice to the honor, it checks in the database for this honor's database is there or not.
00:13:37.586 - 00:13:51.538, Speaker A: It can be done by anybody. So it checks for that particular honor and then once that check is done, you create a new zero knowledge proof using Socrates and you push into the database. Now this proof is then given back to the orchestrator file.
00:13:51.538 - 00:14:06.540, Speaker A: So the orchestrator first calls the Socrates and he creates a shielded proof, means zero knowledge proof and gives it back to the orchestrator. The orchestrator now contacts the shield contract which is on chain and the on chain proof is verified. Once the proof is verified, we update the states and everything is done.
00:14:06.540 - 00:14:25.698, Speaker A: Now, you don't have to know all of this to build on Starlight. All you need to know is to write a solidity smart contract and add these decorators as a men required. Now, something that we understood is that privacy has become a big factor and something that we haven't worked on a lot.
00:14:25.698 - 00:14:40.280, Speaker A: A lot of industry applications or general applications require privacy and people to be building on privacy application. We believe Starlight is a good tool that can help you build it. Now you can use our repo here.
00:14:40.280 - 00:14:57.980, Speaker A: So all our products in R D, both Nightfall and Starlight are completely open source for people to look at. Please have a look and provide feedback and work on it as well. And I'll take maybe a couple of minutes for quick questions and then I'll hand over the mic that's it from.
00:14:57.980 - 00:15:00.220, Speaker A: Any questions?
00:15:03.250 - 00:15:20.400, Speaker B: So how will it so how it will integrate with existing tool like Hard Hat and Truffle because basic solidity has like Abi and here you have AST, so will those.
00:15:27.810 - 00:15:33.794, Speaker A: Sorry way. So yeah, you can try it on Infuria. We have tested on infura.
00:15:33.794 - 00:15:42.134, Speaker A: We are deployed on polygon testnet. We usually use Ganache to kind of test it. We are deployed on Get, so it doesn't really matter.
00:15:42.134 - 00:15:48.020, Speaker A: You can deploy it on any platform that use. We haven't tested on Hard Hat, but I'm pretty confident it will work as well.
