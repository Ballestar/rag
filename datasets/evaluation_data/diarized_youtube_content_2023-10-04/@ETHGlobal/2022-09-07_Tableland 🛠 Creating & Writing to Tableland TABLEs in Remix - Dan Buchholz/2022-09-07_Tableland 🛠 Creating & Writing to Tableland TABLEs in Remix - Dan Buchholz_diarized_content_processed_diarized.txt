00:00:06.810 - 00:00:28.710, Speaker A: Hi everyone. Today we're going to walk through an overview of the Table and protocol and then dive into Remix and show you how to create a table and write to it all from a Smart Contract. So first off, what is Tableand? Tableand is a decentralized database network that makes it easy for people to create, create and write to Tables in a Web Three native capacity.
00:00:28.710 - 00:01:07.940, Speaker A: So you can picture Table end as sort of this off chain network of validators that are listening to on chain events which emit SQL instructions for what these validators should do. So what this allows you to actually implement is cheap ways to store information and smart contracts in this off chain network and then read from that off chain network in things like applications or compose it across NFTs or really anything. So Tableand really opens the door for new experiences to happen in a Web Three native composable way.
00:01:07.940 - 00:01:38.970, Speaker A: And what this really allows you to do is turn any blockchain into an application database. So anything from dynamic NFTs to Game State to Application data, all this can actually be stored in Table and Tables. And then you can use things like different access controls with Smart Contracts to ensure maybe only a specific address with a particular balance that owns this specific NFT can write to a Table.
00:01:38.970 - 00:02:03.620, Speaker A: So there's a lot of creative ways that you can then use Tableand in general. And we do have a number of ways in which you can interact with the network. So as noted, there's really the foundation of everything comes from a validator network running SQLite and they're the ones that are making mutations to Tables, creating Tables and sharing State across them.
00:02:03.620 - 00:02:29.542, Speaker A: And all of those instructions are actually coming from smart contracts that are deployed on chains like Ethereum, Polygon, Optimism and Arbitrum. So as those events from Smart Contracts and in particular what we call the registry Table and Tables Smart Contract, as those events are emitted, they basically tell these validators what to do. And smart contracts can interact with this registry.
00:02:29.542 - 00:03:10.342, Speaker A: Smart contract? Or there are other clients that we've built on top of this, including our JavaScript and TypeScript SDK and a CLI tool as well. Now, once a Table is created, what's actually happening is that it's minted as an ERC 721 token. So the Table token exists on all these different networks and we actually have a rendering of what the if you go on any marketplace like Testnets, Openc, IO or just really OpenSea period for the main net deployments, you'll see something similar like this if you search Table and Tables.
00:03:10.342 - 00:03:40.286, Speaker A: So what this is telling us is that hey, there is a table out there owned by a particular EOA or contract where there is a table name that is the one at the top and you can specify any table prefix that you want to make it human readable. And then there are some additional numbers that are appended to the end of a prefix that make a table globally unique. Every table can exist in this globally unique setting and specific to each chain.
00:03:40.286 - 00:04:10.830, Speaker A: And within this SVG metadata rendering, there is some information just about the table itself. But really when you create a table, it includes setting the schema and then inserting data into it. And then once you do this, you'll notice that rows populate such as the number 1473 represented there is just hey, this table has little over 1400 rows included and the data itself is about a holder which is of type text and a quantity which is of type integer.
00:04:10.830 - 00:04:28.494, Speaker A: And interestingly, this is related to our table and rigs NFT. So if you're interested in that search table and rigs over on any NFT marketplace. Now, before we get started with Remix, just in case you are interested in some of the other tools, here are those resources.
00:04:28.494 - 00:04:58.614, Speaker A: And then lastly, we are opening up a pilot program here shortly. And our pilot program is basically a way to allow builders to have some funding, to have some high touch experience with the table and team and build a product, build some sort of it could be a hackathon oriented type of ordeal or for someone that actually has a well baked idea, could be a dow. It could be like a product that already exists and you're looking for a web three native database.
00:04:58.614 - 00:05:13.140, Speaker A: Essentially you can insert sort of pun intended table and into that equation and we'll walk you through that throughout the pilot program. So if you're interested, feel free to apply. The applications are now open and it's a seven week program.
00:05:13.140 - 00:05:29.122, Speaker A: Cool. So we're going to start by diving into Remix. And if you're not familiar with Remix, it's a great tool for just getting started with smart contract deployments and interacting with different chains.
00:05:29.122 - 00:05:40.106, Speaker A: And what we're going to walk through today is just the very basics of tableand. If you haven't already, check out our documentation. There's a lot of information here on what you can do with table end.
00:05:40.106 - 00:06:09.406, Speaker A: What we're showing here is our deployed contracts page and this will just make it easier in a moment here once we do some initial setup. Now if you are looking for a little bit more in depth information on how to really just build a smart contract from zero to one, check out this build a dynamic NFT Insolidity tutorial on our documentation page. So great, let's go back to Remix and create a smart contract.
00:06:09.406 - 00:06:44.298, Speaker A: So we're going to first start off by specifying the actual smart contract that we're going to create. So let's just call it EVM create Table sol and I have some pre created code that I'll walk you through here now, but it's pretty straightforward to actually get started with table end and create and write to tables. So up at the top, just some basic config information around the open source licensing and pragma solidity.
00:06:44.298 - 00:06:53.230, Speaker A: And here we've imported a few different contracts. So the first one is pretty interesting. Get to this in a second but ERC 721 holder.
00:06:53.230 - 00:07:19.514, Speaker A: Next we have the Table and Tables interface and then third we have a strings library and really the top and bottom one of these imports are important for just interacting with table and making some of those interactions more straightforward. Cool. So we have our contract and up at the top we've specified some state variables that we're going to be saving.
00:07:19.514 - 00:07:44.498, Speaker A: So the first one is when we actually deploy this contract we're going to set the address of the Table and Tables registry smart contract and this will make it easy when we're actually interacting with that contract itself or creating and inserting data into the tables. Next we have some information that is specific to tableand. So every table comes in sort of this.
00:07:44.498 - 00:08:05.858, Speaker A: I'll scroll down here but in a format like this prefix chain ID, table ID. So here we're saving each of those components as individual state variables. Not necessarily required to save the prefix itself but I thought it'd be helpful to do it here just based on the way I've designed the contract.
00:08:05.858 - 00:08:30.462, Speaker A: But note that it's pretty common pattern to at least save the table name and table ID sometimes prefix because it just really depends on your implementation and how efficient you are in trying to get this contract. And then the last piece is just a counter. When we show our write statement down at the bottom it's going to leverage this counter, just increment the value little by little.
00:08:30.462 - 00:08:40.670, Speaker A: So when someone inserts into the table it's just using the updated value. Next we have a constructor. So here we're setting that table prefix.
00:08:40.670 - 00:08:59.480, Speaker A: We are setting the actual table land table's registry smart contract address and then we're specifying the counter as zero. And there are definitely better ways you can handle this around counters and everything. This isn't the most perfect implementation but it's just really the basics to get started and show you how to do things with table end.
00:08:59.480 - 00:09:50.780, Speaker A: So the next step we're going to do is create this create metadata table and I actually will just rename this as Table because it's not necessarily metadata although Table And is great as a metadata solution for things like NFTs because we can make metadata natively dynamic with onchain rules and interactions. But first what we're going to do is since in our constructor we specified that Table and Registry contract we're going to create a table and at the table end registry smart contract and in fact it might be helpful to even look this up in real time. But if we look at Table and Tables what does this really do? So if we scroll down a bit you'll notice two functions that are pretty important to this tutorial in general.
00:09:50.780 - 00:10:02.218, Speaker A: One is create table. So here we're going to specify who the table owner is and what that Create Table statement is. And what this will do is, as you see here, safe mint.
00:10:02.218 - 00:10:21.010, Speaker A: It's going to be minting a table token to whoever mints this table. And then from there we will be writing to the table itself using this run SQL function. So taking that caller so that owner of the table, typically the table ID and then the statement.
00:10:21.010 - 00:10:39.500, Speaker A: So if you come from a world of SQL, this is going to be our Create Table type of statement. And then this is a statement like insert into table values. And this is really cool because this is all happening on chain and there are other ways that you can get pretty creative with this.
00:10:39.500 - 00:11:05.770, Speaker A: You'll notice at the bottom of this run SQL function there's this Get policy. And what this does is actually if you want to have more complex access controls, like checking ownership of a token or checking balance of a wallet saying, hey, this person can only insert into my table if they have a balance above 0.1 ETH, sort of spam production, things like that.
00:11:05.770 - 00:11:28.194, Speaker A: You can leverage the Git policy to make sure that only the right people are updating or inserting values into a table. And we won't be walking through that today. But if you are interested in more of the complex type of ACL configurations, that's where our table and controller contract comes into play, where you can do things like inserts updates, deletes, where clauses, et cetera.
00:11:28.194 - 00:11:40.800, Speaker A: And this is where you can get into the creative nature of the ACLs. And there are some contracts that show you exactly how these type of interactions could be established. So check those out if you are interested in them.
00:11:40.800 - 00:11:45.578, Speaker A: Cool. So back to remix. We have our create table.
00:11:45.578 - 00:12:01.822, Speaker A: We have the actual statement down here and what it looks like is basically this. So create table. And when we use the Create Table type of setup, we're going to leverage a prefix underscore chain ID to initially create the table.
00:12:01.822 - 00:12:14.102, Speaker A: And then once it's actually minted, this value will have token ID appended. And this is going to be generated by the table end table's registry smart contract. But at the current state you don't know what that token ID is.
00:12:14.102 - 00:12:24.710, Speaker A: So you have to let the registry smart contract essentially tell you what that is upon minting the table. So create table prefix chain ID. And then here we have our schema.
00:12:24.710 - 00:12:40.080, Speaker A: So we're saying the first value is the column is going to be called ID. It's of type int for integer and it's a primary key. Next we have a column called Message and it is of type text.
00:12:40.080 - 00:13:03.160, Speaker A: Awesome. Now in this next step we have string concat and this basically builds that actual Create Table statement like it is up here, but does it in a solidity way. So create table space table prefix underscore strings upgradable to string blockchain ID.
00:13:03.160 - 00:13:20.006, Speaker A: You'll notice in a development environment where we haven't necessarily specified that this is going to be on, let's say, Polygon Mumbai or Ethereum Girly or even Ethereum Mainnet. If you want to deploy a table there, it's going to throw this error. Don't worry about it.
00:13:20.006 - 00:13:39.550, Speaker A: Doesn't really mean anything for what we're doing at the current state. So create table prefix underscore strings to string and this converts this number into a string. And then after that space ID int primary key message text boom.
00:13:39.550 - 00:14:01.654, Speaker A: So that is our Create table statement. From there, we are also going to make sure that we have the table name saved as a state variable. So it takes this table ID and then it basically formulates that aforementioned prefix chain ID, table ID type of setup.
00:14:01.654 - 00:14:13.914, Speaker A: So our table name is our prefix underscore strings. We're going to also convert that chain ID. So in this tutorial, we're going to deploy on Polygon Mumbai.
00:14:13.914 - 00:14:31.410, Speaker A: So you'll notice that this will end up being the Polygon Mumbai chain ID 8000 80,001 and then underscore. And then we're also going to convert this UN 256 table ID to a string. So Table name will also be a string.
00:14:31.410 - 00:14:46.198, Speaker A: Great. So let's just review real quick what have we done? In theory, we've deployed a contract. When we do so, we specify these constructor values that basically take care of this.
00:14:46.198 - 00:14:57.658, Speaker A: Actually, in hand with this Create Table function will take care of everything up here. So now we have created a table. It'll have been minted by this contract itself.
00:14:57.658 - 00:15:14.850, Speaker A: And one thing to note before we go into writing to the table is this ERC 721 holder aspect. So in order for a contract to create a table, it has to be able to receive an ERC 721 in general. So you have to make sure that you implement this aspect.
00:15:14.850 - 00:15:34.630, Speaker A: ERC 721 holder does this. So it has this function that it's implementing called the on ERC 721 received. And this is really essential a piece to implement in all your contracts if you are interacting directly with the registry smart contract.
00:15:34.630 - 00:15:51.470, Speaker A: Alternatively, if you want to do it yourself, there is just a contract called ERC 721 receiver. And you can do this yourself, but this just kind of handles it for you. Great.
00:15:51.470 - 00:16:00.060, Speaker A: Next step, let's write to a table. We're going to call Table and run SQL. That function that we looked at earlier.
00:16:00.060 - 00:16:11.590, Speaker A: The caller is the address this. So the address of the smart contract. And again, since this smart contract can receive tokens, this is really what enables everything to be possible.
00:16:11.590 - 00:16:32.600, Speaker A: We have the table ID and then we have the insert statement itself. And the insert statement is going to look like this up at the top. So insert into, we have that format prefix chain ID, table ID, we have the columns that we're going to insert into and then we have the values that we're going to insert into the table.
00:16:32.600 - 00:17:00.250, Speaker A: So the values, we're going to have this sort of counter that's going to be occurring and after inserting, we're going to increment the counter itself. So you don't have to do it in this capacity. You could actually just if you want to insert any value, you don't have to use a counter here, but I'm just doing it for simplicity's sake.
00:17:00.250 - 00:17:20.446, Speaker A: So what we're saying is that insert into this table name, we're going to insert the ID message values. We're going to convert that counter, which is a uint 256, and we're going to convert it into a string comma. And notice this single quote around the message.
00:17:20.446 - 00:17:45.574, Speaker A: And this is just a thing with SQL that you should be aware of. If you aren't as familiar with SQL, make sure that you wrap any strings, any text in these single quotes to make sure that it is SQL compliant. So ID message values, that first value comma the message itself, close out the single quote, close out the values, boom, good to go.
00:17:45.574 - 00:18:05.310, Speaker A: So we have our actual statement ready to go and then at the end we're incrementing the counter just so that every ID that's inserted ended up being unique. And that's actually an important point here because if you recall at our schema we specified that this is the primary key. So the primary key should be unique.
00:18:05.310 - 00:18:16.002, Speaker A: Great. Okay, next step, let's make sure that everything compiles correctly. Nice.
00:18:16.002 - 00:18:22.530, Speaker A: It does. So before going on, let's just do a quick recap. We imported some contracts.
00:18:22.530 - 00:18:43.446, Speaker A: We in theory set all these state variables, or the majority of them through the constructor function. We created a table which sets some of those state variables and also information that's relative to the last step, which is actually writing to the table. And now we are actually ready to deploy.
00:18:43.446 - 00:18:56.926, Speaker A: Now best practice, as with any development, is to do some testing and dry runs and things like that. Prior to actually deploying. We're just going to be bold and skip brick to the end and just, hey, let's launch it.
00:18:56.926 - 00:19:31.606, Speaker A: So we're going to use injected provider, and if you have MetaMask installed that basically is just using the provider via MetaMask, we're going to actually also specify the network. So as noted, table N is live on a number of different networks. We're going to choose Polygon on by because why not? And before doing so, if you recall in our constructor, we passed this registry address in the deployed contracts portion of the table and documentation, you can see all of the smart contract addresses.
00:19:31.606 - 00:20:05.190, Speaker A: If you're curious, you can also even check out what it looks like, what the table tokens look like, what the contract does, how to read and write to it, all from this interface itself. But we're just going to go ahead and copy this address for Polygon Mumbai. Now when we deploy this, we're going to paste that address into this deploy section because that is basically passing that address to the constructor variable and now we are ready to deploy.
00:20:05.190 - 00:20:31.706, Speaker A: So it is rather inexpensive especially on polygon, just a fraction of a matic and down at the bottom you'll see and I'll even open this up a bit but you'll see the deployment information and exactly what happened. So just to even verify things, let's see what it looks like on polygon scan. Here's the transaction hash.
00:20:31.706 - 00:20:43.854, Speaker A: So we'll copy it. Come over here, scroll to the top, search for this address in particular. And often there is a little bit of a lag for really any indexing solution.
00:20:43.854 - 00:20:57.974, Speaker A: But we can see here that cool, good to go. Contract was deployed. And then the next step we're going to do is click down here at the bottom and we're going to interact with that contract first.
00:20:57.974 - 00:21:40.924, Speaker A: What we're going to do is just validate that our table name is empty and then we are going to actually create the table again. Note the cost for table creation is rather inexpensive and always think of this in the context of hey, if I were to save this data to a state variable, what would it cost? And if I were to try to mutate this over time, what would it cost? Table N is significantly cheaper than doing so. So you can kind of see a table as this layer that is saving data that could have been in state variables but doing it in a much cheaper capacity based on the way table.
00:21:40.924 - 00:21:53.060, Speaker A: And is architected with this. Registry smart contract and events being emitted where that table land network of validators are the one materializing the events. So just a different way to think about things overall.
00:21:53.060 - 00:22:23.264, Speaker A: Nice. So we are going to create the table, wait for it to actually go through and then similarly with that last example, we're going to wait for the transaction to be confirmed and upon being confirmed we'll see what it looks like on the table and side of things. And more specifically, let's look at it on polygon scan, wait for the indexing to pick up.
00:22:23.264 - 00:22:40.048, Speaker A: Cool. So let's dissect this a bit and if you ever are interested you can always see some information down in the decoded logs here. There's nothing going to be quite interesting in the scenario.
00:22:40.048 - 00:22:53.864, Speaker A: Maybe if we pull over into this section we can but I don't really want to go into those details at this time. Let's just take a look at what we've done. So here we're saying that within that registry smart contract it's minting a token.
00:22:53.864 - 00:23:08.784, Speaker A: So it's going from the zero x address to this address and it's minting this token ID. So 1380 is actually our token. Now if we're curious what this looks like in the table and realm we can also do this.
00:23:08.784 - 00:23:25.184, Speaker A: So 1380, let's see what it looks like and this will require us to go back to the actual table and tables smart contract. Scroll down the bottom. Find token ID or token uri.
00:23:25.184 - 00:23:38.650, Speaker A: Actually. Token uri 1380. There we go.
00:23:38.650 - 00:23:56.476, Speaker A: So boom, this is our Token itself. If we want to see what it looks like, we can see this real time SVG rendering of the data. So that prefix, that chain ID, that Table ID, the network, the number of rows.
00:23:56.476 - 00:24:09.830, Speaker A: We haven't inserted any data quite yet, so this is expected at zero. And then the number of columns, or the information in particular about the columns. So that int primary key message text.
00:24:09.830 - 00:24:19.232, Speaker A: And we're going to keep this up. We're going to come back to this in a moment here. Now let's validate that it looks good.
00:24:19.232 - 00:24:29.684, Speaker A: Okay, perfect. Just as that SVG had showed. And note that there are also APIs that we can also walk through here today for interacting with the table.
00:24:29.684 - 00:24:52.640, Speaker A: The SVG is just a nice way to see what's happening. But now what we're going to do is write to the Table. So we're going to say, well, recall that if we scroll down, really all this is doing is taking a message and then it's forming like everything else that's incorporated into this insert statement.
00:24:52.640 - 00:25:15.020, Speaker A: So we're going to say hello from Table land right to the Table. Rather low cost compare against writing and mutating some storage variable. It would be much more expensive.
00:25:15.020 - 00:25:26.064, Speaker A: And then confirm as this is confirming or pending. So we have this transaction waiting in the transaction pool. Okay, a miner has picked it up.
00:25:26.064 - 00:25:31.040, Speaker A: It's included in a block. Great. We have this transaction hash.
00:25:31.040 - 00:25:47.560, Speaker A: We will check it out again on Mumbai scan, see what's going on. Indexing. Boom.
00:25:47.560 - 00:26:00.888, Speaker A: So now we can actually see what we decoded, see what we actually wrote as part of that message. So hello from Table and cool. So we know that the event was emitted.
00:26:00.888 - 00:26:12.016, Speaker A: We know that this interaction has happened. Now let's finally check, make sure that everything was good and that the data was rendered in Table N. Cool.
00:26:12.016 - 00:26:20.868, Speaker A: Real time update. Dynamic NFT row is now one. And what's cool is that we can also just query the data itself.
00:26:20.868 - 00:26:42.680, Speaker A: So rather than just looking at this SVG rendering, we can also go over to this endpoint here. And what's cool is that this is actually fully SQL compliant. So testnet Table network query and with this query parameter you can write raw SQL statements.
00:26:42.680 - 00:26:55.680, Speaker A: So we're going to say select all from. And we had what was our Table name ETH online. The chain was polygam and buy and the token ID was 1380.
00:26:55.680 - 00:27:07.296, Speaker A: Awesome. So just mirroring this and marrying this together. With this, you can see Table name chain, rows, columns, the information about the columns.
00:27:07.296 - 00:27:19.606, Speaker A: It's essentially just pulling information from here and summarizing it in a nice SVG type view. Dynamic NFT capacity. Great.
00:27:19.606 - 00:27:39.158, Speaker A: So if you're interested, you can continue interacting with that contract. I will share this in a write up at a different point in time, but appreciate everyone sticking with me throughout this demonstration. What we did was create a smart contract that simply interacts with the Table and Table Registry.
00:27:39.158 - 00:28:05.666, Speaker A: It allows you to easily create a table and write to a table, all using just smart contract interactions. And then from here, what you can do is really get creative, build dynamic experiences that leverage complex ACLs and access controls to really open up the door for truly composable cross chain cheap native experiences to the web three Realm. Thanks again for sticking with me.
00:28:05.666 - 00:28:06.110, Speaker A: Bye.
