00:00:07.530 - 00:00:59.950, Speaker A: Hey, welcome, everyone. Yeah, we're going to get started with the workshop. Just want to first give a brief overview of what Axiom is and then talk through how you can actually build a ZK powered app with Axiom in about 30 minutes. So first of all, what's the problem that we're trying to solve at Axiom? It's starts with the observation that if you're building a smart contract on Ethereum today, you actually quickly realize that your contract can't access much data. As an example, if you look at the OpenSea listing page for Pudgy Penguin, you'll notice that almost all of the information that is on the page is on chain data. For example, the transaction history or historic owners, but only the current owner is actually accessible on chain. And the reason for that is to maintain the decentralization of transaction validation on Ethereum.
00:00:59.950 - 00:02:19.714, Speaker A: So developers work around this by making pretty difficult tradeoffs today between paying more to access more data in their smart contracts by just storing more data in storage, or reducing the security of their applications by using a trusted Oracle that simply puts data on chain. And so at Axiom, we're removing this trade off by providing a new way to access historic on chain data using zero knowledge proofs. What that means is that we use the fact that the current block of Ethereum commits to all historic data on Ethereum to give cryptographic proofs that a piece of historic data that your application is using is actually valid in the history of Ethereum. But because we're using cryptography instead of consensus to access data, we can offer a whole new set of capabilities for your application. And so we've wrapped this up into what we're calling a ZK coprocessor for Ethereum. The flow of using it is that you send a query to our smart contract. We provide trustless reads to any block header, any account, or any contract storage variable in the history of Ethereum.
00:02:19.714 - 00:03:19.770, Speaker A: And we're also adding transactions and receipts in our V two, which we're previewing at ETH Global. Once you have that data, you can do computations on top of it with custom ZK circuits and get to a result that your on chain application is interested in. We provide a zero knowledge proof that those results are actually correctly computed and come from data which actually comes from Ethereum. So that means that you can rely on data results that come from Axiom with the same cryptographic guarantees as something you're accessing directly on chain. So let me talk through how you'd actually use this in your application. So the flow of an application that uses Axiom to access historic data goes as follows. First, we provide a very easy SDK to allow your users to prove computations and request data in your web front end.
00:03:19.770 - 00:04:26.578, Speaker A: So here we actually provide a client side ZK prover that your users are going to be running on their laptops. They'll send a query for on chain data to the Axiom smart contract, which we're indexing, and we'll prove that the data access that they're doing is authentic using zero knowledge proofs. Finally, we verify the end result on chain with the ZK proof and we execute a custom callback on your smart contract, which is the only change you need to make to your contract to integrate Axiom. So let me talk through the steps of actually integrating Axiom into your application. First, we provided an easy web replace for you to specify the computations you want to do and the on chain data access you want to make. So this is called Axiom REPL and we'll walk through it later in this workshop. Once you've done that, we allow you to export a WebAssembly ZK prover to a next JS app.
00:04:26.578 - 00:05:43.920, Speaker A: We have a scaffold app for you already from this web REPL, but you can also migrate that prover to a web front end of your choice. This would be ultimately what your end user is using to interact with Axiom. Once that's done, in the flow of your application, users would send queries to Axiom from the web front end that happens through an on chain transaction. We're indexing those queries and we'll prove valid data access through Xeronoledge proofs that are executed on our server backend. Finally, we'll implement a callback sorry, you'll implement a callback on your onchain application, and what we ask is that you extend our Axiom V two client interface that gives a standardized format for the callback, which allows you to check various properties of the query, make sure things are authenticated and permissioned correctly, and finally, gives you the user data that you're actually interested in. Okay, so now time for a demo. You can follow along by going to replyview Axiom XYZ.
00:05:43.920 - 00:07:04.820, Speaker A: It unfortunately will not work on your phone, but for those of you with laptops, you can watch what I'm doing. You'll actually see the same demo code as I'm running live. So let me just pause for like 5 seconds so everyone can get the URL and then I'll go to do some live coding. All right, so back to Axiom replaced a JavaScript interface to allow you to actually access on chain data and do computations on it. So, as you can see here, we have this in this window you are writing actual JavaScript and we're going to write an application to prove the first block that a user's account actually made a transaction on Ethereum. So how can we know that a user's account made a transaction for the first time at a certain block? Well, if you look into the details of the EVM, you'll know that we have to check that the nonce of that account was zero at the previous block and then became positive on the claimed block where they made the first transaction. And that's exactly what we're going to check in this JavaScript interface.
00:07:04.820 - 00:08:17.210, Speaker A: So we have an input box which let me just pull up here and what we'll check is that for this address, the first block in which it made a transaction was the claimed block number here. And this is all on Girly testnet. So the way we do that is first we compute the previous block and here whenever we do any computations in this JavaScript interface, we require you to use our JavaScript functions. We've written custom functions, for example sub, add, mole and div to implement arithmetic operations that will later be proved in zero knowledge. So here we would prove we would compute the previous block number and then we would call functions that we've implemented to allow you to access on chain data through this interface. For example, here we're calling Get account. You can also call functions like Get Storage gets solidity mapping, Get Transaction or Get Receipt to access the entirety of Ethereum execution layer data.
00:08:17.210 - 00:09:22.480, Speaker A: So here we get the account object from the previous block with this address and then we can access the nonce from that account just by calling nonce. And remember we wanted to check that that nonce was zero. So we call assert equal to check that the nonce at the previous block was actually equal to a constant which is zero. Now we want to check that at the claim block this nonce actually became positive. So again we fetch the nonce by fetching the account and then calling dot nonce on that account. And then we use a function check less than to check that zero was less than the current nonce, thereby showing that it's actually positive. So if all of these pass, then we can use a final function add to callback to specify that the address and the claim block number should actually be sent to your smart contract as the callback arguments.
00:09:22.480 - 00:10:40.084, Speaker A: So if I click test circuit we're going to generate test outputs here and we'll see that indeed we outputted the address and the claimed block number as the test callback arguments. Now I'm going to show a demo flow of this actually interacting with a contract on girly testnet. So to do that we're going to generate proving and verification keys and then we're finally going to generate a zero knowledge proof of the execution of these computations, namely subtracting one from the claimed block number and checking the equality of the nonce to zero and the positivity of the next nonce. Once we've generated this proof, we now can send a query to Axiom to authenticate all the data inputs that went into this proof. What I mean by that is we need to check that the account nonce that we fetched was actually correct for both the previous block and the next block. So we can do that by sending a query on chain to Axiom and that actually sends an on chain transaction on girly. Once we send that, we can check it out on Etherscan.
00:10:40.084 - 00:12:18.600, Speaker A: As you can see, it's still being indexed so let me pull up a transaction I sent maybe 1 hour ago so that's the exact same transaction and we called this send query function what we sent and that's being done in our web front end is some information about the data that we wanted to fetch. So here we have the source chain, in this case the source chain ID is five which corresponds to girly testnet the data query hash which is a hash that specifies that we wanted to fetch the nonce of one account and the knot at one block and the nonce of that same account in the next block. And finally the information about the computation we did which we encode in this compute query object. So we have two pieces of information. One is a V key that allows us to verify that the zero knowledge proof we did in the browser was correct and secondly the compute proof which actually is the proof. So what this query is going to do is to request Axiom to check two things one, that the Compute proof was correct and two, that the data we're requesting was actually used correctly in that compute proof. Once that check has passed, we're going to call this callback that you can specify here I've specified address of an example contract, a function selector of an example callback call and we specified that two results should be passed, so there's a result length of two.
00:12:18.600 - 00:13:26.520, Speaker A: And finally we allow you to pass in extra data in the callback as well. The rest of the arguments specify what sort of gas requirements you want us to hit the callback with. So this is a transaction that's been sent to the Axiom smart contract on chain and we will fulfill that request by calling the fulfill query function. As you can see, the fulfill query function gives you the compute results. So this was the address and this was the block number that the address first sent a transaction. It also provides a zero knowledge proof that the compute proof was correct, that the data was validly plugged into the compute and that everything really came from the history of ethereum. And finally we hit a callback on an example contract in this case, but in an application this would be your contract and we require that you implement an interface for we call Axiom v two client that simply takes a callback that expects the following arguments that kind of correspond to your query.
00:13:26.520 - 00:14:33.460, Speaker A: So the first argument is just the source chain ID where the data is coming from. The second argument caller address is the EOA address that initiated the query. So if you're allowing any user to send a query into Axiom for your application, this would be the address of your user. Finally, the query schema specifies what your query is about. So every time we write a query in the browser it generates a unique query schema that you should validate in your application. The last two arguments, the query hash is a unique identifier for the specific query that's being sent, and the Axiom results are the results, in this case, the address and the number and the block number where that address first sent a transaction. So all you need to do to integrate Axiom into your application is to write a query in our Axiom REPL interface, export the NextJS prover, and then implement this Axiom v Two callback function on your smart contract application.
00:14:33.460 - 00:15:23.490, Speaker A: And we provide this interface axiom B Two client for you to do it. Okay, so last couple of minutes, just wanted to reiterate those steps. So first you write a query or circuit in Axiom REPL to specify the computation, export the prover, modify your front end. To integrate that prover, we will on our server index your user's queries and provide prove a valid data access. And then you will implement a callback on your contract. So for this weekend, we stood up a preview version of Axiom V Two on girly and we have a bunch of ideas for what you can build with it. First, we think the areas of identity and governance are super interesting.
00:15:23.490 - 00:16:18.192, Speaker A: We think you can provide autonomous Airdrops, namely Airdrops, where you deploy a smart contract with some criteria for who should be able to get the AirDrop. Users can prove using Axiom that they performed relevant activities in the past and are therefore entitled to get incentivized. That takes away control of the AirDrop from a centralized team and gives it to a smart contract. Similarly, you can imagine giving volume rebates or other types of loyalty rewards for usage of on chain applications. If you think about Uniswap, no matter how much you trade, you're paying the same fee with Axiom and Uniswap v for hooks. You might imagine that higher volume traders or new traders can get lower fees. Another angle is that you can actually construct a trustless Oracle using Axiom.
00:16:18.192 - 00:17:29.480, Speaker A: You might imagine taking an average of on chain gas prices and constructing an index of ethereum gas prices to settle a derivatives protocol. We listed a few other DeFi ideas here and we're having special prizes for the best usage of Axiom in both identity incentivization and Oracles sorry and DeFi in the last couple of minutes. Just a couple more ideas. You can use Axiom to slash participants in a protocol on chain. For example, because we allow you to access transaction and receipt data, we think you might be able to detect whether an ethereum block contains a sandwich attack and who might be responsible for that. If someone's responsible for a sandwich attack, maybe you should punish them, or maybe you can use that attack to refund part of the proceeds to the initial user. Other things we think are interesting are automatically adjusting parameters of a DeFi protocol, using on chain historic data, or having batch auction settlement prove to be optimal again off chain.
00:17:29.480 - 00:18:06.496, Speaker A: Finally, there are a bunch of very silly ideas. You can give people little badges for various on chain Dgen activities they may have done. Imagine proving that you owned lot of one type of NFT or you lost money trading NFTs. Imagine you have a badge if you lost 100 ETH trading NFT. You could also prove that you did various interesting on chain activities. For example, if you farmed yam during DFI summer, I think that might be a notable attribute of your account. So we really are interested in creative ideas from you guys.
00:18:06.496 - 00:18:29.590, Speaker A: We also have a special prize for the most creative usage of Axiom as well as the best overall usage. So we have a bunch of materials prepared for the Ethg Global hackathon. We have a special guide at ETHGlobal axiom XYZ. And if you use this QR code, it'll take you to our Telegram group where you can get help directly from the team.
