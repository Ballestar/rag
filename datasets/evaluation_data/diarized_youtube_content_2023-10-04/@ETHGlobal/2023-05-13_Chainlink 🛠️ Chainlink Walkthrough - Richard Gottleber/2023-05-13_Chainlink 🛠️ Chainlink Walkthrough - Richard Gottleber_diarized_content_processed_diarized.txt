00:00:07.530 - 00:00:09.546, Speaker A: Hi, I'm Richard, one of the developer.
00:00:09.578 - 00:00:18.890, Speaker B: Advocates at Chainlink Labs. And today we're going to take a look at what is chainlink and what are a few of the products that Chainlink offers.
00:00:19.050 - 00:00:25.878, Speaker A: So let's dive in. All right, so first question what is chainlink? In order to understand that, we need.
00:00:25.884 - 00:00:40.406, Speaker B: To make sure that we have a base understanding of a couple of concepts, the first of which is what exactly are smart contracts and what's the purpose of them? A basic definition is that a smart contract is a digital contract.
00:00:40.518 - 00:00:42.250, Speaker A: It's stored on a blockchain.
00:00:43.230 - 00:00:56.122, Speaker B: It automatically executes when certain parameters are met. Now, why are they important? Well, they're important for two main reasons, in my opinion. First, they're transparent.
00:00:56.266 - 00:00:58.158, Speaker A: That means anyone can see what the.
00:00:58.164 - 00:01:05.426, Speaker B: Terms of the contract are, and they enable you to know exactly what's going to happen when those conditions are met.
00:01:05.608 - 00:01:07.646, Speaker A: Additionally, they're distributed.
00:01:07.758 - 00:01:11.842, Speaker B: Combined with transparency. The fact that they're distributed means that.
00:01:11.896 - 00:01:15.620, Speaker A: You remove trust from the situation.
00:01:16.950 - 00:01:32.902, Speaker B: In a traditional world, contracts rely on a third party, and they rely on trust that the parties involved in the contract are going to do what they say and honor the terms of the contract. Even when legal systems are fairly robust, this isn't a guarantee.
00:01:33.046 - 00:01:36.234, Speaker A: It's a almost always, most likely things.
00:01:36.272 - 00:01:46.510, Speaker B: Will work out type of promise. And that is something that smart contracts can remove. Smart contracts replace that third party, they replace the trust.
00:01:46.510 - 00:01:57.358, Speaker B: No longer do you have a trust based system of agreements. Now you have a system of agreements which allows users to rely on cryptographic truth.
00:01:57.454 - 00:02:01.554, Speaker A: So we have a truth based agreement system instead of a trust based one.
00:02:01.752 - 00:02:11.046, Speaker B: So that's why smart contracts are so important and so powerful. That transparency, the removal of trust being necessary for them to function, and the.
00:02:11.068 - 00:02:17.726, Speaker A: Distributed nature of them. Now, in order for smart contracts to work, they live on a blockchain.
00:02:17.778 - 00:02:20.502, Speaker B: And blockchains rely on the different nodes.
00:02:20.566 - 00:02:24.650, Speaker A: Within the chain, reaching something called consensus.
00:02:25.790 - 00:02:30.278, Speaker B: What about consensus? How do we reach an agreement within.
00:02:30.464 - 00:02:34.670, Speaker A: A network of nodes for certain values?
00:02:35.170 - 00:02:37.680, Speaker B: Let's take a look at a simple example.
00:02:38.290 - 00:02:44.606, Speaker A: What's one plus one? We can all agree that one plus one is two. It doesn't matter when I ask you.
00:02:44.628 - 00:02:51.922, Speaker B: That question, it doesn't matter where you are when I ask you that question. It doesn't matter about any other input into the system.
00:02:52.056 - 00:02:53.810, Speaker A: One plus one is two.
00:02:53.960 - 00:03:02.390, Speaker B: This is a deterministic value, and blockchains work exceptionally well. In fact, they rely on deterministic values to reach consensus.
00:03:02.730 - 00:03:06.806, Speaker A: If you think about us as a network, when you ask me what one.
00:03:06.828 - 00:03:12.250, Speaker B: Plus one is, I'll tell you two. And when I ask you the same question, you'll give me that same answer.
00:03:12.400 - 00:03:13.894, Speaker A: That means we can reach consensus.
00:03:13.942 - 00:03:16.810, Speaker B: We could come to an agreement on what the answer is.
00:03:16.960 - 00:03:30.350, Speaker A: We all agree that it's two. Now, what if I were to ask you a little bit different style of question. What's the current temperature? It depends.
00:03:30.350 - 00:03:35.380, Speaker A: I mean, it depends on where you are when I ask you this question.
00:03:35.750 - 00:03:50.198, Speaker B: There are other factors that determine the answer to that question. That's a nondeterministic value anytime that you can ask a question. And the answer could be, it depends, you know, that it's a non deterministic value.
00:03:50.198 - 00:03:55.266, Speaker B: And the real world is full of non deterministic values.
00:03:55.378 - 00:03:57.238, Speaker A: In fact, pretty much everything in the.
00:03:57.244 - 00:04:00.014, Speaker B: Real world when it comes to data is nondeterministic.
00:04:00.082 - 00:04:02.220, Speaker A: It's going to depend a lot.
00:04:02.590 - 00:04:05.414, Speaker B: This brings me back to smart contracts.
00:04:05.542 - 00:04:16.990, Speaker A: They have phenomenal power, much like genie, phenomenal cosmic power. But deterministic values mean much like genie. Itty bitty living space, right?
00:04:17.060 - 00:04:27.460, Speaker B: They're confined to blockchains. Traditionally, smart contracts can't reach out to the outside world. That's referred to as the Oracle problem.
00:04:27.460 - 00:04:38.674, Speaker B: Now, this isn't a limitation that we can't overcome, right? We can do something about that. We can help our smart contracts interact.
00:04:38.802 - 00:04:40.118, Speaker A: With the real world.
00:04:40.284 - 00:04:48.750, Speaker B: And Oracles are a solution to the Oracle problem. And that's exactly what Chainlink is. It's an Oracle network.
00:04:48.750 - 00:04:51.770, Speaker B: In fact, it's a distributed Oracle network.
00:04:52.670 - 00:04:54.166, Speaker A: So, just to make sure that we're.
00:04:54.198 - 00:05:06.910, Speaker B: All clear, an Oracle is a device that interacts with off chain data to provide that data to smart contracts. Essentially, this unlocks the full potential of smart contracts.
00:05:07.650 - 00:05:11.562, Speaker A: Now, you may be wondering, could I set up my own Oracle?
00:05:11.706 - 00:05:15.870, Speaker B: The answer to that question is yes, you could set up your own Oracle.
00:05:15.950 - 00:05:16.818, Speaker A: And it would work.
00:05:16.904 - 00:05:19.122, Speaker B: You could bring off chain data on.
00:05:19.176 - 00:05:26.266, Speaker A: Chain and you could own that. But I see that as a bit of a limitation because if you notice.
00:05:26.318 - 00:05:29.506, Speaker B: We have a decentralized network that is the blockchain.
00:05:29.618 - 00:05:36.966, Speaker A: And now you're effectively centralizing it with a centralized node for your Oracle. If something were to happen to that.
00:05:36.988 - 00:05:38.506, Speaker B: Node, or if that node were to.
00:05:38.528 - 00:05:44.490, Speaker A: Be a bad actor, well, you're kind of in trouble because you have centralized that.
00:05:44.560 - 00:05:52.842, Speaker B: And that again is what Chainlink offers. It offers a decentralized Oracle network. So the Oracle network that Chainlink offers.
00:05:52.986 - 00:05:56.878, Speaker A: Is much like the network of a.
00:05:56.884 - 00:05:59.550, Speaker B: Blockchain, where there are multiple nodes participating.
00:05:59.970 - 00:06:04.902, Speaker A: But they are participating in a decentralized fashion.
00:06:05.066 - 00:06:16.014, Speaker B: So there's three main things that we're going to talk about today when it comes to what chainlink offers. The first is data feeds. Next is VRF or Verifiable, randomness functions.
00:06:16.142 - 00:06:19.286, Speaker A: And the third is keepers. So let's take a look at each.
00:06:19.308 - 00:06:20.774, Speaker B: Of these and walk through a quick.
00:06:20.812 - 00:06:22.680, Speaker A: Demo of how to use them.
00:06:23.290 - 00:06:28.614, Speaker B: We'll start with data feeds. Data feeds, as the name implies, are.
00:06:28.652 - 00:06:31.306, Speaker A: About bringing data on chain, feeding that.
00:06:31.328 - 00:06:36.490, Speaker B: Data into a blockchain. And what does this data look like? It can be any data.
00:06:36.560 - 00:06:40.666, Speaker A: It could be market data, bank payments, retail payments.
00:06:40.778 - 00:06:44.346, Speaker B: It could be anything that's available via an API.
00:06:44.538 - 00:06:46.126, Speaker A: The most common use case that we.
00:06:46.148 - 00:06:54.610, Speaker B: See are asset pairs. So let's take a look at data chain link and what this looks like in practice.
00:06:55.590 - 00:06:58.034, Speaker A: If you head to Data Chain Link.
00:06:58.152 - 00:07:08.194, Speaker B: You'Ll see various data feeds. I mentioned that these are asset pairs and if you take a look here, the first one you'll see is ETH in terms of USD.
00:07:08.322 - 00:07:09.960, Speaker A: Let's dive into that one.
00:07:12.250 - 00:07:24.966, Speaker B: What we have on this page is the trusted answer that's going to be the aggregated response from various Oracles. On the right side of the screen you can see all of the different Oracles and the price that they're reporting.
00:07:25.158 - 00:07:27.690, Speaker A: There's a few things to look at on this screen.
00:07:27.840 - 00:07:34.778, Speaker B: The first is that trusted answer. That's going to be the aggregate answer based upon all of the different values reported by the Oracles.
00:07:34.954 - 00:07:37.502, Speaker A: This is how you can overcome the.
00:07:37.556 - 00:07:40.254, Speaker B: Issue of bringing non deterministic value into.
00:07:40.292 - 00:07:43.794, Speaker A: A deterministic landscape like the blockchain, each.
00:07:43.832 - 00:07:51.822, Speaker B: Node reports the price that it thinks is the proper answer to the question of what is the value of ETH in terms of USD.
00:07:51.966 - 00:07:56.486, Speaker A: For this data feed, we take those.
00:07:56.508 - 00:08:09.414, Speaker B: Prices and we use the median value to bring the data that is nondeterministic into a deterministic answer. Given various inputs. When taking the median, you now have created a deterministic question.
00:08:09.414 - 00:08:18.298, Speaker B: Given a set of inputs, what is the median value? That will always come out with the same answer. So this is how you've taken a nondeterministic value and brought it into the.
00:08:18.304 - 00:08:22.106, Speaker A: Blockchain and made it deterministic. On the left hand side, we can.
00:08:22.128 - 00:08:32.126, Speaker B: See that trusted answer as well as the trigger parameters. Those are going to be what causes this price to update on chain. So if the price deviates outside of.
00:08:32.148 - 00:08:38.130, Speaker A: The threshold that's set, or if the heartbeat comes up, that will be just a time based trigger.
00:08:38.550 - 00:08:42.434, Speaker B: If we scroll down on this page, we can find more information about this.
00:08:42.472 - 00:08:45.794, Speaker A: Including the history, as well as more.
00:08:45.832 - 00:08:48.406, Speaker B: Information on each Oracle node and the.
00:08:48.428 - 00:08:52.994, Speaker A: Data that it's reporting. At the bottom, we'll find the users.
00:08:53.042 - 00:08:54.050, Speaker B: Of this data feed.
00:08:54.130 - 00:08:59.980, Speaker A: These are the people who are vested in keeping this data feed accurate and up to date.
00:09:02.110 - 00:09:20.850, Speaker B: Let's head back and talk about the next product. Verifiable randomness functions. Now, you may have gone through a course or learned about how to get a random number on the blockchain using some sort of seed like the block hash.
00:09:20.850 - 00:09:24.174, Speaker B: This works to create a fairly random.
00:09:24.222 - 00:09:26.582, Speaker A: Number, but there's a small issue with.
00:09:26.636 - 00:09:37.794, Speaker B: That and the issue is that those values can be known before they're mined onto the block. What that means is that a malicious.
00:09:37.842 - 00:09:47.494, Speaker A: Actor who is adding blocks to a blockchain can know the outcome of that random number ahead of time. And based on that, they can decide.
00:09:47.542 - 00:09:49.338, Speaker B: Whether or not to add that specific.
00:09:49.424 - 00:09:51.938, Speaker A: Random number to the block that they're mining.
00:09:52.134 - 00:09:54.334, Speaker B: Essentially, I like to think about this.
00:09:54.452 - 00:09:57.018, Speaker A: As if you are rolling a dice.
00:09:57.114 - 00:10:15.554, Speaker B: And you can't necessarily determine what value is going to be rolled when you rolled it. It's still random, but a malicious actor could essentially reroll that dice until they get the outcome that they would like. That's an issue, especially when you need random numbers that are verifiably random.
00:10:15.682 - 00:10:17.606, Speaker A: That's where chainlink comes in.
00:10:17.788 - 00:10:20.886, Speaker B: Chainlink will provide a verifiably random number.
00:10:21.068 - 00:10:23.314, Speaker A: From the Oracle network to a smart.
00:10:23.362 - 00:10:39.770, Speaker B: Contract, and this prevents the miners from being able to act in that malicious fashion. Additionally, I mentioned that it was verifiably random. There's a cryptographic proof included with the random number that will demonstrate how that number was generated.
00:10:39.770 - 00:10:52.400, Speaker B: Next, let's take a look at keepers. Chainlink keepers are a way to automate smart contracts.
00:10:52.820 - 00:10:55.160, Speaker A: We talked earlier about how smart contracts.
00:10:55.180 - 00:11:05.300, Speaker B: Are like Genie from Aladdin. And one other factor about smart contracts is they are exceptionally lazy. They're not going to do anything without an input.
00:11:05.300 - 00:11:10.244, Speaker B: Something needs to call a function within a smart contract in order for it to execute.
00:11:10.372 - 00:11:15.256, Speaker A: That's where Keepers comes in. Keepers will allow you to take a.
00:11:15.278 - 00:11:18.392, Speaker B: Smart contract and based upon either time.
00:11:18.446 - 00:11:22.956, Speaker A: Based or a custom function, execute the.
00:11:22.978 - 00:11:24.940, Speaker B: Code within that smart contract.
00:11:25.280 - 00:11:28.940, Speaker A: Now again, you could create your own.
00:11:29.090 - 00:11:32.944, Speaker B: Node that would call smart contracts, much in the same way as you could.
00:11:32.982 - 00:11:38.444, Speaker A: Use your own node to get a piece of information off chain on Chain.
00:11:38.572 - 00:11:48.432, Speaker B: But the keepers network again brings that decentralized network where you have again the benefit of decentralization, and you can ensure.
00:11:48.496 - 00:11:52.020, Speaker A: That your contract will be executed in the same fashion.
00:11:53.080 - 00:12:02.280, Speaker B: Now, let's dive into some code and take a look at each of these products a little bit more closely and see how you'd actually use them in a smart contract.
00:12:02.780 - 00:12:10.056, Speaker A: So the first thing to know is that when it comes to examples and code with Chainlink, you're going to want.
00:12:10.078 - 00:12:20.520, Speaker B: To go to Docs Chain Link. This is the best place to start when it comes to finding up to date information as well as examples. We'll start with data feeds.
00:12:20.680 - 00:12:21.868, Speaker A: If we head down here, we can.
00:12:21.874 - 00:12:32.364, Speaker B: See that the supported blockchains is broken up into two different areas. The first being EVM chains, the second being Solana. Solana is separate because it's kind of a different beast.
00:12:32.412 - 00:12:34.496, Speaker A: If you've ever used any of the.
00:12:34.518 - 00:12:42.390, Speaker B: Programming tools around the Solana ecosystem, you'll know they are much different than Solidity. So that's why it's broken off into its own space.
00:12:43.160 - 00:12:44.980, Speaker A: Let's start with data feeds.
00:12:45.320 - 00:12:52.756, Speaker B: If we head to data feeds, we can learn about data feeds and we can learn about using data feeds. That's where we'll head using data feeds.
00:12:52.948 - 00:12:54.856, Speaker A: Right here on this page you can.
00:12:54.878 - 00:12:58.436, Speaker B: See an example contract, and this contract.
00:12:58.628 - 00:13:00.132, Speaker A: Will allow you to get the price.
00:13:00.206 - 00:13:11.208, Speaker B: Feed for ETH in terms of USD. Let's go ahead and open this in Remix. Now, if you're not familiar, Remix is a web based IDE for solidity.
00:13:11.208 - 00:13:15.900, Speaker B: This means that we can both deploy and interact with contracts on Blockchains.
00:13:15.980 - 00:13:16.768, Speaker A: It's pretty great.
00:13:16.854 - 00:13:28.224, Speaker B: And you can do it all from your browser. Let's take a look at this contract and see what exactly we're doing. The first thing you'll notice is that we're declaring the Solidity version.
00:13:28.224 - 00:13:41.130, Speaker B: Then we're importing a contract called Aggregator v Three interface. That's going to give us the interface to the price feed aggregator contract. We have our contract called Price Consumer v three.
00:13:42.300 - 00:13:43.192, Speaker A: On line eight.
00:13:43.246 - 00:13:54.604, Speaker B: You can see that we are setting up a price feed that is one of those aggregator interfaces. There's some notes talking about what network we're going to be using, as well as what the aggregator is and an.
00:13:54.642 - 00:13:57.196, Speaker A: Address, something to keep in mind.
00:13:57.298 - 00:14:04.930, Speaker B: Each asset pair aggregator has its own address. You can find those in the documentation. I'll show you that in just a moment.
00:14:04.930 - 00:14:07.184, Speaker B: We have our constructor which goes ahead.
00:14:07.222 - 00:14:09.196, Speaker A: And sets up the price feed.
00:14:09.308 - 00:14:24.132, Speaker B: And keep in mind, constructors are only run when a contract is deployed. They kind of set up things that need to be configured when that contract is deployed. And finally we have our function get latest price.
00:14:24.132 - 00:14:39.860, Speaker B: It's going to return one value, the price. Now this looks a little strange. We have all of these commented out values and the reason for that is, within Solidity, you need to account for every single value that a function returns.
00:14:39.860 - 00:14:48.924, Speaker B: This latest round data function will actually return a round ID the price when the round started a timestamp and what.
00:14:48.962 - 00:14:50.524, Speaker A: Round it was answered in.
00:14:50.642 - 00:15:01.232, Speaker B: But we're only interested in the price. So you can either comment them out or just delete them completely. It looks a little strange because essentially the signature for this function would be.
00:15:01.286 - 00:15:04.396, Speaker A: Comma int price comma comma comma.
00:15:04.588 - 00:15:13.190, Speaker B: Again, those are commented out there just for readability and understandability of this example contract. Finally, we take that price and we return it.
00:15:13.720 - 00:15:14.404, Speaker A: That's it.
00:15:14.442 - 00:15:20.520, Speaker B: It's a pretty straightforward and simple contract, but let's take a look at how to deploy it. If we head on over here to.
00:15:20.590 - 00:15:24.088, Speaker A: The Deploy and Run transactions, we'll need.
00:15:24.094 - 00:15:31.828, Speaker B: To ensure that our environment is our injected provider. That will take the wallet from your browser and inject it into remix so.
00:15:31.854 - 00:15:36.188, Speaker A: That you can interact with the blockchain. In this example, I'm using Brave and.
00:15:36.194 - 00:15:37.768, Speaker B: I'm also using the Brave wallet.
00:15:37.864 - 00:15:40.940, Speaker A: But it functions basically the same as MetaMask.
00:15:41.280 - 00:15:53.360, Speaker B: We'll also need to select the correct contract. Anytime you have a contract that imports other contracts, they will be available here to be deployed. So just keep that in mind and make sure that you're selecting the correct contract.
00:15:53.780 - 00:16:00.724, Speaker A: And finally we can click Deploy. We'll need to approve the transaction and.
00:16:00.762 - 00:16:04.436, Speaker B: Wait for it to actually be deployed. We should see a green checkmark down.
00:16:04.458 - 00:16:07.700, Speaker A: At the bottom of our screen once it is deployed.
00:16:09.720 - 00:16:20.632, Speaker B: All right, we've got that green checkmark and we can see on the left hand side we have our deployed contract. If we open that up, we can see all of the functions that were deployed within our contract. Now we only have one.
00:16:20.632 - 00:16:26.428, Speaker B: It's get latest price. Let's see what it returns. When we click it, we can see that we get this price.
00:16:26.514 - 00:16:29.276, Speaker A: And this price seems like it may.
00:16:29.298 - 00:16:30.716, Speaker B: Be a bit out of line with.
00:16:30.738 - 00:16:35.856, Speaker A: The current price of ETH. But there's something to remember when it.
00:16:35.878 - 00:16:43.900, Speaker B: Comes to pricing data. Solidity doesn't have the concept of decimals. That means that we need to somehow account for decimals.
00:16:43.900 - 00:17:04.840, Speaker B: And the way that we do this is by multiplying a result by ten to the 8th power in this case. So we'll need to insert our decimal to understand what this price actually is. If we were to go 1234-5678 places and insert a decimal point there, we would see that the price returned is actually 1917.
00:17:04.840 - 00:17:12.664, Speaker B: So just like that, we have gotten a price data from an off chain resource on chain.
00:17:12.792 - 00:17:13.500, Speaker A: That's awesome.
00:17:13.570 - 00:17:24.464, Speaker B: And I think it was pretty simple and pretty quick. Next we're going to take a look at VRF or Verifiable randomness functions. Let's go ahead and take a look at that.
00:17:24.502 - 00:17:25.090, Speaker A: Now.
00:17:26.900 - 00:17:34.880, Speaker B: Again we'll start at the documentation page. So docs chain link. If we scroll down we'll go to randomness or VRF.
00:17:34.880 - 00:17:44.084, Speaker B: Now, here again we can learn about how to use randomness how chainlink VRF works. But I'm jumping straight into get a.
00:17:44.122 - 00:17:47.572, Speaker A: Random number for this one.
00:17:47.626 - 00:18:02.360, Speaker B: We're going to need another asset. Not only will we need testnet ETH, but we'll also need testnet link tokens. This will allow us to create a subscription that we can fund in order to get our random values.
00:18:02.360 - 00:18:07.884, Speaker B: So if we follow the instructions here, we can open our wallet and make sure that we are on the Go.
00:18:07.922 - 00:18:13.424, Speaker A: Early test network I am. We can then go to the Go.
00:18:13.462 - 00:18:16.000, Speaker B: Early Faucet and get some testnet link.
00:18:16.070 - 00:18:25.696, Speaker A: Or ETH if we need them. And then we can go to the subscription manager. Now, subscription, essentially the way I like.
00:18:25.718 - 00:18:31.590, Speaker B: To think about it is it's a bucket of link that we can allow other contracts to use.
00:18:32.200 - 00:18:34.144, Speaker A: So we'll create a subscription.
00:18:34.272 - 00:18:39.784, Speaker B: It will auto fill our address if we've connected our wallet. You may have been prompted to connect your wallet when you came to this.
00:18:39.822 - 00:18:45.880, Speaker A: Page the first time. We'll create our subscription and we'll need to approve that subscription.
00:18:48.460 - 00:18:51.436, Speaker B: Once that's approved and verified, then we.
00:18:51.458 - 00:18:53.580, Speaker A: Can go and fund our subscription.
00:18:56.080 - 00:18:57.756, Speaker B: And while we're waiting for this to.
00:18:57.778 - 00:19:03.096, Speaker A: Approve, something to keep in mind is the way that subscriptions work is we.
00:19:03.138 - 00:19:33.380, Speaker B: Need to create a subscription, we'll get a subscription ID, then we'll create our contract to interact with that subscription and when we deploy it, we'll let our contract know about the subscription ID. Once we have deployed our contract, we'll come back to our subscription and let our subscription know about the address of the contract we've created. Essentially we need to let the contract know about the subscription and let the subscription know about the contract.
00:19:33.380 - 00:19:43.390, Speaker B: All right, so we've got our subscription created and now we can add funds to it. I'll go ahead and just add five link. Again, we'll need to approve this transaction as well.
00:19:43.390 - 00:19:53.848, Speaker B: While we wait for this to happen, let's head back to the documentation and take a look at what we need to do next. We've gone ahead and created our subscription.
00:19:53.944 - 00:19:55.304, Speaker A: We've added funds.
00:19:55.432 - 00:20:03.424, Speaker B: After we add funds, we'll need to add that consumer. That's going to be the address of the contract that we deploy. But we haven't deployed a contract yet.
00:20:03.424 - 00:20:10.144, Speaker B: Let's scroll down and see if we can find an example. Create and deploy a VRF v two compatible contract. Fantastic.
00:20:10.144 - 00:20:23.492, Speaker B: We'll go ahead and open this contract in remix and take a look at what it does. So again, kind of similar to the other contract. We're declaring the version of Solidity to use and we're importing a couple of contracts from chainlink.
00:20:23.492 - 00:20:35.980, Speaker B: The first is a coordinator that will allow us to request that randomness value. And then we have a consumer that's going to be helping us here in this contract. Go ahead and consume the values returned from the coordinator.
00:20:35.980 - 00:20:44.864, Speaker B: We see that our contract here is using that consumer base V Two. We set up the coordinator interface. We have a few values here.
00:20:44.864 - 00:20:49.356, Speaker B: We have a subscription ID that will be that subscription that we just created.
00:20:49.468 - 00:20:51.612, Speaker A: We have the address for the coordinator.
00:20:51.756 - 00:21:01.540, Speaker B: One thing to keep in mind, this address again will change based on the chain that you're on at the end of this demo. I'll go ahead and show you where you can find these different addresses.
00:21:02.840 - 00:21:11.700, Speaker A: We have a key hash. The key hash is also going to be dependent upon the network you're on. We have a callback gas limit.
00:21:11.860 - 00:21:20.504, Speaker B: This limit is going to be the maximum amount of gas that the fulfill random words will be allowed to use. Depending on what your fulfill random words.
00:21:20.622 - 00:21:23.768, Speaker A: Function does will determine how much you.
00:21:23.774 - 00:21:32.848, Speaker B: Need to set this to. For the example, this will work just fine. We have our request confirmation that's how many blocks need to be confirmed before the request is sent back to us.
00:21:32.848 - 00:21:34.370, Speaker B: Number of words.
00:21:35.060 - 00:21:36.768, Speaker A: In this instance it's two.
00:21:36.854 - 00:21:39.536, Speaker B: That means we'll get two random values back.
00:21:39.638 - 00:21:46.516, Speaker A: Now, words is a computer science term that is technically correct, but sometimes I.
00:21:46.538 - 00:21:52.084, Speaker B: Think it can be confusing to people when they first come to these contracts. When we're talking about VRF and you.
00:21:52.122 - 00:21:56.100, Speaker A: See words, just think random values.
00:21:57.480 - 00:22:00.276, Speaker B: We have an array to store the random values returned.
00:22:00.388 - 00:22:02.792, Speaker A: We have a value to keep track.
00:22:02.846 - 00:22:13.500, Speaker B: Of our request ID. We don't really do much with it in the example here, but if you had multiple calls for different things being made, you could map a request ID.
00:22:13.570 - 00:22:14.748, Speaker A: To a specific thing.
00:22:14.834 - 00:22:35.324, Speaker B: Take for instance NFTs if you are using random values with an NFT, you may want to map the NFT ID to the request ID to keep track of which request is for which NFT. And then we also have the owner of the contract. We have our constructor, which remember, constructors are run when the contract is deployed.
00:22:35.324 - 00:22:42.756, Speaker B: This constructor takes a value in we'll need to supply our subscription ID. Then we set up the coordinator, the.
00:22:42.778 - 00:22:46.390, Speaker A: Owner, and we also set that subscription ID to what we passed in.
00:22:48.620 - 00:22:58.456, Speaker B: Next, we have our request. Random words function. This function essentially reaches out to that VRF coordinator and says, hey, I'd like some random values, please.
00:22:58.456 - 00:23:05.756, Speaker B: And it passes in all the information that we've set above, like the key hash, the subscription ID, the number of confirmations, the gas limit, and the number.
00:23:05.778 - 00:23:07.390, Speaker A: Of words that we're looking for.
00:23:07.840 - 00:23:18.668, Speaker B: Once that coordinator actually generates the random values, it will then come back to our contract and call the Fulfill Random Words function. This is where you would use those random values.
00:23:18.764 - 00:23:20.576, Speaker A: In this case, we're just storing them.
00:23:20.678 - 00:23:22.544, Speaker B: But if you wanted to do something.
00:23:22.582 - 00:23:28.000, Speaker A: With the random values, you'd put that in here. And finally, we have a only owner.
00:23:28.080 - 00:23:40.356, Speaker B: Modifier just to make sure that only the owner can request random words. All right, so let's take a look at deploying this again, make sure your environment is correct as well as your contract.
00:23:40.548 - 00:23:43.112, Speaker A: You'll notice this contract, it needs a value.
00:23:43.166 - 00:23:47.032, Speaker B: It needs that subscription ID. So let's head back to the Create.
00:23:47.086 - 00:23:53.096, Speaker A: Subscription and grab that subscription. It's asking us for a consumer address.
00:23:53.278 - 00:24:01.964, Speaker B: That'S going to be the address of the contract that we're about to deploy. But our subscription ID for this example is 101. Now, when you create a subscription, your.
00:24:02.002 - 00:24:03.230, Speaker A: ID will be different.
00:24:04.160 - 00:24:06.624, Speaker B: Back here, we'll give 101 to our.
00:24:06.662 - 00:24:21.476, Speaker A: Deploy and we'll go ahead and run this transaction, confirm it, and we'll wait for that green checkmark. That means that our contract has been deployed successfully. While we wait, let's go ahead and.
00:24:21.498 - 00:24:25.380, Speaker B: Take a look at where you would find the different values for the different chains.
00:24:25.960 - 00:24:27.956, Speaker A: I mentioned in Data feeds that we.
00:24:27.978 - 00:24:37.800, Speaker B: Could take a look at that as well. Here under Data feeds in our documentation, you can see contract addresses and all of the different chains on which we have data feeds.
00:24:38.460 - 00:24:40.888, Speaker A: You can see each of the chains.
00:24:40.984 - 00:24:45.390, Speaker B: And the asset pair as well as the address that you would need to provide.
00:24:46.080 - 00:24:49.756, Speaker A: Similarly, under Using Randomness for VRF, we.
00:24:49.778 - 00:25:02.460, Speaker B: Have a contract addresses section as well. This will include the coordinator, the link token, some different hashes depending on which gas lane you would want to use. If you're on a main net, there's multiple gas lanes.
00:25:02.540 - 00:25:07.348, Speaker A: Most of the testnets just have one gas lane. But you can find the different information.
00:25:07.434 - 00:25:10.660, Speaker B: That you need for different networks here in the documentation.
00:25:11.320 - 00:25:17.510, Speaker A: All right, we should be deployed and we are fantastic. So there's a couple of things to look at.
00:25:18.040 - 00:25:25.016, Speaker B: Once we have given our contract address back to our subscription. So we'll copy our contract address. This is the contract that we just.
00:25:25.038 - 00:25:34.076, Speaker A: Deployed and we'll put it here as a consumer. Again, we'll need to approve this transaction and once this is approved, we can.
00:25:34.098 - 00:25:49.644, Speaker B: Go and actually look at our subscription. It'll have some interesting information like the history, what our current link balance is, how much each consumer has used of that balance, and information like that. All right, our consumer has been added.
00:25:49.644 - 00:25:56.756, Speaker B: Let's go ahead and view our subscription. So, as I mentioned here, you can see all of the information about the.
00:25:56.778 - 00:26:02.036, Speaker A: Subscription and let's go ahead and call our subscription here.
00:26:02.138 - 00:26:04.870, Speaker B: So we'll request random words.
00:26:05.640 - 00:26:08.996, Speaker A: We'll approve this transaction and once it's.
00:26:09.028 - 00:26:11.096, Speaker B: Been successfully submitted, we should be able.
00:26:11.118 - 00:26:17.556, Speaker A: To see it in our subscription. All right, it's been submitted.
00:26:17.668 - 00:26:20.476, Speaker B: Before we head to our subscription, we can take a look and we can.
00:26:20.498 - 00:26:27.736, Speaker A: See our request ID. Cool. Let's head to the subscription and refresh.
00:26:27.768 - 00:26:29.500, Speaker B: This page and take a look at what it says.
00:26:29.570 - 00:26:33.880, Speaker A: Now, so you can see we have this pending transaction.
00:26:34.040 - 00:26:50.768, Speaker B: That means that we are requesting randomness, but it hasn't been fulfilled yet. Remember, we have to wait for those block confirmations. The amount of time that this takes can vary depending on which blockchain you're on, how fast blocks are mined, as well as how many confirmations.
00:26:50.864 - 00:26:54.196, Speaker A: You're requesting confirmations, you can increase the.
00:26:54.218 - 00:26:57.572, Speaker B: Number and end up with a more secure random number.
00:26:57.706 - 00:27:00.984, Speaker A: But the tradeoff is speed, so more.
00:27:01.022 - 00:27:07.464, Speaker B: Secure but slower, or a little bit less secure but faster. Again, it's a verifiably random number, so.
00:27:07.662 - 00:27:15.542, Speaker A: You can trust that it's random when it comes in. All right, so we refresh the page.
00:27:15.596 - 00:27:30.620, Speaker B: And we can see now our history. No longer is it pending, we have our randomness and we can see that we've gotten a response back in our subscription page. We can see how much link it cost, and we can see that our one consumer has spent that same amount.
00:27:31.150 - 00:27:33.206, Speaker A: One nice thing about this subscription interface.
00:27:33.238 - 00:27:54.926, Speaker B: Is you could add another contract from the same subscription and have two consumers or more using that one source of link. If we head back to our contract in Remix, we can now take a look at the random words. Something to keep in mind, this is an array, so it's going to have two values because that's how many we requested in this contract.
00:27:54.926 - 00:28:06.662, Speaker B: Arrays work with a zero based indexing system. So the first value would be zero, the second would be one. So if we look at the first value, zero, we can get the result of our random number.
00:28:06.662 - 00:28:07.814, Speaker B: Again, if we take a look at.
00:28:07.852 - 00:28:14.540, Speaker A: Number one, which would be the second value in the array, we'll see that it's a different random number.
00:28:15.150 - 00:28:17.034, Speaker B: So just like that, we've set up.
00:28:17.072 - 00:28:26.378, Speaker A: A subscription and deployed a contract to generate provably random numbers in Solidity. That's awesome.
00:28:26.544 - 00:28:49.390, Speaker B: Let's head to the final thing, chainlink Keepers. All right, as always, we're going to head to Docs Chain Link as our place to start and then we'll head to automate contracts because that's what we want to do. We want to automate a contract with Chainlink Keepers.
00:28:49.390 - 00:29:06.642, Speaker B: Now when it comes to contract, Automation Keepers version one two just came out and there are two ways to automate contracts. Now the first is time based. If you're familiar with operating systems that are Linux based, you may be familiar with a command called Cron.
00:29:06.642 - 00:29:09.026, Speaker B: Cron is essentially a time based triggering.
00:29:09.058 - 00:29:19.942, Speaker A: System for Linux Unix systems. Chainlink Keepers uses the same sort of interface to generate the time based automations.
00:29:20.086 - 00:29:26.674, Speaker B: If you're not familiar with what a Cron tab looks like or how to set up a Cron tab, I recommend a website, Crontab Guru.
00:29:26.822 - 00:29:28.958, Speaker A: It will take you through everything you.
00:29:28.964 - 00:29:33.486, Speaker B: Need to know and explain what the different values in a Cron tab are. We can take a quick look at it.
00:29:33.508 - 00:29:34.080, Speaker A: Now.
00:29:36.690 - 00:29:52.886, Speaker B: This website will let you pick random Cron tab values and it puts them in what is essentially plain English at the top. Cron tab is broken down into five different sections. It's going to be the minutes, the hour, the day, the month, and then the day of the week.
00:29:52.988 - 00:29:56.006, Speaker A: The first day being the date of the month.
00:29:56.188 - 00:29:58.306, Speaker B: This is a great resource if you'd.
00:29:58.338 - 00:30:00.534, Speaker A: Like to look into it more, but.
00:30:00.572 - 00:30:07.354, Speaker B: Just something I've found helpful when it comes to ensuring that a Cron tab I create is doing what I think it's doing.
00:30:07.552 - 00:30:09.690, Speaker A: But let's head back to the documentation.
00:30:11.550 - 00:30:19.502, Speaker B: We're going to take a look at time based automation first and then we will take a look at custom logic and we will do the same thing.
00:30:19.556 - 00:30:20.398, Speaker A: In both of them.
00:30:20.484 - 00:30:28.370, Speaker B: And what we're going to do is we're going to deploy a contract that has one value, a counter, and it will increment that counter on a regular basis.
00:30:29.190 - 00:30:38.146, Speaker A: So the first thing we need to do is we need to head to Keepers Chain Link. Again, this is going to be similar.
00:30:38.248 - 00:30:50.040, Speaker B: To VRF in that we'll need to create a new upkeep similar to VRF subscriptions, but slightly different. So let's register a new upkeep. And I mentioned that we're going to do time based.
00:30:50.040 - 00:30:53.020, Speaker B: Now we're running into the first problem.
00:30:53.790 - 00:30:55.014, Speaker A: We need a contract.
00:30:55.142 - 00:30:57.130, Speaker B: So let's head to remix.
00:30:59.150 - 00:31:11.470, Speaker A: So it's remix Ethereum.org and we will create our own smart contract. We'll just call it Count Soul.
00:31:12.370 - 00:31:31.602, Speaker B: All right, what do we need for our basic smart contract? The first thing we'll need to do is tell it what version of solidity we need. And we can just kind of follow along with the same values that we've been using. We also need to name our contract.
00:31:31.746 - 00:31:33.270, Speaker A: We'll call it counter.
00:31:34.490 - 00:31:37.734, Speaker B: And within counter we can create a.
00:31:37.772 - 00:31:41.450, Speaker A: Value, a UN called counter.
00:31:42.030 - 00:31:46.220, Speaker B: And we can make this counter be public. That means anyone can access it outside.
00:31:48.190 - 00:31:53.646, Speaker A: We'll need our constructor and we don't.
00:31:53.678 - 00:32:08.060, Speaker B: Actually need to do anything in our constructor here. So we'll just have it other than set counter equal to zero. So when this contract is deployed, we'll set our counter equal to zero and then we can create a function and we can call it Count.
00:32:09.790 - 00:32:11.674, Speaker A: It'll take nothing in and what it.
00:32:11.712 - 00:32:13.990, Speaker B: Will do is it will say counter.
00:32:14.150 - 00:32:17.180, Speaker A: Equals counter plus one.
00:32:17.790 - 00:32:29.840, Speaker B: This will allow us to increment our counter. Now this function, we're going to need to call it from outside of our contract, so it will be external. That means that we can call it from outside, but not inside.
00:32:30.210 - 00:32:31.118, Speaker A: And that's it.
00:32:31.204 - 00:32:42.674, Speaker B: This is our entire contract. It looks like I'm missing a semicolon up here. Make sure you have your semicolons and yeah, we've got our contract, so let's go ahead and deploy this contract again.
00:32:42.674 - 00:32:46.258, Speaker B: We'll make sure that we inject and we pick the right one and we'll.
00:32:46.274 - 00:32:47.750, Speaker A: Go ahead and deploy.
00:32:49.450 - 00:32:58.906, Speaker B: Now when this is deployed, we can then have the address and give that to our new upkeep that we're creating. That upkeep is going to need to.
00:32:58.928 - 00:33:04.438, Speaker A: Be informed what can actually be done with our contract.
00:33:04.614 - 00:33:07.354, Speaker B: If you verify a contract on the.
00:33:07.392 - 00:33:10.806, Speaker A: Block Explorer of that network, the Keeper.
00:33:10.838 - 00:33:18.798, Speaker B: Interface can go ahead and read that information in this contract's not verified, we'll copy the address of it and we'll come here and we'll take a look.
00:33:18.804 - 00:33:20.160, Speaker A: At what we need to do next.
00:33:20.850 - 00:33:28.622, Speaker B: It couldn't fetch the Abi because the contract's not verified. So we'll need to provide the Abi. That's the application binary interface.
00:33:28.622 - 00:33:32.942, Speaker B: Essentially, it lets other programs know what can we do with this contract.
00:33:33.086 - 00:33:37.246, Speaker A: Where do we find the Abi? In Remix, right here under our compiler.
00:33:37.358 - 00:33:44.690, Speaker B: We can make sure that we pick the correct contract. And then there's this Abi button right here. When you click it, it will copy the Abi to your clipboard.
00:33:44.770 - 00:33:48.578, Speaker A: So we'll head back and paste it in. We can see it gives it some.
00:33:48.604 - 00:33:53.706, Speaker B: Information about what the inputs are and what the different functions are and we can do next.
00:33:53.888 - 00:33:56.186, Speaker A: Now that we provided the Abi, the.
00:33:56.208 - 00:34:00.742, Speaker B: Keeper's interface is aware of what functions there are available in our contract.
00:34:00.886 - 00:34:02.234, Speaker A: This is a pretty simple contract.
00:34:02.282 - 00:34:06.000, Speaker B: It has one function, so we'll select that function and click Next.
00:34:06.450 - 00:34:08.254, Speaker A: Here's where Cron comes in.
00:34:08.372 - 00:34:14.378, Speaker B: So this Cron will give us some things that we can do, like every 15 minutes, every hour, the first of.
00:34:14.404 - 00:34:16.722, Speaker A: Every month, we'll pick every 15 minutes.
00:34:16.776 - 00:34:18.114, Speaker B: To start with and then we'll change.
00:34:18.152 - 00:34:20.350, Speaker A: It to be maybe a little bit faster.
00:34:20.510 - 00:34:22.594, Speaker B: So we'll say every minute we want.
00:34:22.632 - 00:34:26.526, Speaker A: This Keeper to execute, so every minute.
00:34:26.558 - 00:34:32.360, Speaker B: We should see an increase in our counter. We'll name this upkeep, we'll say Count.
00:34:32.730 - 00:34:34.406, Speaker A: We'Ll give it a gas limit and.
00:34:34.428 - 00:34:39.714, Speaker B: We can go ahead and just go with the default here. Again, this is going to be a limit based upon the amount of gas.
00:34:39.762 - 00:34:42.234, Speaker A: That your function needs, we do ask.
00:34:42.272 - 00:34:49.166, Speaker B: For an email address. This is to provide information based on your upkeep. If you have an issue, like you're running out of link or something like.
00:34:49.188 - 00:34:56.120, Speaker A: That, and we can register our upkeep.
00:34:56.200 - 00:34:58.636, Speaker B: Again, this will take some confirmations from.
00:34:58.658 - 00:35:03.980, Speaker A: Your wallet and it will also transfer some link from your wallet to your Keeper.
00:35:06.580 - 00:35:11.824, Speaker B: This does take two confirmations and once they have been confirmed, our upkeep should.
00:35:11.862 - 00:35:13.410, Speaker A: Be ready to go.
00:35:15.460 - 00:35:17.388, Speaker B: All right, our upkeep has been registered.
00:35:17.404 - 00:35:20.868, Speaker A: Let's take a look at it. We can see here all of the.
00:35:20.874 - 00:35:28.820, Speaker B: History and all of the information, as well as a projected time of next execution. This one's pretty straightforward because it's running every minute.
00:35:29.320 - 00:35:31.784, Speaker A: Once our upkeep has run, we should.
00:35:31.822 - 00:35:33.720, Speaker B: See that our counter has increased.
00:35:34.700 - 00:35:38.196, Speaker A: Now, while we're waiting for this upkeep.
00:35:38.228 - 00:35:50.952, Speaker B: To run, let's head back to the documentation and take a look at custom logic. Again, we'll need to register a new upkeep and we'll need to have a contract that is deployed that's a Keeper compatible contract.
00:35:51.096 - 00:35:52.316, Speaker A: So if we look at creating a.
00:35:52.338 - 00:35:59.420, Speaker B: Keeper compatible contract, it requires two things, the first of which is a check upkeep function that will return a Boolean.
00:35:59.500 - 00:36:02.144, Speaker A: As well as possibly some data that.
00:36:02.182 - 00:36:08.272, Speaker B: Lets us know if we need to actually perform upkeep. And that tells us what the second function is. It's perform upkeep.
00:36:08.272 - 00:36:29.668, Speaker B: So with a check upkeep function and a perform upkeep function, we have a Keepers compatible contract. Now, there are example contracts here and we can scroll down and see one. This contract essentially does the exact same thing as our other contract, but it's a little bit more involved because we are using that custom logic.
00:36:29.668 - 00:36:32.292, Speaker B: So let's open this example in remix.
00:36:32.436 - 00:36:34.924, Speaker A: And take a look at it as well.
00:36:35.122 - 00:36:39.800, Speaker B: So again, we have our solidity version and we import Keeper compatible interface.
00:36:39.960 - 00:36:42.184, Speaker A: We set up our contract named counter.
00:36:42.312 - 00:36:51.152, Speaker B: And we create our public value of counter. We create two other variables as well. The first is an interval that's going to be how often we want this to run.
00:36:51.206 - 00:36:53.568, Speaker A: In this case, remember, we're doing the.
00:36:53.574 - 00:36:55.916, Speaker B: Same functionality, but we're using custom logic.
00:36:55.948 - 00:36:58.232, Speaker A: Instead of strictly time based logic.
00:36:58.396 - 00:37:00.896, Speaker B: We keep track of the last timestamp.
00:37:00.928 - 00:37:05.504, Speaker A: That's going to be the block timestamp in our constructor.
00:37:05.552 - 00:37:12.516, Speaker B: We'll pass in the interval in seconds of how often we want to update this. And we'll set our last timestamp to.
00:37:12.538 - 00:37:14.536, Speaker A: The current block's timestamp, as well as.
00:37:14.558 - 00:37:18.804, Speaker B: Setting our counter to zero. We then dive into two functions.
00:37:18.852 - 00:37:21.432, Speaker A: The first is check upkeep, which takes.
00:37:21.486 - 00:37:33.292, Speaker B: In some call data as well as providing the upkeep needed and the perform data if we have it. In this example, we're just passing back upkeep needed that Boolean value.
00:37:33.346 - 00:37:33.612, Speaker C: True.
00:37:33.666 - 00:37:34.392, Speaker A: False.
00:37:34.536 - 00:37:37.152, Speaker B: So upkeep needed will be determined by.
00:37:37.206 - 00:37:40.956, Speaker A: Looking at the block timestamp subtracting.
00:37:40.988 - 00:37:42.848, Speaker B: The last time that we did something.
00:37:43.014 - 00:37:44.448, Speaker A: The first time this runs, that'll be.
00:37:44.454 - 00:37:48.688, Speaker B: When the contract was created. But as we'll see and perform upkeep, it could be the last time that.
00:37:48.694 - 00:37:50.756, Speaker A: We had performed upkeep and seeing if.
00:37:50.778 - 00:37:54.880, Speaker B: Those two time variances are greater than the interval.
00:37:54.960 - 00:38:00.536, Speaker A: If it is, that value is going to be true and we need to perform upkeep. So what does Perform upkeep do? Again?
00:38:00.558 - 00:38:23.804, Speaker B: It takes in that perform data and it checks once more to ensure that we actually need to do our upkeep. And it's important to do this because you always want to make sure before you make a change on chain that you are actually needing to do it. So we check again that block timestamp minus the last timestamp, is that greater than our interval? If it is, we'll update the last.
00:38:23.842 - 00:38:28.560, Speaker A: Timestamp and we'll add one to the counter. It's doing the exact same thing.
00:38:28.630 - 00:38:33.164, Speaker B: It's a little bit more involved because this perform upkeep and check upkeep methods.
00:38:33.212 - 00:38:36.416, Speaker A: Allow you to have any validation that.
00:38:36.438 - 00:38:48.032, Speaker B: You need to check if you actually need upkeep. You could look at things like pricing, wallet balances. Essentially the sky's the limit when it comes to what you can do with custom upkeep functions.
00:38:48.176 - 00:38:54.330, Speaker A: So before we dive into adding this to a Keeper, let's deploy it first.
00:38:55.420 - 00:39:02.424, Speaker B: Same thing that we've been doing this whole time, injected. And we'll make sure that we pick the correct one here. We'll send it an interval.
00:39:02.424 - 00:39:05.928, Speaker B: We'll say 60 seconds and click deploy.
00:39:06.104 - 00:39:08.136, Speaker A: We'll confirm this and while we're waiting.
00:39:08.168 - 00:39:13.180, Speaker B: For this to deploy, we'll head back to our other time based Keeper.
00:39:15.040 - 00:39:17.280, Speaker A: If we head here and refresh our.
00:39:17.350 - 00:39:39.260, Speaker B: Keeper details, we can see that, hey, it's actually run twice while we've been waiting. So if we look at our contract that has been deployed and we take a look here at what our counter is set to, you can see our counter has now changed to two. So this contract is incrementing itself automatically on a time based interval of 1 minute, roughly.
00:39:39.360 - 00:39:41.704, Speaker A: Again, the time based intervals of very.
00:39:41.742 - 00:39:47.508, Speaker B: Low values like that can be less than perfectly accurate just because we're requiring.
00:39:47.604 - 00:39:50.264, Speaker A: A block to be mined when we check.
00:39:50.462 - 00:39:56.968, Speaker B: So depending on what chain you're on, that could be a little bit tricky when it comes to very small time based values.
00:39:57.064 - 00:40:01.148, Speaker A: Just something to keep in mind. All right, so this counter is working.
00:40:01.234 - 00:40:03.580, Speaker B: On a time based interval. That's amazing.
00:40:03.730 - 00:40:08.224, Speaker A: We'll go ahead and close this down just to keep things simple. And we'll head back here.
00:40:08.262 - 00:40:12.816, Speaker B: Our contract is deployed now, so we'll copy this contract and we'll head back.
00:40:12.838 - 00:40:22.900, Speaker A: To creating a Keeper. So where do we need to go? We need to go to Keepers chain link. All right.
00:40:22.970 - 00:40:31.300, Speaker B: And we'll register a new upkeep here. And this time we'll pick custom logic. We'll enter the address of the contract we just deployed and it'll try to verify it as well.
00:40:31.370 - 00:40:33.736, Speaker A: If our contract was verified, it would.
00:40:33.758 - 00:40:43.476, Speaker B: Be able to ensure that it was a keeper compatible contract because we haven't verified it. We can still deploy this Keeper, but it's relying on us now. To make sure that the Keeper contract.
00:40:43.588 - 00:40:50.008, Speaker A: Is a Keeper compatible contract, we'll provide a name again. So we'll just say count two, we'll.
00:40:50.024 - 00:40:59.010, Speaker B: Give it a gas limit, and we'll go ahead and give it the same one we gave it before we'll give it some link to start with. We don't need any check data, but we do need an address.
00:41:03.600 - 00:41:04.284, Speaker A: And we.
00:41:04.322 - 00:41:06.780, Speaker B: Can register our upkeep.
00:41:10.270 - 00:41:16.460, Speaker A: Once this has been confirmed, we should see upkeep kick off pretty quickly.
00:41:19.680 - 00:41:24.776, Speaker B: I often get questions about upkeep and how can we ensure that someone doesn't.
00:41:24.808 - 00:41:32.624, Speaker A: Call perform upkeep other than the Keeper. In my mind, one thing to keep in note is best practice is why.
00:41:32.662 - 00:41:38.304, Speaker B: Wouldn'T you want someone else to call perform upkeep? That's going to be the function that costs gas. If someone else wants to pay my.
00:41:38.342 - 00:41:40.656, Speaker A: Utility bill for me, awesome.
00:41:40.758 - 00:41:41.572, Speaker C: Let them do it.
00:41:41.626 - 00:41:59.864, Speaker B: But make sure that you have your perform upkeep set up in a way that it will not be a problem if someone else calls it or if it's called repeatedly. That is why in this example, we are checking again to make sure that upkeep needs to be run. It's always good to make sure that that one only runs when it's actually needed.
00:41:59.864 - 00:42:08.492, Speaker B: So just something to keep in mind. But locking that down so that only the Keeper's network call it, I think that that's not something to worry about. You should focus on it from a.
00:42:08.626 - 00:42:10.044, Speaker A: How do I make sure that no.
00:42:10.082 - 00:42:11.852, Speaker B: Matter who calls this, it only actually.
00:42:11.906 - 00:42:20.080, Speaker A: Does what I want it to do? We head back here, we can see that our upkeep has been registered. We go ahead and view our upkeep.
00:42:20.820 - 00:42:26.050, Speaker B: We can see here we've funded it, we've created it. We'll need to wait for it to actually run.
00:42:27.460 - 00:42:29.008, Speaker A: All right, we refresh the page and.
00:42:29.014 - 00:42:36.308, Speaker B: We can see, hey, look, it actually did run and we performed our upkeep. Fantastic. Let's head back to our contract and take a look.
00:42:36.308 - 00:42:50.356, Speaker B: If we open up our contract and we check the counter hey, our counter is one. We have an incrementing counter. Again, in this case, it's based on time, but using custom logic that we defined, not just strictly based on a Cron tab.
00:42:50.468 - 00:42:54.056, Speaker A: And this really opens up the opportunity.
00:42:54.158 - 00:43:00.540, Speaker B: For automating anything that you can come up with. So that is some of the products that chainlink has to offer.
00:43:00.690 - 00:43:02.076, Speaker A: I really appreciate you taking the time.
00:43:02.098 - 00:43:09.344, Speaker B: To walk through this, and if you have any questions, feel free to reach out. You can find me on Twitter. I'll put my Twitter handle right here.
00:43:09.344 - 00:43:12.128, Speaker B: And yeah, have fun building.
00:43:12.294 - 00:43:13.456, Speaker A: I look forward to hearing from you.
00:43:13.478 - 00:43:15.808, Speaker B: And seeing what awesome projects you come up with.
00:43:15.894 - 00:43:32.376, Speaker C: Hi, I'm Richard, one of the developer advocates here at Chainlink Labs. And today I have something really exciting to share. We've launched a new product, Chainlink Functions, which brings the power of serverless functions and cryptographic guarantees to your decentralized application.
00:43:32.376 - 00:43:33.880, Speaker C: So what does this look like?
00:43:33.950 - 00:43:35.130, Speaker A: Let's find out.
00:43:41.580 - 00:43:55.592, Speaker C: Chainlink Functions provides your smart contract with access to a trust minimized compute infrastructure. It enables your contract to send code to a decentralized Oracle network, or Don. Each Oracle will run the code in a separate serverless environment.
00:43:55.592 - 00:44:04.908, Speaker C: Once the Oracles have their results, the Don then aggregates that information using OCR two and returns the final result to your smart contract.
00:44:05.084 - 00:44:06.928, Speaker A: Your code could be anything from a.
00:44:06.934 - 00:44:17.840, Speaker C: Computation saving gas by running it off chain to fetching data from an API. Now, it's important to note that this currently is in beta. In fact, it's a closed beta.
00:44:17.920 - 00:44:22.500, Speaker A: There will be a link in the description to sign up, given that things.
00:44:22.570 - 00:44:29.672, Speaker C: May change from the state they're in when I am recording this. But most of you should see something that's fairly similar.
00:44:29.806 - 00:44:31.016, Speaker A: You will need to take a few.
00:44:31.038 - 00:44:34.456, Speaker C: Steps to get everything set up and running, and then you can look at.
00:44:34.478 - 00:44:36.040, Speaker A: Both of the examples.
00:44:36.380 - 00:44:51.200, Speaker C: So what does this setup look like? Well, first you're going to need to install node JS, version eighteen zero or greater. You'll need to clone the Functions hardhat starter kit onto your machine. You'll need to get some link and matic because we'll be using the Mumbai test network.
00:44:51.200 - 00:44:57.984, Speaker C: You'll need to obtain an RPC URL from a node provider like Infura or Alchemy. You'll be using Alchemy if you follow.
00:44:58.022 - 00:44:59.344, Speaker A: Along with this example.
00:44:59.542 - 00:45:08.724, Speaker C: You'll need an API key for polygon scan to verify your contract. And finally, you'll need your wallet's private key. Remember, that's something you never want to share with anyone.
00:45:08.724 - 00:45:15.364, Speaker C: Now that you have those set up, the foundation is laid. Let's look at the starter kit. All right, so here we have the starter kit.
00:45:15.364 - 00:45:21.556, Speaker C: It's on GitHub. Let's take a look at the README and see what we need to do. It walks through an overview, explaining functions.
00:45:21.556 - 00:45:33.308, Speaker C: Lets you know what testnets are currently supported. Gets you through setting up your wallet, getting funds, and providing step by step instructions in our Getting Started guide if we need that. But we can skip straight to the quick start.
00:45:33.308 - 00:45:38.104, Speaker C: Make sure you have node version 18 installed, and then you'll need to clone this repository to your machine.
00:45:38.232 - 00:45:39.404, Speaker A: I've gone ahead and done that.
00:45:39.442 - 00:45:42.544, Speaker C: The next thing we'll need to do is open up that directory and run NPM install.
00:45:42.662 - 00:45:43.856, Speaker A: So let's do that now.
00:45:43.958 - 00:45:53.588, Speaker C: All right, so here we have the repository cloned to my machine. I'm using Vs code, and we can see here that we're in the repository itself, the Functions hardhat starter kit. So the first step is to run NPM install.
00:45:53.588 - 00:45:58.820, Speaker C: This will install all of the dependencies that we need for this project. Great. That's done.
00:45:58.820 - 00:46:15.672, Speaker C: So what's next? Well, we'll need to go ahead and get a GitHub account set up and get a personal access token from GitHub. This will allow us to share our encrypted secrets with the Oracle network. So how do we do that? If we head back to the README, we can visit GitHub.com
00:46:15.672 - 00:46:31.532, Speaker C: slash settings, and from here we can set up a new token. All right, so we'll click set up new token and we'll see something like this. We can create the token name functions, example, set the expiration.
00:46:31.532 - 00:46:32.576, Speaker C: This is how long it will be.
00:46:32.598 - 00:46:35.728, Speaker A: Available for the description, if you like.
00:46:35.814 - 00:46:45.750, Speaker C: Who the owner is. And the only thing that we need to change is we need to go to account permissions and we need to change it for GIS. We need to say read and write.
00:46:45.750 - 00:46:54.280, Speaker C: Once we've changed that, we can generate the token. And here we have the token. We'll need to copy this and use it later.
00:46:54.280 - 00:47:03.000, Speaker C: We'll head to our starter kit. I'll just make a new file and we'll paste the token in here. So remember, this is private, right? You don't want to share this.
00:47:03.000 - 00:47:16.184, Speaker C: I'll be removing this token after I get done recording this video, so it won't be of any use. But this is one of those pieces of information that you wouldn't want to share because it does give, read and write access to your gists. All right, so we've got that value stored.
00:47:16.184 - 00:47:26.240, Speaker C: What's next? Well, we need to set up the environment variables. Now, the way that this is done is through the env ENC package. It will encrypt our sensitive information.
00:47:26.240 - 00:47:36.500, Speaker C: So we need to set that up. The first thing we need to do is run this NPX env ENC and set a password. This will set the password to actually encrypt those values.
00:47:36.500 - 00:47:46.712, Speaker C: So we'll set our password and that's it. All right, so we set up that encryption password. Now we need to set some of the environmental variables up.
00:47:46.712 - 00:47:57.064, Speaker C: Which ones do we need to set up? Well, for this tutorial, we'll need to set up our private key. That's going to be for the wallet that we're using to deploy the contracts. We need to set up our GitHub API token.
00:47:57.064 - 00:48:00.904, Speaker C: That's the one we just generated. You can see it above. We'll need a polygon.
00:48:00.904 - 00:48:08.732, Speaker C: Mumbai RPC URL. Remember, I'm going to be using Alchemy for that. We need a polygon scan API key if we want to verify our contracts.
00:48:08.732 - 00:48:16.272, Speaker C: And then finally, one of the examples here uses a CoinMarketCap API. And we'll need a key for that. You can get one@coinmarketcap.com
00:48:16.272 - 00:48:19.024, Speaker C: slash API. How do we actually set these up?
00:48:19.062 - 00:48:24.324, Speaker A: So we use NPX env from here.
00:48:24.362 - 00:48:35.960, Speaker C: It will prompt us for the first variable name that we want to enter. So I'll use private key for this example. Then it'll ask us to input the value for that variable.
00:48:35.960 - 00:48:45.816, Speaker C: I am not going to input my actual value here, and you'll see why in just a moment. But I'll put private key here. Do we want to set another variable.
00:48:45.816 - 00:48:47.144, Speaker C: Sure, let's set another variable.
00:48:47.192 - 00:48:51.528, Speaker A: We'll set GitHub API token and we'll.
00:48:51.544 - 00:49:13.044, Speaker C: Set this to the value we have above. Once you've set all of these different variables, you press return and we're done. Now, why didn't I enter my actual private key? It's because if you want to check what you've set, you can type MPX env ENC view and this will show you everything that's set.
00:49:13.044 - 00:49:19.156, Speaker C: So we have our private key and we have the value. Remember, I typed in private key here. You should actually input your private key.
00:49:19.156 - 00:49:29.192, Speaker C: We have our GitHub API token and I need to go through and set the rest. The polygon Mumbai RPC URL, the polygon scan API key and the CoinMarketCap API key.
00:49:29.326 - 00:49:30.504, Speaker A: So once you've got all of those.
00:49:30.542 - 00:49:40.060, Speaker C: Set, you're ready to move on to the next step. I'll go ahead and set them now off screen and we'll be back. All right, so you set those different values, your environment is ready to go.
00:49:40.060 - 00:49:58.608, Speaker C: What are we going to be looking at? The first is going to be this calculation example JS. Now, what this file is, is it's a calculation that would be very expensive in terms of gas on chain. It's a continuously compounding interest rate and you can see here it takes in a few things.
00:49:58.608 - 00:50:08.964, Speaker C: So we have the principal amount which comes from ARGs four. What is ARGs four? We'll get to that in just a moment. We have the APY times 100 and then we have our decimal percentage time.
00:50:09.002 - 00:50:11.416, Speaker A: And years Euler's number.
00:50:11.598 - 00:50:22.460, Speaker C: And the actual calculation itself. This is a very complex calculation in terms of what it would cost on chain. We're running it in a JavaScript file like this.
00:50:22.460 - 00:50:32.200, Speaker C: It's super simple. We run that calculation and then we return the value rounded. This value we pass back to our contract.
00:50:32.200 - 00:50:38.864, Speaker C: So we have this ARGs value here. Where is that coming from? Well, if we take a look at.
00:50:38.902 - 00:50:42.976, Speaker A: Functions request config, we can see a few things here.
00:50:42.998 - 00:50:55.408, Speaker C: In the actual request config, the first thing to note is the source that's going to be that file we just looked at. That calculation example, right? That's what's going to be reading in to actually run within the functions. We also have the ARGs.
00:50:55.408 - 00:51:06.056, Speaker C: If you remember, it was four and five that we were looking at and they start at zero. So we have 01234 and five. So those two values that we're passing in come from this arguments array that.
00:51:06.078 - 00:51:11.592, Speaker A: Will be passed in to our JavaScript cool from there.
00:51:11.646 - 00:51:23.784, Speaker C: The other thing to look at is this functions consumer contract. You can see how it's laid out here. We set up our contract, we have a few things set up like the last request ID any error or response.
00:51:23.832 - 00:51:26.864, Speaker A: We have some events, we construct our.
00:51:26.902 - 00:51:40.580, Speaker C: Contract and then we have this execute request function. This is what's going to be actually making that call out to the Oracle network. So you can see it initializes a request, it loads some information in.
00:51:40.580 - 00:51:51.664, Speaker C: We actually make that request and then we get the request ID back. If you're familiar with VRF functions is kind of similar in the workflow. We make a request to the Oracle network.
00:51:51.664 - 00:52:09.084, Speaker C: We wait for the Oracle network to get back to us with the response, and then it's going to come back into our contract with another function. The other function is this fulfill request function. So we go out, we make the request, it runs our JavaScript code, and then it's going to come back into our contract with a fill request here.
00:52:09.084 - 00:52:24.960, Speaker C: The fulfill request is very simple. All it's going to do is update the latest response and error values and then emit a event. We can run it with NPX hardhat functions simulate.
00:52:28.660 - 00:52:30.028, Speaker A: And what this will do is it'll.
00:52:30.044 - 00:52:44.388, Speaker C: Run it locally on our local machine. Now we can see it got back here this decoded value of 1 million and some change. So that's going to be the value that's actually calculated by this calculation.
00:52:44.388 - 00:52:50.328, Speaker C: Example here where we have our total amount of interest, right? Our continuously compounding interest.
00:52:50.494 - 00:52:50.824, Speaker A: Great.
00:52:50.862 - 00:53:03.516, Speaker C: So we've run that locally. How do we actually deploy this? The way to deploy this is with NPX hardhat functions deploy client. We'll need to pass in the network that we want to deploy it to.
00:53:03.516 - 00:53:11.308, Speaker C: That's going to be Polygon Mumbai for this. And we'll go ahead and verify it. So with this command, it will actually deploy our contract, our consumer contract.
00:53:11.308 - 00:53:15.500, Speaker C: This functions consumer sol to the Mumbai network.
00:53:15.660 - 00:53:19.936, Speaker A: We'll need to wait for the block confirmations to come back and we'll have.
00:53:19.958 - 00:53:26.304, Speaker C: Our contract verified if we want to check it out on polygon scan. Great, so it's done, right. So we've deployed our contract.
00:53:26.304 - 00:53:40.324, Speaker C: The next thing that we need to do is we'll need to go ahead and create a subscription. So we can do that with MPX hardhat functions subcreate. So we'll use MPX hardhat functions subcreate.
00:53:40.324 - 00:53:51.304, Speaker C: We'll pass in our network again, the amount is going to be how much link that we're going to supply our subscription with. And then the contract address will need to be the address of the contract that we just deployed.
00:53:51.432 - 00:53:54.908, Speaker A: We'll press return, it will go ahead.
00:53:54.914 - 00:54:05.696, Speaker C: And create that subscription for us. Again, we'll need to wait for those block confirmations and our subscription is confirmed. Now, something to keep in note here is this created subscription ID.
00:54:05.696 - 00:54:09.648, Speaker C: In my case it's seven, seven, eight. Yours will be different.
00:54:09.814 - 00:54:11.076, Speaker A: We'll need to keep track of that.
00:54:11.098 - 00:54:19.056, Speaker C: Because we'll use it in the next step as well as our contract address. So we've deployed our consumer contract, we've created a subscription.
00:54:19.168 - 00:54:21.488, Speaker A: How do we actually run a function.
00:54:21.594 - 00:54:35.124, Speaker C: Into the Oracle network? We do that with NPX hardhat functions request. We pass in our network Gin, that's Polygon Mumbai pass in the contract address. That's the contract that we deployed our consumer and we pass in our subscription ID.
00:54:35.124 - 00:54:49.384, Speaker C: When we press return, it's going to check a few things and ask us if we're sure if we want to continue. We'll say, yes, we do want to continue. And now it's actually running that request in the Oracle network.
00:54:49.384 - 00:54:54.428, Speaker C: So submitting our request and we'll get the response back from the Don here shortly.
00:54:54.524 - 00:54:55.232, Speaker A: And there it is.
00:54:55.286 - 00:54:56.976, Speaker C: We've got our response back.
00:54:57.158 - 00:54:58.000, Speaker A: That's pretty cool.
00:54:58.070 - 00:55:06.416, Speaker C: We've run this code in the distributed Oracle network. We've saved a ton of gas because we're not actually doing these calculations on chain. Right, that's massive.
00:55:06.416 - 00:55:20.104, Speaker C: But this is just running a basic calculation. What if we want to do something more interesting like hitting an API? Well, if we head to API request example here, we can take a look at this file really quick. It's going to use some arguments that are passed in.
00:55:20.104 - 00:55:26.536, Speaker C: Remember, those are going to come from our request config. So it's using one bitcoin BTC bitcoin.
00:55:26.568 - 00:55:29.836, Speaker A: And BTC it then will check and.
00:55:29.858 - 00:55:39.584, Speaker C: See if we have our secrets API key. The reason we'll need that is for Coin market cap. If it doesn't have that set it'll error out.
00:55:39.584 - 00:55:46.764, Speaker C: It'll then create some requests for us. Right, so these are the actual API requests. We'll hit four different APIs.
00:55:46.764 - 00:55:54.630, Speaker C: One from CoinMarketCap, one from CoinGecko, one from Paprika, and one from a bad API. Just see what happens if we have one API that's not working.
00:55:55.720 - 00:55:56.948, Speaker A: We'll use those.
00:55:57.114 - 00:56:01.572, Speaker C: We'll make those requests. We'll check for errors. We'll log the errors if we have them.
00:56:01.572 - 00:56:18.572, Speaker C: Now console log, we'll see what that looks like here in a minute because we will get an error from our bad API. And then finally, once that's done, it will go ahead and calculate the median price based on the responses. So how do we actually run this? Well, there's a couple things that we need to do.
00:56:18.572 - 00:56:29.584, Speaker C: We need to go into our functions request config. You'll notice this calculations example, that's what we used just a moment ago. We'll comment out this line and we'll uncomment the one below it.
00:56:29.584 - 00:56:42.340, Speaker C: This is going to change the source file of our JavaScript. The other thing is that that new API request example, it needs those secrets, right? So we'll need to uncomment the secrets line as well, give it a save.
00:56:42.490 - 00:56:45.056, Speaker A: And we'll run the same exact command.
00:56:45.088 - 00:56:53.280, Speaker C: That we just ran. Our contract hasn't changed. We've changed our config so that'll get picked up by this functions request command and we're ready to go.
00:56:53.280 - 00:56:54.376, Speaker C: So we'll go ahead and run this.
00:56:54.398 - 00:56:56.810, Speaker A: Command and we'll see things look a bit different.
00:56:58.300 - 00:57:05.880, Speaker C: We'll say, yes, we're sure we want to run this. And we can see here that locally it decoded this new value based on those API calls. Sweet.
00:57:05.880 - 00:57:17.436, Speaker C: How does this look? When we get to the Oracle network? You can see it's using our encrypted secrets from our gist. That's really cool. And it's actually making the request to The Dawn right now.
00:57:17.436 - 00:57:41.764, Speaker C: Now, the reason this works is because we're using a UN in both examples, and our contract's not really doing anything with the value other than logging it. If you had something more complex set up, you need to change your contract as well. But we can see here that we have our value came back here as the value of Bitcoin, we can see the transaction cost, and we can see.
00:57:41.802 - 00:57:46.852, Speaker A: That our gist was taken care of. So that's really cool.
00:57:46.906 - 00:57:56.364, Speaker C: We've used chainlink functions to reach out to an API and bring data on chain. I think this is super powerful. I'm excited to see what you start building with this.
00:57:56.364 - 00:58:03.372, Speaker C: I'm really looking forward to the potential and the power that's being unlocked with chainlink functions. So go out there and build and.
00:58:03.426 - 00:58:05.050, Speaker A: I'll catch you in the next one.
