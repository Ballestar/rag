00:00:06.250 - 00:00:43.930, Speaker A: So I'm going to be talking about Uma, which lets you bring the truth on chain with an optimistic Oracle. It's a pretty open ended system. There's a lot of cool things you could build with it, and we'll dive into a couple of them and how you can get started quickly. So the basic idea of Uma is that it's an optimistic Oracle. It can provide and verify any arbitrary data on chain to secure smart contracts and execute things based on what's happening in the real world or based on cross chain events or off chain calculation. It's been called a human powered truth machine. And the reason for that is know, you can and often do use bots to automatically propose and dispute and so on.
00:00:43.930 - 00:01:17.410, Speaker A: But Uma is able to handle natural language questions and it's able to apply human reasonableness. So unlike a price feed style Oracle, it's not trying to determine in advance and then push a price on chain. Anybody can basically ask a question. Anybody can propose an answer and post a bond with it. Anybody else can dispute that answer within a challenge window and we'll get into all the details of that. So oracles are really important. I personally think that the next phase of crypto really needs to bring in more real world events, more real world assets, that kind of thing.
00:01:17.410 - 00:01:39.420, Speaker A: And Oracles are critical to that. The Oo is powered by Uma token holders. It can be plugged into any kind of DeFi protocol or other on chain smart contract. And it's super flexible. It's been used to build bridges, insurance protocols, prediction markets, derivatives. We have some optimistic governance stuff coming out soon. That's really cool.
00:01:39.420 - 00:02:06.846, Speaker A: So here's what goes into it, the basic flow. You have a requester. The requester is asking a question for some data. A proposer provides an answer, and a disputer can challenge the answer. If it's wrong, it has a dispute resolution process. So if it gets disputed, it goes to a vote of all of the Uma token holders that do a secret commitment on chain of what they think the answer is. So you can't copy other people's answers and then a reveal process where the actual answer is revealed.
00:02:06.846 - 00:02:42.906, Speaker A: Documented methodology of truth. So you describe your methodology of here's the kind of information that I'm looking for, here's how you can figure out what the answer is. So if you have something complicated, there's one project that wants you to calculate volatility of an asset, which is kind of like, yeah, okay, are you with volatility now? Okay. There's two projects that are trying to calculate the volatility of an asset. So for that you need to kind of explain to people, here's how you calculate it. You might provide even a script to do it or some backup process to do it by hand. And then you have economic guarantees.
00:02:42.906 - 00:03:00.374, Speaker A: So people have money at stake. If they're wrong, they're going to lose money. If they're right, they're going to make money. So that's kind of the combination of things that you use to build an optimistic oracle powered thing. And this is just kind of a flowchart of how it works. So it kind of starts with a question. The proposer posts a bond and gives an answer.
00:03:00.374 - 00:03:28.878, Speaker A: If it gets disputed, then it goes to this DVM process where all the uma, token holders weigh in on it. But because of this proposer, bond disputes are extremely rare. I think maybe like one out of every 500 proposals and actually probably less when across our cross chain bridge is taken into account because proposers don't want to lose their bond. So normally you just say no. After the liveness period, the challenge window, you have the final answer and you can use it. So these are some things that have been built. I talked about this a little bit.
00:03:28.878 - 00:03:59.026, Speaker A: KPI options and success tokens are like some really cool dow tools to incentivize communities, incentivize investors in a way that's really aligned. And there's much, much more than this. And I'm very excited to kind of see what hackers come up with. I know the last couple of hackathons we've had some really cool stuff. We have a decentralist here. So it's like verifying lists of addresses that meet certain criteria, which is a really flexible tool. There's a cool project from ETH Bogota where you're verifying news information, like basic facts.
00:03:59.026 - 00:04:25.840, Speaker A: You can check it, you verify it, and now you have a corpus of facts that you can deal with and really trust for the news. These are just like small examples. There's so many different things. Yeah, just some examples of so again, like you can ask natural language questions. You don't need to even have an API that you're pointing at. You don't need to have nodes running in the background. You just need a question that someone can answer, that somebody with access to Google basically is able to determine what the answer is.
00:04:25.840 - 00:05:08.266, Speaker A: So our oracle can also be triggered by events. So if you have some event that you know is going to happen in the future, you can essentially set up a trigger in your contracts and provide incentives for people to inform the contract that the event has happened. So for instance, if you wanted to have some kind of a payout, like maybe if ETH San Francisco was canceled and you wasted a bunch of money on plane tickets or insurance or like hotel costs, you could have an insurance contract that'll pay out that's event based. East San Francisco hasn't happened yet at the time you're buying this insurance. But then when East San Francisco does happen, you can resolve this like it happened. There's no insurance payout or vice versa. And then those events can flow into other contracts.
00:05:08.266 - 00:05:36.038, Speaker A: So once that is settled, you can have a callback function in your contract. That when the Oracle resolves the answer. Your contract will automatically do some stuff. And the reason for that is when you're making the request, you're saying like, hey, I have this callback. So when the Oracle is resolving, it's going to call this price settled function in your contract. And then you can do all of your other logic, including like in this example, just doing an insurance payout automatically. So all you really have to do is ask the question, include the reward, the incentives are there.
00:05:36.038 - 00:06:17.240, Speaker A: Essentially this decentralized keeper network is going to take care of it for you now both verifying the truth and triggering all of your events that happen. So now the real world can directly affect on chain state. So if you know something happened in the real world that can now affect a smart contract and you can build the incentives in place, that that information is going to come in and then all of your smart contract logic will play out in this permissionless and unstoppable way. You can also use it to make assertions. And this is a pretty common pattern where you know what the answer is, but you don't want people to just trust you. So you come in and you ask the question and provide the answer at the same time. And then you can use that answer after that challenge window is over.
00:06:17.240 - 00:06:48.080, Speaker A: So that's actually probably the majority of projects might want to use this pattern. And insurance one is a good one too. Like you might trigger the request and the proposal at the same time. There's no point to even necessarily making the request unless the thing has happened. So as the person who's getting the payout, the money's locked up in the insurance contract, East San Francisco is canceled, you just go and say, hey, it was canceled. Make the request, propose it, and then you get paid out after the challenge window. And so this is kind of like a way to implement that.
00:06:48.080 - 00:07:24.012, Speaker A: And really what it's doing is just like wrapping the other function. So you're requesting here you're setting a liveness period of how long the challenge window should be because that's customizable. You might make it longer or shorter depending on your use case. And then you're proposing a price and just emitting an event so that front ends know about it. So you can ask questions about past events, you can subscribe to updates about future events, you can trigger callback functions, you can make assertions about the world, and you can build a collection of undisputed facts on chain and voila. So this is the real world. This is what we're trying to bring on chain here.
00:07:24.012 - 00:07:51.056, Speaker A: Most of the stuff that matters is happening out here. It's not just like the circular kind of crypto economy. This is kind of the next phase that we need. This is what we need Oracles for. So we have a lot of tutorials. I'm going to pull up one that's just like a really basic quick start, but depending on what you're working on, you might want to go to these more advanced tutorials. We have something for like, just a basic deposit box you're putting money in and then you're pulling a different amount of money out depending on the Oracle's response.
00:07:51.056 - 00:08:25.470, Speaker A: We have a prediction market tutorial, so you could deploy a prediction market, an internal optimistic Oracle. And this is just kind of demonstrating a pattern where you might have an escalation game before you even go to our Oracle, where you only come to us if there's a dispute. For instance, we have an insurance tutorial and then something we call the Optimistic Arbitrator, which is kind of showing that assertion pattern. So all of these things are too long to get into right now. But go to Docs Umaproject.org developers and you'll see all of our tutorials that are available. But we are going to go to the quickstart one.
00:08:25.470 - 00:08:59.210, Speaker A: So the Quickstart also includes a video. This is me in the distant past when my hair was short. And this is just going to ask a really simple question. How's the text looking, by the way? Is it like, small? Okay, so it's just going to ask about the temperature in New York City on a certain day in the past. And then you're going to answer yes or no, depending on the temperature. And we're just going to deploy something to Gurley testnet and just like walk through a basic flow. So let's go to Remix and check this out.
00:08:59.210 - 00:09:31.570, Speaker A: While Remix is loading, I'm going to click over to our Oracle interface. So this is something that you could use to manually respond to requests that you've made on Gurley. So if you're testing on Gurley, you could go here and do like, an actual natural flow. You'll see the requests come in and you can respond to them. So it's a more realistic kind of simulation. Request failed. Well, it looks fine, though.
00:09:31.570 - 00:10:06.224, Speaker A: Okay, so this is our contract. It's just a really simple getting started contract. I'm not going to go into all the details of it, but I'm basically just going to go and deploy this to Gurley so we can interact with it and then walk through the different steps. And again, if you go to the Quickstart tutorial page, you'll be able to pull this up and it'll make it pretty easy. You'll need some Gurley ETH, but we have some instructions on how to get that if you don't with the addresses that you're using. All right, so that's confirmed. We just deployed the contract.
00:10:06.224 - 00:10:41.792, Speaker A: We should be able to interact with it now. So let's go and run some transactions. So right here, we're going to start with this request price function, which don't get confused when you see the word price come up in our code. Uma, kind of started out with a lot of financial derivatives focus, and so there was like a lot of focus on price. Just mentally replace the word price with data. In your mind, you're requesting any kind of data. So this function is just going to ask a pretty basic question.
00:10:41.792 - 00:11:22.850, Speaker A: What we've defined here, like, did the temperature on the 25 July in Manhattan exceed 35 degrees Celsius? And then it's providing some instructions for your proposers on how to resolve it because they're going to have to return a number. So one means yes, zero means no. You're just letting them know here. So we're going to make this request, confirm that, and then once this goes through, we should see this pop up in our interface here as a new request. Okay, so we got a new request here. I'm going in just like a manual proposer. I'm seeing new stuff that's coming in.
00:11:22.850 - 00:11:57.208, Speaker A: Pull this up, going to connect it to my wallet so I'm able to propose and I can see the question. So did the temperature exceed this one for yes, zero for no. And again, it's not specifying a data source. It's just kind of up to the proposer to propose something that they can stand behind that they're willing to risk their bond on. So I'm going to go to this random website because it's a testnet thing, so I don't really need to check multiple sources here. And it looks like the max was 84 degrees Fahrenheit. Run the conversions manual kind of thing and that was definitely under 35 degrees Celsius.
00:11:57.208 - 00:12:35.624, Speaker A: So I'm going to read this again. Zero is no. I'm going to propose an answer of zero. And since this is a testnet request, I think the wait period is going to be like 60 seconds that somebody could challenge this and it might actually be so fast that you won't see the dispute option come up here. But once this goes through, you should actually be able to dispute it also through this interface so you can test out that flow as well. And if you're on Gurley and you're doing this, we have a mock oracle contract and there's some documentation for that online. You'll get like 24, 23 seconds left if I wanted to dispute myself.
00:12:35.624 - 00:13:04.288, Speaker A: But if you want to resolve a dispute, obviously there's not going to be a full vote on this on testnet, that wouldn't even work. You can just basically push an answer and that'll simulate getting an answer from the DVM, the dispute resolution process. But in this case we're just going to let it wind down. Everybody thinks this is correct. Other people checked the same sources. Seems like the answer was zero for no. So now that that's gone through, we should be able to actually settle this kind of following through it.
00:13:04.288 - 00:13:36.764, Speaker A: We proposed and we're going to call the settle request function what you could also do. Okay, so this remix hasn't updated yet that this is settleable, but it will in a minute. Okay, now we can do it. So basically you saw it fail because it thought that we couldn't settle it yet. It didn't see that the countdown clock had gone down. That was just kind of like the node updating with the actual state now going to confirm that. So once this is settled we'll be able to actually use this answer for whatever we're interested in.
00:13:36.764 - 00:14:06.026, Speaker A: Maybe this is like again like an insurance contract tied to the weather or something in New York. Give that a minute. Looks like it's pending. Okay, so we were able to call get settled and I don't know if you can see it down here but remix actually gave you the answer. So zero is the answer. We can now use that that is finalized. So that's the really basic quick start.
00:14:06.026 - 00:14:45.074, Speaker A: I really encourage you to go into the more detailed tutorials like here's a prediction market for instance. All of these should have instructions for actually deploying these on testnet or your local environment and just really helps you think through different things that you might want to implement. There's also good instructions for setting custom bonds and liveness parameters. This is something that you would think about in a main net thing because the bonds are going to provide basically a penalty for proposers that are bad and a reward for disputers that are good. And you need to think through like what are the correct levels. You don't want the bond to necessarily be too high because then people are scared to propose. You don't want it to be too low because then people don't have an incentive to dispute.
00:14:45.074 - 00:15:43.222, Speaker A: If you're securing like $100 million you're going to have a lot more to think about than somebody securing like $1,000 to all of these things are configurable. So just think through what makes sense for yourself. So the minimum bond is what we call the final fee and that's just like an anti spam thing and it's about $1,500. And the reason for that is to block people from just like spamming the DVM and farming voting rewards because the incentive as an Uma voter is you get rewards if you show up and vote and vote correctly. So people would have an incentive without that final fee to just create a bunch of fake disputes just to farm a bunch of Uma tokens for themselves. You generally want to set it higher because only the amount in excess of the final fee is going to go towards the disputer's incentives. So if you set like a bond of 4000, half of the excess is going to go to the disputer.
00:15:43.222 - 00:16:10.466, Speaker A: And this is kind of like a complicated thing, but basically with a $4,000 bond, if somebody disputes and they're correct, their reward is going to be $1,250. And then 1500 goes to the store. And I think the rest also is going to the store in that case, just to keep people from proposing and then disputing themselves like front running. A dispute that came up, but yeah. So if you don't give an extra bond, feuters have no reason to show up. They won't make any money. So you do need to set it higher than the final fee.
00:16:10.466 - 00:16:37.994, Speaker A: Unless you have some extra protocol, kind of incentives for people to show up in dispute like you're running bots, you know that lots of other people are running bots and you don't need any extra incentive. They're just going to show up in dispute because you know it's wrong. Wanted to point out prizes too. So basically first place $5,000. 2nd place is $2,000. And this is for uma or across. I didn't really get into across in this presentation, but across is a cross chain bridge that uses Uma under the hood.
00:16:37.994 - 00:17:05.410, Speaker A: You can use it to move between ethereum, arbitram, optimism, boba and polygon. It all has single sided liquidity so no slippage. It's usually the fastest cheapest bridge between these chains. So if you're building something cool with across you could also qualify for prizes. And it uses Uma under the hood to verify that transfers are done correctly. And then there's a pool prize of $3,000 that's split between all the teams that do any Uma or across integration. So there's an opportunity even if you're not like one of the top prize winners.
00:17:05.410 - 00:17:25.870, Speaker A: But we have some more time. I did want to get into what people are thinking about building and maybe brainstorm how you could do that with Uma or with across. Also prediction market. Okay, we've got a tutorial for that. You can get this deployed an hour, you're done and then you kick back your heels and relax.
00:17:33.180 - 00:17:35.130, Speaker B: Could I use it for.
00:17:38.540 - 00:17:40.140, Speaker A: The Seaport contracts?
00:17:41.680 - 00:17:51.310, Speaker B: New openc contract contracts they might implement are called CPORT. It's an RFQ based system.
00:17:54.640 - 00:18:06.580, Speaker A: Okay, how would I use so like a request for quotes? Yeah. Okay, let me think about that. So the quote comes in, is that coming in like on chain or off chain.
00:18:13.240 - 00:18:20.860, Speaker B: In terms of like 21 or you can post a bid.
00:18:22.240 - 00:19:08.632, Speaker A: Interesting. Yeah, I mean it seems like an opportunity that you could gather in a bunch of bids like off chain where it's cheaper and then the highest one could be pushed on chain. So you could basically say like building on top of CPORT and just spitballing here somebody has posted an RFQ and they're like, I want a minimum of this for my board ape. But not everybody wants to go on chain and spend gas to put in a bid and possibly not win. So they go to some kind of off chain broadcast thing and there's some set time period and the winning bid, the highest bid can be proposed now on chain and Uma can verify that that was actually the highest bid. If it wasn't, then it gets rejected. Or if like the time period hasn't exhausted itself, it'll be rejected and that'll be a way to bring that off chain.
00:19:08.632 - 00:19:52.034, Speaker A: Highest bid on chain? Yeah. I mean, you definitely could. I mean, you could use like Uma because Uma can see what's happening on every chain because it's just like whatever, like human beings can look at or bots can look at. So if you have an RFQ that's coming from some other chain, you might use Uma to automate moving funds to the chain where you need to actually make the payment. Like if your funds are on ethereum, you need to move them to polygon for something and you're asleep. But you know that you want to buy this type of polygon NFT as long as one comes in at a certain price. You could use Uma for that.
00:19:52.034 - 00:20:17.600, Speaker A: Like basically give people an incentive to move your funds on your behalf and then submit the bid. So it's like what we were talking about with those event based triggers. You have some new real world event, an RFQ came out that you're interested in. Other people can now trigger some stuff on chain that's going to move your funds in place to actually bid and you'll win this auction in your sleep. All right, after the prediction market.
00:20:20.930 - 00:20:25.040, Speaker B: Could even compare bids from multiple chains too.
00:20:25.650 - 00:20:59.980, Speaker A: Yeah, you definitely could. Like if you see the highest bid on any chain. Yeah, that's interesting. Yeah. So if people are submitting things on chain or you could also I don't know, with C port, if you're able to rescind a bid, like if you put in a bid and then you're like, wait, never mind, something else more important came up, maybe you're able to pay attention to that too. So if you're building like an NFT trading bot that is keeping track of what is the most important thing, maybe you rank the NFTs you want the most and so you pull one bid because you need the funds for some other thing. I think you could probably do that.
00:20:59.980 - 00:22:04.246, Speaker A: I think there's also probably a way NFTs get stolen all the time, so you might not want to bid on one that was stolen. And so you might add a check, basically where it's like, I don't know, anybody can do this and submit this bid on my behalf unless it appears from whatever evidence that this might have been stolen and then there's some kind of delay baked into that so that you're not like otherwise, somebody could come in and steal something, create an RFQ, use this automated system to have you bid on it and sell it to you in an automated way. And they won't be disputed necessarily because you did say you wanted it. You didn't specify you don't want it if it's stolen. Yeah, but it's also very active because it's like in real time, it's like this specific NFT did it happen to be stolen? Can you tell? Within this time period? That seems like a pretty good protection against doing that. As long as it's like a long enough time period. Right, exactly.
00:22:04.246 - 00:22:11.880, Speaker A: Yeah. Because you're not going to know in advance that it was stolen. It's like, probably newly stolen, up for sale immediately. Yeah.
00:22:14.970 - 00:22:29.790, Speaker B: Types can be submitted as a price, like different price identifiers, yes or no queries commonly with zero or one. But are there like, price IDs that take addresses or even, like, structs?
00:22:30.450 - 00:23:31.166, Speaker A: So the return value is always going to be a number, but you're able to ask the question in a way where you can kind of say what number to return based on what the actual return value is. So yes or no is an obvious one where it's like, one means yes, zero means no, 0.5 means this one's not resolvable and just kind of like, split the difference. But you could have more complicated types of answers too. Returning a struct seems tricky. You could probably also do encode something as a number and just really specify somewhere, maybe in your price identifier that went through, uma, governance of, like, here's how you convert the end result into a number and you're returning this number value and then you know to convert it back the other way in such and such. So the Identifiers are approved on chain, but the methodologies are stored off chain.
00:23:31.166 - 00:24:01.026, Speaker A: So you would go to the, UMIP, kind of description of how to resolve yes or no query. For instance, it's on GitHub right now. I think it would be better in the long run if we had some kind of like an IPFS type thing so that it's immutable, but right now it's on GitHub. Cool. Yeah, like I said, it's super flexible. We've got the booth. It's on that side at the end of the hall.
00:24:01.026 - 00:24:25.582, Speaker A: We'll be here pretty much all weekend helping you hack on stuff. And we really want to provide as much support as we can because we want cool stuff to be built. We also want to help you make it to the finale and achieve all your other goals. And then afterwards, we do have grants programs. We can provide follow on support. Alex is here in the audience too. We both help hackers extend their projects, and we're also hiring too.
00:24:25.582 - 00:24:35.580, Speaker A: So if you're interested in working for us, we'd love to work together with you over the weekend and then see if you want to apply to that. And I think that that's it.
