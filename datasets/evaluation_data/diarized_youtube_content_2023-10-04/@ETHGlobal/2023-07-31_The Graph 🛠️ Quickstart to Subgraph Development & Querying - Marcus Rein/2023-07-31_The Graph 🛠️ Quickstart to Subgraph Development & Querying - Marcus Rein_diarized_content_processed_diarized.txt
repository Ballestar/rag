00:00:07.130 - 00:00:07.390, Speaker A: Guess.
00:00:07.460 - 00:00:15.226, Speaker B: Developer Relations at Edge and Node. Developer success. And this is going to be a quick start to subgraph development and querying.
00:00:15.226 - 00:00:30.242, Speaker B: Really getting you guys started for the hackathon as soon as possible. And the best way to get started with subgraphs is to start from the beginning and that's really understanding where you are in the hackathon. So if you would like to scan this to understand our prizes.
00:00:30.242 - 00:00:45.260, Speaker B: Also to have a hacker help Telegram Group, quick Start videos, repos these slides. I really tried to put a lot of information in this QR code, so that can be very helpful for you. And once I see phones down, I will move on.
00:00:45.260 - 00:00:54.618, Speaker B: Good, everyone got it? Phone up. Okay, I got you. All right.
00:00:54.618 - 00:01:08.362, Speaker B: And real quick, I'll go over the prizes for subgraphs as well. Three main prizes we got best use subgraph with those prizes, best use of existing subgraph and then cool prize. Also, we just announced substreams literally yesterday.
00:01:08.362 - 00:01:24.840, Speaker B: So if you want to dive into substreams and what that is, that's also in this QR code? substreams are cool. That's the summary divided. You can it's the same QR code as before the dude, if you already got it, you got it.
00:01:24.840 - 00:01:32.514, Speaker B: Cool. All right, so if anyone wants a live code, you can join along right here. And then this is the repo with all the links.
00:01:32.514 - 00:01:39.514, Speaker B: No more QR codes after this, I promise. We'll just skip through all this real quick. All right, everyone's good? Let's go for it.
00:01:39.514 - 00:01:45.280, Speaker B: So this workshop, there's going to be an introduction. Oh, sure, I got you. Sorry.
00:01:45.280 - 00:01:58.714, Speaker B: Yeah, I'll wait. Workshop repo, live coding links, pretty much. If you want to do this along with me or have anything that you learned from today be displayed in front of you, we use that phone.
00:01:58.714 - 00:02:07.410, Speaker B: There we go. No more QRS, I promise. All right, so this workshop overview, it's going to be an introduction to the graph we'll start with.
00:02:07.410 - 00:02:15.858, Speaker B: Then what exactly are subgraphs? We're going to define those. We'll actually deploy a subgraph live. We'll compare queries with two different subgraphs.
00:02:15.858 - 00:02:34.438, Speaker B: We'll use a subgraph that is pointed to a smart contract, and we'll use another subgraph that's a little bit more well built out, looking at the exact same contract and we'll see how it's a little bit different. And then finally we'll finish with a little plug for Scaffold 20, which connects very nicely with subgraphs now, which is pretty cool. So let's get into the introduction to the graph.
00:02:34.438 - 00:02:41.070, Speaker B: First thing when you go to thegraph.com, you see this access the world's blockchain data. So let's dive into that.
00:02:41.070 - 00:03:00.590, Speaker B: Really, the data storage of a smart contract is very similar to this. It's just very, very isolated if you only look at it in its one point. However, if you want to understand how that smart contract has existed in time, how do you actually do that? How do you look at how it has existed over time stamps.
00:03:00.590 - 00:03:25.622, Speaker B: Well, you want to know about the provenance, you want to know about the history, you want to index that data. So something like this, very simple, but we're actually looking back in time just like this Apple mockup for the backups. And really we're seeing this kind of data layer backing up, backing up, backing up over time and having all of this timestamped information over time in a disorganized way just because it's so write optimized.
00:03:25.622 - 00:03:35.454, Speaker B: We have so much data being piped in at any given second that has no organization, it needs indexing. All right, so that eventually you think is an issue. Well, there's also another issue.
00:03:35.454 - 00:03:46.754, Speaker B: We have a read issue with the blockchain where if we're going to be writing to the blockchain so disorganized, okay, so that's fine. We're going to be getting a lot of data back. Also, it's not just a write issue, it's a read issue.
00:03:46.754 - 00:03:57.346, Speaker B: We got disorganization on the way in and a lot coming back out. For example, who here used Instagram today? Anybody? Who posted on Twitter today? Anybody? I post on Twitter. There we go, twitter.
00:03:57.346 - 00:04:10.246, Speaker B: All right, so that was one post, that was one write. And how many followers do you have? Or anyone have 1500 followers? That's potentially 1000 reads to one write. And that's the exact same thing we're seeing with data retrieval from the blockchain.
00:04:10.246 - 00:04:18.246, Speaker B: So it's a problem. So there's a Web 2.5 solution for reading, which is centralized indexing, indexing being organizing up the data.
00:04:18.246 - 00:04:24.910, Speaker B: And that works. It totally does. You're able to get your data from a certain block and actually get it to your front end, totally fine.
00:04:24.910 - 00:04:35.506, Speaker B: However, if that centralized indexing service goes down for whatever reason, we are sad. That's not a fun thing. Okay, so the question was in the beginning getting introduced to the Graph, the Web 3.0
00:04:35.506 - 00:04:52.886, Speaker B: read solution. We have a lot of indexers working permissionlessly in the Graph ecosystem and they are all providing you options for your data retrievals. All right, so they're all indexing that same data piece that you want on the blockchain and you can get it through the Graph, and that's the Graph right there.
00:04:52.886 - 00:05:00.806, Speaker B: So if any of the indexes, for whatever reason go down, you have other options. Okay. All permissionlessly working through the tokenomic system of the Graph.
00:05:00.806 - 00:05:08.026, Speaker B: So I love this. Hope you guys do. It really provides a foundation for truly decentralized apps.
00:05:08.026 - 00:05:18.426, Speaker B: If you're really needing indexing, you want to be decentralized and have that security guarantee also with incredible speed and uptime. It really is there. That is the Graph network 450 indexers worldwide.
00:05:18.426 - 00:05:30.082, Speaker B: It's permissionless redundant, fast, cheaper, reliable, and a global API. So let's go into subgraphs. Who here has heard of subgraphs? Build with subgraphs? Okay, who here has never built with subgraph before? Cool.
00:05:30.082 - 00:05:31.810, Speaker B: Awesome. So we're just getting started. Awesome.
00:05:31.810 - 00:05:45.094, Speaker B: So we now know we are swimming in blockchain data all the time as developers it's disorganized horribly, but we can index it. How is that happening? This is basically what a subgraph does. It takes all the data and puts in nice clean little buckets.
00:05:45.094 - 00:05:54.122, Speaker B: That's basically it. All right, so let's go ahead and put this to words. subgraphs are permissionless customizable instructions for indexers to organize your data.
00:05:54.122 - 00:06:06.366, Speaker B: If you build these instructions awesome, they are going to be sent to indexers for you to get your data back. And here's basically the pathway it goes through. You have on chain data and off chain data that's IPFS that is available today.
00:06:06.366 - 00:06:20.962, Speaker B: And it goes into subgraph YAML, which is your manifest. You define exactly how your subgraph should look like from a high level and then it gets a little bit more into like a medium level, almost just kind of like the mappings and the logic. And then eventually you present your data.
00:06:20.962 - 00:06:35.974, Speaker B: You have your schema, which you send queries to and they're nice clean little buckets. Okay? And when you have that all of these subgraphs exist in a permissionless market. Each of these subgraphs are valuable and have incentivizations mechanisms that exist within the tokenomic system of the graph.
00:06:35.974 - 00:06:40.426, Speaker B: It's super duper cool. So that's a high level overview. It can go super deep into this.
00:06:40.426 - 00:06:51.200, Speaker B: But let's keep on going about how subgraphs work. Eventually it all comes to this. You guys want query responses, so we use GraphQL, send out a query and then we enjoy that.
00:06:51.200 - 00:06:58.650, Speaker B: So that's the high level summary of the graph. And subgraphs 1.1 to 2 billion queries per day are running to the graph.
00:06:58.650 - 00:07:10.674, Speaker B: There's over 1000 subgraphs published on the graph network, which is super cool. Those are the individual subgraph in the marketplace and there's over 450 indexes. Okay, I said number of QR codes.
00:07:10.674 - 00:07:13.080, Speaker B: I lied. You could take that or not. That's fine.
00:07:13.080 - 00:07:25.722, Speaker B: Okay, I feel bad now. All right, once falls down. Okay, nice on time.
00:07:25.722 - 00:07:40.634, Speaker B: Okay, so let's go ahead and get into the code. We're going to deploy a starter subgraph and then we're going to compare that to a published there we go. We're going to compare that to a published subgraph that's both subgraphs are going to be looking at the same smart contract.
00:07:40.634 - 00:07:49.550, Speaker B: So you can see how different it's going to be to get data back from a basic subgraph. This is the subgraph that we're going to play. Thank you guys.
00:07:49.550 - 00:08:01.398, Speaker B: That we're going to be comparing our starter subgraph to. We're going to look at a little bit more well built out subgraph so you have a learning environment where you can see a basic one and a little bit more advanced one. To start, we'll go to the graph.com
00:08:01.398 - 00:08:12.918, Speaker B: studio if anyone's calling along, and also miniscan. All these links are available to pop into. And throughout this little next section, all you're going to do is just trace the punk transfer event.
00:08:12.918 - 00:08:20.054, Speaker B: That's all I want. And we're going to look how the punk transfer event goes all the way to your Schema GraphQL. From there you'll learn how a subgraph functions.
00:08:20.054 - 00:08:29.070, Speaker B: Let's deploy a subgraph, everyone. So what we're going to start with is we will go to the graph.com and make this a little bigger.
00:08:29.070 - 00:08:47.038, Speaker B: We'll go to Products Subgraph studio and we're going to create a subgraph and we'll call live ETHGlobal Paris Demo And we know this smart contract I'll be indexing, like I said, is CryptoPunks. We know it's on ethereum. So I chose ethereum.
00:08:47.038 - 00:09:00.066, Speaker B: And then we have this dashboard pop up and you're free to actually populate this as you would like. Like I said, these subgraphs exist in a marketplace so other people will see them. It's good to have good documentation and also good dashboard etiquette.
00:09:00.066 - 00:09:20.414, Speaker B: So fill that out. If you are looking to join in a published way, let's go ahead and initialize the subgraph. So go into this copy paste and we'll go ethereum automatically populates the subgraph slug from the actual CLI and then it'll create a directory automatically as well.
00:09:20.414 - 00:09:33.140, Speaker B: We know this is on Mainnet, so we'll select Mainnet. Now we find the contract address. So I've already pulled up the Cryptopunk's smart contract address and I'm going to bring that right in here.
00:09:33.140 - 00:09:40.850, Speaker B: It's going to fetch the Abi automatically. Sometimes, depending on the chain, there might be an issue with that. And that's okay.
00:09:40.850 - 00:09:49.410, Speaker B: There's totally a solution for this. You need to get the Abi manually. So you'll actually go to Miniscan, which is all linked in the repo, and you can get all that information very easily.
00:09:49.410 - 00:09:57.034, Speaker B: So you go to Ethereum, put in the contract address. I love miniscan. Of course, you can go to Ether Scan, but it provides everything right there in front of you.
00:09:57.034 - 00:10:03.818, Speaker B: Very useful for subgraph development. Miniscan is awesome. You got the Abi, the code, all the different events which are awesome.
00:10:03.818 - 00:10:07.762, Speaker B: So let's go ahead and go back. There we go. It did it automatically.
00:10:07.762 - 00:10:20.238, Speaker B: It automatically also found the start block in which the smart contract was initially deployed. So you don't want to index from block zero. You want to go where the smart contract was deployed, finds it for you and then the contract name.
00:10:20.238 - 00:10:28.846, Speaker B: Once again, Etiquette. Because we are making a subgraph that is public, we want to actually have good naming. So guess what the name of the smart contract is? It's right there in MINIscape.
00:10:28.846 - 00:10:37.522, Speaker B: So copy and paste, a lot of copying and pasting. We try to make this as easy as possible for you guys to get up and running. Okay? Index contract events as entities.
00:10:37.522 - 00:11:03.582, Speaker B: This is when now we're going to be talking about that kind of portal that goes through the subgraph and how we define it, how we have the mappings, and then we get the Schema. This is automatically generating that for you right now. Crossing fingers on the WiFi, we'll see, all right, so while that is spinning up, we'll see there we go.
00:11:03.582 - 00:11:09.122, Speaker B: Okay, awesome. So here we could also add more contracts. We're not going to do this is just a starter subgraph press.
00:11:09.122 - 00:11:30.098, Speaker B: No, now it has information on the CLI you could follow through. I personally like to go right back to my dashboard and bigger, just copy paste once again, a lot of copy pasting. Authenticating your CLI paste authenticated and enter the subgraph paste.
00:11:30.098 - 00:11:35.606, Speaker B: Very easy. And then code gen, which is actually compile. It's actually doing type safety.
00:11:35.606 - 00:11:44.330, Speaker B: And then graph build is compiling. So we have that going through, putting everything together. And then now we'll deploy.
00:11:44.330 - 00:11:50.880, Speaker B: All right, awesome. No punch there. I'll point back.
00:11:50.880 - 00:11:58.980, Speaker B: So uploading to IPFS and there we go, the dashboard. Uh oh. All right, that's okay.
00:11:58.980 - 00:12:21.510, Speaker B: We'll just keep on going. So just in case it happened, I have a recording of this. We'll just go through this together like so we got right to here, to the deploy.
00:12:21.510 - 00:12:31.420, Speaker B: And that was not working very well earlier. So I was having some difficulty on that. All right, we went through this, went through this, and here we are.
00:12:31.420 - 00:12:50.260, Speaker B: Okay, so we got the deploy going through. So at this point we have the dashboard loaded and we could actually see the different entities that have been populated. Let's go ahead and dive into those entities right now through Vs code.
00:12:50.260 - 00:12:56.930, Speaker B: Do you guys see that? Cool. So I'll just look at the screen. We'll go through this together.
00:12:56.930 - 00:13:08.520, Speaker B: So we have the subgraph YAML, which is also known as the manifest of the subtraph. It really defines at a high level what the subgraph is. I'm opening up all the three files right here so we could all have to spill one by one.
00:13:08.520 - 00:13:20.602, Speaker B: The subgraph YAML has the smart contract in there that we defined through the CLI. Also have the star block in there. And high level, you're naming the entities, you're not really going into all the properties of them.
00:13:20.602 - 00:13:27.462, Speaker B: Also you're naming the event handlers. It's just a high level overview to just understand what your subgraph is doing. It really is the manifest.
00:13:27.462 - 00:13:40.142, Speaker B: So you can see we have that punk transfer not defined, just named right there. Let's keep on tracing that punk transfer. We'll go down to the automatically generated punk transfer handler which is named Handle Punk transfer.
00:13:40.142 - 00:13:52.854, Speaker B: So you have an event being emitted from chain. And then from there, this is going to start populating the entity of which you will start querying. So you can see it's right here, a Let entity equal new punk transfer type.
00:13:52.854 - 00:14:05.346, Speaker B: And now we have the entity being populated. The event params from becomes transferred or assigned to the entity from property. And literally it's just signing blockchain data directly to the entity for your query.
00:14:05.346 - 00:14:14.230, Speaker B: Okay, so let's go ahead and look at where your front end queries will go. You have the schema GraphQL. This is how you will query using GraphQL queries.
00:14:14.230 - 00:14:32.750, Speaker B: You have an entity with the ID from to punk index, bytes, all that good information there for your front end to gather information from historical data. So once again, here we transfer we went through the punk transfer event that is near for reference. If you need ideas of kind of how to go through a little bit more advanced.
00:14:32.750 - 00:15:00.974, Speaker B: Let's go into some queries right now, guys. So if you guys have time to start to learn a little bit more about subgraphs, use these questions and compare the questions that are here. Could I answer these questions using the starter subgraph or do I need the more advanced subgraph? And like, how do you figure that out? How do you actually dive into that? Let's start with figuring out the punk transfers, the first ten in the history of crypto punks.
00:15:00.974 - 00:15:18.618, Speaker B: So just going on to the right here through the Explorer, you can just go ahead and start sending some test queries. And I wanted the first ten, so I ordered by the block timestamp and then I had order direction being ascending. And then we're sort of send out that query for a test query.
00:15:18.618 - 00:15:28.818, Speaker B: And this is the exact shape of the query on the left that you would send out to the API end. So you're just testing the queries in the playground, seeing what you want to do with that. So that was pretty basic question.
00:15:28.818 - 00:15:45.070, Speaker B: The first ten transfers in the history of crypto punks. Oh, yeah, I wanted to convert the timestamp to show you guys it actually is accurate. So you get to actually confirm that this is the timestamp of the first transaction in crypto punks history 2017.
00:15:45.070 - 00:15:54.522, Speaker B: On that date plan. What about the next one? Find the total value in e sales of all punks ever. Let's just start with that.
00:15:54.522 - 00:16:07.918, Speaker B: All right. That's a pretty cool question. Now with a starter subgraph, you're like, well, how do we get that? How do we actually compute that in this next subgraph? Through Jerry O'colo, he developed this subgraph and extended it a little bit.
00:16:07.918 - 00:16:13.906, Speaker B: And in a subgraph you can do a little bit of computation. You could actually do some processing. And in this subgraph he does that.
00:16:13.906 - 00:16:29.750, Speaker B: So what I'd recommend for you guys, figure out how he was able to compute that in his mappings. You can do that too. You can gather data from the blockchain and actually say, hey, I want this information to have a little bit of computation and publish this to the query and then you can actually gather that data.
00:16:29.750 - 00:16:35.334, Speaker B: It really does the work for you in that way. It's really nice. So let's go ahead and go.
00:16:35.334 - 00:16:44.982, Speaker B: I'm looking for the question here. Find the total value in each sales. Jerry did very good documentation and I'd recommend that if you are going to be going through this, you want to remember your computation.
00:16:44.982 - 00:16:58.254, Speaker B: So you go to the Schema GraphQL. Remember, this is the last point where you actually send your queries to your GraphQL queries. And on this, I'm looking for the total ETH sales in the history of this.
00:16:58.254 - 00:17:07.294, Speaker B: I'm going through, going through, and I'm like, wait a minute, where is it? Where is it? I know it's here somewhere. And there it is. Total ETH sales for Pump.
00:17:07.294 - 00:17:12.290, Speaker B: So total sales forever. That's not going to be on the blockchain. That requires some computation done in the mappings.
00:17:12.290 - 00:17:34.060, Speaker B: And we don't have to dive into that right now because what I want to do is just show you how you can go to the Schema GraphQL, query his subgraph, and we know it's on the contract. There we go. And the ID is going to be the contract ID.
00:17:34.060 - 00:17:46.970, Speaker B: He defined it like so should be not the ID to contract address. And we want the total amount, trade and ever, and then total sale and total supply. He named these through the mappings TS file.
00:17:46.970 - 00:18:01.246, Speaker B: He organically created these and documented very well. Please go into his documentation and see how he did this. I want this to be a learning opportunity for you guys to see how a basic starter subgraph does it and how a little bit more advanced set, a little bit of math, a little bit of diving into it.
00:18:01.246 - 00:18:11.480, Speaker B: So let's go ahead and continue with the slides before I go on. We're doing good on time. Any questions thus far? Yeah.
00:18:17.450 - 00:18:32.994, Speaker A: My question is just about the delay between the event application on chain and the recording in the graph index four. So how long does it take to index?
00:18:33.042 - 00:18:41.578, Speaker B: How long does it take to index? Yeah. Depends on how much you want to index. I mean, if you have a smart contract deployed, at a certain point, you define that start block and it'll start indexing.
00:18:41.674 - 00:18:55.534, Speaker A: I mean, once it's already deployed, if you want systems that want very near real time information, how fast is the response time?
00:18:55.572 - 00:19:04.098, Speaker B: Yeah, last I heard on the network is around I think it's 42 milliseconds. That's pretty good. Okay, cool.
00:19:04.184 - 00:19:13.234, Speaker A: And just one other question is about the tokenomics. If you want to run, use a graph and indexr.
00:19:13.282 - 00:19:13.542, Speaker B: Yeah.
00:19:13.596 - 00:19:19.862, Speaker A: What does that imply? Good question. It's removed at some point.
00:19:19.916 - 00:19:26.890, Speaker B: Yeah, great question, great question. I'll go for this really quickly. Essentially, when you publish a subgraph to the network, you have to incentivize indexers around the world to get to work.
00:19:26.890 - 00:19:39.930, Speaker B: So essentially you're saying, how much do I want decentralization in my stack? If you only put a few tokens, you're not going to have a whole lot of indexers. Hop in and start indexing. Your subgraph, if you put in a good number that we're seeing across the board is 10,000 GRT.
00:19:39.930 - 00:19:49.102, Speaker B: That gets many indexers to hop in and start indexing. So it just depends on the indexer, their hardware, and the subgraph that they want to index. They want to make sure their hardware can handle.
00:19:49.102 - 00:19:55.474, Speaker B: Maybe you're deploying a massive subgraph. So you want to make sure that the indexer can handle that. And so they have a choice on if they index or not.
00:19:55.474 - 00:20:04.280, Speaker B: With 450, the market is pretty healthy with diving in. With any subgraph you publish and have a reasonable amount of GRT, you're going to get indexed. Thank you.
00:20:04.730 - 00:20:07.250, Speaker A: How can I integrate it into my depth?
00:20:07.330 - 00:20:17.946, Speaker B: Do you have any SDK or whatever? So we have an API endpoint, and you can use we have what's called graph client Apollo. Those are two different options for you. And you can send queries through.
00:20:17.946 - 00:20:25.134, Speaker B: Very it's nicely designed. So, yeah, check out Apollo or graph client API key. Yes, there's an API key as well.
00:20:25.134 - 00:20:28.320, Speaker B: And so I can go through that in a little bit as well. I'll help you out. Yeah.
00:20:28.320 - 00:20:31.280, Speaker B: Okay. Yes.
00:20:33.090 - 00:20:36.414, Speaker A: How's the schema designed. Is it a standard schema?
00:20:36.542 - 00:20:42.340, Speaker B: Yeah, I mean, I can quickly go through that right now. Let's do that. So this is the schema right here.
00:20:42.340 - 00:20:53.190, Speaker B: Does that help answer your question? You can definitely customize it. You can extend it to your heart's content. There's reverse lookups, there's a lot of things you can do with this.
00:20:53.190 - 00:20:57.382, Speaker B: Yeah, that's a lot of power in there too. Yeah, good question. All right, let's keep on going.
00:20:57.382 - 00:21:00.550, Speaker B: I got seven minutes. Awesome. Okay.
00:21:00.550 - 00:21:16.122, Speaker B: So we're able to go through the punk transfer event all the way through. And you can see how just with the boilerplate code of subgraph being spun up, you have a lot of power already. To do a little bit more mathematics, you need Jerry's subgraph or your own creativity.
00:21:16.122 - 00:21:27.170, Speaker B: Let's keep on going. Like I said, these are for your reference. Go into this, slideshow that's in that repo, and you can actually learn a little bit more about patterns that you're commonly seeing in subgraphs and how people are using them.
00:21:27.170 - 00:21:36.126, Speaker B: I'll just skim through these really quickly. Please dive in on your own horde. And we already compared queries with two different subgraphs.
00:21:36.126 - 00:21:45.686, Speaker B: And then finally, this is something that I'm really excited about because you guys are all builders, scaffold e two who's tried or even scaffolds one. I love it. It's amazing.
00:21:45.686 - 00:21:47.506, Speaker B: Yeah. There we go. Kevin.
00:21:47.506 - 00:22:09.802, Speaker B: So Kevin back there has put in an amazing and also Simone has worked very hard together at building this repo right here. I don't know why I said no more QR codes. That's just I apologize again, but this is a blog entry written by Kevin Jones specific to combining a Scaffold ETH two repo with a subgraph.
00:22:09.802 - 00:22:23.474, Speaker B: It's all dockerized, it's all contained, and it has super fast feedback from happiness. That feels really good. When you are able to deploy your smart contract on hard hat, you're actually able to see the exact front end respond immediately and have a subgraph respond as well right away.
00:22:23.474 - 00:22:30.614, Speaker B: It's this really amazing feedback. So, Kevin, Simone, cheers to you guys. Great work with this.
00:22:30.614 - 00:22:40.518, Speaker B: And if I were starting in a hackathon this is where I would go. So workshop takeaways, decentralized indexing is love. That's a good one.
00:22:40.518 - 00:22:49.322, Speaker B: Deploy a starter subgraph in subgraph studio. All right. Just deploying a starter subgraph and querying it in your hackathon project is enough to get some money.
00:22:49.322 - 00:22:53.340, Speaker B: So that's pretty cool. You don't have to do anything crazy, just a starter and query it. That's awesome.
00:22:53.340 - 00:23:04.498, Speaker B: You can trace an event. That's a really good way to learn. You can start from front to back from the schema all the way down to the blockchain, or go from the blockchain all the way to schema and see how how that is handled all the way through.
00:23:04.498 - 00:23:19.458, Speaker B: Hopefully this video helped, this interaction helped. And then also really good way to learn subgraphs and subgraph development is just to play a starter subgraph looking at a smart contract and look at one a little bit more advanced. And I provided that for you today so you could see how that's done.
00:23:19.458 - 00:23:27.058, Speaker B: Compare how a little bit more advanced one is done with some good documentation and just you're off to the races, you're good to go. And scaffold these is helpful too. Okay.
00:23:27.058 - 00:23:38.730, Speaker B: So if you would like to join the graph ecosystem, jobs, network roles and community, go ahead and scan here. I'll never say that QR code thing again. And once phones are down okay.
00:23:38.730 - 00:23:47.022, Speaker B: Oh, there we go. Cool. We're good.
00:23:47.022 - 00:23:58.258, Speaker B: All right. And Q and A. All right.
00:23:58.424 - 00:23:58.706, Speaker A: Yeah.
00:23:58.728 - 00:24:17.494, Speaker B: I was just wondering, is it possible to have any access control over the entity mappings that you were sharing? So there is the authentication that you have, so it is on your computer authenticated. And so if there's anyone who's going to be hopping in, they need that authentication key. I showed mine publicly because that's my developer key.
00:24:17.494 - 00:24:25.980, Speaker B: I don't really care. But that would need an authentication code. You just need to authenticate role based access as well.
00:24:25.980 - 00:24:44.586, Speaker B: So you could have access into the subgraph. There are ways to have like a gnosis multisig that has access into a subgraph and can actually use it and alter it at the dashboard level. And also at the code level, you have the authentication that I copy pasted into the CLI.
00:24:44.586 - 00:24:53.860, Speaker B: So anyone that has that authentication code got it by logging in appropriately either through the multi SIG and that allows a lot of people to use it and then copy paste into the computers. Cool, thanks.
00:24:59.510 - 00:25:06.114, Speaker A: Yes. I was wondering, is there a way to ask the indexer to simulate an.
00:25:06.152 - 00:25:09.762, Speaker B: Event so that simulate an event?
00:25:09.896 - 00:25:30.434, Speaker A: So to simulate a transaction and index the resulting event, this will have use cases like for example, in uniswap, when you want to get the fees that are accumulating, you could just ask the indexer to simulate several tiles.
00:25:30.562 - 00:25:34.246, Speaker B: That's a good question. Let's talk I want to open that up a little bit. That's a good question.
00:25:34.246 - 00:25:36.462, Speaker B: Let's talk afterwards. Afterwards. That cool.
00:25:36.462 - 00:25:42.780, Speaker B: Perfect. All right, thank you. Mike is a mod.
