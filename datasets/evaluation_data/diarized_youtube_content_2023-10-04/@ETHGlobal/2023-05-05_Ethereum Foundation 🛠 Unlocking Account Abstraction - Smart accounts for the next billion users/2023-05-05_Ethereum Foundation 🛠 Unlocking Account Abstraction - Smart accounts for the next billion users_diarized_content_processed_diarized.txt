00:00:07.370 - 00:00:12.830, Speaker A: Hello. My name is Roche. I work with the Ethereum Foundation on account abstraction.
00:00:12.830 - 00:00:35.350, Speaker A: So I'll start by saying what is account abstraction, what we abstract and why? So, before talking about account abstraction, let think. What is an account ethereum account? First of all, of course, has an address where we put tokens, NFTs, whatever. This is our account.
00:00:35.350 - 00:00:50.650, Speaker A: Obviously, we have an authentication, which is a private key, ECDSA private key. This account can execute stuff like send transactions, send ETH, send tokens, whatever. And it pays for gas.
00:00:50.650 - 00:01:15.502, Speaker A: It pays for gas using its own ethereum balance. And all of these is defined by the Ethereum protocol, which means every node on the system knows it, know how to do it, and do it exactly the same, like any other node. So what we abstract, what we try to abstract, okay, basically, almost everything, the account itself will become a contract.
00:01:15.502 - 00:01:32.140, Speaker A: So we have the contract address, the authentication, in order to abstract it, to extract it out of the system, is a method call. It's a method call on the account, we call it we will hear it several times in this talk. It's called validate user op.
00:01:32.140 - 00:01:43.770, Speaker A: The execution can be abstract to whatever you like, okay? We provide sample execute method or execute batch method. You can add more if you like. And gas payment.
00:01:43.770 - 00:02:05.220, Speaker A: We also select that we have a paymaster contract, which again, once it validates a request, it accepts to pay for this transaction. And the cute thing about all of this is that this is all done without any change to the core protocol. It is live on testnets on Mainets today.
00:02:05.220 - 00:02:23.766, Speaker A: So what can we do with it? Okay, this is a very short summary of what we can do. Authentication. With a normal account, you have exactly one way to authenticate that is sign a transaction by a single signer.
00:02:23.766 - 00:02:35.018, Speaker A: And if you want multiple, you have problems or you have MPC or something fixed. But with account abstraction, you can do a wide range of authentication methods. You can choose different signatures.
00:02:35.018 - 00:02:50.260, Speaker A: And I gave you an example, two edge cases. One of them is a simple gaming system where you want the browser to sign each transaction as long as it to this limited contract account. So you want a very easy signing for gaming account can support that.
00:02:50.260 - 00:03:03.000, Speaker A: On the other extreme, you have a corporate account in which different roles have different access. Some are multi sign, some allowed only to transfer ETH. Some have limits, some allowed only to vote, I don't know, whatever.
00:03:03.000 - 00:03:13.386, Speaker A: So you can have account of any of these. And by the way, when I'm saying use cases, these are use cases that can use account abstraction. We don't support any of these.
00:03:13.386 - 00:03:24.270, Speaker A: You as developers are here to try and find use cases that you can do all of this stuff. Payment. Again, the account can pay for itself.
00:03:24.270 - 00:03:31.258, Speaker A: This is the default. But there can be a Paymaster. And the Use cases for Paymaster again are endless.
00:03:31.258 - 00:03:42.846, Speaker A: I gave you two highlights as an example. One of them is onboarding Paymaster. Let's say someone has adapt and he wants to sponsor some requests.
00:03:42.846 - 00:03:53.554, Speaker A: All requests? I don't know of its users. It's possible you can have a Paymaster that will accept under some condition. It can decide what the conditions are and accept this request.
00:03:53.554 - 00:04:08.806, Speaker A: And these requests are approved by the Paymaster. Another example very common, very thoughtful example is a token paymaster. A paymaster that will pay the transaction.
00:04:08.806 - 00:04:21.082, Speaker A: The transaction is in native token in east. But the paymaster will make sure the user has enough balance will convert this. User's tokens into the native token and pay for the transaction.
00:04:21.082 - 00:04:46.902, Speaker A: So from the user's point of view, he is paying with tokens. But again, it's not the system, it's a specific paymaster that decide if and how to do. It other use cases you can do is we think of are in recovery mechanism the first and foremost actually most people don't talk about it at all is change your key think about that with normal private key once you have an address.
00:04:46.902 - 00:05:00.034, Speaker A: It is impossible to be changed. Even if you think it might have been leaked, you're screwed. You either replace it completely or go and hope that no one will ever use it with account abstraction.
00:05:00.034 - 00:05:30.546, Speaker A: Account can support change key. Every normal web two application have change password. And if you even suspect that your account address was credentials were compromised, replace it with something new, other more complex recover mechanism like social recovery can also be created like you trust friends to replace your account or do a deadmill recovery or other examples.
00:05:30.546 - 00:05:41.580, Speaker A: We have a full talk about half an hour. A full hour of examples of use cases like I described here. And more so you can look there.
00:05:41.580 - 00:05:56.654, Speaker A: By the way, it's a QR code of the presentation. You have everything now I'll try to jive and explain the components we have with account abstraction. The first component, of course, is an account.
00:05:56.654 - 00:06:23.030, Speaker A: An account is a contract that performs the logic of validation and execution. We'll see it in work. The second component we call it an entry point users don't see the entry points at all developers know about this existent this is where the magic happens this is the on chain contract that performs all the validation and it is trusted by the contracts.
00:06:23.030 - 00:06:33.610, Speaker A: The next component again. It's a contract is the Paymaster. As I said, a paymaster is a contract that accept to pay the gas fees of some transactions.
00:06:33.610 - 00:06:46.458, Speaker A: On the second row we have user operation. Actually, I'm saying in this talk transaction interchangeably with user operation. We call our account abstracted transaction.
00:06:46.458 - 00:06:55.810, Speaker A: We name them a user operation. So a user operation is equivalent of transaction. You fill all the data in it some more data than normal transaction.
00:06:55.810 - 00:07:12.162, Speaker A: You sign it using your account signature whatever signature system it uses and you submit it. The next component we have we call a bundler. As we said, we didn't change the Ethereum network, we didn't change the protocol.
00:07:12.162 - 00:07:26.630, Speaker A: There are still nodes to run the system. But in order to put user operations on the network we had to add another off chain component we call a bundler. You can think of a bundler as a node.
00:07:26.630 - 00:07:43.918, Speaker A: We actually believe that in a production network it will be run adjacent to a node. It's a functionality of a node to put user operations on chain. Lastly, the last component, like in any Ethereum decentralized network, there is a mempool.
00:07:43.918 - 00:08:04.870, Speaker A: Again, it's a mempool of user operation, not a mempool of a transaction. And it is important to understand the system, but usually are not interacted directly by users or developers. Now let's look at the flow, how user operation is executed.
00:08:04.870 - 00:08:20.934, Speaker A: The big component here, this is my wallet. This is an off chain. Think of MetaMask or Sol wallet or any other wallet that implements account abstraction and the wallet creates a user operation.
00:08:20.934 - 00:08:59.654, Speaker A: It has many fields, as I said, like normal transaction and several new fields we'll see later, but like Paymaster and the signature, depending on my account, the user operation is sent into the mempool like normal transaction. But this is a user operation mempool. The bundlers are looking probing this mempool and they pick up the user operations they want to put into the next bundle, the next block they want to sorry, bundlers, as I said, are off chain.
00:08:59.654 - 00:09:20.830, Speaker A: Think of node. It's a node. It's a node with a special functionality for supporting user operations, supporting account obstruction, anything you ask alex, for you to use Ethereum, do you need to be a node? Okay, the same answer.
00:09:20.830 - 00:09:38.450, Speaker A: Because as I said, user operation is a transaction. Bundler is equivalent, it's a little different, but it's equivalent to a node. So you don't have to be there has to be nodes in the system or there has to be bundlers in the system to support it.
00:09:38.450 - 00:09:58.920, Speaker A: So the bundler picked up user operations. And just like a node, if you think about it, a node takes a set of transactions validates that the balance is correct, the signature is correct and the nonsense correct, and then create a transaction. The bundler does just the same, it validates a transaction.
00:09:58.920 - 00:10:13.820, Speaker A: But the way it does a validation is a bit more complex. This is the simulation phase. It calls a method in our entry point which calls the validation function the validation of the account and the validation of the Paymaster.
00:10:13.820 - 00:10:26.816, Speaker A: If both these methods say okay, this is a valid transaction, it means the signature is okay. It means the nonce is okay. It means it will pay for the transaction, someone will pay for it, the entry point will validate it.
00:10:26.816 - 00:10:40.876, Speaker A: It's a call on the entry point. It knows that this user operation is valid. So the next phase after validating actually each of these user operation, it will go into the execution phase where it creates a transaction.
00:10:40.876 - 00:10:56.824, Speaker A: We call it it's a method called handle ops. It gets an array of user operations and it created transactions with it and put it on chain. What this transaction will do it first repeat the validation of each user operation.
00:10:56.824 - 00:11:47.160, Speaker A: Because we don't trust nobody to do anything off chain we call the validation all the validation repeat the exact same validation we did the bundler did previously off chain of course revert if any of them revert and if they all succeed, we continue to the execution phase. We call the execute method of the account whatever it's written there and then you can see that for a paymaster we also call what we call a post op a post operation so that a paymaster has a method called before and after the transaction. The method before first validates and then it can do other stuff like reduce the user's tokens to make sure that it will be used and at the post op it will refund whatever the excess that was not in use the account execution of course executed transaction.
00:11:47.160 - 00:12:06.668, Speaker A: So this flow is done for each user operation? Yes. The message sender is the bundler of the entire transaction. But for each user operation, the execution is an execute method of the account.
00:12:06.668 - 00:12:30.586, Speaker A: So if the account executes token transfer because I want to transfer tokens, the token sees me the account contract as a sender the transaction origin will be the bundler. The MSG sender will be the account. Yes, the account is wrapped.
00:12:30.586 - 00:12:33.982, Speaker A: There are two gotchas. Okay, I'll get them in a moment. Okay.
00:12:33.982 - 00:12:46.050, Speaker A: This is one of them? Yes. Origin if you can avoid it, it's deprecated for a reason. With account obstruction, it becomes even more useless.
00:12:46.050 - 00:12:59.720, Speaker A: There is no good reason. All the good reason to use TX origin are actually wrong. If you think you're protecting yourself by somehow using TX origin, you are wrong because it doesn't protect you.
00:12:59.720 - 00:13:21.534, Speaker A: So if you want to block account abstraction or contract accounts, then use it, go ahead. But if you want to protect yourself against replay against bots again you are not yes use message sender. Okay.
00:13:21.534 - 00:13:44.466, Speaker A: The transaction itself is paid by the bundler because it is the one who put the transaction on chain. But the logic of validate user op, as we will see in a moment that the account is supposed to pay for itself. So the account pays the bundler? Yes, the bundler pays the node and as I said, a bundler and a node that distinguish is blurred and they're usually the same entity.
00:13:44.466 - 00:14:09.654, Speaker A: So yes, it pays for itself for the execution and gets an extra by the account itself that pays for the transaction. Now, if you think about the incentive model of Ethereum, why do transaction get included? Why do a transaction cannot be censored? Because there are nodes out there that eventually will take out of the mempool transaction. The same is true for bundlers.
00:14:09.654 - 00:14:17.354, Speaker A: These bundlers are not ours. We define the spec, we create a reference. There are already five implementations of bundlers.
00:14:17.354 - 00:14:33.810, Speaker A: We are working on the code that they will work with the mempool. Yes, it is still work in progress, but usable as they are today. So again, to recap EOA against user operation.
00:14:33.810 - 00:14:55.766, Speaker A: As I said, account itself with accounter pressure it's a contract instead of ECDSA. It is secured by its own code to do the validation. A wallet with normal account can do a single operation which is approve approve everything because you sign whatever it is with account obstruction.
00:14:55.766 - 00:15:03.774, Speaker A: You have custom UI. You have custom logic in the account itself to do whatever you like. Mempool mechanism generally it is the same, it is different.
00:15:03.774 - 00:15:22.680, Speaker A: Object and block builder is equivalent to bundler and its verification is a little bit more complex because it does a view call. But otherwise it does just the same. Now I've go linked a little into the contract itself.
00:15:22.680 - 00:15:34.700, Speaker A: The only method an account has to implement is validate user op. Yes, of course. It needs to do some execution, but it is not we.
00:15:34.700 - 00:15:54.350, Speaker A: As we write the ERC four, three, seven we define the interface, the concrete interface between actually the entry point and the accounts, how they call the accounts. So we define that an account has to have this validate user of method. This method received the user operation itself.
00:15:54.350 - 00:16:04.510, Speaker A: It received the hash of the user operation. The account can calculate it, but we already need it. So we pass it to the account itself and someone asks about payment missing funds.
00:16:04.510 - 00:16:16.502, Speaker A: The account has to pay its sender, which will always be the entry point. It will receive the amount it needs to pay how much is already missing. We maintain a balance deposit within the entry point.
00:16:16.502 - 00:16:29.578, Speaker A: If you have enough, or if there is a paymaster, you will get zero for these missing funds. Otherwise, you have to pay at least this amount to cover your user operation. This is the code of the base account.
00:16:29.578 - 00:16:37.658, Speaker A: It's the base contract. You don't have to use it, but we think it's very easy to use it. It templatizes several of the things you need to do.
00:16:37.658 - 00:16:47.674, Speaker A: So we of course require the call is from entry point. You will get griefed and someone will steal your money if you don't do it. Recall the stub method.
00:16:47.674 - 00:17:04.760, Speaker A: We'll see in a moment to validate the signature. It will validate the nons if needed and pay prefund is pay this amount if it is not zero back to my owner. So validate signature is the method I need.
00:17:04.760 - 00:17:23.434, Speaker A: Pac validation data is a helper method needed for use cases like gaming. If anyone want, I will not go deeply into that. But you can define that a validation is valid for a specific range of time.
00:17:23.434 - 00:17:43.010, Speaker A: Like if you have a game and you want that your transaction will be valid only for half an hour from now. There is a way for a wallet to convey that information back to the entry point. It is not allowed to use directly the timestamp opcodes, but it can return it using this method.
00:17:43.010 - 00:18:09.578, Speaker A: So, as I said, this is the base account we have and we also have a simple account which is a concrete implementation that uses it and tries to emulate an EOA as much as possible. It uses simple signature. It uses the same signature using ethereum signed message so that you can even use MetaMask signed message to sign it.
00:18:09.578 - 00:18:17.402, Speaker A: So this is the actual code of validate signature. It takes the user operation hash. It adds the ethereum signed message prefix.
00:18:17.402 - 00:18:26.990, Speaker A: This is an open zeppelin helper. It does easy recover. If it is the wrong sender, it fails, otherwise succeeds.
00:18:26.990 - 00:18:44.418, Speaker A: A little note about this method it can revert. Revert is also a way to say okay, I failed. We did add a different mechanism to report a signature failure because we do want to be able to do the equivalent of ETH call.
00:18:44.418 - 00:19:11.178, Speaker A: You want to be able to take a transaction and call like you call the node you call ETH call to make sure that the transaction succeeds. You want to be able to do the same with to estimate or simulate the user operation before the user signs it. And there is no way for us to tell the account itself that it doesn't need to sign that we give it a transaction with wrong signature.
00:19:11.178 - 00:19:19.890, Speaker A: The account doesn't know it is called it's very important in our system. It doesn't know it is called off chain or on chain. It behaves exactly the same.
00:19:19.890 - 00:19:42.230, Speaker A: So what we say that if the signature is wrong, it simply return an error. It is the entry point to decide which nodes. This is a simulation okay, I return it even though it's a signature failure or is it a real execution, I will revert this transaction because it's a wrong signature.
00:19:42.230 - 00:19:55.306, Speaker A: These are the basic execution methods. These are actually very simple. Again, they require from entry point so that only the entry point can call it.
00:19:55.306 - 00:20:22.914, Speaker A: It can be entry point or owner because we make our wallet also callable directly by its owner without account subtraction. And there is an execute batch we created which get an array of destinations, array of function and someone might say okay, why don't you pass value here? I said you are complete, right? You are free to take this simple account, add a different execution method and use it. This is not part of the framework.
00:20:22.914 - 00:20:36.362, Speaker A: This is a sample sample account. You can add as many functions as you like to the account and okay, this is the implementation of a base paymaster. Just like an account.
00:20:36.362 - 00:20:51.960, Speaker A: We have a template method of validate paymaster and postop. Okay, these are the contracts. Now, the contracts can't work alone.
00:20:51.960 - 00:21:10.108, Speaker A: Each contract has to have a wallet that works with with the normal EOAS, you have exactly one account type. So every wallet will work with that, just one account type, which is EOA with account abstraction. We have different account, and each account needs a wallet.
00:21:10.108 - 00:21:20.660, Speaker A: And by wallet, I mean the desktop, probably chrome extension or whatever. And the account is the contract. So each account need a contract.
00:21:20.660 - 00:21:40.590, Speaker A: Sorry. Each account contract needs a wallet to work with. So, to help hackers, we created a project, a boilerplate Chrome extension we call Trampoline, which can help you create a new account.
00:21:40.590 - 00:22:02.930, Speaker A: It is inspired by tallyho and MetaMask, but it is written from scratch. So within this framework, you can replace the account contract and you can replace the UX that works with it. This is the UX that works with the standard simple account.
00:22:02.930 - 00:22:25.448, Speaker A: So, the basic component, we have an account API that gives a high level JavaScript APIs we need in order to work with the account. And we also provide three UX react components. Onboarding is a UX that will pop up when you create the account.
00:22:25.448 - 00:22:39.260, Speaker A: Like if you want to collect some information from the user or nothing. If you are silent, you don't need to collect anything. Transaction is the UX that will pop up whenever you send a transaction and of course, signed when you create a signature.
00:22:39.260 - 00:23:05.060, Speaker A: Now, a simple account has to implement several things in order to support a contract. The first is the init code because very important part of an account is to be able to deploy itself. So it is this account API that knows its account implementation, that knows how to create the constructor, so it creates the constructor signature.
00:23:05.060 - 00:23:22.540, Speaker A: Now, in order to create a transaction, it needs first to get the Nuns, the next nuns to be used. Again, this is not some standardized, it is the account to implement this method underneath. And we need to encode the actual transaction.
00:23:22.540 - 00:23:50.292, Speaker A: Once it creates a user operation with this method, we need to sign it again. There's an onboarding, which is an asynchronous UEX that have a method to call if it needs to collect data in order to send a transaction. And then the transaction itself can modify the transaction just before it receive.
00:23:50.292 - 00:23:58.780, Speaker A: Okay, it is called just after send transaction is called by the application. The application calls send transaction. This provider received this transaction.
00:23:58.780 - 00:24:19.410, Speaker A: Now, this looks like a transaction, but we convert it and create out of it user operation. That will look like CT comes from the account and it's submitted into the blockchain. So let's see how it looks here.
00:24:19.410 - 00:24:37.204, Speaker A: Okay, first of all, in order to install it, I'll need to disable my MetaMask, enable developer extensions and where am I? Okay. I'm here in the trampoline project. I should do yarn start.
00:24:37.204 - 00:25:06.640, Speaker A: I already started it, so I can do it and inside this trampoline project I load this unpacked the build folder as a Chrome extension the Chrome extension is built as a framework as NSN extensions. So this is the framework that I want to create an account. This is the first customizable page.
00:25:06.640 - 00:25:35.770, Speaker A: As I said, this is the onboarding page. You can put whatever you like here you can see this is the onboarding I can open it and add if I want to collect more information. The output of this is a context and this context is passed to the account to create this sample doesn't need any no, it create a private key and it create private key and address and pass it back to the account.
00:25:35.770 - 00:26:06.410, Speaker A: Now out of this account I can see its address and it is not deployed. I don't have a sample here with a paymaster so what I will do is I will send little ETH so it can be deployed. You can see how much it's a max limit, how much it needs to be deployed, why it doesn't ah, it's here.
00:26:06.410 - 00:26:39.348, Speaker A: I will send some ETH to it. Okay, I hope Gary will get it fast now. Okay, good for the demo.
00:26:39.348 - 00:27:07.230, Speaker A: Okay, now I have some ETH in my account. I can deploy it here but instead of deploying I want to send the first transaction I open Ether scan this is a pre deployed standard greeter sample and I will use an application I want to call this said greeting I will connect Ethscan to my account it says MetaMask. Sorry for that.
00:27:07.230 - 00:27:45.160, Speaker A: And this is our extension pop up a connection request, we will accept it and there we can send and I can put some message in again, this is a stub sign in account. We can remove it completely or put if we want to collect more information. Now I see again the transaction data that I want to approve I could have skipped the framework can be set so you will not show this transaction.
00:27:45.160 - 00:27:58.056, Speaker A: Oh, it said I didn't pay. Just a second. Okay, it means it is a little more expensive than what I passed.
00:27:58.056 - 00:28:16.370, Speaker A: It great for sample. Sorry, already out of time. Okay, that means we are out of time.
00:28:16.370 - 00:28:48.024, Speaker A: I want to show you some transaction so we didn't build it alone. We have a lot of partners who worked with us stack app, Alchemy and others build bundlers zero dev candidates sole wallet already built an ether spot build some SD tools you can use a trampoline you can doze SDKs if you want more resources, you have them here. If you didn't copy the QR code before, this is the bigger one that you can use.
00:28:48.024 - 00:28:50.950, Speaker A: We will be here outside if you want to ask more care questions and thank you.
