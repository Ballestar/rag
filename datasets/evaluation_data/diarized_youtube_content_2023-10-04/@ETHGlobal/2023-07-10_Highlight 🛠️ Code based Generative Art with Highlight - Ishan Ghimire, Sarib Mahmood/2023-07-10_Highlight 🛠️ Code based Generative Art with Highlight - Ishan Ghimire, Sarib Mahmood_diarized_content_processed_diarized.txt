00:00:07.770 - 00:00:44.218, Speaker A: All right, so welcome to our presentation. Thanks for being here. We're a highlight. So we're a platform to help creators build code based generative art collections. So Highlight kind of helps creators use no code tooling to deploy collections, create gated content, create a portfolio, kind of survey their content on chain. But what we're most excited about is code based generative art. So we're really inspired by artists like Kim Asendorf, who's a popular artist in the generative art space that we're working closely with because we're going to be launching a platform at the end of this month.
00:00:44.218 - 00:01:23.138, Speaker A: So, like I said, Highlight kind of offers no code tooling. With this code based Sherid of art, you're going to be able to integrate, like, AI models. Gans we kind of do all the stuff in the background for you to create beautiful mint pages and all these sort of things. And this summer, we're going to be collaborating with a bunch of artists and brands just to kind of push the boundaries on code based Sherid of art. So OpenSea coinbase. Obviously, our friends at ETH Global are some of our partners. So today, what we're going to do is we're going to help you kind of like we're going to walk through what it takes to deploy a code based shared of art collection on Highlight.
00:01:23.138 - 00:01:56.478, Speaker A: And we're going to switch back and forth with technical explanations of some of the cutting edge protocol innovations we've made. Also some of the new stuff that we've developed on the generative art side. Yeah. And so Sarab is going to walk you through that. But before we jump into creating a collection, I just want to show you what an end product looks like. So if you come to Highlight and create a generative art collection, we're going to create this kind of, like, mint page for you. So this is kind of like your typical collection on Ethereum or on an EVM chain.
00:01:56.478 - 00:02:44.762, Speaker A: And the way that it works is when you mint a token from this collection, what we do is we take a bunch of parameters from the transaction, the mid transaction, like the transaction hash, the block, hash, the token, ID, the timestamp, like, all these different sorts of things. We input it into the script that the artist initially uploaded. So the actual generative art script. And with that custom input that's unique to your transaction, that script is going to output a unique NFT, and you're not going to know what the NFT looks like before you mint the token. So, for example, we can iterate through possible outputs. So if I press randomize here, what's going on is we're just sending in, like, virtual parameters. So we're like virtualizing a transaction.
00:02:44.762 - 00:03:10.646, Speaker A: So virtual transaction, hash a token, ID, block, hash, that sort of thing. And we're inputting it into the script that the artist uploaded. And this is outputting what you see here. So this is like an example NFT that you could mint. So before Sarub is going to walk you through actually deploying a collection like this, we're just going to mint one. So press mint here. This collection is on Gorely.
00:03:10.646 - 00:03:37.460, Speaker A: It's going to ask me to pay a small fee, which I will happily do. And as you can see here, we have a pending transaction. And what's happening in the background is Highlight is going to pick up this transaction and then pass these mid parameters into the script. And then it's going to output a render through our rendering engine. And that metadata is going to get assigned to our token. So this should complete. It's happening right now.
00:03:37.460 - 00:03:55.030, Speaker A: Once it completes, you can view it on a marketplace, on either scan, kind of whatever you want, but you're not going to know what it looks like. Should sign right about now. There we go. So that's kind of the output.
00:04:05.230 - 00:04:34.178, Speaker B: Yeah. So we've already gone through the actual Mint page. What we're going to go through now is actual the creation page of this. Basically how you end up with that Mint page at the end of it. As we're going through, we'll go through the technical details of it, what basically happens in the background to end up with or how we capture the image or the traits of the token. So I'm going to go ahead and create a collection. So this is basically we provide different types of collection.
00:04:34.178 - 00:05:03.342, Speaker B: Goes from generative to series, to open edition, limited edition. And one of one, which is basically auctions, the one we're going to focusing on is going to be the generative series. So I'm just going to go ahead and create a collection. The first page you see is basically just it basically takes you through what's needed to render generative art based. One of them is index HTML, which is basically your art. And that's what's rendered in an iframe. And then you also have the highlight gen script, which I'll go through the details of it.
00:05:03.342 - 00:05:35.126, Speaker B: But all it does is provide a bunch of attributes which are related to the transaction. The creator can decide when they want to capture the image, the attributes of the token and everything. So again, there's an example project that you can actually download. So you don't have to write the script yourself. You can just play with it. But yeah, let's go ahead. I'll just take you through the so it's going to be open source soon, but for now it's kind of like in restrictive mode.
00:05:35.126 - 00:06:03.780, Speaker B: But I'll take you through a few of the methods of the GenScript that it provides. So as Aishan was mentioning that we basically virtualize a transaction when you actually mint something. So we've got two methods which are generate random hash and generate random address. All they do is basically just map through alphabets and create a random transaction. So you don't have to actually create a transaction. It'll just create a random transaction. Provided to your script and in the end you can actually see what the output of the art looks like as you keep going down.
00:06:03.780 - 00:06:55.138, Speaker B: The two main methods that we use here are these are both open source XMR three, which is a hashing algorithm. It's available anywhere in the public repository. And then SFC 32 what we do with these algorithms is that when you actually call so one of the main methods that you call on the script is random, which works like math random, if you've ever played with it, gives you a random number between zero and one. But the way we do it is basically it's a pseudo random number generator. It takes a seed using these two algorithms. And the way it works is if I go to the seed method, it's going to take in so it's going to take in the hash and the token ID to generate a seed. And then the seed that gets inputted into Sudo random numbers generator and you have a random number which basically every time you input the same transaction, you'll have the same art.
00:06:55.138 - 00:07:36.038, Speaker B: So what happens is when you mint, we basically provide the same transaction, hash, block, hash and all those values so that gets encoded on the chain. So every time you open that URL, you'll have the same art on the blockchain. In terms of creators, the two main methods that creators are usually concerned with or they have to play with are the capture preview and set at reviews. What they do is basically capture preview is if you've ever gone on OpenSea, you've looked at an image of a token. That's what capture preview does is that you can actually call this method anytime in your script that tells highlight that you're ready to capture an image. For the token, we take an image of the token and upload to OpenSea and that stays there. And same with site attributes.
00:07:36.038 - 00:08:17.294, Speaker B: We take the attributes, we basically upload that to OpenSea and then you have that encoded on chain. So going back to the creation process, I'll just get started with a random script. So I have a few bunch of demo scripts. I'm just going to run through one. So I'll take this, it'll basically upload that to our centralized server and at the same time we use RV as our decentralized server. It uploads that to RV and it stays there for permanency and then for validity of the code, again I'll go through yeah, so once you land on this page, it's basically a test script page. You have your P five JS JavaScript file which renders the art.
00:08:17.294 - 00:09:05.450, Speaker B: So this is basically what the code renders. And then these are traits on this side which we capture in like so if you actually refresh or change the attributes. So if I'm going to randomize it, the traits are captured using our rendering engine with the script and a virtual transaction. So as a creator, you can actually play around with changing the hashes, transaction hash, block hash, and you'll see different script, different traits, and you can just basically validate your art as you want it to be. So again, you can not only randomize it, you can actually input custom hash, which will come in handy when we go to the next step. So if I keep moving forward, this is one of the key pieces of the generative art addition size. You can put it to anything.
00:09:05.450 - 00:09:42.614, Speaker B: Like, I'm just going to go with 20. But this part is what allows the creators to say that they have a set of hashes that they want their art to use. So you can have a creator can say, like, I want only these 20 set of hashes to use for my art. So whenever a Mint happens, we pick randomly from one of those 20 and we assign that to the metadata. And that makes sure that whatever the art the creator wanted is basically just given to one of the collectors. We'll go through the details of how that happens, but I'll just give a demo of what that looks like. So basically, as a creator, you can come here, you can say, I like this one.
00:09:42.614 - 00:10:30.786, Speaker B: So if you click basically add, it adds to the selected hashes and you can keep on changing, generate more tokens, they'll take different virtualized transaction and you can keep on adding them. So you build a list of transaction hashes that basically the collectors would use for their Arc. Just going back to the details of it. So the way it works is basically we've already gone through this part, which is that you have a set of hashes, but we have basically EVM Data Manager, which listens to live events on contracts. Whenever an event happened, let's say a Mint happens, we pick that event up. It processes through our pipeline of transaction service. And when it ends up at this service, what it does is that it basically knows that a Mint happened and what was the transaction of that Mint.
00:10:30.786 - 00:11:01.298, Speaker B: So it grabs the transaction details from the EVM chain, let's say optimism, Arbor, Term, or any of the chains, and then it uses those inputs, which would be transaction hash, block hash, token ID, and it uses the Mulberry 32, which is, again, open source Algo. It inputs those values into the Algo. And again, this is the algorithm. And then it outputs a number. So the number can be whatever your collection size is. So let's say I just inputted 20. If I input these transaction hash block hash, I'll get a number anywhere between one to 20.
00:11:01.298 - 00:11:53.554, Speaker B: Given that number, I'll just use this list of hashes that creator wanted and just pick one of the transaction hash and use that hash for the Arc. A few key things about this whole process is that this algorithm is independently verifiable, which means that the algorithm is publicly available the transaction is available on chain, you can basically run the same algorithm over and over and get the same output. So even though it's running centralized, you're always free to just verify that you got the art that you were supposed to get. The second part is that we guarantee processing of events in order. What that means is if you mitate a token first, let's say you got Token ID One and someone has got Token ID two. We make sure that the transaction of Token ID One gets processed or gets the art first, then the Token ID two. That's important because there is a point where a collision can happen.
00:11:53.554 - 00:12:22.060, Speaker B: So let's say someone gets the curated hash number one, and another one got the one. So you want to make sure that the first one who is the valid recipient of the art gets it before the other one. So this is basically two key details of our algorithm and how it basically assigns the metadata. So going back to it, I'm just going to hover through it for simplicity's sake. I'm just going to discard this. So I'll discard the selected outputs. I'll go through the next step.
00:12:22.060 - 00:12:55.814, Speaker B: This is, again, another one of the point where the creator can validate what they're actually trying to capture is actually equal to the live view. So this is the art being rendered in an Iframe on the live view. So it can be basically anything. Right now, it's a static image, but it can be moving image, but the preview image would be the one that's a PNG or JPEG or something. And that's what we capture at Runtime. And these are the values that the creator has, so they can provide a delay. So if your script takes longer to run, you can say, like, I want it to capture up to 22nd.
00:12:55.814 - 00:13:07.530, Speaker B: You can change those values, you can change the image resolution. And once you validate the art is valid, you can go to the next step at this point, ishan will come and talk about the details of the protocol.
00:13:08.750 - 00:13:23.902, Speaker A: Sweet. Thank you. Saurabh all right. Yeah. So we ran through all the generative art stuff. Now let's deploy the damn thing. So we're going to just configure a bunch of details about the collection.
00:13:23.902 - 00:13:52.410, Speaker A: Configure details about the mint. You can deploy this collection on a bunch of EVM chains. We support five right now, but we're going to keep adding them for this mint. We're just going to go with Goreli. Yeah, you can basically customize, like, whatever you want about the contract, add it to the filter registry, whatever you want. We'll just put in some dummy values for this swadalu. 2023 upload a custom logo that represents a collection.
00:13:52.410 - 00:15:09.780, Speaker A: And you can also make the tokens on the collection non transferable. And the way that this works is that we have like the collection that you deploy is highly modular, so you can swap in pretty much any behavior you want to define how the NFTs on your collection operate. So coming here, the collection that you actually deploy basically can refer to a bunch of modules. So almost anything that you want about the collection that you want to modify, like the behavior you can. So whether that's burns transfers, how the metadata is rendered, how the metadata can be updated, how the royalties can be updated, how the NFTs can be minted, you can have your own custom smart contracts or use some of our modules and then swap it into the collection, and then swap them in and out, remove them, that sort of thing. So a couple of interesting things about this is one, because you're swapping in essentially your own code, you can introduce any behavior, right? So any conceivable logic on chain, you can swap it into your collection. So that takes collections from having you being able to configure stuff about the who, like who can mint this NFT, or who can update metadata to who, what, where, when, right, because you're writing custom code.
00:15:09.780 - 00:15:53.230, Speaker A: Another thing about these modules is they're what we like to call composably autocratic, which means that they can define their own behavior about if they can be swapped or if they can be removed. And a second order consequence of this is that creators and collections can define a path to gradually decentralize the collection. So like an example of this is, let's say when we first deploy this collection, we have a really simple module for the metadata. The metadata is frozen, nobody can update the metadata and only the owner can swap this module out. And then the mint happens. All the NFTs are distributed, maybe to each one of you. Everybody owns the NFT and then the owner can swap this module out for a more decentralized module.
00:15:53.230 - 00:16:25.450, Speaker A: Right? So module two now says that if all the holders of the NFT on the collection vote on updating the metadata to something of their choice, they can. And also maybe if they vote, they can also vote to swap the module out. So you've not just decentralized who can update the metadata, but you've also decentralized who can define the behavior of who can update the metadata. So it's kind of like a meta decentralization. And then yeah, maybe after this they vote to also swap this module out for an even more open module.
00:16:26.270 - 00:16:26.586, Speaker B: Yeah.
00:16:26.608 - 00:16:35.806, Speaker A: So here's like a really quick sample implementation of what a module looks like. This is solidity, if you're familiar. I'll zoom in just because might be a little small.
00:16:35.988 - 00:16:36.286, Speaker B: Yeah.
00:16:36.308 - 00:17:03.434, Speaker A: So can update metadata. This example implementation, what it says is all the holders of the NFT, if like over 50%, want to update the metadata to something, they can also they got to do it before a certain time that tiesab is also an Easter egg. It's a Unix timestamp. I'm first one to figure it out. I don't know, I'll give them like that amount in GWe or something. But there's also can swap, can remove itself. So this is like the composable autocracy part.
00:17:03.434 - 00:17:26.186, Speaker A: So in this example, implementation, this module is fully locked in. Like this behavior is locked into the collection. And then finally you can define behavior about transfers. Right? So like here we wanted to make our collection non transferable. So all the tokens are in this case, consensually and non transferable. Sweet. So coming back to the collection creation.
00:17:26.186 - 00:17:44.802, Speaker A: All right, so final page before we deploy the collection. Now we're going to define the mint details. So you can sell each of these tokens at a fixed price, or you can use a Dutch auction, which is schedule of decreasing prices. But we'll keep it simple. We'll go with a fixed price. Maybe we'll make it free. You can define kind of all these mid parameters.
00:17:44.802 - 00:18:31.666, Speaker A: When it starts, when it ends, maybe only let each person mint two tokens. And then something really interesting we have here is we have this idea of gated minting. So you can create kind of these really complex gates that restrict who can actually mint on the collection. So let's create a gate, call it demo. And you can add like a bunch of these conditions. So maybe the first condition we want to add is only holders of board Ape with a certain metadata attribute can mint on this collection. So we can go to this condition, come to the board ape, kind of OpenSea collection page, paste that in maybe, I don't know, board apes with a purple background can mint on this collection.
00:18:31.666 - 00:18:48.230, Speaker A: And then we can add another condition, like holds a minimum amount. So you have to own that board ape with a purple background. And you have to hold a minimum of two ethers. So it's very elitist mint. But we can change this to all. So you can switch between like an oraclause and and clause.
00:18:48.390 - 00:18:48.714, Speaker B: Yeah.
00:18:48.752 - 00:19:08.190, Speaker A: And so we can just create this complex gate. And now the gate is applied to the mint. So the way that our mint works is creators can actually gaslessly swap this gate in and out. So this is a good summary of our mint architecture. This is what it looks like on chain. The mint module is a smart contract. The collection is another.
00:19:08.190 - 00:19:37.574, Speaker A: That's the one that's a smart contract we're going to deploy for you guys. We have this concept of mint vectors. So mint vectors are just like different ways to mint on the collection. So you can paralyze a bunch of different sales, right? So you could have a mint vector that's like only board ape holders can mint at this for a free price. You could have another mint vector that's going on at the same time that's like for a public mint. So it's analogous to mint phases on a normal collection. So at the top left, you see the user comes to highlight they want to mint on the gated mint.
00:19:37.574 - 00:20:11.350, Speaker A: We evaluate their blockchain account, make sure they can actually Mint on the collection, and then we construct a key. We pass the key into the module. We unwrap this on chain with EIP seven, one, two, and then we Mint on the collection. And because these vectors are off chain, the creators can actually come in and kind of edit the Mint config without a transaction. So that's like a nice detail for them. Sweet okay, so I think we've configured the Mint. We can just review everything that we've created and then deploy this collection.
00:20:11.350 - 00:20:19.630, Speaker A: MetaMask is going to pop up. Sweet.
00:20:32.360 - 00:21:00.860, Speaker B: Yeah. So once the Mint is actually deployed, we're just going to quickly go through I think we're running off time, but we'll just quickly go through the actual Mint page. So if you land on the Mint page, basically we've done full circle where we started from. You have the actual art. You can mint it because it's a gate. I don't think I have that much either. So I'm just going to go ahead and remove that gate, which kind of serves as a purpose to show that.
00:21:00.860 - 00:21:43.720, Speaker B: So I go ahead it kind of happens in a gas plus way. So I'm just going to go ahead, save it, and once that's done, I'm just going to go back to the Mint page and I'll be able to mint it again. Same process. Once you mint it, you go through the transaction, it captures the attributes and just to round it off, the way it happens is we have a rendering engine and metadata logic. Again, when the transaction happens, we capture the transaction values, whether the capture details. It goes to a rendering engine which runs chrome headless, and it really relies on the attributes and capture preview. It outputs image, URL animation, URL attributes.
00:21:43.720 - 00:22:23.704, Speaker B: And at this point, what we do is basically we take these attributes, we upload them to RV for decentralization, and then we upload them to s three. The way we do dual upload is basically we want to keep updating the tokens, but we want to also anyone can verify that what values that are on chain, they stay on chain, and nothing from the centralized server changes anything. So we do a dual upload so you can verify anytime the metadata of the token. But yeah, so that's basically, again, the capture happened. It showed the image and it went through it. But yeah, at this point that was just basically a demo. But we'll talk about there's a competition that we're running and Asha will talk more about it.
00:22:23.902 - 00:22:53.584, Speaker A: Sweet okay, so we're almost done. We'll take questions, but real quick before you take questions. So we're running a competition for the hackathon. There's $5,000 in prizes. You can win up to 3000. It's really simple. All you have to do is just we'll give you access to our beta platform, which you can find this form on the ETH Waterloo website, but just make a Generative Art collection with the same flow that we just ran through.
00:22:53.584 - 00:23:24.636, Speaker A: We're going to judge you on creativity, kind of any cool thing that you put input in there. And also, we talked about the composability, the protocol. So if you want to introduce your own modules, if you know solidity or you can use our modules, you can get creative with it. You can win $3,000. And also, the winner of this competition is the official ETH Waterloo NFT. So whoever wins your collection, we're going to distribute your NFT to all the attendees at the end of the sackathon. Yeah.
00:23:24.636 - 00:23:34.360, Speaker A: And if you go to this page, if you're new to Generative Art, you can kind of learn how to do it. You can get a collection set up in, like, five minutes. It's pretty simple. Sweet.
