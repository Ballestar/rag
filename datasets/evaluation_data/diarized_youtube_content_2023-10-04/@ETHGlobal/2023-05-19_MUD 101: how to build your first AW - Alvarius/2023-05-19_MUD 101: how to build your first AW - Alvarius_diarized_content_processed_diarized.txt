00:00:27.390 - 00:00:27.940, Speaker A: You.
00:00:29.910 - 00:00:41.700, Speaker B: Hello everyone, and welcome to the Lattice workshop mud 101 how to Build Your First AW. Joining us today is Alvarius, who will be taking us through this session. And with that, I'll pass it over to Alvarius to get the session started.
00:00:43.110 - 00:00:43.970, Speaker A: Hello, everyone.
00:00:44.040 - 00:00:56.140, Speaker C: Thank you very much. I have this workshop prerecorded to have a better experience for all you guys, and I'm going to be in the chat answering questions if you have any during the workshop. And then also I'm going to be available afterwards to answer any questions.
00:00:57.230 - 00:01:09.194, Speaker A: Let's go. Welcome to Mud. My name is Alvarius, and today we're going to build an on chain app to demonstrate how to get started with the framework, build something real, and then deploy to production.
00:01:09.194 - 00:01:30.850, Speaker A: But before we jump into the code, let me give you a very brief overview of a couple of important concepts in Mud so that everything else clicks into place much faster. Let's start with a quick reminder of how onchain development used to work without Mud. So in the old world, let's say we want to create a contract where we want to store a mapping of the owners of a given address.
00:01:30.850 - 00:01:45.590, Speaker A: We store a mapping, we call it owned by from address to address. And then we create a function set owner, which allows us to set the owner of a given address. That function emits an event, and then we set the owner in our own by mapping.
00:01:45.590 - 00:02:17.090, Speaker A: The data is going to be stored in storage, and the location of the data in storage depends on the hash of the key that we use to index the mapping. That means if we have access to a full node, we can read all the values in storage, but we can never recover the key because the key was hashed to find the storage location. And if we want other contracts to be able to get the owner of a given address, we have to remember to implement a custom getter function, because without this function, another contract really has no way of accessing this value in the storage.
00:02:17.090 - 00:02:41.558, Speaker A: In our front ends, we most likely also want to know which addresses have an owner. So what are all the keys that have been set in this mapping? And this is why we had to remember to emit our custom event in our set function set owner, which also includes the key so that a custom indexer can now index this event. And then our clients can ask the indexer to get a list of all the keys that have been set in this mapping.
00:02:41.558 - 00:03:00.610, Speaker A: Doing all of this for every state variable we need in our contracts is very cumbersome. And this is why we created Mud Store. With Mudstore, you don't need any custom getter functions, you don't need any custom events, you don't need any custom indexers, and you don't need any custom networking code because all of this comes by default.
00:03:00.610 - 00:03:36.560, Speaker A: So how does this work? We start with a standard data model that is based on tables and then we provide an optimized core library that is used to interact with the standard data model with these tables. And because the user doesn't interact with storage directly, but rather through this library, the library can take care of optimizing the storage layout and so in some cases even can achieve more efficient data packing than native solidity. And then this core library also emits events by default for every state change which then can be picked up by a default indexer which can be used by clients to get the state very quickly.
00:03:36.560 - 00:04:04.390, Speaker A: The standard data model is very simple, all the data is stored in tables and every table has a schema that describes the types of values that are stored in this table and then every record. That means a row in the table has a key which is used to index this row in the table. Here is an example of an owner table that has a schema with a single field called Owner and the value that is stored in this field is an address.
00:04:04.390 - 00:04:23.658, Speaker A: And then each row is indexed by a bytes 32 key which is implicit in the schema because we didn't provide any override for a key schema. Here's an example of another table called the position table. And this table has a schema with two fields, one x and one y and both of them have type int 32.
00:04:23.658 - 00:04:36.730, Speaker A: And again we didn't provide a key schema so we're using an implicit bytes 32 as a key. And lastly, here is an example for a balance table. This time we do provide a key schema which means the key has two pieces.
00:04:36.730 - 00:04:57.560, Speaker A: The first one is Owner and is of type address, the second one is item and is of type U and 32. And then our value schema has a single field called amount and is of type U and two five six. And this means every row in this table is indexed by the tuple of owner and item and then the value of this row is the amount.
00:04:57.560 - 00:05:28.770, Speaker A: The data in these tables is modified through the optimized call library. But you as a developer never have to actually touch this call library directly, but rather we generate typed wrapper libraries for you based on the table schema. And another thing that you as a developer never have to worry about is emitting events for when data changes because the core library does it automatically and then based on these events, the default indexes can index the data and make it available in an SQL database to any client.
00:05:28.770 - 00:05:53.466, Speaker A: So as a quick recap, Mudstore gives you structured schemas storage optimization, tight encoding and default indexers and it's compatible with any contract as a plugin replacement for native solidity storage. The second piece of the Mud protocol that I quickly want to give you an intro about is the Mud world, which gives you permissionlessly extendable contracts. And here's how it works.
00:05:53.466 - 00:06:08.750, Speaker A: At first, a single world contract is deployed. Inside of this world contract, anyone can register a new namespace. And then inside of the namespace, the owner of the namespace can register new tables that contain the data of this namespace.
00:06:08.750 - 00:06:35.586, Speaker A: This is powered by Mudstore, and this is a major difference to vanilla solidity, because in vanilla solidity, you would define the data types at the time when you write your contract, and then you deploy that contract and the data types are fixed. Here we're registering a new table inside of an existing contract at Runtime to extend the functionality of the world. The owner of a namespace can register new systems in their namespace.
00:06:35.586 - 00:06:57.530, Speaker A: And for each system, a function selector is going to be registered in the world contract so that the system can be called through the world contract. By default, systems can read data from all the tables, but they can only write to tables in their own namespace. And they can write to tables where the owner of the namespace gave explicit approval to the system to write to this table.
00:06:57.530 - 00:07:12.510, Speaker A: Mud Store and Mud World are two important lower level pieces of the Mud protocol. But now we're going to focus on the Mud framework, which is the thing that glues all of this together into an engine for ambitious on chain applications. And it comes with batteries included.
00:07:12.510 - 00:07:20.440, Speaker A: It comes with a CLI, it comes with the development server and dashboard, and it comes with templates. And this is what we're going to have a look at now.
00:07:29.500 - 00:07:35.080, Speaker C: All right, I'm going to attempt to go into my system preferences real quick to hide this menu.
00:07:36.540 - 00:09:46.394, Speaker A: 1 second. Hey.
00:09:46.432 - 00:09:51.790, Speaker B: Yes, we're still live. Avery's just trying to troubleshoot his zoom, so don't worry.
00:10:16.620 - 00:10:28.176, Speaker A: Create a new mud project. We can do so by running Pnpm create Mud at Cannery, and then we put the name of our project that we want to set up. In this case, it's Mud 101.
00:10:28.176 - 00:10:42.388, Speaker A: And we put At Canary because we want to use the latest alpha version of Mud. So now we're asked to choose between the react version and the vanilla version of the template. And for the sake of this video, I'm going to choose the react version here.
00:10:42.388 - 00:11:14.000, Speaker A: So now it's going to download all the packages, install all the dependencies, and going to set up our project. And once that's done, we can CD into our project and run Pnpm Rundev to start the local development server. What this is doing is setting up a local Ethereum node, deploying all the contracts to that local Ethereum node, and also starting a local web development server.
00:11:14.000 - 00:11:40.510, Speaker A: All right, so this is done. It's saying Mud watching for changes, because later, when we change our files, it's going to automatically redeploy and recompile everything. But for now, let's just head over to the browser and have a look at our app, we can go to Localhost 3000, which is where the local web server is running, to have a look at the app that was just created for us.
00:11:40.510 - 00:11:55.628, Speaker A: Here on the right side, we can see the Mud DevTools. On the very top, you see a couple of general stats about the current chain that we're running on, in this case, our local foundry chain. We can see that the block number is increasing because we're connected to our local RPC node.
00:11:55.628 - 00:12:12.310, Speaker A: And we can also see a burner wallet that was created for us. When we loaded this page for the first time, we see our balance, which is zero ETH, which is fine because we're on a local development chain. And then we can see a couple of store events that were emitted when we set up the app for the first time.
00:12:12.310 - 00:12:36.940, Speaker A: And then on the left side, we see the app that was just created for us. If we press the button here, we see there's a new action coming through and we see one new store event at the bottom, the counter value, which got increased to two. What's happening here in the background is that if we press the button, a transaction is sent to the chain and then mud synchronizes the state of the chain in the background automatically to the UI and to the client.
00:12:36.940 - 00:12:50.456, Speaker A: And to show you how that works, let's jump into the code. Our project is split up into two packages. We have one client package and we have one contract package.
00:12:50.456 - 00:13:11.128, Speaker A: And the first thing we're going to have a look at is the Mud config, which we find inside of the contracts package under Mud config TS. And in here we see that we currently have a single table set up, the counter table. And we see that this table has a schema with a single field, which is a UN 32.
00:13:11.128 - 00:13:25.340, Speaker A: And then we also see a key schema that has no keys inside of it. And the reason for this is that our counter table has only a single row. We call this a singleton table, and we don't need any keys for it because it only has a single row.
00:13:25.340 - 00:13:38.064, Speaker A: Now this is our config. And based on this config, mut code generated a library to interact with this table. And we can find this library in code gentables and then counter sol.
00:13:38.064 - 00:13:49.110, Speaker A: And here we see, okay, this is a code generated, an auto generated file. We should not edit this manually. And we see a bunch of methods that were generated for us, but we don't have to look at this in detail.
00:13:49.110 - 00:14:09.084, Speaker A: We can just close this again and interact with it as a black box. Now, the next thing we're going to have a look at is the client. For this, we switch to the client package and we go into source and open app TSX, which includes the source code of the page we just saw here.
00:14:09.084 - 00:14:26.450, Speaker A: We see the counter with the counter value behind it and we see the increment button that we just saw on the page that we opened. And we also see that when we press this increment button, the increment function is called which comes from system calls. So let's look at where this comes from.
00:14:26.450 - 00:14:53.370, Speaker A: This is coming from Create System calls which is a function inside of Source Mud and then create system calls TS. And in here we set up our functions that we want to call on the world contract. So what actually happens here is we call a function on the world contract via World Send and the function that we're calling is the increment function and we don't provide any arguments here.
00:14:53.370 - 00:15:21.932, Speaker A: So let's switch back to the contract package to see where this function is coming from. I'm closing the clients package, going back to contracts and then I'm going inside of Source and I'm opening the systems folder and I see a single system, the increment system. Every contract whose name ends in system is automatically considered a system by Mud and it's going to be registered in the world contract during the deploy process of Mud.
00:15:21.932 - 00:15:48.680, Speaker A: And then for every function selector inside of that system, this function selector is also going to be registered on the world contract so that people can call this function directly through the world contract. And then the world contract forwards the call to our system contract. So in this case, we have a single increment function and this function is registered on the world contract, which is why we were able to call the increment function directly on the world contract from the client.
00:15:48.680 - 00:16:02.544, Speaker A: Now, what this function does is it reads the current value from the counter table. And remember, this is a singleton table so we don't have to provide a key. And then it increases that value by one and it sets the new value on the counter table again.
00:16:02.544 - 00:16:22.224, Speaker A: So if we go back to our app, we can now read the value from the counter table through this hook called Use component value. And then this is the value that we display in the app. Now, the reason why this is called use component value is because this is coming from a pattern called ECS or Entity component systems.
00:16:22.224 - 00:16:45.500, Speaker A: For the sake of this tutorial, we're not going to go into ECS though. And so I'm going to quickly replace this with a lower level hook called Usero, which also allows us to read rows from a table and doesn't have the ECS abstraction around it. To use this hook, I have to provide the store cache which is where Mud synchronizes all the contracts state to, and I can get this from the network here.
00:16:45.500 - 00:17:05.570, Speaker A: And then I provide that as the first argument. And the second argument is going to include the table that we want to filter for, which in this case is the counter table. And then we also have to provide an argument for the key that we're interested in.
00:17:05.570 - 00:17:26.554, Speaker A: But in this case, since it's a singleton table, the key can be empty. And because our return value is slightly different, we have to fix this up here and provide the key of the value, which in our case is also called value. And then just to confirm everything still works, I'm going back to the browser, pressing the increment button.
00:17:26.554 - 00:17:43.570, Speaker A: I see the transaction going through, and I see the state being synchronized and updated in the UI. We don't need these imports anymore. So let me just real quick clean this up, removing this import, removing the components, and we also don't need the singleton entity anymore.
00:17:43.570 - 00:18:00.242, Speaker A: All right, now let's create a new feature. I want to create a Balance Table, which stores the balance of a certain item that a certain address has. And I want to create a Mint system which allows people to mint a certain amount of a certain item.
00:18:00.242 - 00:18:35.960, Speaker A: So the first thing that we're going to do is go back to our Mud config and add the configuration for that new table. We're going to call this table the Balance Table, and we're going to give it a schema of a single UN 32. And this time, we want to have multiple rows in our table, and we want each row to be indexable by a composite key of the owner, which is an address, and the type of item which is going to be a UN 32 as well.
00:18:35.960 - 00:19:07.166, Speaker A: Once we save this file, the Mud development server is going to pick up the change to our config and then autogenerate the new table that we just defined here, which we can find in code gen. And then in tables, we see there's a new auto generated table library called Balance Table. All right, so let's create a new system to interact with this new table.
00:19:07.166 - 00:19:25.702, Speaker A: For this, we go into systems and we create a new file that we call the Min System. And I'm just going to copy the code from the increment system for now and going to paste it into our new file. And then I'm going to clean up everything that we don't need.
00:19:25.702 - 00:19:37.420, Speaker A: So we're going to rename this to Min System, and I'm going to remove everything that is in here. And we don't want to interact with the counter table, but rather the Balance Table. So I'm going to put balance here.
00:19:37.420 - 00:20:02.480, Speaker A: And of course, I named this table not just Balance, but Balance Table. And this is why I have to import from Balance Table here. Next, we're going to create our Mint function, which we just call Mint, and we take one argument as an input, which is going to be our item that we want to mint, and this is a public function.
00:20:02.480 - 00:20:17.678, Speaker A: And then we want to grab the current balance of the caller of this function to be able to increase it. And for this we're going to do balance table get. And now we have to provide the two keys that we use to index each row in this table.
00:20:17.678 - 00:20:42.166, Speaker A: And so the first index, the first key is going to be the address of the caller and the second index is going to be the item. And one thing to note here is that we don't use message sender here, but rather we use underscore message sender, which is a function that's implemented on the system base contract. And the reason for this is that this system contract is not called directly, but rather it's called through the world contract.
00:20:42.166 - 00:21:03.940, Speaker A: And so the world contract is forwarding the original caller of the system through this function. And now that we have the balance, we want to increase the balance and set the increased balance on the balance table. So I want to set the balance of the message sender of the current item with the new balance plus five.
00:21:03.940 - 00:21:19.942, Speaker A: And that's all we need to do for now. Now once I save this file, the Mud development server is going to pick up the change, recompile all the contracts and redeploy the world with the new contracts. But we don't have any way to interact with it yet from the front end.
00:21:19.942 - 00:21:42.510, Speaker A: And so we quickly set up a connection to the front end by going back into our client and into Source, into Mud and into create system calls. And in here we're just going to create a little wrapper function to call our contract. This is really just for our convenience to not have to call the contract directly in App TSX.
00:21:42.510 - 00:22:11.910, Speaker A: So we call this function Mint. And in here all we have to do is call WorldsEnd with the new Mint function which is now available on WorldsEnd because everything was recompiled in the background and it tells us we need one more argument, the item. So we're going to provide an item here and we're just going to put one for now and then we return this function to make it available on the context that we use in App TSX.
00:22:11.910 - 00:22:35.520, Speaker A: Now let's go back to App TSX and let's clean up all the things that we don't need anymore in here. So we don't need the counter anymore, we don't need the stiff anymore, and we also don't need the button anymore. And instead I'm going to create a new button which will be our Mint button.
00:22:35.520 - 00:22:54.134, Speaker A: And on click of this button we are going to call the Mint function, which we can get from the system calls object up here. And then we want to call this when we click the Mint button. All right, this is all we need.
00:22:54.134 - 00:23:17.980, Speaker A: Now let's go back to our browser and we see the Mint button and we see that if we click this Mint button, a Mint transaction is sent to the contract and it's confirmed. And then here in the recent store events, we can see a new event that came in, which is an event, an update to the balance table. Where we see it now has value five for some key.
00:23:17.980 - 00:23:33.278, Speaker A: But the new value is not displayed in the UI yet because we didn't set up that connection yet. So let's go back to our code and let's set up a connection in the UI. So I want to get all the balances from our balance table.
00:23:33.278 - 00:23:54.650, Speaker A: So in this case, I'm going to use a different hook. I'm going to use the Use rows hook and it behaves very similar to the use row hook. We also provide the store cache as the first argument and then as the second argument, I provide a filter object which will include the table that I want to filter on, which in this case is the balance table.
00:23:54.650 - 00:24:32.366, Speaker A: And then we're going to set up a very simple UI for this by looping over every element of the balances array, every row in the balance table. And we map each of these rows to a paragraph element so that we can see it in our browser. And in here we just put balance key owner has, and then we want to have the number of items it has.
00:24:32.366 - 00:24:42.850, Speaker A: So balances value. This is because the only value in our schema is called value right now. And now the type of item, this is part of the key.
00:24:42.850 - 00:25:06.730, Speaker A: So we do balance key item and then we can save this and head back to our browser and see the result. Well, you can confirm that this is my address by looking at my address in the mud DevTools, but this is way too long. So I'm just quickly going to shorten this to ten characters.
00:25:06.730 - 00:25:31.920, Speaker A: And then when we go back to our browser, this is much more readable and you can see my address has five items of type one. And if we press the mint button again, you see the UI is updating, you see the transaction on the right and you see the event in the DevTools. All right, now the last thing that's missing.
00:25:31.920 - 00:26:09.114, Speaker A: And for this, we stop our development server process and we go quick contract directory, go into the contracts directory from where we're going to deploy our contracts to an actual chain. The first thing we have to do here is create a new wallet. So I'm just going to use the Cast utility to create a new random wallet and I'm going to copy my private key and I'm going to head back over to the code into the contract package where I can find end file, which includes the environment variables, and I'm going to paste my private key there.
00:26:09.114 - 00:26:26.378, Speaker A: So far this included the default, anvil private key, and I'm going to override it with the newly created private key from Cast. Then I head back to the console and I copy the address. And because this is a fresh private key and fresh address, it's not going to have any funds on the testnet.
00:26:26.378 - 00:26:56.310, Speaker A: And so because we want to deploy to the Lattice testnet, I can just say Pnpm Mud Faucet address. And then I paste the address here and the Mud Faucet is going to drip me some ETH to this new address so that we can deploy to the testnet. And now the last thing that I have to do to deploy to the testnet is type Pnpm deploy testnet, which refers to a script that you can find in the package JSON in the contracts package.
00:26:56.310 - 00:27:17.234, Speaker A: And now this is running the Mud deployer again, but this time we're deploying to an actual chain. So this time it's going to take slightly longer than the def runner, which just deploys to the local chain because now we have to wait for every transaction to be actually confirmed by the real chain. And there we go.
00:27:17.234 - 00:27:38.586, Speaker A: The contracts have been deployed to the chain and we see the world address that it got deployed to. And now to interact with this production deployment, we were going to start our development server again, but just to have the development client running, because we don't have our client deployed yet. So I'm going back to the project route running Pnpm Dev to start the development server again.
00:27:38.586 - 00:27:55.850, Speaker A: And it's starting both the development client as well as the development contracts. But in this case, we just care about the development client. The error that you see here is the contracts complaining that we're trying to deploy to the local development chain with a private key that doesn't have any funds on the local test chain.
00:27:55.850 - 00:28:06.626, Speaker A: But again, this doesn't matter because we're only interested in the client here. And if we scroll up a little, we can see that the client is running fine. So this is all we care about.
00:28:06.626 - 00:28:24.486, Speaker A: So we can go back to our browser and to connect to the production chain, we just have to append the chain ID param to the URL. So we type question mark chain ID equals for two, four, two, which is the chain ID of the Lattice testnet that we just deployed to. And we press Enter.
00:28:24.486 - 00:28:36.906, Speaker A: And now you see it's connected to the Lattice testnet. You see the block number increasing because it's connected to the testnet RPC. And you see our new burner wallet that was created for us here.
00:28:36.906 - 00:29:00.980, Speaker A: And we see the balance that we have on this testnet, which is quite a bunch. And if we press the mint button, you can see the transaction being executed and being confirmed, and you can see the balance value being updated and the I being updated as well. This is a very simple app, of course, but it should give you an idea of how to get started with the framework and how to build something much more complex than this.
00:29:00.980 - 00:29:25.222, Speaker A: If you want to dive deeper, you can find the documentation at Mud dev and we're going to follow up with a bunch of videos that go deeper into specific topics like ECS and building games with Mud. Great.
00:29:25.276 - 00:29:36.860, Speaker B: Cheers. Thank you. Various now we have just a few maybe like a minute or so, but I don't know if there are any remaining questions that participants have.
00:29:43.460 - 00:29:50.416, Speaker C: How could we browse games already created a month? That's a great question. There's a website for that. I'm going to post the link in the chat.
00:29:50.416 - 00:29:52.390, Speaker C: It's community math dev.
00:29:55.780 - 00:29:56.736, Speaker A: Oh, there we go.
00:29:56.758 - 00:29:58.710, Speaker C: OK, someone posted already.
00:30:06.940 - 00:30:08.570, Speaker B: Sam, did you have a question?
00:30:09.100 - 00:30:12.024, Speaker D: Yeah. Thanks for this. It was great.
00:30:12.024 - 00:30:26.604, Speaker D: And pulled down and set up a template app and I'm running it locally and just trying to better understand this Burner Wallet stuff. Like great. UX, I love it.
00:30:26.604 - 00:30:42.210, Speaker D: I love running stuff through a Burner wallet like that so you don't get these wallet pop ups. But I'm a little bit confused about transaction fees and more of a production main net sort of deployment here. Right.
00:30:42.210 - 00:30:56.490, Speaker D: Is the suggestion that users should fund that Burner Wallet or is that something that sort of get replaced, least in this stack to make something more serious? It's not just like a sort of demo thing.
00:30:57.100 - 00:30:57.512, Speaker A: Yeah.
00:30:57.566 - 00:31:17.550, Speaker C: So if you deploy to the Lattice testnet, we have a faucet so you can automatically fund the Burner Wallet whenever somebody visits your app. And I think for the optimism testnet, we're also going to have a faucet available which can Autofund the Burner Wallets. Alternatively, you can also just connect any external wallet to your app.
00:31:17.550 - 00:31:25.072, Speaker C: The only downside to that is that you now have to ask users to confirm transactions before doing that.
00:31:25.126 - 00:31:26.144, Speaker D: Well, yeah, okay.
00:31:26.182 - 00:31:26.384, Speaker A: Yeah.
00:31:26.422 - 00:31:29.180, Speaker C: Depending on your use case, that might be acceptable.
00:31:29.260 - 00:31:40.176, Speaker D: I have another tool that I use for Burner Wallets and also implement Metatransactions. So I feel like that's probably the direction I want to maybe take my hack.
00:31:40.368 - 00:31:41.340, Speaker C: Yeah, totally.
00:31:41.440 - 00:31:41.752, Speaker A: Okay.
00:31:41.806 - 00:31:42.328, Speaker D: All right.
00:31:42.414 - 00:31:49.972, Speaker C: That's totally compatible. You can just connect it to the Ethos or VM executor that's connected to your client.
00:31:50.116 - 00:31:56.172, Speaker D: Okay. All right, great. I'll probably have tons more questions as I work through this, but awesome.
00:31:56.172 - 00:31:57.724, Speaker D: Excited to hack around on this.
00:31:57.762 - 00:32:05.858, Speaker A: Thanks. Cool. Yeah.
00:32:05.864 - 00:32:20.758, Speaker B: And there were a few other questions. Just an FYI, if people are looking for the link to that video, this all will be recorded and shared with you later. So if you're looking for that exact video that average presented, don't worry about it.
00:32:20.758 - 00:32:29.980, Speaker B: We'll just share this link to this presentation. The recording Et, it asks is it easy to integrate contracts that weren't written within the same Mud project?
00:32:32.110 - 00:32:42.158, Speaker C: Yeah, sure. It depends on what you want to do. If you just want to interact with an external contract from your contract, you can just call it before.
00:32:42.158 - 00:32:55.620, Speaker C: Essentially, if you want to register an external contract as a system in your world that might be slightly more involved, but technically also possible if. You have specific questions, we can dive into it later.
00:32:57.510 - 00:33:06.322, Speaker B: The MD asked, can we deploy to Latice testnet during this hackathon? I think that might have been yeah.
00:33:06.376 - 00:33:12.310, Speaker C: I mean, I think you can if you want to, but also, Optimism is providing a testnet that's probably better maintained.
00:33:13.790 - 00:33:18.490, Speaker B: And could 43 37 be a solution here, like account abstraction?
00:33:20.750 - 00:33:24.202, Speaker C: Yeah, I think that was related to the discussion before.
00:33:24.336 - 00:33:25.020, Speaker A: Okay.
00:33:27.730 - 00:33:34.990, Speaker B: Can Mud be used to create just a single contract or a few that can be used in a bigger Mud project, like using a predefined interface?
00:33:38.420 - 00:33:52.852, Speaker C: I'm not quite sure if I understand this question. Can Mud be used to create just a single contract or a few that can be used in a bigger Mud project, like used using Prelude? Yeah, I'm not sure I understand. Maybe you can elaborate.
00:33:52.916 - 00:33:53.224, Speaker A: Oh, yeah.
00:33:53.262 - 00:33:54.090, Speaker C: Okay, cool.
00:33:54.540 - 00:33:56.280, Speaker A: I'll chat about it in Discord.
00:33:56.700 - 00:33:57.944, Speaker B: Evgeny, you had a question.
00:33:57.982 - 00:33:59.240, Speaker A: You had your hand raised.
00:34:02.140 - 00:34:24.690, Speaker E: I am that Et guy is me. So the question is the same. And suppose I'd like to be able to extend a project, extend a running project with something provided by other people.
00:34:24.690 - 00:34:45.290, Speaker E: So that shall I use just rigid interface I define beforehand and just take addresses? Or did anyone compose different Mud projects so far?
00:34:45.900 - 00:34:58.424, Speaker C: Oh, I see. So essentially, different Mud worlds is your question. So if you have one world, then it's very easy for people to extend it by registering new systems because that's permissionless.
00:34:58.424 - 00:35:27.984, Speaker C: So people can register their own namespace and their own system. In your world, if you want to integrate different worlds together, that's also theoretically possible, but would require some more custom code because now you can't assume anymore that the caller of your system will always be this one world, but maybe you have different worlds now. So it's totally possible you can just write custom solidity code for it, but it's not the original intention.
00:35:28.032 - 00:35:42.250, Speaker E: Essentially, yes. So to add systems to a running project, what do people do? They download, they clone the code, they add a system, and then what?
00:35:43.660 - 00:35:44.910, Speaker C: That's exactly right.
00:35:45.520 - 00:35:45.884, Speaker A: Yeah.
00:35:45.922 - 00:36:01.490, Speaker C: So you can deploy systems to an existing world as well by just providing the world address parameter to the CLI. And then essentially it doesn't deploy a raw world anymore in the beginning, in the deployer, but rather just deploys your systems to the existing world.
00:36:02.340 - 00:36:06.736, Speaker E: I believe this is covered somewhere in the docs, right?
00:36:06.918 - 00:36:07.650, Speaker A: Yeah.
00:36:10.440 - 00:36:11.750, Speaker E: Thank you so much.
00:36:12.360 - 00:36:13.110, Speaker A: Sure.
00:36:16.200 - 00:36:22.870, Speaker B: We have two more questions. How can NFTs be integrated and be compliant with the ERC 720 spec?
00:36:23.720 - 00:36:37.404, Speaker C: Yeah, there's a couple of different approaches. There's a couple proposals up on the Mud Discord, if you want to read them in detail. And one of our team members actually wants to hack on this during the sackathon as well.
00:36:37.404 - 00:36:42.430, Speaker C: DK one A in our Discord, so we can chat about it later as well.
00:36:44.640 - 00:36:47.820, Speaker B: And can you explain how to create packages?
00:36:50.180 - 00:36:52.370, Speaker C: I'm not sure I understand this one.
00:36:54.420 - 00:36:57.680, Speaker B: Mick, are you still on? You want to maybe come off mute?
00:36:58.660 - 00:37:17.908, Speaker E: Yeah, I think the question is just related to I guess if I want to automate. I think I was reading some of the docs in V two and they explained something about it is possible to I just want to understand the packaging system currently I see we have contracts.
00:37:18.084 - 00:37:19.770, Speaker C: Do you mean modules maybe?
00:37:21.340 - 00:37:21.800, Speaker A: Yeah.
00:37:21.870 - 00:37:46.240, Speaker C: Cool. All right, so modules are essentially contracts that include some logic that install tables and systems in an existing world. So you can basically install a module on a world and then what happens is the world is going to call that module contract and then the module contract is going to call back to the world and register the systems and the tables that you want to or like that the module needs to install.
00:37:46.240 - 00:37:58.260, Speaker C: There we have a couple of basically built in modules that you can have a look at as examples and I think we also might have a doc page and if not, we're working on it and we'll have one shortly.
00:37:59.480 - 00:38:02.790, Speaker E: What's one example of like a module I should look into?
00:38:03.880 - 00:38:25.310, Speaker C: For example, you can have a look at the core module of the world which actually implements some of the core world functionality in a module, essentially. So basically we have a very minimal set of functions that are actually on the world contract. And then during the world deploy contract process we install this core module which then extends the functionality by a bunch more things.
00:38:25.310 - 00:38:43.252, Speaker C: And yeah, if you're on discord I can point you to the specific links. We have other modules, we have the keys and table module which basically installs an on chain indexer for your tables by default. Keys with value is another one.
00:38:43.252 - 00:38:45.348, Speaker C: Yeah, I can send some links later.
00:38:45.514 - 00:38:46.630, Speaker A: All right, thanks.
00:38:50.200 - 00:38:57.240, Speaker B: This was like clarification from earlier. Question are systems and name spaces interchangeable?
00:38:58.220 - 00:39:15.576, Speaker C: Not quite. So the namespace is kind of a namespace wraps around a system in a sense. So a system is a contract that you deploy and you deploy the system into a namespace and you also deploy tables into a namespace and access control is based on namespaces.
00:39:15.576 - 00:39:23.810, Speaker C: So namespaces are more of a concept than an actual contract or anything. So their data inside of the world contract, if you will.
00:39:26.100 - 00:39:32.240, Speaker B: And this is a follow up to Guinea's question can systems interact with each other across worlds?
00:39:33.620 - 00:39:50.730, Speaker C: You can definitely call other worlds from your guess. So basically you would call systems always through the world contract as an entry point. And so if you want to call a system in another world, you would call that other world and then that other world would forward the call to its to its system.
00:39:59.970 - 00:40:18.766, Speaker B: Okay, filecoin mentioned sponsor filecoin. Think they're listed as a sponsor filecoin should be just optimism. Zero x park lattice and NFT storage.
00:40:18.766 - 00:40:27.560, Speaker B: I don't think Filecoin is sponsored for here. Okay, maybe this ovaries. Maybe just like one more question.
00:40:27.560 - 00:40:35.240, Speaker B: This is the last question. Is there a preference for hackathon whether we develop on mud or mud Two, or is mud two not out yet?
00:40:35.850 - 00:40:46.954, Speaker C: Mud Two is out. You can install it with the add canary flag. So if you do pnpm create mud at canary, then you get the latest version, which is matu also on GitHub, on main.
00:40:46.954 - 00:41:01.370, Speaker C: That's all mat two. I would strongly recommend using mat two if you want to use mud over mud one, because there's a bunch of improvements and not really many, if anything, like basically everything you can do in Mud One, you can also do in mat two, but better and cheaper.
00:41:04.930 - 00:41:05.630, Speaker A: Awesome.
00:41:05.780 - 00:41:18.366, Speaker B: Well, cheers. Thank you, everybody, for attending. Thank you, alvarius for presenting today, and if anybody has any other further questions, please feel free to reach out to them on their partner channel and discord and yeah, that'll be it.
00:41:18.366 - 00:41:19.370, Speaker B: So thank you all for attending.
