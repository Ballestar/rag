00:00:07.770 - 00:00:14.670, Speaker A: Hi, everyone. Andrew Foreman. I'm with Ernst and young EY blockchain here talking about Starlight.
00:00:14.670 - 00:00:29.634, Speaker A: I work at EY. I work with a lot of our clients that are building smart contract applications, any kind of web, three app, new range features, things like that. What I'm not is I'm not a cryptographer.
00:00:29.634 - 00:00:36.360, Speaker A: I've never taken a cryptography class. I don't really understand the math behind zero knowledge proof circuits. I know there's a couple out there.
00:00:36.360 - 00:01:07.460, Speaker A: So what Starlight is, is really just a huge leap forward in allowing any average silly developer, myself included, to start to bring and use privacy features in the construction of their DAP and their smart contract. So this is very much like, if I can do it, you can do it too kind of talk. We do have some of the cryptographers that worked on building the application on the phone, and they'll talk through some of the technical parts of it, but definitely want to give you a feel for what this is, what we're building here.
00:01:07.460 - 00:01:20.040, Speaker A: Maybe just another important note, too, is that this is something that we're actively working on at yeti. It's pre alpha release, very much an experimental technology. So we're hoping to launch it soon.
00:01:20.040 - 00:01:57.310, Speaker A: The reason we're talking about it this weekend is so that you guys can see it, you can start to use it, give us feedback, and then we can have a more robust launch very shortly. So what is starlight? So, like I said, the big headline here is that any solidity developer can now use the power of zero knowledge proofs in building private features for their DAP on chain. You don't need to understand kind of all the sophisticated circuits, the elliptical curves, anything like that to go then build private features for your DAP.
00:01:57.310 - 00:02:06.274, Speaker A: So that's what Starlight was built to do. It's really two things. It's one, it's a zero knowledge proof library for writing your solidity code.
00:02:06.274 - 00:02:30.060, Speaker A: And two, a transpiler we call a compiler. But really it's a transpiler to then read that library file and the decorators that are involved there. So what you can do is then you take any of your these decorators do is they take any of your variables mappings arrays that you have in your contract and it allows you to put them into a private state.
00:02:30.060 - 00:02:51.940, Speaker A: And so then some of the names you see up here are the kind of the names that we've been using. I mean, these are kind of like right now, just internal names that we're trying to experiment with. But when you take your adapt and you run it through this kind of construction that we have around decorators, we're calling that a Zap or a zero knowledge proof app.
00:02:51.940 - 00:03:11.542, Speaker A: The Zalidity is the file type that we use in this zero knowledge proof library in the Starlight library, which I'll get to in a bit. And then Zapify is really just a command to run the compiler. So once you understand kind of some basics around those decorators.
00:03:11.542 - 00:03:24.586, Speaker A: It's really just three steps. Write your solidity, add these decorators, run the compiler. And as you can see, we've taken all of that trusted setup, circuit construction, trust assumptions, logic off of you as a developer.
00:03:24.586 - 00:03:45.038, Speaker A: So all you have to do is add this to your solidity code and kind of understand what the logic is going to look like for your users and how these state changes get updated. Okay, so first one, we said two things right. First is the compiler.
00:03:45.038 - 00:04:02.200, Speaker A: So I think I want to say, why did you even build a compiler? It's kind of like a weird thing to even go and tackle. You don't see it that often where someone wants to go build a compiler. And so for us this was really just about scale and getting more developers access to this technology.
00:04:02.200 - 00:04:22.394, Speaker A: It was something that I ran into personally on a project. So we worked with a client, they wanted to build this private donation platform and what it allowed you to do was take a bunch of different charities, make private donations to them. So now like a large donor who may not want their donation to be public could do so privately on chain.
00:04:22.394 - 00:04:36.926, Speaker A: So there's a big step forward in more sophisticated, more real world smart contract applications. But I worked with a team of advanced cryptographers. We had to go through weeks of circuit construction.
00:04:36.926 - 00:05:00.886, Speaker A: They had to explain it to me so that our team could then write it into solidity code. All of that stuff is not scalable when you talk about hundreds and thousands of zero knowledge, proof based and privacy enabled applications. So to make that all work, we started kind of at the compiler level so that you can keep writing your solidity code, add these decorators and run it through this construction.
00:05:00.886 - 00:05:43.900, Speaker A: So the three steps again, we'll say take your contract in solidity sol, add decorators, you mark what you want to be, secret variables, arrays, mappings, anything that can have a private state, then send it through Zapify into what we're calling this compiler transpiler. So then how does that look at runtime? Because this is maybe just like also as a developer education point, understanding what's happening to your code as you go in through and deploy it. So what we have here is the compiler takes that solidity code and we have now this zol file, this solidity file type.
00:05:43.900 - 00:06:15.646, Speaker A: And what we're going to do is we're going to first kind of make sure that the syntax and the way your solidity code is written looks right, that there's no solidity errors. First we're going to run it through the solidity compiler just like as your code always would be executed. Then we're going to add back into this AST tree, which we've broken out the decorators that you put into that file and then we're going to run it through our transpiler.
00:06:15.646 - 00:06:36.218, Speaker A: And so now we've done this, gone through this compiler loop a second time and what you have is a validity or a Zap that's been compiled. And so that's when we would then set up and create the circuits and the state changes that you would need for that application. So, yeah, that's kind of what it looks like.
00:06:36.218 - 00:07:10.130, Speaker A: At the back end, you're going to have one tree that has these three different parts, which is the Shield contract, this orchestration code, and then also just your solidity file structure. And I only call that out now because when we get into the more technical parts of the talk, you're going to see that breakout again of the orchestration, the Shield contract and the solidity file. Okay, so like I said, all that you need to know as developer is how to use these decorators and how to run it through this transpiler.
00:07:10.130 - 00:07:48.032, Speaker A: And you've got your solidity app ready to go. So I want to now jump into the decorators because this is really kind of like the key thing for anybody that wants to go and use Starlight to understand are these three decorators. Miranda, can you hear me or do you want me to take these ones? You want to try and test talking and see if we can hear you? Hello? All right, well, I'll get started.
00:07:48.032 - 00:08:12.968, Speaker A: So the first one is the secret decorator. So what secret is, is think about any kind of variable, whether you declare it at the global level or a function parameter that you want to remain in a secret or private state. So like your basic example here, we can jump to the code as well is I've got variable A.
00:08:12.968 - 00:08:33.272, Speaker A: I don't want anybody else to be able to call and see what I have stored at variable A. So I can put it secret in front of that argument and now it can remain private on chain known and unknown. So this is getting a little bit more advanced.
00:08:33.272 - 00:08:50.352, Speaker A: So then think about this as like a bank account, right? So a known would be where I know what's in my bank account. I can now update the state of my bank account. I would use known for that if I want to add or decrease if I don't know the state of my bank account.
00:08:50.352 - 00:09:00.564, Speaker A: So let's say I want to change his bank account, I don't know what's in his bank account. I would use unknown. And now I can add to his bank account without knowing the state of it.
00:09:00.564 - 00:09:55.930, Speaker A: So that's how you would use known and unknown. A lot of this comes down to kind of the language of ZKP and privacy and cryptography is just like who's creating the commitment, who knows the secret word at any point and who can update the state of whether it's a variable mapping or an array? And so to me, this is just like a very nice distillation of a lot of zero knowledge proof work happening in the background, where for me, all I have to understand is how to use these decorators, what they're going to look like once my code is represented on chain. And now I can start to kind of bring these features of zero knowledge, proof and privacy into my application, who can change states, who knows things when and who can update them.
00:09:55.930 - 00:10:09.368, Speaker A: So let's look into an example of that. Miranda, if you can hear us, you can jump in on this one as well. You start talking, maybe it's a little loud.
00:10:09.368 - 00:10:10.430, Speaker A: You want to try that again?
00:10:11.360 - 00:10:12.636, Speaker B: Hello, can you hear me?
00:10:12.658 - 00:10:14.748, Speaker A: Yes, we hear you fine. Perfect.
00:10:14.914 - 00:10:18.800, Speaker B: Yes, we do. Okay, perfect. So we're going from the example, is that right?
00:10:18.870 - 00:10:19.490, Speaker A: Correct.
00:10:20.260 - 00:10:22.640, Speaker B: I can't see the slide. Sorry. Okay, great.
00:10:22.640 - 00:10:39.524, Speaker B: So you have an example here. So if we want to Zapify something and turn it into a zero knowledge application, we start with a smart contract as Andrew talked through. So let's do this super simple idea, which hopefully some kind of use case.
00:10:39.524 - 00:10:56.648, Speaker B: We have a mapping of invoices from an address, a person to the amount in the invoice. We have the owner of the contract, this is the one who's going to be paying the invoices and we have a function to add invoice and a function to pay them. So you see in red, these are where the decorators are.
00:10:56.648 - 00:11:09.596, Speaker B: So we don't actually need to worry about known and unknown here because we're overwriting state and we're decrementing state. So we know that essentially the only people who are going to call these functions are the people who know and own the state. And the compiler is clever enough to work that out for you.
00:11:09.596 - 00:11:23.750, Speaker B: So we don't need known or unknown here. But yes, this is an example of a kind of input you would be able to put into Starlight and Zapify. At the bottom is just a very high overview of the actual application.
00:11:23.750 - 00:11:48.284, Speaker B: By compiling this we would get a shield contract which would verify the information you put on Chain. In this example, we are not revealing any owners or amounts of these invoices. So very little information will go on Chain apart from the proofs proving you've done these computations correctly and the amounts based on whether you're adding a new amount or whether you're decrementing some amount.
00:11:48.284 - 00:12:07.196, Speaker B: The orchestration is just the node code and a bunch of other types of sort of deployment type things. So like docker NPM files that help you deploy and use and bring together the zero knowledge and the on chain parts. And the Zocrates is the code that we use for isoknowledge circuits.
00:12:07.196 - 00:12:24.800, Speaker B: All right, so on the next slide there should be sort of example flow of this. So lovely. So ideally here, so the user wants to add an invoice using their zero large application that they've made with Starlight.
00:12:24.800 - 00:12:37.160, Speaker B: So number one is the only step that the user has to do. All the rest is done in the background and the user is just waiting for the receipt back from the transaction. So they want to privately add an invoice to this contract.
00:12:37.160 - 00:12:52.508, Speaker B: They still need to input an amount. So if you remember in the previous slide, we still need the user to input an amount but then the rest is done in the background. So they call instead of calling the contract, they will call a JavaScript node file.
00:12:52.508 - 00:13:05.910, Speaker B: And what that would do if you have an old invoice for this exact owner for you, then it would grab that old commitment. If not it would use a dummy commitment which is a bit of an advanced feature. But we'll just continue.
00:13:05.910 - 00:13:27.096, Speaker B: It would get all these inputs together and create all the things that we need to keep the state private. So in this case in number three we want to wrap the amount into a commitment. So what we do is we hash it with lots of other information as well to make sure that it's hidden but it's provably correct.
00:13:27.096 - 00:13:59.750, Speaker B: And we go through exactly the same computations that we did in the original input contract, but instead we do it in the zone arge circuit and we prove that we've done it correctly rather than revealing the inputs that we've used. And then once we've done all this in number four, we send this proof the new commitments we have so the new commitment representing the new value and the nullifier of an old commitment if it exists, we send that on chain. If the contract that we made, if that verifies the proof, it adds a new commitment to a tree so you can prove that it exists later.
00:13:59.750 - 00:14:27.528, Speaker B: It basically tells the world, but mostly our merkel tree application that a new commitment has been added and it adds a nullifier so that you can't double spend any commitments. So all the user had to do was step one and the starlight generated application has done all the rest. So the user has added a completely secret invoice to this application yeah, that goes through the example yeah great, I'm.
00:14:27.544 - 00:15:01.720, Speaker A: Just trying to see if I could switch over to the actual repo itself. I don't know if we can do mean here's another example just to bring it up mean I think that was a good example that Miranda walked through and I think maybe just like some other examples to throw at you, just know, get you thinking about how you would use these decorators. Might be something like if I wanted to have a voting contract and I wanted to restrict the number of people that could vote on that contract and I wanted to keep those ten people private, I could create a mapping that says, here are my ten voters, they're private.
00:15:01.720 - 00:15:15.950, Speaker A: You can go and check on chain. You wouldn't be able to see who's allowed to vote in my contract. And then maybe only I or some admin has special privileges to change the voters in my application.
00:15:15.950 - 00:15:44.532, Speaker A: We've thought about some other ones like issuing IOUs or different kinds of advanced commitments. So I think this one's like an invoice example. I think that these are powerful tools and now we can start to think about what are the privacy features of our users, when do they want their information to be private, or some other part of the application to be private.
00:15:44.532 - 00:16:05.804, Speaker A: And then this becomes a way that we actually instantiate that feature. I'll flip over to in a second, but we have a GitHub repo that is public and anybody can go and access it. I'll put up a slide after this and there'll be a link there to get to it.
00:16:05.804 - 00:16:20.690, Speaker A: There's a lot of good examples, there a lot of good test files for you to go through. So we definitely want people to go and try out the repos, take a look at it, see if it makes sense. If you have questions, we're available to talk through any parts of it that you want.
00:16:20.690 - 00:16:34.740, Speaker A: And then maybe just to hit on two kind of learnings that we've had over the last few months working on this repo. One, building the compiler is really hard. It's hard to find compiler developers to work on this.
00:16:34.740 - 00:16:43.592, Speaker A: There's a lot of different test cases that you need to be working for. I wouldn't advise it for your health to go work on compiler code. It's a mess.
00:16:43.592 - 00:17:21.060, Speaker A: So if anybody's a compiler dev, come find me recruiting dinner. And then I think too, for me, the big opportunity and the big thing that's changing in our space and as ethereum developers EVM developers, is building privacy, indoor applications. And I think as these applications become more sophisticated, as they start to have more real world applicability and use cases, as our governance systems get more sophisticated, that we're going to want to have privacy in the things that we put on chain for our users.
00:17:21.060 - 00:17:56.770, Speaker A: And it's not feasible right now at this point, or just assume that everybody's going to go out and understand how A snark works at a very detailed level to go build those applications. So I really think we need tools like this to be able to make the privacy features that we want and that'll make the space better work. And so I think something that'll be a big focus for myself and our team going forward too, is just like helping designers, developers, product managers, think through what are the feature designs they want to build in and how do they start to think about privacy in a more robust way.
00:17:56.770 - 00:18:07.430, Speaker A: That's pretty much all on the talk. Can I switch over to the GitHub? I'll just show you guys where it's at. Here's a link if you want to scan here.
00:18:07.430 - 00:18:30.640, Speaker A: And yeah, you just heard from Miranda, she was one of the lead developers, michael Connor down there in the stands. Also worked on it. Swati rayal is part of our R D and cryptography team in London, and Megan and are kind of helping us develop a relation, so to speak.
00:18:30.640 - 00:18:39.020, Speaker A: All right. I don't think we're going to get the GitHub, but yeah, come find me after the talk and we can walk through the repo. Okay? Thanks, everyone.
