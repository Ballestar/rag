00:00:07.130 - 00:00:48.730, Speaker A: And today we are going to see a talk about the Safe but specifically the Safe core SDK and we are going to mention what are the Safe modules and safe transaction guards and also how the Safe core SDK can help us manage them. So the content we'll be covering today is an overview of the Safe architecture. Then we're going to see the safe core SDK monorepo that is in GitHub available, how the transaction flow works on the safe where multiple signers must need to sign a transaction.
00:00:48.730 - 00:01:31.370, Speaker A: Then we are going to talk about the Safe modules and how they can expand the functionality of a safe also Safe transaction guards, how they can check or add some constraints to the transactions that are being executed and then we are going to see what hackathon bounties do we have and how to contact us and what resources we have to help you during the hackathon. So first of all I would like to ask you if you please could raise your hand to see who knows about the safe what the Safe is. Okay, who's using the safe, who knows about transaction guards or modules.
00:01:31.370 - 00:01:37.974, Speaker A: Okay, pretty good. So pretty good. So let's start with the Safe architecture.
00:01:37.974 - 00:01:56.660, Speaker A: A brief overview. We have different layers, the main one will be the contracts, the most critical one and there we can find the Safe contract itself. There are a couple of contracts that interact among each other.
00:01:56.660 - 00:02:35.040, Speaker A: Then we have some libraries, for example the multisend that allows to execute batch transactions. We have also the safe modules and safe transaction guards that we'll see later. We also have a layer of services that we run but you can also run by yourselves being the most important one regarding this talk the Safe transaction service because it will allow us to collect the transactions that are proposed by any of the signers and also the signatures from the other signers so somebody can execute a transaction finally.
00:02:35.040 - 00:02:46.130, Speaker A: And the last layer are the interfaces. So we have different interfaces like the web interface, mobile apps, CLI and some SDKs. Here.
00:02:46.130 - 00:02:56.100, Speaker A: We will cover in the SDKs. The SafeCore SDK. So let's see how the SDK monorepo looks like and what it is.
00:02:56.100 - 00:03:12.700, Speaker A: The SafeCore SDK, it is software developer tools that facilitate the interaction with the smart contracts and also the services. And because it is a monorepo there are some packages inside of it. So let's see what they do quickly.
00:03:12.700 - 00:03:34.494, Speaker A: The first two, the SafeCore SDK types and SafeCore SDK Utils. It's pretty easy to see what they do right? One of them exports types makes them available to the other packages and the util has some utility functions. Then we have the next two, the Safe web three library and the Safe Ethers library.
00:03:34.494 - 00:03:59.930, Speaker A: These are two wrappers of the web three JS and the Ethers JS libraries and also allow to get instances of the Safe smart contracts depending on the version you want to use and the network you have your provided connected to. After that, we have the SafeCore. CK this is the most important package in this monorepo.
00:03:59.930 - 00:04:21.598, Speaker A: It will need one of the previous packages like web Three or Ethers that will provide the connection to the network. And then you would need to provide a safe address in order to initialize this package. If you don't have a safe address, you can also deploy one with it.
00:04:21.598 - 00:04:43.030, Speaker A: And this package is all about interacting with the smart contracts. Everything there happens on chain and you can get information from the safe like getting the owners, the threshold, the nons, whatever. You can also create and prepare transactions you want to execute, sign them and execute them.
00:04:43.030 - 00:05:01.786, Speaker A: And finally we have the Safe service client. As if you remember before there was one service, the Safe transaction service that allows to collect transactions that are proposed and its signatures. And this Safe service client consumes that API.
00:05:01.786 - 00:05:33.682, Speaker A: So you can also get information from the safe by consuming this API, but also have access to the history of transactions, check the transactions that are pending and required your signature. You can also propose a new transaction, you can get the balances of the safe, the USDC conversion, et cetera. So in this monorepo we have these packages.
00:05:33.682 - 00:05:45.500, Speaker A: We also have a guide that will show you step by step how to use the SDK, how to propose a transaction, sign it, execute it. And we have a playground. This playground is something new.
00:05:45.500 - 00:06:14.370, Speaker A: It is a folder called Playground, where you already have a few scripts, just have to modify a couple of configuration parameters like your safe, the RPC you want to use, et cetera. And then you will be able to deploy a safe to propose a transaction, to sign it and to execute it. So let's see how the transaction flow looks like and how it is different from the external own accounts.
00:06:14.370 - 00:06:53.230, Speaker A: For external own account, the transaction flow is easy, right? You have just an account with a private key that gives you access to everything inside that account. However, the Safe, because it is a smart contract, where its main functionality is being a multisignature wallet, we need a couple of signatures so these signatures together can approve the transactions we want to execute if they reach a threshold we can define. So for example, two out of these three signers need to approve every transaction.
00:06:53.230 - 00:07:17.106, Speaker A: We can use the Safe transaction service to collect these signatures off chain. This is something optional, but we will use it to afford some gas. And as we saw before, the flow would be to initialize the core CK, deploy a safe if we don't have it, create, propose, confirm and execute.
00:07:17.106 - 00:07:25.158, Speaker A: So let's see how it looks. The code we need to import the Safe Core SDK library. Safe Ethers.
00:07:25.158 - 00:07:55.170, Speaker A: If we are using Ethers and then the Safe Service Client, we need to define our provider, get the signer and then initialize each of these packages. By providing these parameters. After that, we can create a transaction object with the destination value, data, operation, if it's a call or delegate call, et cetera.
00:07:55.170 - 00:08:26.862, Speaker A: We can convert this object into a safe transaction object that will also be able to handle the signatures and then we need to use the service the method proposed transaction to propose it and to send this transaction to the service then if we are running a client like this one using a different signer. We have the service to get a transaction. If we already know the safe transaction has, we can use it to get the transaction completely.
00:08:26.862 - 00:08:47.910, Speaker A: Otherwise, we have a variety of methods we can use like get pending transactions, for example. And then from there we can get the transaction we want to execute. Finally, we can call the service confirm transaction but before we need to sign it with the SafeCore SDK calling sign transaction hash.
00:08:47.910 - 00:09:12.720, Speaker A: And once we call the service, this signature will be submitted. After that, we just need to execute a transaction once we have enough signatures. So before that, before executing there's optionally a method that is called isvalid transaction that will check if this transaction will fail or not.
00:09:12.720 - 00:09:25.154, Speaker A: Here. If the transaction is executable, then we can call the method safe execute transaction passing this object. So that's how the basic flow works.
00:09:25.154 - 00:10:17.742, Speaker A: Now let's see what are the safe modules? This is the main flow and the safe modules are very flexible and allowed to increment or to expand the functionality of the safe because they offer us another flow for these transactions that is more flexible that don't depend on the signers. So we need to deploy a safe module in the same network where our safe is. And all the safe module needs to do is just call the method exec transaction from module in the safe so the current flow when you want to execute a transaction you are calling the method in the safe exec transaction.
00:10:17.742 - 00:10:52.990, Speaker A: Inside of that method there contain all the logic that checks if the signers did sign the signature the transaction. But here the safe module you can start with an empty one just calling exec transaction from module passing the transaction and it will have root access to execute the transaction. This is very flexible because safe modules are like a white paper you can fill but also the responsibility of doing it well it's on you.
00:10:52.990 - 00:11:20.038, Speaker A: So all the logic not for checking designers but for designing how do you want to make a transaction valid or executable or not depends on you. So multisignature control is the basic functionality the Safe has. But Safe modules also give us the opportunity to increase it.
00:11:20.038 - 00:11:36.380, Speaker A: For example assigning roles. We could decide to assign admin rights or token voting or spending limits. For example, this would look like admin rights if you know Zodiac, which is a Dao tooling standard.
00:11:36.380 - 00:12:20.646, Speaker A: Or they are building tools for DAOs. They have a module that is the role modifier and there you can define okay, for this you can define different roles and assign addresses to these roles, meaning that some addresses will be able to execute or to call a specific basically to execute transactions where the parameters of these transactions are checked. So somebody could execute a transaction where the destination is one specific address, but other addresses won't be able to do that, but they will be able to do other things depending on the roles.
00:12:20.646 - 00:12:40.634, Speaker A: For token voting. For example, you can decide to check if the approvers of this transaction have some balance of a token or NFT. And if some of them approve a transaction, then allow them to execute it or spending limits.
00:12:40.634 - 00:13:01.830, Speaker A: You could define that some account is able without anybody with any other confirmation, they will be able to spend a certain amount of a certain token in a certain period of time. Like weekly, daily? Monthly. This is for roles, but also for recovery mechanisms.
00:13:01.830 - 00:13:58.250, Speaker A: Modules would allow at some point of time when, depending on your logic, a Safe is not used to trigger a transaction or replace the current owners with the people who is activating this mechanism or just transferring the funds somewhere else. And we could do that with social recovery by defining your friends addresses and giving them access later in time or a secret questions like if you remember long ago when you were logging into a web page, there was do you remember your password? And then it would ask you what was the name of your first teacher or whatever. You could do something like that or custodial recovery or hybrid custody, et cetera.
00:13:58.250 - 00:14:27.250, Speaker A: And also modifiers. Modifiers are kind of modules that allow to be chained so each of them offers adds some constraints. For example, adding time logs to the transactions so you have a queue establishing cooldown periods or bonds where the people who confirms if a transaction can be executed or not have to deposit something, et cetera.
00:14:27.250 - 00:15:05.050, Speaker A: How does the core SDK facilitate the interaction or the management of Safe modules? There are a few methods that are available, for example get modules where you can get a list of the modules you have enabled into your Safe. Then is module enabled? Because I think I didn't say that in order to execute the transactions from the module, it is mandatory that the module is enabled in the Safe. That means that at the beginning the signers need to create a transaction to enable that module.
00:15:05.050 - 00:15:21.778, Speaker A: It's not that anybody can just deploy its own module and connect it to your Safe. So that's the basic thing. So with the SDK you can enable a module, disable a module, check if a module is enabled or not and get the list.
00:15:21.778 - 00:15:50.266, Speaker A: So that's for modules and then we have the transaction guards safe. Transaction guards are also smart contracts that need to be deployed in the same network and they somehow are connected to the safe but they are not a starting point in the transaction flow but somehow they will take its place. So here we see the transaction flow, the signers, the safe, the network and the safe.
00:15:50.266 - 00:16:21.990, Speaker A: Transaction guards that are connected to the safe the same as before. Transaction guards need to be enabled or disabled by the signers and once a transaction guard is enabled, what they do is they have to implement an interface with two methods. Each of these methods will be run before and after the transaction does some state changes in the contract.
00:16:21.990 - 00:16:57.170, Speaker A: So we will have a method to do a PreCheck and another method to do a post check and these methods will receive the transaction and will be able to parse it and act on it depending on the values of the parameters. If the checks that are there pass, the transaction will be successful, otherwise the transaction will fail and you won't be able to execute it. We saw the advantages or how the functionality can be expanded with the modules.
00:16:57.170 - 00:17:23.174, Speaker A: What transaction guards add is basically more protection. You can define an allow list or deny list, you could freeze an account, et cetera. How this would look like for example, for creating an allow or deny list you can deploy or create your own transaction guard with these two methods.
00:17:23.174 - 00:18:02.918, Speaker A: And in the storage of the Smart contract, you could have a data storage structure to keep a track of a list of addresses. And then in the first check, for example, you could check if the destination of the transaction that is going to be executed it is inside the list or not, and act on that to freeze an account. For example, you could have a variable in the storage of the smart contract that is a switch, a boolean where you can say okay, this account is freezed or it's not.
00:18:02.918 - 00:18:45.622, Speaker A: Do you see any problem with that? It is very cool to be able to freeze an account but if you turn the switch off then the next transaction there won't be any more transactions, right? Because there's no way to turn the switch on again. So it's very important that this kind of transaction guards parse a specific way of turning them on, just denying all the transaction except the one that where the data of that transaction or the encoding data allows to turn this switch on. So it's very cool.
00:18:45.622 - 00:19:15.790, Speaker A: But also you have to know what you are doing now, how the SafeCore SDK helps with Safe transaction guards similar to what we had for Modules, we have the method getguard. In this case, Safes can only have one transaction guard and you can enable them or disable them. These methods return a transaction that is ready to be signed by designers.
00:19:15.790 - 00:19:51.420, Speaker A: Okay, so that was basically it. We had the Safe Core SDK, safe modules, Safe transaction guards and now what you are all expecting, what are our Bounties for this hackathon? So the Safe Ecosystem Foundation has available $10,000 up for grabs and this will be given to the best projects that are built on top of the Safe. It is an open bounty so everything that is built on top of it will apply.
00:19:51.420 - 00:20:14.020, Speaker A: But we have some suggestions or ideas you can use. For example having a subdao management tool. Right now DAOs like to have subdaos with different funds and would be cool to have a tool that allows to do all the accounting thing for all of them.
00:20:14.020 - 00:20:40.170, Speaker A: Just an idea, improving the security with transaction guards, anything like the deny list or the allow list. Everything you can think of. Also working with modules, thinking for example on a family that shares an account and the different people have different kind of access to the funds, different rights.
00:20:40.170 - 00:21:08.420, Speaker A: Also anything related with account abstractions that you can think of. Another thing for example to create a chat where designers of the Safe can interact or can chat with among themselves. Also a tool that allows a Safe to publish official messages so anybody can read them and whatever you want.
00:21:08.420 - 00:21:47.360, Speaker A: So last thing, you can find us on Discord at chatnosis minusafe IO our forum and also on Twitter at safe. Now I will show a QR code if you want to get your phones ready with a Safe hackathon. Successful guide, success Guide then we have some learning materials, past workshops we did, also past hackathon projects and the winners so we can have some idea of what others built.
00:21:47.360 - 00:22:08.840, Speaker A: And also some general ideas like the ones you see with Safe modules, transaction guards and Safe apps. So now take your time to scan it or take a picture of it, otherwise we will be all the weekend in our booth. So feel free to come share your idea with us and we will try to help.
00:22:08.840 - 00:22:35.360, Speaker A: Okay and now some links that are also included in the guide for our GitHub. The SafeCore SDK repo, also the Safe Contracts repo or the Zodiac if you want to check some modules and guards and then some documentation on. So that's it.
00:22:35.360 - 00:22:43.890, Speaker A: Thank you very much and good luck with the hackathon. Thank you.
