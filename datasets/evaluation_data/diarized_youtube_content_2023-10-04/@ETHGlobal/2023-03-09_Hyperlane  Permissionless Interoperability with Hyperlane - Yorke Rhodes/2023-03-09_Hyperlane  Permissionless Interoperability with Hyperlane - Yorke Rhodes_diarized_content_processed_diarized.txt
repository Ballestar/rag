00:00:22.860 - 00:00:23.184, Speaker A: All right.
00:00:23.222 - 00:00:36.690, Speaker B: Hello and welcome everyone, to the Hyperlane Workshop permissionless interoperability with Hyperlane. Joining us today is York Rhodes, who will be taking us through this session. And with that, I will pass it over to York to introduce himself and get the session started.
00:00:38.900 - 00:00:47.016, Speaker A: Hey, guys, how's it going? My name is York. I'm with the hyperlane protocol. Been working on this for around a year.
00:00:47.016 - 00:01:08.392, Speaker A: It's kind of born out of last year's ETH Denver, and just wrapped up last week in Denver. We did some talks. I'm going to be kind of summarizing some of the takeaways there and kind of what tools are accessible for you guys to work with Hyperlane during the hackathons for East Global.
00:01:08.392 - 00:01:23.684, Speaker A: So, yeah, without further ado, I'll hop into Hyperlane. So Hyperlain is an interoperability protocol. And before we begin, I kind of just want to share my definition of what interoperability is.
00:01:23.684 - 00:01:48.700, Speaker A: So to me, interoperability is composability amongst DApps on different infrastructure. So Ethereum unlocked this composability of decentralized applications by introducing this generalized execution environment we call the EVM. And it did so kind of at the expense of performance.
00:01:48.700 - 00:02:42.460, Speaker A: As a consequence of that generalized execution environment, it becomes much more difficult to have kind of highly optimized consensus, basically. And what we've kind of seen over the past ten or so years in crypto is applications. As they want to optimize for performance or kind of capturing other forms of revenue, they begin to move away from these generalized execution environments which kind of provide composability by default to maybe like an Op chain model or a roll up model where the composability story is a bit less clear in exchange for basically better performance.
00:02:42.460 - 00:03:18.730, Speaker A: And in the past maybe couple years or so, the Ethereum community has kind of galvanized around the roll up architecture for kind of performance benefits that can be passed on to application users. And so this is kind of exciting because we no longer have to have all of the network being throttled by a single NFT Mint. We can now have roll ups take on some of the load there.
00:03:18.730 - 00:03:57.780, Speaker A: And what we're seeing in the ecosystem is applications are beginning to adopt these new architectures. So actually, pretty recently, the basically volume of transactions that roll ups which are settling to Ethereum are processing has superseded actually Ethereum L One transaction volume, which is pretty exciting. We're starting to see applications really opt into these new architectures and benefit or have their users benefit from kind of the scaling properties.
00:03:57.780 - 00:04:21.016, Speaker A: But along with those new architectures comes a few challenges. So basically, interoperability between these different roll ups is a highly fragmented ecosystem. And this is because there's kind of all these different types of interoperability between these architectures.
00:04:21.016 - 00:05:12.232, Speaker A: So the first form that probably most of you guys are familiar with of interoperability is what we call like, the canonical bridges of these roll ups, which are basically on L one, there's a smart contract interface for doing a deposit to a roll up and then there's an equivalent withdrawal interface to withdraw your asset from that roll up. And then separately, we have kind of a bunch of these asset bridges that function between roll ups that allow you to move assets using smart contracts between roll ups. And so some examples of this are hop synapse.
00:05:12.232 - 00:05:48.250, Speaker A: A bunch of these are focused on across, these protocols are focused on moving assets between roll ups. And the reason that these exist is the canonical bridges which, again, provide this deposit and withdrawal interface tend to be too cumbersome or too slow to go through always. For certain application use cases, especially in the case of optimistic roll ups, we have this withdrawal period of, I think, like seven days.
00:05:48.250 - 00:06:23.380, Speaker A: I think we don't want to impose that latency on an application that wants to kind of do something for its users across roll ups. And then finally we have these general message passing between roll ups. And this is kind of emerging as a way for smart contracts that exist on different roll ups to have composability, whether it's calling each other's functions or doing something a little more sophisticated than just moving assets between the roll ups.
00:06:23.380 - 00:07:15.540, Speaker A: And there's been kind of a few, I guess, early attempts in the community to establish some shared standards. So instead of each roll up having its own custom bespoke interface that now all application developers need to go in and custom integrate with, people are trying to define standards for this. So there's one ERC from, I think, the pool together team that's shown in the bottom left here, that's basically just trying to standardize these interfaces around something which is a little more sane and doesn't require application developers to have 30 different kind of adapters for all these different interoperability protocols.
00:07:15.540 - 00:08:08.310, Speaker A: And, yeah, just to highlight kind of why are we even doing this in the first place? Why are we trying to introduce interoperability between different chains or different roll ups, different execution environments? And the answer is these new types of application architectures can actually unlock innovation and new properties for users. So just as, like, a very recent example, the A 16 Z research team posted an article. They've been doing kind of a deep dive on a bunch of different auction mechanisms, but they implemented a sealed bid auction using Aztec Connect, which is basically like this L Two that the Aztec team is working on.
00:08:08.310 - 00:08:43.330, Speaker A: And in doing so, they kind of provided privacy to participants in this auction who are settling on L One, but maybe don't want to reveal their entire balances, for example. So, yeah, this is just, like, really exciting. Once we get interoperability between what I call heterogeneous infrastructure, we can really begin to kind of leverage a bunch of the innovation that's happening at the infrastructure layer in a single application.
00:08:43.330 - 00:09:23.070, Speaker A: So right now, there's tons of research, tons of R and d going into basically new roll up architectures, whether it's for privacy or performance. It's basically like majority of the research community is focused on these problems right now. But there's not really great interoperability between these different layers because they're all kind of designed in aren't hearing you at my end.
00:09:23.070 - 00:10:24.364, Speaker A: Yeah, they're all just kind of designed in different companies that maybe have a specific product in mind that they're going to build on top, but haven't really necessarily thought about how those products and those applications are going to compose with applications that are on other chains. There's also a lot of people working on light client interoperability, which is kind of amongst the research community gets lauted as the Holy grail of interoperability. And this is kind of what the Cosmos ecosystem has been working towards for the past, I don't know, four or five years in their work on IBC, basically having these native light clients for every chain that wants to be interoperable.
00:10:24.364 - 00:10:59.660, Speaker A: And so in their ecosystem, they kind of make a bunch of assumptions about the consensus and execution environment that chains are operating and then they're able to do these light client proofs between these chains. But even with this sort of solution, there's a bunch of problems. So for one, it's quite expensive to operate these light clients because you have to basically be processing every block header on chain.
00:10:59.660 - 00:11:23.700, Speaker A: And as you scale the number of connections you have between chains, you have to do this for every chain you're connected to. And actually in the Cosmos ecosystem, this is basically like subsidized as a public good for people to operate these things. But there's not really a great economic model around how to fund these light clients.
00:11:23.700 - 00:12:01.100, Speaker A: And the other challenge is these implementations of these light clients are quite complicated and require an implementation for every single state model. And so with all these teams kind of innovating on the VM layer, we have all these new VMs coming out fuel aptos, there's a ton, there's probably a new one on Twitter today. The light client implementation for these new VMs is probably many years away and these things don't generalize super well.
00:12:01.100 - 00:12:55.330, Speaker A: And for roll ups especially, this is true, we basically don't have a good light client solution for roll ups because of kind of how roll ups are architected. So all that's to say, kind of light clients are not a panacea for interoperability. But we do need some generalized protocol for application developers to understand, to benefit from composability with all these different new infrastructure layers that are kind of spinning up without again, you as a developer having to go through 25 different developer docs and say, what does their interface look like? So this is where this idea of modular interoperability comes in.
00:12:55.330 - 00:13:33.340, Speaker A: And this is kind of aligned with the modular blockchain thesis which is basically once applications reach a sufficient operating scale like let's say Osmosis or dYdX. Recently is moving to a Cosmos chain. Once applications reach this sufficient scale, again, they want to move away from maybe one of these generalized execution environments to something that's much more, well, optimized to their application and more kind of fine tuned.
00:13:33.340 - 00:14:41.536, Speaker A: And so we need to maintain the property of these protocols being composable with all the other DFI Legos, but we want to move them off, let's say, Ethereum L One. And so for developers to maintain that composability, we need to separate what's called the transport layer and the application layer. So the transport layer is basically how information moves between these chains, and the application layer is just basically what is the on chain smart contract interface to actually send and receive messages between these different chains? And so you guys, as DAP developers, shouldn't need to understand all these details about the transport layer, meaning, oh, is this a roll up that's sharing a settlement layer with the destination chain? Am I sending to a roll up? Am I sending to an L 01:00 A.m.?
00:14:41.536 - 00:15:10.284, Speaker A: I sending to a Cosmos chain? Do I need to use a different transport layer? As a developer, you shouldn't need to have control flow for all those different cases. There should be kind of like an application layer interface for you to pass messages and basically to send and receive messages to and from any chain, irrespective of what the underlying kind of infrastructure and transport layer looks like. And so this is where Hyperlane comes in.
00:15:10.284 - 00:15:41.488, Speaker A: Hyperlane is what we call a generalized message passing protocol, which provides this interface to your smart contracts on basically all of the chains that I've talked about thus far. So we're live on, like, I think, around 15 EVM networks, and we're working on a bunch of implementations of our spec across a bunch of other VMs. So we have a Fuel VM implementation, a C level VM implementation, which is for solana.
00:15:41.488 - 00:16:33.284, Speaker A: We have a Cosmos SDK module. And basically, as a customer of Hyperlane or as a developer using Hyperlane, you no longer have to maintain an implementation which is specific to optimism or specific to Arbitrum or specific to one of these roll ups because you have this consistent application layer API. And this is all with the caveat that, okay, we want to abstract away the transport layer from application developers because it complicates the implementation work, but we simultaneously want to allow those application developers to express their preferences for security.
00:16:33.284 - 00:16:57.516, Speaker A: So we don't want to just say, okay, we're going to oracleize all this information at the transport layer between chains. And developers should just trust us in the spirit of kind of modularity. We want to provide an interface for applications to say, hey, I know my application architecture the best.
00:16:57.516 - 00:17:10.800, Speaker A: That's why I'm deploying on this specific chain, or I'm building an application specific roll up, et cetera. I know my application the best. I want to design and pick all of the trade offs at every layer of the stack.
00:17:10.800 - 00:17:29.210, Speaker A: And I want to be able to specify what security I require on messages which are coming inbound to my application. So this can be like a function call from another chain. This can be an asset transfer.
00:17:29.210 - 00:18:17.864, Speaker A: You need some way to say, okay, I have this much confidence that this message which says, let's say that it's transferring me 100 USDC is verifiable basically according to the source chain. And so in the hyperlain protocol we have this, again, another application layer interface we call the interchange security module interface. And as a message recipient or again, like an application developer like you guys, you can say I want to use this specific security model for messages which are inbound to my application.
00:18:17.864 - 00:19:03.670, Speaker A: And so today our default security model that applications are kind of if they're not specifying an interchange security module they're opted into is basically this proof of stake validator set that we have on each chain. And if validators are lying about or basically producing signatures that don't match what the source chain kind of says as what messages were sent out from that chain, then that can be slashed. But the beauty of this kind of modular interface is you can have an interchange security module which is specific to your application.
00:19:03.670 - 00:19:51.540, Speaker A: And again, you don't have to kind of assume some sort of like omnibus security model, like a lot of the existing asset bridges or generalized message passing protocols kind of prescribe. So if you guys are familiar with Wormhole or some of these big asset bridges, there's like a centralized validator set and you're basically trusting that all the applications that are built on top of something like Wormhole are just trusting that that validator set will never be compromised. But it is the case that it might make economic sense for that validator set to collude and rug your protocol.
00:19:51.540 - 00:20:57.400, Speaker A: And that's a pretty unfortunate situation that we're in because we have kind of this third party set of security providers, but with the kind of like ism interface that hyperlane provides, you can now introduce these application specific security requirements. So you could say I want the validators who are providing security on messages inbound to my application to have some exposure or risk to my application. So maybe they also need to be staking your application's protocol token or maybe you have a multi SAG that you want to ensure has signed off on, you know, cross chain governance or something that you're doing between chains that again, now allows you to kind of express stronger and more granular security preferences as an application developer.
00:20:57.400 - 00:21:23.780, Speaker A: Yeah, so hopefully that makes sense. This is kind of like something we're really trying to get people to experiment with and potentially come up with interesting security models which are application specific. So whether that's like a cross chain stable coin, we want to introduce security mechanisms which right now we have a couple of off the shelf implementations available.
00:21:23.780 - 00:22:07.516, Speaker A: We have this like proof of stake multisig. We're working on an optimistic security model that was kind of pioneered by the Nomad folks. But yeah, again, just to summarize, kind of simple messaging API that exists across all these chains that kind of abstracts away the complexity or like idiosyncrasies of some of these different infrastructure layers and then a way for developers to specify their preferences of what security is happening at the transport layer while still having that configuration interface at the application layer.
00:22:07.516 - 00:22:24.420, Speaker A: So it's all just simple smart contract interface. You just set an address, you don't have to run or operate any of your own infrastructure. So again, there's this is like modular interoperability.
00:22:24.420 - 00:23:14.452, Speaker A: And then finally, what really makes this kind of scale well is we're providing the tools for developers to expand our protocol to whatever infrastructure they want. And this allows developers not to have to lobby for kind of inclusion. So let's say you no longer have to go to Jump or Wormhole and ask them and lobby them to bring their bridge to your chain or your roll up, which is a quite difficult process and probably is too much risk for them to take on.
00:23:14.452 - 00:23:26.840, Speaker A: So instead you can deploy hyperlane to any chain you want, you can expand it. permissionlessly. This is what the title of this workshop was about, permissionless interoperability.
00:23:26.840 - 00:24:28.780, Speaker A: So this idea that you can expand this interface messaging API to any new VM or any new chain that you want and you don't have to convince anyone to begin providing kind of transport layer relays to that new chain because you can specify your own interchange security module on that new deployment that says, okay, I want my application to be on this new chain on day one, and I'm going to get kind of all of the composability from all the existing Hyperland deployments inbound to my new deployment. And so we have super simple instructions for how to do this on EVM chains right now. Again, we're going to working on expanding this to a bunch of other VMs and we're also kind of excited to collaborate with people who want to see hyperlane on new VMs or on new chains.
00:24:28.780 - 00:25:00.600, Speaker A: But this is something that we'd really love to see people kind of play around with is take hyperlane, go check out the docs and look at what chains we're on. And if your application wants to be on some chain that we're not on, you can go and just run a couple of scripts and deploy the hyperlane protocol to that chain. And now introduce composability for your application with all these existing network effects.
00:25:00.600 - 00:25:19.710, Speaker A: That's basically what I wanted to talk to you about today. I'm going to take a look at the chat and see kind of what questions came in, what kind of messages we would want to send between chains that are enabled by interoperability. Yeah, great question.
00:25:19.710 - 00:26:01.860, Speaker A: So this goes back to kind of what I was talking about with what interoperability unlocks. So, yeah, again, you know, in a in a single VM like, single chain monolithic world, where we just have Ethereum, all the smart contracts that are deployed on Ethereum can just atomically call functions on each other. And this kind of enables.
