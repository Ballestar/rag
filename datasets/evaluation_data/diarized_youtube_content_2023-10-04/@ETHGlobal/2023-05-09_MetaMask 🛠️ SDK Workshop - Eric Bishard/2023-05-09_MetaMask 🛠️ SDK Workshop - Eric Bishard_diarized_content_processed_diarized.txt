00:00:10.230 - 00:00:31.778, Speaker A: All right, welcome to the MetaMask SDK workshop. Today we're going to be building a React and Next JS decentralized application with the MetaMask SDK. We're going to have a full stack monorepo project that has our smart contracts in a backend end and all of our React and Next JS in a front end.
00:00:31.778 - 00:00:54.022, Speaker A: And we'll use Truffle and Ganache to be able to run basically locally and build our application locally. And then once we're comfortable with where we're at in building our application, we can then deploy it out to a testnet using Polygon and Mumbai. And I'm really excited to get started with that.
00:00:54.022 - 00:01:04.794, Speaker A: My name is Eric bashard. I am the MetaMask Devrel Manager, and I'll be your guide through the workshop today. Before we get started, I already told you about who I am.
00:01:04.794 - 00:01:24.114, Speaker A: So what's next on the agenda is we're going to talk a little bit about the MetaMask SDK just for a few minutes before we get started with the workshop. Because I think it's very important to understand not only which application or which SDK that we're working with in our application, but also what else is available out there. Because developers do more than one thing right.
00:01:24.114 - 00:01:43.186, Speaker A: You might be a JavaScript developer, react native, react iOS developer. So we want to show you all the different flavors of the SDK that we have. First off, this is a few links that I want you to be aware of before getting started with a workshop.
00:01:43.186 - 00:01:53.914, Speaker A: So one we have an SDK developer guide. That's the top link there, and that is an ever changing document that I'll personally be keeping up to date. So you can bookmark it.
00:01:53.914 - 00:02:06.186, Speaker A: And as you're working with the MetaMask SDK, hopefully that document will be changing and anything new will be reflected there. Second, we have the tinyurl.com Svgnft.
00:02:06.186 - 00:02:21.694, Speaker A: So that link is the link to our workshop follow along guide. So, yeah, go ahead and bookmark these. Definitely follow that second link so that you can have that read me up while we're walking through the workshop.
00:02:21.694 - 00:02:50.910, Speaker A: It'll allow you to follow along with us and code with us during the workshop. You can either do that or watch passively, or you could even watch now and then take the guide home and walk through the code on your own time. Again, my name is Eric bashard, devrel Manager at Consensus and MetaMask, and here is my Twitter address http junkie if you want to reach out to me if you have any questions, feedback, anything.
00:02:50.910 - 00:03:14.674, Speaker A: Our DMs are always open. So although the SDK is new and we do believe that it will be the future of how you work with MetaMask from any application or platform, it's kind of a bold statement and we do have a long way to go. But just like any other tech, getting into it when it's new ensures that you're staying up to date and ahead of the curve.
00:03:14.674 - 00:04:20.102, Speaker A: And we really do think that using the SDK is going to make it very seamless for you, from whatever platform you're on, to be able to connect to the MetaMask extension or the mobile wallet. Yeah, so the MetaMask SDK basically lets developers connect to the MetaMask extension or mobile application independently from where their DAP application is running, be it on the web, desktop or mobile, and also separately from how it's developed, maybe with JavaScript native iOS, Android, Unity WebGL, whatever, right? So it provides an easy to implement and seamless solution for connecting to MetaMask and conducting transactions in your application. So the SDK we will use in our workshop today works with react applications, but we also have SDKs that work with vanilla JS node, electron react, native Unity WebGL and mobile applications.
00:04:20.102 - 00:04:35.870, Speaker A: And we'll also have an unreal engine coming soon. SDK has some great partners out there. So the SDK is available in the Unity Asset Store web Three section as a Unity verified solution.
00:04:35.870 - 00:04:54.386, Speaker A: The Unity Asset Store provides an in depth review of the SDK by Unity engineers. And the SDK is launched in, like I said, the new, decentralized kind of web Three section of the asset store. We also have a great partner in Hyperplay.
00:04:54.386 - 00:05:11.290, Speaker A: So Hyperplay is a web three native game launcher that enables players to carry their MetaMask wallet, NFTs tokens and achievements into every game. Hyperplay makes this ingame wallet interaction seamless and intuitive. And at the heart of that is the MetaMask SDK.
00:05:11.290 - 00:05:25.946, Speaker A: Here's just a quick look at what the Hyperplay game Launcher looks like. And also a QR code if you want to check them out. And also Hyperplay, like I said, they make these in game wallet interactions.
00:05:25.946 - 00:05:55.000, Speaker A: And you can see here a little bit of what that looks like and kind of how they've utilized the SDK to bring a very easy experience, a very usable experience to their gamers through having kind of like an embedded MetaMask in game wallet with a QR code. But even from a web application, right, you can do the same thing. You can connect to the extension that's already in Chrome, or you can use a QR code to connect out to a mobile application.
00:05:55.000 - 00:06:01.978, Speaker A: Yeah. So check out the MetaMask SDK on the Unity asset store. This QR code will get you there.
00:06:01.978 - 00:06:27.300, Speaker A: And with that being said, let's go ahead and move on to the workshop portion and let's get started building a DAP with the MetaMask SDK. All right, so let's go ahead and get started with the workshop. So the first thing that we're going to want to do is we're going to want to take a look at the GitHub repo, which was the second link in the intro.
00:06:27.300 - 00:06:46.166, Speaker A: And the first thing we can do is find the link for the code. That'll help us to get this started off here. And by the way, if you want to follow along with the workshop, you can basically just start right here.
00:06:46.166 - 00:07:02.078, Speaker A: And you'll be able to follow along with us. We're going to skip over talking about all this stuff up here in the workshop, why we made the workshop the way we did kind of some of our decisions around it. And what we are going to do is go ahead and just get started.
00:07:02.078 - 00:07:27.234, Speaker A: We're going to clone the repo down and I'm going to move this window over to the side, but you can follow along there if you'd like to. All right, so one of the first things that we need to do is just go ahead and clone the repo and get that pulled. All right? And then let's go ahead and CD into that directory, which is on chain SVG tickets.
00:07:27.234 - 00:07:52.494, Speaker A: And then we'll do code that'll open it up in Visual Studio code for us and we can go ahead and get rid of this terminal. I will really quickly just kind of make sure that I'm on the right version of Node. So I'm using NBM it's node version manager and it says I'm on system.
00:07:52.494 - 00:08:01.060, Speaker A: I think that's fine, but I think I want to go ahead and just do NBM use 18. Okay, good. All right.
00:08:01.060 - 00:08:27.654, Speaker A: So first step I think we want to take care of is just making sure that we have Truffle and Ganache installed locally. So that'll be NPMI, Truffle, Ganache, G, and that will install this locally. And while we're doing that, I will kind of talk about the agenda, kind of what we plan to do during the workshop.
00:08:27.654 - 00:08:52.034, Speaker A: So we're going to start by building and testing locally from the starting point, which is this start repo down here. So down here you can see that we are on this start branch, right? Okay. So what we've done for you is we've pretty much added all the NPM packages and everything that you need, and we'll run that NPM install command in just a moment.
00:08:52.034 - 00:09:08.722, Speaker A: When we're done installing Truffle and Ganache globally. From there we're going to build out our front end. We will talk a little bit about the blockchain part of the application, which has the smart contract in it, which we'll be deploying locally and to a testnet eventually.
00:09:08.722 - 00:09:31.134, Speaker A: But we'll be mostly working in this web directory right here. Once we've kind of finished completing the buildout of our front end and we have our NFT tickets able to be minted and we're able to display those tickets to the user, then we're going to go ahead and deploy to a test net. So we'll need some test ETH or some test matic in order to do that.
00:09:31.134 - 00:09:50.260, Speaker A: I've got a wallet with some of that in it. So we'll switch from using, like a local wallet and local network to using the polygon network, specifically the Mumbai Testnet Polygon network. So you'll need some test ETH for that testmatic in.
00:09:50.260 - 00:10:05.334, Speaker A: Yeah. And then from there, we'll pretty much have completed the entire workshop. We'll have built locally, ran our blockchain locally got to a point that we were confident in pushing to a test net, and then we'll change some configurations and push out to that test net.
00:10:05.334 - 00:10:20.990, Speaker A: All right, so the next thing we need to do is run an NPM install command down here, and that'll just get all of our packages installed. And let's go ahead and take this time to go over the contract that we're going to be deploying. So it's pretty simple.
00:10:20.990 - 00:10:40.020, Speaker A: It is just a basic NFT token with the ability to mint. We have a total supply, which could be any number we wanted, but we're going to stick with 8999. Let's say that's how many people can fit into our event.
00:10:40.020 - 00:10:53.222, Speaker A: We also start the value out at 999. So it's actually about 8000 rather than 8999 because we start at the number 1000. Right.
00:10:53.222 - 00:11:02.726, Speaker A: And the only reason I've done that is so that our tickets look nice. They have a nice, like, four digit number, and it doesn't go beyond a four digit number. So our tickets always stay nice and formatted.
00:11:02.726 - 00:11:11.870, Speaker A: Again, not really realistic. We're pulling in a few different libraries here. You can kind of explore these on your own.
00:11:11.870 - 00:11:24.914, Speaker A: You might already know them as a smart contract developer. The way that we're determining whether the ticket is a VIP or a general admission is by the amount of ETH that they pay. So whether it's 0.2
00:11:24.914 - 00:11:38.600, Speaker A: or 0.1 ETH now, if we were deploying on Maddox versus Ethereum, we might need to change the amount for each one or something like that. Anyways, this is just a demo.
00:11:38.600 - 00:11:44.322, Speaker A: It's not super important. These things can always be changed. We have a minting deadline.
00:11:44.322 - 00:12:02.538, Speaker A: That means after the block timestamp occurs, it's 168 hours until no one is able to mint tickets anymore. So you might want to employ that in one of your contracts. Contract Uri and Token Uri.
00:12:02.538 - 00:12:27.410, Speaker A: These are just kind of what create the JSON for the kind of collection of NFTs and then each of the individual NFTs, which are basically an on chain SVG. So we're encoding the SVG. We're also kind of breaking up the rendering of the top and the bottom of the SVG.
00:12:27.410 - 00:12:44.060, Speaker A: So that's what those functions are for. And then we have a generate SVG token by ID. This one's kind of important because we're going to be calling this from another wallet of owner right here.
00:12:44.060 - 00:12:51.120, Speaker A: Generate. Let's double check on that. Let's see.
00:12:51.120 - 00:13:19.990, Speaker A: We're actually calling that from the token Uri and then from the wallet of owner. Yeah. So what the wallet of owner is doing is the only thing that the wallet of owner is doing is it's determining which NFTs based on the address that you have in your wallet, which NFTs that you've minted on this contract.
00:13:19.990 - 00:13:34.170, Speaker A: And then it's returning those token IDs. And then we're able to do something further with that. So when we get into that part of the front end project, we can kind of see how that works.
00:13:34.170 - 00:13:53.380, Speaker A: What we want to do is we want to mint an NFT, and then we want to immediately show the SVG that they've just minted. Once the Minting is complete, then we have a basic Mint NFT function here. And yeah, that's about the extent of it.
00:13:53.380 - 00:14:31.498, Speaker A: One thing I will note is that by storing our SVG on the chain, it's going to cost a little bit more to deploy our contract to actually mint each NFT. But for a demo purposes and showing you how a full stack Web Three application works, I think it's a great way to start because you don't have to worry about storing JPEGs on IPFS and pinning those assets and just kind of the overhead of kind of managing all of those image assets. All right, so we've kind of walked through the contract.
00:14:31.498 - 00:14:41.506, Speaker A: A few things I'll note in here, we're using Typechain. This is a little bit more too much for us to go over in the limited amount of time that we have for this workshop. So I will skip over that.
00:14:41.506 - 00:15:11.674, Speaker A: But just know that Typechain allows us to have typing in our Web application around our smart contracts, which is really cool technology that we've included into this demo. So with that, I think the next step is to go ahead and just kind of run the application and make sure that it works. So I'm going to show you kind of one way of running the front end, and then we're going to kind of back up and do it a different way.
00:15:11.674 - 00:15:27.630, Speaker A: So you could CD into the Apps directory and then go into Web, and then we could run NPM, run dev. Okay, so that will definitely get our project up and running. There's not a whole lot there right now.
00:15:27.630 - 00:15:52.790, Speaker A: So as we can see, it's just going to say, let's build in Web Three. So it's a react application, more specifically, a next JS application. We've got some basic pages and layout already created for you so that you don't have to do that yourself and some configuration for the different networks that we're going to support.
00:15:52.790 - 00:16:03.130, Speaker A: All right, we're going to have a local host. We're going to support Garly and Mumbai. And then what we will do is we will set an environment variable here.
00:16:03.130 - 00:16:22.082, Speaker A: So let's go ahead and do that now, rename that to env, and we're going to use the local host for this right now. All right, cool. So we've set the local network that we're going to be using.
00:16:22.082 - 00:16:36.914, Speaker A: Our application knows about it. It knows that if this is set here, to look in the config file and find that number and then use that network to test on. But we don't want to run our project in this manner that I just showed you earlier.
00:16:36.914 - 00:17:08.190, Speaker A: We want to go ahead and CD back up to the original root directory, and we're going to run two different commands here. So we're going to run NPM run build which will build our artifacts for our smart contracts. And then after that and by the way, what's happening here is from this command, it's going into the blockchain folder and using a command from inside here a script from inside of that directory.
00:17:08.190 - 00:17:29.846, Speaker A: Back up a moment here. And so now that that's built, we're going to do NPM run local. That's going to spin up a local instance of Ganache and it's also going to give us some private keys that we can use that will give us some 100 test ETH to start playing around with.
00:17:29.846 - 00:17:46.646, Speaker A: We're going to open up one more terminal here and this is where we will run NPM run dev. Right again, it knows to go into the web directory and run the proper script from there. So we can do all of this from the root directory.
00:17:46.646 - 00:18:13.750, Speaker A: That's what I like about a monorepo using something like turbo. All right, so when we ran the NPM run local command, we got some private keys over here and what we're going to do is copy one of those. This will give us our test ETH for running locally and we can open up our browser here, pull this into MetaMask.
00:18:13.750 - 00:18:33.626, Speaker A: And let's go ahead and switch chains for right now just so that we can also do that when we come back. All right, so we are going to import this account private key and that should give us 100 ETH. Now we're not going to see it right away.
00:18:33.626 - 00:19:07.160, Speaker A: What we need is a localhost network chain and we have to import that in. So what we're going to do is just kind of open this back up and go to settings networks, add network, add a network manually and we're going to do localhost 9545. We will do http localhost 9545.
00:19:07.160 - 00:19:22.854, Speaker A: Let's make sure it's a colon chain. ID will be 1337 and the currency symbol will be ETH. So we'll go ahead and save that and now we should see our 100 ETH and we should be on that local host.
00:19:22.854 - 00:19:57.970, Speaker A: Great, go ahead and close that for now. So we have our account imported, we have our local blockchain network inside MetaMask and we've also set the chain in our environment variable file and in our config. The one other thing we'll do is we'll grab the contract address here, copy that and we'll also bring that into the web lib config.
00:19:57.970 - 00:20:08.794, Speaker A: We're just going to paste that right here. Let's go ahead and remove these two because these are going to be different when we run these. When we deploy to testnet later we'll use these two.
00:20:08.794 - 00:20:23.070, Speaker A: But right now we're going to be using this one. All right? So next thing we need to do is we need to start building our application. So the first thing we're going to do is we're going to build our navigation and that's going to have everything we need to be able to connect to MetaMask.
00:20:23.070 - 00:20:43.206, Speaker A: With the SDK, it's very simple to pull that package into your project and with a few lines of code be able to connect to the MetaMask extension or the MetaMask mobile wallet. But there's a lot of other things that you'll need to do in order to keep the wallet state in sync with your application state. So we're going to show you how to do all of that.
00:20:43.206 - 00:20:56.730, Speaker A: So in our components folder, we're going to create a styled components directory. Let's make this a little bit wider. And then in here we're going to create two new files.
00:20:56.730 - 00:21:27.934, Speaker A: One called General JS and another one which is going to be called Navigation JS. All right, so we're going to use styled components for creating react documents that have styling injected. So these styles will typically be like I'm creating a navigation component so the navigation will have styles in it for components that we're going to be using within that navigation component.
00:21:27.934 - 00:21:46.566, Speaker A: And that'll make sense in a minute if you've never used styled components before. The general one is going to be for components with style that we're going to use potentially throughout our entire application. So we're going to go ahead and paste this in and you'll just see that we have a number of components here, a flex container.
00:21:46.566 - 00:22:05.440, Speaker A: We're creating a flexbox layout for our tickets page which is going to have two items in it for each ticket general admission and VIP. We're going to need a button. So these are going to be div components and then the button component is going to be of an element of button.
00:22:05.440 - 00:22:24.790, Speaker A: And we can also pass in props to these button like text, size, margin, top, right, bottom and left. And you'll see a good example of that when we create that button. All right, so for the navigation, we can just copy that from our README.
00:22:24.790 - 00:22:42.840, Speaker A: As you can see here, we have Navigation View. That will be a component that wraps the entire view of the navigation. And then we have a logo that's going to be on the left and then a right navigation that's going to have a balance like our wallet balance inside of it.
00:22:42.840 - 00:22:54.890, Speaker A: All right, so we can go ahead and move on to the next component which will be the Navigation TSX. And that's going to be just right here inside the components folder. We're going to call it navigation.
00:22:54.890 - 00:23:03.694, Speaker A: TSX. Go ahead and copy that code in. We'll take a look at what we have in there right now.
00:23:03.694 - 00:23:27.602, Speaker A: So here you can see we're importing in those styled components and you can see how this is kind of set up, right, we have navigation and a flex container. This is our flexbox container with two items in it, both taking up a width of 50%. On the left hand side we're going to have a logo with an ethereum logo and then ETH Atlantis next to it, right? Nothing crazy.
00:23:27.602 - 00:23:52.778, Speaker A: And then on the right hand side, we're going to have a right NAV with a MetaMask button in it. So we're just going to keep drilling through and creating all the components that we need in order to make this entire navigation work. It's going to be a lot of stuff, but once we get finished and once the navigation works, we'll be able to use a lot of these same components for the rest of our application.
00:23:52.778 - 00:24:09.886, Speaker A: So on the actual index page and also the react hooks that we're going to use, we're going to be able to use those throughout our application. So getting this navigation working is key. So let's go ahead and update our page index.
00:24:09.886 - 00:24:41.280, Speaker A: TSX we're just going to copy over this, and all that we've done is brought in this navigation component here, which already exists. If we go back over to our page now, we should start to see things coming together, right? We've got our ETH Atlantis logo, and we've got our MetaMask connect button text on the right hand side, which we're going to replace with an actual MetaMask button, connect, disconnect, switch, chain, all that good stuff. Everything we need, really, to kind of get this application kicked off.
00:24:41.280 - 00:25:06.882, Speaker A: Now we're going to create the react hooks. So if you're new to react, we've put some links in the description inside the README to link over to the react doc so that you can learn more about react hooks. But basically what we're doing is we're taking functionality from within our application and just kind of extracting it out and colocating it somewhere else.
00:25:06.882 - 00:25:20.950, Speaker A: That's the easiest way to think about that. We're going to create a new folder inside of Web, and this is going to be called Hooks. And the first hook that we're going to be creating is a use MetaMask.
00:25:20.950 - 00:25:32.634, Speaker A: TSX all right, we'll go ahead and copy this in. And this is a big file, so this has got a lot of stuff going on. I'm going to try and explain it very simply.
00:25:32.634 - 00:25:58.786, Speaker A: All of these things that I'm collapsing here, these are just types that we need in order to make this work. If this was just a JavaScript application, we wouldn't have any of these first, like, 50 lines of code, but these are just set up. These are types that are going to make it easier for us to work and build things in our application without the worry of them not working right or having bugs in them.
00:25:58.786 - 00:26:33.540, Speaker A: So that's a really good thing that we get out of TypeScript. I'm sure that a lot of you kind of know all about react and TypeScript, so I won't go too deep into it, but our hook is going to have a reducer in it, and this reducer is going to kind of track and keep in sync all of our state. So constantly we're going to be calling these actions Connect wrong network disconnect page loaded, loading idle, network switched and these are going to be mutating our state and kind of returning a new version of the state.
00:26:33.540 - 00:27:00.860, Speaker A: So we're also going to be doing some things inside of the state. Like we're going to be saving items into local storage when we connect and also when we have wrong network and also disconnect, we're going to remove state from the local storage and that's going to help us to simulate disconnection from the app. And we can talk a little bit more about that later.
00:27:00.860 - 00:27:35.570, Speaker A: After we get done with our reducer here, we are going to need to create a react context and this actually creates a component that we can wrap around our entire application and all of its children will have access to the updated global state of our wallet that we're kind of keeping in sync with our application. And then we'll use this in our other components using this use MetaMask hook. All right, and that will just return the context of the provider.
00:27:35.570 - 00:27:55.302, Speaker A: All right, so we've got that one created. The next file that we need to create is be the use listen. So we're going to create inside the hooks folder a use listen hook uselessen.
00:27:55.302 - 00:28:30.580, Speaker A: TSX all right, so here we are grabbing this is supported network. It's kind of a function from our configuration and this is just checking to see if we are on the right network or not the specified network that we want to be running on, which we've set that in our environment variable file right here. It also listens to any of if the chain has changed and we'll dispatch a network switched.
00:28:30.580 - 00:28:43.576, Speaker A: If that's the case, it's going to be listening for if the account has changed in our wallet. So if someone changes the account, it reflects inside of the application. And then also what is the new balance.
00:28:43.576 - 00:29:01.300, Speaker A: So get balance from MetaMask and ETH chain ID. These are all kind of important so that we can dispatch either a connect or a wrong network action in our reducer, which will again mutate our state. Otherwise it's just going to dispatch a disconnect.
00:29:01.300 - 00:29:26.540, Speaker A: All right, moving along, we have a use switch network hook that we need. So if someone moves off of the intended network that we want them to use, use switchnetwork. TSX this a little bit bigger.
00:29:26.540 - 00:29:47.396, Speaker A: If someone changes the network or if they log on with the wrong network, we want to provide a button that will allow them to switch the network back to the right one. And this is a hook. So this is the actual function that will do that switching of that chain for us, calling that dispatch network switched when we're done.
00:29:47.396 - 00:30:05.508, Speaker A: And all that it's really doing is first again, checking if it's not the supported network. Again, that's for our application. If the right network is not set up in our application, this doesn't really come into play with the user.
00:30:05.508 - 00:30:26.332, Speaker A: That's why it's throwing an error. But when we switch the network, we want to call Ethereum request wallet, add Ethereum chain, and this will either add and or switch the chain for the user. And it's going to require parameters of chain ID, chain name, native currency which has decimals name and symbol.
00:30:26.332 - 00:30:38.176, Speaker A: So name would be the name of the chain, symbol would be the ETH, and then potentially the RPC URLs. I'm sorry. The RPC URLs and potentially the Block explorer URLs.
00:30:38.176 - 00:30:53.540, Speaker A: But this is not always needed, especially when we're running locally. Yeah, and then we're just going to return the switch network function out of that hook. Next, we actually need to create the component that will use this hook.
00:30:53.540 - 00:31:00.170, Speaker A: So we'll go ahead and do that. It'll be called Switch Network spell. That right.
00:31:00.170 - 00:31:07.580, Speaker A: Switchnetwork. TSX. And this is going to be a really simple component.
00:31:07.580 - 00:31:21.056, Speaker A: So all that it is, is it's using that button component that we have, we're passing in some props which are text and all the margins. So these are not required. That's why they have the question mark after them.
00:31:21.056 - 00:31:36.550, Speaker A: They're optional props, but we created an interface for it. And text size will be ten if they don't pass it in, and all the margins will be zero if they don't pass it in. If they want to affect one of these, they can just pass in that one property and nothing else.
00:31:36.550 - 00:31:52.664, Speaker A: So, pretty simple component that we have there. Now that we have that, we want to go back into our navigation and just kind of update the code now that we have this added. So we'll just go ahead and paste in all of the code.
00:31:52.664 - 00:32:01.470, Speaker A: And I'm going to make our terminal a little bit smaller here. And I'm going to go ahead and collapse a few things just to make this easier. And we'll walk through it really quickly.
00:32:01.470 - 00:32:24.256, Speaker A: So we are using that use MetaMask hook, which will get us our state, our context. And so this will give this component any updated state that we have. We're going to be calling that use listen hook so that we can start to listen to the changes from the MetaMask wallet.
00:32:24.256 - 00:32:39.064, Speaker A: We need to create a few variables that will determine whether we want to show the install MetaMask button versus the connect button. We want to be able to call a function to connect them or to disconnect them. Disconnect one is very easy.
00:32:39.064 - 00:32:56.290, Speaker A: It dispatches a disconnect action. However, if they call the handle connect, we have to do a little bit more work here. We're going to dispatch loading, we're going to request the ETH accounts, balance, chain ID, all of that stuff, and then dispatch a connect.
00:32:56.290 - 00:33:11.796, Speaker A: Otherwise, we will determine through this if statement if they're on the wrong network and dispatch a wrong network action. So let's go ahead and close that back up. We're just formatting the address to only show the first few.
00:33:11.796 - 00:33:30.280, Speaker A: Numbers and the last few numbers of their address. And that will get printed out right here. So here's where we are potentially showing one of many different buttons, right? It could be the connect button, it could be the install MetaMask button, the disconnect if they're on the wrong chain switch network.
00:33:30.280 - 00:33:57.632, Speaker A: Or we're going to show the address and the balance if everything else is there, if we have access to that wallet. All right, so moving through this really quickly, I like this. We do need to go update the app TSX page, because now that we've created this provider that has this context, this state, we need to be able to wrap that around our entire application here.
00:33:57.632 - 00:34:13.850, Speaker A: And this is going to be very easy. So we're basically just adding this line and this line, the MetaMask provider around our layout, and then all of our components in our application will have access to this global state. And of course, we needed to import that as well.
00:34:13.850 - 00:34:33.164, Speaker A: All right, getting to the layout. TSX so kind of one of the last steps is the layout has functionality for potentially all of our pages in our next application. So we're going to paste this in and just talk about it really quickly.
00:34:33.164 - 00:34:43.296, Speaker A: We want to have a use effect in here. Lib MetaMask. Yeah, we have to create this instantiate SDK file in just a moment.
00:34:43.296 - 00:35:01.444, Speaker A: So we are again getting access to that dispatch action from our use MetaMask. This will be how we initially listen to the MetaMask wallet. And then we're doing some basic stuff, determining if a provider is injected.
00:35:01.444 - 00:35:22.984, Speaker A: So is the wallet injected into the browser? Is MetaMask installed running that listen for the first time? And then our local variable could be null. So we want to have a backup. If local storage is empty, we want to go ahead and put null in for all of those items instantiate the SDK.
00:35:22.984 - 00:35:41.664, Speaker A: This will just be a few lines of code, which we'll do next, and then dispatch that the page is loaded so that we know that we can start working with the application, so to speak. Basically, the page is loaded. So the final one that we're going to create here is in the lib folder.
00:35:41.664 - 00:35:59.032, Speaker A: We're going to create a MetaMask SDK. TSX and let's go ahead and make sure that we capitalize the M there. We're going to paste this in.
00:35:59.032 - 00:36:17.920, Speaker A: So this is going to get rid of a few of the errors that we have in TypeScript as well. We are going to instantiate that MetaMask SDK, which we'll see that working in just a few moments when we get this up and running. We've already set the network ID in our environment variable file.
00:36:17.920 - 00:36:32.004, Speaker A: So now what we need to do is go ahead and check out the page and see if it's working. All right, let's take a look. So here we have our application.
00:36:32.004 - 00:36:40.260, Speaker A: It looks like we've got our navigation and we've got our Connect Wallet button. So we'll go ahead and hit Connect Wallet. This will bring up in MetaMask.
00:36:40.260 - 00:36:50.804, Speaker A: We don't want to connect to our account one with zero ETH in it. We want to connect to this one down here with our 100 ETH. So go ahead and hit next.
00:36:50.804 - 00:37:02.792, Speaker A: Connect. All right, now we've got our balance displayed over here. We've got our address and we can disconnect and reconnect.
00:37:02.792 - 00:37:27.940, Speaker A: And that's just simulating a disconnect, right? It makes the application kind of stop listening to the changes. I think the best way to describe it is like you can disconnect from the app. Your local storage remembers that you're disconnected from the app and you can come back and then reconnect and it will already be connected.
00:37:27.940 - 00:37:38.570, Speaker A: It's just a UX feature. That's all that it is. It's not really disconnecting from the wallet, but we like to add it or at least show people how to do it.
00:37:38.570 - 00:37:52.424, Speaker A: The next thing that we can do here is we need to start to add the Tickets and Minting page. Looks like everything is working here. Let's go ahead and check if we go to the wrong chain before we start adding our tickets.
00:37:52.424 - 00:38:04.080, Speaker A: So now we get switch chain here because we went to the Ethereum chain and it'll switch us right back to localhost. And now we're good to go. All right, so it looks like everything is working in the navigation.
00:38:04.080 - 00:38:18.980, Speaker A: We're just going to go ahead and close all these pages real quick and let's go ahead and start adding our tickets. So the first thing we want to do is go over to our index TX page. We're going to add some new imports.
00:38:18.980 - 00:38:36.764, Speaker A: So we want to bring in Ethers, the Use MetaMask hook and tickets that doesn't really exist yet. And we'll add a few more things here. So just underneath our Mint declaration of our component here.
00:38:36.764 - 00:38:54.530, Speaker A: And before the return statement, we'll go ahead and add the tickets that we need to display on this page with the prices, a hex version of those prices. So that when we submit that as a transaction, it's using the right values. You can't pass 0.1.
00:38:54.530 - 00:39:19.080, Speaker A: You have to pass the hex value of that number. And then we'll go ahead and add tickets here and we actually want to pass those tickets in. So we'll do tickets equals tickets, right? So we're going to get these tickets from here.
00:39:19.080 - 00:39:43.114, Speaker A: And now we need to go ahead and create this Tickets page that will display all this information. So we're going to go into our styled components first and we're going to create a new file called Tickets JS. I've messed up here, didn't I? No, I don't want to do that.
00:39:43.114 - 00:39:59.840, Speaker A: I want to create a new file called Tickets JS. Go ahead and copy in our styled components. All right, so we've got a Tickets view again, wraps the entire Ticket view.
00:39:59.840 - 00:40:13.488, Speaker A: Ticket type will be the view around the actual two tickets that we have. We have a styled alert for errors, heading, text, ticket type, text. So there's just some text that's going to be displayed.
00:40:13.488 - 00:40:26.650, Speaker A: What color do we want it to be displayed? Nothing big here. Moving on to the next. We want to actually create a tickets TSX page.
00:40:26.650 - 00:40:43.810, Speaker A: So let's go ahead and copy that and we'll just create a new folder. That's what I was trying to do before I kind of went out of order here. And we'll create the tickets TSX page.
00:40:43.810 - 00:40:58.702, Speaker A: Looks good. Copy in our code. And let's just kind of collapse a few things here real quick.
00:40:58.702 - 00:41:12.760, Speaker A: So we have our styled components that we're copying in. We have our interface for our ticket. So each of these tickets that comes across in this array of tickets that we just passed in will have this shape to the object here.
00:41:12.760 - 00:41:23.654, Speaker A: Ticket props is just going to be tickets. And it's going to be an array of this type here that we just defined. These are the values that we could use in our page.
00:41:23.654 - 00:41:37.606, Speaker A: I think we're only using a few, but we could use type, price, price, hex value, anywhere we want. In this page, we have a few pieces of state that we're creating and then we are returning. This is our ticket types.
00:41:37.606 - 00:41:49.170, Speaker A: So this is just going to be the types of tickets that we have. And it's going to be in a flex item because we're going to have a flex box with two items. And each ticket will be a flex item.
00:41:49.170 - 00:42:09.400, Speaker A: And then down on our tickets page, this is where tickets is being passed in. And we're going to be iterating over those tickets and mapping them each as a ticket type component. So there will be two of these components here which look like this.
00:42:09.400 - 00:42:27.114, Speaker A: All right, I think I explained that correctly. All right, so next thing we want to do is we want to add Minting functionality to these tickets because right now you can see everything. But as much as I click, these buttons will not work.
00:42:27.114 - 00:42:35.550, Speaker A: And that's kind of the developer flow. You create a button, it doesn't really work. It looks good, but now we got to create the functionality that makes it work.
00:42:35.550 - 00:42:52.398, Speaker A: So we're going to copy in some new imports to our tickets TSX page. So we're just going to replace all the ones that we have. And you'll see a few new imports come in here, use router which will in next JS, allow us to refresh the page, use MetaMask.
00:42:52.398 - 00:43:01.334, Speaker A: We know what this thing does. This is how we get the state, the global state for our Wallet ETH tickets factory. It's the first time we've seen this.
00:43:01.334 - 00:43:09.718, Speaker A: We'll see how that works in a moment. Ringing in Ethers and we already kind of know what config and is supported network do, right. They tell us if we're on the right network.
00:43:09.718 - 00:43:21.950, Speaker A: It gives us access to that config file. Next thing we want to do is we're going to replace this. We're just going to add a few lines above this.
00:43:21.950 - 00:43:39.342, Speaker A: So we're going to destructure that wallet state out of use MetaMask. We're going to bring in that used router so that we can use this hook in just a few moments. And then from there, we need to add a Mint ticket component.
00:43:39.342 - 00:43:54.066, Speaker A: So right below what we just added, we're going to create this Mint ticket function. So we need a provider and a signer here, because this is actually going to mint a ticket. It's going to create a transaction on the blockchain.
00:43:54.066 - 00:44:04.220, Speaker A: We are going to create a factory variable out of this ETH tickets factory, which needs a signer. In order to work. We need to know what the network ID is.
00:44:04.220 - 00:44:11.054, Speaker A: So we've got that there. We throw an error if the network is not supported. We should actually make these errors look the same.
00:44:11.054 - 00:44:29.214, Speaker A: The one on the other page was slightly different, but that's not really a huge deal. And now we're attaching to that factory. We're telling it what the network ID is and where to find that contract address in whichever network.
00:44:29.214 - 00:44:44.058, Speaker A: So the best way to think about this is the network ID is being passed in. We're looking in the config file for that ID, and then we are looking for the contract address. Probably could have explained that a little bit better, but that's the basics to it.
00:44:44.058 - 00:45:01.946, Speaker A: We Mint an NFT, we pass in the wallet and the value of the ticket. We then wait on that transaction to complete. So we're going to return Minting accepted, Minting complete in the console.
00:45:01.946 - 00:45:13.534, Speaker A: We'll set is Minting to false when we're done and we'll reload the page. Otherwise, if they reject it or if something goes wrong, we'll catch that error and display it right underneath the button. Can't Mint.
00:45:13.534 - 00:45:25.800, Speaker A: This would just be a state in which we don't have a wallet or is Minting is false. So we would want to not Mint in that case. All right.
00:45:25.800 - 00:45:54.880, Speaker A: Now we just need to add the call on the button right here. So we need to add on click, and we're going to call the Mint ticket function. And then with that, we should be able to go ahead and test that our Minting function works and we should be able to confirm here.
00:45:54.880 - 00:46:15.614, Speaker A: All right, so we've Minted a ticket, and if we just inspect that one more time and go take a look at the console, we're going to comment out this router. Reload do that one more time. We can see there Minting accepted, Minting complete.
00:46:15.614 - 00:46:46.550, Speaker A: So we've Minted two general admission tickets. And the next thing we want to do is we want to bring in a tickets owned component just underneath that tickets page so that we can see that those tickets pop up right when we get done, minting them, which will be a visual cue for the user to make sure that they know that the ticket mint went okay. So we're going to create a new file here called Ticketsowned JS.
00:46:46.550 - 00:47:01.274, Speaker A: And we will copy that in there. It's just a view that will control the padding and border of that tickets owned view. Again, it'll show just underneath that tickets area that we just built.
00:47:01.274 - 00:47:12.800, Speaker A: And we'll have a grid, a CSS grid with some SVG items inside of it. Just like Flexbox has items, grids also have items. And we're going to do like four across.
00:47:12.800 - 00:47:25.970, Speaker A: So if you meant more than four tickets, it'll just be like two rows of four. All right. And then we need to create our ticketsowned TSX inside the tickets folder.
00:47:25.970 - 00:47:50.842, Speaker A: All right. And we'll copy in the code for that. And basically we have a few types here.
00:47:50.842 - 00:48:04.240, Speaker A: NFT data. So the data for that NFT each of the tickets formatted, we're going to have a ticket collection piece of state. We're going to destructure some state around the wallet and the network ID.
00:48:04.240 - 00:48:26.322, Speaker A: We have a use effect here, again, which again, similar to the other one, we need a provider and a signer because this is going to be making a call into the contract. We've kind of already gone over what these lines of code do. We need a tickets retrieved variable to have basically an array of all of those tickets that have been formatted.
00:48:26.322 - 00:48:45.102, Speaker A: And for when we call into the wallet of owner function inside of the contract, it's going to give us back a set of owned tickets. We're going to map over those and we're going to basically push each one of those into the tickets retrieved variable. We'll wait on that.
00:48:45.102 - 00:49:01.486, Speaker A: And this will run basically anytime address or network ID changes, which means that those tickets will always stay refreshed down there. Then we have list of tickets. So this is going to be actual all of the SVG items.
00:49:01.486 - 00:49:09.880, Speaker A: So if we've minted four tickets, there will be four of these. And these will go right here inside of our grid. So it'll look kind of like this.
00:49:09.880 - 00:49:38.480, Speaker A: And so each one of these items will get rendered inside of this grid, no matter how many we've created. If we're not on the right network, of course the switch network button will come up and we can actually get rid of both of these because they're not needed, right? Only if we want to change those default values of ten or 00:10, text size or margin zero, do we need to add those in. So we can just do that.
00:49:38.480 - 00:49:57.426, Speaker A: And then at this point, we are pretty much done with minting our tickets. Let's just go ahead and make sure that this works. With that page in place, go ahead and close the console out.
00:49:57.426 - 00:50:08.040, Speaker A: And now when we mint the ticket, we should be able to see those pop up at the bottom there. We might be missing one thing. Oh, yes, of course.
00:50:08.040 - 00:50:24.678, Speaker A: We need to go into the index TSX and pull in that tickets owned. Tickets owned. And that will have imported as well up here.
00:50:24.678 - 00:50:28.306, Speaker A: Boom. And now we should be good to go. All right, so here's our tickets.
00:50:28.306 - 00:50:52.314, Speaker A: Let's submit a VIP ticket. That was weird. Oh, you know what? On our tickets page, we did not uncomment that.
00:50:52.314 - 00:51:00.380, Speaker A: Someone was probably yelling that in the workshop. Hey, forgot to uncomment that line. Here we go.
00:51:00.380 - 00:51:06.826, Speaker A: Perfect. Right? So this is exactly how we want it to work. We want them to mint a ticket.
00:51:06.826 - 00:51:17.602, Speaker A: We want them that to show up in the UI as soon as they've done. It gives them a sense that, hey, everything went all right. And of course, if we were to reject that, you would get that error there.
00:51:17.602 - 00:51:25.830, Speaker A: And if you click it, it goes away again. Show that one more time. If anyone wants to create a better error for me and create a pull request, that'd be nice.
00:51:25.830 - 00:51:50.458, Speaker A: That one's kind of hanging off the ticket panel there. All right, so that concludes pretty much the workshop of building a full stack react NextJS DAP with a minting page wallet connection. Using the MetaMask SDK, we can call into our contract and get all the NFTs that we own and display them on the page.
00:51:50.458 - 00:51:56.990, Speaker A: The NFT, although I probably should update the year here. It's a fictitious event. This is a demo.
00:51:56.990 - 00:52:14.050, Speaker A: It's contrived, but it has the date it has whether it's a ga or a VIP ticket. And you can even see the address that it was minted with. So with that being done, let's go ahead and kill both of our terminals.
00:52:14.050 - 00:52:27.554, Speaker A: In fact, let's just go ahead and delete these real quick and get rid of those. We're also going to clear all of these out. And what we want to do now is we want to push these to a test net.
00:52:27.554 - 00:52:55.892, Speaker A: So we're going to do this really quickly here. Let me see if I have stuff already so I don't have to go pull it out. I'm just checking to see if I have all of the might have to go do this myself.
00:52:55.892 - 00:53:18.912, Speaker A: So let's go ahead and pull up my infura account and we will go to the dashboard. We will go to ETH Atlantis, copy this guy, paste that here into our environment variable for Project ID. And we will go into our blockchain folder.
00:53:18.912 - 00:53:32.324, Speaker A: We have an environment variable file here. So if we're going to push to a testnet, we have to have an environment variable also for this project, which we will have that Project ID there as well. Then I need to get my private key from MetaMask.
00:53:32.324 - 00:53:52.012, Speaker A: So I'm going to show you guys how to do this, but I'm going to pull the thing off screen while I grab my private key because even though this is a test wallet, I don't believe in sharing private keys at all. So what I'm going to do is I'm going to click this account one here, and this is the account that I use for all my tests. It's got all my test ETH in it.
00:53:52.012 - 00:54:00.700, Speaker A: If I were to go back to, I guess, ethereum right now, we should probably see some ETH in there. Let's go to Matic. Matic? Mumbai.
00:54:00.700 - 00:54:08.150, Speaker A: All right, so see, I have testmatic that application's not running. That's why it's erroring out. Let's go ahead and kill that for a moment.
00:54:08.150 - 00:54:51.992, Speaker A: And I'm going to go in here and go to this account, and I'm going to go to account details. I'm going to hit export private key. But I'm going to do that off screen, and I'm going to get that account details, export Private key, type in my MetaMask password, copy it, and then I will pull this off screen, paste that in, save, close that page out, pull it back over.
00:54:51.992 - 00:55:07.576, Speaker A: But now I've got all of that updated, and now we can open up our terminal. And what we're going to do is go to this package JSON here, so we can see the commands that we're going to run. So dev testnet.
00:55:07.576 - 00:55:22.544, Speaker A: This is what we'll run once we have built and deployed I'm sorry, deployed our project. So I'm just going to go up here and kill the build folder real quick. You don't necessarily have to do this, but I'm going to go ahead and do that.
00:55:22.544 - 00:56:00.808, Speaker A: And then I want to run a certain command that will deploy our contract here to Mumbai testnet. And before I run this, let's not forget that I need to go into our env and change this to Ox 13881 to indicate that we want to deploy to the Mumbai network. And then we can see the next thing that we'll do is when we deploy this NPM run, deploy Mumbai.
00:56:00.808 - 00:56:13.232, Speaker A: And we're going to use the workspace blockchain that tells it to go into that blockchain folder and get that script, that deploy script which is in there. We'll run that. I can also show you that really quickly.
00:56:13.232 - 00:56:23.716, Speaker A: Here package JSON. So here is that deploy Mumbai script. And we're waiting for that contract address to show up.
00:56:23.716 - 00:56:36.506, Speaker A: We will copy that. There it is. We will put that into our config here.
00:56:36.506 - 00:56:56.106, Speaker A: Nope, here, let's make this a little bit smaller down here. All right, so now we're going to be using Mumbai. And at this point, we can run NPM, run dev testnet.
00:56:56.106 - 00:57:17.020, Speaker A: And this will know that that's the testnet that we want to run on open up our application. And sometimes I get some errors the first time because it was just running on Localhost 3000. So I'm going to disconnect here.
00:57:17.020 - 00:57:39.970, Speaker A: I'm going to make sure that my other account is disconnected. Yeah, this one in fact, I not only want to disconnect it, but I want to go ahead and remove this account for now because I'm not using it anymore. And then I will go back to this account and we will connect wallet.
00:57:39.970 - 00:57:51.590, Speaker A: That one's already selected. Connect. So we're now connected with my test wallet, and we will mint a general admission ticket, confirm.
00:57:51.590 - 00:58:03.780, Speaker A: It's going to take a little bit longer when it's on the testnet to show up down here. Then we'll also mint a VIP ticket. Just make sure that's working.
00:58:03.780 - 00:58:15.700, Speaker A: We'll test the disconnect, we'll switch accounts, all that good stuff. All right, so let's go ahead and disconnect reconnect. Let's change accounts.
00:58:15.700 - 00:58:41.290, Speaker A: We have to do this. Sorry. Let's do this.
00:58:41.290 - 00:58:53.654, Speaker A: Sorry. That's what we have to do. Because we didn't actually do Connect Wallet and connect it.
00:58:53.654 - 00:59:05.510, Speaker A: That was my own fault there. So we'll go back now that we have two of them connected, we can kind of go back and forth between the two, right? That's kind of how it should work. And notice that this is updating.
00:59:05.510 - 00:59:10.970, Speaker A: So that all looks good. That's exactly how it's supposed to work. We'll disconnect it, we'll switch chain.
00:59:10.970 - 00:59:17.360, Speaker A: It's really not going to do anything here. Connect Wallet. We're back to this one.
00:59:17.360 - 00:59:36.834, Speaker A: Yeah, just kind of, again, just making sure that you're just fumbling around in here as much as possible, connecting multiple accounts, switching between them, just to make sure it all works and everything looks fine. We've deployed to a testnet polygon, Mumbai. We've created a on chain SVG tickets application.
00:59:36.834 - 00:59:45.006, Speaker A: Full stack with next JS. And yeah, that's the end of the workshop. If you have any questions, feel free to contact me on Twitter.
00:59:45.006 - 00:59:50.470, Speaker A: Again, my Twitter is http junkie and yeah, reach chat.
