00:00:07.610 - 00:00:33.420, Speaker A: My name is Herman, I'm developer relations at Safe. Today I'm going to be talking about developing on the SafeCore Protocol. So, SafeCore Protocol, does anybody know what it is? Can you raise your hand if you have heard of it? Good there, good there.
00:00:33.420 - 00:00:50.640, Speaker A: Awesome. There are so many questions, many new terms and concepts that were introduced in the SafeCore Protocol in the last couple of months. Now I'm going to try to summarize most of them and you tell me at the end.
00:00:50.640 - 00:01:11.720, Speaker A: So first of all, I will be talking about the Safe Smart account, what it is and how it looks like. Then the SafeCore protocol, the same, but also how it is connected with the account. And also I will be sharing some resources that you may find useful for the hackathon if you are hacking with us.
00:01:11.720 - 00:01:24.090, Speaker A: So let's start with the Safe Smart account. The Safe Smart account is a modular account framework. So it's basically an account with Safe.
00:01:24.090 - 00:01:48.222, Speaker A: It allows many things, execute transactions, sign transactions, et cetera. But here primarily we are going to be sharing how the functionality can be extended via modules. For example, let's say a recovery module that at some points allows to execute a transaction in the Safe that replace the signers.
00:01:48.222 - 00:02:12.250, Speaker A: So if you lose access to the account, you can recover it later. We also have transaction guards. Transaction guards are logic that can be added when the transactions are executed so they are able to parse the transaction, read the destination, the value, the data and some other parameters and act on that.
00:02:12.250 - 00:02:54.600, Speaker A: For example, we could have an allow list guard that has a list of addresses and then if a transaction is executed, this guard would check the destination and if it's not in the list, for example, the transaction would be reverted. And also we have fallback handlers that would allow to add new extra functions to the core contracts. So in case there's a standard introduced that is not natively supported in the account, then you could implement the required functions in this fallback handler, plugging it to the account and then everything would work.
00:02:54.600 - 00:03:23.650, Speaker A: So I guess and hope that we all agree that modular smart accounts will fail without three things interoperability, discovery and security. Interoperability because there is a risk of Pendor locking different teams, working on different tools and creating a fragmented ecosystem. Also, duplicating work on the same things on tools that are not compatible.
00:03:23.650 - 00:03:55.850, Speaker A: Regarding discovery, there's currently no place to find these smart account extensions like the ones we saw before. So there's a lack of distribution and it's difficult for users to see what the market has ready for them. Regarding security, we still need to make sure that the funds of the users are secure and there are no risks.
00:03:55.850 - 00:04:22.334, Speaker A: So in the last couple of months, the team at Safe has been working on the SafeCore Protocol that tries to fix these three topics I just mentioned so let's see what the SafeCore Protocol is. It's still in alpha version, version 0.1. It's ready for hacking so you can use it this weekend.
00:04:22.334 - 00:04:47.894, Speaker A: But it's not production ready yet, so expect changes and things to break. It's also designed to be account agnostic but for now we are focusing on Safe Account version one, point X, just to make the development processes faster and to add some feedback. It's also open source and right now is the best time for you to provide feedback on the protocol.
00:04:47.894 - 00:05:08.222, Speaker A: If you want to give us some ideas, share your paid points, et cetera. Now we are still building on it, so it's the best time for that. So this is what we had for the SafeSmart Account, right? The account in the middle and then different components that are enabled into the account directly.
00:05:08.222 - 00:05:40.086, Speaker A: So the owners of the account need to enable and disable this one by one. What the SafeCore Protocol introduces is a manager. This manager would be another smart account, sorry, another smart contract that will be placed in the middle of the account and all these modules, it will be orchestrating all the flows as well.
00:05:40.086 - 00:05:57.970, Speaker A: This manager, like the Safe Protocol manager, will also have access to some registries. We have an implementation for the Safe protocol manager and a Safe protocol registry. This registry will be owned by maybe a person, maybe a company, maybe a Dao, ideally.
00:05:57.970 - 00:06:27.734, Speaker A: And the owners of registries will be in charge of adding different modules there and setting the requirements for these additions. For example, as an owner of a registry I can say okay, in order to list some modules there, they must be audited and blah, blah, blah, different criteria that they need to meet. And finally we have the modules.
00:06:27.734 - 00:06:48.302, Speaker A: Modules can be of different types and now there will be a relation between these new ones and the ones we saw before that were enabling the account directly. So first of all we have plugins like the Recovery plugin. If you remember there was a recovery module that was connected to the account directly.
00:06:48.302 - 00:07:16.540, Speaker A: And here as a plugin, the functionality of this Recovery plugin would be the same. But plugins need to implement an interface that allows them to work with the manager. So not directly with the account, but they should be listed in a registry and then the manager will check that they are in the registry and they will connect it to the account.
00:07:16.540 - 00:07:26.750, Speaker A: Same happened for hooks. Hooks are very similar to the transaction guards we have. So for example, we can have an allow list hook.
00:07:26.750 - 00:07:46.470, Speaker A: They will also work with the manager and can be added to registries. We also have the function handlers that will work very similarly as the fallback handler that you saw before. We also have Signature Validators and in the future many more kind of modules can exist.
00:07:46.470 - 00:08:20.622, Speaker A: So let's see now, just focusing on a plugin, how to add a plugin to a registry, how to enable a plugin into an account, and how to execute a transaction via a plugin. So let's start with adding the plugin to a registry. We see the four main components here and to add a plugin in the registry, it is the owner of the registry, the one who should call a method add module to the registry and that's it.
00:08:20.622 - 00:08:53.766, Speaker A: It's more bureaucratic for the owner of the plugin because they need to meet the requirements the owner of the registry defines. But technically it's as simple as this once a plugin is added to a registry, we can see how to enable this plugin into an account as a user of an account. So for that, if we have our own account, we need to execute a transaction that calls the manager.
00:08:53.766 - 00:09:28.680, Speaker A: And in this call we are calling the function enable plugin, passing the plugin address we want to enable, and also a boolean variable that is called allow root access. What is root access? Well, we have defined two different levels of access of permission for plugins, for modules, and depending on if a plugin has root access or not, they will be able to execute certain transactions. Let's say a plugin does not have root access.
00:09:28.680 - 00:10:14.530, Speaker A: This means they cannot execute delegate calls and they cannot execute transactions where the destination is the manager or the safe. Why is that? Because if they were able to execute transactions where the destination is the manager or the safe, they would be able from a plugin to add new signers in the account, or remove some signers from the account, and also in the manager, they would be able to add more plugins or remove some plugins. So these kind of actions, we are just restricting them for plugins who have root access, in the future this can be also be more granular, but for now it is like a boolean.
00:10:14.530 - 00:10:51.790, Speaker A: Once we tell the manager that we want to add a plugin with a certain permission, the manager will call the registry that is attached to this manager and will check if the plugin exists there. If that's correct, then the manager will ask the plugin hey, do you require root access or not? And then at the end of this flow, the manager will store in the storage. Okay, this save or this account has enabled this plugin with this kind of permission.
00:10:51.790 - 00:11:06.070, Speaker A: So that's it. Now we just need to know how to execute a transaction from a plugin. So let's see that now the flow starts from the plugin, somebody's calling it a method exec, let's say.
00:11:06.070 - 00:11:27.878, Speaker A: And then the plugin, depending on the permission it has, it will call the manager. One of these two functions execute root access or execute transaction. It's clear which one it is, I think, right? And we need to pass two properties, two parameters save and transaction.
00:11:27.878 - 00:12:02.630, Speaker A: Save is the account the plugin will be called, where this transaction will be executed and the transaction is the transaction itself, but also some metadata that will provide some context of the plugin and the transaction. So now the manager knows what is the account that will be called and what is the transaction that will be executed. But first it will check that the Safe has that plugin enabled and also that the plugin is added to the registry that is attached to the manager.
00:12:02.630 - 00:12:29.786, Speaker A: There are two conditions here in the registry that need to happen. One is that the plugin is added to the registry and the other one is that the plugin is not flagged. And what has been flagged that means that owners can block plugins if there's a vulnerability that is found, for example, the owner of our registry can say okay, from now on this plugin is not usable.
00:12:29.786 - 00:13:02.250, Speaker A: So hackers could not exploit the plugin. This is a big advantage compared to enabling the plugins directly into the accounts because when plugins are connected to the accounts directly, it's the responsibility of each owner of the account to disable the plugin before it is exploited. But here is the owner of the registry who can decide to block everything at once just for this plugin.
00:13:02.250 - 00:13:22.430, Speaker A: So then in this flow where we are executing a transaction from the plugin, it is added to the registry, it is usable, it's not blocked. Then the manager will check again what is the kind of permission the plugin requires. We'll check the storage.
00:13:22.430 - 00:13:54.810, Speaker A: If it is the same, then the manager will finally tell the account to execute the transaction, calling the function exec transaction from module. So for all of these four components we have defined interfaces. So we are offering a main implementation but the protocol works with different implementations of these components as long as the interfaces are implemented.
00:13:54.810 - 00:14:33.414, Speaker A: And here, for example, I will be showing the interfaces for the plugin and the manager that are the most useful for you maybe. So the plugin needs to have like a name, a version, a metadata provider so where to find this metadata structure and then also if it requires root access or not. On the manager side, there are two functions you need to implement so the plugin can call them execute transaction and execute root access to say something.
00:14:33.414 - 00:15:03.070, Speaker A: Execute transaction allows to batch multiple transactions and execute all of them at once, while execute root access just allows to execute one transaction at a time. Also in the manager you can implement more functions that the ones defined in the interface. For example, how to enable plugins, disable plugins, get information from a plugin so you can create the storage.
00:15:03.070 - 00:15:42.080, Speaker A: Now some resources you can check regarding the SafeCore protocol we have two organizations on GitHub the Safeglobal and then five AF, which is more of well, you will find more experimental things there. So in the first repository, the SafeCore protocol, you can find all the interfaces and the contracts we have implemented, like the registry and the manager. Then there are some specs in the second one, some diagrams and flows that are useful to understand how it works.
00:15:42.080 - 00:15:55.266, Speaker A: You can also find a demo, which is a react application that can be used inside our web app. And you can see a registry with multiple plugins. There you can enable disable them.
00:15:55.266 - 00:16:21.942, Speaker A: And also with the metadata you can link URLs to these plugins so you can open their interface and operate with them. So the Safe Ecosystem Foundation has $10,000 up for grabs for hackers participating. And we have split this into five K for hackers.
00:16:21.942 - 00:16:46.254, Speaker A: Five K in total for the three best projects building on top of the SafeCore protocol, integrating or implementing any part of it. And then five K in total for the three best projects working on the Safe Core account abstraction, SDK, integrating at least one of the existing kits we have. You can find us on Twitter at safe.
00:16:46.254 - 00:17:00.322, Speaker A: We have some docs discord forum. So thank you very much. I don't know if we have time for questions, otherwise I'll be around.
00:17:00.322 - 00:17:07.440, Speaker A: You can find us in the booth. Also will be available on the discord for the hackathon. So thank you very much.
