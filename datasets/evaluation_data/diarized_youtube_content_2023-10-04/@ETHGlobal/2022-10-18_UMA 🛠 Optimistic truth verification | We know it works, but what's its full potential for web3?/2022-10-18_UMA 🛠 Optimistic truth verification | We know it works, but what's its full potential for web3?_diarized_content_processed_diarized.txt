00:00:06.250 - 00:00:39.420, Speaker A: All right, I'm going to jump into this, you guys, honestly, feel free to chat and chitchat. We're going to keep this super casual and just I will do a few slides and then go into a demo that will hopefully work live and won't break on me. And we're just going to showcase how we can bring real world events off chain data on chain using Uma's Optimistic Oracle. And again, kind of late at night. So we're going to keep it loose. Anyone have any questions? Just interrupt me. We're just going to have some.
00:00:39.420 - 00:01:11.940, Speaker A: So okay, I bet most of you have been by our booth already. And for people that are either watching the stream or not, I'll keep this quick. So what is, uma we are what we call an Optimistic Oracle. We look at this as a mechanism that can in a truly trustless and decentralized way, provide and verify arbitrary off chain data. So we're trying to ask things about the world. We're trying to ask events that happened. It could be price data.
00:01:11.940 - 00:02:07.842, Speaker A: It could also be event data. Who won a football game? Did this protocol get hacked? What happened on this other chain? Those are all events that we want to record on chain, validate as them being truthful or not, and then let them be used by smart contracts and smart contracts applications. So, yeah, the Optimistic Oracle we look at as this primitive concept in the blockchain space, just a simple way that we can use to validate statements of truth. And to walk you through this at a really high level, how this works. The concepts are pretty simple. We let anyone propose a statement as true so they could say, hey, the jets won the football game last weekend. Someone made a joke because the jets never win, but I don't know anything about football.
00:02:07.842 - 00:02:44.606, Speaker A: So jets won football game last weekend. This is true. Someone proposes that anyone on the network then has the opportunity to dispute it during a challenge window. If there are no disputes, that statement gets taken as truth and it gets written on the blockchain for protocols to use in their applications. If there is a dispute, those disputes get escalated to the Uma token holders for them to resolve. That resolution process uses a really fun crypto economic game that actually vitalik invented back in 2014. And that crypto economic game has a commit period and a reveal period.
00:02:44.606 - 00:03:44.866, Speaker A: And we can prove with game theory that you will get a truthful answer provided no one controls more than half our token supply. So all told, you can really think of the Optimistic Oracle as a method that prevents us from having to do the hard work of asking our token holders what the right answer is. Rather, we are trying to stay in the optimistic path where we say, hey, do you agree with this? And provided people agree we stay in the happy path, very little work needs to be done. Okay, so what goes in opt in Scoricals? We have these requesters that request data, proposers that, propose data and disputers that say, hey, that's not right. We have the dispute resolution process already figured out and we need our voters to ultimately, our, uma, token holders to ultimately understand what the concept of truth here is. And that's the limiting factor. That's the only limiting factor in the types of questions we can ask of this system.
00:03:44.866 - 00:04:22.926, Speaker A: As long as a reasonable group of human beings can decide what an answer is, whether this thing happened or not, we're set. And then all of on our side. What we've spent a lot of time energy doing is inserting economic guarantees around how secure this protocol is. How much value can it secure, and at what point could this thing be attacked. Okay, so these Oracles can answer many, many types of questions. Polymarket is a prediction market that's a heavy user of our Oracle. They use it to ask all sorts of real world questions.
00:04:22.926 - 00:05:39.900, Speaker A: Some of them are related to sports, some of them are related to elections, some are related to COVID data, anything of that sort of sort. Sherlock is an insurance protocol that uses our optimistic Oracle to ask effectively the question, was this protocol hacked across? Is a cross chain bridge that uses the optimistic Oracle to validate actions that happened on other chains because essentially other chains data is like off chain data to the destination chain. Then we've used this protocol to create a variety of synthetic tokens or fundraising products, things we call success tokens or KPI options. These are ERC, 20 tokens that resolve to a payout based on what the opt in Scorical reports. So we've got a couple of slides in here that I'm going to skip over and we can come back to at the end of using events in your contract to trigger Oracles. We'll come back if there's interest in those. And I'm going to keep jumping ahead until we kind of get to our demo and then start to get into questions that you all may have.
00:05:39.900 - 00:06:34.060, Speaker A: This I will focus on because I think it's useful. A common design pattern we've seen used by our optimistic Oracle is making assertions. And this is no different than asking a question and answering it yourself all at the same time. But we've seen it to be a really useful pattern when developers are actually building on this optimist Oracle. So essentially you're going to say, hey, I assert this to be true, and then you use the optimist Oracle to verify it, provided no one disputes that that statement, I think this is true, gets taken as fact. Yeah. So this assertion pattern and I'll show you guys a little bit of code snippets here and then we're going to go into a real demo and just ask questions and we'll have fun.
00:06:34.060 - 00:07:01.282, Speaker A: This function that I think can be quite useful in many of the hacks happening this weekend. I want to make an assertion in a trustless or decentralized way. And so I'm going to request here price. I'll just level with you guys. We use the word price in here because we used to be focused on price data. The Oracle is now much more than that. This should really be request data, but it's an artifact of our older code base.
00:07:01.282 - 00:07:29.370, Speaker A: So we want to request data. We're going to set a custom liveness period. This is the length of the challenge period. And we're also going to propose an answer to the same question we asked. And effectively, we're making an assertion here that if nobody disputes it within that given liveness period, it will get taken as truth. And so this is something we can use to assert, hey, this action happened on this other chain. Hey, this contract was fulfilled.
00:07:29.370 - 00:08:29.118, Speaker A: If we go back to this concept of real world data, this event happened in the real world. I'm asserting that to be true and I've decentralized it because anybody can disagree with me. But provided there's no disagreement, we're all good. I can use that as statement or assertion to do interesting and useful things. Any actually questions on that? So the way that I prefer this depends on your use case, and sorry, the question was, what happens if you do dispute it? How do you unwind this assertion you made? And there's a few ways to approach this depending on your use case. The most common pattern we've seen is that as soon as an assertion is disputed, you basically throw that out. So the application that's inserted this will just say, okay, that assertion is not true.
00:08:29.118 - 00:08:58.106, Speaker A: If you want to do it again, go ahead and make that assertion again. And the person would have to dispute it a second time. So in that way and there's edge cases you can talk about, about what if you had a whole bunch of disputes and you kind of spam things that way. We can talk about that offline because I think we have reasonable solutions to that. But generally speaking, the simplest pattern is, I'm going to assert this to be true. If somebody wants to dispute it, fine. We'll still use the, UMO, token holders to see who's right.
00:08:58.106 - 00:09:18.880, Speaker A: The person that proposed it or the disputer will use that and those will kind of go to war and they'll earn each other's bonds in that. But we won't block the protocol or the application from doing useful things. Does that make sense? All right. Yeah.
00:09:22.950 - 00:09:24.370, Speaker B: In this scenario.
00:09:28.070 - 00:09:59.894, Speaker A: So there is still a bond. You'll see, there's a bond currency here too. The idea in this assertion is I think there's many use cases where you are here's. One mental model. I was talking to a guy who's thinking about like, a fantasy football game here too. He wants to build like, a decentralized fantasy football game. And I was telling him if he was doing this in a centralized way, this guy and I'm blanking on his name would just he himself would say, here are the scores.
00:09:59.894 - 00:10:17.570, Speaker A: Here are the scores. Here are the scores. Right? What you can do here is you can decentralize that process by instead asserting, here are the scores. Like, I'm the guy doing this work. Here's the answer. But anyone can tell me I'm wrong, and I don't need a reward. I don't need to reward myself for doing this.
00:10:17.570 - 00:10:54.362, Speaker A: Like, I want to be providing the service, but I've decentralized it by opening up this pathway where somebody can say, hey, you're lying. You're cheating. That's not right. Does that kind of make sense if you did incorrectly? So as a proposer, if I'm making this assertion, I post a bond. If someone disputes me and it turns out that they were right, yes, I lose my bond, right? But if I was right, I actually earned the disputer's bond, so I double my money. Makes sense. Cool.
00:10:54.362 - 00:11:15.490, Speaker A: I like this. This question is good. So we're going to keep going here. All right. You can use the Options Oracle to ask questions about past events, subscribe to updates about future events. This is a very cool way to actually frame it. I want to use the Options Oracle to tell me if this protocol ever gets hacked or to tell me if this action ever happens.
00:11:15.490 - 00:11:57.602, Speaker A: And then I want my smart contract to do something else. Trigger callback functions when an event happens, make an assertion about the state of the know, this sort of stuff. And this wasn't my presentation that I put together, but John added this picture of Field of Green at the end, and I quite like it. So here you guys go. Okay, I'm going to do a demo right now, but we are hiring QR code for our jobs page. I always got to put the we're hiring thing out there because it's a hackathon with brilliant minds, and we want to hire you. So let's go into the fun stuff where we're going to just do a little demo and walk through this code.
00:11:57.602 - 00:12:38.474, Speaker A: None of this is particularly fancy, and it's all pretty well documented, but sometimes it's fun to just see people click buttons and maybe see me mess up. Hopefully not. But if you guys go to Docs, umaproject.org, the first page will be like, go to our Getting Started section. And we have here what we call our minimal viable, optimistic Oracle integration. And what we're going to do here is ask the question, did the temperature in New York City on July 25 exceed 90 degrees Fahrenheit? An American wrote this tutorial. I would use centigrade.
00:12:38.474 - 00:13:18.170, Speaker A: It's okay, but you guys just weather. So we are going to go ahead and jump into remix here, and I'm doing this all live. So what do we have here? See if I can make this a bit bigger. We have a very simple contract that is creating an instance of the Optimistic Oracle interface. By the way, guys, I am technical in the sense that I studied computer science, but I haven't written code in a decade, so I'm doing this. It's not that hard. This is like doable.
00:13:18.170 - 00:13:55.560, Speaker A: We are asking what we call a yes or no question, and we're inserting the question here of what's the temperature did. The temperature oh, this one's in centigrade. Now, that's funny. Okay? Not in fahrenheit. Is it above 35 degrees Celsius? We are setting some parameters of the system, including setting a reward in this case to zero, which we could change and we make a price request. We're also setting the liveness period here to 30 seconds. This is for demo purposes so that we don't have to sit here waiting for a liveness period to tick by.
00:13:55.560 - 00:14:35.526, Speaker A: And then we've got our other functions to settle this. So what do I need to do? I need to compile this, and then I need to go select MetaMask, make sure I'm on girly, which I am. Also. Folks, it's quite difficult getting girly ETH right now. I just looked at trying to I don't know if anyone else has seen it's, like, kind of hilarious. We do have some girly ETH that if you ask very nicely, we might be able to send it to people because it's a very difficult thing to get. So I got this.
00:14:35.526 - 00:15:07.200, Speaker A: I should be doing my transactions while I'm chatting. We are going to deploy this. Great. And this will take a second for it to deploy. And, yeah, I shall tell you that you should. In our discord, if anyone needs girly ETH, just ping us and we'll try our best to send you something. Ping us with an address you don't mind getting doxxed on because it is a public channel.
00:15:07.200 - 00:15:32.518, Speaker A: All right, so that was successful. Cool. Deployed contracts. So I have deployed this Oo contract. I followed the instructions here by memory, but they're pretty simple. And they just did what I talked about to actually deploy this Optimistic Oracle contract. And now what we're going to do is we're going to actually propose this question.
00:15:32.518 - 00:16:30.922, Speaker A: Now that the contract is deployed, we're going to go and actually call this request Data function. And if we go back and we look at this, what is Request Data doing? This is the one that's actually making the requesting the price, requesting the data with those custom liveness period of 30 seconds. So this transaction is taking a second to mine. And when it does mine, what we are going to then do is go into our interface. This is a front end interface we have where yeah, we're able to see the question we just asked. Okay, and here is where connect my wallet. Here is where anyone can propose an answer.
00:16:30.922 - 00:17:06.840, Speaker A: I'm going to propose zero here. Doesn't really matter what the testing purposes is, I'm going to propose this. So this is someone is saying no, the temperature wasn't above 35 degrees on this date. This could be anyone. Or if you're using the assertion pattern I was talking about earlier, you could propose this yourself when you are asking the question. So this goes in and you see we've got I don't know if you guys can see this. We've got this countdown window of the time left in which people could challenge this assertion or challenge this fact that someone's saying no here.
00:17:06.840 - 00:17:34.670, Speaker A: And we are going to let that tick down. I'm not going to demonstrate, like, the dispute case right now. We let that tick down and we're done. So now if I'm doing this right, I can go back and actually settle the transaction, which is going to now confirm that. Hey, okay. Yeah, go ahead.
00:17:34.820 - 00:17:49.220, Speaker C: Yeah, I guess protocol do for like four questions. Somebody said, what color my pants? And then do voters say.
00:17:52.630 - 00:18:42.020, Speaker A: Yeah, that is a very good question. So the question is, what do people do if the question is poorly worded? And what we do if we look back here, we have this what we call our Identifier, which we call yes or no query. And this corresponds to effectively a rule set we've written off chain that everybody agrees to follow. And in that rule set, we try to have rules for the circumstance you're talking about. Like, what do we do if it's a shitty question? And generally speaking, that the rule set should specify that it's like, okay, if it's a bad question, just always respond no would be one answer. If it's a bad question, respond 0.5. Like between one and zero, respond something where you kind of split the answer.
00:18:42.020 - 00:19:37.570, Speaker A: We have that kind of agreement there, too. And in that case, again, if the consensus is that this is a badly worded question, that would be the response, and the DAP that's implementing it, or the protocol that's implementing the Optimist Oracle should handle that use case. Does that make sense? So let's see. So now if I call get settled. Did that work, Chris, or did I do something wrong? Yeah, hold on, I gotta why am I getting all this stuff? Yeah, this is my debt data that says zero right here. So my decoded output, I got back my response. So it worked.
00:19:37.570 - 00:19:58.170, Speaker A: We got our answer. Simple lifecycle, pretty simple demo. We're not doing anything rocket science here. We're asking a question. There's a challenge period. We've got an interface where people can respond to it. This interface, this whole thing here, where we have this response period.
00:19:58.170 - 00:20:28.766, Speaker A: You could imagine this being done by bots or some automated process off chain. This is still like an interface where people could manually dispute things if they're like. That's not right. And so there's a lot of flexibility. It's a very generalized or flexible system to let us accomplish those things. All right, so I went through this, settling the final answer and that's it. In our tutorial.
00:20:28.766 - 00:21:48.640, Speaker A: At the bottom we have some more advanced examples that go into doing more things. But for the most part, this remix package gives you the basic building blocks of what you need to do to actually use the optimum scorical to get a piece of data and to kind of ask this generalized question in terms of other resources. First of all, anyone hacking this weekend, please do use our Discord Channel to ping us and ask us questions. We're going to be up at our booth a lot, but the Discord Channel is just good for us to answer quick and dirty things in case we're like back in our hotel rooms or something like that. There is also a very useful video that I'm not going to play right now because it's going to play ads, which we don't want. But there's an awesome video of John on our team walking through this tutorial think. And then if we go back into our Discord Channel, this is maybe a little bit small, but lots of links and resources to our doc site, our website, some ideas of things we can build with the optimistic Oracle and a blog post with, again, more ideas of hacks we're interested in.
00:21:48.640 - 00:22:06.226, Speaker A: And with that I think I might just spend next four minutes answering any questions anybody might have. Yeah, okay.
00:22:06.328 - 00:22:12.770, Speaker B: And they're using 1271, which is a new ERC built a smart contract validate that a signature.
00:22:14.570 - 00:22:15.030, Speaker A: Okay.
00:22:15.100 - 00:22:46.080, Speaker B: So they're going to use that to create orders and more sophisticated logic to buy sell orders. And then browse your example. If I wanted to do a buy order based on the jets winning because that's a positive sign for jets token or whatever, could I use the move of Oracle in that instance? Because maybe that's where I was asking earlier about timing of request because I want to submit a buy order and it's going into their buy sell.
00:22:47.510 - 00:23:40.258, Speaker A: So I think there's actually like a whole suite of interesting call it like trade automation tools you could build here where I could imagine you basically have a trading strategy. Like if this, then that in a trading strategy and you want that to be executed. It's based on real world data, but you want that to be executed on chain. And something like the optuscore call could be very effective at actually doing that. You could just have those orders be automatically submitted and have other people dispute them if they're fraudulent or not following the rule set. The trade off is that unless we do sort of some fancy things, you'd have to wait this challenge period here too. And I think in some use cases that might be okay.
00:23:40.258 - 00:24:08.380, Speaker A: If you want to rebalance your portfolio based on events and it's not super high frequency time sensitive, that's probably okay. If when my portfolio gets I want to keep my portfolio 60 40 balanced between ETH and WBTC or something like that. And when it gets out of Whack, I rebalance it. Then something like that could work really well. If it's something that's super time sensitive, the challenge period does matter or does have an effect.
00:24:10.510 - 00:24:13.290, Speaker C: Yeah, I wanted to know, so who are the voters?
00:24:15.170 - 00:24:59.420, Speaker A: So I should be really specific, really precise with the language. So the people proposing answers and the actors, the entities that are proposing answers and the actors that are disputing answers, those people are either bots or humans, depending on the context. So across this crosschain bridge, we use has a bot that proposes repayments to relayers, and then there's a dispute or bot that disputes that if it's incorrect, Polymarket that uses us for all sorts of prediction market stuff. It's actually all done by people. People propose an answer and people dispute it if they think it's incorrect. And so it really depends on the use case here.
00:25:00.910 - 00:25:16.960, Speaker C: I saw that you were putting up some examples of questions. With indefinite time period, will this protocol be taxed? So what happens if I say, will uniswap be hacked and then doesn't happen for five years? What happens?
00:25:23.430 - 00:26:26.150, Speaker A: The idea would be there's different ways of architecting this, right? You could design your protocol that says anyone can make an assertion, so there isn't actually an outstanding optimist oracle request. But if a protocol gets hacked, I can assert uniswap got hacked at that point in time, and then, and only then, it's like a fresh request, if that makes sense. So there's different ways you could architect this, depending on exactly what you're trying to get around, but you shouldn't just have. Seems like bad architecture, in my opinion. Yeah. All right, guys, we are perfectly on time, which doesn't mean we have to end here. But if anyone has any other questions, hit me up, get me now, or discord on Twitter.
00:26:26.150 - 00:26:48.490, Speaker A: Right, we should have not wrong thing, but we're on Twitter at Uma Project. You can find me on Twitter at hal 2001 and discord in our sponsor, Uma channel is the best way to get in touch of us right now. And happy hacking. Bye.
