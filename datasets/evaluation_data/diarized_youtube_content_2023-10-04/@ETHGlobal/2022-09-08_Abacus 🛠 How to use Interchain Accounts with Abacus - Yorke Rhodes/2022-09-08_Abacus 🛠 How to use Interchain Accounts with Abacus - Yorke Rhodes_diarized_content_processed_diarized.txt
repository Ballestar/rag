00:00:06.410 - 00:00:21.790, Speaker A: Welcome everybody. We have York here from Abacus who will give you a workshop on how to use Interchange Accounts. And if you have any questions in the meantime, feel free to pop them in the chat and we can take them towards the end.
00:00:21.790 - 00:00:24.590, Speaker A: York, I'll let you take the stage.
00:00:25.770 - 00:00:31.010, Speaker B: Cool, yeah. Thanks so much. Welcome everyone to the Abacus workshop.
00:00:31.010 - 00:00:59.760, Speaker B: We're currently going through a rebrand right now to Hyperlane, so apologies for any future confusion there, but yeah, I'm excited to jump into it. Interchange Accounts is kind of a new, I guess, revelation and innovation that we are just about to deploy to Mainnet and I kind of wanted to give you guys a sneak peek at what's going to be possible. So yeah, let's dive in.
00:00:59.760 - 00:01:43.280, Speaker B: So, just as a quick overview, hyperlane is a developer platform that enables developers to build interchain applications. So specifically there's a smart contract API that lets you send messages between blockchains and we're specifically optimizing for low latency applications that require kind of high guarantees on distributed security. So this is kind of like where we might be different from some of the other interchange messaging platforms that you may have heard of.
00:01:43.280 - 00:02:43.182, Speaker B: So why should you care about these types of tools? In general? There's kind of a lot of different dimensions of the motivation for why we're building hyperlane, but generally the choice of blockchain that developer has to make when they're first kind of just bootstrapping their application and just kind of like trying to get PMF. There's all these unforeseen consequences of which blockchain they choose to deploy to which may kind of play out on a longer time horizon. And so they end up getting a few different consequences of this decision that really is not always made with recognition of the consequences.
00:02:43.182 - 00:03:13.610, Speaker B: So one example is the developer experience. Different blockchain ecosystems have different degrees of tooling maturity and block explorers Indexing services, basically any sort of tool that you would want node providers. As a developer, these might be kind of to varying degrees of sufficiency on different blockchains.
00:03:13.610 - 00:03:47.154, Speaker B: You also have to think about the impact on your user experience when you're picking a specific blockchain. Different blockchains tend to be designed for different user demographics and there are different degrees of accessibility on different chains. So some chains might have social login support, whereas some might require you to have some esoteric curve supported on your wallet.
00:03:47.154 - 00:04:31.810, Speaker B: Or maybe you have to run a node yourself as a user to even participate and use applications that are deployed on that blockchain. There's also what we call platform risk, which is basically the inability for application developers to, I guess, isolate themselves from basically the decision makers at the blockchain layer. So if the community around a specific blockchain decides to do some controversial fork that the application isn't necessarily aligned with, there's really no recourse.
00:04:31.810 - 00:05:18.340, Speaker B: And security of the application is really beholden to the underlying platform and then finally the actual kind of long tail value of applications that are deployed to a single blockchain are limited by the network effects which exist within that blockchain. And so if there's some new synergistic application which maybe your users and your application would benefit from being composable with on another blockchain, you can't actually tap into that and grow your network. You're kind of limited by whatever local network effects are available.
00:05:18.340 - 00:06:14.450, Speaker B: And so recently we've seen a lot of application developers deciding to go cross chain and this is an attempt to solve some of this problem of the aforementioned consequences of being in being deployed on a single chain. But the way this happens kind of operationally today is uniswap dao votes where they want to deploy a new application to reach a certain user demographic. But these new deployments exist as kind of individual islands of state and so this actually doesn't solve the network effects that are limited by a single chain context kind of directly.
00:06:14.450 - 00:06:50.590, Speaker B: It does allow a brand and an application to exist on multiple blockchains, kind of for brand recognition and marketing purposes. But the actual utility derived from each one of those application deployments is not composable between each other. And so users on the ethereum deployment of uniswap are not benefiting from the network effects of users on other you know, these are the types of problems that we're hoping to address with Hyperlane.
00:06:50.590 - 00:07:25.018, Speaker B: So Hyperlane is a network that exists between blockchains rather than being a new blockchain. We're not trying to make the decision harder and we're actually trying to eliminate this choice for developers of which blockchain they want to have fealty to. You can kind of think of it as like having blockchain agnosticism as an application developer and we do this while still allowing you to only write your contracts once.
00:07:25.018 - 00:07:56.754, Speaker B: And you can choose kind of however you decide strategically to expand which chains you want to be on, there's no consequences of the initial set of chains that you decide to deploy to. Hyperlain is this protocol, this connective tissue that exists between contracts on different chains. And you can have your application basically communicate with itself across different chains.
00:07:56.754 - 00:08:54.790, Speaker B: You could have your application interact with remote applications. That's what we're going to be focused on today with this concept of interchange accounts, basically allowing your application to have this sort of like sovereign composability with applications that exist on remote blockchains and you can meet users where they are. So rather than asking users to come and come to your chain where you deployed or maybe have to do some complicated process of bridging tokens and understanding a new wallet experience, et cetera, you can bring the familiar experience of a single chain application to your users and to your developers while making it accessible to all of these different blockchain demographics.
00:08:54.790 - 00:09:29.540, Speaker B: And like I said, you reduce this platform risk of depending on a single chain or a single chain's, kind of like long term vision for where they want to go and what types of apps they want to support. So, as a quick overview of what we're going to discuss today, I'm going to introduce the Messaging API, which is this on chain API that is currently live on, I think eight EVM main net chains. So you guys can go and use that today.
00:09:29.540 - 00:09:51.942, Speaker B: And then we're going to hop into this concept of interchange accounts, which I'm super excited about. And then some examples of how to leverage interchange. The Messaging API of hyperlane super simple, there's two endpoints.
00:09:51.942 - 00:10:16.894, Speaker B: You can send messages to other chains by calling the dispatch function on our Outbox Smart contract. So the analogy we use here is kind of like sending messages in the mail. You put an envelope in a mailbox and someone has to take it out at the destination.
00:10:16.894 - 00:10:44.730, Speaker B: And so we have this concept of the outbox where you can dispatch mail and then we have an inbox where recipients can kind of like handle inbound mail. So for sending messages, you use this dispatch endpoint on our Outbox Smart contract. All the addresses that are kind of implicit in this presentation can be seen on our docs.
00:10:44.730 - 00:11:33.190, Speaker B: But yeah, you have to specify basically the destination chain that you want the mail to go to, the recipient address of the contract on that chain that you want to receive your message and then the message content itself. And so really there's nothing prescriptive here about what types of data you can pass in the message content. However, the recipient address that you're dispatching mail to must actually implement a specific interface and have this kind of compliant API.
00:11:33.190 - 00:12:18.330, Speaker B: So when you're receiving a smart contract that wants to receive messages through this messaging API must implement this interface imessage recipient and have this handle function which basically gets called by the inbox contract when mail is kind of received from the hyperlane network. And the interface for this function is defined as the origin chain where the message came from, the sender address that dispatched this mail on the origin chain. So in this case, the sender would be whatever message sender is calling outbox dispatch.
00:12:18.330 - 00:12:50.580, Speaker B: And then again, this kind of like arbitrary message content. And so with this system, this simple kind of channel based communication protocol where you can send and receive messages between any two hyperlain chains, you can create application interchange applications. And so that's ultimately what we're trying to allow you to do here.
00:12:50.580 - 00:13:27.034, Speaker B: It is worth noting that with this API you must have contracts on both sides of the communication. So both sending and receiving sides that are aware of the hyperlane API. And in this case, on the receiving side, what you need is you need a contract which implements this specific handle.
00:13:27.034 - 00:14:16.190, Speaker B: Abi. We developed this thing called the router pattern which kind of allows you to write a symmetric, basically like inherit from an abstraction called the router contract, that allows you to basically write these symmetric applications where there's no distinction between the logic on any chain but that these routers will accept or basically send and receive messages between each other. And you deploy a single router on all of the chains and then you can leverage these channels, all of the pairwise channels between all of the chains.
00:14:16.190 - 00:14:53.290, Speaker B: And I think so far we've been leveraging this router pattern internally, but it's fairly complicated, so I don't want to dive into it right now. But kind of the high level analogy is it's called a router because in traditional networking you have this concept of like routing tables and routing policies that routers use to forward internet traffic. They use some understanding of the network topology to route messages to certain API IP addresses on the Internet.
00:14:53.290 - 00:15:29.270, Speaker B: And this is the same concept of the hyperlane routers. You can route messages to certain contracts on remote chains based on an understanding of the network topology and the application topology. So an application can exist across N chains and depending on the user intent or the action that the user is performing, you can actually route them to specific chains depending on kind of like whatever routing policy you define.
00:15:29.270 - 00:16:39.018, Speaker B: One example of, I guess a use case of this that I'm excited about is like this concept of a gas price or basically like gas minimization routing policy that allows you as an application developer to route computation that needs to happen in your smart contracts to whatever the cheapest chain is at the current block height. And so this theoretically would allow you to provide a better user experience for your users because you could optimize for fees while not requiring your users to actually move their keys or their assets to different chains. All of this can be exposed from a single chain interface and have kind of these messages that are passed between chains unbeknownst to the so anyway, that kind of sums up the Messaging API piece I wanted to cover.
00:16:39.018 - 00:17:31.754, Speaker B: This is kind of the core primitive of interfacing with hyperlane, but today I wanted to talk about interchange accounts which kind of actually eliminate the need for you as an application developer to deploy contracts, or rather for contracts to be hyperlane aware on both the sending and receiving side. So, like I mentioned before, this Messaging API doesn't define what data you can pass or how it's structured, it's just raw bytes. And so you can kind of have whatever messaging coding you would like to see if you want to implement kind of application specific features.
00:17:31.754 - 00:18:04.390, Speaker B: On top of this API, this Messaging API, you need to write specific messaging codings for those application specific actions interactions. So you would need to have some way to encode a token transfer or a swap or someone staking on a remote chain, et cetera. So these are all kind of like application specific implementation, I guess, consumers of the API that you would need to implement.
00:18:04.390 - 00:18:44.740, Speaker B: And so this concept of interchange accounts subverts this idea of application specific encoding and receiving by just leveraging the existing API encoding in the EVM. And at a high level, this concept allows smart contracts, like I said, to control accounts on other blockchains in a way that minimizes security. So the two features of this system are being able to deterministically create an interchange account.
00:18:44.740 - 00:20:03.870, Speaker B: So what this means is a contract on chain A can deterministically create an account on chain B and users or contracts on chain A and chain B can have kind of predictable knowledge of where the contract on chain A's inner chain account would be or what address it is basically to kind of use in application logic. Right? So if you want to if you want to have logic which says, I want to allow this remote contract to have this permission, whether it's an owner or a Minter or some concept like that, you need to know where that interchange account will exist. So this is this idea of deterministically creating an account and then subsequently allowing the controlling account on the source chain to relay a transaction to the interchange account that gets submitted and executed on the target blockchain atomically.
00:20:03.870 - 00:21:11.490, Speaker B: So the kind of main difference between this API that we're working on right now, we're working on deploying, probably will be done in the next week or so, is that you don't have to deploy receiving contracts on every chain. And this is, I think, a much simpler and much lower lift way for us to kind of get backwards compatibility with existing smart contract systems. Because using just the specific abi encoding that exists in the EVM everywhere on all these different chains, you can use this interchange account API to dispatch a call to a recipient contract that doesn't need to be aware of the hyperlane API or messaging API.
00:21:11.490 - 00:21:49.600, Speaker B: And we'll just treat this interchange account that gets created on the destination chain like any other address, like any other local contract or any other local EOA. And this is possible through basically some create to magic. I don't want to get too much into the implementation details because I don't have much time, but yeah, we're kind of like encouraging people in this hackathon to try and use this new API again.
00:21:49.600 - 00:22:14.950, Speaker B: We're still in the process of deploying it on main net. I think we already have kind of some pieces that you can start with if you just want to test locally. But yeah, we'd basically love to see participants of the hackathon use this new API because we think it might be easier.
00:22:14.950 - 00:23:08.150, Speaker B: So, yeah, I wanted to quickly go over an example of how we think interchange accounts could be useful. So, like I said, I guess we have the hypothesis that the interchange accounts will give us improved backwards compatibility with existing contracts and the reason for that is, like we said, receiving contracts don't need to be hyperlane aware. So what that means is a hyperlane aware contract can use interchain accounts to communicate with any contract on any blockchain without that contract knowing that the communication is coming from a remote blockchain.
00:23:08.150 - 00:23:27.086, Speaker B: And I think this is pretty powerful. So in the example of cross chain governance, you could imagine, I assume a lot of you guys are probably familiar with Dows and how Dow governance works. Basically.
00:23:27.086 - 00:24:23.438, Speaker B: Like, to summarize, there is, I guess most Dows use token voting to basically decide on what transactions a Dow contract should execute if the vote reaches a sufficient quorum of voters. And today these calls are limited to the local blockchains where that Dao is deployed. And so if the Dao wants to perform cross chain actions, they need to basically oracleize some mechanism for relaying the contents of a decision that was made by a Dao to other chains.
00:24:23.438 - 00:25:42.890, Speaker B: And this is actually how I think Ave governance works. Now, for example, there's, like, this Oracle system, which isn't really, I think, in my opinion, not aligned with some of the rest of the ethos of the Ave project, but they could instead use a system like this to relay decisions by just passing the calls from the Governance proposal as these cross chain calls through an interchange account. So the Dow could basically have an interchange account on all of these remote chains and any child contracts or subdaos or whatever consumers of, let's say, the Ave Dao can now just transfer ownership to these Dao interchain accounts and basically give power to this remote Dow over all of the owner authorized actions on their contract.
00:25:42.890 - 00:26:15.610, Speaker B: And so we can now create these sort of like cross chain permissions and authorization relationships in a way which doesn't need to be application specific. So that's pretty cool. I think we're running up on time, so I will kind of just leave some time for questions and then maybe we can talk a little bit further about additional ideas for the hackathon.
00:26:15.610 - 00:26:32.650, Speaker B: If there's yeah, if I don't know if there was anything in the chat. Looks like there was one. What are the ICA function? Yeah, so like I said, we're still actively working on deploying this.
00:26:32.650 - 00:26:55.620, Speaker B: So I guess the interface is still slightly in flux. But let me pull up the code for you just to kind of illustrate. Cool.
00:26:55.620 - 00:27:54.174, Speaker B: So, yeah, basically the functions on the interchain account contract will be this ability to dispatch API encoded calls, which is, I guess these things to a recipient contract. So concretely, if you wanted to, let's say, perform a uniswap V three swap on a remote chain, the recipient address would be that pool contract. And then the data that you pass would be the Abi encoded call that you have to make to that contract.
00:27:54.174 - 00:28:03.238, Speaker B: And then the hyperlane interchange accounts. Yeah, exactly like a multi call. That's exactly right.
00:28:03.238 - 00:28:24.030, Speaker B: So I think we've basically just prototyped this through so far, but yeah, that's exactly right. You'll basically have like a multi call interface that you can just pass API encoded calls. Also like I said, there's kind of deterministic.
00:28:24.030 - 00:29:01.354, Speaker B: I wish I had a more stable interface for you but I don't want basically everything. All this code you're looking at right now treat with a grain of salt. But yeah, you'll be able to basically compute the address of an interchange account for a contract that exists on a remote chain even before they've necessarily made a transaction through their interchange account, which is pretty cool.
00:29:01.354 - 00:29:27.890, Speaker B: And that's possible through create two. So basically the create two address of these interchain accounts is salted by the origin chain and the sender on that chain. So each kind of chain and contract has interchain accounts, consistent interchain account addresses across all of the remote chains.
00:29:27.890 - 00:29:53.820, Speaker B: And you can imagine even creating a cross chain wallet that leverages this. If you wanted to kind of route user actions through a single smart contract you could have like natively cross chain account abstraction, that sort of thing. But yeah, great questions.
00:29:53.820 - 00:30:13.834, Speaker B: If there's not anything more, I think I have to seed the floor. But yeah, thank you guys so much for the time and would love for you to hop into our Discord. We're also hiring if you are looking for a job shameless plug.
00:30:13.834 - 00:30:25.800, Speaker B: And yeah, reach out an email if you have any further questions. Like I said, the docs are docs useaptist network and you should have all the there.
00:30:29.690 - 00:30:38.182, Speaker A: Great session. Yeah, feel free to follow up over Discord. It's sponsor Abacus and you'll find yours there.
00:30:38.182 - 00:30:40.450, Speaker A: Thanks a lot everyone. Bye.
