00:00:07.610 - 00:00:22.670, Speaker A: Hi everyone. My name is Nick. So I'm going to start. I am a backend team that one inch. So today I want to talk about our latest innovation. It's a one inch fusion. Maybe you are familiar with Uniswap X right now.
00:00:22.670 - 00:00:47.626, Speaker A: So we had it before it was mainstream. And let's start with some small introduction. Vanish actually is one of the leading projects on the market. Vanish was started at Ethereum, New York at the same hackathon as we have right now, almost from Ethereum global team at 2019 by two members. Right now we have several protocols and we have about 2.8 million users. Actually a bit more right now.
00:00:47.626 - 00:01:18.254, Speaker A: It's about 3 million users. We have billions of volume going through us. We are leading Dex aggregator and not only lead Dex aggregator, we have multiple other protocols. We have aggregation protocol, limit order protocol, one inch fusion protocol, and also we recently released one each developer portal for the developers to make it easier to use APIs with no limits and more adjustable limits for them as well. And also we do have a non custodial wallet on iOS and Android. So let's recap. What is vanish.
00:01:18.254 - 00:02:05.646, Speaker A: Aggregation protocol is basically one inch. Aggregation protocol allows you to have uniswap like experience, but with a bit better rate. Because we are trying to aggregate liquidity across multiple DEXes, not only uniswap but across DEXes like curve, balancer and about 70 more. Basically every time you're trying to make a swap, we are trying to split your initial token, source token, like oneish for example, in this example, to some small sub paths and actually trying to actually try to pick the best payer token, connector token. So let's imagine that we have a one inch token and you need to go to get some die token in the end. But we're trying to build the path across wrapped bitcoin or like wrapped Ethereum for example, USDC. And only after that we go to the Dai.
00:02:05.646 - 00:02:39.694, Speaker A: And the logic of that is because we want to minimize the slippage, we are trying to aggregate all the pools rates across multiple DEXes and find a way where the rate is a bit better. So it's the best strategy if you want to get lower slippage on the market. We have about 220,000,000 volumes during the day. Actually, all the analytics about aggregation protocol and all our protocols is open source. You can check this out on June analytics, one inch basic one inch. Basically, yeah, it's quite transparent. Here we have a little smaller volume, but I made this screenshot like at 06:00 A.m.,
00:02:39.694 - 00:03:04.310, Speaker A: so it's a bit smaller. How varnish protocol, aggregation protocol works basically is as a developer it's quite easy to integrate that. Basically you need to fill some data. It's actually for source token, destination token and the source amount of this token. We have an API for that. Actually. It's a backend algorithm that calculates the best path, but it's executed on noncustodial smart contract basically.
00:03:04.310 - 00:03:42.210, Speaker A: So it's also verified and audited by about seven companies. First you need to make a quote. Basically you're trying to understand what will be the return amount from source token to destination token. If you are okay with this return amount, you basically call another API handle called swap and it will return to you the call data that you need to execute with on chain transaction to the one inch aggregation router. This is quite simple and that's how you can integrate vanish aggregation protocol. Okay, actually you could also try right now aggregation protocol on developer portal with no limits. It will be pretty adjustable.
00:03:42.210 - 00:04:13.726, Speaker A: It's our latest innovation, so latest API, aggregation like latest API for developers. So check this out please. We also have Bounges for that today. Okay, we talked about aggregation protocol. I can say that it's one of the best way to sell something on the market price. If you'll try to compare something to the Dex, to the success like binance, it's like market sell for any token. So it's just one automatic transaction with the best potential path, but it's only market sell.
00:04:13.726 - 00:04:57.818, Speaker A: But what about limit orders? When you want to specify some target price for any token and you just want to wait until it will be executed, it's a bit more advanced and we do have an imit order protocol for that, that allows you to do a lot of fancy things. For example, firstly it's gasless. So for every user you don't need to pay for gas because basically you don't do anything on chain except approves of tokens sometimes. Also it allows you to do additional callbacks. For example, you can use proposed interaction methods to withdraw some liquidity from Ave for example. And only after that interact execute this limit order from part of the user. It's one of the most optimized protocol on the market.
00:04:57.818 - 00:05:25.762, Speaker A: It's open source as well. It's also outdated right now it's a part of aggregation rotary like contract. So let's try to understand how it works as well. So from one point we have a user, basically user do very basic logic. It needs to build, you just need to understand which token you want to swap. You specify the conditions for swap. For example, I want to sell if one ethereum for 2000 die.
00:05:25.762 - 00:06:14.514, Speaker A: And I have some time constraints for example for one week. And what you need to do just create this structure and sign it from your private key and send this signed transaction with the structure to manage limit order APIs and that's it. You can do it with our front end, we implemented basic functions there so everyone can try, can try that, can try that out there. Okay? And on other part we have a kind of professional micro market taker who is trying to fill these transactions. This is the entity who is trying to pay for gas on chain. And actually this is the entity who can make some profits from that potentially. We also integrate this market taker to our aggregation API as well.
00:06:14.514 - 00:07:10.840, Speaker A: So every time somebody is trying to swap something they can also execute limit orders as well on the aggregation part. Everyone actually can participate in that and be like a resolver taker there. But there is an issue that you need to understand how to calculate, how to calculate the exit price. So you need to take care about the gas price that we'll need to spend to execute the order. Yeah, why I'm talking about that is just to understand what we are talking right now. That we have a market makers that's basically the users who create something and send it to the entities and the market takers that trying to execute these orders from trying to fill these orders and get some profits. In this case usually market takers it's like developers, it's professional like some companies that doing that and makers it's basically users who have interface for everything.
00:07:10.840 - 00:08:01.762, Speaker A: So this is like main scheme how it works. So we have users that signing orders, sending it off chain and some takers that getting these orders off chain and executing these orders on chain and there is verification that everything is correct with the signatures and all the rules on chain as well. So it's kind of permissionless. We don't care where you get this order, we only care the structure and the data there. So that's how a limit order works. But there is a small issue that it's not very comfortable for users because you basically want to sometimes to sell on the market side. But we have a lot of issues right now with me for example with attacks like sandwiched attacks on multiple blockchains, it's also quite expensive and it's bad UX sometimes because of the gas prices.
00:08:01.762 - 00:09:05.926, Speaker A: So we just questioned us ourselves what if we want try to solve all of these issues at the same time? What if you want to sell on the market price but we actually don't care too much that it will be one atomic transaction. We want to have just the best market price during some small time interval, like five minutes for example. And we also don't want to have some issues with MIF attacks for the users because it's extremely painful to explain them. What is that? How to be protected from it? It's quite hard to be natively protected, but we want to make it happen and also it must be gazless because it's one of the best experience you can get potentially sometimes. So we are trying to build something like that and actually this is a one inch fusion. It's our product that helps you to have the same uniswap like experience. Our previous experience with aggregation rotor but it allows you to have gasless execution with protection by default and basically in some cases it's almost better prices that we have on the markets because you have almost limitless liquidity there because any resolver can accumulate.
00:09:05.926 - 00:10:08.942, Speaker A: That just a small example. For example, if you're trying to swap, this is actually the real life transaction. It's like 3000 ethereum craft ethereum to USDT. So it's actually a Dutch auction that we have at the same at Uniswap X that allows you to have during some time interval the price is going down. We're starting from the price that is a bit more expensive than on the market and we are waiting until somebody will be starting to fill it. The main point here that there is an open market of competitors that trying to fill it and their motivation for them to execute this transaction is that when it's going a bit more closer to the market price they are trying to arbitrage that and get some profits from the arbitrage. Basically that's the main point of it and because of the open competition, not because it's one on chain on chain transaction, because it can be multiple limit order transactions that will be executed for one order, we have a bit better prices and yeah, basically that's the main sense of it.
00:10:08.942 - 00:10:47.210, Speaker A: We also recently tested that with 11,000 Ethereum as well and it was also executed better than one on market prices with one on chain transaction. So Vanish Fusion is very useful for large trades. So let's talk a bit about gazos execution. So, as I told before, makers basically do the same as they are doing on limit orders. They're just signing some transactions, some data that is off chain. You don't need to pay for gas except you need to make one small approve to one inch contract from the token. Usually most of the tokens support permit function so it's also gasless per approve for the contract.
00:10:47.210 - 00:11:32.620, Speaker A: After you did the permit or you made an approve, you just need to sign this transaction, the auction and set it to the back end to the limit order storage and after that it will be actually shared with the resolvers, with the entities. They will be fighting for your order, trying to fill it and they will be paying for gas. So as you can see, it's a bit gasless but it's not gas free. So actually every user will need to pay a bit in gas but not directly with Ethereum but with the gas rates during the execution of the trade. So like every user will be executing this transaction not on the market price but sometimes a bit below because of the gas price. That's how it works. We don't have any magic that makes everything executed for free.
00:11:32.620 - 00:12:17.378, Speaker A: That's the case here. Let's talk about beef protection. So it's also not that simple because of course users don't need to think about that right now because we don't have any on chain activity from the user side but we do have on chain activity on the resolver side, on the market taker side. So every resolver as a professional. We do assume that resolvers on our site like in One inch Fusion are professionals that actually know how to handle meth attacks and in this case they have an issue with MIF attacks, but users don't have this issue. So we are trying to focus like to trying to allow professionals to solve these issues, not users. And it's pretty simple point about limited liquidity.
00:12:17.378 - 00:13:04.082, Speaker A: Basically because we have a price auction, it's about like about five minutes. It's pretty customizable. Let's imagine we do have some not very liquid token, for example some shitcoin and there are some cases when you want to swap this shitcoin to another coin. If you're trying to do this on some DEXs v one atomic transaction, it will be pretty high price leapage because let's imagine there's not enough liquidity on this chain. But there are some liquidity for example on other chain. If you have a price auction during eleven amount like minutes of time, some resolver can try to arbitrage to bring this liquidity for example from Crosschain and execute this order on better prices that you will have if you will do a one atomic transaction. This is like the main point of auctions that you can accumulate resources during the price execution.
00:13:04.082 - 00:13:37.620, Speaker A: You have enough time for that as a resolver. That's why we have a bit best possible solution for sleepage that is like we can imagine right now. So the main picture actually looks like that. Basically users just need to do two things. Sometimes they need to give a permit or approval to the one inch rotor contract and sign the off chain order. After that it goes to database shared with the resolvers. They are fighting for this order and executed using one inch aggregation router as well.
00:13:37.620 - 00:14:22.318, Speaker A: Actually, it's quite easy to become a one inch resolver. We have a pretty non digitalized way how we can make it. One thing that you need to do is just to register as a resolver on the smart contract side and also you need somebody, maybe some entity to stay to be to delegate you some unicorn power. Actually it's staked one inch token that allows that will bring you to the top ten resolvers who will be executing the orders in our system. So if you want to execute orders of market takers of users of one inch, you just need to get to be on top ten of resolvers. If you want to be in top ten, you need somehow to motivate the users to delegate to your pool. And the system works like that.
00:14:22.318 - 00:15:02.974, Speaker A: You basically can motivate them by sending some token. Right now it's only one inch token to the far full factory and users will have a motivation to stake delegate the tokens to your factory and they will get some rewards on that automatically. So it's an open competition who will be on the top ten. That's like, the main reason why that's the main point. So that users will delegate to the only entities that have the maximum API, and if the MPI changing, they will re delegate to other entities. That's why it's always kind of not. They are not forced to send rewards, but they need to compete with each other for that.
00:15:02.974 - 00:15:19.890, Speaker A: So that's like an opposition. How it works. Right now there are two options. How you can work with anish fusion. Basically the first one trying to integrate it into your app. Z app or like any DeFi app. That way you need to execute any swaps.
00:15:19.890 - 00:15:47.674, Speaker A: It's quite simple. You just need to have an fusion SDK right now. We have it on TypeScript as one of the most popular languages in the market right now. And there is one more option. It's a bit more advanced. I'm not sure it's quite useful for the hackathon, but it's still pretty profitable, as if you want to build some business or doing some market making it's just become a resolver for each Fusion as well. So if you were interested in becoming a resolver, you can talk to any our community member here.
00:15:47.674 - 00:16:04.698, Speaker A: We have a large booth, so yeah, just talk to us. And also, if you have any questions to vanish fusion. To integrate it. To integrate it. You can just ask me later. Right now we are trying to code. We have a vanish network documentation here with SDK.
00:16:04.698 - 00:16:24.118, Speaker A: I will try to code a bit. I actually made a small repo with one inch fusion 101. You can just scan it. Basically everything what you need. To do, is there? I will try to show some live examples right now, right here. But we will not have enough time. You can just launch it on your own.
00:16:24.118 - 00:16:42.906, Speaker A: Only one thing you need there is JSON. RPC. Endpoint. There is a default one there, but maybe you'll need your own custom endpoint. And one more thing. You need some ethereum. You need basically private key there with some ethereum on it to execute transaction ethereum chain or any other chain basically can switch between networks.
00:16:42.906 - 00:17:14.758, Speaker A: So, yeah, I'll try to do some live example how it works and just explain how one inch Fusion 101 works. We'll basically try to emulate the case as a developer trying to integrate one inch fusion to its own app. Yeah, it's pretty on node JS right now. But let's imagine you'll try to use a front end, like react or somewhere else. I just don't want to focus on that. Right now on the user interface part because we have quite not enough time. So we do have a pretty basic structure here.
00:17:14.758 - 00:17:47.766, Speaker A: I will try to make it a bit more visible. 1 second, please. So you just need to open index JS file, index JS file to see the main default picture. Basically. What do we have here? We do have flow where firstly you can potentially make an approve of source token to the one each contract that you want to swap. That's the first step. So if I will put two, it will basically just make your sequence approved to one each contract.
00:17:47.766 - 00:18:41.358, Speaker A: That's the first step that I just automated. The second part is more interesting part it's trying to make a quote for using one inch order SDK. Basically quote, what will be the return amount for the source amount of tokens and the last part is basically do the swap basically creating fusion order that will be actually a real transaction it will be off chain but it will spend some resources from your account. And yeah, in the end of all, we're trying to search for all orders that we do have on this address through actually just database. So this is like the main three things that you need to have. Checking the approve doing that approve for the specific token also quoting some data and after, if you are okay with this data, you can execute the swap and after that you can check the all history of these orders. This is like basics that you need as a developer to integrate Vanich Fusion.
00:18:41.358 - 00:19:05.098, Speaker A: So if you'll take a look on the config side, it's simple example. I just put everything here. It's not like production ready code, it's just like some ideas. Brainstorming. So we do have here some hard coded tokens. I will try to focus on ethereum right now. So I just picked network ethereum here.
00:19:05.098 - 00:19:37.590, Speaker A: I have some hard coded on this token amount that I will use for quoting and potentially for swap, if we have enough time. And, yeah, I have my private key hard coded as a NV variable. I will not show you my private key, but, yeah, you can just put your own later. So let's try to basically run something. I want firstly to run a quote and trying to take a look what will be the return from API of the quote. So for that I just hard coded. Some variables for boolean variables to not to do everything at one step.
00:19:37.590 - 00:20:04.650, Speaker A: Let's just do only quote. So approve and swap is false and quote is true. Let's run some code. So we do have here basically the quote it's the first part and lower. We just have a history of all orders on this account. Let's take a look on basically the return amount and the structure that we do have, we do have from an inch API. For the quote.
00:20:04.650 - 00:20:40.870, Speaker A: What is important here and how we can work with that later. So basically it's just JSON file and it's quite large, but we don't actually need to focus on everything. Sometimes you need everything but the main things that we need to see here is basically presets presets. It's actually the hard coded ways how the auction works. We have price formulas for you, so you don't need to calculate it on your own. It is possible to use a custom price mode on auction, but it's not available on one inch SDK yet. Till we available quite soon, I think.
00:20:40.870 - 00:21:27.190, Speaker A: And the main point why we didn't do this right now is like yet is because it's quite hard to manage the risk in this case and the custom preset is quite painful and you can lose some assets there or it will not work as expected. In some case you need to be sure that you want to specify these parameters, not as default ones for the execution. So in most cases you don't need to do this. So let's take a look on the presets. And basically the main point here is that we executed a quote for swapping 101 h tokens to some wrapped ethereum and this is like the return amount that I got here. It's calculated in way. Let's try to understand what is the real number here.
00:21:27.190 - 00:22:03.740, Speaker A: I'll just open Google for that. So this is the amount that we got from the quote and we can just double check that we have something the same on the front end of an inch for example. So let's take a look how the front end works. What will it will it charge for the same amount of tokens? So we will pick a wrapped ethereum and the swap will be from one inch. So it's 101 inch tokens. So the return path is quite the same as Wiki as we have here. It's like 0.178.
00:22:03.740 - 00:22:35.046, Speaker A: Yeah, it's quite the same at precision, just is different here. We are not showing all the numbers on the UI right now. Okay, so right now let's imagine that we are okay with this trade and we still want to swap some oneish tokens. Let's try to make an approve. So basically as a developer, what you need to do is just to understand the two token amount from the source token amount. That's actually the price that you will get of the destination token in the amount of that. There are some additional data about that.
00:22:35.046 - 00:23:23.414, Speaker A: You can see the prices like from token in USD and two token of that for pure one token actually and the volume of that in USD as well. And we do have a parameter called recommended preset. It's basically you can just use the recommended presale by default. Quite often it's a fast preset for the fast swaps. When you have a small amount, it's pretty easy to do fast swaps because the price auction, the longer it takes, the harder the price formula works and you need to do something with that because the price can go down significantly if it's not a fast preset. So let's try to execute this order and during the moment when I will be doing that, I will be happy to answer any of your questions. So if you have any questions, just raise your hand.
00:23:23.414 - 00:24:17.434, Speaker A: I will be trying to swap at that moment. So yeah, it's quite possible right now. It's not possible in the interface, but using the Our code, the source code that is MIT based on the GitHub. Basically you can use smart contract like not only externally owned account but smart contract own account to do execute the swaps. It works for aggregation rotor. It works for fusion because basically what is fusion? It's a fusion of aggregation rotor as limit order. Basically you're just creating a limit order and in limit order it's quite adjustable protocol and you can do whatever you want there.
00:24:17.434 - 00:24:49.494, Speaker A: You can use externally own account, non externally own account. You can actually not only execute limit orders with us to 20 tokens but almost with any entity with any token. For example with NFC tokens. Actually what you need to do to make it possible, you just need to implement a transfer function for the limit order. There are several examples in our documentation in our GitHub. I just recommend it to everyone. If you want to try limit order aggregation protocol or like fusion SDK, you can just also try to take a look on the tests of smart contracts there.
00:24:49.494 - 00:25:42.724, Speaker A: There are multiple use cases that sometimes are not public from a user interface, but they are always written so you can just use them as a starter for your case. For example, it doesn't work like that because the price constantly going down. If you will increase the price, we will try to make a formula more complex because it will be going down more slower because you have a minimum amount that you will return. So the auction works like you'll never go to zero. It's like some between some price intervals but because of the market it's kind of predicted how it works. If the price goes too much down during long amount of time, you will just wait too much and you will not get enough tokens. It can be failed.
00:25:42.724 - 00:26:42.296, Speaker A: Basically like when we start an auction, we're trying to understand okay, what is the market price right now? Let's imagine like 2000 Ethereum and we are trying to say okay, the starting point will be a bit more above of the market price and let's imagine what can happen. What is the minimum return amount that you want to get? What is the minimum the lowest rate that you are okay with? For example, it's like 1950 for die for Ethereum. So during this interval you are okay to swap. So we build a price auction like function that is going down to this amount, to this rate and let's imagine we have a ten minutes. What will happen in these ten minutes is quite hard to predict. Sometimes the price going down too fast and if it's below the 901,950 Ethereum die, you will just get nothing because it will be not profitable for resolvers to execute the transaction. So it's not a fact that it's not a statement.
00:26:42.296 - 00:27:13.700, Speaker A: Sometimes it works like that. If you wait a bit more, it's quite possible that something can go better but it's not a guarantee that it will happen. So like the interval, the more you wait doesn't mean that the price will go to your interval, like to your target price. Yeah. So the race will be not definitely better. It can be it depends on the amount of money that you have. If it's a large amount of money, like for example, if I like $100,000 in this case it's much more better to wait a bit more because of the volumes.
00:27:13.700 - 00:28:03.068, Speaker A: The reason for that is that basically resolvers will need more resources to accumulate to accumulate to execute this transaction. If it's $100, it's quite easy. But if it's a large sum they need somehow to arbitrage that. And that's why sometimes when the price the auction time is a bit longer, that's why sometimes the price is better for the large amounts, but it's only worse with large amounts mostly. And there is no any guarantee actually partial fuels are possible with user mode. So yeah, that's one of the main points for how you can save on gas as a user. Basically it's off chain transaction for you and it's on chain transaction for resolver.
00:28:03.068 - 00:28:26.012, Speaker A: But actually resolver can batch multiple user transactions into one on chain transactions. So basically they share the gas price across multiple transactions a bit more optimized. There are multiple ways how we optimize that. That's why auction is a bit more gas profitable for the users. They are also matching orders sometimes. So it's actually quite efficient. It's like economy of scale.
00:28:26.012 - 00:29:10.586, Speaker A: The more users will have, the better it will be working and the more cheaper it will be working for the users. Yeah, I just want to comment that we just executed the transaction. So this is we have as a result of executed transaction and we have actually several orders in the history before it was one. Right now it's two transactions. We'll try to take a look what happened on this account. If you have any questions, just ping me, let me show it again. So basically yeah, I think I can modify this picture later.
00:29:10.586 - 00:30:00.774, Speaker A: But basically here everything started from here. This part like if the limit orders part is on chain, part is actually dowsed like the light here. All here is on chain because resolvers field transactions using one inch network using limit orders contract basically and makers basically users are trying to make approve to the limit order contract as well. This activity happens on chain and everything else the matching they're like accumulating and all the calculation when it's profitable happens off chain. Basically what we do on chain is we try to minimize the efficient like to maximize the efficiency of the contracts. Trying to do as minimum as possible on chain. The minimum you can do is just to verify that verify that rate is okay and just execute the transaction.
00:30:00.774 - 00:30:15.990, Speaker A: Just send the funds that's like the minimum you can do on chain. Yeah, okay. I think we can finish. Thank you for everything. Yeah. I will be open there for any questions. Thank you.
