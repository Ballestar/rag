00:00:06.410 - 00:00:06.654, Speaker A: All right.
00:00:06.692 - 00:00:20.160, Speaker B: Hello and welcome everyone to the Hyperlane Workshop permissionless interoperability with Hyperlane. Joining us today is York Rhodes, who will be taking us through this session. And with that, I will pass over to York to introduce himself and get the session started.
00:00:22.450 - 00:00:30.470, Speaker A: Hey, guys, how's it going? My name's York. I'm with the Hyperlean protocol. Been working on this for around a year.
00:00:30.470 - 00:00:51.962, Speaker A: I was kind of born out of last year's ETH Denver and just wrapped up last week in Denver. We did some talks. I'm going to be kind of summarizing some of the takeaways there and kind of what tools are accessible for you guys to work with Hyperlane during the hackathons for East Global.
00:00:51.962 - 00:01:07.154, Speaker A: So, yeah, without further ado, I'll hop into Hyperlain. So Hyperlink is an interoperability protocol. And before we begin, I kind of just want to share my definition of what interoperability is.
00:01:07.154 - 00:01:32.170, Speaker A: So to me, interoperability is composability amongst DApps on different infrastructure. So Ethereum unlocked this composability of decentralized applications by introducing this generalized execution environment we call the EVM. And it did so kind of at the expense of performance.
00:01:32.170 - 00:02:25.930, Speaker A: As a consequence of that generalized execution environment, it becomes much more difficult to have kind of highly optimized consensus, basically. And what we've kind of seen over the past N or so years in crypto is applications. As they want to optimize for performance or kind of capturing other forms of revenue, they begin to move away from these generalized execution environments which kind of provide composability by default to maybe like an Op chain model or a roll up model where the composability story is a bit less clear in exchange for basically better performance.
00:02:25.930 - 00:03:02.280, Speaker A: And in the past maybe couple years or so, the Ethereum community has kind of galvanized around the roll up architecture for kind of performance benefits that can be passed on to application users. And so this is kind of exciting because we no longer have to have all of the network being throttled by a single NFT Mint. We can now have roll ups take on some of the load there.
00:03:02.280 - 00:03:41.250, Speaker A: And what we're seeing in the ecosystem is applications are beginning to adopt these new architectures. So actually pretty recently the basically volume of transactions that roll ups which are settling to Ethereum are processing has superseded actually Ethereum L One transaction volume, which is pretty exciting. We're starting to see applications really opt into these new architectures and benefit or have their users benefit from kind of the scaling properties.
00:03:41.250 - 00:04:04.486, Speaker A: But along with those new architectures comes a few challenges. So basically interoperability between these different roll ups is a highly fragmented ecosystem. And this is because there's kind of all these different types of interoperability between these architectures.
00:04:04.486 - 00:04:55.734, Speaker A: So the first form that probably most of you guys are familiar with of interoperability is what we call like, the canonical bridges of these roll ups, which are basically on L one, there's a smart contract interface for doing a deposit to a roll up and then there's an equivalent withdrawal interface to withdraw your asset from that roll up. And then separately, we have kind of a bunch of these asset bridges that function between roll ups that allow you to move assets using smart contracts between roll ups. And so some examples of this are hop synapse.
00:04:55.734 - 00:05:31.720, Speaker A: A bunch of these are focused on across, these protocols are focused on moving assets between roll ups. And the reason that these exist is the canonical bridges which again, provide this deposit and withdrawal interface tend to be too cumbersome or too slow to go through always. For certain application use cases, especially in the case of optimistic roll ups, we have this withdrawal period of, I think, like seven days.
00:05:31.720 - 00:06:06.850, Speaker A: I think we don't want to impose that latency on an application that wants to kind of do something for its users across roll ups. And then finally we have these general message passing between roll ups. And this is kind of emerging as a way for smart contracts that exist on different roll ups to have composability, whether it's calling each other's functions or doing something a little more sophisticated than just moving assets between these roll ups.
00:06:06.850 - 00:06:59.010, Speaker A: And there's been kind of a few early attempts in the community to establish some shared standards. So instead of each roll up having its own custom bespoke interface, that not all application developers need to go in and custom integrate with, people are trying to define standards for this. So there's one ERC from, I think, the pool together team that's shown in the bottom left here, that's basically just trying to standardize these interfaces around something which is a little more sane and doesn't require application developers to have 30 different kind of adapters for all these different interoperability protocols.
00:06:59.010 - 00:08:06.520, Speaker A: And, yeah, just to highlight kind of why? Why are we even doing this in the first place? Why are we trying to introduce interoperability between different chains or different roll ups, different execution environments? And the answer is these new types of application architectures can actually unlock innovation and new properties for users. So just as, like, a very recent example, the A 16 Z research team posted an article, they've been doing kind of a deep dive on a bunch of different auction mechanisms, but they implemented a sealed bid auction using Aztec Connect, which is basically like this L Two that the Aztec team is working on. And in doing so, they kind of provided privacy to participants in this auction who are settling on L One, but maybe don't want to reveal their entire balance list, for example.
00:08:06.520 - 00:08:42.770, Speaker A: So, yeah, this is just like, really exciting. Once we get interoperability between what I call heterogeneous infrastructure, we can really begin to kind of leverage a bunch of the innovation that's happening at the infrastructure layer in a single application. So right now, there's tons of research, tons of R and D going into basically new role of architectures, whether it's for privacy or performance.
00:08:42.770 - 00:09:23.490, Speaker A: It's basically like majority of the research community is focused on these problems right now. But there's not really great interoperability between these different layers because they're all kind of designed in aren't hearing you at my end. Yeah, they're all just kind of designed in different companies that maybe have a specific product in mind that they're going to build on top, but haven't really necessarily thought about how those products and those applications are going to compose with applications that are on other chains.
00:09:23.490 - 00:10:25.570, Speaker A: There's also a lot of people working on light client interoperability, which is kind of amongst the research community gets lauded as the Holy Grail of interoperability. And this is kind of what the Cosmos ecosystem has been working towards for the past, I don't know, four or five years in their work on IBC, basically having these native light clients for every chain that wants to be interoperable. And so in their ecosystem, they kind of make a bunch of assumptions about the consensus and execution environment that chains are operating and then they're able to do these light client proofs between these chains.
00:10:25.570 - 00:10:50.460, Speaker A: But even with this sort of solution, there's a bunch of problems. So for one, it's quite expensive to operate these light clients because you have to basically be processing every block header on chain. And as you scale the number of connections you have between chains, you have to do this for every chain you're connected to.
00:10:50.460 - 00:11:21.350, Speaker A: And actually in the Cosmos ecosystem, this is basically like subsidized as a public good for people to operate these things. But there's not really a great economic model around how to fund these light clients. And then the other challenge is these implementations of these light clients are quite complicated and require an implementation for every single state model.
00:11:21.350 - 00:11:54.542, Speaker A: And so with all these teams kind of innovating on the VM layer, we have all these new VMs coming out fuel Aptos, there's a ton, there's probably a new one on Twitter today. The light client implementation for these new VMs is probably many years away and these things don't generalize super well. And for rollups especially, this is true, we basically don't have a good light client solution for roll ups because of kind of how roll ups are architected.
00:11:54.542 - 00:12:38.880, Speaker A: So all that's to say kind of light clients are not a panacea for interoperability. But we do need some generalized protocol for application developers to understand to benefit from composability with all these different new infrastructure layers that are kind of spinning up without again, you as a developer having to go through 25 different developer docs and say what does their interface look like. So this is where this idea of modular interoperability comes in.
00:12:38.880 - 00:13:32.880, Speaker A: And this is kind of aligned with the modular blockchain thesis which is basically once applications reach a sufficient operating scale like let's say Osmosis or dYdX recently is moving to a Cosmos chain. Once applications reach this sufficient scale, again, they want to move away from maybe one of these generalized execution environments to something that's much more, well, optimized to their application and more kind of fine tuned. And so we need to maintain the property of these protocols being composable with all the other DFI Legos, but we want to move them off, let's say, Ethereum L one.
00:13:32.880 - 00:14:35.066, Speaker A: And so for developers to maintain that composability, we need to separate what's called the transport layer and the application layer. So the transport layer is basically how information moves between these chains, and the application layer is just basically what is the on chain smart contract interface to actually send and receive messages between these different chains? And so you guys, as DAP developers, shouldn't need to understand all these details about the transport layer, meaning, oh, is this a roll up that's sharing a settlement layer with the destination chain? Am I sending to a roll up? Am I sending to an L 01:00 A.m.? I sending to a Cosmos chain? Do I need to use a different transport layer? As a developer, you shouldn't need to have control flow for all those different cases.
00:14:35.066 - 00:15:07.230, Speaker A: There should be kind of like an application layer interface for you to pass messages and basically to send and receive messages to and from any chain, irrespective of what the underlying kind of infrastructure and transport layer looks like. And so this is where Hyperlane comes in. Hyperlane is what we call a generalized message passing protocol, which provides this interface to your smart contracts on basically all of the chains that I've talked about thus far.
00:15:07.230 - 00:15:27.110, Speaker A: So we're live on, like, I think, around 15 EVM networks, and we're working on a bunch of implementations of our spec across a bunch of other VMs. So we have a Fuel VM implementation, a C level VM implementation, which is for Solana. We have a Cosmos SDK module.
00:15:27.110 - 00:16:25.714, Speaker A: And basically, as a customer of Hyperlane or as a developer using Hyperlain, you no longer have to maintain an implementation which is specific to optimism or specific to Arbitram or specific to one of these roll ups because you have this consistent application layer API. And this is all with the caveat that, okay, we want to abstract away the transport layer from application developers because it complicates the implementation work, but we simultaneously want to allow those application developers to express their preferences for security. So we don't want to just say, okay, we're going to oregalize all this information at the transport layer between chains.
00:16:25.714 - 00:16:48.506, Speaker A: And developers should just trust us in the spirit of kind of modularity. We want to provide an interface for applications to say, hey, I know my application architecture the best. That's why I'm deploying on this specific chain, or I'm building an application specific roll up, et cetera.
00:16:48.506 - 00:17:11.154, Speaker A: I know my application the best. I want to design and pick all the trade offs at every layer of the stack and I want to be able to specify what security I require on messages which are coming inbound to my application. So this can be like a function call from another chain.
00:17:11.154 - 00:17:44.530, Speaker A: This can be an asset transfer. You need some way to say, okay, I have this much confidence that this message which says, let's say that it's transferring me 100 USDC is verifiable basically according to the source chain. And so in the hyperlink protocol we have this, again, another application layer interface we call the interchange security module interface.
00:17:44.530 - 00:18:38.662, Speaker A: And as a message recipient or again, like an application developer like you guys, you can say I want to use this specific security model for messages which are inbound to my application. And so today our default security model that applications are kind of if they're not specifying an interchange security module they're opted into is basically this proof of stake validator set that we have on each chain. And if validators are lying about or basically producing signatures that don't match what the source chain kind of says as what messages were sent out from that chain, then that can be slashed.
00:18:38.662 - 00:19:24.370, Speaker A: But the beauty of this kind of modular interface is you can have an interchange security module which is specific to your application. And again, you don't have to kind of assume some sort of like omnibus security model, like a lot of the existing asset bridges or generalized message passing protocols kind of prescribe. So if you guys are familiar with Wormhole or some of these big asset bridges, there's like a centralized validator set and you're basically trusting that all the applications that are built on top of something like Wormhole are just trusting that that validator set will never be compromised.
00:19:24.370 - 00:20:11.438, Speaker A: But it is the case that it might make economic sense for that validator set to collude and rug your protocol. And that's a pretty unfortunate situation that we're in because we have kind of this third party set of security providers, but with the kind of like ism interface that Hyperlane provides, you can now introduce these application specific security requirements. So you could say I want the validators who are providing security on messages inbound to my application to have some exposure or risk to my application.
00:20:11.438 - 00:20:54.926, Speaker A: So maybe they also need to be staking your application's protocol token or maybe you have a multi SIG that you want to ensure has signed off on cross chain governance or something that you're doing between chains that again, now allows you to kind of express stronger and more granular security preferences as an application developer. Yeah, so hopefully that makes sense. This is kind of like something we're really trying to get people to experiment with and potentially come up with interesting security models which are application specific.
00:20:54.926 - 00:21:17.510, Speaker A: So whether that's like a cross chain stable coin, we want to introduce security mechanisms which right now we have a couple of off the shelf implementations available. We have this like crypto stake multisig. We're working on an optimistic security model that was kind of pioneered by the Nomad folks.
00:21:17.510 - 00:22:01.170, Speaker A: But yeah, again, just to summarize, kind of simple messaging API that exists across all these chains that kind of abstracts away the complexity or like idiosyncrasies of some of these different infrastructure layers and then a way for developers to specify their preferences of what security is happening at the transport layer while still having that configuration interface at the application layer. So it's all just simple smart contract interface. You just set an address, you don't have to run or operate any of your own infrastructure.
00:22:01.170 - 00:22:34.906, Speaker A: So again, this is like modular interoperability. And then finally, what really makes this kind of scale well is we're providing the tools for developers to expand our protocol to whatever infrastructure they want. And this allows developers not to have to lobby for kind of inclusion.
00:22:34.906 - 00:23:05.522, Speaker A: So let's say you no longer have to go to Jump or Wormhole and ask them and lobby them to bring their bridge to your chain or your roll up, which is a quite difficult process and probably is too much risk for them to take on. So instead you can deploy hyperlane to any chain you want, you can expand it. permissionlessly.
00:23:05.522 - 00:23:51.510, Speaker A: This is what the title of this workshop was about, permissionless interoperability. This idea that you can expand this interface messaging API to any new VM or any new chain that you want and you don't have to convince anyone to begin providing kind of transport layer relays to that new chain. Because you can specify your own interchain security module on that new deployment that says, okay, I want my application to be on this new chain on day one, and I'm going to get kind of all of the composability from all the existing Hyperland deployments inbound to my new deployment.
00:23:51.510 - 00:24:25.140, Speaker A: And so we have super simple instructions for how to do this on EVM chains right now. Again, we're going to working on expanding this to a bunch of other VMs and we're also kind of excited to collaborate with people who want to see hyperlane on new VMs or on new chains. But this is something that we'd really love to see people kind of play around with is take Hyperlane, go check out the docs and look at what chains we're on.
00:24:25.140 - 00:24:51.020, Speaker A: And if your application wants to be on some chain that we're not on, you can go and just run a couple of scripts and deploy the hyperlain protocol to that chain. And now introduce composability for your application with all these existing network effects. That's basically what I wanted to talk to you about today.
00:24:51.020 - 00:25:14.290, Speaker A: I'm going to take a look at the chat and see kind of what questions came in, what kind of messages we would want to send between chains that are enabled by interoperability. Yeah, great question. So this goes back to kind of what I was talking about with what interoperability unlocks.
00:25:14.290 - 00:25:52.270, Speaker A: So, yeah, again, you know, in a in a single VM like single chain monolithic worlds where we just have Ethereum, all the smart contracts that are deployed on Ethereum can just atomically call functions on each other. And this kind of enabled a bunch of innovation that wasn't possible on Bitcoin because now we can do arbitrary execution. We have this turn complete environment.
00:25:52.270 - 00:26:18.626, Speaker A: But the caveat is you don't get great scaling properties because all of your verifiability needs to be super generalized. And what we're seeing kind of in the past couple of years is people want to push the envelope and get better performance or optimize the infrastructure for a specific product. And so they're deploying these app chains.
00:26:18.626 - 00:26:43.402, Speaker A: They're deploying these roll ups, but they still need to leverage existing network effects to either bootstrap their growth or just kind of get the same benefits of DeFi on Ethereum. And that you can leverage other protocols, liquidity or other protocols, assets under management. And so this is the type of messages that you would want to send between chains.
00:26:43.402 - 00:27:10.230, Speaker A: You want to do a function call on a contract that's on another chain, or you want to send some assets or communicate some synchronize, some state that's maybe across multiple chains. Maybe you're leveraging assets that are on some other chain or on Ethereum l One for some new application. Or maybe you're leveraging the Ethereum name service on your chain.
00:27:10.230 - 00:27:24.620, Speaker A: You can do interchange queries so you can introduce Oracles between different chains. You can use uniswap T Wops on your chain for some DeFi protocol. That's just the general idea.
00:27:24.620 - 00:27:46.270, Speaker A: Does hyperlain support substrate? Great question. So we're working with a few teams in the Polkadot ecosystem. We don't have kind of like a substrate SDK implementation, but we do have deployments on Moonbeam and I believe Astar.
00:27:46.270 - 00:28:32.030, Speaker A: And, yeah, we're actually seeing some teams in the wild kind of prefer the hyperlain interface to the native substrate solution, which is this like XCM protocol you talk on. How does Hyperland integrate Oracles? Yeah, basic idea is you can basically send a message to some chain that you want to Oracleize state from and say, hey, make this view call on this chain and send me back the response. So it's basically like a two hop message.
00:28:32.030 - 00:29:12.254, Speaker A: We have a section in our docs I might just hop over there real quick on what we call interchange queries, which allows you to basically create an Oracle from any chain to any chain by basically doing these cross chain view calls. So that's what this docs page is for. If kind of a few other developer primitives on top of the messaging API that we talked about, which again, abstract away some of the complexity here.
00:29:12.254 - 00:29:27.780, Speaker A: But yeah, we'd love to see kind of anyone who's interested in getting these cross chain Oracles to use this API, give us feedback. Yeah, if there's any other questions around that. Happy to answer.
00:29:37.430 - 00:29:50.520, Speaker C: Can you talk about how hyperlink provides bar swapping tokens from one chain to another? What does it use?
00:29:52.090 - 00:30:28.430, Speaker A: Yeah, so it's a good question. So right now, we're not operating what you might call an asset bridge or a liquidity layer internally right now. So what we're doing instead is we are basically wrapping a bunch of other asset bridges on chains where they're available in the hyperlane messaging API.
00:30:28.430 - 00:31:15.154, Speaker A: So if you want to basically move USDC with one of these messages to another chain, you can do that with the liquidity layer API and it will go talk to the portal protocol to mint and burn that asset and then handle your message as it receives the tokens on the destination chain. We are working on kind of a more native liquidity layer solution. But yeah, right now we mostly just have adapters to a bunch of third party asset bridges on chains where they're available.
00:31:15.154 - 00:31:38.460, Speaker A: But that can also be a project that you guys can build on top of hyperlan is basically a more generalized asset bridge. We also have this work routes API, which kind of generalizes the ERC 20 standard to cross chain transfers. Definitely check that out as well.
00:31:41.150 - 00:31:58.750, Speaker C: How decentralized are currently used for liquidity and layer API? If I'm building a crosssense web that is using like, decentralized exchange that provides crosssense webs, is that a good idea to use hyperlink?
00:31:59.750 - 00:32:26.170, Speaker A: Yeah, obviously I'm biased, but I definitely think so. Right now, our validator set with the default security that I was describing earlier is not very decentralized. We have basically like a bunch of people in our discord that are operating these validators, but we're working on scaling up the economic security that they're staking.
00:32:26.170 - 00:33:31.630, Speaker A: And we have a bunch of ideas there around leveraging something like eigen layer and restaking and kind of bootstrapping more economic security. I would say right now, if you want to do something with kind of a lot of basically like, I guess, economic risk, then you probably want to do the heavier lift of implementing your own interchange security module, which kind of prevents this currently fairly small, validator set from having an incentive to, I guess, collude against your applications. But yeah, if you want to read more about the validators or understand kind of what our distribution looks like right now, definitely hop in our discord and happy to answer further questions around the security status quo.
00:33:31.630 - 00:34:02.890, Speaker A: Shankar, I'm honestly not totally up to speed on what our substrate integration looks like, but again, would love for you to get in the discord and I'll connect you with kind of the right people there.
00:34:11.960 - 00:34:18.070, Speaker B: Hey, I don't know if you saw the question from Meyer about what's a warp route mean.
00:34:19.560 - 00:34:31.000, Speaker A: Sorry. Yeah, I missed that. So a warp route is just kind of our take on token bridges.
00:34:31.000 - 00:35:01.380, Speaker A: We wanted to differentiate the language a little bit because we've come up with some different trade offs. So instead of wrapping and unwrapping your token through some bridge like wormhole, where you have this honey pot of every single token that's in wormhole functioning as like a bounty on the security of those validators. Instead, you can have what we call warp routes, which allows you to introduce fault isolation between these different applications.
00:35:01.380 - 00:35:37.804, Speaker A: And that's possible through, again, what I was describing earlier with this modular security interchange security module configuration, where you can have application specific fault tolerances instead of having this global shared security model. And there's a repo you guys can check out if you want to understand a little more about how Word routes work. You can basically clone this repo and launch your own Word route super easily.
00:35:37.804 - 00:36:11.530, Speaker A: There's also like a UI template that you guys can basically just clone and get one of these isolated work routes. Yeah, all this is linked on the Docs docs Hyperlain XYZ. And yeah, please do follow up with questions in the discord if you guys do end up playing around with anything we talked about here.
00:36:11.530 - 00:36:19.160, Speaker A: Yeah, I think that's my time, so yeah, thanks so much guys, for coming.
00:36:20.010 - 00:36:24.722, Speaker B: Yeah, cheers. Thank you everybody, for joining us today. And thanks York, for the great presentation.
00:36:24.722 - 00:36:37.750, Speaker B: And yeah, if there are any more questions, please just pop them into the Hyperlains Discord. I posted the link a little while ago. Cheers, everybody.
00:36:37.820 - 00:36:38.814, Speaker C: Have a good day.
