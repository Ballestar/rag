00:00:07.290 - 00:00:11.226, Speaker A: Hi, everybody. My name is Shay. I'm from Flashbots.
00:00:11.226 - 00:00:25.960, Speaker A: And today we're going to be talking about mev, about the history of strange things in the Mempool. Briefly. Hold on.
00:00:25.960 - 00:00:32.842, Speaker A: There we go. At a glance. This is what we're going to be talking about today.
00:00:32.842 - 00:01:01.182, Speaker A: I'll share with you kind of the history of interesting things that have happened on Chain. We'll talk about new emergent phenomenon and then about how you as a user searcher or an application developer can leverage these tools today. As a brief introduction, if you are not already familiar with Flashbots, we are a research and development organization dedicated to mitigating the negative externalities of mev.
00:01:01.182 - 00:01:36.378, Speaker A: So we develop protocols like the ones you see here, mevgeth, Mebboost and Mebshare, as well as products like our Bundle Relay for searchers, the Protect RPC for users and wallets, and our block builders. And purpose of this is to ensure that the Mev supply chain stays decentralized. But what does that actually mean? If you will indulge me, I want to start by taking a quick walk down memory lane, looking at some of the interesting things that have historically happened on Chain.
00:01:36.378 - 00:02:04.214, Speaker A: And I'm going to start if you are an OG, you may have seen this slide before. It is a deck put together by one of our mates a few years ago to show how searchers were engaging with the very earliest form of Flashbots. And I want to share with you some of my favorite anecdotes and stories from this because I think they're quite illuminating and still true with the market of searching in Mev today.
00:02:04.214 - 00:02:38.302, Speaker A: So to begin with, way back in the early days of Flashbots, one of the earliest interesting scenarios we saw was when a searcher named Nathan entered the chat. So Nathan was a very sophisticated searcher, who in this example, we see, he was able to bait essentially a sandwich bot and steal about 250K from them. And this is actually an example of one of the earliest kinds of exploits in Mev, affectionately known as salmonella.
00:02:38.302 - 00:03:05.210, Speaker A: Essentially the way this works is that you create a token which simulates differently from how it executes. So the sandwich bot in this case actually run by miners, was able to buy the tokens but then couldn't sell them back and whoever baited them was able to drain the pool. We also in the early days saw a lot of PvP games between different searchers that were competing and fighting with each other.
00:03:05.210 - 00:03:27.794, Speaker A: So this is a very cute screenshot, actually, of two of these searchers who had, I think one of them had wrecked the other one, left them a nice message on chain saying, good game, well played. And then finally, another theme we see is the entrance of new paradigms, new protocols for searching. So this example is of uniswap v.
00:03:27.794 - 00:03:43.030, Speaker A: Three. It was really interesting, actually, when Univ Three was launched, there basically were very few people who actually upgraded and integrated it. It took months before we actually saw a competitive landscape of univ three searchers.
00:03:43.030 - 00:04:03.850, Speaker A: And I call these examples out because there are kind of three key themes here, three constants, if you will, in the history of searching. And they are, first of all, that there are new exploits that emerge. Maybe used to be the salmonella exploit, now it's something like the low carb crusader.
00:04:03.850 - 00:04:17.950, Speaker A: The second theme is that there's also new paradigms that emerge for searching. So different protocols, different ways of thinking. And the final constant is that despite all of this, in the face of all of this change searchers adapt with style.
00:04:17.950 - 00:04:33.282, Speaker A: So you see the very cute P to P messages. This one, I don't know how easy it is to see on the screen, but this is an example of a searcher who is actually recently trying to integrate a new protocol called Mobshare. And they realized that their bot was not going to be that profitable when it first launched.
00:04:33.282 - 00:04:58.910, Speaker A: So they called one of their functions the charity function, which I thought was very cute. But what's happening now? Like, what is the new frontier in searching today? That was a few years ago. What's happening today? I want to share with you a few things I've seen in the past couple of months that I think are quite interesting and allude to maybe a new paradigm in searching and in mev more generally.
00:04:58.910 - 00:05:08.350, Speaker A: So I'll start with this one. Like a month, maybe two ago, we saw this token launch happen. And it's a pretty standard token launch.
00:05:08.350 - 00:05:27.154, Speaker A: The team announced it on Twitter in advance. And immediately after the token was launched, we saw this bot essentially backrun the launch to basically snipe and grab a bunch of the supply. The reason it looks weird is that the token launch contract had a clause that tried to prevent people from basically loading up on this token.
00:05:27.154 - 00:05:37.322, Speaker A: But as you can see, that was no barrier for the searcher. They were able to just kind of get around it by making a bunch of requests. So all of this is pretty classic token launch, token sniping stuff.
00:05:37.322 - 00:05:45.354, Speaker A: Nothing weird here. But there are two weird things. If you take a closer look at the block where that searcher transaction landed.
00:05:45.354 - 00:06:02.766, Speaker A: The first is if you actually look at the original transaction that launched the token, you will see something strange, which is that this is a flashbots bundle. This is a response from the Flashbots Locks API, which tells us that this was actually a private transaction. It's kind of weird.
00:06:02.766 - 00:06:24.806, Speaker A: How did this searcher know to backrun them? The transaction itself was private. What's happening there? The second thing you might notice is there's actually a third transaction after the launch transaction and the backrun, which is a transfer from the builder to the original launch address of about $20,000. That's weird.
00:06:24.806 - 00:06:34.142, Speaker A: So some portion of the searcher's bid was actually refunded back to the user weird. I have one more example for you. Yeah.
00:06:34.142 - 00:06:56.574, Speaker A: Essentially, how did somebody backrun a private transaction and generate so much value? One more example, which is in this block. I want to take a quick look at another similar case. These three transactions says about a week ago we saw first a user make a trade on a Dex.
00:06:56.574 - 00:07:09.190, Speaker A: They were swapping some ETH, about Ten ETH for this random token called Woofwork. They actually got completely wrecked, not by an Mev bot just because I think the pool was quite illiquid. They basically went from Ten ETH to almost $0.
00:07:09.190 - 00:07:14.954, Speaker A: Very sad. You can see this is also a private transaction. Okay? People make bad trades all the time.
00:07:14.954 - 00:07:35.998, Speaker A: This isn't that unusual. But what is kind of interesting is again, we saw a searcher back running them in the same block despite this being a private transaction and that searcher knew which pool the user was trading on. Weird, we also yet again saw a refund from the builder to the user who made the original trade.
00:07:35.998 - 00:08:07.820, Speaker A: So what's happening? What are these weird phenomena that we're seeing? This is actually not a fluke. This is an example of a new emergent phenomena that's happening today on chain and called an Order Flow auction. So essentially the status quo right now is users will either send their transactions to the public mempool or they will send them to private channels like for example Flashbots Protect, which is where these two examples came from.
00:08:07.820 - 00:08:35.190, Speaker A: And searchers are able obviously to see what happens in the public Mempool, but they're not able to see what happens in the private mempool. And that's actually pretty suboptimal. While these private channels are really great for protecting users from things like front running, as we have seen there's a lot of value that is on the table to extract even just by back running these transactions, which is something that's fairly neutral usually to the original user.
00:08:35.190 - 00:08:56.586, Speaker A: In just these two transactions alone, there's about 15 ETH on the table that's just sitting in these private channels. So order Flow auctions try to find a balance between protecting users and internalizing the value they generate. The premise is that when users transact on blockchains they generate value.
00:08:56.586 - 00:09:22.770, Speaker A: And right now that value is primarily captured, as we have seen, by searchers or the validators they have to bid to for inclusion. But we want to give users a fair price for their transactions. And the way that we do this is by allowing searchers to bid for the right to execute them, essentially allowing us to strike this balance between protecting users and internalizing or refunding them the value that they create through mev.
00:09:22.770 - 00:09:44.730, Speaker A: So this is essentially what we're trying to do is allow some valuable actions to be taken on private order flow. The problem though with all of this is that searchers can't exactly be trusted. So users are using these private channels for a reason.
00:09:44.730 - 00:09:57.258, Speaker A: They don't want to get wrecked. We need to find a way to kind of balance that concern with allowing valuable mev to be generated. And the trade offs here really come down to privacy.
00:09:57.258 - 00:10:20.390, Speaker A: The more information you have as a searcher, the more efficiently you're able to backrun or bundle some user transaction. And this is also good for the user because it means that they're able to get a higher bid in the auction. On the other hand, if you reveal too much information, somebody could generalize front run you on another domain or take some other action that negatively impacts the user.
00:10:20.390 - 00:10:39.490, Speaker A: So at Flashbots, we have thought a lot about this exact problem, this tradeoff. How much information do you share? And what we found is that it's not a one size fits all problem. Different use cases need to share different amounts of information to strike this balance between protection and value internalization.
00:10:39.490 - 00:11:04.238, Speaker A: And we call that concept programmable privacy. Concretely, the idea behind programmable privacy is that you control what information you share and we call these pieces of information hints. So an example of the hints that you might see are things like the contract address or the logs, maybe the call data, maybe nothing the transaction hash that a transaction emits.
00:11:04.238 - 00:11:32.266, Speaker A: And what's very interesting about this is it creates a new paradigm for searching. As a searcher, you will have to actually update your strategy to search on these hints and incomplete transactions rather than on complete transactions that you're used to seeing in the mempool. So for the rest of the time, what I want to talk about is one particular protocol for order flow auctions that uses this concept of programmable privacy.
00:11:32.266 - 00:11:54.334, Speaker A: I'll talk about what it is, how it's architected, and then how you as a user more an application developer, a wallet or a searcher can interact with it today. And that protocol is called mebshare. So if I take a quick step back to orient us, if you have seen any Flashbots presentation, you have probably seen this slide.
00:11:54.334 - 00:12:01.170, Speaker A: If you have not, here's the slide. You will see it many more times after this. But essentially this is the mev supply chain.
00:12:01.170 - 00:12:25.118, Speaker A: In other words, it's all the steps that happen from when a user submits a transaction to when that transaction is included on chain. And that includes the user's intent, which is then signed through something like a wallet, submitted and bundled by searchers, merged into a block by a block builder and then finally confirmed by a proposer or validator and to zoom in a bit. Where mevshare lives is right here.
00:12:25.118 - 00:12:41.602, Speaker A: So at the very start of the transaction or mev supply chain and the protocol is pretty straightforward. It has out three steps and there's really one primary actor which is called the mevshare node. And the mevshare node is responsible for doing a few things.
00:12:41.602 - 00:13:05.206, Speaker A: First of all, it receives transactions from users. Second of all, it shares whatever hints that user has asked for with the searchers that can publicly see this data. Then it receives partial bundles from searchers, which are just like usual bundles, except because we don't share the full signed transaction as a searcher, you're not going to be able to put a transaction in your bundle.
00:13:05.206 - 00:13:22.630, Speaker A: So instead what you would include is an Identifier for the transaction whose hints you thought matched whatever you wanted to put in your bundle. So for example, that Identifier might be the transaction hash. So a partial bundle would be a normal bundle, but with some transactions and some hashes.
00:13:22.630 - 00:13:41.270, Speaker A: Finally, step three, the matchmaker will receive all these partial bundles and then it will convert them into full bundles by inserting the signed transactions that correspond to the hashes that searchers have specified. And the resulting full bundle is then sent on to a block builder. Pretty straightforward.
00:13:41.270 - 00:14:26.530, Speaker A: So how does this fit into the existing Flashbots architecture? Like that protocol is all very interesting and high level, but how do I touch it? Where does it live today? What does it mean for me as a user, a wallet, application developer or searcher? So here is where it sits. If we look back at the original diagram, flashbots Protect is a protected or private channel that users or wallets can submit transactions to. And what we've done is Flashbots has implemented one instance of a Mev share node, which is that party that sits in the middle of the protocol and that node can be accessed directly through the Flashbots Protect RPC.
00:14:26.530 - 00:14:55.514, Speaker A: So these things are now combined together and what this does is allows searchers to in a safe way try to generate additional value on top of this private order flow. So Flashbots Protect is now upgraded and has a bunch of useful properties for users. It gives them both protection and now with mevshare, the ability to internalize Mev that they generate.
00:14:55.514 - 00:15:21.682, Speaker A: And for application developers or wallets, it gives you a lot more options about how you actually design your application in an meva aware way through this configurable control panel where you can decide what information is shared with who and how. So to go a little bit more specific, concretely, as a user, the way that you would interact with this is really easy. There is a button on the Flashbots docs.
00:15:21.682 - 00:15:29.382, Speaker A: You just click the button, it adds the RPC to your wallet. I think it takes maybe two or three clicks depending on what wallet you're using. And it's fairly straightforward.
00:15:29.382 - 00:15:48.622, Speaker A: All you have to do is switch out your RPC to get these benefits. As a maybe more sophisticated user or an application developer or a wallet, you also have more options. These are available to everyone, but especially recommended to folks who are developing their own applications that want to kind of tinker with how the Mebshare protocol works.
00:15:48.622 - 00:16:13.106, Speaker A: So you can select a number of things including the hints or privacy settings that you want to share as well as the other block builders that you might want your transactions to be forwarded to. For example, to have increased inclusion rates. You can also select things like how refunds are distributed, what percent of the searchers bid goes to what address or another, and you can also configure even more advanced things which we call validity conditions.
00:16:13.106 - 00:16:34.830, Speaker A: A refund is one example, but it's basically a way of telling a block builder how it is required to treat your bundle. Happy to talk more about that after, if anyone is interested. As a searcher though, what does this look like? I think this is the biggest step change with something like mev share and programmable privacy is how searchers are going to interact with this new paradigm.
00:16:34.830 - 00:16:59.638, Speaker A: Well, there are about two or three things that you'll want to think about and the first is how to consume data. You're going to be using hints instead of mempool transactions, which means you have to listen to the mem share event endpoint, listen to the node's hints instead of listening to the public mempool. And you're also going to need to parse a different object.
00:16:59.638 - 00:17:13.370, Speaker A: You're going to parse something that has these hints in it rather than a full signed transaction. This is an example of what some common hints might look like. The second thing is you'll have to change the way that you think about sending bundles.
00:17:13.370 - 00:17:27.066, Speaker A: In particular, we talked earlier about partial transactions or sorry, partial bundles which just include the hash of a transaction. So you'll have to adopt that new paradigm. And the way that we do this is through a new API.
00:17:27.066 - 00:17:48.194, Speaker A: We've gone from ETH send bundle to mevsen bundle and this is roughly the structure that you will care about. Migrating is very easy. It's like three things change the namespace from ETH to mev, rename the transactions field to body which we've generalized to allow for hashes and then we renamed block number to block.
00:17:48.194 - 00:18:01.590, Speaker A: So you'll have to rename that as well. But pretty straightforward migration. The most interesting piece of this, once you've got all the integrations hooked up, is how you actually change the way you think about your searching strategies.
00:18:01.590 - 00:18:28.690, Speaker A: So you're not able to do things like simulate a full transaction anymore, which means that you're going to need to move or change the logic that you use as part of your bot. And there are about two ways that we think about this broadly. The first approach I would call on chain searching and basically what on chain searching is, is moving all of the computation you used to do off chain into a smart contract that's executed on chain.
00:18:28.690 - 00:19:08.650, Speaker A: So as an example, if you're used to seeing the amount that somebody is trading in their call data or their logs, you might actually have to use the reserve deltas on chain to run a calculation like at execution time to figure that out. Now, the other way you can think about searching on a programmably, private transaction or set of transactions is to do it in a more probabilistic fashion. So, for example, instead of knowing the amounts and the direction that somebody's trading, you can just guess, basically say, well, I'll send two transactions, one for each direction that they could possibly be trading on this pool.
00:19:08.650 - 00:19:31.702, Speaker A: And then I'll also, for each of those directions, send a bunch of different possible sizes. If this is an ARB, for example, the thing I would emphasize and stress to all of you is, like, it took about three months for anyone to really become competitive on unisoft V. Three mev share is also very early, and this paradigm is new.
00:19:31.702 - 00:19:58.080, Speaker A: And that means that as a scrappy early searcher, you actually have a huge advantage. We're sponsoring some prizes for the scrappy searchers who want to try this new paradigm, as well as wallet application and other developers who are interested in experimenting with mevshare. So I'll briefly talk about what those prizes look like.
00:19:58.080 - 00:20:09.090, Speaker A: The first thing is we're giving a prize for the coolest mebshare bot. Essentially come up with something weird, deploy it, lend some bundles. This should be open source.
00:20:09.090 - 00:20:27.610, Speaker A: We're also giving away the prize for a design that uses mevshare in an application. So really get creative with this. It can be fully implemented, it can be an architecture spec, but the idea is to have some sort of specification for a new configuration, a way of using validity conditions or hints in an application.
00:20:27.610 - 00:20:37.930, Speaker A: Also, please make it open source. There's a theme. Finally, we're giving out a prize for an onboarding viral website for the Protect RPC.
00:20:37.930 - 00:20:52.850, Speaker A: We currently just have this button in our docs. We want to see what interesting things you might come up with. All these value props we've talked about today, how would you want to communicate that to somebody? Again, we build open source software, so please make this open source.
00:20:52.850 - 00:21:10.686, Speaker A: And that's it. I think. To conclude, there are, like I mentioned at the beginning, three things that remain constant in mev new exploits emerge, new paradigms emerge, and searchers adapt with style.
00:21:10.686 - 00:21:27.830, Speaker A: So we're very excited to see all the stylish ways you will interact with this new paradigm. You can reach out to me, and the team will also be in the discord for the rest of the hackathon. Yeah, that's it's.
