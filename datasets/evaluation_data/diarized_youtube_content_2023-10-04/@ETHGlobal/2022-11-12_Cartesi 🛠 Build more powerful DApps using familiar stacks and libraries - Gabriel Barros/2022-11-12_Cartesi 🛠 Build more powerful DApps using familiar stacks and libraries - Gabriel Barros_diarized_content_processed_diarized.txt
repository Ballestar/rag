00:00:06.250 - 00:00:29.362, Speaker A: Let's get started. So for today, I'm going to be presenting to you a little bit about optimistic relapse and also how Kurtesi uses it for our technology and what it can offer to whoever builds on it. And first we're going to start with a quick overview of Cartesi, just very briefly.
00:00:29.362 - 00:00:51.870, Speaker A: And then I'm going to compare a little bit Nabar's eye view, the differences between web two, three and how it looks when you build on Cartesi. And then I'm going to explain a little bit about roll ups. Finally, I'm going to present to you a very simple small sample code of our Cartesi DAP written in Python.
00:00:51.870 - 00:01:17.110, Speaker A: So here is a DAP written in Python that works right now inside the Cortesi machine. I don't expect you to understand it right now, but it's just to show that it's simple, plain Python. And you can have libraries, you can have interactions within the machine, you can have access to other APIs that you develop.
00:01:17.110 - 00:01:39.340, Speaker A: So it's really a server used as a DAP. So Cartesi is a foundation that has been working on this since 2018. We've been a while building stuff, so it's not just some new company coming up when roll ups showed up.
00:01:39.340 - 00:02:07.240, Speaker A: And the team has been building this machine for a long while and then the rollaps technique appeared and it just feeled like a glove. So we adapted the machine to be a roll up solution and scale Ethereum. So the main idea behind Cartesi, but I guess to some extent our roll ups is that Ethereum is awesome.
00:02:07.240 - 00:02:34.678, Speaker A: There is a lot of interesting stuff about it, namely like it is secure, it's censorship resistant, it strives to be decentralized and that's really good, but that comes with a lot of consequences and costs. It is low, it gets to be very expensive. And that means we are always building a process of gentrification of the network.
00:02:34.678 - 00:02:48.494, Speaker A: So we are evicting DApps. They are not profitable, even though they may be important for the communities and for the newcomer developer Is Cumbersome. Because you need to understand about machine architecture.
00:02:48.494 - 00:03:19.370, Speaker A: You need to learn how the EVM works and then a new language like solidity Viper and even low level stuff if you actually need to go that far. So it limits you in several ways, even though it brings a lot of new interesting features. So the main idea is like what if we could have complex computation inside a blockchain and maintain security guarantees.
00:03:19.370 - 00:03:43.778, Speaker A: So the criteria solution is transparent VM. So instead of being another EVM based network, a side chain or even a roll upset, we have a Risk Five emulator. Risk Five is an instruction set for a generous purpose processor, just like the ones on your hand for your computer or your phone.
00:03:43.778 - 00:03:58.954, Speaker A: So you can think of it like a docker machine of sorts or a VirtualBox. And we made it deterministic, so we got something. Risk Five is open source open hardware to be more specific.
00:03:58.954 - 00:04:20.000, Speaker A: So we got it from the community and we made it deterministic and we applied it to blockchain. So here's things that you get. So like any company in person can build on top of risk five, it's auditable, it's more secure because of that because a lot of people have been working in this project.
00:04:20.000 - 00:04:37.718, Speaker A: It's a platform perceptor, like I said, so you can run an operational system inside it. So that's why we were able to port Linux to the blockchain, we made it deterministic. So that means you can dispute any computation that happens on it.
00:04:37.718 - 00:05:12.358, Speaker A: And of course, because it is a full machine, it's very able to do massive computation and you can expand on it like you would do in any server or server application. The main difference between most optimistic rollups and what we do at Cartesi is like we have a local consensus. So if you think about Ethereum, the more computers you add to the network, you're adding on security decentralization, but you're not adding processing power, you're not adding throughput.
00:05:12.358 - 00:05:47.062, Speaker A: However, with local consensus or DAP specific roll ups, what you have is DApps that don't fight for the resources, they don't fight amongst themselves, they have their own sets of validators. What that means is now the more DApps you have out there, you're actually increasing the overall capacity of Ethereum to process things. And that is all really good and possible because of the dispute protocol.
00:05:47.062 - 00:06:18.294, Speaker A: So whenever you have a problem, whenever there is a disagreement between validators, it is not a majority consensus, it really goes back to Ethereum and uses it as a judge. So the same emulator I just talked to you about, the one risk five that you can run on a machine for Cartesi node is also implemented in solidity for the EVM. So whatever process you can do off chain, you can do on chain as well.
00:06:18.294 - 00:07:01.730, Speaker A: But with this verification game dispute you actually go down to the very instruction cycle that you disagree with the other node and you only need to prove one instruction cycle on the Ethereum machine and that is possible because the machine is all mercalized. So you know exactly what the instruction cycle needs to access, like the memory states and you just need to upload this section of the machine and all the worker proofs for it. That means that even if there is collusion among validator nodes of a specific tap, as long as you have one honest validator, you can go back to Ethereum and have the correct settlement.
00:07:01.730 - 00:07:23.034, Speaker A: So how does optimistic roll ups actually work? Any roll ups in general but specifically. So you start with the Ethereum blockchain and whatever you do, you're always making state transitionings inside the main chain. The roll ups, it changes a little bit.
00:07:23.034 - 00:07:46.718, Speaker A: So you go there to a certain block and you basically state the initial state of your computation outside you say hey, I'm starting a new machine here and this is the state. And people who join your roll up, basically they are agreeing with you that the initial state is correct. Then you state outside for amount of time that you specify.
00:07:46.718 - 00:08:08.470, Speaker A: Mostly nowadays we've been using seven days because of the security guarantees of it. So for seven days you go on doing things off chain. When the time is up, you go back to the main chain and say hey, after all that's happened, this is the new state of the machine and people have the chance to verify whether or not you're telling the truth.
00:08:08.470 - 00:08:28.538, Speaker A: If they disagree, they can go back and do the dispute and fight you on exactly where you might have been wrong. However, if they agree after seven days everything is settled. All this computation do not need to happen again inside Ethereum.
00:08:28.538 - 00:08:43.134, Speaker A: So that's why optimistic rollups, they expand the main chain. They are tied to in computational resources. So the overview here's just a baseline.
00:08:43.134 - 00:08:56.114, Speaker A: So you always have some kind of UI, mostly nowadays browser. Then you have the software for the browser that you want the UI to work with. Then you're going to have a connection.
00:08:56.114 - 00:09:09.690, Speaker A: It can be a socket connection, it can be HTPs. For instance, with a set of servers they are centralized and they connect to a set of databases that are centralized as well. That's how web two works.
00:09:09.690 - 00:09:28.850, Speaker A: Mostly. We are very familiar with that web Three, especially with Ethereum, it changed the landscape because now your business logic doesn't leave anywhere physically, it's in the blockchain itself. Supposedly everybody's running their own nodes so they can just communicate with their node local nodes.
00:09:28.850 - 00:09:55.674, Speaker A: Honestly though, we know we've been using infuria too much, we've been using Quick node and whatnot it is, what it is. However, it's much more secure because whenever there is any issues, anybody can just spin up their own full node or even light node and make sure the information they're receiving is correct. With Cartesi, it's very similar here.
00:09:55.674 - 00:10:04.074, Speaker A: I just did a very clean version of it. We're going to break it down. But you still are connecting to nodes just like Ethereum nodes.
00:10:04.074 - 00:10:21.934, Speaker A: So supposedly people should be running their own validator reader node of their DAP. They are connecting to and inside a Cartesi machine. I made sure to have this image over here because we are used to the EVM.
00:10:21.934 - 00:10:38.438, Speaker A: But how would a docker like machine work? Right? So there is no access to the internet. I need to stress this point a lot. So because it's a Linux server doesn't mean it needs to have internet connection.
00:10:38.438 - 00:10:57.102, Speaker A: It communicates through the blockchain and that communication happens using Linux drives and that's cumbersome and difficult to use. So instead of teaching you how to use the operational system to that level, we've created this HTP dispatcher. It's an API that's running on site.
00:10:57.102 - 00:11:23.350, Speaker A: A machine that wraps up all this complexity and just changes it into several four endpoints that are really simple to use. So by just doing ras communication with these four endpoints, you can receive information and output information back to the blockchain. So now it's the blown up version of it.
00:11:23.350 - 00:11:39.770, Speaker A: So first you still see the JSON RPC over there and that's because we have the data availability problem. So blockchain is both data and computational power optimistic roll ups. They're not solving the data problem, they're just solving the computational problem.
00:11:39.770 - 00:12:02.846, Speaker A: So what it means is if we are playing chess in a roll ups, you still need to be able to prove that the moves happened. So if we don't have the base layer as a data availability source for the information, it means people can cheat by just denying information. So let's say I'm playing someone here and they are about to lose.
00:12:02.846 - 00:12:26.166, Speaker A: They can say no, I never did this move, how am I supposed to prove that they actually did it? Now you post this information to Ethereum and now you have a proof that they actually did the move in the chessboard. So that's why we still have the Gsmrpc communication. So it's still communicating with the Ethereum node and people should be posting their transactions eventually.
00:12:26.166 - 00:12:46.878, Speaker A: If you think about other solutions, other projects that have the same solution, so like Arbitrarium or optimism, you're going to see they use sequencers for that. But effectively what they're doing is posting the things to the Ethereum network. And then the very end you see there is a graphical API.
00:12:46.878 - 00:13:04.840, Speaker A: So this graphical APIs, it is useful for you when you're handling the UI, what is being sent, what is being produced from the node. So we have three main outputs from the Cartesian node. We have a report which is basically just a log.
00:13:04.840 - 00:13:27.434, Speaker A: If you're running the node you can still access the full log of the process. But it's really good way of having a clear and clean access to the machine when you are using other processes. So report for instance, is very useful, sorry, it's very useful as an Ethereum call, for instance.
00:13:27.434 - 00:13:39.540, Speaker A: So if you're checking a balance of your C 20, you don't want to make a transaction, you just want the EVM to tell you what is the balance at the current state. So you can generate reports for that. We're going to see this.
00:13:39.540 - 00:14:01.670, Speaker A: A notice is like an Ethereum event. However, with spin you can prove that the event happened. So if somebody creates a game and there is like events about winners and losers of the game and suddenly another project shows up and say, you know what, I want to create a badge for whoever wins ten games.
00:14:01.670 - 00:14:17.086, Speaker A: Now the person has a problem because how they are supposed to use the Ethereum events to prove they won't. You can't do that on chain. However, the notice that you produce here on the Cartesian machine is tied to the cartesian machine state.
00:14:17.086 - 00:14:24.782, Speaker A: So you have a Merko proof that the notice happened. So it's really useful in that way. The Voucher is just like the notice in that sense.
00:14:24.782 - 00:14:37.282, Speaker A: So it's provable, but it's also going to become a transaction. So we call it Voucher because you still need to wait for the seven day window. So it's not truly a transaction until the moment it is.
00:14:37.282 - 00:14:57.654, Speaker A: So whenever the roll ups is settled as a user or as a developer, you can automatize that as well. You can pick up the Voucher, for instance, a withdrawal request, and go to the system, to the roll up system and say, hey, I have a valid Voucher, I would like to execute it. So it becomes a true transaction on Ethereum.
00:14:57.654 - 00:15:08.618, Speaker A: So you can use that to interact with other smart contracts and DApps. And finally we have the HTP rest there. And that's your direct communication with the node.
00:15:08.618 - 00:15:32.150, Speaker A: So the Ethereum call was talking about would be actually done through the Inspect request. So you send a quick request to the machine, it's going to wake up, spin up, do whatever you program it to do, and die and roll back to the initial state. So it doesn't affect the internal state of the machine long term.
00:15:32.150 - 00:16:02.730, Speaker A: So it's really useful for populating UI data. It's useful for you to be debugging the internal state of your program and whatever else you can think that this does not need to transition the state. So going back to the code I showed you before, you're going to notice at the very beginning, I'm sorry, 1 second that we are actually importing Python libraries.
00:16:02.730 - 00:16:10.980, Speaker A: This is not a Python like library. This is not a Python domain specific something for blockchain. This is truly Python running.
00:16:10.980 - 00:16:30.810, Speaker A: It was just compiled for RISC v. On the yellow side, we created a utility for people, a CLI that it's based on hard hat, by the way, that helps you send quick data to the machine. So you don't have to be developing your own scripts just to test things out.
00:16:30.810 - 00:16:52.794, Speaker A: So here we are basically creating a new transaction and sending hello there payload. And then you can use the same CLI to list any new notices, new reports, or Vouchers that was created since you last called it. So here I have an example of a Python layer called DAP.
00:16:52.794 - 00:17:12.630, Speaker A: So it's supposed to send back whatever I send it to it. So going back there, you're going to notice that I grabbed the information for the Http dispatcher was talking before the Rest API. That makes things easier from the environment, so you don't need to hard code it anywhere.
00:17:12.630 - 00:17:29.258, Speaker A: And here I'm signing up two types of handlers. So there's two high level of handlers inside a cartizing machine when it comes to these requests. One is the advanced state.
00:17:29.258 - 00:17:40.938, Speaker A: So that's those ones I was talking about. Whenever there is an input, you're actually going to change the state of the machine. And the Inspect state is those that come from the Http Inspect request.
00:17:40.938 - 00:18:09.098, Speaker A: I just talked about the Ephemeral stuff and here comes the most important request in this program. So whenever you start this program, you're actually starting things up, like registering, starting your process, heating up the machine in a way. So basically the very first time your machine wakes up, you need to tell the architecture that it is done, it's ready.
00:18:09.098 - 00:18:25.738, Speaker A: It's like deploying a new contract. So you call this Finish Endpoint over here. So what it does is tells the wrapper that I told you, it gets that information and tells the framework that it's ready to accept new requests.
00:18:25.738 - 00:18:46.790, Speaker A: So from the perspective of your code, the machine went to sleep over here. So the line 24, your program dies for a second whenever there is a new request, wakes up exactly at the line 24 and resolves the post request. Returning to response their new request.
00:18:46.790 - 00:19:03.980, Speaker A: Now we just unwrap the JSON request. We check what type of request we have, which is of the type advance or Inspect. Since it is an input that I've sent, it's going to be a Handle advanced type.
00:19:03.980 - 00:19:17.966, Speaker A: So we're going to go there to the function. You're going to see them grabbing the data from the data, the payload from the data I just received, and I'm just putting it back into a new notice. So I'm creating a notice right now.
00:19:17.966 - 00:19:34.034, Speaker A: I'm not going to do anything with this data because it's an echo. And now I just need to call the notice Endpoint to create a new notice. With that, I've basically concluded most of the things that this needs to do.
00:19:34.034 - 00:19:45.880, Speaker A: So line nine is just making sure that I finish with an Accept state. Because if you reject, you roll back the machine. So you're going to see that in line 27.
00:19:45.880 - 00:20:01.740, Speaker A: I'm sorry, go forward. Yeah, lines 27, I'm just refilling the finish status with Accept. And because we are in a loop, I'm going to go back to the finish state.
00:20:01.740 - 00:20:13.520, Speaker A: So I'm going to go back to the post on 1 second, I'm going to go back here and queue the machine again. I'm just telling the framework I'm done. I've done all the process that I needed.
00:20:13.520 - 00:20:27.758, Speaker A: If I was sending an Http request, you would come here to the Handle Inspect. In this case, I can only produce reports. So like I said, notices and vouchers, they come with proof.
00:20:27.758 - 00:20:35.814, Speaker A: And because this is going to be rolled back, there is no proof for those. So you can create as much as you like. It's just not going to do anything.
00:20:35.814 - 00:20:41.994, Speaker A: The framework doesn't enforce you. It does not break your machine. Just don't do anything.
00:20:41.994 - 00:20:57.280, Speaker A: So here I'm creating a report. And if I were to list the reports later, I would see on the other side finish Accept. Now supposedly I would be listing the new notices and you would see the payload over there.
00:20:57.280 - 00:21:28.834, Speaker A: That's it for the workshop. I'm open for questions now if you have some. So she asked me if I can change the state of a smart contract on chain while the operating system so yes, but through the Voucher.
00:21:28.834 - 00:21:54.298, Speaker A: So let's say I need to transfer tokens to somebody. We create a Voucher that will be later executed and the execution of a transaction is actually changing the state of a smart contract, right? So that's how I would talk back with native Ethereum DApps. So we saw there that we have inputs being sent to the machine.
00:21:54.298 - 00:22:13.894, Speaker A: How that is possible on the Ethereum network, we are actually deploying a set of contracts for the roll up architecture. And the set of contracts are actually an alias for the off chain code you see here. So this DAP, this Cortesi DAP actually has a ethereum address.
00:22:13.894 - 00:22:36.710, Speaker A: Whenever you interact with it, it's actually an input. And whatever Vouchers get executed, it's executed with the message sender from that address. So all the other DAPs understand that it's coming from this address, that it doesn't know what it is exactly, but it's basically the correct answer to DAP.
00:22:36.710 - 00:22:59.280, Speaker A: So there is an alias, there a proxy and an alias at the same time. Does it make sense? Yes, sir. So it's not private key based.
00:22:59.280 - 00:23:10.946, Speaker A: So it's a set of Validators. Right? So you have a set of Validators. They're enabled to interact with that and act as owners, so to speak.
00:23:10.946 - 00:23:27.190, Speaker A: But it's also a voting in a sense. That's why you have the seven day window. So if anybody has anything they see is wrong, they can dispute that and you can keep disputing for a while until you get to the correct state.
00:23:27.190 - 00:23:33.740, Speaker A: And that means no bodies is the owner. Exactly. But there are responsible people for that.
00:23:33.740 - 00:23:58.814, Speaker A: Does it make sense? It's like a voting season in a way. But you ensure that execution is correct because you have the Emulator on chain as well. Resources for so that's a good question because it is an app specific roll up.
00:23:58.814 - 00:24:16.070, Speaker A: As a developer, you define what is the requirement. So if it needs to run on a calculator, just don't use too much resources on your DAP. But if you needed to do like machine learning or something, it can be as beefy as you want your Validator node.
00:24:16.070 - 00:24:44.720, Speaker A: Yes, but you need to be mindful as you are developing. Like what kind of nodes do I want to have? Do I want to have all my users running it? So if I want my users running it, maybe I don't should be putting the node to be so beefy, right? Otherwise simple computers won't be running it. So it's like on the DAP developer to decide what they want.
00:24:44.720 - 00:25:04.440, Speaker A: Because of the other slide I showed, like this one, every DAP is its own little network in a way. So you decide. Yes.
00:25:04.440 - 00:25:18.698, Speaker A: So if you say that's only going to be like two validators. Sure. Might be like a chess game and that's fine if you want something that is a bit bigger but ten is fine.
00:25:18.698 - 00:25:29.950, Speaker A: Sure. Then if you want to have something that everybody is able to at least validate then you need to be mindful of that. But there's no like intrinsic limitations.
00:25:29.950 - 00:25:51.600, Speaker A: Just like docker in a way. Are we good? So we are here throughout the whole weekend at the table. You are so welcome to visit us and ask us any question.
00:25:51.600 - 00:26:00.270, Speaker A: So at the very end have a link tree for cartesi here if you want to check documentations medium and why not? Thank you.
