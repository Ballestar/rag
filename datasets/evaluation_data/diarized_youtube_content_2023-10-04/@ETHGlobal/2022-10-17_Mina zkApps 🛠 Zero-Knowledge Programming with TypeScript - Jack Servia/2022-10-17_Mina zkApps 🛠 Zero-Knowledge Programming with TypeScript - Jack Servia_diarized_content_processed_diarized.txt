00:00:06.170 - 00:00:38.998, Speaker A: Hi everybody, and welcome to our presentation on Snarky JS and the Mina Protocol. Thank you for being here. And I am Jack Servia. I'm a developer relations engineer at O One Labs, which is the company that incubated the Mina Protocol. So you can kind of think of One as like consensus to ethereum, whereas Mina Foundation is Ethereum foundation to ethereum. I'm based in Denver, and here's kind of what we're going to go over today. So first we're going to talk about Snarky JS, which is the smart contract language for the Mina Protocol and kind of unique for a bunch of reasons we'll get into.
00:00:38.998 - 00:01:20.630, Speaker A: And then we're going to go through an example where we build a simple smart contract that verifies that the number you pass in as an argument is the correct next number in the Fibonacci sequence. Then we're going to make this recursive, which is something we'll kind of explain why that's cool later. But it basically allows you to do a lot of stuff off chain without any additional security assumptions. Then we'll talk about the Mina Protocol, which is sort of like a meta version of this. It's like a settlement layer for these zero knowledge applications. And then we can talk about where to learn more and open up to questions and answers. So, Snarky JS, it's a TypeScript library for defining zero knowledge proofs, and it's also the smart contract language for the MENA Protocol.
00:01:20.630 - 00:01:42.806, Speaker A: It looks like this, but don't worry too much about the code right now. We'll get into it more in a minute. Everything is in TypeScript. So you can keep using the tools you're familiar with, like prettier NPM vs. Code, ESLint, et cetera. And it's really easy to learn. It's actually so easy to learn that you can probably figure a lot of stuff out just with IntelliSense.
00:01:42.806 - 00:02:09.698, Speaker A: If you look here, we have an example of kind of a funky looking decorator and then a really good explanation of what this is. So you can just dive straight into it. And it's also extremely powerful. So this is for two reasons. One is our proof system, which is something that we've built in house. It's called Kimchi, and it has a number of features that make it really well suited to a kind of application like this. It's fully trustless setup, so there's no ceremonies.
00:02:09.698 - 00:03:00.280, Speaker A: We have custom constraints for poseidon, which is a hash function that's particularly efficient in zero knowledge proofs, elliptic curves and encryption. We also have constant proof size. That's why OVone Labs is called OVone Labs and it's recursive, which means that we can generate a zero knowledge proof of something and then we can actually verify that zero knowledge proof inside of another zero knowledge proof. And so this opens the door to a whole bunch of new architectures for things that can increase scalability user experience and of course, also provide privacy. Finally, it's Plonkish, which means that we can add new features like dynamic array access, which is something we're working on. So Kimchi mostly should kind of not be something you have to worry about too much, but just sort of know that we've put as much horsepower as we can into Snarky JS. And so the other side of what makes Snarky JS so powerful is actually the language itself.
00:03:00.280 - 00:03:40.494, Speaker A: TypeScript method chaining allows developers to think through their programs in a very linear way, especially compared to other zero knowledge proof sort of paradigms. And so we can sort of see what this looks like. Here we have this bool is correct color. We can just call and on it and pass in the thing that we want to and it with and what we get out is another bool is white peg. And if we want to do something more complicated we just chain these methods together. And so this makes it very straightforward. Think about this is my data, this is what's going to happen to it and then this is sort of what's going to come out and it makes it easier to make sure that everything that you're doing is being sort of proved correctly, which makes it easier to write code that's secure.
00:03:40.494 - 00:04:26.526, Speaker A: Basically. We also have custom circuit values and these have actually been we're in the process of possibly changing this to something called Struct. You can go look at the GitHub and read the RFC for this and leave comments if you want, but for now I'll explain how circuit value works. Struct is largely the same thing, just better. But even circuit values are very cool and so these provide a layer of abstraction that makes data much easier to think about than it might be otherwise. What this looks like is we can take in zero knowledge truce. Everything fundamentally because of the cryptography has to be represented as something called a field element which is just sort of like a UN two, five, six with some special properties but it's required by the underlying cryptography.
00:04:26.526 - 00:05:27.154, Speaker A: And so trying to represent more complicated data types in other zero knowledge proof languages can be quite hard. Snarky JS makes it fairly easy with this circuit value maybe soon to be struck, which allows you to basically describe a way to turn normal JavaScript values, normal JavaScript variables, numbers, strings, whatever, into fields and then take them back from fields into something you can work with. And so in this case we have defined one called Pegs and this represents four pegs in a board game and we can work with them sort of just the same as you'd expect. Finally, plenty of the stuff that you need is already implemented in Starkey JS. What we have today is support for a bunch of different types that are built on top of this field type. So the field type can be a little complicated to work with sometimes, but what we can do is we can actually compose field types into other things that are more familiar. And so we have types for UN 64, UN 32, Int 64, group Bool, scalar, public key, private key, signature and more coming soon, including hopefully string pretty quickly.
00:05:27.154 - 00:05:59.950, Speaker A: We also have efficient poseidon hash function which means that we can do hash evaluations very efficiently in Snarky JS. And this opens the door to things like big merkel trees and other kind of stuff like that. We have efficient encryption and decryption. So you can do things like take data well, actually we'll jump back to this in a second. We have signatures. Merkel trees are supported in the experimental API right now, which is just a namespace in the API that has stuff that's bleeding edge. And we have the Recursion API, which is something we'll talk more about later in this presentation.
00:05:59.950 - 00:06:43.206, Speaker A: Signatures and encryption and decryption are unique, and I'll just sort of call them out now. Because what you can actually do with this is take a value from a trusted source, they can sign it, and then you can pass this value into Azero knowledge proof verify that it was signed by the trusted party, and then you can augment it in some way. So you could do something like prove I am not a citizen of the United States, I'm over the age of 21 and I'm not ofax sanctioned. Or you could prove the opposite. It's up to you. So why did we choose TypeScript? This is kind of a common question and the answer is because we're ecosystem focused. So the idea is that people who want to work on tough cryptography can do this and they can put their stuff in NPM libraries very easily.
00:06:43.206 - 00:07:30.714, Speaker A: And then people who want to build user facing products can import this and have access to a whole lot of power really quickly. We want to kind of get both of these groups of people working together in order to sort of really push forward a new class of applications. We're looking for code reuse that's as high as it is in the JavaScript ecosystem. The other thing that I think is worth calling out is that if TypeScript sounds a little bit like what would you say? Some people have maybe a problem with TypeScript if you're writing your front end, writing a Snarky JS smart contract is only nominally more work. So how actually the smart contract works is actually I'm sorry, we'll dive into this a little bit more later. I keep getting ahead of myself. For now we'll just stick to this.
00:07:30.714 - 00:08:09.640, Speaker A: So this is Snarky JS We've been through all this. How does it work? Well, here it is in five sentences. It's a TypeScript library. All the information is represented in one of the Snarky JS compatible types. So these are all composed of the field type ultimately, but like know we know how to turn that into field so everything is under the hood fields or an easier way to work with fields, one of the circuit values that's composed of them. Circuit JS provides classes and functions that are compatible with the field type or these circuit values that are composed of them. So we can do things like add two numbers together, but not only can we add the numbers together, we can prove that we added numbers together correctly without revealing what they were.
00:08:09.640 - 00:08:46.082, Speaker A: And this is sort of this next thing. So, Sharky JS, after we've written our program, it can represent any operations on the field type is what's called a Kimchi arithmetization, which is basically a math problem that represents the program that we wrote. And this is important because the zero knowledge proof system is itself kind of a math problem. And so we need to turn everything into math in order to be able to prove that we're doing what we say we are. And then finally, a user that interacts with the Snarky JS program can generate a zero knowledge proof that their interaction was legal. And this opens the door to a lot of cool things. One of them is Snarky JS smart contracts on Mina protocol, which we'll dive more into in a little bit.
00:08:46.082 - 00:09:34.210, Speaker A: So in this paradigm, developers write smart contracts in TypeScript and they deploy the verification key to a Zkap account, which is just a specific kind of account on the MENA protocol. What this looks like is we write our application, we send a transaction with a verification key, which is just an artifact that's generated. You can think of it as sort of like a commitment to our code with extra features, which is that we can use this key to verify zero knowledge proofs that we generate for this code. And only this verification key lives on Mina. So then the user will run the smart contract in their browser and they'll generate a zero knowledge proof of their interaction, proving that it was allowed. And then they'll send this proof to Mina. And if Mina will check it against the verification key that's stored on chain, and if it passes, then the transaction goes through, and if it doesn't, then it fails.
00:09:34.210 - 00:10:21.090, Speaker A: If the transaction does go through, then it commits any of the relevant state updates that were associated with the proof. So when we do something with a Mina smart contract, the smart contract is sort of getting in as arguments, the arguments that the user passes in some smart contract state. This is the state of the smart contract prior to the user interacting with it and some values from this state of the world. This could be like block height. And so the smart contract will actually run in the user's browser. The user will get all this information themselves, they'll pass it in and they get a proof out, as well as the new state of whatever value they were interacting with. So if I want to send you money, I can literally just say I'm going to basically write to your token balance and here's a proof that I'm allowed to.
00:10:21.090 - 00:10:42.490, Speaker A: And that's all that's needed. That's a rehash of that. So how do these Ek apps work? Well, you install your smart contract in your UI and then you deploy it and that's all. And so, yeah, you can just publish your smart contract on NPM or GitHub or wherever. You can just NPM, install it, import it like you would anything else. And it's a part of your UI. It's very straightforward.
00:10:42.490 - 00:11:12.830, Speaker A: So now we'll kind of get into an example. And this is hopefully everybody is familiar with the Fibonacci sequence. If you're not, the last two numbers in the sequence added together equals the next number in the sequence. So one and one, two, two and one, three, so on and so on, three and two, five. So we'll write a smart contract that calculates the next number in the Fibonacci sequence. And also, don't worry if this goes a little bit, we'll be at the booth. We're upstairs on the second floor in the corner.
00:11:12.830 - 00:11:33.946, Speaker A: And if this is sort of obfuscated at some point, come talk to us and we'll make it clearer. But the point is now just kind of broad strokes. So we'll have two pieces of state that we store in the smart contract. This is going to be N minus two and N minus one. These represent the last two numbers in the sequence. If we have a method. So we'll also add a method update which will let us update n minus one and N minus two.
00:11:33.946 - 00:12:08.306, Speaker A: If we pass in the correct number, the next number in the sequence. So in order to do this, all that we do is we extend this smart contract class into something called Fibonacci Sequence. And now we have a smart contract called Fibonacci Sequence. Then we add some state and we call it N minus one and N minus two. We set it to the field type and we use the state decorator, which if you're not familiar with TypeScript decorators, again, come get us. They're not too hard to get your head around. But what this basically tells Snarky JS is, hey, when a user alters this value, figure out how to store it on chain and prove that we're updating it correctly.
00:12:08.306 - 00:12:47.070, Speaker A: And so these numbers will be stored on chain. The next thing that we have is this deploy method. This is a method that gets called at the time that the smart contract is getting actually deployed to the chain, which is at the time where we're calculating this verification key and bundling it up into a transaction and sending it off to the chain. You usually don't have to worry too much about this. The defaults work nicely in most cases. But in this case we're going to use this deploy space to initialize the values of our state variables. And you can do other things here, too, like set permissions.
00:12:47.070 - 00:13:09.640, Speaker A: Again, we won't dive into it too much. But all that we do is we call this and minus two and then we call the set method on it and we pass in a value. And in this case we're passing in field zero. Don't worry about this zero one. You can also pass in field open parentheses, one closed parentheses. It does the same thing. This is a confusing kind of artifact that exists right now.
00:13:09.640 - 00:14:00.360, Speaker A: So next thing that we do is we define a method that users can use to interact with the Smart Contract and we just call it method. I'm sorry, we call it update and we add the method decorator and the method decorator basically says, hey, this is a thing that users are going to call when they do prove that they're doing it correctly. We can pass in an argument N that will be the next number in the sequence. And what we do is we grab N minus one and N minus two from on chain state. We store them in local variables, then we add N minus two to N minus one. And we check that the value that we passed in as an argument is equal to this addition of these last two numbers in the sequence. And so this assert equals it actually means that you will simply not be able to generate a valid zero knowledge proof if new state does not equal N.
00:14:00.360 - 00:14:47.094, Speaker A: And so there's no way for a user to call this unless they're passing in the correct argument. Now, what's really cool, and I don't know if this was sort of clear by now or not, but the value of the argument that the user passes in and all the computation that they do is private. They don't ever send it out of their browser unless they want to. So the only thing that is public is the on chain state. And you can build a lot of private applications very easily by storing a commitment to something private in the form of, I don't know, hashing some private value and storing the hash on chain. So yeah, I guess it's not useful. In this case, we can prove that we know the next number in the Fibonacci sequence without well, in this case, I guess we do reveal what it is because it becomes N minus one.
00:14:47.094 - 00:15:36.790, Speaker A: But you get the picture. There's a lot of cool stuff you can do with this. Now, the final thing that we do is we set these on chain states to we move N minus one to N minus two, and we move the new state to N minus one. This is pretty much the basic structure of the Smart Contract. We extend the Smart Contract method, we add our state definitions, deploy method, and then we add the user callable methods and add the method decorator to them. So what's really cool about this architecture is that we can actually make this recursive. And what this means is that right now, the current Fibonacci program that we just built, every time a user wants to interact with it, every time a user wants to do something, they basically have to create a transaction, send it to Mina, pay the fee, and wait for it to be mined.
00:15:36.790 - 00:16:00.590, Speaker A: This is what's really cool about recursive zero knowledge proofs. They allow you to move away from this in really interesting ways. So we had smart contract, but we also have ZK program. And ZK program is what it sounds like. It's just a zero knowledge proof program as opposed to sort of a zero knowledge proof program. That's also a smart contract. And so what we can do is we can write a ZK program that actually takes proofs as inputs.
00:16:00.590 - 00:17:00.610, Speaker A: So the ZK program, we run it and we get a proof out. And that proves that we ran the ZK program correctly as well as the outputs. But we can actually also pass these proofs so we can pass proof that we ran a ZK program correctly into a ZK program. And this lets you scale in really cool ways. And so I won't dive too much into what this is now because I think we'll be a little bit short on time and I want to get to Mina, which is really the sort of important part of this. But to give you an idea of why this is useful, we can basically yeah, we so we can what would you say? We can prove that we have a number in the Fibonacci sequence and we can take that proof and pass it into another proof that verifies it. And so this can be useful for something like, let's say we wanted to take a moving average of values over like 20 years.
00:17:00.610 - 00:17:43.246, Speaker A: What we could do is we could take the moving average for the last 10 minutes, prove it, and then take the moving average for the next 10 minutes, prove that but in that proof, we can also include the computation that verifies that the first proof is correct. And we can do this over and over and over again. And we can just keep one proof that attests to the fact that we've had been keeping a correct moving average for 20 years or something and it stays very small. The other thing you can do is you can create like, well, we'll get into it in a second. So how does this work? Well, you write your ZK program, or sorry, you wrap your ZK program inside of a proof class, and then you pass the proof as an input parameter to your ZK app to verify that it's correct. Again, this was kind of fast. We went over this really quickly.
00:17:43.246 - 00:18:26.090, Speaker A: But if you have any questions, seriously, come by the booth and stop us. We'll help you get started building something or just answer any questions you have. So this kind of brings us to the climax of the presentation, which is what is mina? And actually, wait, I'm sorry, I'm going to go back. I know this is very nonlinear, but another thing that we can do with recursion is we can build smart contracts that execute largely off chain. And so an example of this is like, let's say that we built a game, and I don't know if anybody has heard of the game Mastermind, but this is a tutorial that we did a while ago. Sorry, not a tutorial, a workshop that we did a while ago. And we have it recorded.
00:18:26.090 - 00:19:05.658, Speaker A: And so at the end of this presentation, there'll be a QR code that will take you to a bunch of relevant links and also that. And so this is a game where it's limited information, so I can't know what my opponent is doing, but I have to know that they're making legal moves. And so this is a game that would be very hard to build on a normal blockchain. It's very easy to build on mina, but it goes a step further if you build it in the naive way. You have a game that you have to send a transaction to mina every time a user wants to make a move. But using Recursion, we can take this and we can set the game up in such a way that I will make my move. I'll prove to you that it was correct, and then you'll make your move, which will also verify the correctness of my move by verifying the proof and send your move to me, proving that it was correct without revealing what it was.
00:19:05.658 - 00:19:53.180, Speaker A: And we can do this back and forth, so on and so on, without ever having to pay fees or wait for a block to get mined. So the user experience is literally like it would be in web two. And at the end, we have a proof that attests to the correct computation of all of our whole game, and then that can get settled on chain. So this is obviously really good for user experience and also really cool. Okay, now we're back to where we were with what is mina protocol? Well, it's a layer one blockchain that proves its entire finalized state using Recursive zero knowledge proofs. And because of that, it stays small. You only need 22 KB in order to verify basically that the current finalized chain state for an account is correct.
00:19:53.180 - 00:20:23.300, Speaker A: This is cool, but it's also really useful for quite a few reasons. One is privacy. As we said, Ethereum smart contracts are on every node, so all the information is public. Here's what ethereum looks like. Mina smart contracts run in the browser. And so arguments and intermediary values are private by default. Again, managing keeping the state private if you want to can in many cases be as simple as just hashing it.
00:20:23.300 - 00:20:58.030, Speaker A: So what does this look like? We do the stuff we want to do in our browser. Then we just send state updates and a proof that's it Mina verifies the proof and updates the on chain state if it's correct. Next, scalability. There's no gas model ZK apps run off chain, which means that the amount of computation does not affect the transaction cost. You can do, in theory, an unlimited amount of computation in a single Mina transaction. You can also do them asynchronously, which this presentation isn't about, but is another pretty cool feature. So, yeah, you can run smart contracts asynchronously on Mina.
00:20:58.030 - 00:21:31.846, Speaker A: Again, come to the booth and ask if you're curious about that. So developers can use your cursors to build application specific rollups. What are these? Oh, well, they're what we talked about earlier. I think I kind of forgot the order of some of this. Yeah, these are applications where only the parts that need to be verified on chain are verified on chain. In many cases, you actually don't need the chain to sort of verify what you're doing. Like if you're just interacting with one other user in a game or something, really, you only need to prove to the other person you're playing against that what you're doing is correct as long as you can eventually prove it to the chain.
00:21:31.846 - 00:22:14.594, Speaker A: And so this is a door to some really interesting stuff. Decentralization, it's possible to validate the entire finalized minestate using only a small zero knowledge proof. What that means is that there's no need to rely on trusted third party node operators like infuria right now, ChainSafe is working on an implementation of a wallet that will basically be a full, you know, no additional security, sort of concessions. And how it works is that it just uses the zero knowledge proof to verify the transaction history. Right. With Mina, we do some stuff, we prove that it was correct. So all the transactions are zero knowledge proofs.
00:22:14.594 - 00:23:05.314, Speaker A: And then we take these zero knowledge proofs and we verify them inside of another zero knowledge proof. And inside of that zero knowledge proof, we also verify a zero knowledge proof that represents the last batch of transaction and that one verifies a zero knowledge proof that is also verifying the batch of transactions before that, and so on and so on. And so what we're left with is 10 knowledge proof that represents the entire chain history and proves that it was legal for us to get to the place that we got to, basically. And so then a wallet can just, with this 22 kilobyte stub, verify that the proof is correct and know that things are right. It doesn't have to grab all the previous data and sum it all together like an ethereum node does. This is really cool. Also, because of bridging so Smart contracts on other Chains can bridge the entire Mina state just by verifying the most recent proof.
00:23:05.314 - 00:23:50.246, Speaker A: To get into what this means a little bit more, you can write a Smart contract on another chain. And as long as that smart contract can do the math to verify the mina zero knowledge proof, then you can be sure from within that chain that whatever state route is associated with that zero knowledge proof is the legal mina state route for a given block. So the Nil Foundation is working on one of these bridges right now. They have a demo working on one of the Ethereum testnets, but it really does work. You can go play with it here. And the result of this is that there's no multi sigs. There's none of the really confusing stuff, there's none of the really hackable stuff.
00:23:50.246 - 00:24:21.242, Speaker A: There's just basically a smart contract. Anybody can interact with it, anybody can go grab the mina state, anybody can send the estate to the smart contract, pay the gas fees, and in one block you have got the whole most recent state bridged. Over. Finally Oracles. We're working on a product called Ziki Oracles right now. And these will allow users to create TLS proofs that bridge data from any website onto the MENA blockchain. And so when you go to websites now, you get a little lock in the side of your browser.
00:24:21.242 - 00:24:52.730, Speaker A: This means that we did this thing called a TLS handshake. It's like a thing that allows you to know that you're talking to Amazon and Amazon is talking to you and that nobody's in the middle listening to what you're saying. And the problem is that it's interactive. And so the protocol only really proves anything to you into Amazon. You couldn't send it to Ethereum because it's interactive. Ethereum would have to sort of interact with Amazon for it to work that way. And so with zero knowledge proofs, we can use this interactive sort of protocol and make it non interactive.
00:24:52.730 - 00:25:48.410, Speaker A: And the result is that I can prove that I went to my bank account's website or my bank's website and basically I can prove that the person@usbank.org sent whatever they sent to me and that nothing has been tampered with. And this is really cool because then we can take this information and we can do something like then augment it so I could get all this really personal information, prove that it really did come from US Bank and then just have a boolean that says, does Jack have more than $1? And get a proof that just says jack has more than $1 or Jack doesn't. And so you can make the information sort of as private as you need it to be and no more. What else? Well, we actually don't really know everything that's possible yet. And this is what we're hoping that you guys here will help us figure out. There are so many new ways that we've found that we can do things that we would not have thought of even six months ago.
00:25:48.410 - 00:26:19.574, Speaker A: And yeah, that's what we're hoping to get out of hackathons like this. We hope that you guys try. New things and find new ways of doing things that leverage all of this sort of new flexibility. So what makes Mina protocol unique? All this stuff. Where to learn more? How do I get started? Okay. Yeah. So, yeah, how do I get started? Well, all you do is NPM install the Zkap CLI and ZK project.
00:26:19.574 - 00:26:41.654, Speaker A: It'll start up a repository with a scaffold code, a simple contract that will add two numbers together. And that's all that you need. The Zkap CLI is our only piece of developer tooling. It's very simple, it's very straightforward to use, and it's very powerful. If you want to get started, just do this. There's nothing more, really. It should take 1 minute.
00:26:41.654 - 00:27:13.574, Speaker A: And you can even deploy to Berkeley Testnet, which is our testnet, I think we have cards at our booth that will explain how to do that. Again, should take no more than 15 minutes to get started. Where do you get involved? Well, we have a well, Mina Foundation has a quarterly grants program. So you can get grants by building ZK apps, creating educational content, or mentoring. And so these are backward looking grants. So just do Google stuff and then maybe you'll get a bunch of money or some money. So here's a QR code.
00:27:13.574 - 00:27:35.594, Speaker A: If you scan it, we've got links to a bunch of the relevant stuff from this presentation. We also have our Docs website, which we just revamped, like, maybe a week ago. It's a lot better. Now we have Search and some other stuff that we'd been kind of putting off for a little bit. We have the ZCAP Developers Channel and Discord. This is a really great place to meet other people who are building stuff. Here's our Twitters.
00:27:35.594 - 00:27:36.940, Speaker A: All right, well, thank you so much, guys.
