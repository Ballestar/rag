00:00:01.690 - 00:00:23.790, Speaker A: So before, everything that I would do with the first startup, that was very personal. And if if somebody has criticism, I would be the one crying in the corner or at home because I would take it very personally. Now it's a bit of a better work life balance where there's a separation between what we do, what we're building as a platform, and my personal worth.
00:00:23.790 - 00:00:51.574, Speaker A: For example, there was an approval of the crowd back then, and one example of this, we invested a lot of time and money into making our office really cool. Some people here either been in our office in Toronto and currently it's like more of a disregard of opinions and working from coffee shops or working from WeWork in places like that. Back then, there was more of an investment in appearances.
00:00:51.574 - 00:01:07.380, Speaker A: We paid a huge premium, hundreds of thousands of dollars, to have our sign visible in downtown Toronto so that people would know that we're there. I would not do this now, so there's no need for those nice perks. But back then it was very important to me.
00:01:07.380 - 00:01:22.578, Speaker A: And also back then we had investors that were pushing us to build for growth. This is companies like Andreessen Horowitz and a whole bunch of others that are trying to instigate as massive growth as possible. And now it's more of a build with intention.
00:01:22.578 - 00:01:38.550, Speaker A: So be more focused on solving crucial artists issues that we can that actually make a meaningful impact. And back then, there was lots of drama. So now we're trying to deal with kind of like a little bit less drama.
00:01:38.550 - 00:02:11.058, Speaker A: So as my finishing slide kind of like what are the next ten years? Because it's nice to look in decades, it takes a long time to build something. So we see for the next ten years that there's going to be a lot of interest in keeping art royalties. And it's something that actually exists in some countries on the regulatory level, where whether you're in France or some European countries, if the artist is alive and the art is resold, there are some royalties that are attached to the physical art when it's resold.
00:02:11.058 - 00:02:28.940, Speaker A: So taking a digital and making sure that it's available for 100% of art is kind of important. I think we'll see what I would call ubiquitous blockchains, that everything of importance will be on a blockchain. We just wouldn't know or care whether it's one blockchain or the other.
00:02:28.940 - 00:02:38.218, Speaker A: That also stems from that. Transactions will go from expensive as they are today on ethereum, to cheap and to eventually free. So that's already happening with LTUs.
00:02:38.218 - 00:02:58.482, Speaker A: There's going to be a lot of talks today, but eventually the platform is either going to subsidize those or there will be players that will subsidize the transactions for everybody else. And that's going to be completely free to transact and we're going to have a much better future in that regard. There's also happening when we started with Web Two.
00:02:58.482 - 00:03:05.686, Speaker A: When we started with photo sharing, that was very simple. You share a JPEG, and that's it. Or a video, and that's it.
00:03:05.686 - 00:03:35.534, Speaker A: Now, there is a bit of an evolution in the artistic medium, and people are using, whether it's generative art plus photography or whether it's on chain art that evolves with every transaction. So those things are becoming more important and more interesting for the artist to start using some of the methodologies that only exist in Web Three, like, only the stuff that can actually be on chain. And so those are making a very interesting impact.
00:03:35.534 - 00:03:58.950, Speaker A: And the last two digital displays. So we're currently hosting an exhibition in Italy with our current platform, and the art exhibits around the world are touring from physical to more digital. So it's a physical space, but there's this place, and the artwork is having a clear provenance like who owns it or who can buy it and stuff like that.
00:03:58.950 - 00:04:27.362, Speaker A: So kind of like more likely to see more of those digital screens around the world. So much so that I think people have those in home eventually, or they'll have them in their Apple Vision Pro set. And lastly, kind of like what I mentioned earlier, IRL events like this one, like, getting personally, getting to meet people is super critical, regardless of how far the technology evolves, because it's a fist bump or handshake that can make a big difference.
00:04:27.362 - 00:04:38.002, Speaker A: Meeting those people, sharing experiences is something that we take personally. And with the current platform, we actually talk to every single photographer that's on platform. Almost 1000 people.
00:04:38.002 - 00:04:56.758, Speaker A: We had either phone call or a zoom call or something like that to know them a little bit, to verify who they are, and just to ask them, like, hey, we're humans too. Let's chat, even though some are staying anonymous and they wouldn't turn their camera ons, which is totally fine. So this is the end of my presentation.
00:04:56.758 - 00:05:05.370, Speaker A: If you guys have questions, ask them. If not, I'll be outside as well to take questions and chat about all things building startups.
00:05:05.450 - 00:05:06.320, Speaker B: Thank you.
00:05:16.590 - 00:07:53.600, Speaker C: Thank you. It is muted. Yeah.
00:07:58.130 - 00:08:00.270, Speaker D: Maybe I shouldn't keep it in my pocket.
00:08:03.170 - 00:08:22.520, Speaker C: Nicely in there. Thank you. That.
00:09:21.940 - 00:09:23.810, Speaker D: Let me know when we're good to go.
00:09:29.580 - 00:09:30.730, Speaker B: We'll just get.
00:09:33.940 - 00:09:35.010, Speaker C: Sounds good.
00:10:53.790 - 00:10:57.082, Speaker D: Hello. Okay. Hey, everyone.
00:10:57.082 - 00:11:11.058, Speaker D: I'm glad there's actually a few people here right now. My name is Hardik, I'm from Learn Web Three, and today we're going to be talking about building for the future in an uncertain market. So, quick show of hands.
00:11:11.058 - 00:11:29.606, Speaker D: Who here is a student right now at Waterloo or Laurier or anywhere? Okay, I saw one, two. Okay. Who here is a software developer by trade? 12345.
00:11:29.606 - 00:11:43.866, Speaker D: Okay, cool. And how long have you been in the Web Three space? Roughly? Just raise your hand if it's like, less than a year. One to three years, maybe two.
00:11:43.866 - 00:11:48.510, Speaker D: Okay. And more than three years. Okay, cool.
00:11:48.510 - 00:12:09.842, Speaker D: So this is going to be a little different. It's also been a long time since I've done one of these IRL, so it's nice to be back. I'd prefer this to be more of a discussion than a lecture, so if you guys want to be talking while I'm doing this, I'd love to sort of engage with you, but we'll go forward with it.
00:12:09.842 - 00:12:21.554, Speaker D: So, as said, my name is Hardik. I legally have no first name, so when I'm signing papers, it just goes down as Hardik Hardik, which is weird. I'm a Waterloo, Alum.
00:12:21.554 - 00:12:49.454, Speaker D: I started the UW Blockchain Club back in early 2018, I think. Software developer by trade and currently co founder at Learn Web Three. So being at Learn Web Three, there's some questions I get asked every day and I kind of wanted to take this opportunity to if some of you have these questions or similar along those lines, I kind of just want to talk about that.
00:12:49.454 - 00:13:22.746, Speaker D: So one of the most common questions I get pretty much every single day is I'm just starting out, how do I get a job in this space? Or if you're a student, the second one's probably particularly relevant is every company wants years and years of experience. And how do I deal with this as a new grad? Maybe if you're in the co op program it's a little different, but for most university students, new grads don't usually have years of experience under them. And do we need to grind lead code? That's very common.
00:13:22.746 - 00:14:00.280, Speaker D: And what chain, what language, what protocol, what framework to use? And also is crypto just dead? Do we just do AI now is OpenAI, is going to take all of our jobs anyway? And why are we doing this at all? Or do you want to learn front end, the back end, smart contracts and when AirDrop, we're not going to talk about the last one. So from these, I want to kind of go over these, but there's some facts, but then there's also opinions and then there's things you can do. So fact is, the job market is shit right now.
00:14:00.280 - 00:14:08.618, Speaker D: If you're on Waterloo works, you know about this. If you've been grinding, you know about this. Some companies need lead code.
00:14:08.618 - 00:14:12.650, Speaker D: They will always need lead code. It's just how it is. Some don't.
00:14:12.650 - 00:14:35.650, Speaker D: A good amount of companies want past experience. But if you're a new grad, if you're learning, if you're about to graduate soon, there are things you can do to sort of get around that. And ethereum and sort of EVM esque chains still remain the most popular to build on, if that's the goal you're working towards.
00:14:35.650 - 00:14:47.446, Speaker D: Crypto is not dead. AI is a thing, but crypto is not dead. What you should learn is a bit of a tricky topic and I'd love to dive into that in a little bit.
00:14:47.446 - 00:15:02.186, Speaker D: And no AirDrop questions, that's the facts. But then again, we have some thoughts. Being at learn Web Three, we've had students been hired at a lot of great, well known companies in this space.
00:15:02.186 - 00:15:24.846, Speaker D: Some of them are here in this room right now. We had people hired. I'm not going to list out all of these names, but I kind of know a thing or two about what can you do to sort of being a student, being in a bear market, being in an absolutely terrible job market and sort of getting away with it and still being able to get a job or get funding.
00:15:24.846 - 00:15:30.146, Speaker D: If you're trying to do a startup or along those lines, you get what I mean?
00:15:30.328 - 00:15:32.630, Speaker E: So let's just talk.
00:15:32.700 - 00:15:46.554, Speaker D: Let's just talk. If anybody at this point wants to ask me questions, has a question, has a problem they're struggling with or anything, let me know. More than happy to answer, but let's just talk about the questions I started off with first.
00:15:46.554 - 00:16:25.670, Speaker D: So I think number one we want to talk about is AI going to actually take your jobs? And are you wasting your time learning how to code if you don't already do it professionally? AI is not going to take your jobs. And I think one of the reasons is actually this is something I hate, and this is something I've been talking about a lot more recently publicly, is a few years ago, when sort of this term, Web Three came along, chris Dixon was like, oh, Web Three is read, write, own. And all of these guys were talking about sort of it was gaining popularity.
00:16:25.670 - 00:16:42.342, Speaker D: It never equated to crypto. It never equated to blockchains either. That's a weird issue that we've run into sort of sometime in between over the last few years, where everybody is just like, Web Three means tokens.
00:16:42.342 - 00:16:47.680, Speaker D: Web Three means scams. Web Three means pepe shit coins. There is nothing real in this space.
00:16:47.680 - 00:17:05.620, Speaker D: There's not a dunk on crypto. Big crypto bro here, but is this being extreme? Sorry about that. Okay, so, yeah, Web Three was always sort of meant to be like the next frontier of technology.
00:17:05.620 - 00:17:14.950, Speaker D: It could have been crypto. There's AI, if you saw WWDC, maybe probably vision pro is probably going to be very common in the next few years. Hopefully.
00:17:14.950 - 00:17:41.918, Speaker D: That's one thing I want to clear up. So if you're in this space, there's a lot of beginners who are just like, oh, did I make a mistake learning how to build on Ethereum or learning how to build on XYZ chain? Should I have just spent my time doing data science instead, or should I have just spent my time learning how to use TensorFlow instead? The answer is you don't have to choose. There's no reason for you to pick one or the other.
00:17:41.918 - 00:18:18.038, Speaker D: If we're really working towards sort of what the next frontier of the Internet is, a few years down the line, ten years, 510 years down the line, you're not going to see apps in the mainstream who are just like we do this in a decentralized way or we do this with a chat bot. There's going to be a combinations of all of those things and any sort of dev who's been full time software developing for 10, 20, 30 years now, if you know anybody like that. When they started off tech looked very different than what it looks like today.
00:18:18.038 - 00:18:27.134, Speaker D: A lot of the things we use today, a lot of the things they even teach you in school today probably didn't used to exist back then. That's going to change. And this is just something I wanted to rent about.
00:18:27.134 - 00:18:36.382, Speaker D: I've been renting about this a lot recently. That's one of the things. And what else? Lead code.
00:18:36.382 - 00:19:07.378, Speaker D: If there's a lot of Waterloo people here who probably have strong feelings about lead code one way or the other, I don't know if you've seen this problem come up if lead code is important or not, but that's whatever. I want to answer the second question with what to do about not having years of experience. Again, if you're the target audience for this talk, this might be relevant to you where you may have co ops, but internships are not the same thing and you may not have co ops.
00:19:07.378 - 00:19:39.300, Speaker D: You may be in a non co op program. How do you get hired in a job market that's terrible in a bear market where tokens are all down to shit? What I've seen here what I've seen, students get the most value from when they're sort of on this journey to learn, explore, figure out what they want to do, what kind of field they want to work in, what job they want to get. What helps them sort of the most is kind of just building in public.
00:19:39.300 - 00:19:59.674, Speaker D: Not saying you have to be active on Twitter 24/7, there's absolutely no need to do that. But you have to be building, and you have to be building in a way where you can say that that was your experience. If you copy a to do list, tutorial to learn react, that's not going to land you a react job.
00:19:59.674 - 00:20:20.638, Speaker D: If you copy how to build a task tracker using Node JS and Express, that's not going to get you a backend developer job. What is going to get you those jobs is building something that you can't copy paste on a tutorial is building something that is not so simple. It could be a clone of something, sure, but it shouldn't be a copy paste from a tutorial.
00:20:20.638 - 00:20:32.566, Speaker D: And hackathons like East Global and other types of hackathons are probably the best place to do that. If you're a hacker here, that's amazing. I got my start in the Web.
00:20:32.566 - 00:20:47.994, Speaker D: Three space ETH, Waterloo, 2017. So this is great sort of being back here after so many years. But if you're here to hack, if you're here to learn that and you're here to sort of get ready, get a name out there.
00:20:47.994 - 00:21:01.354, Speaker D: Build projects. I think that is the key number one thing you can do apart from grinding lead code and going after fang. If you're building projects and you're building stuff that's novel, that's not a copy paste from a tutorial.
00:21:01.354 - 00:21:14.962, Speaker D: And if you're building stuff, hopefully that can get some users, some actual users. It's not a necessity, but it's always a nice to have. If you build a project that has, like, 50 users, right? 50 users better than zero.
00:21:14.962 - 00:21:36.406, Speaker D: Do that, and I promise you, you get a few of those under your belt, companies are going to stop complaining about you not having years of experience on your resume. Because when you have actual things you've built that have users or just actual cool things you've built that are not copy pasted from tutorials, that is a very high value signal. I've been on kind of both sides.
00:21:36.406 - 00:21:53.082, Speaker D: I was a student at Waterloo doing the Waterloo Works grind, applying to 200 jobs every semester and being on the other side, sort of done hiring for companies I worked at, done hiring for Learn Web Three. And there's a lot of times I hire new grads. I've hired a bunch of new grads.
00:21:53.082 - 00:22:14.360, Speaker D: And the key thing is, again, have they had Novel projects under their belt? Yeah, I think that's a key point I wanted to get across. Again, this is meant to be a discussion, so if any of you have any specific questions I can help answer that might be relevant, I'd love to take on those now. Otherwise, I can just continue on this list.
00:22:14.360 - 00:22:23.808, Speaker D: All right. Okay. So what else do we got? We got the lead code questionnaire.
00:22:23.808 - 00:22:38.988, Speaker D: It's okay. It's kind of the same similar answer to that. Oh, the other thing I would say kind of pertaining to number one and number two both is being involved in a community helps a lot.
00:22:38.988 - 00:22:47.344, Speaker D: I'm not here to shill Learn Web Three, by the way. Okay, we'll go through this slide. There's like one slide at the end where I'll give you the website link.
00:22:47.344 - 00:22:54.660, Speaker D: I'm not here to shill you a course. I'm not here to sell you a boot camp. Our education is anyway free, so I'm not here to sell you anything.
00:22:54.660 - 00:23:21.550, Speaker D: But realistically, the most value. I've seen that's like the students I've seen who've gone from sort of not knowing anything about ethereum or not knowing anything about crypto and in less than a year, getting, like, a great remote job traveling the world, perhaps. If they're in Deverel or just working on cool protocol layer development stuff, which used to be a dream of mine when I was starting out.
00:23:21.550 - 00:23:54.256, Speaker D: The biggest thing that separates them is also how active they were in the community. There's a lot of people, and this is unfortunately, somewhat a toxic culture at Waterloo, I have to say, is people really tend to be in isolation a lot when they're learning, when they're trying out new things. Obviously if you're not from Waterloo maybe don't recognize that problem, but there generally tends to be a little bit of competitiveness toxicity around that culture.
00:23:54.256 - 00:23:59.512, Speaker D: And I want you to forget that. I want you to be collaborative. I want you to talk to people around you.
00:23:59.512 - 00:24:14.748, Speaker D: Because when imagine we're in a room right now. Imagine I'm not giving this talk. We're just sitting around, we're just chatting, having coffee, and we're just talking about sort of what's going on in this space, right? What is Cosmos doing? Is Bearachain even real? I don't know.
00:24:14.748 - 00:24:29.824, Speaker D: We're just sitting around talking about that and we'll bring up things that the other person doesn't know about. I'm going to go out after this talk. I'm going to meet some of my friends who are going to teach me a thousand DeFi things I have no idea about because that's not who I am.
00:24:29.824 - 00:24:49.592, Speaker D: I don't do DeFi Djen all day. You meet somebody else, they're going to tell you all the new advancements happening in NFTs. You meet somebody, they're going to tell you why Op Stack is better than Arbitrum Stack, or why Arbitrum is better than Op Stack, or why Coinbase is building on optimism, or what the hell is WorldCoin and why are we all selling our eyes to Sam Altman, whatever that reason is.
00:24:49.592 - 00:25:00.956, Speaker D: When you're around people, you get to bounce off ideas. You get to talk to people who are focused on things other than you. And you will never be able to get that far by yourself.
00:25:00.956 - 00:25:34.360, Speaker D: Web three is, or I should say crypto is such a small ecosystem relative to a lot of other technologies that are out there. And even then it's almost impossible for you to stay up to date just by yourself. So if you aren't doing this already, and if you are kind of in your journey to learn more about this, build more, maybe get a job, maybe build your own thing, the number one, highest value thing you can probably do is being part of the community.
00:25:34.360 - 00:25:51.004, Speaker D: And the number two would be building projects that you can put on your resume that hopefully have real users. Yeah, want to say that out. What else do you just move to AI now? Kind of touched on that.
00:25:51.004 - 00:25:55.400, Speaker D: Not going to take your job. Use it to your advantage. Train chat GPT.
00:25:55.400 - 00:26:17.524, Speaker D: It's really simple to do. Train chat GPT, feed it a hundred page ethereum yellow paper and ask it all the fucking questions you can so you can learn how ethereum actually works inside out. You don't need to stay just on the conceptual level, you need to be using it to your advantage few years from now.
00:26:17.524 - 00:26:40.396, Speaker D: Devs who are using chat GPT to ten x their productivity, they are the ones who are going to take your jobs. It's not Chad GPT who's going to take your job, it's the people who can perform ten times better in the same amount of time who are going to take your jobs. So if you don't have an OpenAI account, if you aren't paying for Chad GPT right now, or if you aren't paying for an API key right now, come on, guys.
00:26:40.396 - 00:27:01.350, Speaker D: Okay, it's put in $20. Put in $20, and it's going to be worth a month, two months of whatever usage you can get out of OpenAI. And that'll be way more value than, should I say that way more value than the 20K you're probably paying for a semester over here.
00:27:01.350 - 00:27:09.030, Speaker D: I have my thoughts on university education. That's whatever. Maybe another time.
00:27:09.030 - 00:27:24.888, Speaker D: Yeah, there's another thing sorry, I'm just going on a rant here, but there's another thing. Seeing so many people come up to me, they're like, hey, so I want to learn how this OpenAI thing works, but it wants me to put in a credit card. I'm a first year student.
00:27:24.888 - 00:28:00.896, Speaker D: I don't want to spend money on this stuff. I'm like, dude, you just bought a $5 coffee, right? $5 will get you thousands of messages on Chat GPT. $5 will get you so much value from OpenAI's API, you're going to sink back to this time a few years from now and be like, why did I not just do that? If there was ever a time in history where you could look at it and be like, this is going to change the future as we know it, I don't think there's been a clearer time, at least not in my lifetime.
00:28:00.896 - 00:28:11.800, Speaker D: There were probably times before I was born, but in my lifetime, I don't think anything as big as the air revolution right now has happened. And you shouldn't have to make a choice. You shouldn't have to choose.
00:28:11.800 - 00:28:22.190, Speaker D: You shouldn't not be using it. You should be using it to improve yourself as much as you can. Whether you're building in crypto, whether you're not building in crypto, if you're just here for the free t shirts and food.
00:28:22.190 - 00:28:45.124, Speaker D: If there's anything you want to take away from this, take away the fact that don't be worried about spending $5 and talking to people, because talking to people will get you the most value in your career than ever before. Another thing to think about on that topic, actually, somebody said this to me the other day. Somebody was know.
00:28:45.124 - 00:29:02.216, Speaker D: Oh, XYZ person has so many know. He knows everyone. How do you compete with that? If you want to build something, how do you compete with somebody who already knows everybody? They can just give them a phone call and be like, hey, use my thing or promote my thing on Twitter or whatever.
00:29:02.216 - 00:29:25.680, Speaker D: And how do you compete with that? One thing I want you to think about on that note is if you're in university right now, if you're in school right now, and I'm assuming if you're at least the people who said they're developers, you're either doing ECE or CS or something like that. Your classmates, you have hundreds of classmates. Hopefully you're friends with some of them.
00:29:25.680 - 00:29:47.370, Speaker D: Those people, five years from now, ten years from now, 20 years from now, will hold some very good positions at hopefully some very good companies. And kids who are in school then will look at you and will be like, this guy knows all the people from all these big companies. How do we compete with them?
00:29:48.460 - 00:29:49.432, Speaker B: So talk.
00:29:49.566 - 00:29:55.740, Speaker D: Talk to people. Build in public, build projects, talk to people, get the value out. Talk to AI.
00:29:55.740 - 00:30:03.356, Speaker D: Learn all of this. What chain, what language of protocol, front end, back end, smart, contracts. Do whatever.
00:30:03.356 - 00:30:16.450, Speaker D: Do all if you can. I think a lot of you are in the age group where you're probably still exploring. You aren't 100% sure what you'd like to be doing a few years from now.
00:30:16.450 - 00:30:24.004, Speaker D: If you're in that phase of life. Just do everything, dude. You have time.
00:30:24.004 - 00:30:32.244, Speaker D: Just explore everything. Do a little bit of everything. That's why I think building projects is amazing and hackathons are amazing because you have to build out the whole thing.
00:30:32.244 - 00:30:42.090, Speaker D: It can't be just, oh, I just wrote an express API, but I can't demo it because I don't have a website to show it off. You have to build out the whole thing. Do that.
00:30:42.090 - 00:30:51.372, Speaker D: I think that's all the questions on my list, at least. And again, this is all the shilling I'm going to do. It's free.
00:30:51.372 - 00:30:55.612, Speaker D: We don't charge you. Check it out if you want to. Come meet me later if you want to.
00:30:55.612 - 00:31:01.264, Speaker D: This is my Twitter DM me if you want to. I reply to every single one of my DMs. That's about it.
00:31:01.264 - 00:31:37.660, Speaker D: If you have any follow up questions to that, if you want to chat in front of everybody or just by myself later, come up or ask the question now, and then we'll hand it off to whoever the next speaker is. All right? Yeah. Thank you very much.
00:31:37.990 - 00:35:56.420, Speaker C: Office, one view, go. Yeah.
00:35:57.110 - 00:35:58.050, Speaker F: One, two, three.
00:35:58.120 - 00:36:00.420, Speaker G: Testing. One, two, three. Is that.
00:36:03.350 - 00:36:04.734, Speaker B: Testing, testing.
00:36:04.862 - 00:36:05.940, Speaker G: Think we're good?
00:36:09.510 - 00:36:10.260, Speaker C: Cool.
00:36:17.040 - 00:36:17.790, Speaker D: Yeah.
00:36:20.320 - 00:40:31.010, Speaker C: Good job. It's that's. Welcome, everyone.
00:40:31.010 - 00:40:41.420, Speaker C: We'll get started on our next workshop. Please join me in welcoming Kendall from everyone.
00:40:45.230 - 00:40:59.600, Speaker G: All right, it's great to be here. I am here to tell you guys how to decentralize your front end for this hackathon and potentially beyond. And we're going to talk about how to do it with a tech stack that we're calling the Blockchain Operating System.
00:40:59.600 - 00:41:20.418, Speaker G: So just to kick it off, like, what is the Blockchain operating System? So, two main things. One, it's this common layer for discovering open web experiences that's compatible with any blockchain, which is a part of it that we're really excited about. And then maybe even more directly, for those of you who are developers in the room, probably most of you, it's a tech stack for building fully decentralized applications.
00:41:20.418 - 00:41:30.794, Speaker G: And most importantly for this talk, it's about decentralizing your front end. So the main reason we decided to build Boss is to solve a few different problems. So onboarding and distribution are common ones.
00:41:30.794 - 00:41:51.120, Speaker G: Compliance is one that's becoming a lot more important, especially if you're building financial applications complexity. Another one for developers. There's a lot that comes with building a front end these days and we aim to make it easier and then we're really excited about bringing Claus platform to support to this ecosystem and really just letting blockchains collaborate in a more compelling way.
00:41:51.120 - 00:42:11.894, Speaker G: So the Boss stack is a few different pieces. We'll mainly be talking about user interfaces and blockchains today, but we also do have some products for onboarding, mostly around users being able to use blockchains without actually needing an explicit wallet. If they're new to their crypto journey or using a crypto application, they may not have a wallet and they may not want one just yet.
00:42:11.894 - 00:42:33.246, Speaker G: And we do have some products for that but less relevant to this talk. And here's kind of a snapshot of a few of the different pieces that fit into the Boss stack. Again, we have what's called these gateways which are going to be basically interfaces that enable users to interact with the front ends of various decentralized applications like say, Aave, Uniswap Liquidy and others.
00:42:33.246 - 00:43:03.938, Speaker G: And the code for these will be stored both on the near blockchain for the front end and then on, say, the Ethereum blockchain for the smart contracts. So one of the biggest things we aim to solve when we set out in building the blockchain operating system is that typically developers are forced to make a choice between distribution and decentralization when it comes to their front end. You're way better off like kind of baking your front end into a few existing applications or even hosting your own front end and promoting the hell out of it if you're trying to get distribution.
00:43:03.938 - 00:43:33.598, Speaker G: If you want decentralization though, those are kind of counter to the things that you want. Fortunately, we think we have a way to kind of thread the needle and actually give you both increased distribution while also giving you even more decentralization you would have had if you're hosting your own website on like Vercell or something like that. So to make it very clear in exactly how it works, let's imagine that you guys are developers and first you're going to deploy a smart contract to Ethereum and now you need somewhere to deploy your front end.
00:43:33.598 - 00:43:57.618, Speaker G: And let's say you choose Boss and you choose the near blockchain. So what you're going to be doing today is you will actually be deploying basically like react's JSX code, like these components. You'll make a component for your DAP that you will deploy to the near blockchain and then users will be able to interact, access that interface, conduct some actions that will then result in a transaction and then they can send that transaction to Ethereum.
00:43:57.618 - 00:44:17.642, Speaker G: Which means they can have basically they're interacting with two different blockchains in one experience. They don't necessarily know that all they care about is accomplishing their goals. And a component of this we're really excited about is that since you will be able to deploy your code on chain, what this means is that dows that are currently managing their smart contracts can now also manage their front end all on chain.
00:44:17.642 - 00:44:36.462, Speaker G: So we're hoping we can see a world where every single dow will do this. Like if you have smart contracts, you will at least have some basic user interface or even a very full feature user interface that you as a dow will maintain an upgrade that reflects the usage of your smart contracts. To make this a little bit clearer, we'll talk about it from the user angle.
00:44:36.462 - 00:44:46.386, Speaker G: So let's imagine that we have a user. The first step to use Boss, they're going to navigate to some kind of interface or front end. This could be MetaMask, this could be Zapper on iOS.
00:44:46.386 - 00:44:52.674, Speaker G: It could be Nier.org. Soon it's going to be Urbit, which we're pretty excited about. And it could also be this site called Bossugg.
00:44:52.674 - 00:45:01.002, Speaker G: That's basically like a doc site that we have. So by going to any of these they can access all of the same applications. So then they're going to select a DAP that they want to use.
00:45:01.002 - 00:45:06.986, Speaker G: These are four examples we have available today. Ave one inch, uniswap or liquidy. Let's say they select Aave.
00:45:06.986 - 00:45:27.202, Speaker G: So after they select Aave, then the Ave front end code is going to be loaded from the near blockchain. So there'll be an RPC request to the near blockchain which will then return the JSX. And that JSX will be rendered in a specialized virtual machine that'll be running on one of those different gateways that the user first navigated to.
00:45:27.202 - 00:45:44.090, Speaker G: And this virtual machine is designed to basically be a strict subset of JavaScript that has some extra security guarantees so that if it is near and there's private keys in local storage, for some reason those are not able to be snooped easily. That's the goal. So then they've loaded the front end.
00:45:44.090 - 00:45:57.930, Speaker G: They're doing their thing. They're like, I want to deposit 100 USDC into Ave great forms a transaction because now they're just using a front end. And then it hits the Ethereum RPC, sends the transaction to Ethereum.
00:45:57.930 - 00:46:10.180, Speaker G: They then get some kind of receipt showing them that the transaction was bind, get a message saying that they were deposited. It updates the front end. Now they're happy and they've used a fully decentralized or cross platform application.
00:46:10.180 - 00:46:44.060, Speaker G: What's really cool if you want to get really paranoid with this, which we like to do, is that gateway in the first step can be self hosted and it can be self hosted very easily. You can run this in an Electron app and soon we'll have that as an access point or I think even more commonly, we'll just see people using their typical mobile wallet and they'll be able to access the application kind of skipping DNS entirely, skipping going to this front end entirely, just interacting with two blockchains at most. One blockchain if it's fully built on near, or two blockchains if the front end is on near and then the back end is on Ethereum or an L two or Salana or whatever it may be.
00:46:44.060 - 00:46:55.146, Speaker G: And the best part for you guys is that it's super easy to get started. So there's basically five steps. If you guys want to want to build with this today or even get some things running, you can go to near.
00:46:55.146 - 00:47:06.270, Speaker G: You can use the search function that I just search for these five different applications. You can click Fork, you can make changes, and then you click Save. And that Save is actually going to be a transaction to the near blockchain.
00:47:06.270 - 00:47:10.994, Speaker G: It's super cheap. Should be a few cents. If anyone in here needs some near, come talk to us at the near booth.
00:47:10.994 - 00:47:28.250, Speaker G: We'll get you guys some near and you'll be on your way. And then the other aspect of this that we're really excited about is that every single component that you build can be composed of other components. The same way if you're familiar with React, where you can have higher order components and you can compose components, you can pass State and Props between them.
00:47:28.250 - 00:47:40.682, Speaker G: You can do that with Boss. With a bunch of different components, there can be ten different components that are deployed. I gave an example of a page for Polygon that shows a few of their different applications, all of which are available on Boss.
00:47:40.682 - 00:47:55.330, Speaker G: And then it shows an interactive swap component there that's also being rendered in the same page. And this is actually going to be like seven different components, all of which are composed together into a single experience, which is really cool. So now onto the fun part, which is the demo.
00:47:55.330 - 00:48:10.342, Speaker G: And we'll actually walk through how you can access Boss components and how you guys can get started for this hackathon. So this is actually a demo that was created for ETH Soul. And I think what's fun is it's going to be a very easy way for us to show how you can get started.
00:48:10.342 - 00:48:28.014, Speaker G: So in this demo, there's basically four different components that are going to be showed. And you see that little widget line that's basically a different component that's being loaded into this higher order component. So some of the things you're going to get out of the box here is like detecting the network that the user is on.
00:48:28.014 - 00:48:36.878, Speaker G: That's going to be like the first thing that this component is doing. Then you can detect basically who the sender is going to be from State. And we have some examples of how to do that.
00:48:36.878 - 00:48:54.454, Speaker G: You can load their balance, their ETH balance, and you can load their state ETH balance. Because in this case, this is like a lido component example, like helping people stake their Ethereum. And I think it'll be even easier if we actually just go to this and show you what's happening.
00:48:54.454 - 00:49:01.614, Speaker G: So here you can actually see this being rendered. This is the Lido component. And I can go up here and I can click fork.
00:49:01.614 - 00:49:05.894, Speaker G: Now we're seeing the code. So users can actually do this. They can view the source code in the browser.
00:49:05.894 - 00:49:22.760, Speaker G: Same way you'd be viewing the source code for like a smart contract on Ether scan so they can check out. I can't actually see it on my screen. Bear with me.
00:49:22.760 - 00:49:32.586, Speaker G: Somewhere in here we'd be able to see the smart contract, but I cannot actually see it. Maybe let's just go to the actual Lido contract itself.
00:49:32.768 - 00:49:34.380, Speaker F: Let's see here.
00:49:34.910 - 00:49:49.214, Speaker G: Here we go. So let's fork this one. Here you can see the smart contract so like a Savvy user would be able to actually check the smart contract, go cross check it on another website and be like, cool.
00:49:49.214 - 00:50:05.746, Speaker G: I am very confident that this is going to actually send my e to the contract I want to, which in this case is the Lido contract. And you can easily change that to say, the Lido contract for polygon. And then I can just click Save and it's actually just going to show me the state diff.
00:50:05.746 - 00:50:15.000, Speaker G: So this is like showing you like the code that's actually going to be saved to the near blockchain. Click save data. I'll probably have to sign a near transaction maybe.
00:50:15.000 - 00:50:26.746, Speaker G: Oh, I don't even have to. Yeah, if it's below a certain size, then you don't even necessarily have to save it. Do a transaction in order to save the state diff and then bam, we're good to go.
00:50:26.746 - 00:50:38.298, Speaker G: And I can preview this. I can preview it here so that I can actually see what I'm doing and then just hop back and forth between the in browser editor. Or you can download a Vs code extension that will make it a lot easier to compose your wraps.
00:50:38.298 - 00:50:58.360, Speaker G: Like if we have from the previous example we had that you can see here, there's like these widgets that are being loaded. The widget means it's another component. So if you use the Vs code extension, you can actually click into this and you can then see the component or pull in the component so you know what it is that you're going to be interacting with.
00:50:58.360 - 00:51:14.620, Speaker G: Yeah, and then if you go to near, you can actually use the search functionality here and find a few different components so we can look for Ave, for instance, if the WiFi is going to cooperate. I think this is the one I cannot see.
00:51:19.810 - 00:51:21.070, Speaker F: Whoops.
00:51:22.070 - 00:51:22.770, Speaker C: Okay.
00:51:22.920 - 00:51:39.574, Speaker G: This is for Ave on the polygon zkevm testnet. Where did my browser go? Here we go. While that's loading, we can oh, there we go.
00:51:39.574 - 00:51:55.322, Speaker G: So you can see this is like an ave component that someone in the community built. We can then go to develop and check out the details which will show us who deployed it. It'll show us all the source code and then go ahead and fork it.
00:51:55.322 - 00:52:12.062, Speaker G: And maybe in this case we'll want to change the network that maybe we don't want it to point to Ave on Polygon zkvm. Maybe we want to sorry guys, I can't see it on my screen here. But we can change it to point to Ave on Polygon or Ave on Ethereum or whichever network it's deployed on.
00:52:12.196 - 00:52:14.106, Speaker F: And then we can do the same.
00:52:14.148 - 00:52:19.326, Speaker G: Thing and save it here. It's over here. Or we can save this version of it locally.
00:52:19.326 - 00:52:33.990, Speaker G: This will be saved in the browser so you can just kind of like edit while you're testing. And then if you want to publish it, then you can do the transaction. So in this case, I'm actually just forking it live demos.
00:52:33.990 - 00:52:42.300, Speaker G: All right, let me just pull up the slideshow again.
00:52:48.790 - 00:52:49.250, Speaker C: Cool.
00:52:49.320 - 00:52:50.260, Speaker E: There we go.
00:52:51.270 - 00:53:06.710, Speaker G: All right, so just diving into some more of the technical details and showing you what we're doing here. So a lot of this right now, this assumes a react dependency out of the box. We're launching a version of the virtual machine that will not make that assumption because I'm sure plenty of you want to use other JavaScript packages.
00:53:06.710 - 00:53:20.910, Speaker G: So right now we use Props and State if you're familiar with how react works. So like Props, you can pass between components. You can also pass state, but State in this case will be more global, which means that you can just store state between components.
00:53:20.910 - 00:53:35.166, Speaker G: So here's an example of how you can use Ethers. So we inject Ethers just by default right now to make it easy for developers to get started. So you can see here, this is like basically doing a get balance function from Ethers.
00:53:35.166 - 00:53:58.380, Speaker G: Pretty simple, similar to what you've been doing before. And then the result here will do a state update and then similar to updating any sort of state in a component, it uses the lifecycle of react and this component will rebrander with the state balance to whatever the user's balance is. So that's an example of just like how State and Props are going to work.
00:53:58.380 - 00:54:15.194, Speaker G: Similar kind of thing here. I think this one's actually doing the kind of smart contract call. So you can see, you can assume here that we have the Lido contracting in there and then encodes the data using the standard that Ethers is expecting.
00:54:15.194 - 00:54:26.546, Speaker G: In this case like balance of and we'll call it. And then it will then update the interface based on the result of that transaction. And then a very important part for everyone who's building a front end.
00:54:26.546 - 00:54:44.986, Speaker G: You're going to want to style this component. So by default we actually enable sorry, this is an example of that composability. We're talking about where you can have this kind of like, other component, pass the props to it and yeah, it shows an example of basically how to do that.
00:54:44.986 - 00:54:57.686, Speaker G: And then finally we have styling. So by default, it'll let you use styled components. So it should be like a nice and familiar way for you to include your style sheet.
00:54:57.686 - 00:55:09.774, Speaker G: So you don't actually have to pull in an external style sheet. You can just build it into the component like similar like you would do in a lot of typical react components. And that is what I have for you today.
00:55:09.774 - 00:55:22.242, Speaker G: So we do have some bounties here. So we have ten K total in Bounties. I think it's split up between a first place prize of three K, two second place prizes of two grand, and then two or three of one K.
00:55:22.242 - 00:55:30.966, Speaker G: If you scan the QR code there, you can check it out and you can also come visit us at the near booth. We're on this side. There's also like, filecoin in the graph right over there.
00:55:30.966 - 00:55:42.380, Speaker G: We're right between them if you have any questions. And we'll be here all weekend and yeah, we still have a good amount of time left, so I'm happy to answer any questions that anybody has about how this works.
00:55:45.950 - 00:55:46.960, Speaker E: All right.
00:55:56.200 - 00:55:57.270, Speaker C: Go for it.
00:55:58.520 - 00:56:01.140, Speaker D: While you guys were building this, what are the challenges?
00:56:03.960 - 00:56:18.932, Speaker G: Yeah, great question. So I guess our goal here is that you can fully decentralize this, right? So there's a few different layers. If you want to decentralize a blockchain application, right, there's going to be the front end code and where that's going to be running, there's going to be the smart contracts.
00:56:18.932 - 00:56:33.644, Speaker G: Those parts are almost like the easy part. The harder part is making sure that if you need radical decentralization, like I'm in a place where there is serious censorship, then you're also going to probably need to run your own RPC. And most applications these days have some kind of data layer.
00:56:33.644 - 00:56:44.640, Speaker G: Hopefully it's the graph, which fortunately is getting very decentralized, but a lot of times it isn't. And if it's not, you need some easy way to access that data. So that's been a general big problem on most blockchains.
00:56:44.640 - 00:57:26.192, Speaker G: At near, we've worked with a lot of teams and created a lot of solutions to kind of make just more easily indexable or accessible data available to developers. But we basically want front ends at some point to let users kind of define their data layer, define their RPC, define their wallet, and define each of the different parts of the yeah, that part is tough. Right now, basically, the gateway is usually just choosing an RPC provider, they're choosing the data provider and making sure that developers can essentially be agnostic to the choices that the gateway providers might eventually make is a bit of like an experience problem.
00:57:26.192 - 00:57:27.810, Speaker G: That's one of the ones.
00:57:30.610 - 00:57:40.990, Speaker D: Sorry, I have questions. How is it technology? But I post my content on the website.
00:57:46.920 - 00:58:23.036, Speaker G: Oh, you mean like if millions of people are accessing like how many? Yeah, so that actually gets into that first question is like it sort of depends on which part of the stack will end up getting essentially DDoS, the near blockchain itself can handle quite a few transactions and these are mostly view calls, so they're not actually going to be updating state for users who are accessing it. Which means that it really comes down to RPC load. So we have a few applications not actually related to Boss that send a lot of transactions to the network and so there are some pretty battle tested RPC solutions.
00:58:23.036 - 00:58:36.950, Speaker G: So that probably is going to do okay, but depending on which one whoever's running the gateway chooses, that might fail, right? That's a common one. We see in blockchains that get kind of a lot of load as RPC fails. That could be a problem.
00:58:36.950 - 00:58:58.364, Speaker G: The data layer in theory could be another problem. If the app you'rendering the component you'rendering is making some assumption, maybe the developer is like oh, we didn't want to use the graph so we just built our own API and it's running on some really small EC two instance that could then fail. Or just like the gateway itself if it's like again, running on a small EC two instance or something.
00:58:58.364 - 00:59:09.344, Speaker G: So it depends. There are ways to do it, like neo.org for instance, it could handle a lot of simultaneous users, but it's because they built it in a way to anticipate that because they get a lot of load already.
00:59:09.344 - 00:59:22.948, Speaker G: There's quite a few people who visit that page on a monthly basis. But yes, smaller instances of each of those could lead to some failures. But it is possible to build these things in a very resilient way these days.
00:59:22.948 - 00:59:54.460, Speaker G: Maybe not like tens of millions of concurrent users, but definitely like pretty substantial numbers, especially for this industry right now. Serving what exactly? Oh, I see. Yeah, this is definitely designed more for kind of like stat doesn't be static, but like pages where the dynamic loading is data.
00:59:54.460 - 01:00:04.352, Speaker G: I mean you could use a different it is just the front end code, right? It's just JavaScript. You could stream content too. Maybe you're even streaming it from Filecoin or something.
01:00:04.352 - 01:00:24.004, Speaker G: Yeah, that would work fine. Basically you shouldn't be using near to store videos for instance, or something that would need to be streamed, even photos. Near is kind of like a sweet spot where because it's a sharded system, we can handle a higher state load than most chains can, but it's not designed for petabytes of data like Filecoin is.
01:00:24.004 - 01:00:39.820, Speaker G: Right, a great solution for that would be like combining Filecoin to actually store the video using their new CDN solution to kind of stream it and then piecing it together and creating DUI can be done on using Boss. That would be like my recommendation for that. Stack.
01:00:41.520 - 01:00:44.540, Speaker C: Follow up on that. What is the cost effectiveness of storage?
01:00:46.490 - 01:01:03.466, Speaker G: Yeah, so it's like one near per either 100 no, maybe it's a megabyte. So it tends to be pretty cheap for front ends. Most front ends that I deploy and a lot of times after you deploy the first version when you do updates, it's just uploading the state diff.
01:01:03.466 - 01:01:16.686, Speaker G: So it ends up being usually a few cents for most front ends for something really rich. If you store the images and just stuff like that, it could get a little crazy. But yeah, I would recommend using other solutions for that media and then just using this for the front end code.
01:01:16.686 - 01:01:27.810, Speaker G: The idea is like mission critical stuff, right? You want people anywhere to be able to access it, have those pieces there and then the nicer images and stuff like that can come from elsewhere.
01:01:30.570 - 01:01:31.320, Speaker D: So.
01:01:34.250 - 01:01:35.558, Speaker E: Follow up question on that is.
01:01:35.644 - 01:01:37.990, Speaker G: The scaling of near, for example.
01:01:38.060 - 01:01:56.266, Speaker C: So higher usage value is through to a near, for example, because it's denominated in cost of near. Question now is a few cents feature challenges with that?
01:01:56.368 - 01:02:06.014, Speaker G: Yeah, it's a good question. So I mean, the biggest thing is like yeah, obviously our approach to scaling is like adding more shards. We don't know how many shards we can add.
01:02:06.014 - 01:02:28.294, Speaker G: I think right now they're testing with 100 and that's working pretty well and we don't need that many yet. Going beyond there probably there are going to be some sort of limits that are hit eventually. But I think we've got the reason that we chose Sharding and took on all of the complexity that comes with that is that we believed it was a much more future proof solution than a lot of the choices that are made.
01:02:28.294 - 01:02:49.470, Speaker G: So we're confident we can scale for a while. And I mean, the other thing that happens if the price of near were to go up, just like if the price of ETH goes up, that can manipulate the storage prices in a weird way. So what we do there is similar to ethereum is like you just update kind of some of the assumptions that are made so that the real cost can either stay static or go down even.
01:02:49.470 - 01:03:14.270, Speaker G: And that could go the other way too. Whether the price of near goes up or down, we can kind of adjust the static costs. That is a great question.
01:03:14.270 - 01:03:30.850, Speaker G: So the long term answer will be absolutely. The short term answer today is unfortunately, yeah, you're going to have to use the packages that we have sort of pre install and that's just because of the security assumptions of the VM. But that is a common request and it's like one of our top priorities is to enable that.
01:03:30.850 - 01:04:02.796, Speaker G: The problem we have now is we have to kind of add them manually and so we get a lot of requests and we don't want to actually have to make that choice for developers. So we are, I think, pretty close to the V, two of the VM that will allow you to import probably most JavaScript packages, or at least it will be way more like the choice of the developer rather than the choice of us. So, yes, soon you will be able to use tailwind.
01:04:02.796 - 01:04:17.120, Speaker G: Today you're going to have to use style components. Unfortunately, that is a great question. I don't have a great answer.
01:04:17.120 - 01:04:23.150, Speaker G: I would say, yeah, style components, ethersjs. You can assume. I would look at a few examples.
01:04:23.150 - 01:04:25.258, Speaker G: Definitely check out. Yeah. Like aave.
01:04:25.258 - 01:04:29.598, Speaker G: Lido. Uniswap. Like some of those just to kind of see some of the common patterns.
01:04:29.598 - 01:04:34.500, Speaker G: We'll give you an idea. We should have a list, though. We'll get on in making that.
01:04:34.500 - 01:04:46.940, Speaker G: All right, thanks, everyone.
01:06:30.270 - 01:06:31.190, Speaker C: My name is Marcus.
01:06:31.270 - 01:06:31.826, Speaker E: Brian.
01:06:31.958 - 01:06:41.430, Speaker C: Yeah. I'll write it down here. Change it.
01:06:41.430 - 01:06:42.550, Speaker C: Oh.
01:06:48.020 - 01:06:49.504, Speaker D: Is it okay if I say.
01:06:49.622 - 01:06:51.040, Speaker G: Controlled edge and note working?
01:06:51.110 - 01:06:54.210, Speaker C: Yes, working on the graph. I know.
01:06:56.260 - 01:06:57.680, Speaker D: The graph is medium.
01:07:10.430 - 01:07:36.650, Speaker C: Okay. We all collapse here. Make sure your video works.
01:07:36.650 - 01:07:48.640, Speaker C: All right. Oh, so it's a secondary screen. Okay.
01:07:48.640 - 01:07:50.720, Speaker C: If you want to.
01:07:54.610 - 01:07:57.246, Speaker G: Mirror, it be.
01:07:57.268 - 01:08:12.130, Speaker C: The same, or you can just have it. Let's see. Just do this.
01:08:12.130 - 01:08:34.228, Speaker C: Yeah, there we go. All okay, so let's try it again. It's on that screen.
01:08:34.228 - 01:08:46.086, Speaker C: There we go. Just want to mirror. Is that mirror? It says mirror.
01:08:46.086 - 01:09:02.894, Speaker C: Yeah, I don't want to do that because I'll be mirroring to everybody range. No. Is that called Roland video?
01:09:03.012 - 01:09:03.294, Speaker B: Yeah.
01:09:03.332 - 01:09:09.058, Speaker C: I don't even see Roland video. Okay. I mean, I can give this a go like this.
01:09:09.058 - 01:09:19.634, Speaker C: That's fine. Yeah. Yes, I know.
01:09:19.672 - 01:09:20.260, Speaker G: Right.
01:09:23.690 - 01:09:26.850, Speaker E: Main display, and then you just change it to mirror.
01:09:26.930 - 01:09:29.480, Speaker C: There we go. Perfect time. Thank you.
01:09:29.480 - 01:09:35.000, Speaker C: This is getting worse. I can see it.
01:09:35.690 - 01:09:36.810, Speaker D: Definitely see that.
01:09:36.960 - 01:09:38.906, Speaker C: Thank you. Awesome.
01:09:39.008 - 01:09:40.426, Speaker G: Okay, and then it'll get mixed up.
01:09:40.448 - 01:09:41.740, Speaker C: And then I'm going to check the next.
01:09:45.430 - 01:09:47.554, Speaker B: Podium because the camera that makes sense.
01:09:47.752 - 01:10:01.952, Speaker C: Perfect. Okay, cool. Feel like that's about right? Yeah.
01:10:01.952 - 01:10:11.030, Speaker C: Okay, cool. Makeup. How's my hair? You know.
01:10:11.030 - 01:10:40.152, Speaker C: Test, test, one, two. Test, one, two, test. We're good.
01:10:40.152 - 01:10:47.644, Speaker C: Cool. We good. Oh, we are good.
01:10:47.644 - 01:11:01.380, Speaker C: Hi. Please join me in welcoming Marcus from Edge and Node. Working on the graph.
01:11:01.380 - 01:11:10.980, Speaker C: Hi, everyone. Yes, I'm Marcus. I'm working on the graph.
01:11:10.980 - 01:11:21.972, Speaker C: I work for a company called Edge and Node. And welcome to this presentation, an introduction to the graph. Quick start to subgraph development and querying.
01:11:21.972 - 01:11:28.956, Speaker C: So let's get into it. First and foremost oh, we got some Internet issues. There we go.
01:11:28.956 - 01:11:34.704, Speaker C: Let's try that again. Interesting. Well, we're going to be presenting here.
01:11:34.704 - 01:11:47.602, Speaker C: That is totally fine. I'm sorry. There we go.
01:11:47.602 - 01:12:01.846, Speaker C: For some reason, that's going okay, let's keep going. All right, so if any of you all want to hop into our hacker dashboard, we've got a few different things on this dashboard that would be of interest to you. We've got prize information.
01:12:01.846 - 01:12:10.394, Speaker C: We've got the Telegram group also and then also this presentation as well as all the repos. So we're going to be doing a little bit of live coding. Feel free to scan that.
01:12:10.394 - 01:12:23.610, Speaker C: Let's get going. Okay, so first things first, an overview of the workshop. We're going to go an introduction to the graph, a high level overview of what's going on when you are getting your data from the graph.
01:12:23.610 - 01:12:28.510, Speaker C: We're also going to talk about what subgraphs are. All right, that's really important. We're going to go through that.
01:12:28.510 - 01:12:42.020, Speaker C: We're also going to go through deploying a subgraph. And then also we're going to compare queries between two different subgraphs, the subgraph that we deploy, as well as a well developed subgraph. Okay, let's get into it.
01:12:42.020 - 01:12:51.686, Speaker C: First, an introduction to the Graph. So when you go to, thegraph.com first thing you're going to see is this access the world's blockchain data.
01:12:51.686 - 01:12:59.050, Speaker C: Let's go ahead and parse that. Let's go ahead and see what that means. And we're going to go all the way down to the Smart Contract layer.
01:12:59.050 - 01:13:05.082, Speaker C: First things first. A Smart Contract really is just a bit of data storage. That's all it is.
01:13:05.082 - 01:13:21.966, Speaker C: And if you're looking at this, this is a CryptoPunks example, kind of a mockup, where it's just some data. That's all it is. Now if you have this data, what about the data in the past? What about how that has interacted with other data points? Well, what you're talking about is this type of history.
01:13:21.966 - 01:13:41.970, Speaker C: All right, we're looking at historical data and you really have to understand in Smart Contract Land, everything can interact with everything. So we have to understand really all those different types of interactions and seeing how really are we able to get that information to you in your DApps. And this is really a problem, really, because the blockchain is write optimized.
01:13:41.970 - 01:13:59.518, Speaker C: What I mean by that is it's easy to write to the blockchain. Relatively speaking, we're able to write to the blockchain, especially with L two S now in a rapid and affordable way. Now that's really creating an indexing issue where now we have to organize all of this data.
01:13:59.518 - 01:14:11.458, Speaker C: And when we're here, now we have to read that data. We have so much data, we are sending our information to the blockchain. And then now we need to read that.
01:14:11.458 - 01:14:29.030, Speaker C: Who here today has interacted with Instagram or some type of social media app on Web Two? There we go. All right, have you posted on Instagram recently? Okay, so that's a write, and that was a single write. And then with as many followers as you have, hundreds, thousands of followers, that's the read.
01:14:29.030 - 01:14:43.162, Speaker C: And that's the exact same thing we see on the blockchain, where there's a lot of reading going on relative to the actual writing that's occurring. So in Web 2.5, there's a certain amount of solutions for this where anyone here could spin up an indexer on their own.
01:14:43.162 - 01:14:47.034, Speaker C: They could do it. That's totally fine. There's other ways to index as well.
01:14:47.034 - 01:14:49.702, Speaker C: That's totally fine. We call those centralized indexing.
01:14:49.766 - 01:14:50.138, Speaker D: Okay?
01:14:50.224 - 01:14:56.462, Speaker C: And so if you have a data point that you're looking for and you want to get it and it goes to your front end, awesome. All right. That's a really awesome thing.
01:14:56.462 - 01:15:03.954, Speaker C: However, when that goes away, your DAP goes away. All right? And that's really, really a problem. The Web 3.0
01:15:03.954 - 01:15:23.778, Speaker C: solution is to have decentralized reading and decentralized indexing from the blockchain. And so what you have here is a single data point going to lots of nodes, and all of those nodes are able to populate your front end. And if anything should happen to any one of those nodes, you're still intact, you're still good to go.
01:15:23.778 - 01:15:37.120, Speaker C: And that, in a nutshell, is a high level overview of the graph. We love this. So let's think about what this means because is that too loud? There we go.
01:15:37.120 - 01:15:54.274, Speaker C: We good? Yeah. Okay, cool. So what that means is we have a read layer that is amazingly, we take the advantages of the blockchain and its decentralization and we apply that to the read layer because the blockchain is very much you're writing to it all the time.
01:15:54.274 - 01:16:06.834, Speaker C: If you're reading in a centralized way, well, that's a problem because now you have the Web 2.0 type of issues. And then from there, if you decide to decentralize also your front end, you can actually have truly decentralized apps.
01:16:06.834 - 01:16:20.474, Speaker C: And that's a really powerful thing. So to overview the graph network, which is the decentralized network of indexers the world over, we have over 450 permissionless indexers working worldwide. There's redundancy between them.
01:16:20.474 - 01:16:30.362, Speaker C: If anything should happen to one another, one will pick it up. It's fast, cheap, and reliable, and it's a global open API. Okay, so let's get into subgraphs.
01:16:30.362 - 01:16:37.226, Speaker C: Who here has deployed a subgraph? Okay, got a few people. Awesome. So let's get into subgraphs.
01:16:37.226 - 01:16:53.298, Speaker C: What are subgraphs? Why do we need subgraphs? Let's talk about it. We are swimming in blockchain data all the time, all right? Being able to write all of this information to the blockchain, all the l two capacity, it's amazing. A subgraph essentially is a way of organizing that data.
01:16:53.298 - 01:17:14.650, Speaker C: You're providing instructions to indexers around the world to say, this is the information that I need, and I need it organized and I need to be able to query that information. That's essentially what a subgraph is. It's a set of rules that you give to the indexers around the world and say, hey, I need the data prepared in such a way that will be useful and queryable, okay, that is a subgraph.
01:17:14.650 - 01:17:24.686, Speaker C: So, like I said, subgraphs are instruction for indexers. Let's break down the pipeline in a high level overview of what that might look like. You might be looking at on chain data.
01:17:24.686 - 01:17:31.714, Speaker C: You might be looking at off chain data, specifically IPFS that's currently supported. There's also a push to support more off. Chain data.
01:17:31.714 - 01:17:45.694, Speaker C: But right now it's just IPFS. You will define your subgraph in the subgraph manifest, also known as the subgraph YAML. You want to think about that as like the rules and overview of kind of the shape and structure of your subgraph.
01:17:45.694 - 01:17:59.638, Speaker C: From there you're going to give that information a little bit of logic, and that is in the mappings TS file. And you're going to say, hey, we're pulling this information in. Do we want to put any logic on it? Do we want to actually start to transform it that's in the mappings TS.
01:17:59.638 - 01:18:23.870, Speaker C: And then from there we've got this schema GraphQL where you can actually have your data in nice easy buckets, also known as entities. And you could send GraphQL queries to those buckets and get your data on your front end and it'll look something like this. All right? Instead of going through ether scan, instead of parsing through, you could send a simple query in GraphQL that's very easily read and from there get your data through an API endpoint.
01:18:23.870 - 01:18:37.174, Speaker C: Okay, so that's a high level overview of the graph. We are seeing around one to 2 billion queries per day. There's over 1000 subgraphs published on the graph network with the indexers all over the world.
01:18:37.174 - 01:18:44.634, Speaker C: And there's 450 plus nearly 500 at this time. Okay. So if you'd like to scan this, feel free.
01:18:44.634 - 01:18:56.814, Speaker C: I love QR codes. They're easy way to communicate where you have learned about graph, about the graph protocol and subgraphs. And once I see the phones down, we will continue going.
01:18:56.814 - 01:19:02.094, Speaker C: There's a phone there. Awesome. Okay.
01:19:02.094 - 01:19:05.534, Speaker C: Phone there. Awesome. Got it.
01:19:05.534 - 01:19:17.342, Speaker C: Okay, finally, part three. Let's go ahead and deploy a subgraph. All right, so if you would like, here is the repo that you can star and reference.
01:19:17.342 - 01:19:29.686, Speaker C: You don't need to actually clone this. This is just for reference and kind of just getting these overviews of what I'm talking about today. And there's also going to be another repo that we'll look at in just a little bit.
01:19:29.686 - 01:19:35.318, Speaker C: So once I see phones down, I'll keep on going. Phones down, phones down, phones down. Cool.
01:19:35.318 - 01:19:42.842, Speaker C: All right. So first things first, you're going to want to go to thegraph.com if you want to participate with this, you're more than welcome to.
01:19:42.842 - 01:19:46.894, Speaker C: I'll take my time. Is anyone going to be live coding with me? You're welcome to. Yes.
01:19:46.894 - 01:19:49.502, Speaker C: No. Okay, kind of, sort of. Okay, yes.
01:19:49.502 - 01:19:57.418, Speaker C: Awesome. Saw some hands. Also you're going to want to pull up miniscan Https, miniscan XYZ.
01:19:57.418 - 01:20:03.438, Speaker C: Those are really the only two things you'll need. And then also of course, ether scan. That would be helpful too.
01:20:03.438 - 01:20:18.930, Speaker C: Okay, those are the three tabs you'll need. And what we're going to do in this deployment is we're going to deploy the subgraph and then we're going to trace the punk transfer event. Because subgraphs are optimized to look at events, we're going to look at this punk transfer event and we're going to see it on chain.
01:20:18.930 - 01:20:25.634, Speaker C: We're then going to see it in the subgraph manifest. We're also going to see it in the logic. And then we're going to actually be able to query that in the Schematic GraphQL.
01:20:25.634 - 01:20:34.762, Speaker C: That is the pipeline we're going to follow from beginning to end. Okay, let's go back and we'll start. So, like I said, we'll need some tabs open.
01:20:34.762 - 01:20:41.854, Speaker C: First things first, we'll go to the graph.com and studio see, make this a little bigger. Very nice.
01:20:41.854 - 01:20:58.286, Speaker C: And we're going to create a subgraph and we'll say live at Ethglobalwaterloo and we're going to be looking at CryptoPunks. All right, we're going to be looking at the CryptoPunks smart contract. So what we're going to do makes it a little smaller.
01:20:58.286 - 01:21:04.062, Speaker C: There we go. It'll be on Ethereum and we're going to create a subgraph. Now, this is the subgraph dashboard.
01:21:04.062 - 01:21:12.726, Speaker C: We have yet to deploy our subgraph. It is not published onto the network. It is just something we are working on when we do get to the point where we want to query it.
01:21:12.726 - 01:21:20.426, Speaker C: This is our development query URL, where you could actually query that in the front end. Just getting you guys familiar with this. You're free to fill out description, information.
01:21:20.426 - 01:21:26.314, Speaker C: All of this is all great. Just providing information. I'll tell you why this information is important in a minute.
01:21:26.314 - 01:21:38.110, Speaker C: Let's keep on going forward. First things first, you're going to want to install the graph CLI. All right? So open up your terminal, copy there and paste Internet.
01:21:39.350 - 01:21:39.858, Speaker F: Yes.
01:21:39.944 - 01:21:48.290, Speaker C: No, we'll see. All right, as that's spinning up right there. There we go.
01:21:48.290 - 01:21:53.950, Speaker C: Yay. Awesome. So we've got the graph protocol, graph CLI installed.
01:21:53.950 - 01:22:02.134, Speaker C: From there, we want to initialize our subgraph. We'll copy this and paste it right into the terminal. A lot of copying and pasting, that's all it is.
01:22:02.134 - 01:22:08.486, Speaker C: So here you're presented with a selection of protocols we had Nier on earlier. So awesome. We index on near that's.
01:22:08.486 - 01:22:18.294, Speaker C: Also there for you. We have Cosmos, Ethereum and Rweave. Now, we know our smart contract is on Ethereum, but any EVM compatible chain that we also support is through Ethereum.
01:22:18.294 - 01:22:25.534, Speaker C: We index right now, I believe, 40 chains. 40, 41 chains. And some are EVM compatible, some are not.
01:22:25.534 - 01:22:37.470, Speaker C: So just go ahead and dive in. Since we know this is Ethereum, we'll click on that subgrass slug, it automatically populates from the CLI and directory automatically populates. And here we're given all the chains that are EVM compatible.
01:22:37.470 - 01:22:41.430, Speaker C: We know it's on Mainnet. So there it is. And then contract address.
01:22:41.430 - 01:22:53.080, Speaker C: This is where we can start doing a little research. So let's go to Etherscan and we'll type in Crypto punks. There it is.
01:22:53.080 - 01:22:59.354, Speaker C: And we're going to get the smart contract address. Is that too small? That might be too small. That's fine.
01:22:59.354 - 01:23:05.986, Speaker C: We'll be here just for a second. And then we're going to go to Miniscan XYZ. And here I love miniscan.
01:23:05.986 - 01:23:26.238, Speaker C: It's incredible because you're able to select a smart contract address and find relevant subgraph information really fast. All of this information you may need for your subgraph. Some you definitely do for depending on the smart contract, depending on the chain, there's different interactions that you will have depending on what is supported on a certain chain.
01:23:26.238 - 01:23:32.418, Speaker C: But a lot of that information is just right here. Do you want the abi? Do you want the code start block? All of that is here. Do you want the name? It's all here.
01:23:32.418 - 01:23:39.206, Speaker C: Why would you need this? Let's go back to the terminal and find out. We're going to copy the terminal. Excuse me.
01:23:39.206 - 01:23:53.610, Speaker C: The smart contract paste it in, it's automatically getting the abi and this is okay. Sometimes it fails just due to internet issues just through the chain. This literally was working all day today and now it's not no big deal because what I did was I have the Abi here.
01:23:53.610 - 01:23:56.894, Speaker C: So I'll pop this open. Very nice. There we go.
01:23:56.894 - 01:24:24.306, Speaker C: Control A, control C and I'm going to pull up a new window and we're going to open folder, desktop twelve repos Waterloo demo. That's where we are at and we're going to open that up and we are going to create a new file and we're going to list Abi JSON. This is what you do if your Abi is not able to be gathered.
01:24:24.306 - 01:24:35.980, Speaker C: And now we have it right there, right click and then you have the path. So that's what this CLI is asking for. Close, so close.
01:24:35.980 - 01:24:41.610, Speaker C: Copy path. There we go. There it is.
01:24:41.610 - 01:24:53.470, Speaker C: Okay, now a lot of times the start block is also populated. But just in case it doesn't populate, depending on the situation at the moment, you have it right there. Copy and paste into terminal.
01:24:53.470 - 01:25:06.002, Speaker C: Okay. Now the contract name subgraphs can index lots of smart contracts all on the same chain all at once. So it's important to name your smart contract by its actual name.
01:25:06.002 - 01:25:14.214, Speaker C: You don't want to just have the demo name of contract because if you have 2310 smart contracts, not helpful. So we'll go here. Hey, there it is.
01:25:14.214 - 01:25:23.266, Speaker C: And copy. And from there paste a lot of copying and pasting. Very convenient from the scanner right there from Miniscam.
01:25:23.266 - 01:25:37.350, Speaker C: Now this is the, I think, impressive thing. The most impressive thing is when you actually see this occurring, this is the index contracts, events as entities, any events being emitted. Remember that little blocked pathway that I showed you where it had subgraph YAML and it went all the way to the schema GraphQL.
01:25:37.350 - 01:25:51.230, Speaker C: This is where that connection is occurring. All right. When you just press true right there, you're having this scaffold out and it's connecting all the things in the backend automatically for you to look at all the events in historical data that you can query using GraphQL.
01:25:51.230 - 01:25:57.780, Speaker C: So that's all doing that right now while this is occurring. Let's see. Come on.
01:25:57.780 - 01:26:13.530, Speaker C: Any questions so far? While this is spinning up. Question yes, I'm sorry, a single subgraph. So that's not there right now.
01:26:13.530 - 01:26:22.186, Speaker C: Now we have a single subgraph for a single chain. You could index as many different smart contracts you want on that same chain. If you have a different subgraph that'll be for a different chain and you could separate it like that.
01:26:22.186 - 01:26:52.482, Speaker C: You could have pipe all those different APIs into your front end and work with it like that. But good question. The second so wherever you want to start gathering information, you can do that if you want your subgraph, correct? Yeah, the initial deployment of exactly right where that smart contract was initially deployed, it automatically finds it for you and there it goes.
01:26:52.536 - 01:26:52.850, Speaker E: Perfect.
01:26:52.920 - 01:26:57.782, Speaker C: So now we could add another smart contract. We're not going to do that right now. So we'll say no.
01:26:57.782 - 01:27:08.502, Speaker C: And you are welcome to run through these steps here. I like to go back to subgraph studio at this point and here, which is more copying and pasting, super quick, super easy. You're going to authenticate.
01:27:08.502 - 01:27:24.702, Speaker C: First things first, very nice. And you're going to CD, just copy paste, copy paste and then graph CodeGen and graph build. Graph code gen is type safety, making sure all those connections that you've built up, let's say you make any modifications to your code.
01:27:24.702 - 01:27:33.040, Speaker C: It's important to keep those connections fresh. And then graph build compiles everything and you can read a lot about that in the documentation. Totally fine to do that.
01:27:33.040 - 01:27:42.642, Speaker C: We're just going to go ahead and graph code gen and graph build what has been scaffolded on the back end. We're not doing any changes so that's fine. And then we're going to deploy.
01:27:42.642 - 01:28:03.094, Speaker C: Now just so you know, when you deploy here you do want to have incremental versioning and also when it is deployed you should see the front end of the dashboard also respond nicely. There it is and it responded very nicely. So the build is completed, it has been deployed.
01:28:03.094 - 01:28:10.986, Speaker C: We have our development endpoint that is active right now. It is currently syncing at 73%. So it's gathering more information takes a little bit of time.
01:28:10.986 - 01:28:24.834, Speaker C: Just so you know, when you deploy a subgraph for the first time it takes about 5 minutes before it's queryable because there's a certain amount of cacheting going on in the back end. At 5 minutes it is going to be active. So just be a little bit patient right now though.
01:28:24.834 - 01:28:48.618, Speaker C: Let's go ahead and head back into the presentation as this is getting ready and let's keep on going in the presentation as that's going. So where are we right now? Okay, as that's spinning up, let's go ahead and do a reference for subgraph patterns. You may see these sometimes, you may not see these sometimes, but these are relatively common.
01:28:48.618 - 01:29:16.398, Speaker C: And then we'll see if these exist in the actual boilerplate subgraph that we spun up with our graph CLI and then we're also going to compare that to a very well developed subgraph as well. And you'll be able to compare and contrast something that's relatively simple, that is a boilerplate one to something a little bit more advanced. So if you are indexing a crypto punk, if you're trying to gather that, you're going to pipe that into an entity and an entity is in the front end, really what you're going to be querying.
01:29:16.398 - 01:29:33.670, Speaker C: So what buckets do you want to create? Generally speaking, you're going to create a contract entity, an account entity, NFT entity trait, entity metadata, and event interface. These are like different buckets that your subgraph will create and pipe the data into. And let's go ahead and go back to the actual code and see if that's the case.
01:29:33.670 - 01:29:44.426, Speaker C: So head back to Visual Studio code and there it is. Nope. Okay, so let's look at these buckets right now.
01:29:44.426 - 01:29:54.142, Speaker C: Everyone, let's say, hey, schema GraphQL. Hey, these were automatically created for us. We have an entity that is an assigned entity, a transfer entity, a punk transfer.
01:29:54.142 - 01:30:08.782, Speaker C: These are automatically created and these reflect the events that have been emitted from the actual smart contract. Just for the sake of this demo and just for the sake of being focused, I'm going to focus on the punk. Let's make it big so everyone can see the punk transfer entity.
01:30:08.782 - 01:30:30.454, Speaker C: Let's just focus on that and we're going to trace that all the way into our actual root level of the smart contract. So we have this entity right here, this punk transfer. How did this get here? How did this punk transfer entity appear here? Well, remember, if you take one step back from the different blocks that we were just at, it went from the schema to the mappings.
01:30:30.454 - 01:30:40.686, Speaker C: We got to go to the logic and that's going to be in the SRC folder. So let's look and see how this punk transfer event is actually getting populated. There it is.
01:30:40.686 - 01:30:53.726, Speaker C: Okay, we have export function handle punk transfer. So when a punk transfer occurs, this handle punk transfer handler triggers and there's the event right there. And you can see everything light up right there very nicely.
01:30:53.726 - 01:30:59.442, Speaker C: Thank you. Vs code and an entity begins to be populated. And we see this event right here.
01:30:59.442 - 01:31:08.342, Speaker C: This event params from. This is an event right here that is being emitted. And the from from the chain is going to the entity also named from.
01:31:08.342 - 01:31:16.046, Speaker C: Very nice. We have event params two and then that's also going to the two event params punk index. That's also going to the punk index.
01:31:16.046 - 01:31:25.222, Speaker C: Also, we have event block. Events also carry block information that's carrying the number. It's all just being piped right into this entity and it's being saved.
01:31:25.222 - 01:31:32.634, Speaker C: All right, that's all that's happening. It's simply coming from the event and being piped into our entity right there. And the entity is being saved.
01:31:32.634 - 01:31:38.754, Speaker C: I'm going to slow down. We got a few minutes. Any questions so far? Am I going too fast? Are we good? We're good.
01:31:38.754 - 01:31:51.678, Speaker C: Question. Yes, it's just a way of looking at the entity and saying, hey, this is how it's organized. I'm going to send a query to those entities.
01:31:51.678 - 01:31:55.334, Speaker C: Yes, great question. We'll get to that in just a second. So here we are.
01:31:55.334 - 01:32:10.422, Speaker C: We have our handler, that is, we're going from the front, which is the schema, and now we're going one level deeper to the handle punk transfer. How was this actually defined? Well, that was in the manifest. Let's go back to the root and we'll go to the subgraph YAML, which is the manifest.
01:32:10.422 - 01:32:19.820, Speaker C: And this is really how your subgraph is defined. It's really important information. We have everything that we put in the CLI, the address, the crypto punks market, the start block, important information.
01:32:19.820 - 01:32:32.574, Speaker C: I'm not going to go over mapping it's a little bit right there, but let's look specifically for the event handlers right there. And then there it is, the handle punk transfer. And it's looking at the event from the Smart Contract indexed uint.
01:32:32.574 - 01:32:37.314, Speaker C: And we have a uint right there. We have a few different informations. Right there.
01:32:37.314 - 01:32:51.622, Speaker C: The address that's really all the way to the front of this diagram that I had a second ago. Let's go back here. And here it is.
01:32:51.622 - 01:33:09.510, Speaker C: So we just went you could look at this from back to front or front to back. And you'll need to do that regularly when you're developing on subgraphs because you'll be interacting back and forth. So let's keep on going and let's look to see are there any Immutable events? We're running low on time.
01:33:09.510 - 01:33:17.470, Speaker C: We're going to keep on going. This is something that you'll see regularly. Immutable events are important for just keeping logs of straight up blockchain information.
01:33:17.470 - 01:33:35.586, Speaker C: If it's in blockchain information, you should keep it Immutable because you're simply just keeping a log. That's just something you should look into. Aggregation entities, entities that have a lot of information from various sources on the blockchain you want to have on a single entity like a contract, might have information that is being aggregated, definitely have that in there.
01:33:35.586 - 01:33:49.686, Speaker C: And linking entities to have a little bit more power on the front end. You could link entities using one to one or even one to many or many, many relationships and also reverse lookups. You also want git or create helpers because assembly script needs null checks.
01:33:49.686 - 01:34:05.882, Speaker C: Just check on those and there's a few other tips and tricks. So document your schema well. Let's go into that really quickly as well so we could see how important that is when you document your schema well, that allows people to really understand what they're querying.
01:34:05.882 - 01:34:20.926, Speaker C: And let's go ahead and go into a subgraph that is now published on the graph network that is well designed. Because remember, the graph network is not just indexers. The graph network has subgraphs and those subgraphs are also part of a marketplace.
01:34:20.926 - 01:34:33.186, Speaker C: Let's go find a subgraph that is also indexing the CryptoPunks smart contract in a more built out way. So we're going to go to the graph.com and explore.
01:34:33.186 - 01:34:47.386, Speaker C: And you could see all of the subgraphs that are currently active. We just spun up a subgraph and we haven't published it yet. But now these are all published and what we want is a crypto punks subgraph that is currently gathering information.
01:34:47.386 - 01:34:58.942, Speaker C: There we go. So we can see a few different CryptoPunks subgraphs. Which one do you want to choose? Generally speaking, the one with the most signal on it, generally speaking, that is being incentivized by the marketplace itself.
01:34:58.942 - 01:35:07.342, Speaker C: That is the GRT utility token that is incentivizing. This right here. So we're going to choose that one and you can see it's gone through a few different versions.
01:35:07.342 - 01:35:22.018, Speaker C: We can go into all of this, but what we really want to do is go to the playground and also from here we want to go let me go back. We want to go into where is it? There it is, the actual GitHub repo. All right, so we have the GitHub repo.
01:35:22.018 - 01:35:34.566, Speaker C: We're seeing how this is being built and we can also query it. Let's go ahead and take a look at the GitHub repo. And see here the Schema GraphQL, which is really what you're querying.
01:35:34.566 - 01:35:37.280, Speaker C: You're sending your queries. That is these are the buckets. Remember that.
01:35:37.280 - 01:35:56.302, Speaker C: Okay, so remember we had the punk transfer entity before and we were tracing that. Well, this developer here, he had the kindness to actually put in the actual things you're querying. So if you're looking at a let's not look at interfaces, let's look at an entity.
01:35:56.302 - 01:36:19.174, Speaker C: Here we have an aggregation interface right here where we have an account and there's lots of different properties on this account. Let's not have that there. And he's done such a nice job with the mappings and also with gathering blockchain data and organized it so well that when you type in a query, a GraphQL query to the account entity, you know exactly what you're going to be querying.
01:36:19.174 - 01:36:32.394, Speaker C: Do you want to know punk transfers by account? And you put in the account number. You can get that right there. It's very nicely well documented from this, which is of course, we don't have documentation on our actual not Abi JSON.
01:36:32.394 - 01:36:49.140, Speaker C: We don't have it on our Schema GraphQL because this was just boilerplate. But when you're building out have some nice documentation, tell developers what you are actually doing and that helps them from there. Let's go ahead and go to the next part of this presentation where there we go.
01:36:49.140 - 01:37:04.386, Speaker C: We can compare queries with two different subgraphs. We have our boilerplate subgraph that we spun up and we have a more advanced subgraph that we spun up. And then from there well, what type of questions can we ask to this subgraph? Can we ask some questions to this basic subgraph.
01:37:04.386 - 01:37:22.726, Speaker C: Sure we could. Or could we ask some more advanced questions? And if you guys want, we have this presentation right here with all of these questions where you could practice and see okay, well, if I could look at the schema and trace it all the way back to the blockchain, that would be helpful on your subgraph. Or if you would like to use the more advanced subgraph, some of these questions can be answered by the more advanced subgraph.
01:37:22.726 - 01:37:35.662, Speaker C: Let's just go ahead and do the first one just to do that and then you guys on your own are free to go through this on your one. Tell me about CryptoPunk number one's, transfer history. So what we're going to do is go to Subgraph studio.
01:37:35.662 - 01:37:45.186, Speaker C: So we have this setting up right now and we'll go here on the right. And this is our little explorer right here. We could send some test queries.
01:37:45.186 - 01:37:54.106, Speaker C: We're not, of course, going to the API endpoint. And remember that punk transfers event that we're looking through from the very beginning. Let's go ahead and look at that.
01:37:54.106 - 01:38:08.590, Speaker C: We have the punk transfers event. And what we want to do is we want to go ahead and let's go ahead and look at punk transfer ID. We want the punk transfers.
01:38:08.590 - 01:38:22.258, Speaker C: There we go. Punk index and first ten where the punk index is equal to one. Okay.
01:38:22.258 - 01:38:31.934, Speaker C: And we want to see the punk index, which is the first punk one right there. It's the first ten right there. And we want the punk index.
01:38:31.934 - 01:38:43.080, Speaker C: We want the ID, we want to, we want from let's see where it came from, the timestamp and why not? Let's get the transaction hash, two demo gods. There we go. Oh, dang it.
01:38:43.080 - 01:38:47.026, Speaker C: Let's go ahead. We've been having that happen. There we go.
01:38:47.026 - 01:38:51.546, Speaker C: So I pulled this up earlier. We're having Internet connection issues sometimes. And here it is.
01:38:51.546 - 01:39:04.670, Speaker C: We have this punk transfers, punk index number one, where you have the ID and then to and from and the block timestamp all the way through, all the way from the chain. And then you're able to organize that at the front end. There we go.
01:39:04.670 - 01:39:07.040, Speaker C: Okay, that's the end of the presentation, everybody.
01:39:16.070 - 01:39:18.734, Speaker E: So the big difference between the graph.
01:39:18.782 - 01:39:40.314, Speaker C: And just using like an RPC provider to get information is that your graph can get historical information, all the historical information from wherever smart contract had been deployed and then all the way through. Yeah, that's just bringing it right from the front. Yeah, sure.
01:39:40.314 - 01:39:55.050, Speaker C: So when you have created a subgraph that you really like and you're like, man, this thing could actually have some legs, you are going to publish that to the network. We just deployed a subgraph today, which is great publishing. It actually shows indexers around the world that, hey, this subgraph is valuable.
01:39:55.050 - 01:40:11.362, Speaker C: And then you signal that with curation in the form of GRT utility token so that tells indexers out there they could be incentivized if they take action by getting a small reward from that actual signal. And that's how a lot of the economics works. Within the graph, there's lots of different types of this subgraph is well built.
01:40:11.362 - 01:40:24.126, Speaker C: It helps if developers make their subgraph and make them public. So different indexers can say, OOH, different people can actually not just indexers, but curators and delegators different participants can just partake in the entire ecosystem.
01:40:24.258 - 01:40:28.666, Speaker D: When you deploy without publishing, where does that run?
01:40:28.768 - 01:40:39.306, Speaker C: So that's being run on actually centralized indexers that the graph has, and it's more of a development area. And then when you're actually finished with developing, you're ready to publish. You're able to go out.
01:40:39.306 - 01:40:44.810, Speaker C: That's why it's a free indexing service. You're able to actually use that development query endpoint. Feel free to play in there and get it nice and ready.
01:40:44.810 - 01:40:53.140, Speaker C: If you're hacking, go ahead and use that. But when you're ready to publish, then it goes out the network. Yes.
01:40:53.140 - 01:41:05.902, Speaker C: So when you've deployed it through the subgraph studio and you haven't published it, it's free. You're free to go ahead and query. You're free to use the development API endpoint right there.
01:41:05.902 - 01:41:14.122, Speaker C: That is for hackathon. That's for people right away. When you're ready to start participating in the network, you publish it to the network and you can actually start earning rewards yourself.
01:41:14.122 - 01:41:20.940, Speaker C: You're able to start curating or actually start participating in your own way. That's it. Okay, perfect.
01:41:20.940 - 01:41:34.314, Speaker C: Thank you. I got through it all.
01:41:34.352 - 01:41:35.370, Speaker F: I was tough.
01:41:37.390 - 01:41:38.940, Speaker C: Really. Thank.
01:44:34.740 - 01:44:37.330, Speaker E: All right, that seems to be working.
01:44:41.300 - 01:44:44.790, Speaker C: Martin from awesome.
01:44:47.560 - 01:44:49.508, Speaker E: All right, guys, thank you very much.
01:44:49.594 - 01:44:50.484, Speaker B: Very happy to be here.
01:44:50.522 - 01:44:55.396, Speaker E: My name is Martin. I'm from Quantstamp. We are smart contract security auditors.
01:44:55.396 - 01:45:14.910, Speaker E: So I'll be talking about best practices for smart contract development and best practices for developing smart contracts in Solidity. Specifically, the talk is aimed towards beginners. So if you are a very well versed Solidity programmer, probably you will be bored in here.
01:45:14.910 - 01:45:37.056, Speaker E: But hopefully for the rest of you, I will be able to pass some good notes. So the agenda for the talk, at first I'm going to introduce Solidity as the language and the EVM, just so that we are on the same page of what kind of execution environment we are talking about. Then I will be talking about some specifics that Solidity as a language has over other languages.
01:45:37.056 - 01:45:52.008, Speaker E: And then I will be covering the best practices those do's and do nots. So introduction to solidity and EVM. You're at an Ethereum hackathon, right? So you probably have heard the word Ethereum virtual machine before.
01:45:52.008 - 01:46:19.932, Speaker E: Ethereum virtual machine is a virtual machine that is powering the Ethereum blockchain and that is powering the execution of smart contracts on Ethereum blockchain. It is a stack based machine. And when you develop smart contracts, pretty much what you're doing is typing some high level programming language that gets compiled to bytecode and that bytecode then eventually just contains opcodes that somehow manipulate the data on the stack.
01:46:19.932 - 01:46:37.610, Speaker E: So we have opcodes such as Add which adds two numbers on stack. We have opcodes such as Call that sends transactions. We have opcodes such as Load or Write for writing and reading from the memory or storage of a Smart Contract and so on.
01:46:37.610 - 01:47:09.932, Speaker E: Then the EVM uses something called Gas to measure how much computation was carried out and bills the users who triggered the computations for that. It's for a very good reason because all the miners or validators in the network will be interpreting those transactions and will be running those computations. And we don't want anybody to be running computations on our machines for free, right? So that's why Gas actually exists and the actors on Blockchain are identified by addresses.
01:47:09.932 - 01:47:20.640, Speaker E: We have two types of actors. One is the general people who transact through something that we call externally owned accounts. And then we have smart contracts.
01:47:20.640 - 01:47:41.496, Speaker E: The difference between Smart Contracts and externally owned accounts is that Smart Contracts do not have private keys or nobody knows what those private keys are. So Smart Contracts cannot sign or initiate transactions. Everything comes from people's own externally owned account for which we do have private keys, right? This is how we have created and generated those accounts.
01:47:41.496 - 01:47:54.428, Speaker E: So this is kind of the setup that we are going to be talking about. Now, the language that we use to develop Smart Contracts I already mentioned is called Solidity. So Solidity is an object oriented statically typed language.
01:47:54.428 - 01:48:17.268, Speaker E: It's similar to JavaScript, Java, C Plus Plus or anything of this similar category. But it is specifically catered towards developing Smart Contracts. So it provides us with data types that we will find on Blockchain, right? Those addresses, those unsigned INTs and bytes and it will provide us with blockchain specific functionality.
01:48:17.268 - 01:48:48.800, Speaker E: So for example, functions for sending and receiving ether can be controlled through primitives of this language, right? Unfortunately, compared to other languages that you might be used to, it actually has a limited standard library. So it doesn't contain whole bunch of things that I will be talking about a little bit later that you might be used to. And it also has many blockchain specific gotchas that other languages do not really have or are not relevant in other settings.
01:48:48.800 - 01:49:22.616, Speaker E: So let's take a look at something that is kind of sort of special to Solidity. First of all, Solidity similarly to other programming languages, contains some access modifiers that allow us to indicate whether certain variables or functions should be accessible from other Smart Contracts, right? So it has something called keyword Private, which if you are used to developing in other languages, just signifies that external classes or external actors cannot access our data. Right? So this is the first gotcha for Solidity.
01:49:22.616 - 01:49:35.836, Speaker E: Anything that is marked as private really means that you cannot query it directly on chain, but it. Doesn't mean that that data is private. At some point it made it on blockchain using a transaction.
01:49:35.836 - 01:49:54.868, Speaker E: That transaction can be queried from the archive nodes and any participant in the world is essentially able to derive what the particular private variable currently holds as data. So even though stuff is sometimes marked as private, it's actually not truly private. Private only means that you cannot query it on chain.
01:49:54.868 - 01:50:19.816, Speaker E: It's definitely possible to learn what is in those variables. The next special thing that Solidity has over other languages is that stuff that allows us to interact with blockchain and reference the blockchain context itself, right? So we have context that relates to blocks. At any point we can query these environment variables that are initialized with the block number timestamp and hash.
01:50:19.816 - 01:50:46.520, Speaker E: And then we also have some environment variables that relate to the context of a transaction and message itself. So who was the initial person who sent the transaction? What was the gas price that was allowed for this particular transaction and for this given message that arrived directly through the smart contract? Who is the sender? What is the value that is being sent along with this message? What is the call data? And so on. So this is something that we have available in Solidity.
01:50:46.520 - 01:51:10.892, Speaker E: What we do not have available in Solidity over other programming languages is floating point arithmetic and floating point numbers. That doesn't exist at all. Solidity only has integers, okay? So that comes in question when you are dividing or when you actually want to use those floating points numbers, right? So all division in Solidity will always be integer division.
01:51:10.892 - 01:51:54.430, Speaker E: So one over two will result in zero and similarly and analogously other divisions will behave. And when you need to somehow have access to floating point numbers, you essentially have to simulate them, right? So what we usually do in Solidity is that we say okay, we will work with really long numbers and past certain point all the zeros past this point will be dedicated to representing the decimal positions past the floating point, right? So that's something that is very important to remember. Whenever you work with something especially like Ether, you are always working with super long decimal numbers.
01:51:54.430 - 01:52:07.616, Speaker E: So Solidity doesn't have floating point. Another thing that Solidity doesn't have is random number generators. There is no way for you to go and say hey, smart contract, generate a random number.
01:52:07.616 - 01:52:21.380, Speaker E: People really like having that functionality, right? Because we want to develop games, we want to develop lotteries, we want to develop stuff that actually has some randomness in it. But unfortunately it doesn't exist. And again, it doesn't exist for a very good reason.
01:52:21.380 - 01:52:39.652, Speaker E: Because we know that the transactions that will be executed will be executed by a whole bunch of miners and validators in the internet, right? And they have to be deterministic. They have to have deterministic results so that everybody arrives to the same state of the blockchain. So therefore generating random numbers is not a thing in solidity.
01:52:39.652 - 01:52:57.372, Speaker E: So what people very often try to do, they actually try to exploit those environment variables that I was talking about a little bit earlier. So what is my blog hash, what is my transaction hash, what is the current timestamp? And use that as a source of randomness. But that is not really random, right? And it is also predictable.
01:52:57.372 - 01:53:23.348, Speaker E: So it's actually wrong to be using that for randomness. And if you at some point require using random numbers in your software development, what you need to do is actually use random number generators in the form of Oracles, which I'll be talking about a little bit later as well. So we don't have random numbers and we need to remember that I already said that smart contracts are accounts that have some code associated with them, but they do not have private keys.
01:53:23.348 - 01:53:42.000, Speaker E: So another thing that you might want to do, but will not be able to do is schedule some transaction and have it be initiated by a smart contract that doesn't work. Smart contracts cannot initiate anything. It's always people and externally owned accounts that actually can sign and create transactions.
01:53:42.000 - 01:53:58.736, Speaker E: On this particular slide, I have two words that I want you to understand for the rest of the talk. So one word is called Immutable. It means that once you put something on blockchain, it stays there forever.
01:53:58.736 - 01:54:23.180, Speaker E: You cannot change that and you cannot delete that. If you work with Immutable data, it will just be there and it will not change. Even if you work with data that is not immutable and you somehow explicitly allow for your smart contracts to change and for these pieces of information to be somehow replaced with other pieces of information, the history will still be available as well.
01:54:23.180 - 01:54:42.748, Speaker E: So just the sheer fact that you've put something on blockchain that you've changed, it doesn't mean that nobody will ever be able to see what was in that variable in the past. The other thing that I want you to understand is atomic execution. So what we have on Ethereum is transactions.
01:54:42.748 - 01:55:02.036, Speaker E: And those transactions are being executed in an all or nothing fashion and nothing can interrupt the execution. So there is nothing like a processor where you would have multiple processes. And sometimes this guy gets the core, sometimes this guy gets the core and that's somehow interleaved and preempted that doesn't exist.
01:55:02.036 - 01:55:17.260, Speaker E: Transaction starts running and it finishes all the way to the very end unless it reverts. If it reverts, nothing ran, it rolls back all the state, okay? So that's the property of the runtime that we are having. So transactions are atomic.
01:55:17.260 - 01:55:52.632, Speaker E: The other thing that we do not have available, and we would very often like to have available, is access to external data. So you might want to develop a smart contract that for example, provides entrance for delayed flights, right? And a normal Web Two developer, the way how they would think about such a system is, okay, well, I need a system that will query some API that will learn whether my flights were delayed or not, right? So sometimes developers try to stuff access to API and Internet into smart contracts. But there is no such thing.
01:55:52.632 - 01:56:04.776, Speaker E: It just doesn't exist. You cannot query the internet from smart contracts. Smart contracts are only capable of querying data that is already recorded in some other smart contracts.
01:56:04.776 - 01:56:31.216, Speaker E: And so companies and the Ethereum community developed something called Oracles, where Oracles are smart contracts designated specifically for this purpose. They are made to record some kind of information and then communities and external actors, they record this type of information into smart contracts. So if you want some specific data, you have to find an Oracle for it and then you can query that Oracle's API.
01:56:31.216 - 01:56:50.700, Speaker E: So, this is kind of the situation that we are at with Solidity. And now I will be going through a very long laundry list of what you should be doing and what you should keep in mind when developing your smart contract. So, the first thing that I want to cover is checkfx interaction pattern.
01:56:50.700 - 01:57:10.332, Speaker E: So you might be able to Google a whole bunch of lists with best practices for developing smart contracts in Solidity. And every single list will contain this check effect interactions. This rule specifies the order in which you should be making actions inside of your functions.
01:57:10.332 - 01:57:17.540, Speaker E: So here I have a snippet of code. It has two functions. One is called bad withdraw, one is called good withdraw.
01:57:17.540 - 01:57:33.556, Speaker E: Both of these functions have some state check, right, that's the require at the beginning. Then it applies some or they apply some changes to the state. That's the line where I am decreasing the balance of the message sender.
01:57:33.556 - 01:57:59.644, Speaker E: So in the good withdrawal, that happens right after the require check, and in the bad withdrawal, that happens at the end of the function. And what is in between in the bad withdrawal is the interaction. It's the transfer of a balance that is actually making a call to the message sender, right? And that actually transfers the execution power to the message sender.
01:57:59.644 - 01:58:18.436, Speaker E: Because when we send Ether in Solidity, what gets invoked are some special functions in smart contracts. So in the bad withdrawal, we are actually not respecting this pattern check effect interaction. That interaction should come at the very end in the order that I have it in the good withdrawal.
01:58:18.436 - 01:58:47.024, Speaker E: And the reason why this is really, really important is a very profoundly known vulnerability called retrancy. So what can go wrong if you have effects? Sorry, if you have interactions in the middle of an execution, somebody in the middle of that transfer of ETH can come and they can make another call to your function, to your bad withdrawal. And this pattern is designed so that in 99.9%
01:58:47.024 - 01:59:08.964, Speaker E: of cases, it actually protects you from such defects. So whenever you are doing stuff, whenever you're interacting with other contracts, the interaction comes always at the very end after you update the state. The second item that I want to cover here are pull patterns and push patterns.
01:59:08.964 - 01:59:42.864, Speaker E: So what people want to very often do is somehow give something to other people, to other addresses and accounts on Ethereum, right? So imagine that you have some treasury and the treasury wants to distribute some rewards or some NFTs or something like that. So you have two options. Either you actually do it actively, you are the treasury and you are going to dish out the gas and you are going to pay for transfer of the asset to every single person, right? Or you can adopt the philosophy where you say you are entitled to get something from me, but you have to come and you have to grab it.
01:59:42.864 - 02:00:04.372, Speaker E: In such a case you will not have to pay gas for transferring the asset to every single person, right? The person came, initiated transaction, they are paying for the gas on their own. So we always prefer pull patterns over push patterns. The reason why we actually prefer pull patterns over push patterns is not that push patterns would be way too expensive.
02:00:04.372 - 02:00:21.616, Speaker E: That's usually the secondary reason. But the real reason is that the push pattern can actually fail. Because if you imagine that you are transferring ether to a smart contract, to whole bunch of smart contracts, one of these smart contracts can just say no, I'm rejecting this ETH, I don't want it.
02:00:21.616 - 02:00:37.344, Speaker E: I'm going to revert your transaction. And if you remember my spiel about atomic transactions, that means that nobody is going to receive the Ether, right? Because the entire transaction is going to revert and is going to be rolled back. So that's the problem with the push patterns.
02:00:37.344 - 02:00:55.680, Speaker E: They have so many, so many interactions that can actually dos your system. So we prefer pull patterns over push patterns. The next thing that new developers in Solidia are very confused about is the difference between Assert and Require.
02:00:55.680 - 02:01:28.932, Speaker E: So both these keywords serve the purpose of reverting a transaction if some kind of a condition is not fulfilled, but they behave differently with respect to refunding the gas to the transaction initiator. So in the case of Assert, if you're asserting that some condition holds in Solidity, if the condition doesn't hold, your transaction will be reverted but all the gas that was provided to this transaction will also be consumed. The invoker of the transaction will not receive anything back.
02:01:28.932 - 02:01:47.660, Speaker E: On the other hand, with Require the person who invoked the transaction will receive all the gas that is left back. And that kind of drives the difference between the two functions. We use assert to make sure that some conditions, some kind of state that we are assuming holds.
02:01:47.660 - 02:02:44.712, Speaker E: So if you're assuming that your system is in some particular state, you check it with assertions and if one of those assertions fails it means that either you have some bug in your smart contract and that smart contract got to a state where it should never never work or somebody's actually attacking you, right? They found some attack vector and they decided that they will use this attack vector to bring the smart contract to a state where it shouldn't be and shouldn't operate. And in such a case it's actually very okay for you to burn all the remaining gas for this transaction and say fine, we are done, we are just going to revert in here, right? On the other hand, require is used to check results where you fully expect that the result of an external call to somewhere might have failed. You called some smart contract, the smart contract was like nah, I won't do that and you say yeah, this is fine, this is a perfectly fine outcome.
02:02:44.712 - 02:03:20.244, Speaker E: Maybe, I don't know, I didn't provide enough tokens, I didn't have balance or your smart contract just like rejected and that's okay. So require in the cases where we are anticipating a possible failure and just wants to say no and assert in cases where we are making sure that we are in a good state before we do anything cool, the next thing that I want to talk about are modifiers. So this is a special feature of Solidity as a language you will not find custom modifiers somewhere in Java.
02:03:20.244 - 02:03:37.032, Speaker E: You might find something similar in Swift in the form of extension. But essentially modifiers allow us to add code that will be executed before or after or both to a function. Here I have actually an example of a modifier.
02:03:37.032 - 02:03:51.490, Speaker E: I have function non reentrant where I do something and it's annotated with that word lock, right? And lock is a modifier that at the beginning acquires a lock so it checks that the lock is sorry.
02:03:53.540 - 02:03:53.856, Speaker C: A.
02:03:53.878 - 02:03:56.032, Speaker E: Log checks for us that nobody else.
02:03:56.086 - 02:03:57.184, Speaker B: Holds a lock, right?
02:03:57.222 - 02:04:07.124, Speaker E: And it acquires a lock. Then I have that underscore and semicolon which says execute my function and then in the end we release the lock. So those are modifiers.
02:04:07.124 - 02:04:27.080, Speaker E: What people started doing is the modifiers, they are originally intended for checking stuff, right? So that would be where you do your checks in the checked effect interaction. But people actually started stuffing a lot of logic into these modifiers. We see it very often in audits.
02:04:27.080 - 02:04:50.660, Speaker E: What it results in is a spaghetti code. If you go back to your intro to programming courses and the languages that contain the Goto statement you've probably heard many many times do not ever use Goto because it just breaks the flow of the code and it results in spaghetti. Same thing happens if you start stuffing the modifiers with too much logic.
02:04:50.660 - 02:05:03.736, Speaker E: The example that I have in there, this is the only acceptable example of where you can put some right logic and some side effects into a modifier. There is very little of it. It's literally three lines of code.
02:05:03.736 - 02:05:18.620, Speaker E: So that's probably roughly the maximum and the effect is not permanent, right? This modifier itself, it locks and then unlocks. So it's predictable. So do not put too much logic in your modifiers.
02:05:18.620 - 02:05:39.428, Speaker E: I'm going to skip this slide because I want to get to some more interesting stuff. So for this slide only, remember, if you want your smart contracts to be able to receive Ether, you have two options. You either can implement function called receive or function called callback or both of them.
02:05:39.428 - 02:06:09.724, Speaker E: And there is a difference when these functions get invocated. So look it up in the documentation if you do not know the one gotcha that I am going to definitely mention in here is you can never assume that your smart contract has zero ether balance even if you do not implement these functions. So even if you say hey, my smart contract can never, never accept ether, it is absolutely possible to force sent ether using instructions called self destruct.
02:06:09.724 - 02:06:44.456, Speaker E: So never make an assumption that your contract has a zero balance unless you actually check it directly in the code. Here is a slide about pragmas. So pragma declares for us what kind of version of Solidity we are going to be working with and what kind of version of compiler we are going to be compiling these high level words that are very similar to English into bytecode, right? So that's, that line that I have there in the example underlined we can declare pragmas in two possible ways.
02:06:44.456 - 02:07:04.672, Speaker E: We can either declare a pragma that is fixed version that's right here 0.8.15 or we can put that like little carrot character in front of it or the greater sign, right, which allows floating pragmas which essentially mean that I will be able to compile this code with anything that is 0.8.15 or higher.
02:07:04.672 - 02:07:46.908, Speaker E: Okay? So best practice here is always lock pragmas of your smart contracts and the reason why you should be locking the pragmas of your smart contracts is the software development lifecycle. So imagine that you're developing, right, and you're working on a big project and you're done and then the rest of your team is not done and you are just waiting for one to two more months for the rest of the team to be done and then maybe audits to happen, right? Eventually somebody is going to come and will wants to deploy your code on blockchain. But within that time span, those two months, three months, however long this took, it's totally possible that the compiler has changed, right? That two new versions actually came out.
02:07:46.908 - 02:08:05.632, Speaker E: And so then when somebody starts deploying your smart contract, it's totally possible that they compiled it with a different version of the compiler than the version that you actually have tested it with. So the code that ends up on blockchain is different from what you've tested and that might be wrong. And yes, compilers do have bugs.
02:08:05.632 - 02:08:27.604, Speaker E: They get fixed all the time. But the way how you should keep up with your compiler and have it be up to date is by declaring fixed pragmas and then updating them deliberately every once in a while. I'm slowly running out of time here, so let me maybe mention something about timestamps.
02:08:27.604 - 02:08:39.768, Speaker E: I had a lot more slides, but we will not be able to cover that. That's fine. So using timestamps in smart contracts for any kind of logic and decision making is an anti pattern.
02:08:39.768 - 02:09:08.216, Speaker E: When we were in the Ethereum proof of work situation, we would have multiple miners, right? They would be trying to solve the proof of work puzzle, and at some point they would be successful and they would start propagating these blocks throughout the network through something called Gossip Protocol. Well, the Gossip Protocol, it's a peer to peer communication protocol. It has some latency, right? It takes time for me to produce a blog and send it all over the world to the other side.
02:09:08.216 - 02:09:29.400, Speaker E: So this network, it admitted tolerance in timestamps to roughly 15 seconds. So me as a miner, I would always be able to push that timestamps a little bit to the future, a little bit to the past, whenever it was convenient for me. Now, this is no longer the case because since Ethereum transitioned to proof of stake, I am not able to do that anymore.
02:09:29.400 - 02:09:51.296, Speaker E: We have a fixed interval of 12 seconds where every single block has to fall into. Right? So timestamps are predetermined, but there are many chains in the world that still do not have predetermined timestamps because they do operate on some kind of a proof of work system, and they are forks of Ethereum. So never assume that timestamps are not manipulable.
02:09:51.296 - 02:10:08.172, Speaker E: And the good rule of thumb is think about also tolerance for yourself. Think about those 15 or even 30 seconds. If your smart contract can operate with 15 or 30 seconds tolerance, then your usage of timestamps is okay.
02:10:08.172 - 02:10:22.368, Speaker E: If it cannot, and if you require the time that it got reported is absolutely accurate, then you are doing it wrong. Okay? So very careful about timestamps. All right, looking at the clock, 10 seconds left.
02:10:22.368 - 02:10:32.690, Speaker E: I'm going to stop right here. If you have any questions, please shoot them right now or find me or Jan sitting in the back after here at the hackathon. We'll be happy to help.
02:10:32.690 - 02:11:13.132, Speaker E: Yes. Do we have some public space to post slides? Yes. So Mohammed over there in back had some talk here at the beginning, and we brought some T shirts, so we tossed them in these packages on these tables.
02:11:13.132 - 02:11:25.270, Speaker E: And those are the three T shirts that are left. So you should grab some and wear it. All right, thank you.
02:14:49.960 - 02:14:50.710, Speaker C: Welcome.
02:14:54.840 - 02:15:04.470, Speaker F: All right. Okay. One 2341-234-1234.
02:15:04.470 - 02:15:09.268, Speaker F: Yep. All right, we'll get started.
02:15:09.434 - 02:15:10.790, Speaker G: Please join me.
02:15:11.320 - 02:15:12.550, Speaker C: Stanley from.
02:15:19.040 - 02:15:25.016, Speaker F: Hi, everyone. I'm Stan Lee. I'm from Gnosis Chain.
02:15:25.016 - 02:15:34.880, Speaker F: Specifically Gnosis Builders ecosystem builder team. For Gnosis. Today I'll just be going through the what, why and how of nosis chain.
02:15:34.880 - 02:15:54.176, Speaker F: So, yeah, just the first little to introduce the prizes we have for E for loo. So we'll be awarding a total of 20,000 USD for the use of noisy chain. So we have in addition to our gold, silver and bronze price, we also have different tracks.
02:15:54.176 - 02:16:02.120, Speaker F: So best AI project on nosis chain will be and we also have best project on Hashi. And lastly, best project on Safe.
02:16:03.740 - 02:16:04.164, Speaker C: Yep.
02:16:04.212 - 02:16:25.084, Speaker F: So I'll just be going through what is nosis chain, why and how and also going through a bit on what's nosis builders and at the last I will just introduce hashi. So what is nosis chain. So, nosis Chain is a level one proof of stake based EVM compatible chain.
02:16:25.084 - 02:16:36.112, Speaker F: So it utilizes a dual token system. So for Xdai for gas fees and GNO for Staking. So the XDI token is a USD pack token.
02:16:36.112 - 02:16:58.460, Speaker F: So it's a stable coin that is derived from die on ethereum. So that makes it possible for the transactions to be very cheap because with $100 you can perform as many as 100,000 transactions or more. And for nosis chain, it's also community powered and developer focused, so anyone in the world can become a validator on the chain.
02:16:58.460 - 02:17:24.884, Speaker F: So the goal, what's the mission of Nosischain? So, Nosischain aims to be the most decentralized blockchain. We already have the tools actually to measure the level of decentralization as shown as the screenshot. And why nosis chain is most suitable for this goal is currently because we have over 129,000 validators and it's still growing every day.
02:17:24.884 - 02:17:46.330, Speaker F: And the barrier of entry to become a validator in nosis Chain is very low. So one GNO is all you need compared to 32 if for Ethereum. And nosis chain also tries to be accessible for user types through like a straightforward user onboarding experience.
02:17:46.330 - 02:18:15.248, Speaker F: So, the key priorities of nosis Chain is, like I say, decentralization. We want to have a resilient backbone for Nosischain and we also want to have an intuitive validator experience for anyone who wants to come and validate for Nosischain. And we also provide a seamless and accessible onboarding process for users into the Nosischain ecosystem.
02:18:15.248 - 02:18:43.944, Speaker F: And lastly, we also have a growing ecosystem of tools and infrastructure to support DApps, DAOs and et cetera on Nosischain. So just to introduce what is Noddy chain, I'll just go through why. So Noddy chain with over 129,000 validators, it is the third most decentralized chain.
02:18:43.944 - 02:19:00.200, Speaker F: So after bitcoin and ethereum. And our speed noisy chain is fast with average block time of 5 seconds. And getting started with nosis chain is innovative and cheap because we have affordable transaction costs.
02:19:00.200 - 02:19:08.420, Speaker F: And lastly, because fees are in XD stable coin, nosis chain is stable.
02:19:10.120 - 02:19:10.496, Speaker C: Gas.
02:19:10.528 - 02:19:24.048, Speaker F: Transaction because the cost is not susceptible to market volatility. So, this is the current state for nosis chain. So these are derived from Gnosis metrics.
02:19:24.048 - 02:19:47.456, Speaker F: So we have 237,000 active accounts with over 5 million transactions and 129,000 validators with $14.9 million in total deposited USD. And for validators who are validating for noisy chain we also have a yield of 14.6%.
02:19:47.456 - 02:20:24.536, Speaker F: So this is another incentive for validators who want to validate for so why developers choose notice chain? Because it's user friendly and nodded chain is accessible for everyone and anyone can actually interact with your project easily. It has also a strong ecosystem of budding ecosystem of Excelling projects, tools and resources. And we also have a grants program by Gnosis Builders so we also allow public good projects to apply for ecosystem grants.
02:20:24.536 - 02:20:45.424, Speaker F: And through nosis Builders we also provide project support. So projects built with Nosischain can actually hit us up and they can receive support for marketing, liquidity networking and more from the nosis Builders team. So this is a summary of our ecosystem at a glance.
02:20:45.424 - 02:21:03.604, Speaker F: So this was taken in December, so from then we are still growing. So I'll just go through how to build for nosis chain. So, nosis chain is an EVM compatible chain.
02:21:03.604 - 02:21:37.680, Speaker F: So anything that you have developed, for example smart contracts that we develop for Ethereum can be easily ported over to Nosischain. You just have to check out these RPC endpoints and alternatively you also can also auto config your MetaMask wallet by going to this chain list where we have like a one link set up. All of this information will be available in the Docs or so this is just for your consideration.
02:21:37.680 - 02:21:54.600, Speaker F: And like I mentioned, nosis chain is 100% EVM compatible. Means you can actually use all of the DF tools, development tools that you use on Ethereum, on Nosischain without changing anything. In fact, you can take a smart contributor for Ethereum and deploy Nosischain without much hassle.
02:21:54.600 - 02:22:05.624, Speaker F: So here are the useful resources for Nosischain. So we have the first is nosis IO. So it's the main website and provides a quick overview of the nosis chain.
02:22:05.624 - 02:22:17.516, Speaker F: We also have Docs Nosischain.com so it's the entry point for all documentation for Nosischain. And Gnosis wallets will just list the support wallets for Nosischain.
02:22:17.516 - 02:22:40.440, Speaker F: nosis Faucet will allow developers like you to actually get a small amount of XDI to deploy your projects. And for users who would like to validate for Nosischain, after this hackathon you can actually visit validatenosis.com and we have an interface for you to actually learn on how to validate for Nosischain.
02:22:40.440 - 02:23:25.750, Speaker F: So yeah, I'll just go through like a quick overview of what's nosis Builders so I'm from nosis Builders so we actually provide tools for users and developers to get on board on Nosischain. So yeah, our tools are on Slash tools and we also have useful information for developers, users, validators and we also have community events and all of these are here and all of you can check out. And for projects who like to collaborate with us, you can actually reach us out and we'll try to meet with you and provide as much support as possible.
02:23:25.750 - 02:23:31.000, Speaker F: So let's switch gears. Today. I'll also be going through hashi.
02:23:31.000 - 02:23:55.628, Speaker F: So Hashi is a new project launched by nosis Guild, which is a cross chain protocol based on additive security. So Hashi is the hash Oracle aggregator for cross chain communication based on additive security. So multiple inputs and multiple oracles.
02:23:55.628 - 02:24:41.436, Speaker F: So at its core, Hashi is a hash Oracle aggregator and it allows developers to build what Oren calls ryho so redundant array of hash Oracles. So the main goal here is to distribute trust for bridges on the mechanism level, where essentially you don't have to trust a particular individual bridge mechanism and allow users to set up a layer of independency for their systems. So why hashi? So Hashi was created by the Gnosis Q team because there were many security incidents involving security incidents related to breach exploits.
02:24:41.436 - 02:25:03.952, Speaker F: So in 2022, there's more than $2 billion worth of tokens that are lost due to breach related exploits. So four of the five top exploits on the Rec news leaderboard are all related to breach. And because of this, there's no single breach implementation that is 100% secure.
02:25:03.952 - 02:25:35.680, Speaker F: So we shouldn't building security, we should not be building security critical systems that solely depend on them. And at bridge designs have also some trade offs, whether it might be due to cost security or auditability. And most important thing to take away is that systems built on top of bridges get hacked and get exploited because they are put all the trust into individual bridges that eventually get exploited.
02:25:35.680 - 02:25:56.308, Speaker F: So for Hashi, essentially what we want to standardize at the lowest level, which is the block header. So in addition, we want to be modular and agnostic to the underlying mechanisms by implementing Ryho. So what Ryho is, is a redundant array of hash Oracles.
02:25:56.308 - 02:26:19.852, Speaker F: So let's say you have a critical piece of data, you will not want to save only this data on a piece of hard drive. So ideally you want to create multiple backups of this or you can create a rate. So in the computer terms you'll be redundant array of in specific disks and so where you have multiple disks running in parallel.
02:26:19.852 - 02:26:35.700, Speaker F: So if in a case that any data is lost, you will actually not lose any data. So like any redundant systems, rate can also have its own trade off. So in terms of speed versus cost versus redundancy.
02:26:35.700 - 02:27:00.728, Speaker F: So Hashi system is like sort of rate, but for breach Oracles. So in Hashi, we decided to optimize for security over cost and speed. So Hashi will only move as fast as the slowest Oracle, since multiple bridge oracles will have to report the same hash in order to consider the hash valid because of this robustness.
02:27:00.728 - 02:27:16.064, Speaker F: And security is definitely going to improve, but at an expense of cost and speed. So here are. The main components that the team has built and at the same time we're also looking for other people to others to build as well.
02:27:16.064 - 02:27:51.144, Speaker F: So we are very interested in applications such as token bridges, government bridges, and yeah, so I'll just go through the architecture overview of hashi. So on the left hand side, starting from canonical example, we have a token bridge contract that wants to ultimately mint tokens at the destination chain. So on the source chain it's going to send a message to the storage and that message is going to be reported to a variety of different mechanisms into the destination chain.
02:27:51.144 - 02:28:17.430, Speaker F: So in this case you can see that we have this EMD reporter and Wimo reporter that's reporting to a variety of mechanisms into the destination chain. So at the destination chain each of these mechanisms is going to essentially validate the message independently and the results from each mechanism is going to be aggregated by hashi. So hashi will be at the end here.
02:28:17.430 - 02:29:07.460, Speaker F: So the token bridge control will actually ultimately request from hashi using a hash that's associated either with the message ID or block ID and if they all agree with each other it will then allow tokens to be minted on the destination chain. The core contracts for hashi is kind of stateless and very unopened way of querying for multiple Oracle adapters. And Girigiri bashi is a kind of governable extension to hashi that allows you to have an ownable contract where you can define explicitly which set of adapters must agree for a given hash for the system connected to consider it valid.
02:29:07.460 - 02:29:58.288, Speaker F: So systems built on top of this will also want to leverage things like storage proofs reporter contracts for broadcasting and then executing messages based on the hash and then relayers for listening to events on the origin chain and reporting hashes or triggering corresponding destination chain. So for hackers who like to build with hashi so what to build with hashi? So we like to see people working on its adapters, so preferably a ZK like client based one and would love to see kind of optimistic bridge and community based bridges. So diversity is kind of the key here and we also love to see contracts that check for local proofs for some events or storage on the oranging chain.
02:29:58.288 - 02:30:23.870, Speaker F: We also like to see alternate implementations of Giri bashi. So right now it's a relatively kind of simple aggregation rule and we like to see different governance rules or different aggregation rules. And lastly, we love to see things built on top of hashi so like token bridges, NFT bridges, government bridges or other novel things that we are not thinking about.
02:30:23.870 - 02:31:00.760, Speaker F: So here are the resources for hashi we have the singular repository in GitHub where you find all the information that's related and get you started. And the Gnosis guild team has already implemented adapters for Gnosis, EMB, Wormhole and connects and we also have deployed the contracts on girly Chado and yeah, just to summarize again, these are the prizes that we are giving out. So that would be it.
02:31:00.760 - 02:31:05.050, Speaker F: Thank you for this listening and all the best.
02:31:09.100 - 02:31:09.850, Speaker C: Questions.
02:31:12.240 - 02:31:15.196, Speaker D: Is there a free environment that we.
02:31:15.218 - 02:31:16.030, Speaker C: Can use.
02:31:18.100 - 02:31:36.980, Speaker F: For Gnosis chain for developers you can use if you go to docs. Gnosis. IO you will see we have also like a testnet called Chado and if you would like to deploy your contracts on Chado, you can actually visit the Faucet.
02:31:36.980 - 02:31:53.280, Speaker F: Let me bring up the Faucet link. Yeah, nosisfosset.com and you can actually get like one XDI in Chado for you to test out.
02:31:53.280 - 02:32:11.140, Speaker F: But if you want to test out on main net, you can also get the XDI from the faucet as well. And the transition cost is not very high. So actually yeah, but you can try on chatto first.
02:32:21.020 - 02:32:21.930, Speaker C: Thank you.
02:32:24.160 - 02:32:45.744, Speaker F: If you have any questions during the hackathon, you can actually hit us up on the Eve Global discord and we'll be there to support the hackers. And also for hackers who like more Xdai for deploying their smart contracts, just hit us up and we'll just send it individually.
02:32:45.872 - 02:32:46.548, Speaker C: Yeah.
02:32:46.714 - 02:32:48.836, Speaker F: Thank you guys. Have a nice day.
02:32:48.938 - 02:32:58.890, Speaker C: Thank you. We still have one more workshop at 630.
02:36:36.860 - 02:36:41.960, Speaker B: All right, testing, testing, testing, testing.
02:36:43.340 - 02:36:44.328, Speaker C: Just about good.
02:36:44.414 - 02:36:45.050, Speaker B: Awesome.
02:36:45.500 - 02:36:46.440, Speaker C: Sweet.
02:36:48.620 - 02:36:52.120, Speaker B: I do tend to talk louder when I'm actually presenting.
02:39:10.950 - 02:40:02.560, Speaker C: It'S shorter.
02:40:33.060 - 02:40:34.290, Speaker G: Let's get started.
02:40:36.100 - 02:40:37.824, Speaker C: We'll get started now.
02:40:37.942 - 02:40:42.240, Speaker G: And please join me in welcoming Ian from the workhorse.
02:40:46.860 - 02:40:47.352, Speaker C: All right.
02:40:47.406 - 02:40:54.184, Speaker B: Hi everyone, I'm Ian. I also go by Penrin on Twitter and telegram. That's why my pseudonym's up there instead of my real name.
02:40:54.184 - 02:41:14.416, Speaker B: So I do developer relations at WorldCoin technically Tools for Humanity, the corporation supporting the WorldCoin ecosystem. And I am here to give you an overview into our global proof of personhood system. How you can use it in your app to know that your users are unique humans doing something only once without having to know anything about which unique human they are.
02:41:14.416 - 02:41:52.824, Speaker B: So it's very privacy preserving, but also great to know that your user is not a bot. So I'll go over what World ID is, I'll go over why WorldCoin created it, I'll go over what you should do with World ID and most importantly, how you integrate World ID into your hackathon project or even later into an app that you're working on after this hackathon. So to start, World ID answers the question, how do you know who or what is a real and unique person? Right? WorldCoin started out as a project that wanted to give everyone in the world a little bit of cryptocurrency to introduce them to this digital economy.
02:41:52.824 - 02:42:16.180, Speaker B: But in order to do that fairly and effectively, you basically have to solve the civil resistance problem, right? You want to make sure everyone who's claiming WorldCoin is a real person, and you want to make sure that they only get to claim their fair share. So for that, we built World ID. World ID is built to be private, right? So we don't have to collect any information about who you are.
02:42:16.180 - 02:42:34.330, Speaker B: We never ask for names, emails, government ID, anything like that. It's designed to be inclusive so that as much as possible of the global population can sign up for World ID. And it's meant to be robust, right? Each person only gets one account.
02:42:34.330 - 02:42:51.500, Speaker B: You can't have someone with ten accounts or anything like that. And there's a couple of different ways that we wanted to a couple of different ways we looked at doing this proof of personhood, right? Email or phone is like the weakest possible version of this. I have multiple emails, I have multiple phone numbers.
02:42:51.500 - 02:43:15.844, Speaker B: It's great when you just want to make sure, like, all right, did they at least have to put in some effort to try and create multiple accounts here? But it's not super useful when there's a big incentive for someone to make multiple accounts. We looked at doing KYC of official government IDs, but less than half of the global population has a digitally verifiable government ID. And for us that meant that it wasn't inclusive enough.
02:43:15.844 - 02:43:53.996, Speaker B: We looked at web of trust systems, right? I'm not going to name any names, but existing web of trust systems really don't work that well when you have an initial trusted set of 64 or 1000 users. Because in a web of trust system, every step you take past that initial core trusted set is a less trusted profile, right? And when you're dealing with trying to sign up the entire global population and your initial trusted set is 64, you get really far away from that initial trusted set and it becomes a very gameable system. So that leaves us with biometrics, which initially sounds scary, but we can do in a privacy preserving way.
02:43:53.996 - 02:44:36.112, Speaker B: And I'll explain how in a little bit. We looked at fingerprint, face scans, palm scans, but the problem with all of those is that they simply just don't have enough entropy to distinguish unique humans at the scale of humanity, right? With Face ID or Touch ID on your phone, apple can distinguish about one in 30 million people, which sounds like a lot, but at the scale of 8 billion isn't, right? And that's because that's for authentication. They want to check is the person in front of the device now the same as the person who is in front of the device during sign up? And the ODS that some random person who steals your phone is the one in 30 million who would be able to authenticate as you is really, really low.
02:44:36.112 - 02:44:44.790, Speaker B: And it works sufficiently for that use case. But for us, we have a different use case. We're trying to distinguish are you unique? From everyone else who's ever signed up.
02:44:44.790 - 02:45:11.352, Speaker B: So we need to be able to do on the scale of one in a billion or higher, so one in 30 million that Face ID or Touch ID can do just doesn't cut it for us. And the other end of the spectrum with biometrics is DNA, right? Lots of entropy, lots of data, but it breaks the privacy. There's a lot you know about a person just by having their DNA, right? You can tell what race they are, what sex they are, and those are things we don't want to know about our users.
02:45:11.352 - 02:45:18.200, Speaker B: And it's also just generally really invasive. So that one was thrown out as well. But we settled on iris recognition.
02:45:18.200 - 02:45:33.860, Speaker B: Your iris has a ton of entropy in it. It's something that's non invasive for us to see. It's something that to get at a high level of detail, it requires your attention and your focus, and inherently, then your consent.
02:45:33.860 - 02:45:52.356, Speaker B: And it's very, very unique, right? Even identical twins will have very different irises. So it's useful because you can't tell a lot about who that person is just by knowing what their iris looks like. Additionally, iris recognition has been studied for decades.
02:45:52.356 - 02:46:09.180, Speaker B: You also all probably heard about the Apple Vision pro. They use tech quite similar to what we do, but again, they use it for authentication rather than proving uniqueness. So the level of detail that they're getting with the Vision Pro isn't going to be sufficient for, say, signing up for WorldCoin.
02:46:09.180 - 02:46:28.580, Speaker B: So then when it comes time to how we do these iris scans, we looked at phone sensors, right? Phone cameras are great, but they're not good enough to distinguish one in a billion people. We looked at off the shelf hardware. If any of you are familiar with Clear at airport security in the US, it uses iris verification.
02:46:28.580 - 02:46:44.200, Speaker B: But for us, those still sometimes didn't have enough detail for us. And additionally, it wasn't a trusted environment. So it became really tricky to actually trust that that hardware was doing what it was saying it was doing.
02:46:44.200 - 02:46:55.790, Speaker B: So that left us with developing custom hardware. And if any of you have ever built hardware in here before, you know that hardware is hard, it kind of sucks. But it's what we had to do, and frankly, I think it's kind of fun.
02:46:55.790 - 02:47:16.260, Speaker B: So with that, I introduce you to the Orb. The Orb is the device we use to identify you as a unique human. It does this by taking photos of your iris, computing an iris code on the device, and comparing that iris code to all the other iris codes that have been scanned and can verify that iris code is unique.
02:47:16.260 - 02:47:48.610, Speaker B: Today, we're confident our algorithms can handle one in a billion, and they're always improving. The Orb has been in development since before COVID so early 2020, it's gone through lots of different revisions, as you can see here. We started out with two cameras, one for each eye, but eventually moved to one camera that can actually move a gimbal mirror to see both eyes right? So the orb makes sure you're real checks your unique iris code and then it verifies your unique World ID.
02:47:48.610 - 02:48:07.508, Speaker B: World ID is kind of like this global digital identity protocol, like an internet passport in a sense. And it supports multiple proof of personhood credentials, starting with Or Biometrics and phone number, right. We see this proof of personhood is a spectrum in a sense, right.
02:48:07.508 - 02:48:34.510, Speaker B: How strongly can we trust that this is truly a unique human? So for some use cases you're going to want Or Biometrics, we consider it the gold standard for knowing someone's a unique human. But in other use cases, just knowing that they have a phone number and have verified that in the World app will be good enough. And we're always looking to add more proof of personhood mechanisms to this one that we may add at some point in the future would be verifying a government ID.
02:48:34.510 - 02:49:01.430, Speaker B: But it is up to app developers using World ID to determine where they set the bar for how strong a proof of personhood they want to allow users to take certain actions in their app. World ID is privacy first, decentralized and open source, right? We never collect personally identifying information from you. That's sort of the whole point of it is that we can't even disclose which person you are because we don't know in the first place.
02:49:01.430 - 02:49:15.850, Speaker B: It's decentralized and open source. So the protocol, all the smart contracts are open source. Our developer portal code is open source, our ID kit, the front end SDK, that's open source as well.
02:49:15.850 - 02:49:42.000, Speaker B: And there's lots of different use cases for World ID. So some that I really like, voting one person, one vote is something I'm a big fan of compared to one token, one vote, customer incentives are another one I really like. That I think play in well with the fact that we see personhood as a spectrum, right? So if you have a user who's orb verified, maybe you give them a one month free trial and a 25% discount on their first order.
02:49:42.000 - 02:49:55.972, Speaker B: But if they're phone verified, right, because you're a lot less certain that they are a unique human with only one account, maybe you give them a week long free trial and a 5% discount on their first order. Right. Airdrops are another great use case.
02:49:55.972 - 02:50:15.660, Speaker B: You want to make sure you don't have someone claiming the AirDrop 100 times social media, it's great to know that you're working with a real person instead of a bot. Lots of different ways that this tech can be used. So we designed World ID to be super, super easy to integrate across web, mobile and on chain use cases.
02:50:15.660 - 02:50:29.650, Speaker B: And there's two ways that you can integrate worldID. One is sign in with WorldCoin, one is anonymous actions. So let's start with sign in with WorldCoin and let's see how it works.
02:50:29.650 - 02:50:45.510, Speaker B: So I'm actually going to sign into our developer portal here. So with the developer portal. I hit login and it takes me to this page with a QR code that I scan within the World app.
02:50:45.510 - 02:51:10.750, Speaker B: So what's happening here is that QR code tells the app which app it is that I'm signing into. When I press verify with World ID, a zero knowledge proof will be generated on my device attesting that I am one of the verified WorldCoin identities without revealing which one. The list of those identities is stored in a merkel tree on chain.
02:51:10.750 - 02:51:27.720, Speaker B: So it attests that I am one of those identities performing an action without revealing which identity I actually am. So I press verify, that information gets passed back to the sign in portal and then I'm logged in. Simple as that.
02:51:27.720 - 02:51:39.258, Speaker B: So I can come back to the developer portal in a little bit, but that's a quick demo of how we sign in with World ID. And there's lots of different ways that you can integrate sign in with WorldCoin. So I put auth zero at the top there.
02:51:39.258 - 02:52:01.982, Speaker B: We're going to be launching an integration soon where if you're using auth zero in your web Two app, you can implement sign in with WorldCoin just as easily as you can implement sign in with Google, sign in with Apple, sign in with Facebook, whatever it may be, right? Five minute process. Nextauth JS is sort of the go to right now for using it in any of your web apps. We have our OpenID Connect provider.
02:52:01.982 - 02:52:11.734, Speaker B: It provides an OIDC well known file. So if you've worked with OIDC before, you're almost certainly familiar with that and makes it quite easy. Or you can even implement OpenID Connect flows yourself.
02:52:11.734 - 02:52:23.818, Speaker B: But that's a very masochistic exercise and I don't recommend it. So here I'll talk about how we can integrate signing with WorldCoin using Nextaut JS. This is all you need.
02:52:23.818 - 02:52:51.154, Speaker B: You put this configuration for the WorldCoin provider into Nextdoc's configuration file. You pass it this well known file or the URL to the well known file that instructs it on what endpoints to use for authorization, for exchanging login token. You pass it the client ID and client secret that you get from Worldcoin's developer portal when you create an app.
02:52:51.154 - 02:53:09.420, Speaker B: And then down here we are mapping the information returned from sign in with WorldCoin to that user. So the user ID is going to be the nullifier hash. It is a unique identifier for a combination of user and action within World ID.
02:53:09.420 - 02:53:37.220, Speaker B: Anytime that action a user is taking changes, that nullifier hash changes, and anytime the user performing a specified action changes nullifier hash changes as well. The fact that nullifier hash will always be the same for any combination of user and action means that we use that as your unique identifier when you're signing into Platform A. But when that action changes, say you're signing into Platform B instead.
02:53:37.220 - 02:54:03.580, Speaker B: That nullifier hash also changes, which means that your accounts across multiple platforms using sign in with WorldCoin can't be correlated to each other, at least with the information passed by World ID. If you were to give platform A and platform B both your email and they were to compare their list of accounts, they'd be able to correlate you then, but that's with extra information that they have to ask you for specifically. World ID doesn't disclose any information like that because we don't have it in the first place.
02:54:03.580 - 02:54:36.386, Speaker B: And now we can talk a little bit about anonymous actions which are more powerful, they can be used for on chain use cases and likely what most of you will be interested in. So anonymous actions attest that you are a unique human doing something once or within a specified number of times, you can set that number arbitrarily I'll talk about how you can set that later. And for on chain use cases specifically with a specific signal, right? So say you're claiming an AirDrop.
02:54:36.386 - 02:54:47.790, Speaker B: That signal would be the wallet address. You want to claim that AirDrop to for on chain use cases. Even though there is a wallet within the World app, it is not designed to be a fully functional cryptocurrency wallet.
02:54:47.790 - 02:55:06.350, Speaker B: You can't connect it to DApps. So you would have users connect their wallet the same way that they always do and then they would additionally verify with World ID as part of the transaction to claim that AirDrop or mint that NFT. So let's see a quick demo of anonymous actions.
02:55:06.350 - 02:55:25.510, Speaker B: So, if I go over here, we actually have a try it out section in our documentation. And additionally here on the right, I am using our simulator. So the simulator is how you can test your apps for staging use cases.
02:55:25.510 - 02:55:55.930, Speaker B: So if any of you guys are doing on chain apps when you use testnet, specifically Polygon Mumbai testnet, you have to use the simulator in order to do these actions. So in the simulator, you can create temporary identities and then validate them as Orb and or phone verified or you can actually sign in with an existing crypto wallet. You have to generate a persistent identity that you can verify once reuse for multiple use cases.
02:55:55.930 - 02:56:22.630, Speaker B: But the reason the simulator is important for testing is that if you're just testing civil resistance and all you have is your real world app, you will run out of opportunities to test your civil resistance the first time it works, right? So as soon as you have performed an action with that ID, you won't be able to anymore. Whereas in the simulator you can spin up lots of identities to test different use cases and things like that. So let's say we're using the staging network.
02:56:22.630 - 02:56:35.114, Speaker B: Let's make this the Waterloo test action. Let's only accept Orb credentials and let's hit continue with WorldCoin. Oh, it thinks that this is a mobile use case.
02:56:35.114 - 02:56:49.226, Speaker B: So this is what your users would normally see. This modal pops up and for testing use cases, we can very conveniently click on the QR code to copy the information within it. You can also run the simulator on your phone and scan it just as I did in the app earlier.
02:56:49.226 - 02:57:00.494, Speaker B: And in the simulator we can tap up here to go into the scanner or insert QR manually. I paste that in there. Oh, I did hit Submit.
02:57:00.494 - 02:57:16.946, Speaker B: Let me try that again real quick. So I copy the QR code, insert it here. I will verify with my biometrics, the orb verification.
02:57:16.946 - 02:57:31.066, Speaker B: I click Verify with World ID and the proof gets passed back to the front end. So that's what the flow for your users looks like when they're verifying with World ID. And now we can get into how to actually implement it.
02:57:31.066 - 02:57:49.170, Speaker B: So when you're using anonymous actions, everything starts with Idkit. Idkit is our front end SDK and it's a single react component, right? So the Idkit widget, you tell it what action your users are performing as well as the app ID. You get both of those things from the developer portal.
02:57:49.170 - 02:58:03.218, Speaker B: You pass it two callback functions handle Verify, which is actually optional. And on Success, handle Verify is called as soon as that proof is returned from the user's device. On success gets called when the user closes out of the modal.
02:58:03.218 - 02:58:16.374, Speaker B: And then you have to pass which Credential types you want to accept. So you can limit that to just phone verification, just orb verification, or both, if you leave that one. If you don't specify, it will assume just orb credentials.
02:58:16.374 - 02:58:30.302, Speaker B: Additionally, you pass it the button that is displayed and then pops up the modal when you click it. And this is what gets returned from Idkit. This is the proof generated on a user's device and passed back to your app's front end.
02:58:30.302 - 02:58:53.062, Speaker B: So the merkel root specifies the root of the merkel tree with the user's identity listed within it. The nullifier hash, as I said earlier, is the unique Identifier for that combination of user and action. The proof is much longer than shown here and that is actually the cryptographic proof with Semaphore and then the Credential type is passed back as well.
02:58:53.062 - 02:59:15.962, Speaker B: So orb or phone at the moment, with more to be supported in the future. But what do we do with this? We still have to verify that proof, right? Because on the front end anyone can put in any data they want and you can't really trust it. So you have to do something on a back end, whether that is your web apps back end or if that is on chain.
02:59:15.962 - 02:59:27.298, Speaker B: So let's start with talking about how you would do this in a web apps backend. So you would pass that information to your back end. There's many different ways you can do that.
02:59:27.298 - 02:59:54.650, Speaker B: In our Cloud Actions template repository that gets handled for you and then in your backend you would run a bit of code like this that would call Worldcoin's API, right? So the base URL would be ID worldcoin.org or I'm sorry, developer Worldcoin.org Apiv, one verify and then your app ID that this action is for you, pass it that request body.
02:59:54.650 - 03:00:12.800, Speaker B: Additionally, with values, the actual request body there will include values that you had to pass to Idkit in the first place, like your app ID and action ID. And then we handle verifying that proof for you. You don't have to worry about any of the math for the zero knowledge proofs, anything like that.
03:00:12.800 - 03:00:35.510, Speaker B: But then when you get a 200 response back, you know that user has been verified, and then you perform whatever actions you want to perform for that user from there. So that can be marking their profile as verified in your database. Lots of other things you can potentially do, but you have to verify them on the back end.
03:00:35.510 - 03:00:59.774, Speaker B: If you just verify it on the front end, a user can manipulate that and it's not actually proving anything. Now, if you want to verify it on chain, first you have to construct your World ID instance, right? So underscore World ID here you would pass the address of the WorldCoin Smart contract. We do have an ENS name for that, it's listed in our documentation, which I'll link to at the end.
03:00:59.774 - 03:01:11.522, Speaker B: And then you have to pass your app ID and action ID as well. Then you have to actually build the external nullifier yourself. But that's sort of the first step.
03:01:11.522 - 03:01:41.882, Speaker B: Get everything set up. From there you can define your verify and execute function, right, which you give the signal that that user wants for this specific action, right? So again, AirDrop could be wallet address, you give it the root of the merkel tree, you give it the nullifier hash and the proof. So in this example we've implemented civil resistance, right? For off chain use cases, we handle the civil resistance for you.
03:01:41.882 - 03:02:01.666, Speaker B: You can pick an arbitrary number of times you want to let a user do something in the developer portal, but for onchain use cases you have to implement that yourself. So in this instance, the first thing it does is check if we've seen that nullifier hash before and if it does, we revert. We just have a list of the nullifier hashes we've seen and we know if it's in there, we've seen it before.
03:02:01.666 - 03:02:23.270, Speaker B: This user is trying to perform an action twice and we don't want to let them do that. So then we call the verify proof function on Worldcoins contract, we pass it root of the merkel tree, the group ID. So the group ID is going to be either zero or 10 is if that user is phone verified, one is if that user is orb verified.
03:02:23.270 - 03:02:50.180, Speaker B: We do that because we have separate merkle trees for orb and phone verification. It's explained in our documentation and in your smart contract, if you only want orb verified users for example, then you can just hard code that as one, right? But there may be some use cases where you're going to want to pass that information in based on whether that user is orb or phone verified. So you abi encode the signal and hash it field.
03:02:50.180 - 03:03:14.042, Speaker B: You pass the nullifier hash and the external nullifier and the proof. So if that proof doesn't verify, this will revert. But if this does verify, we'll continue on and we add the nullifier hash for this example into the list of nullifier hashes so that we make sure that that user can't perform this action again.
03:03:14.042 - 03:03:30.640, Speaker B: And once we've done all that, that's when we continue on to do whatever it is that we want our smart contract to do. Minting an NFT, claiming an AirDrop, whatever that may be. So that is like the really quick overview into how to integrate World ID.
03:03:30.640 - 03:03:48.626, Speaker B: It covers everything, right? It's actually quite simple. And for us, we have 20K in prizes here at the hackathon. So $5,000 to the best overall use case, 2500 each to the best Governance app, most creative use case, best AI use case, and best sign in with WorldCoin app.
03:03:48.626 - 03:04:13.466, Speaker B: Right? So the Governance app can be a bunch of different things that could be dao governance, that can be more political voting systems. Governance is pretty broad there. Similarly with AI, right? That can be AI safety, that can be ensuring a human is in the loop with your AI system, that can be ensuring that that training data is actually generated by a human.
03:04:13.466 - 03:04:26.020, Speaker B: Again, lots of different things there. But for all of these, I want to clarify that you do have to integrate World ID into your project. It's not that we're giving away 2500 to just some cool AI project that doesn't use World ID.
03:04:26.020 - 03:04:51.750, Speaker B: Additionally, oh, I made a slight typo here. We have two $1,000 honorable mention prizes and then a $3,000 prize pool split among all submissions that properly integrate World ID. So our SDK and Developer Portal is still in beta, but we're letting all of you skip the waitlist for hacking here at East Global Waterloo.
03:04:51.750 - 03:05:01.258, Speaker B: Additionally, you can continue to build on top of World ID after the hackathon. If you do, please let me know because I really want to be able to help you out. I am Developer Relations.
03:05:01.258 - 03:05:10.494, Speaker B: It's kind of my job. But this will get you access to the SDK. I would recommend visiting the URL on a desktop instead of doing it from your phone.
03:05:10.494 - 03:05:25.140, Speaker B: But you can also, if you missed this here, come find me at the booth. This information will be available there. Everyone good? Can I move on? All right, so if you guys still want to get access, I'll give you questions.
03:05:25.140 - 03:05:48.460, Speaker B: Okay, so I'll do questions right after I put this link up as well, which links to a bunch of resources, including our documentation, our developer Portal template repositories that we have available. For you all information on our Bounties and where to contact us if you have any questions so now questions? All right, I'll go with you first.
03:05:51.730 - 03:05:53.966, Speaker D: My personal thought of project was I.
03:05:53.988 - 03:05:57.454, Speaker E: Could feel that the unchained dow can.
03:05:57.492 - 03:06:19.560, Speaker D: Make the smart contract to be upgradable to change the parameters make the smart contract build the trust and also able to change the code. The way that I've been doing that is through the government. So we have considered several options.
03:06:22.250 - 03:06:22.614, Speaker C: To.
03:06:22.652 - 03:06:38.940, Speaker D: Actually bring the trust. One is that you have the role have the identity to identify. The specific role is to use the soba token and the other way is the did.
03:06:38.940 - 03:07:10.100, Speaker D: But as my understanding, let's say the more like we can identify person as an entity, there's more exposure of their actual personal information. It's not like the private information.
03:07:11.830 - 03:07:12.206, Speaker C: Is.
03:07:12.248 - 03:07:30.140, Speaker D: Probably not private anymore. And especially the one that you talk about that workforce use personal bio information. I just want to know you guys are the central entity and you use the personal information.
03:07:30.140 - 03:07:35.130, Speaker D: How does that you keep the preferences?
03:07:36.930 - 03:07:51.374, Speaker B: So I can expand a little bit on how we use the biometric data in the Orb. So in the Orb, it does take photos of your irises. Unless you opt in, those photos never get stored anywhere.
03:07:51.374 - 03:08:25.120, Speaker B: We compute the iris code, that digital representation of the entropy of your iris in Ram, and if you didn't opt into having those photos stored, they get deleted. If you did opt in, they are encrypted, temporarily stored on the Orb until they get uploaded to our server using a sealed box encryption mechanism to prevent, say, a rogue operator from trying to get that data off of the Orb. The Orb itself has lots of other physical security measures, like tamper, resistance, things like that.
03:08:25.120 - 03:08:50.470, Speaker B: But if that is stored, it is encrypted, full stop. And once we have that iris code, we also know, as part of the sign up process, the public key of your world ID. And to clarify, the Wallet in the World app and the world ID are based on two entirely separate secrets, right? Your biometrics never touch anything related to the wallet.
03:08:50.470 - 03:09:23.290, Speaker B: But the public key of your world ID. We know which iris code it's associated with, but we just add that public key to the Merkel tree on chain so that when your device generates a proof that merkel tree is publicly available for verifying that proof but that public key never gets revealed. Not even WorldCoin knows which actions any specific identity is taking because that zero knowledge proof is generated on your device.
03:09:23.290 - 03:09:33.890, Speaker B: The only way to associate actions back to a public key is if you have the private key and you are the only one who has that private key on your device.
03:09:38.250 - 03:09:39.080, Speaker C: Of course.
03:09:42.190 - 03:09:55.030, Speaker D: I understand how the iris is stored as it's on chain, but is there any on chain APIs to associate with the public key?
03:09:55.200 - 03:10:12.818, Speaker B: So the Iris code is not stored on chain, just the merkel tree of World ID public keys. But those public keys themselves aren't really useful for anything because you can't associate them with actions they're not meant to be a true public Identifier of who you are. Right.
03:10:12.818 - 03:10:24.120, Speaker B: Everything with world ID is context specific. You have your nullifier hash in the context of a specific app, but you don't know that user's public key for their world ID.
03:10:26.650 - 03:10:27.560, Speaker D: Right now.
03:10:29.470 - 03:10:33.546, Speaker C: Yes, but I want to sign to.
03:10:33.568 - 03:10:47.440, Speaker D: This MetaMask and associate the world coin ID once to identify our app. This particular ID of the wallet where I made a signature associate with that.
03:10:48.930 - 03:11:09.922, Speaker B: So that's possible, but you would have to have the user sign in with both. Right. In that use case, would you want your user to be able to sign in later with WorldCoin or would you still want to have them connect their wallet? Okay, so in that case, I would say actually just using an anonymous action to have that user verify once right.
03:11:09.922 - 03:11:18.230, Speaker B: It's using the anonymous action rather than sign in with WorldCoin makes more sense for the use case you're talking about, which I would describe as verifying that wallet.
03:11:23.550 - 03:11:23.914, Speaker C: Right.
03:11:23.952 - 03:11:25.370, Speaker B: And that's all you're looking to check for.
03:11:25.440 - 03:11:25.626, Speaker C: Yeah.
03:11:25.648 - 03:11:27.820, Speaker B: So anonymous actions work great for that.
03:11:29.790 - 03:11:30.540, Speaker C: Question.
03:11:34.850 - 03:11:36.400, Speaker B: Can you speak up, please?
03:11:37.090 - 03:11:53.300, Speaker C: On the back end, without using any prevention. But on chain, we should add that.
03:11:55.830 - 03:11:56.580, Speaker F: Because.
03:11:58.630 - 03:12:04.226, Speaker D: Development for the future, we don't need to use that code or there.
03:12:04.248 - 03:12:06.130, Speaker C: Is an issue that prevents.
03:12:09.630 - 03:12:42.930, Speaker B: So I couldn't hear you perfectly. Was the question specifically about why you have to custom do the sibyl resistance for on chain? So that's because for off chain use cases, it's very simple for us in our back end to just track how many times this action has been performed and let you pick that for your app. It really is just more of a convenience feature for developers who are using things off chain.
03:12:42.930 - 03:12:59.414, Speaker B: But for on chain use cases, it would add a tremendous amount of bloat to our contracts to track that for you so that the more people use World ID, the more expensive it would become for you to use World ID, which we don't want to do. Right. So that's why we have you track that yourself.
03:12:59.414 - 03:13:13.600, Speaker B: It is, as you saw, an extra two lines of code, so that's why we did that, or at least saving you money that you don't have to spend in the first place. Any other questions?
03:13:13.970 - 03:13:14.750, Speaker C: Yep.
03:13:20.280 - 03:13:25.720, Speaker B: It's most efficient to verify an inclusion proof in a merkle route.
03:13:35.100 - 03:13:35.976, Speaker C: So the.
03:13:35.998 - 03:13:58.880, Speaker B: Orb can detect that it's actually a human face and it can detect that it is like a real face and not a photo of a human. Yeah, we have thoroughly modeled a lot of potential fraud attempts. So, yeah, if you put a cat or a dog in front of the orb, it's not going to work? Unfortunately.
03:14:00.820 - 03:14:01.472, Speaker E: Yeah.
03:14:01.606 - 03:14:05.890, Speaker B: I tried to verify my cat and it didn't work. Oh, I'm sorry. Don't worry.
03:14:08.980 - 03:14:13.680, Speaker C: Right here. Answer everyone's questions. Thank you, everyone, for attending the workshop.
03:14:15.420 - 03:14:21.190, Speaker F: Good. Yeah.
