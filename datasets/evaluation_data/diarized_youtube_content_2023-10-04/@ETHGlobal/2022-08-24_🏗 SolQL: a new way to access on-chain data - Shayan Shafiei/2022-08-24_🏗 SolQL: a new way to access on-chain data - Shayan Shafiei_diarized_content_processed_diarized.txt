00:00:06.090 - 00:00:27.462, Speaker A: Okay, are we ready? Yes. Let's begin. Hello everyone, my name is Cheyenne, I'm here to present Solkial before I do that for malodies first, a big thank you to the ETH Global team for obviously organizing this event and in particular this workshop onto business.
00:00:27.462 - 00:00:39.100, Speaker A: What is solql? I'm going to say what it isn't first. It isn't a querying language so why is QL in the name? The same reason Java is in JavaScript. Sounds cool.
00:00:39.100 - 00:00:57.840, Speaker A: I've told you what it isn't. I'm going to show you what it is. Now, the most brief description would be it is a tool that mimics Hard hat forking but is much quicker than hard hat forking I'll show you in a moment.
00:00:57.840 - 00:01:41.374, Speaker A: So here I've got a standard hardhat environment set up I've got a config file with the compiler version provider URL, the forking standard setup if you have used Hard Hat this will be pretty familiar to you, obviously. So the smart contract I'm going to be testing today is called the query contract and in order for this to work, we need to impose some restrictions on this query contract. So one of those restrictions is it has to have a function with this signature right here.
00:01:41.374 - 00:02:28.780, Speaker A: So it has to have a function named query which returns bytes memory. So what is going on here? Basically what we're doing is we're taking the Uniswap v two factory contract on girly testnet and we are calling the all pairs function to get the ith pair and then once we have the ith pair we call the token zero function to get its first token. Now, there is a specific reason why this example was chosen I'll explain that later but let's get into the comparison first.
00:02:28.780 - 00:03:12.908, Speaker A: So this benchmark repo is available on our website over here so you can try running the benchmark yourself, see if you get similar results without further ado, let's test Solql first and then I'll test hard Hat forking afterwards. Okay, 7.9 seconds to do what? To get ten pair contracts from the Uniswap V two factory and then get their first token.
00:03:12.908 - 00:04:05.700, Speaker A: Cool. Now, 7 seconds does sound slow but we are offering this as an alternative to hardhat forking which gives us the following result wait a while okay, 13 seconds. Now, that doesn't seem like much of a difference even though it is almost a two x gain but what ends up happening is as we increase the number of token addresses we are fetching, the difference goes up quite quickly.
00:04:05.700 - 00:04:28.810, Speaker A: An example would be assuming that hard hat forking grows linearly with the number of tokens that we query whereas Solql would grow logarithmically so much slower. Now, before I explain how this performance game comes to life, I'm going to go through some caveats. There's two main ones.
00:04:28.810 - 00:04:51.162, Speaker A: Firstly, we do not have Hardhat's console log functionality yet although it's possible just will take a while. And two, we don't have the functionality to be able to pass constructor parameters to contracts yet again that can be implemented. So here you'll notice that there is no constructor.
00:04:51.162 - 00:05:25.834, Speaker A: Every piece of information that we need has been declared inside as a literal and that is because as of right now, there is no support for being able to pass data into a constructor. Okay, so this is what I was talking about earlier. This is a graph representing on the x axis we have the number of pair contracts we're querying and on the y axis we have the number of milliseconds taken to get a result.
00:05:25.834 - 00:05:50.926, Speaker A: So as you can see, Sokyo the blue dots here stays pretty constant, whereas hard hat grows pretty quickly. So at this point right here, at 2000 pairs, we're looking at about a 30 x gain in performance. So that would be comparing around 6 seconds to 1800 seconds.
00:05:50.926 - 00:06:09.498, Speaker A: So just to put things into perspective, that's 6 seconds compared to 30 minutes, which is a pretty big difference. Okay? And at the very far end, so here we have 9507 pairs. At that point, Hard hat doesn't even work.
00:06:09.498 - 00:06:37.970, Speaker A: You will probably get a timeout or some other form of networking error. So again, for this demonstration, just because it takes a while, we're not going to demonstrate these data points right here because they would quite literally take the rest of the workshop to show. But yes, so that shows the speed gain that you would have from using Soulql.
00:06:37.970 - 00:06:48.742, Speaker A: Now we do have examples you could follow along with. So if I open here, go to the docs. Obviously we have this warning here.
00:06:48.742 - 00:06:59.402, Speaker A: This is still in alpha. So breaking changes will happen. But installation, you go to a directory and you run this command right here.
00:06:59.402 - 00:07:32.930, Speaker A: Basically what it does is it clones a repo that we have set up and it installs the dependencies I'll actually show you. So right here, if I do NPX solql, at zero point twelve, we're going to call this test two. So we get this test two directory.
00:07:32.930 - 00:07:45.302, Speaker A: We've already run NPM install. So all of your dependencies are already installed. So here what you have is the exact same smart contract I just showed you.
00:07:45.302 - 00:08:05.754, Speaker A: But we also have this main script which shows the usage of the Soulql API. So basically the way this works is you import the Soulql class from the package. Obviously you instantiate an Ethers provider with your provider link you would have a contract name.
00:08:05.754 - 00:08:14.960, Speaker A: This name would be this name right here. So if I turn this into query two, I'd also have to turn this right here into query two. For this to work.
00:08:14.960 - 00:08:39.122, Speaker A: We are passing the chain ID and we instantiate a Solql interface. Like so the reason you pass the chain ID and your provider at the same time is because if you already know what chain ID your provider has, obviously we don't need to make an Asynchronous call to figure out your chain ID for you. That would take an extra couple hundred milliseconds.
00:08:39.122 - 00:08:53.014, Speaker A: Don't want that. You also have to pass the Hard Hat runtime environment to this Solkyo class. Reason being, Hard Hat does quite a bit behind the scenes.
00:08:53.014 - 00:09:06.430, Speaker A: So rather than reinventing the wheel ourselves, we just decided to rely on Hard Hat. So that is quite essential over there. And then to get the results, all we have to do is run the following line.
00:09:06.430 - 00:09:42.970, Speaker A: This gives you an encoded string of bytes like this. But we can obviously use the default Abi coder of Ethers JS to decode our results and have it in a nicer format. Reason this is address 100 is because over here, this address 100 array is what we are packing and returning as bytes memory.
00:09:42.970 - 00:10:31.590, Speaker A: So, just to show you where was I, if I go here, that is, by the way, if you there we go. That was quicker than before. Anyway, so this is your encoded result, basically, which you use the Ethers JS decoder to turn into this right here.
00:10:31.590 - 00:11:09.996, Speaker A: Okay, now, with that out of the way, where were my slides? This is diving a bit into the nitty gritty of how this thing works and why it gives us the performance gain it does give us. So firstly, I'll explain what Solkyl is doing and then I'll go through what Hardhat is doing and why Hardhat is slower than soulql. So basically what Solql does is it takes your contract, it uses the built in Hard Hat compiler to compile it down to EVM bytecode.
00:11:09.996 - 00:11:22.644, Speaker A: It then sends that bytecode to the provider. You give the Solql API and it gives you the results back. Now there is one step in the middle here.
00:11:22.644 - 00:11:36.312, Speaker A: So the way this actually works is we also have these Oracle contracts. These are contracts that we deploy. So these are actually deployed right now just on Gurley, but we are on the verge of deploying it to other chains as well.
00:11:36.312 - 00:12:11.284, Speaker A: So what is happening here is basically we call this function here when we want to simulate our smart contract, which takes in the bytecode of that smart contract, and then deploys that contract using this assembly block here, runs the query method on it and returns the result. Now, in real life, this would cost gas. However, we're not actually signing this transaction, we're simulating it.
00:12:11.284 - 00:12:20.730, Speaker A: So if you've used call static before, that's what we're doing here. So we don't actually pay any gas for this. So that's how that works.
00:12:20.730 - 00:12:49.570, Speaker A: Now, it would be more helpful to see all of this happen on the provider's dashboard so that you can see the type of JSON RPC request you get for Hard Hat forking as opposed to solve PL. So I'm going to run the Hard Hat forking script again and we don't need to wait for it to finish. We can just come here.
00:12:49.570 - 00:13:00.280, Speaker A: Don't steal my API keys. Thank you. Okay, this is what Hardhat does.
00:13:00.280 - 00:13:18.652, Speaker A: Recall that smart contracts have a storage address on the global ethereum state. So what Hard Hat does is it has a local EVM instance, but it doesn't obviously have access to the entire ethereum state because if it did, it would be a full node. But it isn't.
00:13:18.652 - 00:13:38.336, Speaker A: So what it does is to get the data it needs to do its computation, it sends your provider ETH getstorage at requests. So this parameter here is actually a smart contract address. So if you look this up, this could be the V Two factory, or it could be Pair.
00:13:38.336 - 00:13:48.752, Speaker A: Actually. We can probably do that. Yes.
00:13:48.752 - 00:13:58.864, Speaker A: There we go. So this address here is the uniswap V Two factory deployed on Gurley. So obviously we're getting data from the smart contract, but we don't have the data locally.
00:13:58.864 - 00:14:16.970, Speaker A: So we send JSON RPC requests to our provider to get the data. So basically the bottom line is, when you're using Hard Hat, you are sending a lot of JSON RPC requests. And Hard Hat deliberately slows this down just so you don't get rate limited, which is actually a fair call.
00:14:16.970 - 00:14:43.030, Speaker A: But then let's see the alternative approach of Solql. Again, we don't really need for it to finish. Right? This is all we get, a single ETH call.
00:14:43.030 - 00:15:04.792, Speaker A: Reason being we are passing the bytecode of our smart contract. That's what this mysterious looking string here is to the provider. And the provider simulates deploying a smart contract using this bytecode, using the Oracle smart contract that we genuinely have deployed.
00:15:04.792 - 00:15:17.200, Speaker A: So this is the result that you then get. So essentially the performance gain we get from using Soulql comes from making fewer JSON RPC requests. We make exactly one request.
00:15:17.200 - 00:15:53.634, Speaker A: So obviously that has a lot less networking overhead, which is what results in. Where is it? This graph right here. So, as you increase the number of pairs that you're querying, obviously you get proportionally more ETH gets storage at JSON RPC requests, whereas with Solql, if you increase the number of iterations you're doing in your loop, you're really just changing the jump I bytecode.
00:15:53.634 - 00:16:36.210, Speaker A: So the length of the bytecode of the smart contract doesn't change that much as you increase the number of pairs. So what ends up happening is, firstly, the data you have to send to the provider to be able to simulate this smart contract doesn't increase linearly as the number of reads from storage you do increases. And secondly, because the provider is doing all of the reads from state locally, they can obviously do it much, much quicker than the Hard Hat EVM on your machine having to make a separate JSON RPC request each time it needs to read a contract's storage.
00:16:36.210 - 00:16:48.860, Speaker A: So, yes, that's what Solq does. Any questions? No questions. All right, I believe we are early.
00:16:48.860 - 00:16:52.394, Speaker A: Ten minutes early. Cool. Well, that's it for me.
00:16:52.394 - 00:16:53.110, Speaker A: Thank you for listening.
