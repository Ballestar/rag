00:00:07.530 - 00:00:14.526, Speaker A: Okay, cool. Hi, I am Emily. I am the developer advocate for Linear A ZK roll up.
00:00:14.526 - 00:00:24.240, Speaker A: And here I'm going to give a crash course on L two. So it's going to be high level, but also low level. And we'll see where we fall in terms of how much you understand what I'm saying.
00:00:24.240 - 00:00:37.474, Speaker A: So I'm just going to go ahead and get started. There's a lot of information to cover. So first off, from the start, what are L two S if you guys aren't familiar? Basically, hopefully you've heard of these blockchain trilemma.
00:00:37.474 - 00:01:00.394, Speaker A: Why is ethereum? It's a pick two situation, right? We have decentralization, we have scalability and security. We need to choose three. What has happened is we've chosen as a community to focus on decentralization and security, but we don't have that scalability access, right? So what that means is we are going to be pricing out users because of high transaction costs and slow transaction finality.
00:01:00.394 - 00:01:15.666, Speaker A: What does that mean? Layer two to the rescue. So layer twos are specifically the scaling solution for Ethereum. What that means is we are decreasing congestion by pulling off the execution layer from Ethereum and then creating that data and posting it back.
00:01:15.666 - 00:01:43.882, Speaker A: When I say posting it back, I mean specifically this concept called data availability. So basically what data availability is, is the guarantee that all this data is going to be published to Ethereum. So this is what powers trustlessness, right? So one common misconception is how many of you guys are familiar with polygon? Proof of stake, right? How many of you guys think polygon is a layer two? Okay, actually, nobody.
00:01:43.882 - 00:01:58.660, Speaker A: That's great, but I think it is a common misconception, right? They have their own consensus mechanisms, they have their own security flaws. Basically, layer twos, right now, data availability is the key to defining the difference. So that's something to think about.
00:01:58.660 - 00:02:14.982, Speaker A: Kind of an image of like we all love visual. So just to kind of show you what that looks like is Ethereum is the monolithic version is taking care of execution, settlement, consensus, data availability. It's doing a lot of stuff.
00:02:14.982 - 00:02:24.150, Speaker A: Like I said, again, linear or like roll ups in general. Pull off the execution layer. Ethereum is handling settlement and consensus data availability.
00:02:24.150 - 00:02:35.322, Speaker A: How does it do this? Here's another really fancy visual. Basically, there are various ways to do layer twos. The kind of winning solution for it is roll ups.
00:02:35.322 - 00:02:53.422, Speaker A: So when a roll up, it's pretty self explanatory. Definitely what it does is it rolls up all these transactions together and then takes that and then posts it to Ethereum once. But how does it do this? Right? So when we talk specifically about roll ups, there are two types ZK rollups and optimistic roll ups.
00:02:53.422 - 00:03:15.270, Speaker A: How they differ is specifically on the proof verification part. So the proof verification is basically telling you, how do I know? How am I proving that this data I'm posting is correct? Right? So now we're going to dive into oh, actually I forgot about this slide to further explain roll ups. It's composed of a few parts.
00:03:15.270 - 00:03:26.842, Speaker A: So we have the on chain contract. So you're going to have a roll up contract on Ethereum that basically does the storage monitors, states, tracks, deposits. The second piece is the off chain VM.
00:03:26.842 - 00:03:47.218, Speaker A: So this is where that execution is happening. And the third piece is you guys might have heard of like, operators, validators, aggregators sequencers. That's a lot of words, but you can basically think of them as the people who aggregate transactions and then post that on specifically, when I talk about sequencer, that is a little bit of a separate concept.
00:03:47.218 - 00:03:57.350, Speaker A: They are the ones who have the authority of actually posting it. Next. Okay, so now I'm actually going to talk about optimistic versus ZK.
00:03:57.350 - 00:04:15.226, Speaker A: So optimistic roll ups basically do prove verification by basically not proving verification. What does that mean? So they're optimistic because they assume that everything is valid. In order for it to be invalid, somebody has to send in a fraud proof.
00:04:15.226 - 00:04:22.302, Speaker A: They say, hey, wait, that doesn't look exactly right. Let's run a fraud proof. If it proves that it's correct, then it'll post.
00:04:22.302 - 00:04:43.814, Speaker A: If it proves that it's incorrect, then obviously that transaction is rolled back. What that means specifically is this concept of a challenge period, right? So in order for fraud proof to be submitted, or like that transaction data to be posted, we have to wait seven days basically to give time for fraud proofs to be submitted. There are workarounds for this.
00:04:43.814 - 00:05:00.474, Speaker A: So something you might have heard of with regards to optimistic roll up specifically is something like a liquidity pool. So that's basically kind of a separate entity that says we'll actually just verify it all for you. If you want to post it and withdraw your ETH immediately from the L one, we can do that for you.
00:05:00.474 - 00:05:16.850, Speaker A: The only issue here is that doesn't really address the issue of NFTs. The other piece is that is another kind of hackable element, if you care. So liquidity pools is something you might hear as a solution for the challenge period of an optimistic roll up.
00:05:16.850 - 00:05:31.186, Speaker A: I don't think it's foolproof. And that's why we're going to go into ZK roll ups. So ZK roll ups essentially, basically, instead of waiting for a fraud proof to be submitted, we, I guess, proactively submit something called a validity proof.
00:05:31.186 - 00:05:56.586, Speaker A: So what that looks like specifically, if you go back to this side right here, the proof verification is done via a zero knowledge proof. So if you guys have heard of zero knowledge proofs, it basically means proving the correctness of a statement without revealing the statement itself. I want to step in here again in case you guys are a little I have heard a common misconception with ZK rollups specifically.
00:05:56.586 - 00:06:15.982, Speaker A: I think when people think about ZK, they think about privacy a lot and they're like, oh, all this is but there's a difference between a privacy solution and a scaling solution. So ZK proofs are using we're using it specifically to keep the data small, make that faster. That's for scaling.
00:06:15.982 - 00:06:23.874, Speaker A: That's not the same thing as a ZK proof for obscuring your information. So those are two separate things. We are a scaling solution.
00:06:23.874 - 00:06:42.086, Speaker A: So I want to point that out. The other piece about ZK proofs that makes it really cool specifically is we think about there's a concept of recursive ZK proofs. So essentially with a ZK proof you can have this information and you can actually put a ZK proof on top of that and make it smaller.
00:06:42.086 - 00:06:57.246, Speaker A: And you can put a ZK proof on top of that and make it smaller. Right? So there is what you could call like infinite scaling that is enabled by a ZK roll up versus an optimistic roll up. So when we talk about ZK rollups, we want to dive in a little deeper.
00:06:57.246 - 00:07:12.098, Speaker A: So there's this concept of the Zke EVM. And so basically this is executing, I guess, solidity or EVM bytecode. And what does that mean specifically? So Vitalik put out this article of four different types of Zke EVMs.
00:07:12.098 - 00:07:28.998, Speaker A: So when you think about the rollup space, you might have heard a lot of things like there's like StarkNet, what else is there in the ZK spink space? ZK sync I'm part of linear polygon ZK EVM scroll. There's a lot. How do they differ from each other is specifically in the Zkevm portion.
00:07:28.998 - 00:07:35.402, Speaker A: So at the highest level we have type four. So type four is language equivalent. It is not bytecode equivalent.
00:07:35.402 - 00:07:59.634, Speaker A: So basically what that means is you will be writing in solidity, but that will compile into something that is not readable by the EVM, like the Ethereum virtual machine. As we move further down, I guess, further down in number, further up this, I guess, table, we have type two EVM Equivalency. So that's basically it is language equivalent.
00:07:59.634 - 00:08:08.630, Speaker A: So that means you can write like solidity. Everything is going to be directly portable from Ethereum to the layer two. And it is also bytecode equivalent.
00:08:08.630 - 00:08:42.100, Speaker A: The difference here specifically is you can think of being farther away from the EVM, I guess, is a bet that EVM, I guess, inherently is not super compatible with ZK proofs. So performance is not as easily achievable. Whereas type twos and then type ones, which are fully Ethereum equivalent, then you're thinking about like the easier it is to interact with the Ethereum ecosystem, the easier it is to have the network effects of all the tooling that's already been created around it.
00:08:42.100 - 00:08:53.240, Speaker A: Everything, you know, that has already been built around Ethereum works out of the box. Right? And so that's the really strong point. That's the Win versus, I guess, a type four.
00:08:53.240 - 00:09:27.470, Speaker A: And I'm not going to read everything on this slide, but it's just kind of the graphical representation of what I was talking about versus compatibility and performance. So type four, the least amount of compatibility or it's on the side, type four, but the highest amount of performance as you go up that's, that cool. So now that we kind of have a basic overview of how evolve that works, what it means, what is linear specifically? So just Fast Facts linea is the product of four years of research and development at consensus.
00:09:27.470 - 00:09:42.086, Speaker A: It's actually pretty interesting. When we first started we were thinking about I guess payment solutions, like anonymous payment solutions. The idea that ZK proofs could be applied to scale was actually just kind of no one thought it was possible.
00:09:42.086 - 00:10:02.278, Speaker A: So we were doing a lot of ZK proof research and then through that research we realized actually scaling solutions are possible with ZK proofs. And so that's kind of how linear first got started. The other piece, like I said, we are on the way to type two ZK EVM Equivalency or type two Zkevm which is EVM equivalent.
00:10:02.278 - 00:10:09.280, Speaker A: Right now we are at type three. You can think of that as more of a transitionary stage. When we get to Mainnet, the goal is to be type two.
00:10:09.280 - 00:10:27.906, Speaker A: The other piece is we are powered by an award winning prover. So when you think about the technical, I guess, underpinnings of how linear works, we won an award that's pretty cool. And the second piece is we actually are very new as compared to the other ZK roll ups that exist in the space.
00:10:27.906 - 00:10:38.598, Speaker A: So you might think like, I think Polygon recently came out with Main net. We actually just opened public Testnet March 20 eigth. So that was like three weeks ago, I think or less than three weeks.
00:10:38.598 - 00:10:52.874, Speaker A: But in that little amount of time we have a lot of activity, right? So I pulled this this morning. We have over five and a half million transactions. 560,000 wallet addresses, a lot of deployed contracts.
00:10:52.874 - 00:11:07.410, Speaker A: I just guess for comparison, I think Polygon might have like less than a million transactions right now. There are different reasons for that I can get into later. But there has been a lot of activity, there's a lot of real big assignment excitement.
00:11:07.410 - 00:11:21.894, Speaker A: Why exactly is that? Why are people so excited about linear? So I'm going to dive into this portion of how do you choose where to build. Well, the first piece is there's a lot, right? Like I mentioned, I was naming all these UKs. There's actually more than this.
00:11:21.894 - 00:11:41.882, Speaker A: There's more optimistic roll ups, things are developing. How do you choose? When I think about what I build and why I care about a roll up, there are a few factors that I'm considering. Right? So I think the first thing that people consider is like the reason I'm choosing a roll up is because I care about finality and gas fees, right? So speed of the roll up, how cheap it is, stuff like that.
00:11:41.882 - 00:12:01.422, Speaker A: But the next piece is you want to think about liquidity, right? So how much liquidity is on that protocol. So if you're focusing on building like a DeFi DAP, for example, you want to think about how much transaction volume you can get from there, EVM compatibility equivalents. So this is where I was talking specifically on whether or not you want to leverage the network effects.
00:12:01.422 - 00:12:13.842, Speaker A: So specifically with Linea, for example, because we are EVM equivalent, nothing changed in terms of when we were bringing on partner DApps. Literally all they did was just redeploy. Right? Because nothing had to be changed.
00:12:13.842 - 00:12:22.826, Speaker A: If their code is written in solidity, it should work on linear. The other piece is users. So when we are thinking about building a DAP, you obviously want people to use it.
00:12:22.826 - 00:12:38.490, Speaker A: So how many people are actually building or I guess transacting on that? L two. The other piece is security. So I think this is kind of where the reason people might focus on optimistic rollups versus ZK rollups.
00:12:38.490 - 00:12:48.418, Speaker A: Optimistic roll ups have been around for a while, so you could say they are battle tested to an extent. ZK roll ups are a very new technology. Are there going to be bugs? Probably.
00:12:48.418 - 00:13:03.266, Speaker A: We've only been around for like three weeks, public testnet wise, but something to think about. I think this will be a solved problem, but we'll see. And then the second piece is future proof.
00:13:03.266 - 00:13:27.914, Speaker A: So I think this is kind of where I'm talking about. Where do you think the future of this roll up will go? Is that EVM equivalency super important? Is it going to be able to be fast enough? The other piece is like is that ecosystem just going to be supported in the long term? Other things to think about. So I mean, like I said, I think for the most part ZK roll ups have won against optimistic roll ups.
00:13:27.914 - 00:13:41.234, Speaker A: I spelled optimistic incorrectly. Ignore that. But yeah, I think specifically when I talk about the differences between the ZK roll up on the linear side, the Vortex is our prover technology.
00:13:41.234 - 00:13:56.200, Speaker A: So when I talked about how you might think about a type four being able to be more performant more easily, our assertion is like actually our proofer tech is going to be fast enough. You have a confused face. Maybe that's not true, but that's our bet.
00:13:56.200 - 00:14:06.646, Speaker A: No. Anyways, what does that mean exactly? So this is kind of like a high level of what it looks like. So I'm going to name these important parts.
00:14:06.646 - 00:14:19.054, Speaker A: I can't explain them directly, but basically we have Arithmetization. So you can think of Arithmetization as taking all the cave proof, can actually prove it. The inner proof system is kind of where that proving is happening.
00:14:19.054 - 00:14:35.026, Speaker A: Arcane and Vortex is basically our tech to recursively make that proof smaller and smaller and smaller so that when we submit it to that verification contract on Ethereum, it is as small as possible. So it is faster and cheaper. That's my understanding of this.
00:14:35.026 - 00:14:50.642, Speaker A: If anything is incorrect, I will let you guys know when I talk to our researchers. But yeah, so this is also just like another slide of what that looks like. It's very complicated but basically what you can see is the language Equivalency versus the bycode Equivalency and how that compares to Ethereum.
00:14:50.642 - 00:15:00.682, Speaker A: So that's kind of all of them. But they're all really good and smart projects. So I'm not here to say one is better than the other, but specifically why linea like I said.
00:15:00.682 - 00:15:11.978, Speaker A: So I think we have the basics of a roll up, right? Cheaper, faster. Secured by Ethereum. When we talk about ZK versus optimistics, we don't have that challenge period zero switching costs.
00:15:11.978 - 00:15:29.154, Speaker A: So that's when I was talking about being able to take advantage of the existing Ethereum tooling system. Something I want to speak to specifically and I think this is kind of in line with how future proof you think it is with Linear. Linear is a default network on MetaMask.
00:15:29.154 - 00:15:55.870, Speaker A: So right now when you deploy to other networks right now you have to go through the UX of hitting add network manually finding that RPC information, adding it all there user UX is going to be smoother. We live in the same company as MetaMask so there is a partnership in that sense of we're very close to the most popular wallet in Ethereum or in Web three. But yeah, that's that the other piece I want to know as well.
00:15:55.870 - 00:16:07.662, Speaker A: I think there is a lot of, what do you call it, people like to fight between L two s. I don't think that's necessarily true. So something we are exploring is something called the multi prover theory.
00:16:07.662 - 00:16:20.978, Speaker A: So like I said before, things might have bugs, right? So at the end of the day we're sending it through a prover. If that prover has a bug in it, that's problematic. So what the multi prover is saying is we're actually going to send it to multiple provers.
00:16:20.978 - 00:16:40.730, Speaker A: So scroll linear polygon is like people we're talking to, if there is a consensus on this is true, we've verified it in three different ways. So that is a lot more secure than for example, if linear was the only L two that existed in the space. And so this is what I say when we're competitors, but actually it's very important that we collaborate.
00:16:40.730 - 00:16:57.410, Speaker A: So yeah, that's kind of the future. The other piece to this too, I guess a sneak peek, right? We are in L two but we are thinking about building L three S in the future. That could be anything from more specific app chains to again doing that recursive proof so that it is faster.
00:16:57.410 - 00:17:09.086, Speaker A: The definition of an L three is actually still in flux, which is pretty interesting. So keep an eye on the space. But yeah, so actually what does it look to build on linear? I think the WiFi is really bad.
00:17:09.086 - 00:17:18.040, Speaker A: So I'm not going to do this live. But the first thing you need to do is actually get linear ETH. Let's see if I can access if it'll go.
00:17:18.040 - 00:17:28.150, Speaker A: Oh, okay. I guess so. Yeah, I mean, basically what happens is you're going to need to bridge ETH from girly testnet over to linear.
00:17:28.150 - 00:17:39.598, Speaker A: So this is kind of I hope you guys know how to use a bridge, but you can just think of it like this and then send it over. If this is not working. I think it will work.
00:17:39.598 - 00:17:52.174, Speaker A: You can come to me. I have 2000 linear ETH, so I'm happy to share but definitely try out our bridge. But yeah, so the first thing you need to do is get linear east to actually transact.
00:17:52.174 - 00:18:12.730, Speaker A: The next piece is going to be choosing where you build your smart contracts. So I have an example specifically for Truffle Foundry and hard hat, but because it is EVM equivalent by code equivalent, you should be able to use like remix brownie. I don't know what other people use, but wherever you build, that's where you choose.
00:18:12.730 - 00:18:26.798, Speaker A: So specifically with Truffle, actually, I can probably do this. Let's try this. So let's do a truffle init project.
00:18:26.798 - 00:18:35.440, Speaker A: Oh, I'm in a project already. Whoops, okay. Truffle init project code project.
00:18:35.440 - 00:18:42.530, Speaker A: And I don't have any demo code in here actually. So pretend I opened this and then whoo. I added all this stuff.
00:18:42.530 - 00:18:46.130, Speaker A: Amazing. Wow. What does that look like? To actually deploy.
00:18:46.130 - 00:18:51.542, Speaker A: So to deploy. And I'm going to show you what this looks like actually. Oh, I already opened it.
00:18:51.542 - 00:19:00.390, Speaker A: So here's Truffle dashboard running. If we go to truffle dashboard specifically, you can choose what chain to deploy on. On MetaMask.
00:19:00.390 - 00:19:10.640, Speaker A: I chose linear. If you want to deploy on Gurley mainnet, et cetera, you can do this all here. I'm choosing to use dashboard because I don't want to expose my private key to you.
00:19:10.640 - 00:19:24.706, Speaker A: And then you can just do a Truffle migrate network dashboard. And if the internet works, something should show up. I don't know if it will, so I'm just going to show you.
00:19:24.706 - 00:19:31.140, Speaker A: This is what it looks like. It actually sends them the transaction. You just hit approve and then it happens.
00:19:31.140 - 00:19:41.906, Speaker A: With hard hat. Actually, you can also use the dashboard. You would just fit it in here and then deploy with NPX like hard hat.
00:19:41.906 - 00:19:52.554, Speaker A: Deploy RPC like Truffle dashboard with linear specifically. This is our RPC endpoint RPC early linea build. We are permissionless public testnet right now.
00:19:52.554 - 00:19:59.606, Speaker A: So that's how you would do it. Have any of you guys actually deployed a contract before? Oh, actually most of you haven't. Damn.
00:19:59.606 - 00:20:06.154, Speaker A: I'm just saying stuff as if you understand. Yeah, okay. I will briefly touch on contract deployment.
00:20:06.154 - 00:20:19.314, Speaker A: So essentially you have various tools. So like I said, Truffle Foundry, hard hat that help you manage the deployment process. So that's going to be writing it and then giving you the opportunity to deploy to a network configure what those networks look like.
00:20:19.314 - 00:20:35.270, Speaker A: So if you want to deploy to multiple networks, that would be part of a configuration that you add to your Truffle Hard Hat or Foundry project. The other piece is like, it offers testing functionality specifically when you choose where to deploy. That's kind of where this network configuration comes into play.
00:20:35.270 - 00:20:49.882, Speaker A: If you guys have deployed a contract before, what it looks like is this URL will just be replaced with like Gurley testnet. Will we be replaced with mainnet will be replaced with polygon. What we're saying here is actually just needs to be RPC Gurley linea build.
00:20:49.882 - 00:20:57.434, Speaker A: It's exactly the same. You don't have to change any of solidity code. So that's when I'm talking about stuff like StarkNet, for example, they are building in Cairo.
00:20:57.434 - 00:21:09.362, Speaker A: So you will have to write a different language and then do it differently. But with Linear, you can do this. Yeah.
00:21:09.362 - 00:21:16.114, Speaker A: Okay, cool. And so Foundry is kind of how you use that too. I would be pro to explain all of that.
00:21:16.114 - 00:21:34.300, Speaker A: So anyways, talking about how you can use Linear in your project so basically we have a very open ended bounty. Basically, all you need to do is deploy on Linear. So whatever smart contract you're building, just go and change this address to Linear build.
00:21:34.300 - 00:21:57.010, Speaker A: Show us the actual deployed contract on the Explorer, like the Block Explorer. And then that's all the proof you need to actually and then one more thing. Put keep calm and love Tokyo on your GitHub repo so that we know you actually read these instructions, but otherwise, yeah, it's super simple.
00:21:57.010 - 00:22:15.430, Speaker A: I highly recommend doing it. Basically, whatever you build should be able to be deployed on Linear. So, yeah, this is kind of information I have quick starts on, actually the full deployment process of how you set up a project and then actually write a contract and then deploy.
00:22:15.430 - 00:22:28.618, Speaker A: I'm sorry, I just assumed everyone was already a smart contract developer. That was like, very bad of me. But hopefully you guys will try it out.
00:22:28.618 - 00:22:40.480, Speaker A: And that's all I have to say. Does anyone have any questions? Yes?
00:22:42.370 - 00:22:53.310, Speaker B: More of a general question about L two S. Not specifically about Linear. On the roadmap for ethereum, for essentially Vitalik's whole vision is to bring everything onto L two S and whatnot.
00:22:53.310 - 00:23:11.282, Speaker B: And the first step was that all the roll ups are being stored in the Call data. That the first step would be actually making the Call data size larger. I'm still trying to wrap my head around as to how increasing the size of the Call data translates into directly the throughput like the TPS increasing.
00:23:11.426 - 00:23:18.234, Speaker A: If you know about that, that actually surprises me, too. You bet he would want to expand the Call data. I don't know.
00:23:18.234 - 00:23:27.520, Speaker A: I have three very good friends who are like the experts in the room. Do you guys have any idea? If not, I can write down your question and then take it back to my team.
00:23:29.330 - 00:23:46.130, Speaker C: Call data can be treated as a data availability space. And by expanding call data, this was like the simplest way, without any more complex solutions on Ethereum, to just give more space for storing the proofs. You are sending the proofs through the call data.
00:23:46.130 - 00:24:07.020, Speaker C: Instead of storing them in the storage on Ethereum, you were just passing them on call data because it didn't really need to store them on storage. But instead, now for the 4844 on Ethereum, you're providing additional space for data storage that is outside of state, outside of call data. So instead of creating that in the transactions, you create a totally separate transaction type.
00:24:07.020 - 00:24:22.218, Speaker C: So it's like continuation of the same thought process of give more call data. But instead you're providing the specialized Blob transactions that only have cold data and only care about that. But they're quite big and they have different roles of propagation.
00:24:22.218 - 00:24:29.150, Speaker C: So this is coming potentially most likely in Cancun extension in few months in Ethereum.
00:24:31.010 - 00:24:31.854, Speaker A: Thank you.
00:24:31.972 - 00:24:33.200, Speaker B: Thank you very much.
00:24:36.850 - 00:24:45.106, Speaker A: Well, so that's my presentation. Let me know if you're building on linear. I can help you with solidity development.
00:24:45.106 - 00:24:53.330, Speaker A: I can't help you with call data explanations, but that's where I am. Okay, have a good hackathon.
