00:00:06.090 - 00:00:22.154, Speaker A: And without further ado, I'd like to welcome Ari to talk about everything that's happening in the Solidity ecosystem. So welcome back after our last year's Devtool summit and excited to have everybody also learn about all the things that are going on in Solidity.
00:00:22.282 - 00:01:06.882, Speaker B: Yeah, I would like to start the talk with a question to the audience. It usually works better when there is a live audience and when people can shout the answers. But I'm still trying it here. So the question is simply like what is the most requested Solidity feature since the last two years? You can just type your answer in the chat or wherever you want. I'm going to have a look at it later and we are also going to talk about it in the second part of the talk. Until then, let's forget about it and talk about the next thing, which is a very simple way to do something in Solidity. So you have an interface here.
00:01:06.882 - 00:01:49.742, Speaker B: It is an ERC 20 interface that only has a single function transfer, because that's all you want. In this case, you want to encode a call. So how do you do this usually? So since the beginning of Solidity we had this feature called Abi encode with signature. And this is very useful for doing this thing. The syntax is very simple. Abi encode with signature and then the signature of the contract. And this has been around since the beginning of Solidity perhaps, but this is bad in many face many ways.
00:01:49.742 - 00:02:27.146, Speaker B: And why is it bad? It's actually not typo safe. What does that mean? So here is the same thing but with like two typos. One is a space after the comma and the other one is uwind instead of Uwin 256. You can see Uwin 256 here. And this actually leads to a different encoding of the call data. And this is really bad. And moreover, imagine if you actually change something here, maybe the function, maybe the types, it doesn't really get reflected over here.
00:02:27.146 - 00:03:15.850, Speaker B: So this is like a feature with a lot of footguns and we have to really rethink if we should really do this. It turns out there is a better way to do it. So let's look at Abi encode with selector. So it's pretty much similar to the last one, except that you use Abi encode withselector and you have to make a reference to a function. So in this case it's minimal ERC 20 transfer selector which would like automatically put the four bytes of the selector here and then you can encode with the two end value, which is the parameters. So even this is not very good. And why is that? It's actually not typesafe.
00:03:15.850 - 00:04:28.340, Speaker B: The problem here is that, okay, imagine if we actually use a UN parameter instead of an address in the API encode with selector, it actually compiles and it will give you probably a different answer depending on what the value of two is. So this is also bad, we shouldn't do this. Is there a better solution that actually fixes both these issues? Yes, there is and that is the Abi encode call. So this is both typosafe as well as typesafe. So how does it work? It pretty much works exactly like the last two ones except the name Abi encode call and then a reference to the function here it would be like minimal ERC 20 transfer and then the parameters as a tuple. So if you make a typo here, the compiler would complain and if there is a different type instead of two, let's say you win. The combiner would complain so you don't have to worry about shooting yourself in the foot.
00:04:28.340 - 00:06:02.414, Speaker B: So as I said before, it's type safe and type of safe you can avoid a lot of foot guns. It's available since eight one one and in retrospect these two features we have to even think if we should even put this in the language anymore, we have to probably deprecate it at this point and it's already in use currently. Here you can see Alex's contract which is doing like a deploy of saves on chain and he's already using Aviat or Encode call and you can use it too. Let me go back. Perfect. So what can we do next after we have Abi or Encode error? So, as you might already know, in the last year or so, writing tests in Solidity has become incredibly popular because of Daphub and now Foundry. And this pattern comes up quite often, which is Foundry has this idea of expect reward which is you want to make a external call and you expect the call to revert with some bytes as you might already be using, as you might already know by now.
00:06:02.414 - 00:07:01.890, Speaker B: Soradity has this idea called custom errors which allows you to have properly encoded errors instead of just strings. It's more gas efficient in most cases and also just more elegant. So what you can do to test this would be something like VM expect reward and then just put whatever data you are expecting to reward. And this is an example from Opensea's new contract Cport. So if you look at how they are doing it right now it's Abi encode withselector with the signature of the error and then the parameters. So recall that errors and functions are encoded identically. So you can actually reuse a lot of things that are done for functions, also for errors.
00:07:01.890 - 00:07:49.620, Speaker B: But we can actually do better here. You can actually introduce something like Abi encode error with similar semantics to Abi encode call. We don't have this implemented right now, but there is an issue and there is somebody working on implementing it. So you can very likely expect it to land in the compiler soon. So this is how the same code would look like, which is again typesafe and typosafe and just more elegant. Yeah. So now let's go back to the question from the beginning of my talk, which was what is the most requested solidity feature perhaps for the last two years and even more.
00:07:49.620 - 00:08:55.290, Speaker B: And you can look at the results and a lot of developers have made in the survey and there is one thing that really stands out which is fixed point arithmetic and that is indeed the most requested feature for solidity since ages. So before we talk about what's happening, I want to make an introduction to fixed point arithmetic. What is e? One fixed point arithmetic. Effectively you can think about it as working with fractions or floating point numbers, although the use of floating point number is a bit of a misnomer. But you get the idea. So typically you start with a base, we call it B and this is going to be for example, ten raised to 18 is typical. 18 is a good typical number because E has 18 decimals.
00:08:55.290 - 00:09:49.878, Speaker B: One either is ten raised to 18 way. So you represent a number in real terms p by B by storing it as p. So as an example, if you have one way which is actually the fraction one by ten to the power of 18, either you store it as one instead of like as one. So the number like 18 times or 17 times, then one would be represented as one in the EVM. And the way to interpret this would be by thinking about it as like 18 decimals. So you are already implicitly using this if you are interacting with the ERC 20 token. For example, they have this innate idea of decimals.
00:09:49.878 - 00:10:44.574, Speaker B: For example, in USDC it is six in died 18 and you just add them like any other numbers. And that's my next point which is addition and subtraction requires no change. You just add, you just subtract it's exactly the same. But the next thing is more interesting. Multiplication and division, they are entirely different. Now, so if you want to multiply two numbers, p and Q that are installed values, I want to make this distinction of stored value and the actual value. The actual value would be P by B and the stored value would be p, remember? So p times Q in this case would be equivalent to p times Q by B I mean you can try to work your way to this calculation but this is how it works.
00:10:44.574 - 00:11:30.540, Speaker B: And similarly for division, if p and Q are stored values, the actual stored value for p by Q would be p times B by Q. So this is fixed point 101. Now let's talk about some history of fixed point arithmetic. And why doesn't solidity already support it? So solidity has the type Ufixed and fixed for a very long time and also in the Abi. So Ufixed stands for unsigned fixed point arithmetic, fixed point type and fixed stand for the signed just like Uwint and int. And what do I mean by it's? In the abi. I will talk about it later, but just remember that it's in the Abi already.
00:11:30.540 - 00:12:22.830, Speaker B: But these types are actually unimplemented and therefore useless if you actually try to do anything with it. You would get a compiler error if you actually end up using this somehow. But many of the programs you can compile but without being able to do anything with it. Yeah, so going back to the question, why don't we have it? We were pretty close to merging a lot of things into the language, but in the last minute we decided no. And one reason is because it's such a contentious issue. There are multiple different implementations and there is no consensus in the community on how this should look like. To give an example, there are multiple ways to implement fixed point types.
00:12:22.830 - 00:13:37.234, Speaker B: One is you can ask the question should it be decimals or should it be binary? And how many decimal points? 1824 or six? And there is this third point which is very interesting. I would like to call it the shadow overflow or some people call it the phantom overflow. So remember that this is the most basic calculation, p times Q by B. So p and Q are PQ and B are 256 bit numbers, but the multiplication p times Q may not fit inside 256 bits. But there can be cases where P times Q by B is a 256 bit number but P times Q is not. And how do we handle the situation? Like should we revert? Should we actually do the computation? There are people who say that we should reward, there are people who say we shouldn't revert and actually do the computation in a painful manner. And this also brings the question of chaos efficiency.
00:13:37.234 - 00:14:39.340, Speaker B: Like if you are doing reverting early would be easy, but whereas actually handling the shadow overflow is much harder. So let's now look at how many protocols implement fixed point arithmetic. The most famous example would be perhaps the VAT math introduced by Maker. As far as I know, it is actually decimal. It uses 18 decimals in fact and it reverts in the case of shadow overflow, which is if P times Q it doesn't fit into 56 bits, then it's going to overflow and it's relatively gas efficient because the computations are very simple. A modern implementation of this can be found in like SolMate. So you can see the reward happening here for example.
00:14:39.340 - 00:15:30.530, Speaker B: So let's go back. It perfect. Yeah. So to summarize, it's 18 decimals, it's decimal, not binary, it's relatively gas efficient and it doesn't care about shadow overflow. It would revert early. And the next example is in UNICEF V Two which actually uses a binary fixed point type with it's actually 112 bits, not 122. It's a typo and it actually uses shifts instead of division where shifts are actually cheaper in the EVM than division.
00:15:30.530 - 00:16:17.110, Speaker B: Shifts are three gas and division is five gas. So there's a very minor efficiency improvement here and it actually doesn't care about shadow overflow at all. It turns out that this overflow case would never happen and they ignore it. And it's very gas efficient because first of all, you use shifts and second of all, they don't care about this intermediate overflow. Now, going back to Unisa v three, this is where things actually get very interesting. As far as I know, they use binary fixed point, but they use something called the full math. And the full Math is a very interesting function originally implemented by Remco.
00:16:17.110 - 00:17:25.390, Speaker B: So you can see this very interesting piece of code with a really complicated math. What they're doing here is what they're doing here is trying to get rid of this shadow overflow. Yeah. So in the case where P times q overflows, but the value p times Q by B is well defined, UNICEF V three or the implementation by Remco still manages to compute the actual number. And this is very impressive, but unfortunately there are a lot more checks and there are more complicated arithmetic operations involved in this computation. And that means there is more gas. So we saw like three different implementation, the Vodmath, the units of V two, binary units of V three, fixed point, I mean units of V three with binary and the Full math.
00:17:25.390 - 00:18:51.610, Speaker B: So the question you ask is which one do you implement? The unison V three is perhaps the most canonical implementation, but unfortunately it is more expensive than the other simpler ones. So can we find a better solution than this? Probably we can. So remember that the key computation here is sorry, the key computation here is P times Q by B. And if we can compute this value in full precision, we can actually do the Uniswap V three full math implementation cheaply. And we have this proposal for a new opcode in the EVM, which is called Maldive, which actually does this computation. So it's going to perform P times Q by B in 512 bit arithmetic, but in the end it truncates it to 256 bits. So where do we go from here? So first of all, it's not clear to us if fixed points as a type should belong to the language, but we want to have very good support for fixed point arithmetic in the language.
00:18:51.610 - 00:19:32.690, Speaker B: And one way to do that is by allowing users to build their own types and operations on the type. And the first step towards this is already there, which is user defined value types. So you can try to implement your own type. In this case, it's fixed 18, it's exactly like UN 256. And more importantly, there is no change in the Abi. So the Abi is going to be exactly the same as as if you use UN 256, but it's more type safe. I mentioned before, I will talk about Abi issues, about Ufixed.
00:19:32.690 - 00:20:31.690, Speaker B: So the type Ufixed actually exists in the Abi, but this wouldn't have the same selector as the real transfer functions. So this means that the Ufixed, which is already present in the Abi, it doesn't have any backwards compatibility. So if you want to try to interface with, let's say, Die or USDC, die would have 18 decimals, USDC would have six decimals. This function wouldn't even be calling the right one. Whereas if you use fixed 18, it actually has exact Abi compatibility. So this is the very first step towards fixed point types in the language. And the second type is to implement Maldives in the EVM, which is probably going to take another hard fork in the EVM.
00:20:31.690 - 00:21:24.170, Speaker B: And the third step is going to be implementing operators for fixed point types. This can be done in whichever order we want. So just to give an idea of how operators would look like. So here is how the checked multiplication in fixed point numbers would look like if you have Maldives in the EVM. So I didn't mention this, but there is an exceptional case in the Maldives which is around zero. So the EIP currently proposes a special case for Maldives AB Zero, where the zero would be treated like two raised to 256. And the goal would be that this is going to help with checked fixed point multiplication.
00:21:24.170 - 00:22:04.930, Speaker B: And this is an example of how it would look like. Here you're using like fixed .8 user defined fixed point 18. And perhaps a syntax like this using checked mull as star for fixed 18. And then your user defined fixed multiplication can be used anywhere in the language. So what can you do now? So the Maldive EIP is still a relatively new proposal. We want to get as much feedback as possible for the EIP.
00:22:04.930 - 00:22:59.020, Speaker B: Feel free to talk to us. We want especially to get feedback about the exceptional behavior around the value zero. So that is, Maldive AB zero is treated in a special case. There are ways to get around it. You can treat AB zero as zero, but then there is more gas to actually deal with this truncation detecting the Truncation Case the third thing is of course, we want to see if there are other uses for Maldives, especially for implementing cryptographic operations. Perhaps you want to implement EVM inside EVM. Then you might need to calculate, for example, Malmod Mod, X, things like that.
00:22:59.020 - 00:23:49.000, Speaker B: Do you see a use case for Maldives in any of these other applications? Let us know. And of course we would like to get your feedback on the syntax for user defined operators. So I mentioned how the using statement is currently being I mean this is not currently implemented, but this is the current proposal. So we would like to get feedback on how this looks and how this implementation feels to you. And lastly, you can find more notes about fixed point automatic in this HackMD. I will be linking. Here is the link to my talk and that's it.
00:23:54.910 - 00:24:15.090, Speaker C: Amazing. Hey, I'm not Kartik, I'm Jacob. Just kind of jumping in as Kartik works on some stuff behind the scenes. Awesome talk. If anybody has any questions, feel free to drop them in the channel and I will surface them over to Harry. I guess I had a quick question. It's sort of, I guess, related a little bit to the topic.
00:24:15.090 - 00:24:47.850, Speaker C: I know just from my experience programming with floating point in different implementations in different languages, precision comes up a lot as a potential issue. And given that with blockchains we're writing contracts that are largely dealing with money and that kind of thing, I'm kind of curious what your thoughts are about being able to both come up with great specifications for putting point but then also teach people on the risks of precision when it comes to dealing with these primitives.
00:24:48.590 - 00:25:38.390, Speaker B: Yeah, that's a very good question. So when dealing with decimals, there are two approaches. One is fixed point numbers, the other one is floating point numbers. Floating point numbers are incredibly popular in usual computations because they are very fast to implement. Most processors have some instructions to deal with them. But the issue is that it can be a little bit counterintuitive to understand it and also those floating point errors. So if you look at historically, maybe like 2030 years in the past, the equivalent of maybe this 500 million smart contracts hack, smart contract hacks would be rocket failures.
00:25:38.390 - 00:26:43.866, Speaker B: So a lot of these rocket failures can be traced to bad floating point implementations or how people did not or how the accuracy of some numerical computations, some numerical computation did not end up being accurate enough because of this repeated floating point errors. And hopefully the fixed point arithmetic makes this a little more apparent. So the issue with floating point errors is that almost every floating point operation, it has an error associated with it. So if I go back, if I go back addition and subtraction, it has a small error in floating point implementation. But in fixed point implementation there is none. Similarly, in multiplication and division, there is an error term. In division and EVM, there is an error term.
00:26:43.866 - 00:27:11.930, Speaker B: But other things like addition and subtraction and multiplication, there wouldn't be any errors in fixed point implementation. So first of all, the answer is we think fixed points are the way to do it. But of course, if you are introducing division, there's going to be errors and you would need to have some understanding of rounding issues, unfortunately.
00:27:14.110 - 00:27:37.694, Speaker C: Yeah. And then hopefully those don't trickle into too many really bad outcomes at some point down the line. Awesome. Okay, great. Well, actually I think Kartik is actually back from behind the scenes, so I'm going to invite him back on stage and I will disappear and I'll let him wrap us up. But thanks for the talk, Harry, I really appreciate that and learned a lot about how the team is thinking about implementing these permits break, but I did.
00:27:37.732 - 00:28:03.020, Speaker A: Watch the rest of the talk, so thank you so much, Ario. This was a great review. And I feel like we got to get you more here because oftentimes there's a big feedback loop that we get to close when we work with thousands of devs trying to figure out how to do more interest into the solidity. So this has been really helpful. And thanks for also linking to the slides, because that's the most common question. We it and how do they catch up on our slides? And we'll share that with everybody else.
00:28:04.270 - 00:28:05.466, Speaker B: Perfect. Thank you.
00:28:05.568 - 00:28:07.670, Speaker A: Really appreciate it. Bye.
