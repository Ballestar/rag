00:00:07.530 - 00:00:23.642, Speaker A: Hi, thanks for tuning in. In this presentation, I'll be walking you through the different features and use cases of Marlin and how you can offload intensive compute onto it to build secure and scalable decentralized applications. The flow of the presentation is as follows we'll start with a brief introduction to Marlin.
00:00:23.642 - 00:00:52.670, Speaker A: We'll quickly skim the different services that the Marlin network provides, and this will be followed up by some example use cases which might even inspire your project. Once you have an understanding of the capabilities you have access to when using Marlin, we'll walk you through some tutorials for using some of these features. Specifically, using Marlin for privacy preserving or confidential computing offloading the operation of backend services onto a decentralized network, as well as outsource proof generation for ZK applications.
00:00:52.670 - 00:01:23.670, Speaker A: Finally, we point you to some appropriate resources and channels to further your exploration. Mullen, in short, is a network of nodes that make their hardware resources available to users under a PRGO model. These resources can include anything from a vanilla service to trusted execution environments like Intel, SGX or AWS, Nitro Enclaves, GPUs or even FPGs for hardware acceleration of, say, CK proofs or storage and bandwidth for Caching.
00:01:23.670 - 00:01:55.202, Speaker A: A trusted execution environment of Te, in short, is a special piece of hardware in computers where code and data is protected from interference or leakage to external processes. Any code or data sent to the Te can be encrypted and decrypted only inside the Te with special keys, ensuring that when you send private data like identity or like financial or medical records to someone else's device, the owner of the device or any program running in the device isn't able to access the data. Since the data might include code itself.
00:01:55.202 - 00:02:26.566, Speaker A: Programs can be run securely in these environments with the assurance that no one can manipulate the execution of the code and that its output isn't tampered with. As Tes can be used to serve Http or RPC requests like entire backends can be offloaded to a network of Tes to decentralized services that you might otherwise run on a centralized server. Building ZK based applications involves a proving step which is computation intensive, but can be optimized using GPUs and FPGAs.
00:02:26.566 - 00:02:54.286, Speaker A: Some applications require that such operations be run client side to ensure privacy of secret inputs involved, resulting in minutes of wait times for end users. However, such computations can be outsourced to the Malay network, where even the secret keys can be secured by running the operations inside secure on place. So under normal circumstances, validators control the ordering of transactions within a block.
00:02:54.286 - 00:03:20.150, Speaker A: However, interesting applications can be built if ordering preferences of transactions can be communicated to validators. So users who are familiar with using Flashbots on Ethereum can now use it with polygon as well using the Malin relay. So, as mentioned earlier, Tes can be used for building decentralized applications where the confidentiality of data and integrity of execution matters.
00:03:20.150 - 00:03:35.342, Speaker A: For instance, identity for credit scoring and insurance protocols, applications that involve running machine learning algorithms or private data sets. In fact, even private keys can be shared inside Enclave. So one can deploy mev bots or applications that use such bots.
00:03:35.342 - 00:04:09.766, Speaker A: For example, decks that shares mev profits with users entire backends like trading engines for a closed order book decks, gateways for IPFS, RFQ based DEXes, et cetera can be deployed inside Nclaves. So ZKPs can be used to build games, wallets, voting apps, ML applications, and a lot more. And if you want to have the provers run efficiently without utilizing all of your or your users resources, such proving operations can be outsourced to Marlin.
00:04:09.766 - 00:04:40.070, Speaker A: You can also build integrations with existing ZK ecosystems by outsourcing some of their provers to our network using our Flashbots relay. You can build rescue bots that help users rescue funds from hacked wallets, bots that help users get priority doing NFT Mints, maybe sharing DEXes that shared captured me with users, and a lot more. So without further ado, let's jump into some walkthroughs for some of these features.
00:04:40.070 - 00:04:56.454, Speaker A: In this tutorial, we'll take a look at how to create a simple node JS server and deploy it inside an enclave. The tutorial that we'll be following for this is the one from our docs. You can find it under User Guides enclaves tutorials deployment JS server.
00:04:56.454 - 00:05:08.302, Speaker A: I also have with me a fresh Ubuntu 20.0, for instance, where I'll be running all the commands. So before we do anything, we need to install dependencies that we are going to need later.
00:05:08.302 - 00:05:37.040, Speaker A: So we need docker to actually build the employer image. So let's install that. Since we are building a node JS server, let's go ahead and install that as well.
00:05:37.040 - 00:06:30.888, Speaker A: And we also need to install MetaMask, but I already have it installed, so I'm just going to skip that step. Great, let's move on to the next step now. So let's actually create our node JS server.
00:06:30.888 - 00:06:51.530, Speaker A: So let's create a working directory for it first, and let's just create a basic node JS project. Great, so we'll create our server using Express. So let's install that and let's actually create our server file.
00:06:51.530 - 00:07:16.490, Speaker A: So you can actually deploy node JS servers directly inside Enclaves, which install node and use that to run it. But if you were seeing our steps from before, installing node takes a lot of time and then installs a lot of stuff. So that basically bloats the image size significantly.
00:07:16.490 - 00:07:46.040, Speaker A: So what we are going to do is we are going to use Pkg to package up the server file and node JS into a compressed binary so that you can just run it directly without installing any dependencies. So let's go ahead and do that. Let's install Pkg first and let's actually create the binary.
00:07:46.040 - 00:08:05.640, Speaker A: Great. So if you see I have an app binary now and you should just be able to run it and yeah, it just opens up a server that's listening on port 4000. Let's now move on to actually creating our enclave image.
00:08:05.640 - 00:08:20.130, Speaker A: First we'll set up a development environment. And for that we'll use our nitro CLI image, which sets up a development environment for you out of the box so you don't have to do manual installation steps. So let's do that.
00:08:20.130 - 00:08:29.476, Speaker A: Great. It's running. Now I will just open new terminal and leave the other one running.
00:08:29.476 - 00:08:57.528, Speaker A: And we'll basically get a shell inside our container using this. So this container basically comes pre installed with like docker and ito CLI, the most important parts that you need to actually build the on click. So let's navigate to our server here and you'll see that our server from outside has basically been mounted inside the container.
00:08:57.528 - 00:09:13.030, Speaker A: So any changes that you make to files directly on the instance itself will reflect over here. The next step is to actually prepare our image specification. And for this, let's go to this link.
00:09:13.030 - 00:09:28.730, Speaker A: What we'll be using is we'll be using the default image specification that we provide and we'll basically just be customizing all this stuff. So let's first create a docker file. I just open a new terminal for this.
00:09:28.730 - 00:09:41.870, Speaker A: Let's go inside. Yeah, let's create a docker file first. The next one is setup sh.
00:09:41.870 - 00:10:02.210, Speaker A: Create that. And finally we have the supervisor configuration. Let's also set that up.
00:10:02.210 - 00:10:22.970, Speaker A: So something that you'll notice is that all of these files basically have customization points built into them where you can basically put our custom setup code. And that's exactly what we'll be doing in this tutorial. So now that I've copied the files, let's go back.
00:10:22.970 - 00:10:40.112, Speaker A: Yeah. So the docker file basically sets up a lot of default networking and supervisor related stuff for you. And what we are going to be doing is we want to run our server when the enclave boots up.
00:10:40.112 - 00:10:55.248, Speaker A: So we'll just copy our server into the enclave first in the docker file. Yeah. And the setup sh file doesn't really need any modifications.
00:10:55.248 - 00:11:07.210, Speaker A: And what we'll do is we'll edit supervisor d to basically start up our enclave program. Start up our server program when the enclave starts up. So let's copy this.
00:11:07.210 - 00:11:28.180, Speaker A: So this will make your server startup, but one thing that you need when you're running inside enclaves is you need a proxy to basically expose it to the outside world and not just inside your enclave. So let's set that up as well. Great.
00:11:28.180 - 00:11:43.320, Speaker A: Yeah, that should do it. So let's go back to the terminal that we had before this one. And let's first build a docker image based on the docker file that we just created.
00:11:43.320 - 00:12:38.072, Speaker A: And you should be able to see the image that you just made over here on player latest. Now let's use this docker image to create our enclave image. Great.
00:12:38.072 - 00:12:52.060, Speaker A: And it basically prints some measurements over here. These are used to ensure that the integrity of the enclave is maintained. Let's move on to the final step, which is deploying the image on the Malay network.
00:12:52.060 - 00:13:13.920, Speaker A: So here one thing you need is you need to host the image somewhere where it can be publicly downloaded by nodes in the Malay network. So for this purpose, I have chosen to go with the service called Web Three Storage. You can upload files to the service and it stores them on IPFS and pins them using Filecoin, essentially.
00:13:13.920 - 00:13:39.832, Speaker A: So I have already uploaded my image over here that you can see and it gives you a URL. If you just right click and click Copy link, it gives you a URL that you can use to basically copy the onclair image. So once I've done that, let's actually just verify whether the image hosting and stuff is working properly.
00:13:39.832 - 00:13:58.050, Speaker A: So let me just copy the link address. Let's go here and let's try to actually download it. One thing about Web Three Storage is you need to manually add the file name at the end.
00:13:58.050 - 00:14:12.424, Speaker A: But yeah, seems like it's able to download it, in which case it's hosted properly. So that shouldn't be an issue. Now, let's create a job for this.
00:14:12.424 - 00:14:26.984, Speaker A: For that, we go to the UI that's hosted over here using the URL link. And what we do is we basically fill in fields as given over here. So for example, this is the provider that we've run for ETH India.
00:14:26.984 - 00:14:40.916, Speaker A: So we put that over here and we put 250 as the deposit amount. That will make your own place run for roughly two to three days. And we also give the link that we just saw to the Web Three storage thing.
00:14:40.916 - 00:14:50.070, Speaker A: And yeah, we need two steps. One is we need to approve the contract to actually get your tokens. So let's do that.
00:14:50.070 - 00:15:11.500, Speaker A: Yeah, it's done. And let's now create our job. That should be done as well.
00:15:11.500 - 00:15:28.420, Speaker A: Yeah, that's controlled. So once you've done this, you can basically come to us and we can give you the IP address of the enclave that you just deployed. So in my case, it happens to be this.
00:15:28.420 - 00:15:39.750, Speaker A: So what I'll do is to ensure that the enclave is running. I'll just try to call 4000. Yeah, there we go.
00:15:39.750 - 00:15:49.740, Speaker A: There's the response from a server that we just deployed. And so that concludes this particular tutorial. And thank you.
00:15:49.740 - 00:16:05.870, Speaker A: Let's try something a little bit more complex. Now in this tutorial, you'll learn how to perform privacy preserving compute inside enclaves. This tutorial is also from our docs, you'll find it under Oyster Tutorials.
00:16:05.870 - 00:16:22.900, Speaker A: More specifically, we are going to learn how to load numbers inside an enclave and also how to perform compute on them. In this case, it's going to be addition. So we just expect the enclave to return the sum of the numbers that we are going to be loading inside it.
00:16:22.900 - 00:16:35.026, Speaker A: I have an Ubuntu instance with me where I'm going to be running most of the commands. Let's start by installing some dependencies. So I need docker to build the infrared image.
00:16:35.026 - 00:16:57.880, Speaker A: So let's install that. Most of our programs are also written in Rust, so let's install that as well. Let's install a few more programs that we need to actually build our programs.
00:16:57.880 - 00:17:18.030, Speaker A: You also need to install MetaMask wallet, but I already have it in web browser, so I'm just going to be skipping this step. Let's go on with creating a project now. Let's create a working directory for it first, and let's just create a basic cross collect.
00:17:18.030 - 00:17:34.340, Speaker A: Let's now set up our dependencies and the binaries that you're going to be building. So here I just have a bunch of dependencies that are going to be used by the programs that you're going to build. And this is a list of the programs that you're going to build.
00:17:34.340 - 00:17:55.648, Speaker A: Let's first create the app server. So the app server is the main program that's going to do the addition inside the enclave. And it accepts two types of messages.
00:17:55.648 - 00:18:22.396, Speaker A: One message is used by the loader to load numbers into the enclave, and the other message is used by the requester to essentially fetch the results of the addition operations. The privacy is maintained here because the program first does a diffie helmant key exchange to generate a shared secret key. And it expects the data that is coming in to be encrypted by this key.
00:18:22.396 - 00:18:48.500, Speaker A: So nobody can eavesdrop on the data, and the data can't leave the end play either. Let's create our loader. Now, the loader is the one that's going to be sending data to the enclave.
00:18:48.500 - 00:19:08.750, Speaker A: In our case, we've chosen the numbers to be twelve and 43. So our expectation is that the enclave is going to add these numbers up and return as a result of 55. The loader also does the same DP helmet key exchange to generate the shared key and it encrypts the data using this key to ensure that nobody is eavesdropping on it.
00:19:08.750 - 00:19:39.210, Speaker A: Let's write our requester now. Requester pretty much just does a query of the result that's inside the enclave and it prints that on the console. That's pretty much it.
00:19:39.210 - 00:20:22.418, Speaker A: Let's create a key generator program that we're going to need to generate keys for the DeFi Herman key exchange and let's create the verification program. Now, if I start by creating an AWS cert file this certificate is the root certificate of the AWS Nitro infrastructure. So this gives you an assurance that you are actually communicating to an enclave and not any other random server.
00:20:22.418 - 00:20:38.102, Speaker A: Let's create our Verifier program. Now. The Verifier basically downloads the Attestation from the enclave.
00:20:38.102 - 00:20:59.920, Speaker A: It does a verification of is the Attestation signed properly? Are the certificate chain signed properly? Are they expired or not? And does the chain end up at the AWS root certificate? Things like that. And yeah, that's pretty much all our components. Let's now build everything.
00:20:59.920 - 00:21:39.728, Speaker A: It's done. Let's generate our keys that we're going to use for the key exchange and we should have our loader and requested keys over here. Let's now build our image.
00:21:39.728 - 00:22:05.020, Speaker A: Let's first set up a development environment by using the Nitro CLI docker image that we have. This already comes built in with a lot of the dependencies that you need, mainly like docker, nitro CLI and all that. Let's get a shell into this and you can see that it already has the main dependencies that you would need to build NKL images.
00:22:05.020 - 00:22:29.750, Speaker A: Let's navigate to our directory and there we have the directory that we had before mounted inside this NCLE. Now let's now start preparing the specification for our image. So the images that we are going to be using are going to be based on our default image specification.
00:22:29.750 - 00:22:44.506, Speaker A: So you'll find it on the link here, which basically consists of three main files. Just open a new terminal for this. Let's create docker file.
00:22:44.506 - 00:23:12.120, Speaker A: First you'll see that the docker file has a customization point where you can write your custom setup code. Let's also create the setup file. And same here, the setup also has the customization points where you can put stuff.
00:23:12.120 - 00:23:36.430, Speaker A: And let's finally create our supervisor file. This has all the programs that are going to be running inside the enclave and you can add your own over here. Let's customize the image.
00:23:36.430 - 00:23:53.486, Speaker A: Let's go back here. And once we build the image, you should see that we have an app binary over here. That's our actual server.
00:23:53.486 - 00:24:15.802, Speaker A: So we need to copy it inside the enclave and start running it. So let's do the copying first. We also need to copy the public keys in order to support the deb admin key exchange.
00:24:15.802 - 00:24:27.940, Speaker A: Let's do that. The setup file doesn't really need any changes, so we leave that alone. And let's now copy our program specifications and start running them.
00:24:27.940 - 00:24:43.240, Speaker A: Our server goes here and we also need a proxy to expose the server outside the enclave. So let's add that as well. And that goes here.
00:24:43.240 - 00:24:54.390, Speaker A: So yeah, that's pretty much it. And let's now build our image. Let's go back to the terminal we had and let's start building our image.
00:24:54.390 - 00:25:43.770, Speaker A: We first build a docker image using the docker file that we had and now we use nitro CLI to convert the docker image into an enclave image. So this command prints some measurements. Make a note of these values because we'll be using them during verification later.
00:25:43.770 - 00:25:58.460, Speaker A: Let's now deploy the image. So for this you first need to upload the image onto somewhere where it can be downloaded by the nodes in the network. So for this I've chosen web three storage.
00:25:58.460 - 00:26:16.580, Speaker A: It stores files on the IPFS network and pins them using filecoin. I've already uploaded my image over here. That's the first one here, and you can just right click to get a URL link to the CID archive that's on filecon.
00:26:16.580 - 00:26:35.558, Speaker A: One thing that's good to do is check whether the URL is publicly accessible using just duplicate or call. You can just download it and just verify the step. Let's move on with creating a job.
00:26:35.558 - 00:26:55.022, Speaker A: So for that, I first go to the oyster portal, and I already pre filled in some data that's over here. This is the address of the infra provider that you deployed for ekindia. And you can just put a deposit amount, and the link that we just saw from every storage goes here.
00:26:55.022 - 00:27:55.940, Speaker A: One thing to remember is you need to add the nclea EAF file name at the end manually over here. Just make a note of that. Let's go ahead and create our job confirmed as well.
00:27:55.940 - 00:28:19.798, Speaker A: So once you've done it, you can come to us and we can share the IP address of the enclave that you just deployed. Let's now move on to verification. So for this part, I'm just going to use an existing enclave that's already deployed, just so I don't have to wait for the current one to get deployed.
00:28:19.798 - 00:28:45.460, Speaker A: And that's over here, you can see it pretty much has almost all of the same files that you had previously. And the enclave image that was previously deployed had the following measurements, and it was deployed on the following IP. So I'm going to be just using this data.
00:28:45.460 - 00:29:00.340, Speaker A: So let's first verify whether we are able to communicate with the NCLA, whether the attestation matches and all that. So let's do that. You'll see a lot of blank spaces here that you'll have to fill in.
00:29:00.340 - 00:29:43.480, Speaker A: Let me fill the IP first. It once it prints the puppy like this, you know that the verification was successful. And it also creates an app pub file that contains the public key of the enclave that you can use to basically do the defaultment key exchange.
00:29:43.480 - 00:29:54.220, Speaker A: Let's now load data into the Nclip. And there we go. It says, data rate succeeded.
00:29:54.220 - 00:30:09.490, Speaker A: And recall that the data that we loaded were with the numbers twelve and 43. So our final step should give us the result of 55, which is the sum. And there we go.
00:30:09.490 - 00:30:16.112, Speaker A: So that's how you do privacy preserving compute inside the enclave. Of course, I just did. Simple addition.
00:30:16.112 - 00:30:24.010, Speaker A: You can do any sort of computation that you want inside that. And that concludes this tutorial. Thank you.
00:30:24.010 - 00:30:41.660, Speaker A: In this tutorial, we'll create a small circum program and take a look at how to outsource compilation and proving onto our prover network. The tutorial that we'll be following for this is again from our docs. You can find it under user guides pros tutorials.
00:30:41.660 - 00:32:02.600, Speaker A: Let's start with installing some dependencies that we'll need in later steps. So first, let's install snagges that we're going to use to verify proofs. Also install unzip that we need to extract proofs from archives that the proven network is going to send us.
00:32:02.600 - 00:32:12.374, Speaker A: Yeah. So let's create our program now. Let's first create a working directory for it.
00:32:12.374 - 00:32:25.370, Speaker A: And let's create our program. The program that we're going to use today is a simple multiplication program. So you have two secret inputs, A and B.
00:32:25.370 - 00:32:49.352, Speaker A: And the goal is to check whether you know a particular combination of A and B that when multiplied together, gives rise to a public output C. Now let's outsource compilation of this program onto the pro network. We do that by making a simple API call.
00:32:49.352 - 00:33:09.536, Speaker A: And when you're running it yourself, you would probably want to change the entropy value to some other random combination of letters. That's done. And make a note of this project ID.
00:33:09.536 - 00:33:24.324, Speaker A: We'll need it while generating the proof. Before generating the proof, we need to first specify what the values of ENB are going to be. So for this tutorial, I've picked C to be 1024.
00:33:24.324 - 00:33:46.872, Speaker A: So I've picked a particular combination of A and B as like 16 and 64, that multiplied together gives you 1024. So let's create our inputs file and let's now generate the proof. This has the project ID blank over here.
00:33:46.872 - 00:34:03.204, Speaker A: Let me just copy and fill in from before it. Now we have an output zip file which contains the proof. Let's extract that.
00:34:03.204 - 00:34:18.104, Speaker A: Now it and there we go. We have all our proof files over here. So to verify proof, we need to verify a couple of things.
00:34:18.104 - 00:34:38.450, Speaker A: We first need to verify whether the public outputs or like public inputs that were generated by the proven network match with what we expect. So recall that we wanted our C to be 1024, which matches over here. So that's all good and let's do the final verification step now.
00:34:38.450 - 00:34:52.320, Speaker A: Yes, seems like all good. And yeah, that's essentially like compilation and proving outdoors to our proven network. And you can easily verify it locally using Snap JS.
00:34:52.320 - 00:35:05.176, Speaker A: And that concludes this tutorial. Thank you. You can reach us on these platforms and we'll also be in person at the ETH India event itself.
00:35:05.176 - 00:35:14.180, Speaker A: So if you guys have any feedback, any questions or want help with the hackathon, feel free to hit us up. Thank you and the best of luck for the hackathon.
