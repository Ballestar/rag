00:00:25.170 - 00:00:43.798, Speaker A: Said, I'm going to kind of maybe speak in spanglish in some parts. One of my kind of core key mission statements as a developer advocate is to make sure that computer science education in general is widely accessible to people from all over the world. And that means that when you're in a different country with a different language, making sure that those people can access education in the same way.
00:00:43.798 - 00:00:55.294, Speaker A: I did a check here, and everyone here speaks English, so I'll lean more towards English on that for sure. And all of the stuff that it's published is in English, but it would actually be great for us to potentially translate it. So cool.
00:00:55.294 - 00:01:05.540, Speaker A: We're going to do a Foundry workshop, a complete introduction to smart contract development with Foundry. So Nader is being my emotional support right now, but then we're going to switch. Then he's going to get on, and I'll be his emotional support.
00:01:05.540 - 00:01:18.734, Speaker A: Cool. So Foundry is a portable, fast and modular toolkit for ethereum application development. So you might have heard of it, but you might have heard of others that fall into the same category in that part of the stack.
00:01:18.734 - 00:01:25.330, Speaker A: So maybe hard hat. Maybe truffle. So it falls into the same place it does the same thing where it's tooling around development.
00:01:25.330 - 00:01:40.746, Speaker A: And we'll talk about exactly what are some of the unique values and the unique propositions that Foundry has and how you can leverage it in your smart contract development. So why foundry? Like I said, there's other competitors. If you look here, there's oh, is it ugly for you guys too? Yeah, okay.
00:01:40.746 - 00:01:44.550, Speaker A: It's okay. It's in the middle. So there's hard hat, there's truffle, there's brownie, there's anchor.
00:01:44.550 - 00:01:59.822, Speaker A: But kind of like, what is the unique proposition of Foundry? And why are we here talking about Foundry specifically? So, a few different reasons. One is that it lets you write your tests in solidity instead of JavaScript. And we say instead of JavaScript because I think at least for both of us, before Foundry, we were using hard hat.
00:01:59.822 - 00:02:20.790, Speaker A: And when you're writing your tests there, you're writing your tests in JavaScript even though your smart contracts are in solidity. So with Foundry, it allows you to kind of have just less context switching and less mental overhead of writing in one language and then testing in a different the next one is that it's really, really fast. If you've used hard hat or anything else, and then you use Foundry, you'll be able to feel the difference and tell the difference.
00:02:20.790 - 00:02:41.850, Speaker A: And it's partially because it's written in Rust, it's able to leverage a lot of the key properties that come with Rust and why Rust is gaining so much popularity right now. Another really cool thing that we're going to go over today in the workshop is an improved developer experience with Fuzzing. So Fuzzing is an automated testing strategy that basically lets you as a developer, make sure that you're testing for all possible cases.
00:02:41.850 - 00:02:56.510, Speaker A: So when you write unit tests or maybe functional tests, you're checking that an output for a very specific input matches what you expect. So you're like, check that the output equals one, check that the output equals two. But there's no way that you can manually write tests to handle every possible outcome.
00:02:56.510 - 00:03:21.190, Speaker A: So that's exactly what Buzzing does, is it makes sure that you as a developer are seeing all of the edge cases, all of the kind of failed cases that are out there, so you can make sure that you're handling those. And then, okay, one of these are out of pocket, out of order. So talking about the tools that come with Foundry and what we're going to talk about exactly today are anvil forage and Cast.
00:03:21.190 - 00:03:40.270, Speaker A: So starting with Anvil, anvil is a local ethereum node similar to what you've already seen in Hard Hat or Ganache, where you can spin up your local ethereum node and use it for testing your contracts and interacting over RPC. Cast is another CLI tool that allows you to interact with the smart contracts. This is where you actually send transactions, read data from the network.
00:03:40.270 - 00:03:58.360, Speaker A: And we're not going to talk too deeply about this next part, but I would encourage you guys to check it out in the Foundry book, which is linked at the end. CAS also has some really cool subcommands that you can use for decoding call data and sending arbitrary messages and a bunch of other things. And then this is the one that was in the wrong place.
00:04:00.570 - 00:04:01.350, Speaker B: CAS.
00:04:03.710 - 00:04:14.586, Speaker A: Oh, forage okay, well, I didn't put one in the slides, but the other one is forge. And that's like what you use to what do you call it?
00:04:14.608 - 00:04:19.502, Speaker B: It's kind of one of the main commands that you're going to be using on the CLI to generate a project and run tests and stuff.
00:04:19.556 - 00:04:26.334, Speaker A: Yeah, like when you do Hard Hat in it, it's the equivalent to that. So when you're doing forge. So now we're going to actually walk through.
00:04:26.334 - 00:04:35.166, Speaker A: If you want to pull out your laptop, you can follow along. If you want to do this later on your own and just watch, you can do that. If you want to follow along, go to Natter's, Twitter.
00:04:35.166 - 00:04:39.350, Speaker A: He just tweeted out the link to it so you can see it up close so you don't have to squint.
00:04:40.010 - 00:04:45.986, Speaker B: Thank you for that introduction. So I'm going to get off stage.
00:04:46.018 - 00:04:48.626, Speaker A: And help people if they run into stuff while we're doing it.
00:04:48.668 - 00:05:08.414, Speaker B: Yeah. So what we're going to be going over today is an open source GitHub repo that you can obviously follow along with today. Or if you are watching at home or watching this at any other time and you don't have time to follow along, you can do this obviously at another time.
00:05:08.414 - 00:05:31.606, Speaker B: But I've kind of tried to make this the most concise introductory level workshop to kind of get all of to me, the most important, exciting things about Foundry covered in a short amount of time. And along with this workshop, I've linked to a couple of really great resources. One of them is the Foundry Book, and it's a great resource, obviously.
00:05:31.606 - 00:05:49.238, Speaker B: The other two, though, are one of them is something that I actually reference almost on a daily basis when I'm writing smart contracts with Foundry. And this is something I created called the Foundry cheat sheet. And this basically just has all of the copy and paste commands for the 90% of the work that I do with Foundry.
00:05:49.238 - 00:06:10.594, Speaker B: So you might want to know, oh, how do you send a contract call to an address that's local? How do you send a contract call to a live contract? How do you do this or that? There's a lot of good copy and paste code that you can use here. And I believe that we are going to actually merge this into the Foundry Book. There's already kind of a GitHub issue open there.
00:06:10.594 - 00:06:24.434, Speaker B: So for right now, the Foundry Cheat Sheet is separate, but it might be part of the book later. And then the other is a video tutorial that I've done on getting started with Foundry. It's very similar to this workshop, but maybe a little bit more in depth.
00:06:24.434 - 00:06:41.098, Speaker B: So with that being said, the only prerequisite for this workshop is that you have Rust installed. And if you want to see where this actual GitHub repo is, it's actually GitHub.com Dabbit Three.
00:06:41.098 - 00:06:47.550, Speaker B: I think the URL was actually the slides there. So GitHub.com Dabbit three.
00:06:47.550 - 00:07:06.350, Speaker B: The very top workshop should be there. And the things that we're going to be covering today are testing and assertions, fuzzing logging, running a local node and deploying to that node. We're going to be looking at calling contract calls directly from your command line to that local node, installing and using libraries.
00:07:06.350 - 00:07:23.370, Speaker B: So in hard hat we can use NPM to install like open Zeppelin contracts and stuff like that. And with forge, you can actually do the same. We're going to look at how to configure the remapping so that your text editor understands where these libraries are, but also the development environment knows where those are as well.
00:07:23.370 - 00:07:42.510, Speaker B: And we're going to also look at some of the more interesting things that you're going to probably doing on a daily day to day basis, like mocking users. So let's say you want to kind of like run a contract call from one user and then test it out by transferring a token to another user and all that stuff. How do you do that? Well, we're going to cover that today.
00:07:42.510 - 00:07:57.986, Speaker B: And that should be, I think, a really great overview. Once you go through this, then I think at least for me, this was everything I needed to get started building. So with that being said, Cammy kind of gave an introduction around a lot of this overview stuff.
00:07:57.986 - 00:08:10.950, Speaker B: That I'm going to skip now, and we're going to actually go directly to getting the installation done. Now, if you don't have Rust installed, it might take a little time for you to actually do that. So you might not be able to follow along.
00:08:10.950 - 00:08:25.242, Speaker B: But once you have Rust installed, you're going to be installing Foundry Up. And once you have Foundry Up installed, you can just run this command, Foundry Up. And this will either install Foundry or it will install the latest version of Foundry.
00:08:25.242 - 00:08:40.846, Speaker B: So before this workshop, I ran Foundry Up and broke everything in the workshop because things changed. So I had to go back and make some updates. But the only thing that really changed with the new update was the actual original contract that was scaffolded by Foundry.
00:08:40.846 - 00:08:52.342, Speaker B: They used to just scaffold out an empty contract. Now they scaffold out a counterexample, which is actually much nicer. And honestly, it's also a good contract to play around with if you're learning.
00:08:52.342 - 00:09:10.346, Speaker B: So with that being said, what we want to do is install Foundry by running this command and running Foundry Up, like I mentioned. And what that's actually going to do? It's going to install a couple of different libraries or a couple of different tools, I would say. And Kami already kind of covered those.
00:09:10.346 - 00:09:22.478, Speaker B: But once you do the installation, you're going to have three different CLI commands available to you. One is forge, one is cast and one is amble. Forge we're going to use to create a new project.
00:09:22.478 - 00:09:35.294, Speaker B: We're going to use it to do testing and stuff like that. Cast is actually what you're going to use to then make contract calls against any live contract. And it doesn't have to be a contract created by Foundry.
00:09:35.294 - 00:09:49.350, Speaker B: Actually, you can literally just use this cast to interact with any live EVM network, which is cool. And then Amble is what you'll use to spin up a local node. So with that being said, we're going to run Forge Init, and this will scaffold out a new project.
00:09:49.350 - 00:09:57.866, Speaker B: So I'm going to go ahead and open my command line. And is that readable for everyone? Okay, cool. Try to make it big enough.
00:09:57.866 - 00:10:08.366, Speaker B: So we're going to run Forge init. Well, first of all, let me just show you that we're in an empty directory now. So Forge Init will scaffold out a new project.
00:10:08.366 - 00:10:30.994, Speaker B: And while that's scaffolding out, I'm going to open that up in my text editor, and we're going to look at the folder structure, and we're going to see that we have the SRC directory, which holds our main contracts. We have our test, which holds what? Our tests, obviously. And then we have our script, which is actually what you're going to use to deploy your contracts.
00:10:30.994 - 00:10:42.614, Speaker B: And scripting is actually really cool. And I think it's something that wasn't there when Foundry first came out. And then Lib is like the node modules, but it's for this environment.
00:10:42.614 - 00:11:01.194, Speaker B: So if you install open Zeppelin contracts, it'll go in the Lib folder and you can immediately start doing things. So if you wanted to run a build, you could say forge build, and this is going to compile your contracts and it's going to give you the abis. So if you ever use Hard Hat, you compile, you get your abis.
00:11:01.194 - 00:11:19.780, Speaker B: And you can use those to make client side calls, or you can use them to deploy and verify your contract on something like Etherscan. Once you run Forge build, you're going to have this out directory, and this out directory holds your APIs. You can also run Forge test.
00:11:19.780 - 00:11:46.718, Speaker B: And we're going to be actually running back through these commands again with a new code base because we don't really know what that's testing because we haven't even looked at the contract. So what I'm going to do is go back to my code base. And what I want to do is instead of using this counterexample, we're going to do a Hello World, which is going to just give us a little bit more room to work with to show some of the functionality that you might not be able to do with just a counter example.
00:11:46.718 - 00:12:03.358, Speaker B: So in order to do that, I'm going to rename this to Hello World Soul. And everything that I'm doing is actually covered in the workshop materials, copy and paste directly from here. So don't worry if you're not keeping up, you can literally just go here and copy and paste.
00:12:03.358 - 00:12:18.642, Speaker B: So what I've done is I've renamed counter to Hello World, and this is a very basic Hello, World contract that I'm going to go ahead and paste here. The only functionality that we have is that we have two variables. We have a greeting and we have a version.
00:12:18.642 - 00:12:31.740, Speaker B: When we make a new greeting, we're going to increment the version and we're going to have a function that just returns the greeting. So it's about as simple as you can get. But it also, I think, is a good basic starting point.
00:12:31.740 - 00:12:42.510, Speaker B: So the contract is there. This isn't on solidity development, it's on Foundry development. So we're going to actually go now to the test and we're going to spend more time on testing.
00:12:42.510 - 00:13:12.870, Speaker B: And what we want to do is we're going to go to test foldercounter t Soul. We're going to rename that to Hello World, t Soul, and you're going to notice that in this example contract here, that we have a couple of functions and they start with the word test. Now with Foundry, any function that starts with the word test will automatically be tested when you run Forge test.
00:13:12.870 - 00:13:24.990, Speaker B: It doesn't even have to be in this directory. So keep that in mind when you're writing your test. If you create a test in the test that doesn't start with test, it won't actually get tested, at least by default.
00:13:24.990 - 00:14:08.646, Speaker B: So what we're going to do is just go ahead and copy this test and we're going to walk through the assertions that are being had there. All right, so the first thing that you might notice that's different is that we have this setup function and this just allows you to create some type of initial variable or whatever that you want to reuse across all of your other tests. So it often makes sense to just create a new instance of the contract and then you can just reuse that instance of the contract.
00:14:08.646 - 00:14:35.126, Speaker B: So that's kind of what we're doing here. We're creating this variable called hello that initializes a new Hello World contract and then we can just now say hello, whatever the method of that contract is that we want to call. So the first test that we're going to run is we want to get the value that's returned from the greeting and make sure that what we expect what we expect it to be is this because the constructor takes in that initial argument and we're doing that now.
00:14:35.126 - 00:14:47.014, Speaker B: That's interesting. But I think the most interesting thing to be keeping an eye out for is this assertion assert equals. So you have about a dozen different assertions that you can work with.
00:14:47.014 - 00:15:08.000, Speaker B: And I have a link in the workshop to all of those assertions. So you can assert equality, you can assert things like greater than, less than, equal to, you can assert truthiness, pretty much anything that you would probably need for assertion. So it's a really basic test here, right? We're just kind of like making sure the greeting isn't equal to the string that we expect it to be.
00:15:08.000 - 00:15:31.640, Speaker B: And then we're going to also do an update and we're going to say the initial version of the version is zero. I guess you could say we're going to then create a new greeting which should increment that version number to one. And then we're going to assert that that is equal to one and also assert that the greeting is equal to Hello World.
00:15:31.640 - 00:15:41.690, Speaker B: So with that being said, we can now run forge test. That should work. That's cool and all, but that's not all that interesting.
00:15:41.690 - 00:15:53.126, Speaker B: Let's kind of look at more interesting stuff. So now that we have our basic project set up, let's dive into more stuff. So I mentioned some of these other assertions.
00:15:53.126 - 00:16:06.434, Speaker B: We're not going to really be using any of those other ones, but here are some of them and here's the link to view more. But what we want to look at now is Fuzzing. So fuzzing is cool because we don't actually have to pass in the argument that is expected here.
00:16:06.434 - 00:16:40.558, Speaker B: Fuzzing can actually take care of that for us. And therefore you have also more, I would say, variation in the types of tests that are run because it will basically automatically inject just different variables there. So instead of passing in the variable ourselves, we're going to use fuzzing here and we're just going to define that there is a variable that should be passed in there and then Foundry will automatically inject that and it'll make it available for us.
00:16:40.558 - 00:16:58.660, Speaker B: Everything else kind of I would say stays the same. So now if we run forge test again, it should still work. But if I go to maybe change this greeting to something else, obviously like Hello World, then that should maybe break.
00:16:58.660 - 00:17:17.558, Speaker B: Okay, so the greeting that's coming in is some value that we don't know. So what if we want to know that value, we can start logging it out. And if you want to log, you have about a dozen different logging methods that you can use.
00:17:17.558 - 00:17:30.622, Speaker B: You can just use a straight up basic log, which is just log, which is really simple. And you can also log integers if you know for sure that it's going to be an integer log string. You can do log name string, which would be something like console log.
00:17:30.622 - 00:17:37.178, Speaker B: Passing in the first argument is the string. The second argument is the value. So let's do some logging.
00:17:37.178 - 00:18:01.538, Speaker B: So I'm going to go back to test two and what I want to log out is the value that is returned from the greet method, which should just be Hello World. But you're going to notice when I run this test that nothing is logged out because by default logging isn't enabled. You have to actually ask for more verbose logging.
00:18:01.538 - 00:18:10.866, Speaker B: So what we're going to do is just pass the VV and then now we see that we have the logs there. So hello world. So that's how logging works.
00:18:10.866 - 00:18:23.738, Speaker B: You just want to pass in the verbosity and I think there's up to four v's and I don't know what that would do, but let's see. There we go. So I've never really needed that much, honestly.
00:18:23.738 - 00:18:33.022, Speaker B: Okay, so we have some basic stuff going on. We're going to dive even deeper to more interesting stuff. We only have five minutes, but I think we have enough time.
00:18:33.022 - 00:18:49.170, Speaker B: Next we want to go ahead and run a local ethereum node. So in Hard Hat we would run NPX hard Hat node and in Foundry you just type in the word anvil and this spins up a node. And here you see that we have ten different accounts and ten different private keys.
00:18:49.170 - 00:19:18.826, Speaker B: So what I want to do now is go ahead and set an environment variable to one of these private keys and then that way we can start interacting with the network and referencing that private key as an environment variable. So to deploy the actual contract to the network, we need to run a script. And we already have a basic script in our project here under Scripts.
00:19:18.826 - 00:19:39.030, Speaker B: We want to just rename this to Hello World s Soul. And we have this run function and then we have this broadcast method on the VM that actually does the deployment. And that's kind of where we're going to be doing our work.
00:19:39.030 - 00:19:51.526, Speaker B: So I'm going to copy this and not a whole lot has changed. We still have this empty setup method because we're not really using it. We're doing the VM broadcast and then after that whatever is called will be actually deployed.
00:19:51.526 - 00:20:13.194, Speaker B: And all we're saying is like we want a new Hello World contract deployed. And then we're passing in the constructor argument of the string and then from there we should be ready to go. So how do you actually run this? Well, we are going to use the forge CLI and we're going to say forge script.
00:20:13.194 - 00:20:22.622, Speaker B: We're going to define the location of the script. We're going to define where the RPC is that it's going to be deployed to. So if this was like infuria, you would set an RPC endpoint.
00:20:22.622 - 00:20:36.150, Speaker B: But since we're running locally, we're going to set the localhost 85 45 and then we're going to set the private key as the private key that we stored in our environment variable. And then we're going to say broadcast. Because if you don't say broadcast, it doesn't actually deploy that.
00:20:36.150 - 00:20:55.070, Speaker B: So let's do this without broadcast. And I'm going to go ahead and open my terminal and this will basically just give you a simulation of the deployment. So this will just tell you whatever information about the deployment, like how much gas would be used and stuff like that.
00:20:55.070 - 00:21:23.414, Speaker B: And then when you're ready to deploy, you just run that again and then you just say broadcast. And then what you should be given is the contract address and we're going to also be using that. So now we've deployed and we see some logging that's happened there in our anvil and you also see the transaction ID and the contract ID.
00:21:23.414 - 00:21:39.250, Speaker B: So now that we've deployed our contract, what we want to do is store that in an environment variable. So I'm going to go ahead and do that. Well, let me just do this.
00:21:39.250 - 00:22:04.414, Speaker B: So we have two environment variables now we have our contract address and our private key. And now we want to call that contract because we want to start reading information from our contract locally. So what we can do is say cast call and we're going to pass in the contract address and the method.
00:22:04.414 - 00:22:15.026, Speaker B: So we have that stored in our environment variable so we can just reference it. And then what we want to do is call, greet and we know that it's going to return a string and we get hello from Foundry. That's what we expected.
00:22:15.026 - 00:22:25.834, Speaker B: Pretty basic stuff, but it's pretty cool to be calling that from the command line. We want to now send an update to update the greeting. So we're going to say cast send.
00:22:25.834 - 00:22:38.690, Speaker B: We're going to say update greeting. We're going to pass in the new greeting and then everything else is the same. So if I copy that and then I go back and read the greeting again, this should now have my new greeting.
00:22:38.690 - 00:22:53.378, Speaker B: And there we go. We've read the contract, we've updated and we've then read the new value. So now that we've kind of gone over some of the basics, let's look at how to install a new package.
00:22:53.378 - 00:23:07.420, Speaker B: So one of the most popular packages is OpenZeppelin Contracts. So let's create an ERC 721. And what we want to do is just say Forge install OpenZeppelin, OpenZeppelin contracts very similar to like NPM install.
00:23:07.420 - 00:23:40.414, Speaker B: And what I need to do first is make a commit because they don't like that if you have uncommitted code. Okay, so we're installing Open Zeppelin contracts and after that's installed, it should just show up in our Lib folder right there. And we now need to configure our remappings because we need to tell our local environment where to find that code once we try to import it and use it.
00:23:40.414 - 00:23:54.314, Speaker B: So you can actually run Forge remappings and see already whatever remappings are configured. And here you kind of already see them trying to kind of make some assumptions about your environment. But we want to set a custom remapping.
00:23:54.314 - 00:24:25.292, Speaker B: So if you would like to do that, you can actually just create a new file called remappings Text and we will set our remapping for OpenZeppelin here. And now we can actually just import that directly from OpenZeppelin without having to reference the entire path. And it looks something like going to we have maybe three more minutes and we're already over a little bit.
00:24:25.292 - 00:24:43.680, Speaker B: But we still have just one more thing to cover. We want to look at mocking another user, which is, I think, one of the more useful things that you could probably learn here. So to do that, we're going to be going to make a new ERC 721 soul.
00:24:43.680 - 00:25:10.170, Speaker B: This is a really basic contract, but you see now we're actually importing from Open Zeppelin contracts, which is pretty cool. We're creating an ERC 721 called DevCon Panda and we will just have a Mint function, pretty basic stuff. And we are going to also have a test for this because this is going to be the part where we're actually learning something in the test.
00:25:10.170 - 00:25:30.492, Speaker B: Okay, so the test that we have set up for right now is really basic. We haven't added any of the mocking features yet, but what we want to do is simulate another user. So we have two users, we have Noah and we have Sophia.
00:25:30.492 - 00:25:44.976, Speaker B: And what we want to do is create a token, transfer it to another person. We want to make sure that only the owner of that token can actually transfer the token. So to do that, we are going to use the prank method.
00:25:44.976 - 00:26:03.704, Speaker B: And you can either say Prank and Prank will be using the next call only to prank that user, or you can say Start Prank and it will do all of the users or all of the calls that come after that until you call stop prank. So this will wrap up the workshop. I know we're a little bit over.
00:26:03.704 - 00:26:13.848, Speaker B: I'm going to go ahead and create the function that we're going to be doing here. And we have this method where we're going to test a transfer. So we want to mint a new token to Noah.
00:26:13.848 - 00:26:28.820, Speaker B: We want to start pranking and simulating us being Noah. We want to then transfer to Sophia. And then we want to check the owner of that token and then assert that Sophia is indeed the owner.
00:26:28.820 - 00:26:45.880, Speaker B: And if we run forge tests, that should work. We want to actually only test this contract. And if you would like to do that, you can pass in the match contract.
00:26:45.880 - 00:26:58.504, Speaker B: So now we're only testing that one. And to make sure that everything is working good, we're going to assert that Bob is the owner when he's not the owner and everything fails, which is what we want. Okay.
00:26:58.504 - 00:27:10.908, Speaker B: So that's basically it. We're not covering everything. You can run forge coverage, which is a pretty cool command to give you test coverage and you can go even it's not working because the test has failed.
00:27:10.908 - 00:27:15.788, Speaker B: But anyways, forge covers is really nice. So that wraps up the workshop. Sorry we started a couple of minutes late.
00:27:15.788 - 00:27:19.196, Speaker B: I'm sorry we went a couple of minutes late. Over. Check out the GitHub repo.
00:27:19.196 - 00:27:22.830, Speaker B: Walk through all that stuff a little bit slower if you'd like to learn more. Thank you.
