00:00:06.410 - 00:00:21.630, Speaker A: Okay guys, we are at Canon Ethereum hackathon. My name is Lisa and I'm happy to introduce you to Tyco. Taiko is a fully decentralized Ethereum equivalent ZK roll up.
00:00:21.630 - 00:00:30.694, Speaker A: That is a type one ZK EVM. And let's quickly define what all that means. What all that means.
00:00:30.694 - 00:00:51.126, Speaker A: So a roll up is an layer two scaling solution that batches multiple transactions of chain and submit them to a separate chain in a single transaction. For example, to ethereum. So it batches multiple transactions and submits in a separate transaction one single transaction.
00:00:51.126 - 00:01:10.900, Speaker A: That's why it has kerneling solution. And the stake roll up is just a roll up that uses zero knowledge proofs, also often called validity proofs. When we say Ethereum equivalent that means that there are no changes to the way Ethereum clients execute bytecode and store data.
00:01:10.900 - 00:01:34.198, Speaker A: That is, Teicco uses the send hash function, they send state trees, transaction trees, precompiled contracts and other inconsistent logics and it will inherit future Ethereum upgrades. Further. And decentralized in a roll up context means that both proposers and provers are decentralized.
00:01:34.198 - 00:02:07.730, Speaker A: That is, no single party is able to control all transaction ordering or be solidly responsible for proving blocks. So, where we are today, in December we released alpha one testnet and in Marv that is very very soon we are releasing alpha two testnet. So we are here tanko consists of three parties, that is a Zkevm and a layer two client and the protocol.
00:02:07.730 - 00:02:31.530, Speaker A: And today, right now, we will learn a bit about the takeoff protocol. Let's go. Layer two solution roll up bundles some transactions in a block and then this block goes through three stages block proposition, block validation and block verification.
00:02:31.530 - 00:03:05.430, Speaker A: Let's start with block proposition. TECO client determines the transaction sequence in the block so it gathers some transaction and order them in the block and proposes this block to the Ethereum node. Many blocks are proposed in parallel and pending in the Ethereum manpole.
00:03:05.430 - 00:03:34.500, Speaker A: However, for UN verified blocks Taiku supports a limited amount of slot on Ethereum be contained and reuse this slot. Let's suggest we have 10,240 slots and reuse that. That is for block number 10,240.
00:03:34.500 - 00:04:14.750, Speaker A: The block number 210 thousand 240 takes the slot 10,240 and after that the block number 10,241 takes the first slot, takes the same slot that the first block took. And so it's kind of slot three. And that means that after the first 10,240 block were used the block proposal T will be minimized as storages are being reused.
00:04:14.750 - 00:04:52.700, Speaker A: Proposed block consists of metadata and list of transactions and metadata is specified according to the theoretical yellow paper. And what is interesting about that, that metadata is accessible by EVM by the Ethereum virtual machine that is accessible for anyone while the transaction list is not. And the transaction list will be executed on layer two only.
00:04:52.700 - 00:05:24.340, Speaker A: And that's the core idea of roll up. In fact, TECO client proposes a block using Tyco L one contract tyco client communicates with ethereum layer one, executes transaction, builds new states, updates the merkle trees on demand, shares the witness with the prover and can be run by anyone. An ethereum node determines the final block order on layer one.
00:05:24.340 - 00:05:54.430, Speaker A: That is, when the block is proposed by Taiko Klan, its parent hash is not specified, meaning that the final block order is fully up to the ethereum node. After block proposition we have block validation. This check is executed by takeoval contract and we have a set of formal rules that a proposed block should pass to become valid.
00:05:54.430 - 00:06:30.362, Speaker A: The validation rules for a block include the following so the first criteria the transaction list is RLP decodable into a list of transactions. RLP decodable is a standard for data transfer between nodes in a space efficient panel. Then criteria number two is that the number of transactions in the block is no larger than the maximum number of transactions in the table block minus one and this minus one.
00:06:30.362 - 00:06:58.530, Speaker A: This is minus the first transaction in the block, that is the NKL transaction and we will talk about it later. The criteria number three is that the sum of all transactions gas limit is no larger than a Taiko block's maximum gas limit. Besides the gas limit for this first reduction in the block, the anchor transaction then is the block is valid.
00:06:58.530 - 00:07:23.794, Speaker A: Teiko client downloads this proposed block and converts it into a real Taiko layer two block and it is appended to the Taika chain block list. In fact, when the block is proposed, it is not a real block, it's just a bundle of transactions with some metadata. And while it is checked to be valid, takeo client converting into a real takeo layer two block.
00:07:23.794 - 00:08:08.082, Speaker A: So when they say converting to a real takeo layer two block, it means that after being downloaded, the block is decoded into a list of transactions and tyco client validates each transaction and generates a trace lock for each transaction for the prover to use it as witness data. And valid transactions are typed through the layer two block as invalid transactions are dropped. And for transactions, validation rules include the following the transaction signature is valid, nouns is correct and the sender's balance is no less than the intrinsic gas.
00:08:08.082 - 00:08:35.780, Speaker A: Intrinsic gas is defined in the theorem yellow beta take a layer two block consists of anchoring transaction and just a list of transactions. And this anchoring transaction is always the first transaction in the block. And this anchorage transaction contains all necessary data that is not covered by the ZKE EVM itself.
00:08:35.780 - 00:09:11.150, Speaker A: So, while ZKE EVM covers signature validity proof for each transaction state proof that the member peri and the execution proof that is, given the right inputs, one will get the right outputs with very high probability. The anchorage reduction holds 256 hashes of the latest blocks that are not a part of Merkle tree. And there too chain ID a bit more details about valid and invalid transactions.
00:09:11.150 - 00:09:33.970, Speaker A: If a transaction is invalid, it doesn't make the block invalid, the invalid transaction is kept in the block. However, teico client pours an option to run an invalid transaction to generate a trace for proverbs. And furthermore, even an empty block is a valid block and still needs to be proven.
00:09:33.970 - 00:10:01.870, Speaker A: Final stage block verification. The prover generates zero knowledge proof and submits this proof directly to the terminal. But it submits it through the Taiku client and Taiku client provides the prover with the weakness data for zero knowledge proof generation.
00:10:01.870 - 00:10:37.350, Speaker A: There is no specific order for proof generation, so prover can submit approved for any block she likes. Before Bailey verified, the block should be checked for Bailey valid and its parent hash transaction should be verified. And right after that the block is immediately verified, that is, the proof is immediately generated and if the block is invalid, that is how it works today.
00:10:37.350 - 00:11:18.980, Speaker A: If the block is invalid, instead of converting it into a real tanko layer to block tenco, client creates a temporary block with the only transaction inside invalid block and the prover generates the valid proof for this temporary block. But with the next protocol upgrade, these will change and we won't have any temporary blocks anymore. And with the next protocol upgrade, approval will generate a proof that verifies a block is either valid or a block's transaction list is invalid.
00:11:18.980 - 00:11:24.900, Speaker A: So that's the short story of Tyco protocol.
00:11:28.520 - 00:11:42.256, Speaker B: All right everyone, welcome to this workshop. My name is David from Tyco. Today we're going to speed run build an Ethereum app which has some nice tech included.
00:11:42.256 - 00:11:59.264, Speaker B: So it has a Svelte kit app. The abis and contract addresses are automatically generated and fully typed with Wagme. It has a web three modal connect button using Wagme core and it has foundry configured as well.
00:11:59.264 - 00:12:18.070, Speaker B: So the whole project is a mono repo set up with Pnpm and it's configured for it to be easy to work on any layer two as well. So let's get right into it. To get to this repo, you can just scan this QR code and it should take you there.
00:12:18.070 - 00:12:39.150, Speaker B: Otherwise the repo link is here. GitHub.com this thing, click this blue button for deploy, connect your GitHub account and create some repository name to the app.
00:12:39.150 - 00:12:49.810, Speaker B: You need to set one environment variable. You can just get this from wallet connect. This is for the connect button.
00:12:49.810 - 00:13:09.140, Speaker B: You need this project ID we've added here. And after clicking deploy, you should have an app that's fully functional and it'll be deployed. So yeah, let's take a look at this repo so we can work on it locally.
00:13:09.140 - 00:13:36.652, Speaker B: So first thing we need to do is clone the repo. So I'll just clone it, then we need to CD into it, then we need to do this forge install command. Then we need to run this setup script.
00:13:36.652 - 00:13:53.764, Speaker B: This will just copy the environment variables and install node dependencies. Then we need to set two environment files or two environment variables, the mnemonic phrase and the web through Metal Project ID. So you can generate a mnemonic phrase here.
00:13:53.764 - 00:14:08.920, Speaker B: It's also inside of the environment variables, which I'll just open right now. Yeah, you can see the link right here. So, yeah, you can just generate some mnemonic.
00:14:08.920 - 00:14:24.572, Speaker B: It'll create a string of some words that map to wallet addresses. I already have one, and yeah, I'll just show it. I don't really care.
00:14:24.572 - 00:14:32.480, Speaker B: It only has a little bit of test on you. Okay, so copied that. I'll use this mnemonic.
00:14:32.480 - 00:14:41.430, Speaker B: Just share the ETH. If you take it, I'll get the wallet connect ID. I'll put it right here.
00:14:41.430 - 00:14:55.280, Speaker B: All right, cool. Yeah, that's the full setup. Just setting those two environment variables.
00:14:55.280 - 00:15:04.430, Speaker B: And now we can start the local development environment. So it says we need three development windows, and you need to make sure to source your environment. So I'll go ahead and do that.
00:15:04.430 - 00:15:11.500, Speaker B: Let's see here. One, two, three. I'll source the environment variables.
00:15:11.500 - 00:15:28.396, Speaker B: There's two environment files, one for each for Foundry, one for the front end. Okay, cool. So these two windows, the first one will start, and all these commands are just available right here.
00:15:28.396 - 00:15:40.176, Speaker B: I just know them, so I won't refer to it. But first we'll start a local ethereum node, or local ethereum chain, rather. So this is anvil.
00:15:40.176 - 00:15:53.400, Speaker B: It's supported by foundry. And now I started this anvil chain locally with these ten accounts. And these ten accounts are all populated with ETH, and these accounts were derived from that mnemonic that I passed in.
00:15:53.400 - 00:16:28.228, Speaker B: So what you can do is you can take any of these accounts, and you can just take the private key, and you can just go to MetaMask, and you can import the private key, so you can use it on your front end. All right, so after starting the local anvil chain, we can start the web app, and then after that, let's just see what happens first. I think it might not work or hasn't errored it'll have an error if I click that.
00:16:28.228 - 00:16:37.610, Speaker B: Okay, cool. So we need to deploy a contract to this chain that we started, because it doesn't have one deployed yet. So we have a script for that.
00:16:37.610 - 00:16:51.084, Speaker B: It's just like so. And now if you read a message, I need to connect to Foundry network. So now if we read a message, it says hello, world, right here.
00:16:51.084 - 00:17:17.430, Speaker B: And if I actually open up that contract right here, and I change it to hello, world asdf blah, if I deploy this new contract and I read the message, you'll see it's automatically updated. So it's not just the contract. Like, all of the abis and types ways to interact with the contract on the front end are automatically generated as well.
00:17:17.430 - 00:17:29.832, Speaker B: So that works with this wagme generate command. So let's see here. Yeah.
00:17:29.832 - 00:17:34.724, Speaker B: So we have a contract. We can interact with it. We can write a new message to this contract.
00:17:34.724 - 00:17:42.716, Speaker B: It's just a dummy contract that has a message, and you can change the message. Now it gets updated to this new message. Yeah.
00:17:42.716 - 00:17:55.730, Speaker B: So that's how you deploy smart contracts in your local chain. You connect to that local chain through your front end, and you automatically have all of your APIs and types. No imports or copy pasting needed.
00:17:55.730 - 00:18:17.092, Speaker B: That's all being done in this Wagme config TS file, where we declare a deployment, this food deployment. And we just pick up the contract address from the logs of deploying the contract. So let's try to see a little bit more about how this flow works by just creating another contract.
00:18:17.092 - 00:18:22.136, Speaker B: So I'll go to this contracts folder in the monorepo. I'll create it. This will just be called bar.
00:18:22.136 - 00:18:38.284, Speaker B: Sold. It's going to be like exactly the same as Food Sol, except I'll change the message to just say Bar and yeah, let's write a unit test for it as well, just to show how that works. It'll also be the same as, like, this unit test from Foo.
00:18:38.284 - 00:18:50.070, Speaker B: We'll put it in here. We'll just rename foo to bar. Yeah, that's about right.
00:18:50.070 - 00:19:20.188, Speaker B: Uncomment this bar. Let's run a test to see if this actually compiles says, what is source bar sol? Probably because I didn't name this contract correctly. So now if we run the test assert failed, it says the message should be hello world.
00:19:20.188 - 00:19:33.052, Speaker B: But we're expecting it to be Bar. So we will just go ahead and change that and then now the test should pass. Okay, test is passed.
00:19:33.052 - 00:19:38.480, Speaker B: So we just wrote a unit test. We just wrote a smart contract. Let's deploy this smart contract.
00:19:38.480 - 00:19:54.512, Speaker B: So what we'll do is we'll do this same. We'll have to look at how this deploy works. So if you look at the command, you'll see we run a script called Deploy, and we deploy that to an RPC URL, which is Foundry.
00:19:54.512 - 00:20:11.580, Speaker B: And then we generate the types so we can easily deploy to other chains, too. And maybe we'll show that. But if I go in and I look at this script, this deploy script, I'll deploy another contract now, which is the Bar contract that we just created.
00:20:11.580 - 00:20:26.220, Speaker B: And it's going to look very similar, obviously. So we got to deploy Bar. Basically, the deployer of this smart contract is the first key in the Mnemonic that you generated.
00:20:26.220 - 00:20:39.424, Speaker B: It'll just use the artificial ETH inside of the local Anvil chain to deploy the contract. So here, this is just straight, solidity. We'll just create a new Bar smart contract.
00:20:39.424 - 00:20:52.440, Speaker B: And yeah, let's deploy this. So now this will deploy both of them again, says, what the heck is Bar? Okay, it's this thing. Okay, cool.
00:20:52.440 - 00:21:00.728, Speaker B: All right. So now they've both been generated. And the last thing we need to do is inside of our Wagme config, which is inside of the app folder of the monorepo.
00:21:00.728 - 00:21:11.890, Speaker B: We need to declare that deployment for Bar. So I will just create that. So we're going to call it Bar.
00:21:11.890 - 00:21:30.980, Speaker B: The contract address for this chain is going to be the Foundry Chain ID. And we just need to import this JSON file, which is an artifact of the log run latest JSON. Actually the way this is configured is like now there are two.
00:21:30.980 - 00:21:43.236, Speaker B: If you look at the broadcast deploy logs in this run latest JSON, you'll see that two were deployed. This Foo contract and this bar one. The bar one is the second transaction.
00:21:43.236 - 00:22:04.560, Speaker B: So it's a little bit of a finicky set up for this. You don't have to do it this way, but I think it's easier if you're just continually deploying your contracts and testing updates. But what we can do is we have this bar JSON now and we can take that as the second transaction from the logs.
00:22:04.560 - 00:22:28.056, Speaker B: And basically anytime you redeploy a contract, this run latest JSON will get updated. It'll pull the contract address so that on your front end you're using the new contract. If you don't want to do it this way, then after you deploy, you can just see what the contract address is and you can just directly copy and paste that in here, which is how the Wagme documentation shows it.
00:22:28.056 - 00:22:34.920, Speaker B: I just think this is a little bit more of a reactive way. Okay, cool. So we deploy the smart contract.
00:22:34.920 - 00:22:58.130, Speaker B: We might need to generate the types again, I'm not sure, but we'll just do it anyways because we just changed the Swag me config and now we should be able to use this bar contract. Okay, so how do we use that? Let's go into our app folder. Let's find the component for this first page that we saw.
00:22:58.130 - 00:23:12.288, Speaker B: And inside this component, you'll see, we obviously get the foo abi, the foo address. Let's do the same thing, but we'll get the bar abi. And as you can see and as we've said, it's just all automatically generated.
00:23:12.288 - 00:23:30.430, Speaker B: So now I have the bar abi and the bar address. So what I can do is how do I want to do the bar? I won't duplicate it. I'll just use the bar abi and the bar address.
00:23:30.430 - 00:23:43.616, Speaker B: So I'll change this to bar abi. Change this to bar address. I think that's everything foo is only up here.
00:23:43.616 - 00:23:53.876, Speaker B: Okay, so now we're going to use the bar contract in our front end. So the way that we can test that is Bar was initialized with this thing. Bar right here.
00:23:53.876 - 00:23:57.012, Speaker B: Right. So will it say Bar? Yeah, it says Bar. Okay, cool.
00:23:57.012 - 00:24:11.880, Speaker B: So now we can update this smart contract and maybe okay, cool. And now we just updated the state of this bar contract that we just deployed. So just to hammer it home, we can literally just update this to something else.
00:24:11.880 - 00:24:18.132, Speaker B: We can go ahead, go down here. We can deploy the contract. It'll know what the new address is of the deployed contract.
00:24:18.132 - 00:24:26.204, Speaker B: All of the abis and everything will be typed. And now if we read the contract, it says this crazy thing that we just put in there. Okay, so we wrote a unit test.
00:24:26.204 - 00:24:39.388, Speaker B: We showed how you can deploy to your local chain. Now, if you want to deploy to another change, like another chain, like let's say Tyco, for example, I think I have Tyco set here. Yeah, we have this hackathon RPC.
00:24:39.388 - 00:24:53.270, Speaker B: So if I want to just deploy this to Tyco, I literally just change the Tyco. Or I could change this to Optimism, or it could change this to scroll, or it could change it to Base. You get the point.
00:24:53.270 - 00:25:05.028, Speaker B: It's just easy to deploy essentially anywhere. Okay. Tyco doesn't have this EIP 1559 enabled, so I need to do send the transaction in legacy mode.
00:25:05.028 - 00:25:15.260, Speaker B: I think I'm supposed to put this over here. This is just deploying the bar contract to Tyco. All right.
00:25:15.260 - 00:25:25.452, Speaker B: It's not going to be as fast as the local chain, but yeah, it'll deploy it. Okay. So now just for full coverage, we showed how we can write a unit test and write a smart contract.
00:25:25.452 - 00:25:44.010, Speaker B: How we can add that smart contract into our deployment script by just initializing it like this and how our front end automatically knows the configuration to interact with that smart contract. And we updated that. Let's see here.
00:25:44.010 - 00:25:51.752, Speaker B: Is there anything else to talk about? It is supposed to be a speed run. All right. Yeah.
00:25:51.752 - 00:26:07.544, Speaker B: So, yeah, that's the basic directory structure for Foundry. It's just script source and test. If we look inside of the Packages folder, like I said, the main thing is that Wagme config file, which is kind of like declares your smart contract configuration.
00:26:07.544 - 00:26:17.456, Speaker B: So your front end can use it. Yeah, it's pretty straightforward. I mean, that's about it.
00:26:17.456 - 00:26:35.604, Speaker B: You can just start building smart contracts and start consuming them in your front end and yeah, that's about it. Spelt has very good documentation, so I won't go into how to build on it, but it's very simple, so I don't think you'll have trouble with it. And we have these stores that you can use.
00:26:35.604 - 00:26:55.150, Speaker B: So if you need to access the Wagme client or a provider or anything like that within any kind of file, you can just go in and you can just do like an import, let's say providers from stores here. Yeah. And then you can access it.
00:26:55.150 - 00:27:09.920, Speaker B: You can access that store. Like, maybe you can do something like this and then you can do it. I think you can access this store by chain ID.
00:27:09.920 - 00:27:22.870, Speaker B: And then let's do Get balance. Do we need a provided address? All right, yeah, let's do balance of this address.
00:27:26.120 - 00:27:26.980, Speaker A: Math.
00:27:31.950 - 00:27:35.530, Speaker B: We need to wait for it. Type s contract. Get Balance.
00:27:35.530 - 00:28:00.612, Speaker B: Yeah. This is an async function. Okay, so let's just do like Async function, get balance here and then we'll just call this the main point is that you can just access this provider from like anywhere, but we'll we'll do it anyways.
00:28:00.612 - 00:28:14.830, Speaker B: Confalance is equal to that balance and take a two string. I don't know if it does. Okay.
00:28:14.830 - 00:28:33.028, Speaker B: And then on mount of the component, shout out chat GPT though, maybe doesn't know what on mount is. Oh yeah, I think this is imported from the wrong place. It's probably just supposed to be from like there maybe.
00:28:33.028 - 00:28:35.700, Speaker B: Okay, cool. And here's our balance. Okay.
00:28:35.700 - 00:28:54.596, Speaker B: Anyway, so you can use the stores to access Global state. Let's talk about the next part of this app, which is this Signal Service tab over here. So basically Tyco has some really elegant properties just because it's Ethereum equivalent.
00:28:54.596 - 00:29:08.524, Speaker B: So one of those is the ability to build a bridge on top of the protocol. So the bridge is built on top of this very simple signal service. But let's just show how it works and I think it'll make sense.
00:29:08.524 - 00:29:23.076, Speaker B: So step one, it says here, connect to Sepolia network. And then what we can do is we can store some signal on Sepolia. So that's just writing some data to a smart contract called Signal Service that we have deployed on Sepolia and anybody can use that.
00:29:23.076 - 00:30:02.584, Speaker B: So I'll just send this signal from my address and basically after I send that signal, the thing is Tyco and the base chain, like Ethereum or whatever, keep track of the respective block hashes. And because block hashes look the same on Tyco, because Tyco's blocks look the same as Ethereum blocks, it supports Merkel proofs. So what we can do, essentially, is we sent a signal to this base chain Sepolia and now we can ask some Sepolia node to generate a Merkel proof to just prove to me that I sent this message somewhere.
00:30:02.584 - 00:30:21.648, Speaker B: Inside of the state, or I stored this inside of the state. And I can take that proof and I can verify it on Tyco. I can actually make a call to Tyco verify that Merkel proof and it can check if that message was received on the base chain just by checking its hatches because it keeps track of the hashes of the other chain.
00:30:21.648 - 00:30:35.300, Speaker B: So this is a signal that I haven't sent before, so it'll say signal received is false. And here is one that I have sent before, so it will say signal received is true. And yeah, you'll have to wait about like five minutes.
00:30:35.300 - 00:31:00.716, Speaker B: It'll take five minutes before this one returns true because the time in which we're deriving blocks under the L two is configured at like five minutes. Currently it's a configurable variable, but we just set it that way so we don't burn through too much Sepolia ETH. And yeah, so we're really hoping you can build on top of this.
00:31:00.716 - 00:31:20.250, Speaker B: You could actually build a bridge yourself on top of the Signal Service. I think it's a really cool solution for cross chain messaging, and there are some cool app ideas here, especially Bridges. Okay.
00:31:20.250 - 00:31:43.900, Speaker B: Yeah, so we went through the application, we showed how easy it is to deploy contracts and work with them, and yeah, that's really it. That's really that simple, I guess. And, yeah, if you need any help at all, please just reach out to us on the discord.
00:31:43.900 - 00:31:53.110, Speaker B: We'll definitely be happy to help with anything that you're trying to build. You can reach out to me directly. My name's Steve, as I was saying, if you want as well.
00:31:53.110 - 00:32:05.650, Speaker B: And yeah, happy hacks. I'm looking forward to some cool projects here's. The Repo URL again, and thank you very much.
