00:00:07.770 - 00:00:24.362, Speaker A: Hello everyone and welcome to the Compound Grants Developer Workshop for ETH Global Waterloo 2023. My name is Adam Bavosa and I am the developer relations lead at Compound Labs. You can find me on Twitter at adam Bavosa and also in Discord.
00:00:24.362 - 00:00:46.700, Speaker A: I'm ad them be I'm here to help out with protocol related development projects. Whether you're building something in Solidity or JavaScript, you are integrating the Compound Protocol or building on top of it, or developing an upgrade for community governance of the protocol. I can help you out with your code and also brainstorming your idea.
00:00:46.700 - 00:01:03.678, Speaker A: So what we're going to go over in this workshop is the hackathon bounties for Compound Grants. I'll tell you a little bit about the Compound Protocol in case this is the first time you're hearing about it. I'll highlight key differences between Compound V two and Compound V three.
00:01:03.678 - 00:01:27.000, Speaker A: Compound V Three came out in summer of last year. I'll go over the governance system for Protocol community Governance and also share some developer resources so you can get started working on your project immediately. So the Compound Grant's Bounty prize for this year is $5,000 USD to the best integration of Compound Three.
00:01:27.000 - 00:01:48.266, Speaker A: The project must interact with smart contracts or JSON RPC with any instance of the V Three protocol or be a supportive project that is specifically created for the compound community's use. So, a little bit about compound. In case you're not familiar, I work at Compound Labs.
00:01:48.266 - 00:02:13.746, Speaker A: We are the authors of the Compound Protocol, a protocol made up of several smart contracts running on the Ethereum main net since 2018. Our mission is to create efficient algorithmic money markets. And what gets me excited to work in the DFI space is that we author and continue to steward decentralized, free and open crypto tools for everyone with an Internet connection, including the banked, the underbanked and the unbanked.
00:02:13.746 - 00:02:34.720, Speaker A: This is an incredibly huge amount of potential market to serve globally. If you think about it, anyone on Earth with a smartphone and an Internet connection can use DFI and can use compound. Historically, we've seen interest rates for suppliers as high as 15% APY on USDC, as well as all the other supported assets that I'll share in a little bit.
00:02:34.720 - 00:02:56.520, Speaker A: I love that what we're doing is different from TradFi because DeFi systems like the Compound Protocol are transparent and voluntary systems with public ledgers where code is law. With DeFi, you instead get decentralization and transparency, unlike centralized banking and financial systems. That's what gets me excited to work in DeFi and also in the Ethereum space.
00:02:56.520 - 00:03:12.650, Speaker A: What is the compound protocol? It is, simply put, crypto asset money markets. We refer to it as the Compound Protocol. It runs on Ethereum and also some other chains, some other L two S like Polygon and Arbitrum.
00:03:12.650 - 00:03:34.114, Speaker A: It is decentralized, which I will explain shortly in the Governance section. The main use case is that it allows users to earn interest on their cryptocurrencies or permissionlessly borrow other cryptocurrencies. So instead of an asset like Ethereum or USDC sitting idle in your wallet, you can supply it to Compound and earn a varying interest rate.
00:03:34.114 - 00:03:52.470, Speaker A: Users can supply crypto collateral and borrow a different crypto asset against their collateral. The interest that suppliers earn is driven by the interest that the borrowers pay. Those are the two basic uses of the Protocol for everyone earn interest on crypto or borrow other crypto assets.
00:03:52.470 - 00:04:14.480, Speaker A: And you can do that completely permissionlessly. And no single entity controls any of those assets that are stored in smart contracts, which is controlled by community governance. At this time, compound can only support crypto assets that are tokenized on Ethereum or other EVM chains as ERC Twenty S.
00:04:14.480 - 00:04:35.570, Speaker A: And it allows suppliers to earn a variable interest rate on their assets. And an individual that uses adapt like the ones listed on the compound homepage or their own code that they write, can use every feature of the Protocol. Developers can build their own apps that use the Protocol as interest earning infrastructure.
00:04:35.570 - 00:05:03.070, Speaker A: Users or organizations can use interfaces to earn interest to borrow assets or participate in community governance. So use cases we see are crypto wallet applications using the Protocol to offer interest earning for their users. Also, any business that holds assets for a period of time, they can use the Protocol to supply and earn interest for a period to create some income, instead of letting those assets sit idle.
00:05:03.070 - 00:05:26.098, Speaker A: And here is an example of supply operation. Let's say you have one of the many interface applications for the Protocol and you want to supply assets to compound. When a supplier supplies, they get a fixed amount of C tokens, which you can think of like a code check for your underlying assets.
00:05:26.098 - 00:05:46.090, Speaker A: And as time progresses, more underlying can be redeemed for those same amount of C tokens in compound V two. So as time passes, interest accrues to the C token holder in compound V three. C tokens are only minted for supplying the base asset, not for collateral.
00:05:46.090 - 00:06:04.526, Speaker A: And those V Three C tokens are one to one rebasing, so the balance will increase in your wallet as the supplier earn interest. So there's more differences between v two and v three, which I'll share later. Assets are stored in smart contracts that no individual controls.
00:06:04.526 - 00:06:18.946, Speaker A: There is an onchain governance system that will be covered later. C tokens are redeemable at any time. Users can supply for as little as one Ethereum block and interest accrues every ethereum block, which is about 12 seconds.
00:06:18.946 - 00:06:25.682, Speaker A: Nowadays. This enables on demand supplying and redeeming from the Protocol. No need to wait for a lockup period.
00:06:25.682 - 00:06:37.606, Speaker A: You can earn interest for supplying to the Protocol for even just 1 minute. So the other key feature of Compound is borrowing. The Protocol enables over collateralized borrowing of assets.
00:06:37.606 - 00:06:52.646, Speaker A: So a user must supply collateral before they can borrow. And they can only borrow up to a certain amount of the USD value of their collateral. So their total value of their collateral is always worth more than their total borrow relative to USD.
00:06:52.646 - 00:07:17.142, Speaker A: So an example would be that a user supplies collateral like WBTC or ETH, and then they can borrow a smaller value of an asset like Dai or USDC and keep it such that their account is over collateralized. So the limit of the borrow depends on the collateral asset. There's a percentage called the collateral factor, which is set for each individual collateral token type.
00:07:17.142 - 00:07:39.498, Speaker A: ETH and WBTC have different collateral factors, and those factors are chosen by the community members and are selected based on perceived risk of the value fluctuation. In order to borrow, a user must supply a supported collateral asset, and they can then borrow any asset supported by the Protocol. And the borrowed asset will subsequently be held in the user's wallet with no strings attached.
00:07:39.498 - 00:07:50.802, Speaker A: In V two, borrowers earn interest on their supplied asset just like a supplier does. However, their borrowed asset accrues interest as well. This is not exactly the same in V three.
00:07:50.802 - 00:08:11.702, Speaker A: I'll cover it more in depth soon. If an account becomes under collateralized, like when the USD value of the collateral goes down, or too much borrower interest accrues the user c tokens of collateral can be clawed back to the protocol. When a liquidator performs a liquidation on the account, supplying only is safer than borrowing.
00:08:11.702 - 00:08:24.894, Speaker A: You can't get liquidated if you only supply, and there is much less risk involved. When a user supplies and does not borrow, liquidators keep the Protocol safe and collateralized. They are incentivized to do so.
00:08:24.894 - 00:08:38.574, Speaker A: So borrowers that become under collateralized are subject to liquidation of their account. They can lose some or all of their collateral. And due to the autonomous nature of the protocol, the liquidation system is much harsher than in traditional finance.
00:08:38.574 - 00:08:54.146, Speaker A: There's no negotiating, there are no delinquent repayments. So compound v two has 18 supported assets that can be supplied to earn interest, or they can be borrowed. Not all of them can be used as collateral.
00:08:54.146 - 00:09:09.142, Speaker A: Some assets have a 0% collateral factor, so you can't use them as collateral to borrow a different asset. And we'll go over V three as well. This version of the protocol is more gas efficient and capital efficient.
00:09:09.142 - 00:09:29.230, Speaker A: It streamlines the most popular use case of V two, which is to supply a volatilely priced asset like WBTC and borrow a stable priced asset like USDC. This version has additional safety for liquidations, a higher threshold for the same collateral factor. One asset can earn interest or be borrowed per deployment.
00:09:29.230 - 00:09:40.582, Speaker A: So this asset is called the base asset. It makes opening positions in V three have less stacked risk than V two. Currently, there are two deployments of compound three.
00:09:40.582 - 00:09:53.820, Speaker A: On ethereum mainnet. There's USDC and Weath. So you can earn interest on USDC or Weath if you use one of those deployments of Compound V Three.
00:09:53.820 - 00:10:03.630, Speaker A: There of course, are other deployments on other chains. There's polygon and Arbitrum. They both have their own USDC deployment.
00:10:03.630 - 00:10:23.006, Speaker A: So the key differences between V Two and V Three are that V Three has less risk, less gassiness, and the V three protocol can be deployed anywhere that solidity is supported. In V two you can borrow any supported asset. But in V three you can only borrow the single base asset per deployment.
00:10:23.006 - 00:10:26.174, Speaker A: So compound v. Two and v. Three coexist.
00:10:26.174 - 00:10:39.320, Speaker A: Compound V Two is not going anywhere. There is no deprecation schedule. Because the use case of V two is somewhat different from V Three, users are still using it in high volumes on Ethereum main net.
00:10:39.320 - 00:10:57.866, Speaker A: So here's a list of differences between Compound V two and Compound V three. The C token system for V Two is a little bit more confusing. The assets that you supply, you get about 50 to one ratio of C tokens return in return for minting.
00:10:57.866 - 00:11:16.350, Speaker A: And the redeemable amount of underlying that comes when you redeem a C token in V two is always changing. So as the block height goes up, you get more underlying for your same C token. So that's the mechanism in which interest accrues to the supplier.
00:11:16.350 - 00:11:29.350, Speaker A: And in Compound V three, the C tokens are a little different. They are one to one and rebasing. So if you supply five USDC, you get five C USDC V three in return and that amount will go up in your wallet.
00:11:29.350 - 00:11:45.274, Speaker A: So in combat V two you can borrow any supported asset like I showed on the screen earlier. And in V three you can only borrow the single base asset per deployment. So currently there are two different kinds of deployments deployed across three chains.
00:11:45.274 - 00:11:55.982, Speaker A: There is Weath and USDC. So you can only borrow Weath or USDC. Compound V Two is a single system with many assets.
00:11:55.982 - 00:12:10.822, Speaker A: It's a monolith running on Ethereum, Mainet only. And Compound V Three has a single asset focus per deployment and can be deployed on any EVM chain. The Max borrow and liquidation are the same in V two.
00:12:10.822 - 00:12:32.522, Speaker A: So if you borrow the maximum amount allowed by the collateral you supplied to the protocol, you will get liquidated in the next Ethereum block, which has left some users unhappy because they immediately got liquidated and they didn't realize that they shouldn't have borrowed that much. Compound B Three has a little bit safer mechanism built in. The maximum borrow and the liquidation point are separate.
00:12:32.522 - 00:12:49.230, Speaker A: So if you borrow the maximum amount allowed by the collateral you supplied, you won't get liquidated immediately. There's like no new borrows period in between those two points. So there's some time to either top off your account or repay your borrow before getting liquidated.
00:12:49.230 - 00:13:08.210, Speaker A: So in Compound V two you earn interest on any supported collateral asset that is supplied. In V three, there is no earning of interest on the supplied collateral you can only earn interest on the base asset. So currently you can only earn interest on USDC or Weath.
00:13:08.210 - 00:13:28.602, Speaker A: In V Two, some assets are not valid collateral, but they can be supplied to earn interest. V Two has an integrated comp distribution into the protocol contract code for the comptroller, which is also in charge of supplying and borrowing as well. In V Three this is more encapsulated into a special contract called the rewards contract.
00:13:28.602 - 00:13:44.514, Speaker A: So any reward token can be added to compound V Three. And in compound V Two there is one account controller, the self. So only zero x ABC can control zero x ABC's position in compound V Two.
00:13:44.514 - 00:14:05.094, Speaker A: But in V Three there is a system for allowing account managers. So say you have a special contract, that is a team contract. It could be controlled by other users outside of it, like a list of allowed managers that the account needs to approve, or can revoke privileges for manager.
00:14:05.094 - 00:14:19.886, Speaker A: So they can do things like supply, borrow or transfer within the protocol as an allowed manager. Let's go over the compound governance system. It was the decentralization of the protocol which occurred in 2020.
00:14:19.886 - 00:14:38.434, Speaker A: The contracts for compound governance are available on GitHub in the Compound Finance Organization, and governance is controlled by the comp token holders. And community proposals are what manage upgrades of the protocol. The Comp token is a governance token.
00:14:38.434 - 00:14:59.302, Speaker A: It can be used to vote yes or no on proposals that are created by community members. And if you are a community member that has more than 25,000 comp delegated to your address, you can create proposals. And those proposals are literal code changes to the solidity code or the parameters for the contracts.
00:14:59.302 - 00:15:11.358, Speaker A: And anyone can create those if they have the delegation. And anyone can vote if they have comp tokens. So here's the governance proposal process.
00:15:11.358 - 00:15:55.310, Speaker A: There's a two day review period once a user creates a proposal so other community members can investigate this proposal, make sure it's safe, make sure it does exactly what it's saying it's doing, and one of the consequences once it is executed. Like other apps that depend on the protocol, what would they have to change to support this new protocol code change? There is a three day voting period where comp token delegates can vote yes or no on the proposal. If there is a vote that exceeds the quorum of 400,000 votes and also is in favor instead of no vote, it will succeed.
00:15:55.310 - 00:16:16.894, Speaker A: There'll be a two day lockup period where apps that depend on compound can prepare for this upcoming change that will be executed in two days. So then the proposal is queued and executed by anyone in the community. You can hit those governor smart contracts yourself if you want to be the one that queues or executes that's a little bit about governance.
00:16:16.894 - 00:16:25.170, Speaker A: Here are some developer resources that you can use to get started working on your project. Right away. The developer documentation is at docs Compound Finance.
00:16:25.170 - 00:16:43.122, Speaker A: You can find solidity smart contract documentation there. You can find examples of JSON RPC calls in Ethersjs, and you can also find SDK documentation there as well. If you have questions, you can always come into the Compound Community Discord.
00:16:43.122 - 00:16:54.320, Speaker A: All of the engineers that work on Compound are in that discord. They can help you out with your protocol related development projects. You can go to Compound Finance Discord to get that discord link.
00:16:54.320 - 00:17:06.866, Speaker A: The grants program for Compound is at questbook app. Questbook is managing the grants program for the compound community. You could apply for a grant at any time to build something on Compound.
00:17:06.866 - 00:17:19.090, Speaker A: Questbook has given out over $2 million worth of grants to community members so far. You can head over there and apply for a grant immediately. GitHub is a great developer resource.
00:17:19.090 - 00:17:34.926, Speaker A: We have two organizations compound developers and compound finance. You can find protocol code and also examples for building your own application in those GitHub organizations. Here is a repository for the developer workshop that I'm going to go over today.
00:17:34.926 - 00:17:55.300, Speaker A: So you can get out your phones and scan this QR code, or you can just visit that URL on your laptop and you could see all the code that I'm going to walk through in this presentation. So that's the portion I'm going to go through next. Again, if you want to apply for a grant, remember you can go to Questbook app and apply for a Compound Community grant today.
00:17:55.300 - 00:18:17.610, Speaker A: If you still haven't come up with an idea for your hackathon project, we can help you out with this blog post. Please scan this QR code and take a look at our hackathon project ideas that we have ready for you to go and help you get your Bouncy prize in this hackathon. Next, I'm going to get into some code.
00:18:17.610 - 00:18:48.476, Speaker A: I'm going to show you how to build an app on top of Compound that you can use as a starter point to start building your application for the hackathon bounties today, or as a starting point for your project that you'll build on Compound and you'll get a grant for it using Compound Grants. All right, so I've got a repository open here where I have some files missing. I'm going to write them alongside with you today in this workshop.
00:18:48.476 - 00:19:07.560, Speaker A: If you go over to the repository on GitHub, these files are already filled in and that project is fully working. All you need to do is NPM install and add your provider URL in there. And that project should work if you follow the instructions in the README to get it running.
00:19:07.560 - 00:19:39.852, Speaker A: And in a few terminal line commands, I'm going to walk through installing dependencies and also writing some of the important files in there so you can get started with your hackathon project right away. All right, to install the dependencies, we're going to use NPM Install and we're going to install Ethers and we're going to install a specific version which is 5.7.2. We're also going to install exprs JS and Hard Hat.
00:19:39.852 - 00:20:01.610, Speaker A: We're going to run an exprs Http server to serve our HTML, CSS and JavaScript in a front end DAP. And we're going to use Hard Hat to fork Ethereum mainnet to our local machine so we can test out our application and make sure it works. We'll be able to do that with our localhost MetaMask account.
00:20:01.610 - 00:20:22.480, Speaker A: So once I've got my dependencies installed, I'm going to go over to the package JSON file and I'm going to add a Start script which is just node server JS. We're going to run a script called Server and that's going to be our exprs server. And also where we fork ethereum mainnet using hard hat.
00:20:22.480 - 00:20:45.300, Speaker A: And we're also going to seed our localhost account with some ERC 20 tokens so we can use them in our interface to supply and borrow from compound. So here is my hard hat config. I've got some environment variables here where I store my provider URL as well as my development Ethereum mnemonic.
00:20:45.300 - 00:21:11.436, Speaker A: So the accounts that appear in my Hard Hat localhost node will be using the accounts for that mnemonic and we'll be forking Ethereum mainnet using my provider URL which I use in Fura. We have some settings for our Hard Hat network like a chain ID of one to match mainnet. And I also got rid of some gas things that might cause issues in our test environment.
00:21:11.436 - 00:21:41.112, Speaker A: And I forked our accounts for our devnemonic so they will each have 10,000 Ether in them that we can use on our test localhost node. Okay, so I'm going to open server JS and I'm going to import requirements like Ethersjs. I'm going to import Hard Hat as well as the task to create a Hard Hat server which will fork mainnet and run a local node for us.
00:21:41.112 - 00:21:53.580, Speaker A: And I'm going to initialize an exprs app as well. This is an HTP server running on my local machine. We'll be able to access our front end assets from this web server.
00:21:53.580 - 00:22:12.880, Speaker A: I'm going to make it so everything in the public folder where we have our HTML, CSS and JavaScript that will be loaded in our web browser. And I'm going to listen on port 3008. We're going to log that to the console so we can see that the app is running when we run it in our terminal.
00:22:12.880 - 00:22:57.360, Speaker A: Later, I'm going to create a fork of mainnet using Hard Hat's task node create server and we're going to run that on port 85 45 and that way our MetaMask will know to connect there. When I set the localhost network in there, I'm going to seed my first localhost account with some ERC 20 tokens. So I'm writing a method later called Seed localhost dev account and I'm going to pass the asset address, the source address to take tokens from the destination which will be my first account and the amount of tokens without any decimals we'll do an integer.
00:22:57.360 - 00:23:13.012, Speaker A: So I'm going to write that method for seeding the localhost dev account. I need to run a specific node RPC command that is special for a hard hat node. You can't do this with geth on your real Ethereum node.
00:23:13.012 - 00:23:33.500, Speaker A: What we're doing is we're going to impersonate account so that way we can act as any Ethereum account. And I'm going to move assets from addresses to my address, like some liquidity pools. So I can start out with some seed tokens like some WBTC, some Weath and some USDC.
00:23:33.500 - 00:23:52.950, Speaker A: So I'm going to get the signer for that for Ethersjs. And I'm going to point to my localhost node and I'm going to create a token to transfer assets. So I'm going to act as that signer and transfer the tokens to my address.
00:23:52.950 - 00:24:10.568, Speaker A: So now that this method is written, we can insert some addresses for the seed localhost dev account call. I'm going to put the weath address. There is some accidentally sent weath in there usually.
00:24:10.568 - 00:24:29.436, Speaker A: So I'm going to take some of that for my local host account and I'm going to use the compound v two pools. We call them C token contracts for compound v two. I'm going to take assets from there by impersonating those C tokens.
00:24:29.436 - 00:24:46.340, Speaker A: And I'll insert those addresses here and I'll put in the amounts that I'd like to take. So now when I run this script, it will boot up my exprs server on my local machine running at port 3008. So we can serve our HTML, CSS and JavaScript.
00:24:46.340 - 00:25:14.940, Speaker A: And after it sets up the exprs server, it runs a fork of mainnet using hard hat on port 85 45 and it seeds my account using the method we just wrote to give us some Weath, WBTC and USDC. Once that's successfully run, we can continue to the next part where we're going to build this application. We see it's called Interest rate app.
00:25:14.940 - 00:25:32.950, Speaker A: It is some simple HTML, CSS and JavaScript. No frameworks besides Ethers JS and these files are already in the repository on GitHub. But I'm going to write them here in this workshop so you can see what it's like to write them while you're working on your hackathon project.
00:25:32.950 - 00:25:41.424, Speaker A: So I'm going to go into my public folder and create a new file. I'm going to call it index. HTML this is where the browser will navigate.
00:25:41.424 - 00:26:01.864, Speaker A: When I go to localhost port 3008, I'm going to use the Sublime text autocomplete to fill in the head tag and the HTML and body tag, stuff like that. First thing I'm going to do is create an H one where I will put Interest Rate app like you saw in the screenshot from earlier. I'm going to create a button called Enable Ethereum.
00:26:01.864 - 00:26:21.728, Speaker A: And what that does is when a user clicks it, it's going to make a request to the Ethereum object in the browser so that the user can connect their MetaMask wallet. Next, I'm going to create a select box so you can select the instance of compound three on Ethereum mainnet. There are two instances of compound three.
00:26:21.728 - 00:26:42.680, Speaker A: We've got cUSDC v three and C week v three. So I'm going to have the user be able to select the instance there and then they can supply and borrow using the interface. Next, I'm going to create that little model box and I'm going to have a place where you can supply or borrow the base asset.
00:26:42.680 - 00:27:15.460, Speaker A: We're going to display the supply apr and the borrow apr for the selected compound three instance and we're going to put an input box as well as a button to supply or withdraw. Now in compound V three, you supply to supply or repay a borrow and you withdraw to withdraw your supply or to borrow. Okay, I'm going to run my web server so we can see what our HTML looks like in the browser.
00:27:15.460 - 00:27:36.888, Speaker A: Once it's ready, I'm going to open up localhost 3008 in Chrome and we can see here my unstyled application. We need some CSS to get this looking nice and clean like we saw in the screenshot earlier. I'm not going to go over the CSS that I wrote earlier.
00:27:36.888 - 00:27:59.124, Speaker A: You can just import it using a link tag in the head of the HTML file. Okay, once we import that CSS file using a link tag, we can see that the interest rate app looks much more clean and colorful. Okay, next I'm going to make the same modal right below our modal that we just made.
00:27:59.124 - 00:28:22.580, Speaker A: And I'm going to make it so users can supply or withdraw collateral assets so they can borrow can reuse most of the code. And I'm going to change up some of the HTML tags here so that we can reference them in our JavaScript properly. We currently don't have an input for the collaterals.
00:28:22.580 - 00:28:46.240, Speaker A: We'll draw those on the fly once a user has selected their Compound Three instance of choice. We'll make that work in the JavaScript. Later, I'm going to make one more modal that shows the user's balance within compound three, so we'll update those with numbers once the user is supplying and borrowing tokens.
00:28:46.240 - 00:29:13.476, Speaker A: Last, I'm going to import some scripts, first of which is Ethersjs, so we can make calls in our front end JavaScript code to our Ethereum node fork running at 85 45. MetaMask will be able to interact with that. So I'm importing second a constants JS file, which is basically all of the HTML elements here.
00:29:13.476 - 00:29:47.684, Speaker A: I'm going to get them by ID using JavaScript and create variables that I'll reference in my script. So to keep things clean, I'll put the constants in one file and my code that actually does things in app JS. And my constants will also hold some JavaScript objects that have data for compound three instances, like the contract addresses the number of decimals for each asset, asset addresses, stuff like that.
00:29:47.684 - 00:29:59.240, Speaker A: You can check out the Constants file yourself if you'd like. All right, next we're going to write our app JS file. I'm going to create a new file in the public folder and name it App JS.
00:29:59.240 - 00:30:12.380, Speaker A: I'm going to create an event listener that waits for the browser page to finish loading before it executes this JavaScript code. I'm waiting for the Dom content loaded event to fire. And then we'll call this callback.
00:30:12.380 - 00:30:25.056, Speaker A: Our callback arrow function will have all of our code in it. We're going to make a variable for the selected account. This is the account that the user is selecting in MetaMask to submit transactions for.
00:30:25.056 - 00:30:51.288, Speaker A: I'm going to make a place to handle whether or not the user has a Web Three interface enabled in their browser. So if they don't have MetaMask installed, they will get an alert that says that they should go to MetaMask IO and install it. And if they do have it installed, we'll make an Ethereum request to the MetaMask's Ethereum object and it'll fire an event called On Ethereum Connect.
00:30:51.288 - 00:31:12.012, Speaker A: And when we on Ethereum Connect, we'll do some stuff on the page to load Web Three assets for the user. So I'm going to reference the Ethereum Enable button that we wrote in HTML. There's a variable for that in Constants JS, as well as all of the other variables we created in HTML.
00:31:12.012 - 00:31:42.584, Speaker A: We have some contract abi references as well as our Comet instance data, which I pre populated with some data I took from the documentation page. Remember that if you go to Docs Compound Finance and scroll down to the network switcher, you can see all of the addresses of the relevant contracts for Compound Three, and you can see them for each deployment of Compound Three. Okay, next, I'm going to make an event listener for my Ethereum Enable button.
00:31:42.584 - 00:31:56.430, Speaker A: So whenever a user clicks this, this event will fire. We're going to run that same on Ethereum Connect method. First, I'm going to write a render UI function.
00:31:56.430 - 00:32:22.934, Speaker A: We're going to select the instance of Compound Three that the user has selected in the select box, and that will correspond to the object in the array. Here, by index, we'll make a reference to the base asset as well as collaterals. In my object in a Constants file, I have the base asset as the first asset in the array.
00:32:22.934 - 00:32:45.826, Speaker A: So that's why I'm using address zero, and then the remaining assets in the array are the collaterals. So once I know the collaterals and the instance of Compound Three I'm using, I can fill in that collateral select box that we saw earlier that was empty. And I'm going to insert each of the tokens that can be used as collateral for that instance of Compound Three.
00:32:45.826 - 00:32:57.506, Speaker A: Next, I'm going to make a button to supply or withdraw the base asset. We're going to make. A click event handler for those as well as the collateral Supply and Withdraw buttons.
00:32:57.506 - 00:33:30.130, Speaker A: And we're going to call methods called Supply and Withdraw respectively. We can use the same method for both the base asset and the collateral asset and I'll show that a bit later. I'm going to pass the relevant compound three instance the index of the asset in my array of assets in constants such as and I'm also going to pass the amount, which is the value in the text box that the user input.
00:33:30.130 - 00:34:00.022, Speaker A: And the last thing I'm going to do in my render UI function is call another function called draw balances, so that will fetch each of the balances of the user's account, so they'll know how many tokens they've put in the protocol as collateral, or they've supplied or borrowed if it's the base asset. And we'll draw that on the screen as the last thing in the render UI function. Okay, I'm going to go back and create my On Ethereum Connect method that we talked about earlier.
00:34:00.022 - 00:34:20.942, Speaker A: I'm going to pass the first selected account in MetaMask and I'm going to remove the hidden class from the instance select box. So when the user loads the page, they see that ethereum enable ethereum button. And if they've already connected.
00:34:20.942 - 00:34:50.890, Speaker A: It will skip that part and just show the Compound Three instance select box so they can choose a deployment of Compound Three to interact with. Whenever they interact with that select box, there is an onchange event handler that will fire and we can render the UI once again with our relevant data for the specific compound three instance. And by default we will render the first index which is index zero of the UI before they've selected any of the instances.
00:34:50.890 - 00:35:01.640, Speaker A: Great, we could see that works. But our Draw Balances function is not yet defined. We'll write that soon.
00:35:01.640 - 00:35:19.490, Speaker A: Okay, next I'm going to write the draw balances function. We're going to first write a reference to a Getbalances function which will fetch the data from the blockchain. And in the Draw Balances function we'll handle creating the HTML elements.
00:35:19.490 - 00:35:41.770, Speaker A: So we're going to create a label for each asset and we'll post the balance inside of that label as well so they can see the asset and the balance they have inside the protocol. Now I'm going to write my get balances function. So we're going to pass the instance index.
00:35:41.770 - 00:35:58.430, Speaker A: First thing we're going to do is create a Ethers JS provider using the window Ethereum object. We'll make a contract object for the specific compound three instance that the user has selected. We'll call that contract comment.
00:35:58.430 - 00:36:34.010, Speaker A: We're going to loop through each of the assets for that specific compound three instance and we're going to make an array of promises. Each of those promises is an Asynchronous request and it will make a JSON RPC request to our Ethereum node which is running on our local host fork of Mainnet and for the base asset. We're going to use User Basic to find out the balance of the base asset that the user has supplied or borrowed from the Protocol.
00:36:34.010 - 00:36:56.180, Speaker A: And for all of the collateral assets, we'll use a different method called Collateral Balance of. We'll push each of those requests to our array called Balance Fetches. We'll use the Promise All function to wait for each of those requests to return.
00:36:56.180 - 00:37:20.890, Speaker A: Once they've all returned, we can make a subsequent request. So the first one is to check to make sure that the user is either supplying or borrowing from Compound Three. And once we know that they're supplying or borrowing, we can do a subsequent method with a balance of check to see how much they've supplied, or a borrow balance of check to see how much they've borrowed.
00:37:20.890 - 00:37:55.140, Speaker A: Once that last request is returned, we can loop through each of the numbers and turn it from an integer into a decimal number and return that whole array back to our Draw Balances function. Okay, now when we load the page, we see that each of our balances is zero for each of the assets for the selected Compound Three instance. Next, we're going to show how to calculate the APRs for both supply and borrow, and we're going to display those in our app as well.
00:37:55.140 - 00:38:18.490, Speaker A: We're going to go back into the Render UI function and add a place where we display the APRs. I'm going to write a function called Get APRs where we do the JSON RPC fetches. I'm going to reference the HTML element and I'm going to input the Apr for both supplying and borrowing.
00:38:18.490 - 00:38:39.890, Speaker A: Next, I'm going to write a new function that's an Async function for Get APRs. I'm going to pass the specific instance of Compound Three so we can get the relevant metadata for that instance from our constants JS file. We're going to copy and paste our provider creation object.
00:38:39.890 - 00:39:09.930, Speaker A: For an ethersjs provider, I'm going to create a variable for the number of seconds in a year so we can calculate our Apr. The way to do that with Compound Three is we need to first get the present utilization of the Protocol, that is, the amount that is supplied and borrowed. We also need to get the current supply rate based on the utilization and also the current borrow rate based on utilization.
00:39:09.930 - 00:39:28.782, Speaker A: So we can calculate the supply or borrow Apr using this formula, and it's pretty similar for borrow. So I'm going to write that in and return an array of the two numbers. So once our Render UI function runs, it will display those APRs.
00:39:28.782 - 00:39:48.946, Speaker A: So I'm going to refresh the page and you can see here the APRs with a really long decimal amounts. I'm going to use the JavaScript Two fixed function to shorten that down to two decimal places so that looks much cleaner, better for a user interface. Okay, next we're going to write our supply and borrow functions.
00:39:48.946 - 00:40:09.098, Speaker A: These are going to submit transactions to our localhost node to supply and borrow assets on behalf of the user. So the first thing I'm going to do is create a Ethersjs signer. This special type of provider can be passed to a contract and it can use the user's private key to sign transactions.
00:40:09.098 - 00:40:34.950, Speaker A: When submitting a transaction, I'm going to make a reference to the asset data that we have in our common instances array. I'm going to make a scaled up amount, which is an integer version of the amount that the user inputs so they could put like 1.1 Ether and that'll get scaled up to eleven E 17 because Ether has 18 decimal places.
00:40:34.950 - 00:40:51.580, Speaker A: I'm going to make an Ethers JS contract for the specific token. I'm going to call that asset. We're going to use our ERC 20 API, which only has the Approve function in it.
00:40:51.580 - 00:41:04.770, Speaker A: Next, we're going to approve the Comet instance before we run the Supply method. We need to do this for any ERC 20 contract. We need to approve the contract that is going to move the tokens before we move the tokens.
00:41:04.770 - 00:41:26.342, Speaker A: Next, I'm going to make a transaction for the Supply method. Comment Supply I'm going to reference the token address for the asset we're supplying and the scaled up integer amount that the user wants to supply. Once that transaction mines in my localhost node, I'll get a receipt back and I'll be able to draw balances once again.
00:41:26.342 - 00:41:53.198, Speaker A: Because our balances in the protocol have changed now that we have supplied an asset, I'm going to log that using console log to investigate if there are any issues we see later. We'll be able to open the console and make sure that the numbers are correct and the proper logs fired for the contract events. I'll wrap all of this in a try catch and make a similar error log.
00:41:53.198 - 00:42:08.418, Speaker A: In case we do have an error with our Supply function, which does happen time to time, we'll be able to debug a little easier if we log the error. Next, I'm going to create my Withdraw function, which is using a lot of the same code from Supply. So I'm going to copy and paste.
00:42:08.418 - 00:42:34.960, Speaker A: I'm going to remove the Approve function because you don't need to approve when you're withdrawing or borrowing. I'll update this comment to reflect that I'll change to the Withdraw method, which has the same parameters as Supply, and I'll also change out my console log so when they get logged in the console, we won't confuse them with our Supply method and that's it. It's pretty similar to the Supply method, mostly the same code.
00:42:34.960 - 00:42:53.230, Speaker A: All right, now that we've written our code, we can test out our application. Let's go over to the browser and refresh the page. You can see that I've switched my MetaMask to localhost 85 45 and we can see that I have 10,000 ETH because we are running our script we also have assets seated.
00:42:53.230 - 00:43:09.160, Speaker A: We have some ERC, 20 tokens that we should be able to see in our MetaMask wallet. So if I scroll through my assets, you can see I have five wrap bitcoin, five we and 5000 USDC. This is, of course, only in localhost development test world.
00:43:09.160 - 00:43:24.634, Speaker A: This is something you likely have to do. You'll have to go into Settings and go to Advanced and clear the tab data. This will remove all of the pending transactions and clear out the nonce data so that I can make requests to my local host chain.
00:43:24.634 - 00:43:33.390, Speaker A: This way sometimes MetaMask will get confused and resetting. This will fix that. I'm going to do it preemptively so we don't see any nonce errors in the console.
00:43:33.390 - 00:43:50.754, Speaker A: Okay, first thing I'm going to do is I'm going to try and supply 1500 USDC. I'm going to input that into my text box and click the supply button. You'll see MetaMask appear on the right and it's going to confirm that I want to approve this contract.
00:43:50.754 - 00:43:58.550, Speaker A: I'm going to hit the max amount. This, of course, is a new feature of MetaMask. It allows users to limit the amount that they're approving.
00:43:58.550 - 00:44:12.960, Speaker A: I'm going to just approve the max amount and I'm going to confirm the transaction. Okay, we can see that our receipt got logged like we referenced in our code. And you can see all of the transaction information there.
00:44:12.960 - 00:44:22.138, Speaker A: And you can see also that our comment balances have changed. We now have 1500 positive USDC. This means that we've supplied.
00:44:22.138 - 00:44:48.246, Speaker A: There is a little bit of a rounding error there, but if we wait a few blocks, we'll see this update to more than 1500 USDC. Now I'm going to try and withdraw the full amount. And now we've withdrawn all of our USDC.
00:44:48.246 - 00:45:06.320, Speaker A: We left some dust in there unintentionally because the protocol accrued some supplier interest to us. It does it by the block timestamp. So a little bit accrues every ethereum block and you can see that dust is still there.
00:45:06.320 - 00:45:16.130, Speaker A: Next, I'm going to supply some collateral so I can borrow USDC. I'm going to supply one USDC. I'm going to get two transactions, one to approve and one to supply.
00:45:16.130 - 00:45:40.404, Speaker A: Now that we've supplied, you can see that my Comet balance for WBTC is one. And now I can use the withdrawal function to borrow the base asset. If we head over to app compound finance markets, we can see the collateral factor for wrap bitcoin.
00:45:40.404 - 00:45:59.440, Speaker A: On ethereum mainnet, we could see that it's 70%. That means I can borrow up to 70% of the USD value of my wrap bitcoin as the base asset. So based on the current price of wrap bitcoin, I can borrow roughly 18,000 USDC from the Protocol with one wrap bitcoin as collateral.
00:45:59.440 - 00:46:21.516, Speaker A: Now that I've submitted my withdrawal transaction, I am borrowing. So my comment balance is negative for USDC. And you could see I have negative 17,999 USDC as my borrow.
00:46:21.516 - 00:46:37.576, Speaker A: And if I open my MetaMask wallet and scroll to USDC, you can see that I now have that plus 5000 which I had initially. So I have about 23,000 USDC now in my wallet. I'm going to switch the deployment of Compound Three that I have selected in the app.
00:46:37.576 - 00:46:48.744, Speaker A: I'm going to go to see weath v three. I don't have any CBE or Staked ETH as tokens that I can supply as collateral. I don't have any of those in my wallet.
00:46:48.744 - 00:47:13.840, Speaker A: I didn't seed my wallet with them using my seed function and my server. So the best I can do here is actually supply Weath as the base asset so I can earn interest on Weath. If you go over to the Markets instance selector, you can see the current Apr for Weath is 1.89%.
00:47:13.840 - 00:47:27.652, Speaker A: So supplying those to Weath, I can get 1.89% with the variable Apr. Now if I try and supply CBE, which I have zero of, I will have an error in the console because I'm not able to execute that.
00:47:27.652 - 00:47:44.456, Speaker A: I get the error transfer amount exceeds balance because I don't have any CBE, so I can't supply one CBE. So I hope this was helpful for everyone. You can build your own compound Interest rate interface using JavaScript, or you can do so using Solidity.
00:47:44.456 - 00:48:04.332, Speaker A: I have some examples on GitHub for using the protocol with JavaScript or Solidity. If you head over to Docs Compound Finance, you can click on Developer Resources on the left and it'll scroll down to the Developer Resources. You can click on Compound Three developer FAQ.
00:48:04.332 - 00:48:22.916, Speaker A: You can see here in the README that there are several frequently asked questions with code examples linked. There are JavaScript files that reference each of those examples, and you can see two different examples for each one. There's an example in JavaScript, and there's also an example in Solidity.
00:48:22.916 - 00:48:52.664, Speaker A: If you click on the Contracts folder and look at my contract here's where all of the Solidity examples live. You can see stuff like how to supply or withdraw from Compound Three, how to repay a full borrow, how to get the Apr, how to get the reward Apr, get the borrowable amount based on the liquidity of an account, get the borrow collateral factor, and several other examples. To run these examples, you can take a look at the Scripts file.
00:48:52.664 - 00:49:09.220, Speaker A: There are a bunch of JavaScript files that run JavaScript examples as well as the Contract Solidity examples. And we can run that using NPM test. That will run a test suite that runs all 28 of those examples.
00:49:09.220 - 00:49:21.756, Speaker A: In your console. You need to reference a provider URL for Alchemy or Infura, and you can watch each of those examples run on your own machine. And you can walk through the code examples if you need them.
00:49:21.756 - 00:49:41.632, Speaker A: For your project. Remember to ask a member of the Compound grant staff if you have any questions about the bounty prizes or your project that you're building on top of compound, we're happy to help. We can help you out with your technical questions or help you brainstorm your project idea.
00:49:41.632 - 00:49:52.468, Speaker A: We're happy to help you out. Come find us. Remember to check out our Hackathon Project Ideas blog post, which you could find using this QR code.
00:49:52.468 - 00:50:21.608, Speaker A: And you'll be able to come up with an idea that gets you going towards those hackathon bounties so you can win some cash prizes at ETH Waterloo 2023. On behalf of the Compound grant staff, I would like to thank you all for the opportunity to participate in ETH Global Waterloo 2023. If you have any technical questions, want to brainstorm your project idea, or have questions about Compound's community grants, please come find me or a member of the Compound Grant staff.
00:50:21.608 - 00:50:33.100, Speaker A: We're eager to help you out. Also, come and find us if you'd like your own compound t shirt or a compound sticker. Happy hacking and best of luck to all of the hackathon participants.
