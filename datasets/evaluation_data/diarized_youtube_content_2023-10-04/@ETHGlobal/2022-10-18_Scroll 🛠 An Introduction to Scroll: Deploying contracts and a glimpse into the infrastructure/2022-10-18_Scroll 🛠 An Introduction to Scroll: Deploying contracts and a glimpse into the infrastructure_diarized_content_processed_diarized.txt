00:00:06.250 - 00:00:09.994, Speaker A: All right, so welcome, everyone. My name is Peter. I'm going to talk about scroll tonight.
00:00:09.994 - 00:00:28.562, Speaker A: And first of all, thanks a lot for joining us tonight. I know it's very late, and I know most of you are just as jet lagged as I am, so really appreciate that you joined. Also, before we start, to all of you who listen to the optimism introduction 1 hour ago, I want to make a public announcement.
00:00:28.562 - 00:00:44.060, Speaker A: So scroll is, in fact, the only serious blockchain out there and the best layer two to Ethereum. So I just wanted to correct the optimism team there. So any questions? All right, so who heard about scroll? Hands up.
00:00:44.060 - 00:00:57.566, Speaker A: Okay, quite a few. So today we're going to see how you can deploy contracts on scroll. And I'm also going to go into some details about how scroll does what it does and what is it.
00:00:57.566 - 00:01:11.698, Speaker A: So scroll is a layer two to Ethereum and it's a ZKE EVM based layer two. So our goal is to scale Ethereum. So we want to have more transactions, lower fees, while we maintain the same level of security as layer one.
00:01:11.698 - 00:01:26.850, Speaker A: So it's a ZK roll up. And why is it a ZK EVM? Basically, we want to maintain very high level of compatibility with layer one. So the idea is that when you develop on scroll, it feels exactly the same way as when you develop on Ethereum.
00:01:26.850 - 00:01:33.338, Speaker A: You don't need to learn a new language. You don't need to learn any other tools. You don't need to understand what Xeonoh proofs are.
00:01:33.338 - 00:01:44.666, Speaker A: Everything is done under the hood, and you just develop your DAP and it's fast and it works and it's safe. So that's the idea. So we're going to start by looking at how you can get started with our testnet.
00:01:44.666 - 00:01:59.678, Speaker A: And the most interactive part of this workshop is hopefully you scanning this QR code, which you can use to sign on to our testnet. So currently we're in a permission testnet phase. So that means you have to sign up, you have to get on the whitelist.
00:01:59.678 - 00:02:10.774, Speaker A: And once you get on the whitelist, you can get some tokens. You can deploy some contracts, et cetera. So you can either open Scroll IO early dev, or you can scan the QR code.
00:02:10.774 - 00:02:18.770, Speaker A: It's the same thing. You fill it, and after a few hours, we will put you on the whitelist and then you can start building. And we also want to encourage you to join our discord.
00:02:18.770 - 00:02:41.050, Speaker A: And then you can also ask technical questions there, give us some feedback, all that stuff. All right? So we're going to have a very simple live demo here, if it all works. Okay, so when you get started on scroll, once you get on our whitelist, the first thing that you want to go to or the first website, is prealpha Scroll IO.
00:02:41.050 - 00:02:54.418, Speaker A: This is our so called Prealphateestnet. And this has all the information and all the tools that you need. So MetaMask configuration Faucet for getting funds and a breach to bridge from layer one to layer two.
00:02:54.418 - 00:03:05.206, Speaker A: So, a bit about this testnet. So in mainnet, of course, layer one is going to be ethereum and layer two is scroll. But in this testnet we are actually maintaining a simulated layer one.
00:03:05.206 - 00:03:20.990, Speaker A: So we have scroll layer one testnet and scroll layer two testnet. They are both maintained by us. So first thing that you want to do is just simply add these networks to your MetaMask so that you can send transactions and query the blockchain on these two networks.
00:03:20.990 - 00:03:38.670, Speaker A: So after this, you're going to have two new configurations in MetaMask and this automatically will configure the RPC address and also the chain ID. Okay, that should be pretty straightforward. And the next thing you want to do is get some funds.
00:03:38.670 - 00:03:45.074, Speaker A: So, as I said, we're not operating yet on Ethereum. We're not operating on Ethereum testnet. We're maintaining our own layer one.
00:03:45.074 - 00:04:01.686, Speaker A: So you need to get some test ethereum. And once you're on the testnet, you can just request some funds and you will get one test Ether and 100 test USDC tokens and then you should be good to go. So after that, you should have some test ETH.
00:04:01.686 - 00:04:13.486, Speaker A: And before you can start deploying on scroll, the last thing that you want to do is move your funds to layer two. So currently from the Faucet, you get your funds on layer one. So you don't have any tokens on layer two.
00:04:13.486 - 00:04:21.146, Speaker A: So you need to use our bridge. And it's a very simple UX. You've probably used plenty of similar DApps.
00:04:21.146 - 00:04:42.198, Speaker A: You just enter the amount, send the transaction and under the hood. We're maintaining this bridge from layer one to layer two and it's relaying tokens like ETH, ERC 20 tokens. You can also relay NFTs, which I think is kind of unique, or not something that you see so often.
00:04:42.198 - 00:04:52.060, Speaker A: But actually this bridge is also an arbitrary message bridge. So if you want to build something using this bridge, then we're also open to that. So just reach out to us.
00:04:52.060 - 00:05:07.806, Speaker A: So by the end of this onboarding process, you open your MetaMask and now you finally have some funds on layer two. So it's time to start building. And I'm going to use this open Zeppelin wizard here, which some of you might have seen.
00:05:07.806 - 00:05:26.846, Speaker A: This is just a very simple tool for putting, like implementing tokens with no coding. You can just choose the features that you want to have. So we want to implement an ERC seven to one NFT token and let's say it's a scrollers NFT.
00:05:26.846 - 00:05:40.646, Speaker A: This is probably going to be one of the first NFTs on layer two. So it's a historic NFT and the only feature that we want to add is that it's going to be mintable. So we're going to be able to mint new tokens and that's about it.
00:05:40.646 - 00:05:49.178, Speaker A: That's the coding part of this so called Workshop. And the next thing I want to show you is how to deploy on scroll. And I'm going to use Remix for that.
00:05:49.178 - 00:06:13.860, Speaker A: But as I said, the main goal with scroll for us is that we maintain 100%, even though we are a zero knowledge proof roll up or a ZKE EVM, we maintain 100% compatibility with Ethereum. So you can use Remix, you can use Hearthat, you can use Foundry, all the other tools that you're already familiar with. So here I just click on Open in Remix to open this code.
00:06:13.860 - 00:06:27.090, Speaker A: And I'm just going to use Remix as I would use it on Ethereum. So notice that we don't have any scroll specific here. Solidity is compiled into EVM bytecode as on other EVM chains.
00:06:27.090 - 00:06:45.946, Speaker A: And then you can just simply go to the deployment part to deploy on scroll. So select the scroll add to testnet and choose the injected provider MetaMask. And you see that I have my balance here and just click Deploy and then it should be deployed.
00:06:45.946 - 00:07:02.446, Speaker A: So at this point, if this deployment fails for you when you're doing it, chances are that you either don't have enough funds or that you are not on the whitelist yet. So feel free to register or reach out to us and make sure that you're on the whitelist. And now we have a contract deployed on scroll.
00:07:02.446 - 00:07:16.706, Speaker A: It's actually fairly straightforward. And just as another example, I'm going to mint one token to my own address. So call this Safe Mint function again, just confirm the transaction.
00:07:16.706 - 00:07:26.460, Speaker A: It's going to go through within a matter of seconds. And now we can see it on the blockchain Explorer. I minted one token to my address.
00:07:26.460 - 00:07:43.930, Speaker A: Thanks. So that's the example with Remix. And for a more detailed tutorial, you can go to guide Scroll IO, where we have all kinds of guides about our current testnet, including a contract development or deployment tutorial.
00:07:43.930 - 00:07:52.066, Speaker A: And this is an example repo that we have. Again, it's just a very simple contract. I think if you've developed on Ethereum, this should all be very familiar to you.
00:07:52.066 - 00:08:16.874, Speaker A: And you can either deploy with Hearthat or you can use Forge Create to deploy with Foundry as you would do on other chains. So back to the presentation. So you might ask me like, okay, so what is the point? What's going on, Peter? Why are you telling me stuff that I already know? And I would argue that if this is all boring to you, that's kind of the goal that we are aiming for.
00:08:16.874 - 00:08:27.210, Speaker A: So the goal with scroll is that you're building on ZKE EVM, you're building on layer two. But you don't have to learn a new language. You don't have to learn a new tooling, new ecosystem.
00:08:27.210 - 00:08:44.078, Speaker A: You can just use your existing tools out of the box and it works exactly the same way. And when I say exactly, it's not actually 100% the same. So we have some slight modifications if you're familiar with Vitalik's classification of ZKE EVMs.
00:08:44.078 - 00:08:56.774, Speaker A: We are aiming for type 2.5, which means that there are some slight differences between layer one and layer two. Like the gas costs might be different because some operations are more expensive in a ZK roll up.
00:08:56.774 - 00:09:07.100, Speaker A: And the other thing is that some opcodes might not work as on layer one. For instance, self destruct is going to be disabled. But I think for most DApps that should not be an issue.
00:09:07.100 - 00:09:27.954, Speaker A: So now that you understand that scroll works exactly the same way from your perspective as Ethereum, let's dive into some technical details of how we implement this Zkevm stuff. So here you can see like a high level architecture. So we're operating on two chains, as you would imagine, layer one and layer two.
00:09:27.954 - 00:09:46.550, Speaker A: And in our case, layer one is the Ethereum mainnet and the two main components there are the roll up contract and the bridge contract. So the roll up contract is basically maintaining the state of the layer two chain. It maintains the data from the layer two chain as the data availability, the content of the data availability.
00:09:46.550 - 00:10:03.790, Speaker A: And it also receives the zero knowledge proofs and maintains the state route of the layer two chain. The bridge contract, as you just saw in the example, it's for bridging assets from layer one to layer two. As I said, it can bridge all kinds of contracts sorry, all kinds of assets.
00:10:03.790 - 00:10:16.302, Speaker A: And this is pretty familiar, pretty similar to other chains. And now we get to the juicy part, which is actually the layer two implementation. It has, let's say, four major components.
00:10:16.302 - 00:10:23.246, Speaker A: So one is the sequencer node, which is responsible. It's basically maintaining the blockchain. So it's a fork of go ethereum.
00:10:23.246 - 00:10:40.106, Speaker A: It's responsible for collecting transactions, creating blocks and just maintaining the blockchain itself. Then we have the relayer, which is strictly related to the bridge contract. So it's for relaying messages between layer one and layer two both ways.
00:10:40.106 - 00:10:58.394, Speaker A: And then most crucially, we have this component called roller. So that is the prover in our system that is the component responsible for creating the zero knowledge proofs. So the way it works is that for each block the roller receives this block or receives some data related or derived from this block.
00:10:58.394 - 00:11:16.530, Speaker A: And using the Zkevm circuits, it creates a proof for this block. So what does it actually mean? So you could imagine that currently we have state A. So state root is a now we get a new block and now we transition to state B by executing that block.
00:11:16.530 - 00:11:30.890, Speaker A: So we have this state transition from A to B. Now what the roller does is that it creates a proof for this execution of this block. And then using this proof, you can actually prove that this transition from A to B is correct.
00:11:30.890 - 00:11:50.314, Speaker A: You can prove this or verify this without actually executing the transactions. So that is the essential part how zero knowledge proofs are used in all ZK rollups is that you create this proof of the state transition which the roll up contract on Ethereum can verify independently. So in our case, we have a decentralized network of rollers.
00:11:50.314 - 00:12:11.298, Speaker A: So if you have a couple of spare GPUs and you want to earn some money you can actually during mainnet or the next testnet iteration you can actually join our testnet. You can spin up your GPUs, you can create some zero noise proofs and you can earn some rewards for this. And to maintain this connection between scroll and the rollers we have a coordinator.
00:12:11.298 - 00:12:34.554, Speaker A: So coordinator is simply responsible for assigning blocks to the rollers receiving the zero H proof and verifying it. Yeah, these are the main components and if we zoom into the roller itself, like what is the workflow of the roller? The input for the roller is the execution trace. So for the block you could imagine that we generate all kinds of information about the execution of the block.
00:12:34.554 - 00:12:54.606, Speaker A: So that includes all the opcodes that were executed, all the storage entries that were updated, all kinds of informations and that is the input for the circuits. And the ZKE EVM itself, which we are developing. Along with the Ethereum foundation is a collection of circuits for proving these different state transitions.
00:12:54.606 - 00:13:09.962, Speaker A: So we have an EVM circuit that proves that the opcode was executed correctly. Then for instance, we have the storage circuit that proves that the storage updates were also executed correctly. And we have a whole bunch of different circuits proving different things.
00:13:09.962 - 00:13:33.770, Speaker A: These all create different CK proofs that we aggregate into single proof and that is the output of the roller. And just one final diagram of this whole process like how do we all put it together in terms of time. So on this diagram you have time as the x axis and we see the process of the ZKE EVM.
00:13:33.770 - 00:13:45.550, Speaker A: So you can look at the sequencer. The sequencer is creating the layer two blockchain so it's creating blocks 1234 and all these blocks are first of all committed to Ethereum. So we have the data available on Ethereum.
00:13:45.550 - 00:14:19.930, Speaker A: At the same time the coordinator will assign these blocks to different rollers based on some algorithm and the rollers will start a proof generation session. So this is a pretty expensive computation but this only has to be executed once and later we only just verify this proof that was created. So for each block we create a proof and then finally we can aggregate these proofs into single proof and that is submitted to Ethereum to the roll up contract and that is verified independently by the contract.
00:14:19.930 - 00:14:33.794, Speaker A: So that is how it all comes together. Hopefully to all of you who didn't know how Zkvms or ZK rollups work this kind of demystifies some of the main ideas. Zooming out a bit.
00:14:33.794 - 00:14:50.554, Speaker A: So again, our vision is to scale Ethereum so it should be faster, it should be cheaper, and it should be just as secure as layer one. And that is what Zkevm does. And in our case, so there are many different companies working on Zkevms and there are different design trade offs to be made.
00:14:50.554 - 00:15:08.814, Speaker A: In our case, we aim for as much compatibility as we can. And that means that we're aiming for bytecode equivalent. So that means that you take the EVM bytecode, let's say from Remix or from heartet that you deployed on layer one and you can, in exactly the same way, deploy it on layer two.
00:15:08.814 - 00:15:19.678, Speaker A: And it works the same way. Then we have decentralization as a main design component. So, as I said, the provers or rollers are decentralized from day one, so decentralized during the main net launch.
00:15:19.678 - 00:15:35.910, Speaker A: And eventually the sequencer is also going to be decentralized. And finally, we're pretty much aligned with the Ethereum ecosystem. So we're aligned with Ethereum's Rollup centric Roadmap and we're also building the zkvm together with the Ethereum foundation.
00:15:35.910 - 00:15:51.340, Speaker A: So there's a lot of very highly skilled ZK engineers working on this. If you're interested in ZK, all of this is open source, so I encourage you to look into it. I think it's pretty complex, but this should be a very interesting thing to you.
00:15:51.340 - 00:16:05.470, Speaker A: What can you do? So, we are a sponsor at this hackathon. So we really would like to welcome you to build on scroll. As you see, if you've built on Ethereum before, then it's very seamless, very easy to move to scroll.
00:16:05.470 - 00:16:24.790, Speaker A: And you can build all kinds of applications because scroll is general purpose. Layer two, for instance, you could build some more complex AMM Daxis that might not be feasible on layer one because of the computational burden. Or similarly some lending pools with some more complex borrowing computations.
00:16:24.790 - 00:16:42.806, Speaker A: Or I think a very exciting idea is web three social apps, which I think current systems cannot really support the user experience that we would expect from a social app. But layer two blockchains, especially ZK AVMs, might be an excellent fit for these. Or you might want to just build some simple NFT projects.
00:16:42.806 - 00:16:56.740, Speaker A: Or if you're interested in ZK, you can just build a ZK DAP on scroll. And the advantage here is that we have a lot of engineers that are super experienced with ZK. So if you choose this route, then we're more than happy to guide you and give some help.
00:16:56.740 - 00:17:07.350, Speaker A: So we have two bounties. One is for the most innovative DAP and the other one is for the best DK DAP. And all in all, you can get like $5,000.
00:17:07.350 - 00:17:18.920, Speaker A: So, yeah, if you're interested, please join or please just find us. It's me. We have our team members sitting at the back, so feel free to reach out to us and ask some questions.
00:17:18.920 - 00:17:29.158, Speaker A: And finally, some resources for you to get started. First of all, you should go to scroll IO early Dev. Again, to get on the whitelist for our testnet.
00:17:29.158 - 00:17:43.914, Speaker A: And then you should go to guide, Scroll IO to find all these tutorials on how to deploy it, scroll, how to get funds, all that kind of stuff. Yeah. And finally, here is the most important resources.
00:17:43.914 - 00:17:51.886, Speaker A: So on the right you get these slides so you can review all the links and everything. On the middle is the discord of scroll. Please feel free to join.
00:17:51.886 - 00:18:04.454, Speaker A: And on the left is my telegram. So if you have any questions to me or you have any issues you didn't get on the whitelist, et cetera, please feel free to message me directly. Yeah, and we're also hiring, by the way.
00:18:04.454 - 00:18:17.110, Speaker A: So if you're a ZK engineer, if you're interested in infrastructure engineering, feel free to reach out to us as well. All right, that's our workshop for tonight. Thanks a lot for joining.
00:18:17.110 - 00:18:55.002, Speaker A: Do you have any questions? Yes, go ahead. Yeah, for the coordinator and yeah, because you mentioned the alignment. Yeah, thanks for the question.
00:18:55.002 - 00:19:29.686, Speaker A: So the question was that how much is proof generation is reliant on GPUs? What is the specific requirements that we have here and how does this relate to ethereum after the merge becoming more and more green? So I think GPU accelerated ZK is a breakthrough in the last few years and that's what makes really Zkvm possible. So previously we had most stuff running on CPUs and that was not really practical for any practical purposes. Recently we have GPU acceleration and that makes it practical in terms of running time.
00:19:29.686 - 00:19:54.078, Speaker A: And I think in the future we might have some ASIC hardware for this. So in terms of the environmental impact, there is some similarity here to mining for sure, because we have a decentralized network of provers, they consume a lot of energy to create these proofs. I think there are some very interesting or very important differences though, because in proof of work you do like useless work.
00:19:54.078 - 00:20:19.814, Speaker A: I mean, it's useful in terms of proof of work, but the computation that you execute doesn't have any useful results by itself. In our case, the computation that you're doing is actually useful because you're calculating these decay proofs that many people will use to verify this state transition in the future. So I think this is not really the same thing or the same concern as proof of work.
00:20:19.814 - 00:20:52.510, Speaker A: And also there won't be so much of an arms race here because whether it's profitable to create proofs depends on the utilization of the system. Basically, the more blocks we have, the more transactions, the more rollers can join the system and contribute. But this is linearly, directly related to the amount of usefulness of the network as opposed to proof of work, where if your neighbor gets more computing power, then you're also forced to get more computing power to remain competitive.
00:20:52.510 - 00:21:32.420, Speaker A: I hope that answers the question. Any other questions? What happens if the coordinator, what happens if the coordinator makes a mistake. So what kind of mistake do you, do you have in mind? Is it possible for the the error if something goes wrong? Yeah, that's a good question.
00:21:32.420 - 00:21:59.692, Speaker A: Like if something goes wrong, what happens? And also given that some of these components are centralized on day one, is there any kind of cheating that scroll can do or the maintainer of the coordinator can do? So the way it works is that before we even do any SDK proof generation, we commit the block data on layer one. And yeah, this data is available for everyone to see on layer one. And at this point it cannot be changed.
00:21:59.692 - 00:22:22.020, Speaker A: And so this is the commit phase and once we have the proof, that is what we call finalized. When we make it final, it cannot be reverted. What's on layer one? What can go wrong? If we look at the coordinator, it cannot really fake any proofs because all the data is available on layer one.
00:22:22.020 - 00:22:44.110, Speaker A: So only a correct proof will go through. And if the roller, let's say, fakes a proof, we can catch that at the coordinator level because it's fairly cheap to verify that the proof is correct. But even if we don't verify it at the coordinator level, the roll up contract will verify the zero noise proof and will revert the transaction if there's an issue with that.
00:22:44.110 - 00:23:01.110, Speaker A: That said, I think there's an interesting question here of auditability or how can we make sure that the Zkavm is correct. Because it's an extremely complex set of circuits. There's not that many people with this kind of expertise who can review and audit them.
00:23:01.110 - 00:23:20.388, Speaker A: So I think the most crucial part is to make sure that this component of the system is correct. And for this, if any of you is ZK enthusiast, we would invite you to come learn about our circuits. And once you have a good understanding, start reviewing and start seeing if there's any errors.
00:23:20.388 - 00:23:28.670, Speaker A: So there's going to be bounties for this. We also hire people just for this purpose to make sure that the circuits are correct. So that's the effort that we do.
00:23:28.670 - 00:23:41.304, Speaker A: Thanks for the questions. Maybe one last question if you guys have any more. Okay, thanks again for joining at 10:00 P.m..
00:23:41.304 - 00:23:50.930, Speaker A: I really appreciate it and hope to see you around at the Hackathon. So enjoy you stuff.
