00:00:06.170 - 00:00:31.222, Speaker A: So, hi everyone. My name is Nicolas and with my colleague Nikolai also, we're going to present and explain this motive of the hackathon working for Sigma SDK. You know, doing stuff, funny stuff with Sigma SDK, the first thing that I want to ask is how many people here speak Spanish? Okay, a lot.
00:00:31.222 - 00:01:16.994, Speaker A: So, okay, so what is Sigma? So Sigma basically is cross chain interoperability protocol allowing general message passing, but also LC 20 and NFD transfer. So with our SDK and with our infrastructure, you can relay message, you can transfer tokens, you can transfer NFTs cross chain between EVM compatible networks. Right? So the basic idea here is that you have chain A and chain B and you have Sigma in between.
00:01:16.994 - 00:01:34.550, Speaker A: And then of course, you can transfer the most populous formats. I would say LC 20 LC 721 and we use this acronym, GMP and GMP. It stands for General Message Passing.
00:01:34.550 - 00:03:00.870, Speaker A: Okay? So, ladegi SK infractutura para construed application across chain um capacity jamar funciones the contratos sinuses amo funcionke algoma complexion, de liquid, et cetera. So Sigma also with our infrastructure, we have also our SDK. So of course, all of this is open source.
00:03:00.870 - 00:03:40.882, Speaker A: And with our SDK, the main idea is to allow developers that usually are familiar with JavaScript or TypeScript to build cross chain applications in an easier way without too many hassles, without the needed to set up a lot of stuff. Our SDK had mainly like three methods, or I would say three big general methods. And those methods are aligned with the type of transfer or type of message passing that we do.
00:03:40.882 - 00:03:59.130, Speaker A: So RC 20 tokens NFT stuff. And of course you can use this SDK in the front end and of course in the back end. So, for instance, if you are building something in node JS, you can use this SDK in node JS.
00:03:59.130 - 00:04:35.294, Speaker A: We have documentation for this and of course, you have to provide perhaps a little bit more setup, but it's pretty straightforward. And also you can use this SDK in the front end so you can communicate directly with our contracts. And another big thing that I think we have, and it's like I would say, a winning in this I would say scene is that if you want to develop something that is so custom that you need to I don't know, iterate a lot over this, you can use also our local Setup.
00:04:35.294 - 00:04:43.670, Speaker A: So we have something called local setup. It's basically all our infrastructure. You can run it in a docker container.
00:04:43.670 - 00:05:01.226, Speaker A: So it's like just one command. And then you have two nodes and then relayers. So then you can play with this, like play around with this building stuff if you need, of course, speed, because sometimes testnets are a little bit slow.
00:05:01.226 - 00:05:28.180, Speaker A: Or if you need something that is so custom that you need to iterate really fast over your code. So what's the main idea of the challenge to hack with us. So many ideas to see how many developers they want to be excited and interested in building cross chain applications with us.
00:05:28.180 - 00:05:47.062, Speaker A: I mean the sky is the limit in this case. You can build, I don't know, you have uniswap LPs, it's an NFT. You can try to build cross chain liquidity pool because you can transfer NFTs.
00:05:47.062 - 00:06:29.320, Speaker A: You can do defy typical stuff with RC twenty s and also with our contracts you can interact with general message passing. So if you want to escape a little bit the defy space I would say, and you want to do something that is not related to this, you can do this with our contracts. So yeah, we have a lot of resources, we have our homepage, we have Docs, we also have our Rhythm of course our repos, we have our contracts, right? So everything is open source so you can just clone the repos, play with it.
00:06:29.320 - 00:06:47.310, Speaker A: Of course we have also a definite environment. So if you don't want to use our infrastructure like in your machine, you can just use DevNet and just connect to the contracts. So in in a way it's a little bit more straightforward.
00:06:47.310 - 00:08:40.290, Speaker A: So yes, and let me get interesado and contribute cross chain yase tokente or NFTs loyamo general semifinal number contra cross chain message passing poem locals connectors so we have the faucet UI, so you can get tokens from this faucet. And also we had so it's pretty straightforward. You just go to this URL and you get the tokens.
00:08:40.290 - 00:08:50.310, Speaker A: So in case you want to use DevNet, you get the tokens and then you can do whatever you want. You can pay for your NFT transactions or transfer. Sorry.
00:08:50.310 - 00:09:31.540, Speaker A: So yeah, there is not too much hassle to do this using DevNet and Faucet UI. And the main idea, the main bounty prices for this hackathon is tier one is to build or showcase something using general message passing and this is the amount that we are giving for this. And also there is this tier two price in this case is utilizing Sigma SDK and showcase something with NFTs or SC 20, whatever your imagination can, I don't know, build.
00:09:31.540 - 00:10:09.646, Speaker A: Now I would like to explain a little bit in more technical terms. How can you use our stuff or SDK and our infrastructure to build cross chain applications? So I'm going to show some code snippets, then I'm going to show you a demo of an NFT application and then I'm going to try to run live demo of RC 20 transfer. So yeah, I hope demo got behaves well with me today.
00:10:09.646 - 00:10:40.570, Speaker A: So basically for you to build with or SDK you need to provide addresses because of course you need to know who are the contracts that you need to connect. And this is our standard configuration to use our SDK. So you define this stuff like domain ID, the network ID in this case is the chain ID of a node and then you provide the addresses.
00:10:40.570 - 00:10:55.802, Speaker A: If you run our local setup, addresses are provided after everything is running. So you have this and then you can plug this and use it locally. So I would say it's a seal environment.
00:10:55.802 - 00:11:14.906, Speaker A: So you use SDK locally and with the infrastructure locally. If you want to use our DevNet, of course you have to go to our resources and get the addresses of our contracts. And then you plug these addresses in this setup format.
00:11:14.906 - 00:11:57.070, Speaker A: And of course, you define, for instance, here the RPCO URL and in this case, the RC 20 co token the address, et cetera, if you want to deposit. For instance, in the case of RC 20, if you want to transfer some tokens from one network to another, besides of course the setup, you need to initialize connections and in this case we have two separate ways of doing this because of course this SDK works in the front end and also in the back end. So if you want to do stuff or if you want to transfer tokens in the front end, you just initialize connection from web three provider.
00:11:57.070 - 00:12:24.534, Speaker A: In this case you are going to use MetaMask provider. So MetaMask is going to carry out approval and all the actions behind the scenes with the account. And of course, since in our infrastructure we have a fee structure, you need to get the fee in order for you to then do the deposit.
00:12:24.534 - 00:12:50.980, Speaker A: Because our entry point, and I think this is one of our advantages or entry point for our application is the deposit on the bridge. So you need to provide this fee and in order for you to provide this fee, you just need to fetch this fee data. In the case of our local setup, fee data is like a constant and you get this and then you can play with it.
00:12:50.980 - 00:13:21.230, Speaker A: And of course in the case of DevNet, also fee is already provided so there is no miscalculation. And then of course you do the deposit and you define these parameters, amount, recipient address and fee data. And after that you should see if you are running for instance, infrastructure in your machine, you should see the logs of the message being carried out to the other network.
00:13:21.230 - 00:15:40.130, Speaker A: Okay, so in el caso de tutorial como DevNet obtainer el fee parabola implemented el monto la direction. So for LC 721, it's kind of the same configuration, but you add this LC 700 and 2100 address, of course again another address and it's like there is no much change in terms of what you are calling. You are always calling deposit method and you're always providing in this case, recipient address, basic fee, and in this case the amount represents the token ID.
00:15:40.130 - 00:16:01.630, Speaker A: So in a way, transferring SD 20 and NFTs kind of behaves the same in our SDK. So this is an advantage in a way that we don't want to provide different APIs or a lot of methods. And we want to, in a way, make a developer's life easier.
00:16:01.630 - 00:16:29.430, Speaker A: And for this, we have this straightforward way to use our SDK. In the case of generic handler, it's a little bit more, I would say complex, but still straightforward, since from this week, our contract is permissionless, meaning that you just register the resource. In this case, resource is the function that you want to call in another network.
00:16:29.430 - 00:16:51.566, Speaker A: And then this registration make the function available for everyone, and you need to provide this sort of format for the data. And the most important part of this is, of course, metadata depositor in this case is the address who is doing the deposit. And then execution data.
00:16:51.566 - 00:17:09.890, Speaker A: And execution data are the bytes that correspond to the arguments of the function that you want to call in the other network. And then again, it's straightforward. For instance, in this case, deposit function signature.
00:17:09.890 - 00:17:31.126, Speaker A: You can get this using web three JS or Etherjs, providing, of course, the abi of the contract. And then, for instance, in this case, we have this hex red color. And you just want to transfer this color to another contract, another chain.
00:17:31.126 - 00:18:01.650, Speaker A: So you just call this, create generic deposit data, and you provide this signature, the deposit function signature, the address or your contract in the destination chain and other parameters that are describing our documentation, like max fee deposit or address. And of course, the data in this case, the color that I went to transfer. And then using our contract, you just do again, a deposit.
00:18:01.650 - 00:18:08.710, Speaker A: So, again, it's really straightforward. Nothing really changed. Provide domain ID in this case for destination chain and deposit data.
00:18:08.710 - 00:18:27.834, Speaker A: And deposit data in this case is going to be bigger because you are not just transferring an asset like an NFT or SD 20. You are transferring like, a function call to another network. There is, like, questions up to this point.
00:18:27.834 - 00:18:33.420, Speaker A: Preuntas. Okay. If you have questions, you can ask me later.
00:18:33.420 - 00:18:56.374, Speaker A: Okay, no problem. Yeah. La transactions.
00:18:56.374 - 00:19:16.690, Speaker A: Roberto no. Say yaga Santio no. I Digamo incompetent you another question.
00:19:16.690 - 00:19:26.546, Speaker A: Or Otaperunta. Okay. And I don't want to extend more because I want to show you how everything works.
00:19:26.546 - 00:19:49.050, Speaker A: So first I'm going to show you the video of this is our NFT example that we have in the SDK. It's like pretty bare bones. It's super basic and simple, but it allows you to check the code and then see how easier is to use our stuff.
00:19:49.050 - 00:20:02.266, Speaker A: So I'm just going to press play. Okay, so what you see, of course, you have the front end application, right? You are doing stuff with MetaMask. You are doing the transfer with MetaMask.
00:20:02.266 - 00:20:21.190, Speaker A: You have, of course, the DevTools with the logs. And this in the right corner is our local infrastructure. So this docker image that you just run and you have nodes and relayers working for you with contract addresses.
00:20:21.190 - 00:20:37.770, Speaker A: And then you wait a little bit because of course this is really fast, but of course it doesn't happen right away. And those logs that you are seeing right now are the logs of the relayers. Relaying the message to the other network.
00:20:37.770 - 00:20:55.066, Speaker A: So we should see a result in the transfer complete. So we managed to transfer one NFT to the other network. And this example, as I say, is currently in the GitHub repo.
00:20:55.066 - 00:21:07.122, Speaker A: So you can just clone install and run it. And it's pretty straightforward. I'm going to try now to run like a demo of the RC 20.
00:21:07.122 - 00:21:25.798, Speaker A: So I hope everything works. So here I have a local setup and I'm going to run it with docker. You can also use there is a make command to do this, but since I like to tweak a little bit the Docker file, I always ended up to using docker.
00:21:25.798 - 00:21:37.470, Speaker A: So now our infrastructure is running. And here is the example of the RC 20 application. Also like a really bare bones application for transferring tokens.
00:21:37.470 - 00:21:56.542, Speaker A: So first we're going to run this command called Mint RC 20. So what I'm going to do now is going to mint some tokens, 99 for me, then to transfer. So okay, everything went smoothly.
00:21:56.542 - 00:22:16.906, Speaker A: Now I'm going to run the server. Okay, so, demogot, please. Okay, so we have this bare bone application.
00:22:16.906 - 00:22:33.760, Speaker A: And you can see that we have 99 tokens to this account. And then I can try to transfer one or whatever. We can put, I don't know, eleven, because we have a lot.
00:22:33.760 - 00:22:58.790, Speaker A: So you get this message because you are getting first the fee as I show you in this code snippet. And then if everything works great, we confirm the operation. And I'm going to try to put this no, okay, of course.
00:22:58.790 - 00:23:13.034, Speaker A: Demo. Want to put it aside? Yes. Okay.
00:23:13.034 - 00:23:21.390, Speaker A: So there is an issue. I'm going to try again. If not, you can check the repo.
00:23:21.390 - 00:23:56.650, Speaker A: So I don't have access to this. Okay, so let's try this. I wanted to show you the logs, but since this screen size is kind of weird okay, so first getting the fee and yeah, so confirmation.
00:23:56.650 - 00:24:14.242, Speaker A: And it let's wait for it. So, here are the logs. Now you are seeing the logs of the transaction being carried out from one node to another.
00:24:14.242 - 00:24:24.310, Speaker A: So these are the logs of the relayers. And that's it so simple. It's pretty straightforward.
00:24:24.310 - 00:24:50.882, Speaker A: This is our SDK. This is the main idea that we want you to get excited about. It like build with us, build what in your imagination, a cross chain application looks like, and use our open source code, use our SDK, your infrastructure, your DevNet, and we are going to be here, here.
00:24:50.882 - 00:25:01.360, Speaker A: So if you have, I don't know, questions, doubt, if you want to debug stuff, we're here to help you. So, yeah, I think that's it. Thank you.
