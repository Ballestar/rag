00:00:06.650 - 00:00:56.190, Speaker A: So after Moli here gave the high level view of the Certora Approver and tools and what is the idea of the whole thing? Our next step is to do something more technical to dive into how actually working with Certora looks like. And we would like to explain you how to define these properties of the code, how to feed them to the prover and hopefully we'll have the chance to actually use the tool and write rules of your own. So, like I mentioned before, the practical part will require docker desktop and downloading our docker image, which might be a bit slow with the Wi Fi because many people are here, but we'll see, we'll manage it.
00:00:56.190 - 00:01:37.126, Speaker A: So how will the workshop look like? First we will talk about the setora approval technology, which is muli already discussed it at length from the high level point of view. Then we will give some introduction to the CVL, where CVL is the verification language, it's the rules, that the custom language that we use to define properties, to define rules, how the code should behave. Then we will dive deeper after the introduction to CVL, we will dive deeper into some CVL features like parametric rules and invariants.
00:01:37.126 - 00:01:56.958, Speaker A: Don't worry if you don't understand these terms, we will explain everything in detail. And after we finish explaining all the CVL and the features, we will move to the exercise. Maybe we will have a short break and have to install the docker image for the exercise.
00:01:56.958 - 00:02:18.760, Speaker A: So the exercise will be you will try to provide the ERC 20 token code box and you write simple rules and basically find this bug. And idea is that you can get a feel, get a taste of how it is to do formal verification. Just pretty interesting.
00:02:18.760 - 00:02:29.626, Speaker A: All right, so let's start this example. Sigmulli discussed it. What does approver do? So I will not talk a lot about it.
00:02:29.626 - 00:02:43.890, Speaker A: Here is the good code. So we give the correct code and the invariant total supply equals to the sum of all balances. We give both of them to the prover and the prover says fine, the property, the environment always holds.
00:02:43.890 - 00:03:17.674, Speaker A: And when we give the buggy code to the prover and with the same invariant, the prover will find a counterexample which is a self transfer like somebody mentioned here. So when from equals to two, then the property doesn't hold because kind of new tokens are being minted out of thin air. So everybody understand this part? So now let's give a high level view of Certora Approver architecture, how the whole process works.
00:03:17.674 - 00:03:32.720, Speaker A: So, like we see, first of all we take the smart contract code and the rules, the specification, how the code should work. So there is some kind of transformation of the smart contract code. We will not discuss that in detail.
00:03:32.720 - 00:04:00.810, Speaker A: And eventually the smart contract code and the rules, they both are combined by the Serator Approver into VC and VC here is not the venture capital, it's a verification condition. It's a big logical formula that combines both the code and the rules. And this huge logical formula is being fed into several open source constraint solvers.
00:04:00.810 - 00:04:22.474, Speaker A: Now, the job of these constraint solvers is to find the variables which do not satisfy the logical formula. So when this set of variables that doesn't satisfy the formula is found, then it's the counterexample. Then it means that the rules don't describe the code properly.
00:04:22.474 - 00:04:43.718, Speaker A: So it means either there is a bug in the code or the rules are not written properly. And if the constraint solvers don't manage to find any variables that violate the formula, then it means that the formula is correct and it means the rules are correct. That means that the rules describe the code correctly and we call that we prove the correctness of the code.
00:04:43.718 - 00:05:18.930, Speaker A: So this is the big scheme, how the Certura prover is built. Okay, so after all these abstract diagrams, let's dive in and start to talk about CVL, how we write this part. So in this workshop we've worked with ERC 20 code, which is probably the most common smart contract in existence.
00:05:18.930 - 00:05:45.500, Speaker A: And we want to start by proving that the transfer function works as expected, right? So this is CVL, this is for most of you, probably your first view of the CVL. And CVL is very similar to solidity. It's been designed to resemble solidity so that the solidity developers will find it easy to work with.
00:05:45.500 - 00:06:16.514, Speaker A: And this keyword rule, like it says, it describes one property about the code. So what we want to express what do we want to express? We want to express them transfer functions properly, that after the transfer is called on the token, then the sender's balance is reduced by amount and the recipient's balance is increased by amount. So this is the basic structure of the CVL rule.
00:06:16.514 - 00:06:43.818, Speaker A: First we do some operation and then we describe the assertion. We assert something, we describe what should the state be after the operation has been executed or performed. So here we see there is all these variables, but I guess we're all developers here, so we cannot use variables without defining them or declaring them somewhere.
00:06:43.818 - 00:07:14.280, Speaker A: So let's see how we declare these variables. So my balance will be balance of message sender, which makes sense? Message sender sender tokens and recipient balance is the balance of the recipient. Then we call the transfer and we check the balances again, my balance after the operation, recipient balance after the operation and we do the assertion right.
00:07:14.280 - 00:07:39.470, Speaker A: So if these assertions are true, then it means we've proved the correctness of the transfer function. We prove at least that the balances are increased and balances are handled correctly. Maybe you can see some definition is missing in the code, right? Anybody can see which variable just is mentioned but is never declared.
00:07:39.470 - 00:08:03.820, Speaker A: Yeah, the contract also and some local variables we see the recipient and the amount they're just mentioned here. But actually the compiler would not know what is these variables. So let's handle that.
00:08:03.820 - 00:08:25.914, Speaker A: Let's pass this recipient and the amount as parameters to the rule. So basically rule is similar to a function syntactically and we can pass any parameters to this rule. So now when we use the recipient and the amount in the call to smart contracts transfer compiler knows what it is, it is this parameter to the rule.
00:08:25.914 - 00:08:54.598, Speaker A: And the way Sartora Approver works, you can think about it as if Sertora Approver will try all the possible combination of these parameters, all the possible amounts, all the possible recipients. Of course, it's impossible to actually try all the possible amounts, it will take long time, but because we use logical formulas, then we can think about it as if trying all the possible values here. But there is still another thing which we didn't declare.
00:08:54.598 - 00:09:20.978, Speaker A: And this is the message sender. So what is this message sender? We all know message sender from solidity but in Seville it's just a little bit different. Before we talk about that, we should mention that these variables like recipient and amount, they can also be declared inside the function inside the rule and it's identical syntax, just different syntaxes to express the same thing.
00:09:20.978 - 00:09:56.030, Speaker A: Just declare these variables for the compiler, so we see we can pass it as parameters to the rule, we can declare them inside the rule, we can pass something as a parameter and declare another variables inside the rule, it's all the same, doesn't matter. So now let's talk about message sender. So the actual syntax in CVL, so in civil, to refer to the environment variables we use a data type called env struct.
00:09:56.030 - 00:10:28.482, Speaker A: And this struct contains all these variables that are built in in solidity. So in solidity you can use MSG, sender, MSG value block number, et cetera in CVL because it's not solidity, it's different execution model. So we use this env struct and we can refer to message sender, message value and block number and the others as fields of e of this env struct.
00:10:28.482 - 00:10:53.102, Speaker A: So env is the data type and e is the instance, right? So to take the message sender balance, we just say balance of e MSG sender. We just have to make sure that the e is declared so the compiler knows what we refer to. And another thing, another thing where another important way we use the environment.
00:10:53.102 - 00:11:22.598, Speaker A: We have to pass it to some smart contract functions. So when we call transfer, we need to give it the environment as well because the transfer depends on what is the message sender value, what is the MSG value, what is the MSG sender. So we need to give the environment and then what happens is approver tries the transfers with all different environments, different message sender.
00:11:22.598 - 00:11:36.458, Speaker A: It will try everything. So now a rule is complete, but there is still something is missing. What is missing is the declaration of this smart contract calls.
00:11:36.458 - 00:11:53.966, Speaker A: So we know that ERC 20 includes balance off. We know that ERC 20 includes transfer, but we also need to declare them for the CVL compiler, right? So how do we do that? We use methods block. So here is an example of a small methods block.
00:11:53.966 - 00:12:12.870, Speaker A: And in this methods block we have a declaration of balance off. Now you will see some keywords that you are not familiar with from Solidity, which is env free. What does it mean? Env free means that we declare functions that don't use the environment.
00:12:12.870 - 00:12:22.186, Speaker A: They don't care about message sender, don't care about message value. Usually it's going to be view functions. Like here we have balance off, we have allowance.
00:12:22.186 - 00:12:42.290, Speaker A: These are view functions, they don't change anything, they don't care about the environment. So we declare them in methods block as env free. And it means that when we invoke these functions, when we call these functions from the rule, we don't need to pass the environment of these functions.
00:12:42.290 - 00:13:05.340, Speaker A: That's why you can see here that when we call Balance Off, we don't send the environment, we just send this parameter with the address MSG sender. At the end of the day, it's an address. But when we call the transfer, we need to pass the environment on top of the usual transfer parameters, which we all know, which is the recipient and the amount.
00:13:05.340 - 00:13:23.602, Speaker A: Okay, so now we wrote the message block, now we have the message block, now we have the rule. And let's see what happens when we actually execute this rule with the Sertora Approver. This is the output, this is the output of the tool.
00:13:23.602 - 00:13:40.614, Speaker A: So when we run the rules, it gives you a web page which is dynamically updated with the execution results. And we see on the left side the name of a rule was Transfer. Here.
00:13:40.614 - 00:13:46.734, Speaker A: It's called transfer spec. It should be transfer. And we see that the rule failed.
00:13:46.734 - 00:14:42.726, Speaker A: We see this scary red icon. So what could be the problem in this rule? Can anybody say why is this rule incorrect? Why is there counterexample self transfer? Yeah, there is a problem here with self transfer because there is a problem with self transfer. But let's see how Sertora Approver helps us understand the problem, helps us understand the so when it shows as a counterexample, it shows what is the state of the local variables in this counterexample.
00:14:42.726 - 00:15:01.618, Speaker A: So if you see here we look at the recipient and we look at the message sender, we see they are one and the same. It's zero x 401. So it kind of gives us a hint that the problem here is with self transfer, right? If we zoom in on the local variables, we see the same thing.
00:15:01.618 - 00:15:25.254, Speaker A: So the problem is, yes, if we send the token to ourself, the assertion says my balance after should be my balance before minus the amount. But obviously if we send the token to ourselves, the balance stayed the same and this assertion is incorrect. So this is how the Certora approver shows as a counterexample in this situation, of course, the problem is not with the smart contract code, the problem is with the rule.
00:15:25.254 - 00:15:42.660, Speaker A: It's just not written correctly. It doesn't take the self transfer scenario into account. So how do we handle that? It's very common, very common scenario because a rule is mostly correct.
00:15:42.660 - 00:16:01.160, Speaker A: There's just one situation where it's not correct. So what we do, we add the require, we say let's only look at the scenarios where the message sender is not equal to recipient. Let's ignore completely the scenario where message sender is equal to the recipient because it's not interesting for us.
00:16:01.160 - 00:16:22.410, Speaker A: And for this we use the require keyword, which basically kind of a precondition. So here we have a precondition, here we have the operation and here we have the post condition. And when we run the rule with this requirement, it will succeed.
00:16:22.410 - 00:16:35.010, Speaker A: Because now it's is this for most of you, it's the first introduction to CVL. This is how rules look like. This is how we write the rules.
00:16:35.010 - 00:16:51.320, Speaker A: We went over rule declaration, variable definition, methods, block and what is the NVA variable? So this is basic intro to CVL. Congratulations. Now you've already seen CVL and know the basis of it.
00:16:51.320 - 00:17:13.674, Speaker A: Now let's do something a little bit more complicated. Now let's move to another rule where we want to say that whenever transfer is called, the recipient's balance always increases. What we do is we take the balance before balance of the recipient.
00:17:13.674 - 00:17:29.890, Speaker A: Then we transfer to some tokens to the recipient, some amount of tokens, then we take the balance again. And then our assertion is that the balance after should be greater than balance before. So I guess most of you already see what can be problematic with this rule.
00:17:29.890 - 00:17:50.086, Speaker A: When the amount is equal to zero, then this inequality will not hold because the balance after will be equal to balance before. So what do we do about that? Like we mentioned before, we can add the require. So we just require the assumption.
00:17:50.086 - 00:18:09.310, Speaker A: We can say okay, let's require that the amount should be greater to zero and then the Sertora prover will ignore the scenarios where amount is equal to zero. We'll not look at these cases. Another thing we can do is use an if statement, which is a little bit clumsy, but it also works.
00:18:09.310 - 00:18:21.170, Speaker A: So we say if the amount is greater than zero, then balance after. We assert balance after is greater than balance before. If the amount is not greater than zero, then we don't care, we just return.
00:18:21.170 - 00:18:42.650, Speaker A: True, but there is a more elegant way in CVL to express this if statement. And this way is to use an implication which we use. Basically it's quite common to use with CVL implication is a logical operation which is not present in solidity but it's very useful for assertions.
00:18:42.650 - 00:18:50.398, Speaker A: So just a reminder implication. This is the truth table of implication. So it's always true.
00:18:50.398 - 00:19:04.370, Speaker A: But only if false predicate implies true predicate, then the whole implication is sorry. If the true predicate implies false predicate, then the whole implication is false. It's true in other cases.
00:19:04.370 - 00:19:32.854, Speaker A: So this is the syntax for implication and it's short and it's elegant way to express this kind of assertions. So we say if the amount is zero implies that the balance after is greater than balance before. I think we all can agree that it's more elegant syntax and more readable than using if statements and it simplifies the rule because we don't need to use the requires at the beginning.
00:19:32.854 - 00:20:04.594, Speaker A: So basically we define oral logic in this implication, right? But what happens when we run this? We will still get some error and what is the error? Yeah, the self transfers that we had before when the recipient is equal to message sender. So how do we fix the error? Yeah. Now, we already know a few ways how to fix this kind of error.
00:20:04.594 - 00:20:19.226, Speaker A: So again, we can add the require that says recipient is not equal to message sender. We could also use an implication. It's not in the slide, but also implication could be added here.
00:20:19.226 - 00:20:48.660, Speaker A: It just would make it a bit more clunky, this assert in the end. So basically implication is like an if statement where the else block contains assert true and just to summarize the ways to work with assumptions, either there is a require as a precondition or we use implication in the assert. Okay? So questions until now everything seems clear.
00:20:48.660 - 00:21:12.982, Speaker A: Awesome. So now let's move to another syntax, another part of CVL syntax which is revert. So in general in general, if we use the syntax that we looked at until now, like precondition operation, post condition, the proverb only looks at non reverting path.
00:21:12.982 - 00:21:46.994, Speaker A: So if during the execution of smart contract it did the revert, then the prover completely ignores this execution path. It will only look at the pathes where there was no revert. So in this example, this is a bit counterintuitive so let's look at this function foo which reverts if the parameter is ten and now we write a CVL rule which is supposed to test foo so we invoke foo with ten and we say assert false.
00:21:46.994 - 00:22:14.042, Speaker A: So assert false of course means that the rule will fail because we can never assert false and expect true but the rule will succeed. Why? Because when we invoke four with ten it always reverts so the Sertora approval will always ignore this execution path and it will never reach this line. It will never reach this line and the rule will succeed.
00:22:14.042 - 00:23:21.260, Speaker A: So this is a bit counterintuitive part which important to remember that it all interesting question how do we handle try and catch if the if the revert is caught inside the solidity code, so then internal revert is equal to normal revert and then it will be considered the reverting path.
00:23:43.420 - 00:23:46.130, Speaker B: Function catch extra.
00:23:48.820 - 00:24:49.090, Speaker A: Function, right? So we see that the approver normally will consider non reverting paths, but sometimes it's very important to consider reverting passes as well. So of course code, sometimes we have to verify, we have to prove that the code reverts correctly corrects when we expect it to reverts when we expect it to revert and doesn't revert when we don't expect it to revert. So how do we look at reverting passes as well? So CVL has a syntax for that and the syntax is we invoke the function with this little addition add with revert.
00:24:49.090 - 00:25:20.978, Speaker A: So this keyword tells the prover to consider all the passes both reverting and non reverting. And how do we know if this function call reverted or not? So we have this boolean variable last reverted, which is another keyword in CVL, and this boolean variable just holds the result of the previous function call. It's true if the previous function call reverted, it's false if the previous function call did not revert.
00:25:20.978 - 00:25:55.454, Speaker A: So this is an example of a rule that uses this syntax. So it says user must not be able to transfer more tokens than they own. So what happens is first we had a precondition that says the balance of the sender is less than the amount, right? So obviously we cannot transfer more tokens than our balance, right? So this transfer should revert and then we call transfer this invalid amount and we expect, we assert that this call reverted.
00:25:55.454 - 00:26:23.366, Speaker A: Yeah, that the last reverted is true again, because the amount is too large, because the amount is larger than our balance. But when we use reverse, there is a lot of small nuances because function may revert for several reasons. We expect it to revert because the amount is too large, but it may revert for many other different reasons.
00:26:23.366 - 00:26:56.518, Speaker A: And it's important to remember when we work with reverting passes now we will look at different scenarios where the function, where the simple function transfer reversed for many different reasons. So first of all, first of all, when we execute this rule, we will okay, so now we do it a little bit different rule. Now we say the balance is legitimate, right? We transfer with revert and we assert that the call did not revert, okay? Now the balance is greater the amount.
00:26:56.518 - 00:27:20.234, Speaker A: So we are allowed to transfer this amount, but we say, okay, let's consider the reverting passes as well as non reverting. And we assert that there was no reward because it looks good, our balance is good enough and we try to transfer tokens, but we're still going to get a lot of rewards. Why? So the first rewards will be because message value is zero.
00:27:20.234 - 00:28:00.330, Speaker A: Is not zero, sorry, right, because message value means there was some ether value sent to this function to transfer, but the transfer is not payable, right? So it will revert because it doesn't know what to do with this ether sent to it. So normally when we don't use this at with revert, the proverb would ignore all these kind of scenarios, but when we explicitly tell it, don't ignore reverting passes, it will find us all the possible rewards. So because MSG value is part of this variable of E, and like we mentioned before, sertorial proven will try all the possible combinations.
00:28:00.330 - 00:28:15.374, Speaker A: Of course it will try E with all values of V, including where message value is one, two, whatever is greater than zero. So here it reversed because message value is not zero. Okay? So we fix that.
00:28:15.374 - 00:28:36.850, Speaker A: We say require message value is zero, and we expect it to work. But no, it will not work because now it will revert due to overflow, because when the recipient balance is too large is almost maximum. And when we try to send the recipient three tokens, now we get an overflow.
00:28:36.850 - 00:28:57.126, Speaker A: And now, because let's assume that we use the new solidity, newer solidity versions, which checks overflow by default, so it will revert because it cannot add three to this max uint minus one. So it reverts again. So now, okay, let's add this condition.
00:28:57.126 - 00:29:17.460, Speaker A: Let's add this precondition. Let's say, okay, balance of recipient plus amount should be less than max uint, so we don't get overflow, but now we get a different revert. And what is the different revert? It says Message sender is zero, right? Because most of the ERC 20 tokens, they do not allow transferring tokens from zero or to zero.
00:29:17.460 - 00:29:44.054, Speaker A: And Certora approval is going to try all the possible values of environments. So of course it will try the environment where the message sender is zero because we didn't explicitly tell it not to try. So now we have to add this condition require message sender is not equal to zero, but we're still going to get a reward because the recipient is zero only after we added all these preconditions.
00:29:44.054 - 00:30:04.770, Speaker A: Now we can run the rule successfully. And what is the point of all this? The point of this is to explain that when we work with reverting passes, usually there is many of them and sometimes there is more than we expect. So every time we have to look, why did we get this revert? Is it interesting? To us, these cases are not so interesting.
00:30:04.770 - 00:30:15.586, Speaker A: So we just have to add a precondition and filter them out. So there's a lot of nuance, there's a lot of work involved with working with reverting passes. It's more complicated.
00:30:15.586 - 00:30:39.920, Speaker A: Yeah. How long does it take to run a rule? It depends on the code complexity. So, for example, the simple ERC 20 code running a rule would take maybe 30 seconds, a minute, but when the code is very complex, it can take even an hour.
00:30:39.920 - 00:30:50.722, Speaker A: It really depends. And sometimes even we can get a timeout. Like the proverb might not be able to prove the formula if the code is complex enough.
00:30:50.722 - 00:31:01.910, Speaker A: And then it's a very advanced topic. How to make the code simpler, how maybe to split it into modules, maybe simplify some code. Yeah, it happens often.
00:31:01.910 - 00:31:06.322, Speaker A: In real time. Real code, not the demo. ERC, 20 token.
00:31:06.322 - 00:31:58.384, Speaker A: Yeah, you mean the message? No, we don't have the message but we use the trace call trace and the variables to understand why it reverted. So the summary of with revert and last reverted so basically when we use at with revert we tell the tool to get to the assert even when no non reversing passes exist last reverted can be used to check situations. It should revert fairly easily and checking all these liveness properties is less straightforward like we showed, we have to look at a lot of nuances and add a lot of requires.
00:31:58.384 - 00:32:22.780, Speaker A: It's common. So another how to say check spot we finished another part of the explanation of several so we went over transfer spec check addition of transfer rule transfer revert transfer does not revert. We already seen example of four rules.
00:32:22.780 - 00:32:40.080, Speaker A: We explained the env variable in more detail and we explained with revert and last reverted and now Sasha will explain another parts of another civil features.
00:32:50.360 - 00:33:15.692, Speaker B: Hi everyone, I'm Sasha also work at now I'll continue euro's talk about other features of the Seville. He explained you, he showed you the properties that we can verify over the transfer but in ERC we know there are also many other things, for example allowance and how confident we are about allowance that it's correctly. Well, it's ERC and we know that it's okay.
00:33:15.692 - 00:33:26.812, Speaker B: But let's say you got a new token, you don't know what's going on there, we also need to check it. Then we start to write a simple rule. We start with defining the rule.
00:33:26.812 - 00:33:45.056, Speaker B: Then we usually prefer to start it's like a good practice from the assertion where you express your formula. For example, here we want to say that if allowance was changed then the message sender was the owner. Pretty simple, but also it can help you to understand what do you need for your rule.
00:33:45.056 - 00:34:12.348, Speaker B: For example, we definitely need to call approve because the properties that we want to verify is for now it's only on approve. We defined the necessary variables to call it and we made a call to approve itself and the only thing that's left is allowance before, allowance after simple call, simple rule. If we run it in our tool, we will get it as verified.
00:34:12.348 - 00:35:09.788, Speaker B: But what does it mean in general? And now it's the time to talk about the coverage. It's like one of the important property of our properties that we try to improve this part to make the coverage more like if the contract is covered, like 100% that we know it's like the perfect it's not easy to reason about it, but we try to do our best. So according to that rule, we can say is it that? Does it increase the coverage, is it well written, is it passing? It might be objective but we should do our best to improve the coverage and what we can say the coverage of allowance the good thing that we proved that approved is only called by the owner that's good but what about other functions? There are many other functions, and they can change allowance.
00:35:09.788 - 00:35:20.836, Speaker B: One approach is like the most straightforward, but the most tedious. You write specific rule for each function of our contract. Let's say you decided you don't want to check.
00:35:20.836 - 00:35:28.644, Speaker B: Few functions because they don't change anything. There are still many like transfer from increased decrease. Allowance might be tedious.
00:35:28.644 - 00:35:38.296, Speaker B: And we have a better way, a simpler way to do it. We introduce notion of parametric rule. They don't.
00:35:38.296 - 00:35:51.936, Speaker B: Ask if the owner called a specific function. Instead, we ask if any function was called and what the outcome of that call. This is the rule we have is very specific.
00:35:51.936 - 00:36:17.876, Speaker B: We want more generalized. And the question how? We can do it instead of proof we want to call any possible function of a contract for this we use method F method is a keyword it means that instead of F the tool will try to use any public or external functions of the contract. I want to state it only public and external.
00:36:17.876 - 00:36:43.084, Speaker B: So if you have something private or internal, you need to change the visibility or make another function which calls it like you create. A public function which calls your internal function, then we need to define the arguments of the function and they can be different here. You don't need to specify it because we have another keyword called data arc.
00:36:43.084 - 00:36:59.824, Speaker B: It means that the tool automatically will assume necessary arguments for each function. Like, if it's like only one address as an argument, or it's like unint another address, we don't care right now. The rest we simply copy from the previous.
00:36:59.824 - 00:37:30.030, Speaker B: Version of the rule where we did it only for approval only and now let's try to run and see the magic happens on the left side you can see all the function that our tool try to call and we are the only one. But there is one red dot that we don't really like because it's a violation. I mean, if it's a bug, it's good because we prevented it, but it also might be in feasible state.
00:37:30.030 - 00:37:47.616, Speaker B: Here we see that it's like we transfer from and it's legitimate way to change the allowance as we know it. But let's try to understand what's the real reason of it. And in our verification report we can get a call trace.
00:37:47.616 - 00:38:01.130, Speaker B: The call trace we get only for violations. To see the scenario, to understand in what way we could to violate the property and to understand if. It's the bug in the spec that we wrote or it's in the bug in the code.
00:38:01.130 - 00:38:51.880, Speaker B: Here we see the arguments that we used for transfer from the sender is 401 the same as owner, recipient is F and also we want to check the emessage sender because this is what we use in our assertion and as we can see here, it's another address, it's four to six. That's why we've got a violation because the sender is stated in the transfer from the same as owner. But the message sender is not an owner right now and what we can do about it because we have a violation but it's not a problem code we can change our property a bit and the way to do it that instead of saying that allowance is changing, we want to ensure that if allowance was increased, then the message sender should be the owner.
00:38:51.880 - 00:39:13.404, Speaker B: Any questions at this point? Okay, now if we run it, we see that it's passing. Well, that's good. We checked something and when we increase allowance in allowance but there are still some unverified parts about other functions.
00:39:13.404 - 00:39:28.352, Speaker B: For example, how we can change allowance. One proposal that we have is to check if allowance was changed by specific functions. And for this thing we use another feature of CVL.
00:39:28.352 - 00:39:40.090, Speaker B: It's called method selector. The most of the rule we take from the previous version but we change the assertion a lot. Here we see if allowance before and after different.
00:39:40.090 - 00:40:13.920, Speaker B: Then we check using the selector f selector equal then the function signature selector and we know like for example, we could read the code and see what changes it briefly like approve transfer from increase decrease allowance we check it here. We can use them in one block with or we cannot use and because in any specific run f can be only one method. So that's why we use the or and if we run it, it will be verified.
00:40:13.920 - 00:40:32.600, Speaker B: So we again increase the coverage. Now we're more sure that there is no other way to change allowance. We are more confident here and we covered the main things about the rules.
00:40:32.600 - 00:40:41.912, Speaker B: But the rule is only one thing which we use to explain our properties. There is another thing. We call it invariant.
00:40:41.912 - 00:41:00.592, Speaker B: It's a property of the contract state that is expected to be true whenever a contract method is not currently executing. As I said, it's like another way to write the properties but it's only applicable for several types of them. The types of the properties is not a part of this talk.
00:41:00.592 - 00:41:17.236, Speaker B: But in general we can reason about valid states of a contract and high level properties. By high level properties we usually mean if we reason about external dependencies or not dependent on the implementation. On implementation, some properties they are not dependent.
00:41:17.236 - 00:41:28.648, Speaker B: Like in ERC, the total supply should be greater or equal to the balance of one user. Just like the simple example. Like some benefits of an invariant.
00:41:28.648 - 00:41:47.708, Speaker B: Usually it's smaller in the size because it's smaller in the size. It's one of the reasons because why it's really comfortable, it also covers a bit more than a rule, because the rule doesn't cover the state after the constructor. Invariant can do it invariant.
00:41:47.708 - 00:42:18.484, Speaker B: We also can rewrite as a rule every invariant, but not every rule can be rewritten as an invariant. And one of the main disadvantages if you want to check any specific scenario, for example, in a parametric rule, I showed you that we can call only method F, but you can define method F and method D and to see some other interesting outcomes of it. This is an example of the properties that I already defined, that the total supply is greater or equal of balance of a user.
00:42:18.484 - 00:42:30.564, Speaker B: And on the top you see the invariant itself pretty simple, like only two lines of code. And this is how it looks in a rule. And also it can help you to understand what is an invariant.
00:42:30.564 - 00:43:01.272, Speaker B: Invariant is simply the requirement that we defined then any function call, parametric call, and then the same assertion this is how it looks like. But there are several violations we won't stop a lot about how to fix, because invariant is more like additional topic for this workshop. But I want also to show you the benefits of invariant in terms of the size and comfortability to use it.
00:43:01.272 - 00:43:23.392, Speaker B: Because for example, the first thing that we will see in that violation that in our assertion right now we assume only balance of one user and the contractual will be like the total supply equal to balance of a user. But what about all other users? They also can transfer, do something. And this is what happened in the contract example.
00:43:23.392 - 00:43:45.812, Speaker B: For that rules we change a little bit our invariant. Now we assume two invariants, but there still will be the violation in transfer, because it's a parametric call and two and emessage sender in transfer, they can be different from the addresses that we check. And this will be the violation.
00:43:45.812 - 00:43:58.132, Speaker B: In this case, we need a preserved block. It's just a set of requirements that will be applied only for transfer. This is how it looks in invariant.
00:43:58.132 - 00:44:20.460, Speaker B: We need to make sure that the two equal to account from our invariant and the message sender equal to our sender, that the balance of we check. But if we try to write the same in a rule, it takes much more space, much more lines of code, not really comfortable. Of course you can put this if block inside the rule, but then the readability will be awful.
00:44:20.460 - 00:44:48.090, Speaker B: It's better to make as a separate function. But here we need to use again selector, define variables, write some constraints, and then we need to call the transfer. So you write the transfer two times instead of one time here, for example, but it doesn't mean that if you define this function, it's always the bad thing.
00:44:48.090 - 00:45:05.600, Speaker B: For example, it's good in reusability. If you need to use this function in several rules, like welcome to do it, it's a really good thing because you optimize the size of your code. And as I said, not everything we can express as an invariant.
00:45:05.600 - 00:45:27.160, Speaker B: And this was an example, just only for transfer, for all other functions which had violations kind of the same. The main point is just to show you another feature of CVL, how to explain the properties and why it might be good to use it for now. That's it.
00:45:27.160 - 00:45:44.910, Speaker B: We covered many things, there are still more things to do, but they are more advanced. And it's advanced topic not of this workshop, we wrote the simpler rules, we saw how it can be written. We talked about environment, variables, methods, block and what does it mean, environment and then free.
00:45:44.910 - 00:46:10.230, Speaker B: We considered reverting paths, parametric rules, how we can select methods in parametric rules. We talked a bit about the coverage, which is kind of a subjective thing, and the last feature was the invariance. Now I think the Euro will take over to talk about the workshop, the practical part of it.
00:46:10.230 - 00:46:11.830, Speaker B: Thank you.
00:46:17.100 - 00:46:39.144, Speaker A: So we went into a lot of several features, a lot of theoretical stuff, and now let's try to do some hands on work. Yeah, so we're going to work on Open Zeppelin ZRC 20 token contract in which we inserted some bugs, really simple bugs. So if you look at the solidity code, you will see the bugs immediately.
00:46:39.144 - 00:46:52.600, Speaker A: They're not super interesting. The interesting part is to try to find the bugs using formal verification. So the task will be to write a unit test rule which verifies transfer and the parametric rule.
00:46:52.600 - 00:47:01.348, Speaker A: And then there is a bonus task which is a bit more complicated. Parametric rule. Yeah.
00:47:01.348 - 00:47:38.540, Speaker A: So what we're going to do so first of all, you should have the docker desktop on your laptop and you should clone our tutorials repository. So can the people who participate in this exercise raise hands? Okay, so the people who will participate in the exercise so follow this step. So start the docker desktop, then clone the repo.
00:47:38.540 - 00:47:56.080, Speaker A: And wherever you run into some issues. So we have Sasha Armand here, miri will help you with anything. So clone the repo and just follow the steps on the slide.
00:47:56.080 - 00:49:11.390, Speaker A: So again, people who followed the exercise, please raise your hand if you run into any issue, we will help you. So, yeah, this is the steps you clone the repo. In the repo there is like files which describes what tasks to next sorry, there is also the next slide that explains that you have to go to the CVL workshop folder and see the spec.
00:49:11.390 - 00:50:28.050, Speaker A: So this is the actual exercise. So if you start with people who follow, start with the docker, clone the repo, open the correct branch of the repo switch checkout of the correct branch and then you have to use the reopening container command in Visual Studio code use the remote containers extension. This comment will ask you to download our docker image and then from this docker image you do the exercise, they change the name.
00:50:28.050 - 00:50:52.660, Speaker A: So we're going to do a small change of plans because the internet here is a bit slow to download the docker file. We're going to do some live coding demonstrations how we actually solve the exercise. So it's going to be more clear for you guys.
00:50:52.660 - 00:52:03.420, Speaker A: So our task is our first task is our first exercise is to write a unit test rule that test the transfer function. And we need this assert to we basically need to write a rule that at the end of it this assert will be checked. Right? So how are we going to do that? First of all, like you remember we need to declare the environment and since we test a transfer function so we're just going to call it V some random recipient and amount.
00:52:03.420 - 00:52:50.660, Speaker A: Now we also need to declare this recipient an amount and we need to declare these variables balance sender after and balance sender before. Balance sender before will be the balance of the message sender. So all these functions like balance off and transfer and others already declared in the methods block, there is no need to declare them again.
00:52:50.660 - 00:56:13.420, Speaker A: And the balance sender after will be clearly the balance after the operation. And now the rule looks ready. So according to the instructions we can execute it.
00:56:13.420 - 00:56:43.178, Speaker A: We have already script the script just runs the Certora run command CLI tool and we tell the sertora run to verify the ERC 20 contract with the setup spec. So like we mentioned at the beginning of the talk to the Certora approver, we have to give the smart contract code and the rules. So here this is the smart contract code and these are the rules.
00:56:43.178 - 00:57:10.162, Speaker A: So what happens here is that there is some kind of static analysis happening locally and then the tool sends everything to the cloud. So the main chunk of the tool runs in the cloud, just some small local static analysis runs on the computer and most of it runs on AWS. And here we get some command line outputs.
00:57:10.162 - 00:57:53.398, Speaker A: Eventually it will give us the link to the web page where we'll see the execution results. Here we have a link to the status page and verification report which is the interesting part. So we're going to click on that and see that the transfer correctness function which we written, which we're writing right now has failed.
00:57:53.398 - 00:58:35.270, Speaker A: So it's interesting to find out why it failed and we open the call trace. Okay, so in the beginning the balance was two and then we tried to transfer 15 tokens, which is not supposed to work because with a balance of two, we should not be able to transfer 15, but it still did not revert. So there is some problem there because like we mentioned, the Certora will only look at non reverting pass and normally if the code is good and you try to transfer 15 tokens from balance of two, the code would revert.
00:58:35.270 - 00:58:48.880, Speaker A: But here it did not revert. And now we look at balance sender after and it's become huge. So it's obviously an underflow here.
00:58:48.880 - 00:59:09.720, Speaker A: It's obviously an underflow. So this assertion doesn't hold because now balance sender after is huge. It's almost maxi inch and balance sender before was very small zoom.
00:59:09.720 - 00:59:34.480, Speaker A: So we see the possible problem is with underflow. So now we can go look at the code. What is this bug that you found? And it's a very silly bug.
00:59:34.480 - 01:00:11.040, Speaker A: So basically what we did is what we did is we just say unchecked, we do this transfer unchecked. We don't check that the sender has enough balance to send the tokens and we do unchecked subtraction. So that's why we have this underflow problem.
01:00:11.040 - 01:00:26.162, Speaker A: And the point is that we found this bug not by looking at the code. We found this bug by writing a very simple rule. We call it the unit test rule because it just checks one function, one particular scenario.
01:00:26.162 - 01:00:40.426, Speaker A: And the Approver found this problematic case for us. We just try to send too many tokens and the code doesn't check that the balance is sufficient. So that's why we have this problem.
01:00:40.426 - 01:01:57.542, Speaker A: So this is the exercise one's makes sense I think usually the code should check if the balance is sufficient for the transfer and I think I just removed this check require that the balance is greater or equal to the amount but when there is no check it just says okay, we have enough tokens let's go. Now for exercise two we want to write a parametric rule that verifies fixed total supply. So we assume that we work with a token that has fixed total supply and we want to write a rule that says no function call ever can change total supply.
01:01:57.542 - 01:02:58.540, Speaker A: This is a bit more interesting rule so how we're going to do that? This is our final assert. So again we do environment method method as we already have. Let's do call data arcs for the F invocation let's get the total supply before total before this total supply function is already defined, declared here in the methods block it's just access to the public variable and now the magic part is calling any function with any arguments and again it will take the total supply after the operation.
01:02:58.540 - 01:03:35.986, Speaker A: And this is a rule that's a very good question but this would require much more rule writing than we can do now. Basically for this we would need to track locally if the total supply variable is updated correctly. For this we would use a local state in CVL which we call ghost ghost variable.
01:03:35.986 - 01:04:35.872, Speaker A: Basically we would have a CVL variable which tracks the solidity variable. It requires a bit of yeah, you're right. If you want to really work, verify everything we need to prove that the total supply variable is updated correctly.
01:04:35.872 - 01:06:48.720, Speaker A: After we prove that, we can already use this proof and use the total supply variable and assume that it's true. Now, when it finished checking this is the total supplies fixed rule also failed. And it failed on a few different functions on Approve, on transfer from, on cruise allowance, decrease allowance.
01:06:48.720 - 01:07:03.560, Speaker A: So let's see the first one white felt on Approve. So when we ran Approve, the total supply was 15. Then we executed this generic function F, which in this particular case was approved.
01:07:03.560 - 01:07:11.950, Speaker A: And then we see that the total supply changed. It became 17. So something happened inside the Approve function.
01:07:11.950 - 01:07:35.216, Speaker A: And if we drill down the cold trace into the deep inside Approve, we see that for some reason something changed in total supply. So this cold trace gives us a place to look in the code. It tells us to look at function underscore Approve.
01:07:35.216 - 01:08:06.266, Speaker A: Maybe something wrong is going on there. So let's check this function in the solidity code so we can see immediately that the total supplies just increased. The Approve just increase the total supply by the amount asked to Approve.
01:08:06.266 - 01:08:12.340, Speaker A: So it's a very silly code. Again, the idea is to show.
01:08:14.390 - 01:08:14.754, Speaker B: How.
01:08:14.792 - 01:08:36.438, Speaker A: We can find the bug, not by looking at the code, but by writing a very generic rule that the total supply should not change. And immediately we see that the Approve function does something suspicious, changes the total supply for some reason. And obviously the increase allowance, decrease allowance and transfer from they also call this underscore Approve.
01:08:36.438 - 01:09:15.030, Speaker A: So it's all the same bug. And we found a problem in the code just by writing a very short, very concise parametric rule that says check total supply, do any operation, check total supply again and make sure they're equal. So this was the second task questions.
01:09:15.030 - 01:10:22.680, Speaker A: And now let's do the third exercise, which is the can transfer balance. Basically it's a rule that says that any user can transfer their entire balance out. You require that, but you can do your way as well.
01:10:22.680 - 01:13:13.290, Speaker A: We did this transfer with Revert, which we discussed in the presentation. It requires a lot of preconditions to make sure that we don't get reverts on things that don't interest us. All this stuff, we don't care that if the message sender is zero, recipient is zero, stuff like that.
01:13:13.290 - 01:17:17.000, Speaker A: So now the execution, the verification completed and we can go to the report and look at this can transfer balance rule. Bakhta question to tip sender doesn't. But list as a tiny mushroom.
01:17:17.000 - 01:17:41.000, Speaker A: It problem with white stone to the new bug. That quite malicious.
01:17:51.200 - 01:18:00.980, Speaker B: Contact page send message message.
01:18:01.390 - 01:18:24.334, Speaker A: Um can transfer balance to tip on.
01:18:24.452 - 01:18:37.310, Speaker B: Yeah to PPTP switch no web page learning browser which I want to set the switch.
01:18:57.400 - 01:19:03.460, Speaker A: Methods. While okay important the committee.
01:19:07.240 - 01:19:25.920, Speaker B: Shows curriculum it's just.
01:19:29.970 - 01:19:31.520, Speaker A: Private at least come.
01:20:11.550 - 01:20:11.914, Speaker B: More.
01:20:11.952 - 01:20:15.290, Speaker A: Loop addresses optimistic loop.
01:20:18.230 - 01:20:19.620, Speaker B: Android I.
01:20:24.790 - 01:20:25.438, Speaker A: Prepare.
01:20:25.534 - 01:20:34.690, Speaker B: We are deciding walking through quiet.
01:21:14.940 - 01:21:15.620, Speaker A: Validated.
01:21:15.700 - 01:21:22.140, Speaker B: For can transfer bounce valuation.
01:21:25.620 - 01:21:26.960, Speaker A: Just the keys.
01:21:30.260 - 01:21:37.120, Speaker B: Yeah, transfer culture transfer keys.
01:21:40.280 - 01:21:45.572, Speaker A: It wetlist. Why did you write list?
01:21:45.626 - 01:21:46.230, Speaker B: Beautiful.
01:21:49.080 - 01:22:26.256, Speaker A: So our final task was our final exercise was to write a rule that verifies how a user can transfer the entire balance out. And what we did, we added all these requires for all these preconditions for cases that don't interest us, so we don't fail on message center zero, recipient zero or message value greater than zero. So we filter all the things that are not important, and then we just call transfer with revert and assert that there was no revert, because all the conditions are correct for a transfer.
01:22:26.256 - 01:22:57.340, Speaker A: But we still see that the function failed, the function reverted. And when we drill down the call trace, we see that there is a line, something about whitelist in the smart contract code line two seven nine. So we will go to the Smart contract to the line two seven nine, and we see that the transfer function in this token, it requires the sender to be whitelisted.
01:22:57.340 - 01:23:21.888, Speaker A: So only whitelisted addresses can transfer. That's why we got to revert, because actually this is like an example for a malicious token that doesn't let addresses transfer tokens out unless they're whitelisted. So there used to be like rug pool tokens like this maybe a couple of years ago.
01:23:21.888 - 01:23:30.176, Speaker A: You can buy this token, but you can never transfer it out. You can never sell it. So this is another example that this is not even a bug.
01:23:30.176 - 01:23:53.870, Speaker A: This is kind of an example for a malicious code. And we can easily detect it with a simple rule that tests that users just can transfer their balance out, right? And the proverb immediately finds a counter example. Any address like here 40 one, it's not whitelisted, so it cannot transfer the tokens out.
01:23:53.870 - 01:24:35.050, Speaker A: This concludes the hands on exercise, which unfortunately difficult to do without slow WiFi and without installing all this docker image. But you can see how it's possible to write this, how to possible how it's possible to write the rules on the faulty ERC 20 token and detect all the three bugs which were inserted into it by the rules, which are quite simple. This is into.
