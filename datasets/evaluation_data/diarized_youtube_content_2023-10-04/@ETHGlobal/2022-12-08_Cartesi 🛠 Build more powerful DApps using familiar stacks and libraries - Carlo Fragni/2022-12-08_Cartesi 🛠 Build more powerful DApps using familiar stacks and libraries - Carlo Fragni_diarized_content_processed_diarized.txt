00:00:06.330 - 00:00:27.830, Speaker A: Okay, so lovely to be with you guys. My name is Carlo, I'm a senior lead solution architect at Cartesi. And today we're going to talk about how can we do things using our tech, right? So basically what we will cover is an overview of Cartesi, an overview of how you can develop with it.
00:00:27.830 - 00:00:51.946, Speaker A: And I'm going to do some comparisons on how you do web free development, web to development, and then how you do it with Cartesi, right? And a quick intro to Cartesi rollups, which is the product we use for enabling our tech. So just an overview of what the stack is about is this. So basically the objective is having this really rich code that you can use for decentralized applications.
00:00:51.946 - 00:01:22.722, Speaker A: So if you develop on Solidity, you probably have faced a lot of issues like the size of transactions or lacking libraries that do stuff that you're usually doing on web two, like parsing a string or something like that, accessing database, all this stuff. And that's what we want to bring. We want you to have the same power and expressiveness and computational power that you have on web two, only available on web three in decentralized fashion, right? So if you take a look in here, this is a really simple example of a DAP in Cartesi.
00:01:22.722 - 00:01:42.086, Speaker A: This is an echo DAP. Basically what it does is whatever you throw at it, it just throws back at you, okay? And if you are into Python, you can see that this code looks just like any regular web two Python code, right? That's because we wrap the whole framework and how we interface with it in a simple HTP interface. And that has a couple of reasons.
00:01:42.086 - 00:01:59.630, Speaker A: Because most developers, they are not web three developers, right? You have a really steep learning curve. And in order to make it easier for web two developers to onboard, we made this decision of providing this nice Http interface. You comply to it, you're used to it, and now you have a decentralized application, right? This is just a preview.
00:01:59.630 - 00:02:11.426, Speaker A: I'll just explain stuff and go back to this later. Okay? So let's go from overview of Cartesi. Basically, we're bringing this new OS and we think it's pretty neat.
00:02:11.426 - 00:02:20.902, Speaker A: So we love ethereum. Ethereum has security, it has decentralization with censorship, resistance. We have all these thousands of nodes validating everything.
00:02:20.902 - 00:02:40.122, Speaker A: Anyone wants to tamper with something, it's really hard because you have to lie consistently with thousands of nodes in order to do this. But Ethereum also has its drawbacks, right? Because since everyone on the network is validating everything, it means that all the nodes on the network are producing all the computations. And that makes it very limited.
00:02:40.122 - 00:03:24.154, Speaker A: Because if you have the Ethereum network and you don't have tiny transactions, well, just throw a Y one loop at it, you just halted the entire network, right? Or if you don't make it really expensive like this, well then you can just flood it with useless tiny computations and you halt the network anyway. Right? So the idea on Cartesi is can we get these really nice security guarantees of the blockchain but enable really large computations and also bring better tooling for development? And that's what we go for. So how do we do this? Well, basically what we do is have this special VM we call the Cartes machine.
00:03:24.154 - 00:03:55.010, Speaker A: And this Cartes machine provides a Linux runtime environment and the computations that happen inside Cartes machine are secured by the blockchain. Right? So this cartes machine is based on RISC five. And what happens here is RISC Five is an open hardware specification done by the guys at Berkeley and it's really similar to what we have on our computers, on our cell phones, right? And because of that it's compatible with Linux.
00:03:55.010 - 00:04:09.900, Speaker A: And another thing we do is that unlike in Ethereum in which everything is running on the same VM so the AVM basically is running all the applications. If some applications use more resources using a lot of things, the other ones lose it. We have a VM per application.
00:04:09.900 - 00:04:20.874, Speaker A: So a VM per application with a regular processor and Linux. Well, we just enable a lot of things for you to use in there. And the Cartes machine, in order to do this, needs to be deterministic.
00:04:20.874 - 00:04:32.050, Speaker A: So we put a lot of effort on making this risk. Five based machine deterministic like clock, floating point instructions, all the stuff that could generate entropy. We just had to make it deterministic.
00:04:32.050 - 00:04:56.474, Speaker A: And yeah, as I was saying, to reach this stage in which you have a lot of computational resources, what happens is we rely on local consensus and we have a ropes solution on top of it. So what happens is that unlike an Ethereum in which everyone on the network is validating everything, on Cartesi we have different sets of validators per application. So if you're interested in an application, you can validate it.
00:04:56.474 - 00:05:14.650, Speaker A: If you're not, you just let it go. You don't have to watch and validate everything that's going on in the network. And as I said, so consensus is basically really strong on Ethereum and others because if you want to tamper with a computation, it's really hard to lie because you have a really large amount of nodes.
00:05:14.650 - 00:05:39.234, Speaker A: And I just told you guys that in order to scale, what we do is not everyone validates everything. So you can have a really small subset of the network validating a certain application. So how do we keep it secure? So basically when there's a dispute and you don't agree with result, it's not a matter of a local consensus with the people that are validating that application and you just pick up the majority and that's a consensus? No, what we have is a dispute protocol.
00:05:39.234 - 00:05:57.706, Speaker A: We call it the verification game in which whenever there's a dispute, what we do is basically the people that are disputing. Since they are running the same application on the same cartes machine and deterministic, they should reach the same result. If they didn't, it means that at least one of them did something that they shouldn't.
00:05:57.706 - 00:06:20.102, Speaker A: So we have this interactive protocol called the verification game in which it has two parts. So the first part is it tries to use this cartesian machine on both parties off chain and they post a signature of the state. So we basically pick up all the cartesian machine state with Ram disk, even processor state, like the instruction counter everything.
00:06:20.102 - 00:06:32.342, Speaker A: We map it to Ram and then we divide it in 4K pages. And these 4K pages are hashed and those are the leaps of a mercury. And then this root hash of the mercury tree represents the whole state.
00:06:32.342 - 00:06:44.762, Speaker A: And you use this to check if you agree or not with the state of someone's else cartesian machine. So when there's a dispute, what you pick up is you pick up the whole computation. Let's say you have, I don't know, a million, for instance, cycles on that computation.
00:06:44.762 - 00:07:13.030, Speaker A: So we do an NR search to search what's the first instruction we don't agree on? What we do is, okay, I'm going to post my root hash of the Merko of the cortez machine at 10 million cycles, sorry, 2030, 40, up to 100 and then you're going to tell me, okay, so up to 40 million, I agree, 50 million onwards doesn't match. So now we know the divergence is between 40 million and 50 million. Then we drill down.
00:07:13.030 - 00:07:27.178, Speaker A: So 41,000,042, 43, 44, up to 50 and we go there. And each time we divide the search space by ten. So in logarithm number of interactions, I'll know it's instruction 43,003,007 that we don't agree.
00:07:27.178 - 00:07:49.214, Speaker A: Cool, now we know the instruction we don't agree, but who did it, right? Right, because I'm claiming something, you're claiming something else. That's a real special part. So what we did, and this is the second part of the process, is whenever we reach that instruction, it's not my word against yours, we just pick up that instruction and we have an on chain implementation of the cartes machine.
00:07:49.214 - 00:08:10.550, Speaker A: So we had this huge effort of making an onchain set of contracts that can emulate each instruction of the cartes machine. And this on chain emulator is the one that actually picks up that instruction and executes it. So it's not me, it's not you, it's the thousands of nodes on ethereum or whatever based blockchain we're using that are going to say who did the execution.
00:08:10.550 - 00:08:36.122, Speaker A: Right? So this way we can have a really tiny set of validators and computations, really large ones, but still maintain the guarantees of the strong guarantees of security of blockchain. Right? So as I said, it's an optimistic lob solution in which we built. So basically we do all these computations inside a Cartez machine and from time to time we just pick up the signature of the Cartez machine and put it on chain.
00:08:36.122 - 00:08:44.420, Speaker A: If someone disputed, okay, there's the verification game. If not, we move on. That's set on Stone, and you can keep up the computation for the next stuff.
00:08:44.420 - 00:09:07.414, Speaker A: So how's the development of this? So you guys are used to web two. Web two is really simple. You have a browser, you use some framework like, I don't know, angular or react or whatever you want the tools, HTML, CSS, JavaScript, as based technologies, and you do these nice interfaces, and then you interact with a backend, right? Generally using HTP or HTPs.
00:09:07.414 - 00:09:28.078, Speaker A: And then you have a service, this service might use a database, might use someone else's API, this kind of stuff, right? Really simple. Now, when we go to webfree, we still have a similar front end, but now we need a special library to interact with the blockchain. Generally, we have something that implements the JSON RPC protocol.
00:09:28.078 - 00:09:47.014, Speaker A: So e first web three, JS, something else. And then instead of talking to a backend, this guy is actually talking to the blockchain, like a node on Ethereum or maybe a broker like Infuria or Alchemy or something like that, right? And as you guys know, you have multiple limitations and processing all this stuff. It's very hard to look for data.
00:09:47.014 - 00:10:04.654, Speaker A: That's why we have services like the graph and stuff like this, which are very popular, help you on de indexing and this kind of thing. And how does it look when you develop with cortez? Well, basically you still have your front end in which you use whatever technology you want. So if you have a browser, you can still use Angular, View, or React, all this stuff.
00:10:04.654 - 00:10:29.718, Speaker A: And then you have a set of libraries to interact with the framework, right? And this framework there, then it has a real nice machinery which takes all the abstraction of the verification game of all this stuff from you. And inside the Cortez machine, we actually wrap, as I told you guys, all the framework on an HTP interface. So we have this Http dispatcher service, which is the one that you're talking to when you're developing your application.
00:10:29.718 - 00:10:40.986, Speaker A: So from your development point of view, you're just talking to Http interface, and that's it. You don't have to care about the blockchain, about reorgs, about any of that. We take care of that for you.
00:10:40.986 - 00:11:00.522, Speaker A: Okay, so just going a bit deeper on how this works. So those libraries I said, they basically use three different interfaces. So we still need a JSON RPC to talk to the blockchain, because whenever you're trying to reproduce computation, well, you need the inputs, right? So you have a data availability problem if you're not using the blockchain.
00:11:00.522 - 00:11:09.026, Speaker A: Let's say I'm storing my input on IPFS, for instance, and then you say, I cannot do your computation. Why? I don't have the inputs. Okay.
00:11:09.026 - 00:11:32.502, Speaker A: From the blockchain point of view, there's no way for you to say it's me lying about it not being rPFS or it's you lying that you didn't put it in there. So that's why we need a JSON RPC interface and we provide inputs through the blockchain. The second interface we use sorry, the second interface we use is a HTP Rest interface and that's used for something equivalent to ethereum calls.
00:11:32.502 - 00:11:50.574, Speaker A: Right. So we have this Inspect interface that on this Inspect interface, basically we allow you to directly talk to the cartes machine without any fees, anything, it's just HTP connection directly to it and you can do whatever processing you want to query for state. So let's say you have a chess game.
00:11:50.574 - 00:12:13.014, Speaker A: For instance, if you open an application on mobile phone and you want to know if you have ongoing games and what's the state of the game, you probably need your client to go there and look at a GraphQL with something you're an indexing or go directly to the blockchain. Check that you have a transaction which you started a game. Check all the moves that our players did until you have the current game state and you're actually good to go.
00:12:13.014 - 00:12:34.246, Speaker A: Right, so this Inspect interface is to handle things like that. So instead of doing that, what you do is you go through this Inspect interface, you just call it the cartes machine. You give your address and you say hey, what's up? And then inside the cartes machine you can process it on whatever language you want, python, C, regular backend and then you can check, oh yeah, you have an ongoing game because I started it in the database.
00:12:34.246 - 00:12:45.314, Speaker A: And yeah, this is the game state in a JSON and it's white player's turn. So much easier than just going through the blockchain trying to reconstitute the data or using something like the graph to index a lot of data. Right.
00:12:45.314 - 00:13:01.922, Speaker A: And the third interface in there, which is the graph, is an interface that we use to ease the outputs of the cartesian machine. So the cartesian machine basically use reports, which is something you generally return when you're using this Inspect interface. Then you have notices.
00:13:01.922 - 00:13:17.846, Speaker A: Notices are a mechanism really similar to what we have on Ethereum events. So when you want to have a statement and it makes sense forever, like I want this match or something like this, notices is what you want to go for. And then we have this third interface which is Vouchers.
00:13:17.846 - 00:13:47.666, Speaker A: So what Vouchers are, is a way for you to emit a transaction to interact with the blockchain from within the cartes machine. So, since the cartes machine is deterministic and doesn't have outside interfaces like Internet and stuff like this, inside the cartes machine, you just do your transaction and then you put it on a Voucher. And the Voucher is a really cool mechanism because you query it on GraphQL, anyone can enforce it because after all, it's a transaction that's signed by the application itself.
00:13:47.666 - 00:14:07.370, Speaker A: And then we have an incentive mechanism that when you submit the voucher and enforce it, you get rewarded by it. And we got all these nice smart contracts on the framework that check if the voucher is valid, if it was submitted already, and all these guarantees that we should have. Right, okay, so let's go back to that initial code.
00:14:07.370 - 00:14:14.718, Speaker A: So how does it look like? So basically, this is an eco application. As I said, it's a really simple one. Whatever you throw at it, it throws back at you.
00:14:14.718 - 00:14:26.274, Speaker A: On the left side, we have an example using this front end console that's available on our Apple. So the URL is down here, but you can also query me for that later. Also available on our site.
00:14:26.274 - 00:14:44.898, Speaker A: So it's a simple application done in TypeScript that basically implements all those freeze interfaces I shown. And on the right side we have a basic echo application written in Python. So that's the actual decentralized go, right? So what we have in here, if you take a look, is first we start using this front end and sending a payload.
00:14:44.898 - 00:14:51.158, Speaker A: So hello there. So from the blockchain point of view, we don't know what it is. It's just a binary input.
00:14:51.158 - 00:15:12.046, Speaker A: But your application knows that's a string, right? So inside your application, that's regular Python code, as I said. So we're importing OS because after all, it's a Linux machine. And that service that I mentioned that has all the wrappers in HTP interfaces, well, basically, this server is listening somewhere and we settle an environment variable with it.
00:15:12.046 - 00:15:40.234, Speaker A: So we're using OS environment to load up that variable. And we also use requests so people familiar with Python know it's a really well known HTP library, right? And okay, using that OS now, we're picking up that environment variable so we know where to connect on the Cortesi Http service. And now we have this dictionary here in which we settle Advanced State and map it to a method called Handle Advanced and Inspect State.
00:15:40.234 - 00:15:43.622, Speaker A: And map it to handle inspect. So advanced. State inspect.
00:15:43.622 - 00:15:57.754, Speaker A: State are payload. Whenever you receive an input on the Cartesia machine, it can be from two different sources. So it can be this input that came through the blockchain and is actually advancing your application state, or it can be a direct query.
00:15:57.754 - 00:16:05.562, Speaker A: You do, for example, that chess in which I said, so do I have any game? Something like that. Inspect Host. It will come with this metadata as Inspect State.
00:16:05.562 - 00:16:24.338, Speaker A: So you know it's something that's going to be thrown away afterwards. Right? And the basic structure is you have this infinite loop, and this infinite loop has an iterator, okay? In this iterator, you're doing two things. When you call that finish endpoint, you're putting a payload that's saying what you did with the previous input.
00:16:24.338 - 00:16:35.110, Speaker A: So let's say we're playing chess and I just do a legal move with the queen. Well, it shouldn't happen right? So you refuse this input. So in that payload, you're going to say that the status is reject.
00:16:35.110 - 00:16:45.022, Speaker A: Now if you provide me with a valid input, I'm just going to accept it. And that's the input of this endpoint. Now what's the response? The response only comes when there's something to process.
00:16:45.022 - 00:17:09.638, Speaker A: So once you call this guy, it just pauses the Cartes machine. And the Cartes machine is woken whenever the framework has something new for each process, either Inspect or a new input for the blockchain, right? And well, this response there, then you parse it and as I told you, you have a special header in there, request Type, which can be either Advanced State or Inspect State. And given that, we're going to use that dictionary in there to map to the right method to handle it.
00:17:09.638 - 00:17:19.618, Speaker A: And then we just call this method so Handle Advance, which is the one we call in case it's Advanced State. It's an app application, really simple. So it just picks up the payload that you received.
00:17:19.618 - 00:17:33.454, Speaker A: It creates a new dictionary with a payload entry and putting whatever you received in there. And then once again, a simple call. So you do a post on this notice endpoint with the payload that you've just set on that dictionary and that's it.
00:17:33.454 - 00:17:56.834, Speaker A: You just immediately your first Cartesi event, which is a notice with the payload you received from the blockchain itself and you return accepted because, well, that's valid. So let's go forward. So on the handle Inspect, which is the case for the Inspect API, which is ephemeral, same stuff, only that this time we're picking up this payload and we're putting on a different endpoint on report.
00:17:56.834 - 00:18:08.662, Speaker A: Report is this other interface in which I told you guys that it's meant to be ephemeral. So whenever you do a report, it's not stored, it's not there in forever. It's like an ethereum call response, right? And yeah, that's it.
00:18:08.662 - 00:18:22.858, Speaker A: After you process it, we just set up that finish status to accept or reject and do it again. So now on the left side, once we process this, what happens is we emitted a notice in there, right? Because we just sent this payload through the blockchain. Hello there.
00:18:22.858 - 00:18:37.086, Speaker A: We got in there and a notice was emitted. So we can still use this front end application and use this really nice command yarn start to Notice list. And what this does is it goes to the Cartesian node to the GraphQL interface and says, hey, show me the notices.
00:18:37.086 - 00:18:45.154, Speaker A: And there it is. You're going to have a notice, sorry, you're going to have a notice stating the epoch input and notice index. And the peloton is in there.
00:18:45.154 - 00:18:57.218, Speaker A: Hello there. So epoch is because we are optimistic roll up solution, right? So all these time frames in which we validate stuff and then we roll up those we call epochs. So that's the index of the epoch.
00:18:57.218 - 00:19:11.200, Speaker A: So in a given time frame, you can have multiple inputs, so you have the index of the input and then a single input generates multiple events. Right? So we also have another index for the notice there. Well, that's it.
00:19:11.200 - 00:19:29.954, Speaker A: So basically we have a tracking here which has a $10,000 USD price and it's divided in three. So first place takes five k, second place takes three k and third place takes two k. We have multiple resources available to help you guys.
00:19:29.954 - 00:19:44.594, Speaker A: So first of all, we're here so you can just come at our booth and talk to us. We also have multiple examples of code. Like we have this getting started, which is echoing Python in JavaScript in C, plus plus in Low in multiple languages.
00:19:44.594 - 00:20:07.086, Speaker A: We also have some nice applications using machine learning or database like SQLite. And yeah, a lot of interesting stuff in there so you can give it a look. We have a special discord channel for this hackathon, so if you scan our QR code on our booth, you'll get there, you also get a special badge that no one else would ever get, just people attending this event.
00:20:07.086 - 00:20:34.866, Speaker A: And we also have the Cortesi docs available. So, yeah, once again, this is a hackathon, so you probably want to mix most tracks to have more chances, right? So if you want to mix our project with something else, let's say you want to do a slot machine and you want to do it on top of polygon calling smart contract on chainlink for random number generation. And then you want to feed it to Karthi's machine to actually do this lot machine.
00:20:34.866 - 00:20:57.562, Speaker A: And so you want jackpot or you didn't get anything or something like that, you can always come and discuss with us and we can help you integrating stuff and figure it out, right? That's it. Hope you liked it. If you have any doubts, anything, just talk to me later or can stop at our booth and yeah, hope to see you guys doing something really nice on this hackathon.
00:20:57.562 - 00:20:58.560, Speaker A: Thank you.
00:20:59.570 - 00:21:02.750, Speaker B: Can you go back to the starting of the slideshow?
00:21:03.830 - 00:21:04.866, Speaker A: This one?
00:21:05.048 - 00:21:14.328, Speaker B: Starting of the slideshow next, the flowcharts.
00:21:14.424 - 00:21:14.796, Speaker A: This one?
00:21:14.818 - 00:21:36.004, Speaker B: Yeah, this one. Okay, so let's say for the Ethereum network, right, it is more secure because you need more nodes to there are many people, right? You need more than at least half of the chain for the request to get through, right?
00:21:36.202 - 00:21:41.424, Speaker A: Yeah. Basically when you reach consensus it's true. And you need most of cardisai.
00:21:41.472 - 00:21:51.912, Speaker B: We have different for different CMS, we have different computers. Like DAP A will have its own set, DAP B will have its own set, right?
00:21:51.966 - 00:21:52.472, Speaker A: Yeah.
00:21:52.606 - 00:22:03.484, Speaker B: So less number of members also does mean that it's more susceptible to monopolizing, right?
00:22:03.682 - 00:22:23.372, Speaker A: Yeah. As I said, if we just use consensus I'm playing poker with you and two other guys, right? If I just ask, okay, so what's the winner? And then if we have like three people saying one guy is the winner. Well, he's the winner and that's easy to manipulate, right? You just have to temperate it with three people.
00:22:23.372 - 00:22:49.924, Speaker A: But as I explained, whenever there are disputes, we don't rely on the consensus of the nodes that are involved in that computation. We actually engage on this verification game and then the consensus is based on the execution of that instruction that we came together as the divergence instruction. And this is done on chain on a blockchain with thousands of nodes like ethereum.
00:22:49.924 - 00:22:55.720, Speaker A: So I'm playing with you and two other guys. Poker. We have a dispute, it's not us that's settling.
00:22:55.720 - 00:23:16.556, Speaker A: We engage on this verification game and this verification game runs on top of ethereum or another protocol with thousands of nodes. And then even if the three of you are lying but I'm telling the truth, I can still enforce the truth. So what's really nice on this protocol of ours is that the security guarantees is not most of the nodes, it's at least once.
00:23:16.556 - 00:23:39.500, Speaker A: So a single party can enforce the correct result. So we have computation with 100 validators, 99 are lying, but a single party can still challenge them all and enforce the correct result because in the end it's consensus of the underlying blockchain that settles it. Which in case can be ethereum, polygon, hygnosis, even other roll up solutions like optimism or arbitrary.
00:23:39.920 - 00:23:40.764, Speaker B: Thank you.
00:23:40.882 - 00:23:47.730, Speaker A: Yeah. Anyone else wants?
00:23:57.390 - 00:24:06.814, Speaker B: When you're using a database, the database will be public, right? And if you're encrypting from the cartesian machine, will we store the key also in the cartesi machine or how does it work?
00:24:07.012 - 00:24:44.998, Speaker A: Okay, so basically the cartesian machine can have the size you want as long as the validator is willing to storage, right? So you can think of it kind of like a decentralized AWS, right? So you set your application, you say that your cortez machine is, I don't know, 2GB of Ram for instance, and 10GB of storage. And then you say I'm willing to pay xctsi per epoch validated. And then on the other side you have validators that will say okay, I'm willing to store this cartes machine, I have the resources and yeah, I'm willing to do to validate each epoch for the amount that you're proposing.
00:24:44.998 - 00:25:10.674, Speaker A: If not, then you should probably raise your fee and actually have a group of validators wanting that. But going back to the storage itself. So basically the validator is holding that cartes machine, which in practice is a docker container with this emulator inside and if he wants to store like a Cartez machine that has ten gigabyte database, that's fine.
00:25:10.674 - 00:25:37.220, Speaker A: And yeah, the database would be stored inside the cartes machine so off chain, so you don't have to pay for a lot for storage and stuff like this. Did I answer your question? Okay, awesome. Anyone else got a question? Anything? Okay, awesome.
00:25:37.220 - 00:25:47.930, Speaker A: It was great talking to you guys and well looking forward to what every building have fun. We.
