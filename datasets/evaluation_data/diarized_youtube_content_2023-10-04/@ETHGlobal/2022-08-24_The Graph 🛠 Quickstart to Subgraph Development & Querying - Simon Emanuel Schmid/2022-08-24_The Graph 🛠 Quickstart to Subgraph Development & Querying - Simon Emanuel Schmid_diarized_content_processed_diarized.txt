00:00:06.330 - 00:00:17.246, Speaker A: Nice. This feels cool. I mean, like I flew in from Europe yesterday and this for me, my body is probably kind of giving that talk at an after hour at 06:00 a.m.
00:00:17.246 - 00:00:27.954, Speaker A: In the morning, but let's do this. Eat, sleep, hack, repeat. Yeah, what I will do is kind of a quick start to graph development and also querying.
00:00:27.954 - 00:00:47.178, Speaker A: I mean the problem with a lot of Devs when we talk with them about the Graph is like they are a little bit afraid about the technology because the graph is such a powerful thing. But it seems like at the first sight overwhelming. Like how get I into it and how can I use it and what exactly does it I think it's cool.
00:00:47.178 - 00:00:59.386, Speaker A: Everybody uses it, but I don't know how. So I want to kind of reduce that fear and give you kind of a quick intro. So let's have a quick repetition about what is actually a smart contract.
00:00:59.386 - 00:01:14.994, Speaker A: So I think about a smart contract actually in the thing that it is just data. So it's structured data that lives on the blockchain, it's immutable or kind of actually mutable and then you have rules how to change that data. That's a smart contract basically.
00:01:14.994 - 00:01:30.746, Speaker A: And the smart contract by itself, it always knows about its current state, who owns which NFT right now. But it does not really know about historical state, but the blockchain knows. But the smart contract by itself knows only about the current state.
00:01:30.746 - 00:01:51.502, Speaker A: So let's look at that example. So if you look at the standard NFT smart contract, this is the data, like you have just a list with token IDs owners and then some random metadata Uris. If you're lucky, then they're not on Google cloud, that's the state.
00:01:51.502 - 00:02:41.338, Speaker A: You can always create a smart contract who owns which token, but what you don't know by just looking at the state of the smart contract who owned it before. So that's problem especially for NFTs, like there's this big word about the provenance but it's also other stuff that's interesting when we want to look into the past, like for example on uniswap, how did the prices of a pair kind of develop or how did the TVL of a certain protocol change over time. Very interesting data, but you need to look into the past of the smart contract state, right? So it would be nice to have kind of something like a time machine, right, that you can just kind of go back in time and see how was the state of that smart contract yesterday or like before yesterday, a week ago and so on and so forth.
00:02:41.338 - 00:03:06.098, Speaker A: So that's one way how you could look at what the graph is. It kind of gives you this possibility for this time machine, but not only that or kind of to understand it a little bit better. First I said the smart contracts are basically data and rules how to change the data and if you want to change the data, what you do is you send a transaction to the blockchain so that data actually gets changed.
00:03:06.098 - 00:03:18.410, Speaker A: Right? And that's what we look at with the graph. We look at the transactions. Another angle on the whole thing is when you start to develop depths.
00:03:18.410 - 00:03:52.406, Speaker A: So initially kind of in the early days of Ethereum, there was this idea of having the user interface, just HTML, CSS and JavaScript deployed somewhere on a decentralized storage, censorship, resistance and so on. Then you run your own blockchain on your computer, right? And then you download that front end on your computer and start to run and start to interact directly. But yeah, there was a problem because the blockchain by itself is write optimized and the JSON RPC interface that you use to interact with your Node is also kind of for writing data.
00:03:52.406 - 00:04:14.174, Speaker A: Mostly the reading stuff is a little bit kind of afterthought, but like the modern front ends that we see today, usually you read data, right? You want to see kind of how did the token price develop, who traded which and what's going on. And there was not really a thing. That's also why a lot of centralized companies jump in to fill the gap, to kind of provide that data somehow in an efficient way.
00:04:14.174 - 00:04:38.962, Speaker A: But we want to be decentralized, right? So in the wild we see code like this. This was actually one of the projects that I worked with, kind of looking at the code and for those that understand JavaScript, you see like all these await statements. Those are then kind of the loop through an arbitrary big number of balances and all these await statements.
00:04:38.962 - 00:05:15.938, Speaker A: They get 200, 300, 400 milliseconds to resolve. And if you have like ten NFTs or 20 NFTs here and all of those are awaited and then in the end kind of this simple page that just shows you how your NFTs take seconds to load, which is a super bad experience, right? So how should it be? Like you should have a user interface on top that actually writes to the blockchain and that you have kind of this indexing query protocol in the middle that gives you this data efficiently. So in the end you can write queries that look like this, right? Kind of very nice.
00:05:15.938 - 00:05:26.450, Speaker A: And I love GraphQL because it's such a nice language. So this does actually the same. And like to send this query, it's kind of a matter of milliseconds.
00:05:26.450 - 00:05:41.500, Speaker A: This is actually where the graph comes in. It's kind of these APIs for this vibrant decentralized future on the host service. Currently we have roughly 1 billion queries per day.
00:05:41.500 - 00:06:06.914, Speaker A: Big names like Audios Uniswap, Mstable enzyme used the graph, it's well used. And now there is also kind of this decentralized indexing network protocol launched one year ago. So you were not only able to kind of use the centralized hosted service, which was a proof of concept, but you can really have like decentralized subgraphs and data.
00:06:06.914 - 00:06:24.470, Speaker A: So there is kind of this network with 170 indexers that are kind of individuals. There's this redundancy across the world, it's fast ship, reliable and we're going towards this global open API. So in the end you can build truly decentralized.
00:06:24.470 - 00:06:54.346, Speaker A: But again to get back to what we can do here is there are two bounties from the graph and I'll show you how to get those. Now there's the best use of an existing subgraph which is a little bit easier so we have a winner and a runner up so the winner gets two K and the runner up 500 and then the best new subgraph which is more heavy but also more cool to do is the same. So it's kind of a little bit of strategy.
00:06:54.346 - 00:07:24.010, Speaker A: So what do you want to do? Do you want to do the easy stuff but you have more competition or do you want to do the hard stuff but it takes you more time but that's up to you but we're happy to help. Bonus points for the touching is if you go with the new technologies like substream I do not talk about this in the talk but you can read it online or you use the decentralized graph network. Right, so how do we do it? Yeah, a subgraph explained again is kind of this thing where you write kind of a data structure.
00:07:24.010 - 00:07:36.960, Speaker A: It's actually a database for those who know about databases. And then you have instruction set, so you look at the blockchain, what's going on there, and then you start to write to the database. So you have it easily retrievable later on.
00:07:36.960 - 00:08:03.378, Speaker A: So you can think about the transactions on the blockchain are kind of a mess, everything is kind of on the same thing. What you want to do is you want to kind of have databases per protocol so you can easily query it and make sense out of it. So roughly then how it works on top you have the DAP, as we said, you send transactional smart contract to change the state, which will emit some events.
00:08:03.378 - 00:08:29.550, Speaker A: The graph node kind of having the information from the subgraph. Will take those events, put it into a database, so that on the other side you can then just query that database and have quickly your front end. So in the end like a subgraph more or less what's going on here you have this mess of different stuff and magically it kind of is organized in a way that you can reuse.
00:08:29.550 - 00:08:45.620, Speaker A: Now you have learned about the graph so you can now scan that QR code and tell all the people that you learned about the graph. Marketing team told me to bring in the slide so you could do it or not. Three, you want to do it.
00:08:45.620 - 00:09:04.766, Speaker A: Nice, you got it. Cool, thanks. So NFT subcraft development like I always use NFTs as an example because you understand it's the super easy thing.
00:09:04.766 - 00:09:28.158, Speaker A: So how does an NFT contract look like? You have a transfer event, which is the most important one actually. And then you have those functions, kind of balance of owner which are read functions and you have this transfer from which is a write function more or less, that's it. There is some other stuff around with allowances, but in a nutshell that's kind of an NFT.
00:09:28.158 - 00:09:39.074, Speaker A: You just have some contract that emits that event and kind of provides those functions. It's very simple, but that's also the beauty because you can build so much out of it. But it's also easy then to index.
00:09:39.074 - 00:09:57.386, Speaker A: So I have some tips tricks here, but we skip through these because I want to show you also how we can query but the slides are online so it's more kind of a reference for you. So you can think about like what queries do I really want before you start to write your subgraph. For NFTs.
00:09:57.386 - 00:10:13.902, Speaker A: It's kind of how many NFTs are in total, who owns what, what's the provenance? We have kind of a rough schema how you would model that in a database. So you have a contract which represents the collection. You have an account which are the owners, then you have the NFTs which are then linked to the account and also the contract.
00:10:13.902 - 00:10:41.630, Speaker A: Then you can store all the events for later reference and store the metadata if you have it, and traits also if you have it. That's roughly how I would model it. And then what you do is kind of you install dependencies, find the contract and then you start to initialize and then you just deploy it to the studio and then you enhance the subgraph and then deploy again and so on and so forth until you're ready and then you can publish.
00:10:41.630 - 00:10:56.500, Speaker A: I also have kind of a collection of pattern in this presentation, but it's also probably better for looking into that later. But they are here. It's kind of some stuff that you could do, but I would say let's just do it.
00:10:56.500 - 00:11:41.136, Speaker A: Can I go into this terminal list or something? Okay, so I hope you have graph installed right on latest version. So what can we do? We can go to Etherscan and I know I could just go for a random NFT and you can just copy the contract out actually you can just do graph in it. What is it? Index events and this index events.
00:11:41.136 - 00:12:02.024, Speaker A: Actually it's kind of the trick to make the initialization much, much faster and we need to document this a little bit better. But like now I tell you and if you do this, then a visit starts and then they ask you so okay, which protocol do we want to index? The graph supports RV ethereum near Cosmos. We are on ethereum here.
00:12:02.024 - 00:12:12.476, Speaker A: So let's go with Ethereum then. In which product you want to initialize? There is the Subgraph Studio, which is the new one, where you can publish to the decentralized network. So we always go with the cool new stuff.
00:12:12.476 - 00:12:19.728, Speaker A: Then we give it a slug. So let's name it hashmasks subgraph. All right.
00:12:19.728 - 00:12:31.136, Speaker A: Directory to create in. Yeah, let's go with this hashmask Subgraph. Why not? Before we use the protocol now, we kind of take the chain.
00:12:31.136 - 00:12:37.876, Speaker A: So we go with Ethereum mainnet contract address. I already got it. So it's this one.
00:12:37.876 - 00:13:18.354, Speaker A: You just go with the address. Oh, shit. What did I do wrong? Can we just try again? All right.
00:13:18.354 - 00:13:30.226, Speaker A: Yeah. The alternative is that you have the Abi, maybe for the hackers around you, especially when you start to write your contract. You can also just add the path to an API.
00:13:30.226 - 00:13:47.574, Speaker A: But I think it would take too much time here to do this. But actually, I want to show you anyways. There is a much cooler possibility currently with new tools.
00:13:47.574 - 00:14:03.700, Speaker A: So now we have the Soulbound Studio, which more or less does the same that I've just tried to do in the command line. But let's see, maybe this is a little bit more reliable. So actually how this works.
00:14:03.700 - 00:14:18.438, Speaker A: So you can go on this sole mounted XYZ. And then there is this subgraph canvas. And here you have very nice UI, so we can give it a name.
00:14:18.438 - 00:14:34.294, Speaker A: I don't know what's going on here. I don't want this. So we add a contract and now I can paste in the address and what it does in the background, it starts to download Abi and also resolves the start block eventually.
00:14:34.294 - 00:14:42.430, Speaker A: Nice. And then that's it. And I can save the smart contract probably now in the Explorer.
00:14:42.430 - 00:15:01.492, Speaker A: Nice. Okay, cool. So you see, I have the contract and you see, okay, the contract has these events.
00:15:01.492 - 00:15:08.616, Speaker A: I have the approval events. I don't really care about the approval, actually. I just want the hash must have a funny feature.
00:15:08.616 - 00:15:16.856, Speaker A: So the names who have the name change event. So let's change this. The ownership is also kind of just internal and then the transfer.
00:15:16.856 - 00:15:35.300, Speaker A: So you can easily go and say like, okay, I want to just index those events and here they are, and it's all kind of prepared for you. And go back to edit subgraph. Maybe I need to there are box today.
00:15:35.300 - 00:16:11.268, Speaker A: I'm not lucky with my live coding. Maybe it's because of this. Yeah, I know that they worked on it today.
00:16:11.268 - 00:16:21.690, Speaker A: And now also this demo doesn't work. But what we have is the Abi. So let's go the other route again.
00:16:21.690 - 00:16:52.420, Speaker A: Shit. I cannot work with VI on the English keyboard. Any private data that would reveal if I do this.
00:16:52.420 - 00:17:40.900, Speaker A: Or maybe let's do a new folder. Okay, graph in it theorem, contract, address. I will see that coming.
00:17:40.900 - 00:17:49.176, Speaker A: All right. Yeah. The dependencies will take some time probably.
00:17:49.176 - 00:18:07.740, Speaker A: In the meantime, so what it does, it now creates the scaffold, which is cool. So we can go to the graph.com studio or actually if you want to follow then you have here in the products you go to the studio.
00:18:07.740 - 00:18:27.864, Speaker A: Yeah, sign and then you can just create a subgraph. You get main net, hash mask continue. And actually you just need to do graph alth.
00:18:27.864 - 00:18:59.310, Speaker A: Let's see where we are here. So what we have here is now it initialized the subgraph for us already. So you have the subgraph YAML which says like which source? We can also add the start block here which is you can see the transaction when it was deployed.
00:18:59.310 - 00:19:11.438, Speaker A: It saves us time thinking and so on and so forth. You also have like auto generated schema. You see similar like all the events are just indexed and you have also the auto generated mappings.
00:19:11.438 - 00:19:23.750, Speaker A: So you can easily just get started with that stuff and don't need to overthink. I would not really do much now. We just kind of say yeah, that looks good, just deploy.
00:19:23.750 - 00:19:45.990, Speaker A: I probably need to do graph code gen first deploy. Nice. It's here.
00:19:45.990 - 00:20:18.268, Speaker A: See, it's already syncing and did it fail now? And then you can go already in the playground and start to yeah, and it already see, it's already start to have data. Very cool. Also when you do this here, you see this query endpoint and this actually comes the next thing how to query the stuff from the graph.
00:20:18.268 - 00:20:48.456, Speaker A: So from the studio you have this GraphQL endpoint that you can also use in your front end then. But you can also go here and start to inspect. And I know for example, like the hash masks, they can change names so I can say like okay, ID name, new name, what happened here and then you can just send this query and then you see, okay, someone changed the name to this or eleven Mark Cuban, dosh Nikola Tesla.
00:20:48.456 - 00:21:04.732, Speaker A: So we already have like you see it took me five minutes and we already have very valuable data about the contract ready in a nice GraphQL interface. Yeah, so that's about developing subgraphs. So if you want to go like if you just do this you probably don't get the bounty.
00:21:04.732 - 00:21:18.820, Speaker A: You should then start to change the schema, change the mappings and so on. But if you have that first step and you want to extend your subgraph, then come to our booth and I'm happy kind of to explain the concept. You can also go to the documentation.
00:21:18.820 - 00:21:38.652, Speaker A: How to proceed from here further. But I want to spend some time also here this next slide, how to query data from the decentralized network. We also don't need to go through the slides, but this works like this.
00:21:38.652 - 00:21:57.764, Speaker A: So you have again the graph and then there is this one product called Graph Explorer and here you see all the subgraphs, like all the 439 subgraphs which are deployed to a decentralized network yet now. And you can scroll through them. And there are very interesting ones.
00:21:57.764 - 00:22:22.960, Speaker A: So, for example, you have Lido Ray Mainet pull together, Sushi Hop protocol, some Doodles ethereum blocks, can query if you want. There's this ERC 721 marketplace that tracks kind of marketplace volumes and stuff. But like, the one that I like the most actually is the CryptoPunks.
00:22:22.960 - 00:22:34.658, Speaker A: So you can search for CryptoPunks and then you need to be careful. Always go for the ones with the highest signal. That's what Quoration is here for.
00:22:34.658 - 00:22:46.262, Speaker A: I think this one is a scam, but yeah, it's a decentralized network everybody can deploy. Right. So how it works again here you have a playground similar to before.
00:22:46.262 - 00:23:06.142, Speaker A: So we can see like, okay, which accounts do we have sent a graphical query. We can start to a little bit explore it. But actually it really gets cool if you do this.
00:23:06.142 - 00:23:33.026, Speaker A: So you can get that query URL here and then you go to Graphic online and paste it here. But the next step is also you need to have an API key. You can also go again into the studio.
00:23:33.026 - 00:23:49.818, Speaker A: And then you can create API keys here. You can just create one and then you can use it so you can copy that API key. There are thousand free API keys initially queries if you do this.
00:23:49.818 - 00:24:12.690, Speaker A: And then you just need to replace the API key here with your API key. Sorry, should I take the other here? Okay. All right.
00:24:12.690 - 00:24:28.762, Speaker A: Get the API key. Nice. Again.
00:24:28.762 - 00:24:55.060, Speaker A: And now I can say, for example, this is actually interesting. So who wants to know actually the sales for the punks? It's interesting. The highest sale, so I can say like the NFT ID and then amount order by amount order, direction, descending send.
00:24:55.060 - 00:25:12.150, Speaker A: And see, this is interesting. Nobody knows that, but actually the highest sale on the crypto punks was that much and it was a wash trading. If you go to the Larva labs or now Uvalaps website and you want to see this, you don't see that wash trading here.
00:25:12.150 - 00:25:19.178, Speaker A: But it's true. Like somebody did it, get a flash loan, get the highest sale and then get the flash loan back. Thought it was interesting.
00:25:19.178 - 00:25:38.114, Speaker A: So now we had kind of this walkthrough from what is the graph, how you can create the subgraph and how you can query existing subgraphs on the decentralized network. Yeah, I know it was a lot packed in 30 minutes, but yeah, thanks for watching. And if you have any more questions, we're trying to be at the booth as much as possible.
00:25:38.114 - 00:25:42.110, Speaker A: And then there is Discord and other channels. Yeah, happy hacking.
