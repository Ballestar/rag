00:00:34.030 - 00:00:47.020, Speaker A: Hello, everyone, and welcome to the Ezko Workshop zero Knowledge Machine Learning with Ezko. Join us today is Jason Morton and Dante Camuto, who will be taking us through the session. And with that, I'll pass it over to Jason and Dante to get the session started.
00:00:48.910 - 00:01:54.090, Speaker B: Hey, thank you very much. Nice to meet you all. We'll jump right in with a screen. Okay? Yeah. So we're jason, Dante, we've been working on building this software for machine learning on chain or for doing zero Knowledge proofs for machine learning. And today we're going to talk about how to use that for autonomous worlds, which is something that people have become increasingly interested in in recent days. Okay, so what's the picture? So one way to think about it is that we're providing kind of a physics engine for autonomous worlds, so we can do kind of arbitrary matrix computations, arbitrary kind of machine learning computations, convolutions, all kinds of crazy stuff, things that you wouldn't be able to write in solidity because of their gas costs.
00:01:54.090 - 00:02:48.338, Speaker B: You can sort of offload those heavy computations to this engine so the game client or a server can prove sort of a state transition of a game. So you can imagine there's a diffusion happening in the game or there's an evolution in the world state that's more complex than what you want to implement with the ECS. And so you can use this as a way to kind of shortcut that. You can also use it to build NPCs that are powered by AI. And a lot of the examples people have done as well are things like kind of a fickle God model where you're trying to please trying to please someone like a cooking mama, or you're trying to please someone by creating some kind of pattern in the game. And then what's happening behind the scenes is there's a classifier model that's being run on your input. Of course, sometimes those models don't work as well as you would like them to.
00:02:48.338 - 00:04:01.050, Speaker B: But the fun part about a game is that even those failures can become sort of fun part of the game, like beating an NPC. So let me back up for a second and say, what does it mean to run a model on chain, an AI model on chain? So you're all familiar with an ECDSA signature, which is a kind of zero knowledge proof, takes public inputs and a private key, combines them in a well known signature function, produces a result, which is the signature, and then you pass that to the chain to verify it, or someone else can verify that signature. And what a Zero Knowledge proof is is basically just a programmable signature. So we can replace that signature function with any function we like. The functions we like are kind of ML models and linear algebra. And what we're doing with Ezekiel is to make it easy to create a model in Python, describe the pipeline that you want in terms of who is responsible for proving, who's responsible for verifying and what's the setup. We bake that into a proverifier pair and then someone produces a proof either on the client or the server and then the chain verifies the proof and it's as though the model has run on chain even though it ran off chain.
00:04:01.050 - 00:04:46.290, Speaker B: And the big picture, of course, is that AI is something that doesn't run well on chain now. So AI and machine learning and linear algebra are great but require trust either in the general context, trust from someone like OpenAI, or trust from the person who's running the game server or wrote the game client. We can work in Python or other numerical languages. There's a big library of existing models and transformations. We could use it in a game for on chain contracts. They obviously have the property of being decentralized, being trustless, being composable and having this property of autonomy that many other people will talk about. But they're less scalable because they rely on a consensus mechanism.
00:04:46.290 - 00:05:59.534, Speaker B: The same computation has to be repeated many times and they're kind of too slow and too expensive to do complex AI machine learning or linear transformations. ZK brings to the trustlessness decentralization and reposability some scalability because now instead of having everyone, all the consensus nodes have to produce, do the same computation. A single model can be a single machine can do the proof of a single client or a single server and then everyone else can trust it. But of course would pay a cost in terms of math and security properties in a weird programming model and possibly weird languages. But what we've done with Ezekiel is to make it easy to use Python models or Python description of the linear algebra, the machine learning model that you want to run so that you can access a library of existing models and or train your own models and then make it easy to deploy it so that we can use it in an on chain game. And I want to mention an example by Dinolo Rich, Patricia and Paul Henry. Dinolo is on the call as well, I think.
00:05:59.534 - 00:07:16.790, Speaker B: And what they did was to produce just so you get a sense of what the kind of thing that happens is. They made a world, the players could take actions and then you evolve the state of the world in response to those actions, like trees spread and grow or fire spreads or whatever with a Zkml model. And there's another LLM that's not right now in Zkml but will be eventually that tells stories about the things that happened just to give you a sense of the kind of evolution that might be possible. The other piece I want to bring up here is how this might interact with mud. So there seems to be a lot of connections with lattice's mud and I think we're going to see a lot more integration happening as people experiment with it. Right now if you look at the bottom part of this picture is kind of that without a mud. We're going to be responsible for writing the code to ingest state from the chain or to take an action the player action prove an update of the state how the players actions or inactions result in a change in the state of the game.
00:07:16.790 - 00:08:13.420, Speaker B: And then that proof goes to a verifier that lives on chain and updates the state. And now it's back into state on chain. So there's kind of a game loop that's happening between the client and the state and the state that's stored on the chain where the more complex updates involving diffusion and whatever else happen client side or server side and not in a smart contract that would require a fair amount of development. Like an example I showed you before, but with Mud you can use the ECS framework to sync the state with the client state and the chain state. And we're sort of now agnostic about where we're going to do the proofs, either on the client side or the server side, but a lot less work in terms of producing that. Of course much folks talking about that. So the basic idea of how a zkml proof works is very simple.
00:08:13.420 - 00:09:08.218, Speaker B: So we're taking floating point numbers and representing them as six point numbers. So we're picking a denominator like 256 or we're quantizing it and then we're representing a small floating point number 7256 as literally seven. We're just storing the numerator and then we keep track of the denominator 256 in the type system. And to prove dot product you could write a custom gate, in other words make the constraint into the constraint system of the zero knowledge proof that says that y, the output of the first of the two vectors dotted together is equal to whatever they are. That's not really what we do. We do something more complicated. There's a lot of different arguments that can be made to accomplish that but sort of not critical for you to worry about exactly how that argument works because we've abstracted that away.
00:09:08.218 - 00:09:59.750, Speaker B: And then to prove that y is equal to ax plus B, that a matrix multiplication and a shift has been applied, you just basically repeat that argument or arguments like that. And then to prove that a nonlinearity like ReLU has been applied, what we do is we prefill a table with all of the possible inputs and outputs that might occur, given our assumptions about quantization and the maps on the size of the numbers that might appear. And we prove that the input output pair lies in that table. That's called a lookup argument. There are other alternative ways to do that and there's lots of new arguments to pipeline to make it more efficient. But it's already pretty fast. So I'm going to pass off in a minute to Dante, but I want to say something about the big picture, about how to use Ezekiel.
00:09:59.750 - 00:11:05.470, Speaker B: Basically what you do is you find a model that works for your use case. You either train it yourself, you design it yourself, or you download it. For example, you're using it to compute a state transition, an evolution of the world or the natural world. You might be using it for this judge. Does the player recipe make me happy? Or did the picture that the player drew or the song that they sung satisfy the basically on chain AI or to run an NPC AI or some other idea that hasn't occurred to anyone yet that you'll come up with. Then you take this model and you compile it using Ezekiel to sort of a triple of circuit which is expressed in the setup approver artifact which is either a laws improver or a binary prover and a Verifier artifact which in our case will be an on chain EVM Verifier. You have to deploy that Verifier and sort of route the update into it and integrate the prover either on the server or the client.
00:11:05.470 - 00:11:18.760, Speaker B: And then you launch your game. And these are just our Telegram group and our GitHub for you to check out. And I think with that I will pass it to Dante to show you how it works.
00:11:22.570 - 00:12:24.330, Speaker C: All right, I see there's a few questions in the chat. I don't know if we want to do those now or later on. There's one question which is is the output a regression result or is it limited to classification results? You can do both. I'm going to sort of demonstrate the computational graphs that you can build, but you're not really limited to either regression or classification. There's another one which is, can we use Ezekiel for provable training as well as inference? We currently only support inference training. Yeah, training is a lot more computationally expensive and hopefully at some point we'll support it, but currently we're just working yeah, with inference. Someone asked you to go back to the slide with the GitHub and discord.
00:12:35.370 - 00:12:41.640, Speaker B: I just put it into the chat. If you just search for easykl, also find it.
00:12:42.650 - 00:13:08.270, Speaker C: All right, awesome. All right, well, I am going to showcase what all of this looks like in practice. Basically. There's actually quite a few. We've developed a lot of tooling to make it easy for you to use this. So the main library is written in Rust. I know it's a challenging language, so we've sort of wrapped it in Python.
00:13:08.270 - 00:14:25.750, Speaker C: You can compile it to WASM if you're running a browser application, so you can run proofs and verification straight in the browser. But today, kind of as a neat sandbox, I'm going to be running you through how you might use Ezekiel to generate proofs inside of a jupyter notebook or something. Just so you have a nice sandbox to yeah, it's just kind of a nice sandbox to try out different models and see how they perform. Let me share my screen. All right, this is kind of a pretty typical setup for starting off an Ezekiel project. So what's kind of cool is that? You can actually just define your circuit, or you can think about your circuit just as a PyTorch sort of computational graph. So you're going to start typically by defining a wrapper around NN module, which is really just like how you might define a neural network in Python more broadly.
00:14:25.750 - 00:15:01.922, Speaker C: So how are we going to do this? All right, let me create some sort of model. What's interesting is that I have copilot on, so sometimes it suggests layers as I'm typing. Yeah, there we go. Let's see what it comes up with. Kind of interesting to see what the AI might be interested. All right, we're going to define okay, let's start simple. Let's start simple.
00:15:01.922 - 00:15:41.070, Speaker C: And let's just have a single comp layer and then a value nonlinearity as part of our model. And our model is just going to be applying oh, look at that. Stuff is amazing. So our model is just going to be applying a comPlayer and then subsequently applying a relative nonlinearity onto some data. Let's say that data is like mnus shaped or something, which is like images with a single channel. Whoa. And yeah, 28 by 28 images.
00:15:41.070 - 00:16:08.200, Speaker C: And we need to instantiate the model once. We're not going to train it because we're sort of limited by time. And I also don't want to download a data set. But all you need to do now is you can just export this and get out locally. So let's run that cell, make sure everything works.
00:16:08.650 - 00:16:09.302, Speaker B: Yes.
00:16:09.436 - 00:16:36.338, Speaker C: All right, so we've exported the model. The format that we use is something called Onyx. The details of this don't really matter, but we've just saved this model locally. And what we need to do, as Jason described, we use a slightly different representation for numbers. So we're not really working in floating point space. We're working with field arithmetic. So what we need to do now is quantize the model.
00:16:36.338 - 00:17:16.526, Speaker C: So basically fit everything into that field and make sure everything runs correctly. And this is done with the forward method on the easygale library. There you go. So we've quantized the model. And now for a ZK proof, we need an SRS string, which corresponds to the parameters that we're going to be using to generate the Verifier key, the proving key, and subsequently it proofs. We also provide a method to do this to make it really easy for you to use. This takes a little bit longer to run, but hopefully not too long.
00:17:16.526 - 00:18:09.950, Speaker C: And yeah, there we go. And then we have what's called the setup phase, which is where we generate the Verifier key and the proving key. So the proving key in particular is important for it's in the name. It's important for generating proofs, and the Verifier key is important for the verifier to then subsequently verify the proofs. So this is all done in the same step, and then it can be distributed to the two different parties that need to either prove or verify. Proofs generated from a specific circuit can run that and nice. All right, so that ran and then generate a proof using a simple method by providing the paths of all the things that you need, and then you can verify it and voila, that's kind of it.
00:18:09.950 - 00:19:01.470, Speaker C: We also provide a bunch of methods for you to I don't have my ledger with me right now, but if you plug your ledger in, you can basically submit proof on chain. You can deploy verifier contracts if you need. So we provide tooling to do all of that internally to the library. We've tried to make it as easy as possible to generate circuits, prove, verify, generate on chain verifiers, and then submit proofs to those verifiers. But let's go back up and start generating something slightly crazier here. Okay, what do we want to add? Let's say we want to double X and then subtract it just for fun. And then we want to take it to the power squared.
00:19:01.470 - 00:19:42.734, Speaker C: Let's see if this works right. Let's run through those cells again. Basically, the idea is that you're not really constrained by anything when you're generating these circuits. We support a whole bunch of methods. So if you want to generate something really crazy, you can chuck it into a PyTorch model and then start running proofs on it. So, yeah, we need to generate the setup phase again and start proven. And there you have it verified again.
00:19:42.734 - 00:20:06.760, Speaker C: All right, let's see if we can chuck a second comp in. Make this a little bit spicier. TADA. All right, let's add that into here. Oh, wow. And then maybe yeah. All right, that sounds good.
00:20:06.760 - 00:20:38.960, Speaker C: But yeah, in terms of circuit size, if you're wanting to prove something in less than 10 seconds, we've got in like, six, five, or six layer comms. Yeah, we've got in five or six layer comms to prove in less than 10 seconds. So you can go pretty crazy in terms of parameter size. Yeah. Let's see if this one verifies. I kind of want to see if I can break it at this point. Like, see how much we can throw it at.
00:20:38.960 - 00:21:17.482, Speaker C: All right, sweet. All right, that's still verifying. God, I don't know if we're going to be able to get this to stop working today. Yeah, I see there's a few questions in the chat. Have you tried using mojo with Vkml? I'm actually not too familiar with mojo, but yeah. Are there any questions on the specific demo as to how to use this? I'm a bit confused what the demo is trying to prove. Well, basically, yeah.
00:21:17.482 - 00:22:22.366, Speaker C: Okay, so what is the demo trying to prove? Could you explain? All right, yeah. So if you were to try and build ZK circuits on your own to generate proofs of that. A zero knowledge machine learning model was run correctly. You would basically either have to go into Circom or Halo Two and start coding up like a gate for matrix multiplication, for a value, for a convolutional layer, all those sorts of things. And what we've done is we've started to abstract away a lot of that complexity. And what does that mean? So it means that instead of having to go into those languages like Circom and those sorts of things to generate proofs or a circuit that represents a specific machine learning model, you can just use the frameworks that you are probably familiar with if you're a machine learning practitioner. Meaning that you can just use things like PyTorch or those sorts of things to generate a model.
00:22:22.366 - 00:23:18.370, Speaker C: We take that model and then compile it into a circuit for you so you don't even have to think about it. Oh, you meant what is the ZK proof proving? All right, yeah, good question. So currently we're just proving that the model executed correctly. So given that, you know, a specific given that there's a public model and there might be some public data, you're proving that you executed it correctly and then you can submit that proof as call data to the chain. But you can generate a whole host of other proofs. Like for example, you could keep the parameters of the model private and run it on a set of public inputs, you could keep a set of private inputs, but run a publicly known model on those and then generate a proof that you ran it correctly and then submit that proof on chain, basically. So we allow all those sorts of different scenarios to be realized.
00:23:18.370 - 00:24:30.330, Speaker C: What model am I using currently? Well, I just ran through it. I'm sort of generating these models on the fly, so you can really generate kind of anything, sort of anywhere. Can the code be shared? Yeah, we actually have a jupyter notebook demo, so if you want to play around with this, this is all available inside the GitHub repo, but yeah, definitely already available. Someone's asking, someone saying they're not familiar with Python. Is it possible to have a similar tutorial with JavaScript eventually? So currently we are on the JavaScript side. What we're really focusing on at the moment is getting Provers and Verifiers in WASM so that you can run these things with relatively good performance straight in the browser. So you can generate proofs for a specific model or verify proofs for a specific model straight into a browser.
00:24:30.330 - 00:26:02.758, Speaker C: If you have interest in getting this stuff into JavaScript, definitely open up an issue and we'll take a look. Is there some Mud integration allowing game clients accepting events from the indexer? So currently we are not fully integrated with Mud, but that's definitely something we're moving towards that we're aiming to integrate as much as possible with them to make using our tooling within autonomous Worlds as quickly as possible. In ML, a lot of people talk about keeping input data private. I'd imagine it could be interesting to also keep the output data private in that scenario. Also, could you go through how a proof like that would be set up? Yeah, what's pretty interesting is that the proof command down here, you can actually say what parts of the model you want to keep private and public. You can actually just pass a flag that says I want my parameters, for example, of my model to be private, I want the output of the model to be private, or I want the input of the model to be private. So we allow all of that to be configured from start to finish.
00:26:02.758 - 00:26:07.000, Speaker C: So if that's something you're interested in, we can already do that.
00:26:09.130 - 00:26:14.010, Speaker B: We should also probably show something from EVM Verify.
00:26:16.910 - 00:26:24.380, Speaker C: Yeah, for sure. I don't know if we have that into the Python bindings yet.
00:26:25.070 - 00:26:29.180, Speaker B: Yeah, we might not. We can do the Docs or something.
00:26:30.430 - 00:26:35.860, Speaker C: Yes. Let me show that it.
00:26:49.870 - 00:27:46.170, Speaker B: Successfully sharing. Are you sharing? But if you go to the Doc site, there's a section on Verifying on Chain which shows you have to generate a proof with a transcript set to EVM. And then you can generate a Verifier which emits code, deployment code specific, visit the command line specific to your model and solidity code, and then you can test it. It verifies by using verify EVM. And that just is running the code that you generated just before it. And then you can deploy that code to a chain and then you would need to sign it. And then you can also send proofs or you can send those proofs manually or deploy that code manually.
00:27:46.170 - 00:28:08.900, Speaker B: But just wanted to highlight that it is possible to create Verifier. So a very common use case would be something like you have a state update. You want to check that the state update is valid before you apply it. And so you would create that Verifier and use a Verifier called from your main smart contract in order to check that the update was correct.
00:28:14.520 - 00:28:21.472, Speaker C: And yeah, I think that answers another question in there, which is, are we making function calls to the Verifier contract?
00:28:21.616 - 00:28:21.924, Speaker B: Yeah.
00:28:21.962 - 00:28:39.820, Speaker C: So there's a method called Verify EVM where you can just pass a Verifier contract address and then submit your proof there. But yeah, we also have a bunch of methods for deploying the Verifier contract, so you don't have to think about that either, which was what Jason was just showcasing.
00:28:45.070 - 00:29:11.060, Speaker B: One more question, which is Strawberry detector should work. Yeah, I would love to see that if that's something that you end up doing, or hot dog detector or whatever, this kind of stuff. Some people have done uses this doodles thing, the Google Quick Draw program, for example, where you have to draw a picture of a snowflake or a horse or whatever. That should also work.
00:29:19.410 - 00:29:21.280, Speaker C: All right, any more questions?
00:29:29.930 - 00:29:34.970, Speaker A: Yeah, if anybody has any other questions, feel free to type in the chat or take yourself off mute.
00:29:37.230 - 00:30:24.230, Speaker C: Very curious to know whether you have a complex use case that you've imagined that you can share with us. Another one. So there's two ways to answer that, I guess. There's complexity in terms of the models that we're trying to get in. Most definitely we're aiming to get transformer based models in at the moment in that sense, for sure. And I guess we're also trying to hit the Verifier contracts into larger DApps and stuff. So start composing complexity within those sorts of applications.
00:30:25.310 - 00:30:26.458, Speaker B: Yeah, there's a lot of interesting, but.
00:30:26.464 - 00:30:28.086, Speaker C: I guess Autonomous Worlds.
00:30:28.198 - 00:31:08.040, Speaker B: Yeah, in Autonomous Worlds people thinking about, for example, having the world physics or evolution function being something that could be player owned or could be like the player commits to an evolution function and then is responsible for maintaining their planet or NPCs with serious AI powered by Transformers or whatever else that can even move between games. Stuff like that. So that kind of thing should eventually unlock certainly the state updates and really basic AIS, but more sophisticated AIS would be really fun.
00:31:08.890 - 00:32:00.914, Speaker C: Yeah, and I guess for Autonomous Worlds, people specifically have been using it not as ML, but as a sort of physics engine, which is what Jason would have showcased earlier, which is like all the state transitions between things. All right, this can be huge for verifying physical objects and useful and unlock things as well. Yes, definitely not just strawberries and hot dogs. Strawberries and hot dogs, yeah. If you want to try relatively light. That's true. I'd be curious to see the strawberry Verifier.
00:32:00.914 - 00:32:51.122, Speaker C: So if you want to whip that up, definitely message us and we'll help you get strawberry verification over the line. I guess one more thing I wanted to address was the JavaScript question, just to go back to that. There's a bunch of ML libraries in JavaScript which will export to Onyx, which is the neural network representation we use. It's a sort of universal format. So I think TensorFlow JavaScript can save to Onyx, and then you can point our CLI. So we also have CLI tooling to that Onyx file to then replicate the flow that we just showcased. So you're not limited to Python.
00:32:51.122 - 00:32:59.560, Speaker C: Basically any framework that can generate Onyx yeah, as usable, basically.
00:33:12.440 - 00:33:38.510, Speaker A: Awesome. Well, cheers. Thank you all very much for this presentation. And thank you all, everybody else, for attending. The recording will be shared to you all. And so if you have any questions, please feel free to reach out to Dante and Jason on the discord channels and yeah, so thank you all for this. And we have one more session later, and then the team formation will be at the last session of the day.
00:33:38.510 - 00:33:42.822, Speaker A: Cheers. Thank you all.
00:33:42.956 - 00:33:44.530, Speaker B: Thank you. Bye.
