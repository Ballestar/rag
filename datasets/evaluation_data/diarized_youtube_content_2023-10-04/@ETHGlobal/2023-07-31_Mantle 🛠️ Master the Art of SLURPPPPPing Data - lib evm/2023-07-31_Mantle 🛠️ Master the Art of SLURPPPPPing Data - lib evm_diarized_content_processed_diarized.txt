00:00:07.290 - 00:00:09.882, Speaker A: Thanks. Coming. Welcome to schlerp.
00:00:09.882 - 00:00:18.842, Speaker A: Mastering that of schlopping yummy data. If it doesn't make sense to you, don't worry, we'll proceed to explain what this is. So one query.
00:00:18.842 - 00:00:34.546, Speaker A: One query is all you need is the claim that I'm giving in this talk where if for you front end developers, I'm claiming that you can extract all the data you need for your front end application in one query. So a little bit about myself. I'm a Deverel at mantle XYZ.
00:00:34.546 - 00:00:39.286, Speaker A: We're in layer two that just launched last week. Feel free to check us out. Mantle XYZ.
00:00:39.286 - 00:00:50.714, Speaker A: And those are my socials. So the number one thing for every DAP is the front end. I mean, that's what your users interact with, that's what your users see.
00:00:50.714 - 00:01:02.640, Speaker A: No one really cares about the back end. It doesn't really matter how it organizes logic, as long as it's aesthetic to the user, the user will come back. If it loads quicker, the user might come back more often.
00:01:02.640 - 00:01:24.578, Speaker A: So Albert Einstein, the react JS founder, famously said that frontend is just a well of bugs. Reason being because frontend requires a lot of state management, you want to query data a, data a, and then you use data a to query data b, and use data b to query data Cde. So there's a lot of state management involved.
00:01:24.578 - 00:01:40.170, Speaker A: So I'm here telling you that by querying all your data in one query, you can avoid auto state management and reduce the number of bugs we'll go through. Like a simple uniswap case study. And everyone here I assume, is familiar with the uniswap model.
00:01:40.170 - 00:01:52.222, Speaker A: You put in some tokens and you get out some tokens. So in this example, we're swapping maybe say ten e to USDC. On the surface it sounds very trivial, but behind the scenes there's actually a lot going on.
00:01:52.222 - 00:02:02.522, Speaker A: So the front end is kind of anticipating how many ETH you want to swap, what asset you want to swap. In this case it's ETH. How much of the asset you want to swap.
00:02:02.522 - 00:02:24.774, Speaker A: In this case it's ten. How much of the asset you want sorry, which asset you want, which is USDC in this case, how much are you going to get out from this swap, how much are the fees on the network in USD as opposed to ETH? And what is the price impact? Do you have enough ETH to complete this swap? So and so on. There's a lot of complexity going on behind the scenes.
00:02:24.774 - 00:02:48.498, Speaker A: And a very simple example of how one might approach this data extrapolation is with this example whereby you get the EF address, and from the EF address you get the user's balance. When you get the user's balance, you can get the user's die balance and then sorry, if balance or die balance, and then you can get the amount of die that the user will get swap out. Given this data.
00:02:48.498 - 00:03:08.658, Speaker A: This is terrible one, mainly because this is blocking to get the die balance, you first have to get the ETH balance and so on and so on. So this is incredibly bad because it's blocking. A naive approach to do this is parallelizing all these queries into a promise.
00:03:08.658 - 00:03:23.390, Speaker A: So you might call awaitpromise all and query all the promises. This is still good, this is good, this is better. But you're still doing three parallel queries and I'm here telling you that you can do any amount of data you want in one query.
00:03:23.390 - 00:03:51.462, Speaker A: So yeah, we can do all this in one query and so we can do that with multicall three. For those of you who don't know what multicall three is, it's a smart contract that is deployed on, I think, 106 chains, all using the create to upcode, so it's on a deterministic address and so you can use the same address for all 106 chains. Traditionally without multicore three.
00:03:51.462 - 00:04:20.842, Speaker A: How your DAP would interact with the blockchain is by issuing a separate query for each data extraction, for example, die balance off, uniswap swap amount out and the balance of E. With multicore three it's actually a smart contract that lives on the blockchain. So when you call multicall aggregate, you actually call one query to the smart contract, the smart contract then queries all the other relevant information needed from the other contracts.
00:04:20.842 - 00:04:56.250, Speaker A: So that way instead of using three queries, you can use one query. The problem with multicloud three is that it is quite verbose by default if you're using ETIs, which is the canonical library these days, to encode and you have to actually encode and decode your function into a very specific format. So it's not very user friendly, it adds a lot of complexity on the front end, but it allows you to achieve querying parallel multiple queries in one query.
00:04:56.250 - 00:05:25.314, Speaker A: Luckily, Vium, I'm not sure if I'm pronouncing this correctly VIAM from Paradigm XYZ, a new JavaScript library supports multicultural encoding and decoding out of the box, if you guys would like to check it out. I think on the developer docs page you can see that there's a specific provider for the multicall three provider provided that it's deployed on your chain. So that's cool.
00:05:25.314 - 00:05:44.374, Speaker A: Multicolored is good, but it's not good enough because it does not support dependent data. And what I mean by dependent data is that it does not support the cases where the inputs to the previous query, sorry, to the current query is obtained from the previous query. In this case we have a vault address obtained from a yield optimizer.
00:05:44.374 - 00:06:15.870, Speaker A: We would like to then query that address to get the bounds of our vault address, which is simply not possible with multicolored three because it is stateless. Yeah, so we can't do that in multicolored three. However, if we combine two little known hacks on E, Call and Solidity, we can actually achieve and we can actually achieve arbitrary code and arbitrary business logic in a read only fashion.
00:06:15.870 - 00:06:44.494, Speaker A: And let me explain a little bit more. So, for those of you who are not familiar with Eve call, EC call is an JSON RPC method that is used behind the scenes every time you use a readonly function. For example, if on the front end I do die balance off user address, what's actually happening behind the scenes is that I'm calling the JSON RPC provider EC call and it's providing it with a transaction object.
00:06:44.494 - 00:06:59.326, Speaker A: For example, an address the two address the data blob and then it will return me the data. So that's what's going on behind the scenes. A little known fact is that you can actually use Ethcore to query data from mutable functions.
00:06:59.326 - 00:07:08.518, Speaker A: An example of this would be the uniswap quota. So traditionally, the uniswap quota is a write function. It's a mutable function.
00:07:08.518 - 00:07:24.182, Speaker A: For example, the function quote exact input is external. It's not external view and it's not external pure. What that means is that if you're using it based on the Abi loan, each query will cost you gas.
00:07:24.182 - 00:07:42.480, Speaker A: But you can actually do it in a view only mode and achieve the amounts out without sending a transaction. So you can actually query traditionally read functions in a read write functions in a read only matter. So cool.
00:07:42.480 - 00:07:50.180, Speaker A: That's cool. We can read on write functions. So what? Okay, hear me out.
00:07:50.180 - 00:08:31.760, Speaker A: So what if we hijack Solidity and made it return data in the constructor and write the data extraction logic in the constructor? Then we use ETH call to perform a read only contract deployment to extract out the data we want. Does anyone get that? That means, what if we can write arbitrary code? Because traditionally Solidity does not return any values when you create a contract. So what if we hijack a constructor to force it to return some data, and while deploying that contract, we get back some values? Okay, again, let's recap again what the dog said.
00:08:31.760 - 00:08:46.546, Speaker A: One, we force the Solidity constructor to return values. Two, we write out our business logic in the constructor aka writing out arbitrary code. Three, we use E call to quote unquote deploy the contract.
00:08:46.546 - 00:09:02.838, Speaker A: And upon deploying the contract, our constructor will execute the business logic and return us the data because we've hijacked it to do so. So this is how you force the constructor to return values. We need to go into assembly mode.
00:09:02.838 - 00:09:13.978, Speaker A: Now, we have some kind of arbitrary data that we want to return. Return data. We perform our data extraction logic or business logic, aka arbitrary code in the middle section.
00:09:13.978 - 00:09:33.198, Speaker A: We abi encode it and then rewrite some assembly to force it to return some data. And that is how you force a constructor to return values. Next, once we've written a contract to pass our custom business logic, we can use E call to deploy the contract.
00:09:33.198 - 00:10:01.520, Speaker A: And by deploying the contract with provider call, which uses ETH underscore call behind the scenes, we're able to deploy a contract with custom business logic in a read only manner and extract out our data. The only thing left for us to do now is to format the data into its relevant data types. For example, U into 56 strings or bytes, depending on how you packed it.
00:10:01.520 - 00:10:30.050, Speaker A: And that is how you can query all the state you need for your front end application in one query. Some parting remarks is that Eve Call actually is actually really powerful. It has a lot of undocumented, not well known features behind the scenes, such as the state overwrite set, where you can actually overwrite the code or the storage slots behind the scenes.
00:10:30.050 - 00:10:53.390, Speaker A: You can also override the balances or nonsense of things. It's very, very useful when testing things. GEF, the most popular ethereum execution layer, has a GraphQL server behind the scenes, so you can also extract a lot of data through GraphQL instead of the traditional RPC methods.
00:10:53.390 - 00:11:01.594, Speaker A: Yeah, I have a proof of concept on my GitHub. It's GitHub.com libmcallabuser.
00:11:01.594 - 00:11:18.760, Speaker A: There's a proof of concept there if you guys would like to check it out. Yeah, thanks for listening. Any questions? Yes, I realized I went a bit quick here.
00:11:18.760 - 00:11:44.290, Speaker A: Have you done any benchmarking to see what the actual performance improvements have been? I mean, this is more like it's the same. I mean, it's all on latency, you're offloading the computation to the ethereum node, so you're not actually on speed wise, it's the same because you're not actually doing any additional the amount of data isn't that significant. Yeah, it's kilobytes.
00:11:44.290 - 00:12:05.300, Speaker A: Unless you're on like, I guess, 2G or 3G, it might make some issues, but I think traditional on on most apps, it shouldn't matter. Yeah, because there's a contract size limit of, I think, a few kilobytes. Are there any protocols using this in production right now? No, I'm using it.
00:12:05.300 - 00:12:10.380, Speaker A: Yeah, you very much. Awesome, thanks. Thank you.
00:12:10.380 - 00:12:11.030, Speaker A: Bye.
