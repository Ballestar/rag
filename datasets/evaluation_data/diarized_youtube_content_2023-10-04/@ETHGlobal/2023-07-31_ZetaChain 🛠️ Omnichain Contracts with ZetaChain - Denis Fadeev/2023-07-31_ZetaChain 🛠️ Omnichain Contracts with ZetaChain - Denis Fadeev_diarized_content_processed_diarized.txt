00:00:07.610 - 00:00:32.722, Speaker A: So I'm going to be talking about Zeta chain. What is Zeta chain? It's essentially an interoperability solution that lets developers build cross chain DApps, or as we call them, Omnichain DApps. So Zeta Chain offers a solution for developers to just write a contract once, deploy it to Zeta Chain.
00:00:32.722 - 00:01:03.890, Speaker A: And this contract essentially has powers to manage assets on all the connected chains. So, for example, if a user has an asset on Bitcoin, they can send BTC to a specific address. And this BTC becomes available to the contract on Zeta Chain, and your contract can perform logic and for example, swap the token for another token and withdraw it back to a native chain.
00:01:03.890 - 00:01:17.126, Speaker A: So that's called omnichain contracts. It's super easy to start building with Zetachain if the screen comes back alive. I will even show you that.
00:01:17.126 - 00:01:50.030, Speaker A: But Zeta Chain offers also an alternative way of building cross chain DApps, and it's through cross chain messaging. So cross chain messaging is instead of deploying a single contract to Zeta Chain, you deploy contracts to a bunch of different chains, and they're using Zeta Chain's API to send messages with arbitrary data between chains. So both solutions have advantages.
00:01:50.030 - 00:02:08.070, Speaker A: The main advantage of Omnichan Contracts is that it drastically reduces the complexity of the system that you're building. So you just have one contract to worry about. Only states is only in one place.
00:02:08.070 - 00:02:28.166, Speaker A: So that's very convenient from an architecture point of view. So the question was, should you deploy it to Single Chain or to all the chains? Or Zeta chain deploys the contract. So it depends on which path you're taking.
00:02:28.166 - 00:02:39.066, Speaker A: For Omnichan contract, you would deploy it once to Zeta Chain, and that's it. You don't need to do anything to any other chains. It just all works out of the box.
00:02:39.066 - 00:02:53.418, Speaker A: If you're using cross chain messaging, you have to deploy it to all the chains you want to connect. So right now, four chains, zeta Chain is in the testnet phase. Four chains are connected.
00:02:53.418 - 00:03:15.494, Speaker A: More chains, of course, will follow. But if you're using cross chain messaging, you're deploying a contract on all four chains and you're also setting an interactor. So you're basically telling to each contract, you're telling the counterparty contract address so that it knows which contract to talk to.
00:03:15.494 - 00:03:50.130, Speaker A: So it's a bit more involved from the architecture point of view, but it's kind of a very well known solution, basically. Right? So if you have an existing application that needs to be augmented to become cross chain, you can use crosschain messaging for specific areas. If you were to build something from scratch, I would recommend looking into Omnichan contract first because it's just so much simpler and it's the killer feature of SATA Chain.
00:03:50.130 - 00:04:32.200, Speaker A: If anyone has questions, let's just jump to questions, I guess, first, which is weird before. Yeah, go ahead. So again, it's like if Omnichan, you just deploy once crosschain messaging, you deploy it to all the chains for cross chain messaging, you will be able to send messages between the chains you've deployed your messaging contract to.
00:04:32.200 - 00:04:49.020, Speaker A: For example, data chain at some point might support like 2050 Blockchains. You might be interested only in three of them or like ten of them. So with crosschain messaging you have to explicitly deploy it to the contracts you're interested in.
00:04:49.020 - 00:05:09.650, Speaker A: So does that the question right now, in the testnet phase, only four chains, so that would be Bitcoin, Ethereum, Polygon, BSc. Of course more chains will follow. And Zeta chain is built on Cosmos tech.
00:05:09.650 - 00:05:23.718, Speaker A: So possibly it will be IBC compatible. If you're familiar with Cosmos, then this will connect it to even more chains. And we are planning on integrating more EVM blockchains and non EVM chains as well.
00:05:23.718 - 00:05:39.386, Speaker A: One of the advantages. So besides Omnichain contracts, the advantages of Zeta chain include Bitcoin interoperability. So not many solutions, especially decentralized solutions, support Bitcoin out of the box.
00:05:39.386 - 00:05:59.262, Speaker A: So from Bitcoin you can trigger smart contracts on Zetachain, which is pretty cool. There's very little overhead and there's nothing you need to do on Bitcoin. You just ask users to send tokens to a specific address and that triggers a contract call on Zeta chain.
00:05:59.262 - 00:06:31.930, Speaker A: And the other advantage is that there's no wrapped assets. So there are wrapped assets on zeta chain when the process happens, right? When you send tokens to a TSS address on a chain, ZRC 20 wrapped version of the original asset gets minted, but only gets minted on Zeta chain for the purposes of swapping and working with it. So it's like representations of the original asset on Zeta chain.
00:06:31.930 - 00:06:43.654, Speaker A: Okay, cool. So let's continue with the slides. So I talked about cross chain messaging, Omnichan contracts.
00:06:43.654 - 00:06:58.994, Speaker A: Now I want to show how well, basically easy it is. So if you go to Zayshain.com Docs, in the developer section, you will see two sections, omnichan contracts and crosschain messaging.
00:06:58.994 - 00:07:14.540, Speaker A: So here is a complete example of an Omnichan contract. As you can see, it's super simple. The only thing you need is Z contract here a couple of imports, and you need to implement on crosschain call function.
00:07:14.540 - 00:07:39.982, Speaker A: This function gets called whenever tokens are sent to a specific address on any of the connected chains. So, for example, if someone sends tokens to a TSS to a specific address on Ethereum, there are two paths. These tokens might be just deposited into your contract on zeta chain.
00:07:39.982 - 00:07:59.562, Speaker A: Or if a user sends tokens and supplies arguments in the data field of the transaction, these arguments get passed to your contract as the message. Then you can decode the message, implement your logic. For example, this contract is super simple.
00:07:59.562 - 00:08:17.594, Speaker A: It just withdraws the tokens to the same chain. Doesn't do much, but it shows you an example of how to trigger an Omnichan contract and how to withdraw. But you can of course swap to a different token and withdraw to a different chain.
00:08:17.594 - 00:08:33.426, Speaker A: Or you can mint tokens on zeta chain. It's really up to your contract, but the logic is super simple. Token transfer on a connected chain triggers this function call and that's it.
00:08:33.426 - 00:08:50.278, Speaker A: And then you can use ERC 20, which is an extension of ERC to withdraw the tokens back. Right now Omnichan contracts support native gas tokens as well as ERC 20. Of course, more asset types will be added later.
00:08:50.278 - 00:09:23.940, Speaker A: ERC 20 need to be whitelisted by the chain and this is not a centralized solution, not a centralized decision, but the blockchain is going to be very decentralized and people are going to the community is going to be voting on important decisions like which ERC 20 we want to whitelist. If it's whitelisted, a pool will be created internally on zeta chain so that tokens can be swapped and so forth. So as you can see, there's not much to it.
00:09:23.940 - 00:09:33.746, Speaker A: Your contract just need to implement one function. That's it. With cross chain messaging, it's also pretty straightforward.
00:09:33.746 - 00:09:52.590, Speaker A: So here you have a few things you need to implement. First, a function that will use zeta chain's connector API to send data. So you just provide some helpful information like where do you want to send the message to the destination chain.
00:09:52.590 - 00:10:12.340, Speaker A: You need to provide things like gas, but most importantly, you need to provide the message. Here is just a text hello world message. But you can encode any kind of data you want and it will be processed once the function gets called.
00:10:12.340 - 00:10:36.506, Speaker A: This will essentially trigger a process where an event is emitted on the source chain. Zeta chains validators. They run nodes of all the connected chains and when they see a transaction happening, they will vote on zeta chain whether they've observed this transaction or not.
00:10:36.506 - 00:10:53.390, Speaker A: If enough votes are cast, the transaction will go through and will be processed by zeta chain. And on the recipient end you just implement on zeta message. So if the transaction comes through, you just handle it.
00:10:53.390 - 00:11:18.070, Speaker A: For example, if it's a NFT project, you might want to lock the NFT in the send message function right here. Before connector send, you will lock the NFT. You will mint an NFT on zeta message on the receiving chain and maybe send an acknowledgement back to burn the original NFT.
00:11:18.070 - 00:11:44.170, Speaker A: If you got a new NFT minted right, that could be, but again, the architecture is up to you. This is just a kind of low level primitive for you to be able to transfer value and data between all the connected chains. You don't need to worry about zeta chain here at all because data chain works as intermediary here.
00:11:44.170 - 00:12:03.158, Speaker A: So we have a lot of tutorials for everything. You can see a very simple cross chain swap and just what is like 30 lines of code withdraw tutorial. You can also check out the Bitcoin tutorial as well.
00:12:03.158 - 00:12:14.506, Speaker A: Not many projects support Bitcoin, so that's pretty interesting. What I'm going to show the last thing I'm going to show is basically how you would start. So you would go to GitHub.com
00:12:14.506 - 00:12:22.394, Speaker A: Zetachain. We have a bunch of reposts here, but I recommend just cloning the template. So GitHub.com
00:12:22.394 - 00:12:50.694, Speaker A: Theta chain Template when you clone the template, you have something like this, and it doesn't have much, but it imports a bunch of helpful utilities. So if you run NPX Heart Hat, you will get a bunch of helpful tools. So for example, if you need to connect, create an account, you just Hearthat account and it will create an account for you can even save it.
00:12:50.694 - 00:13:02.122, Speaker A: You can hardhead balances. This is helpful because we're dealing with a bunch of chains. So you need to know what kind of tokens you have.
00:13:02.122 - 00:13:15.950, Speaker A: So on all the connected chains, you can see native zeta and zero C 20 equivalents. What is super helpful, I think, is how you get started building. So you have a command, hardhat Omnichain.
00:13:15.950 - 00:13:44.198, Speaker A: And what this does is it accepts a name. So let's call this contract withdraw and a bunch of params like recipient data, whatever from. So what this will do is it will create a contract that you just need to fill in the blanks, right? So it's already there for you and you already have a deploy task, so you don't need to worry about that.
00:13:44.198 - 00:13:57.610, Speaker A: And also a task to interact with it. So you just executed one command to create a new contract. Then you can run hardhap compile.
00:13:57.610 - 00:14:33.310, Speaker A: Now you can just run deploy. Since this is an Omnichan contract, you always deploy it to zeta testnet and of course it doesn't do anything, right? You saw that there's a blank in the contract and boom, you got the contract deployed and you can interact with it as well. So all the boilerplate code is here and there are more tasks.
00:14:33.310 - 00:14:55.830, Speaker A: One more useful thing is if you're building with crosschain messaging, we also have a task for this. So NPX Hard Hat messaging, my contract FUBAR, and this will create a crosschain messaging contract instead. And it has foo and bar here.
00:14:55.830 - 00:15:05.938, Speaker A: So you can already compile it and deploy it to different chains. Let's do that. It's slightly different because with crosschain messaging, you deploy it to several chains.
00:15:05.938 - 00:15:37.008, Speaker A: So let's take early testnet and buy testnet, okay? To compile it first, and what this will do is it will deploy the contract to all the chains you specified, but also set interactors for all the contracts. So it will tell the contract on Mumbai, the address of the contract on Gurley. So it kind of wires everything up together.
00:15:37.008 - 00:15:53.252, Speaker A: So you don't need to worry about that. You just read the docs, understand how it works, and implement the logic of your contract and send data you want to send through this connector. Send Zeta Chains API.
00:15:53.252 - 00:16:09.880, Speaker A: So I don't have much time for anything else. I will be available, as is the rest of the team downstairs at the booth. So please do check out Zeta Chain if you have questions, more than happy to dig into any technical details.
00:16:09.880 - 00:16:25.436, Speaker A: If you're going to be building on, we have a price for the hackathon. More on the website. But please do make sure that you're using Zeta Chain's API and actually build something with cross chain messaging or Omnichain contracts.
00:16:25.436 - 00:16:29.470, Speaker A: That's very important. And, yeah, good luck on the hackathon. Thank you.
