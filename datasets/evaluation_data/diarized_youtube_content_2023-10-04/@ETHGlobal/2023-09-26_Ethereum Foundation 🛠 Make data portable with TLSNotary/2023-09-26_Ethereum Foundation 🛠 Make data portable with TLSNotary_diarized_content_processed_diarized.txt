00:00:07.290 - 00:00:35.270, Speaker A: Hello? Eat global. We are Sinu and Hendrik from the TLS Notary Team, which is part of the Privacy and Scaling Solutions from the Ethereum Foundation. So first I'm going to introduce you notary, show you why we build it, how it works, and then Sinu will give a demo of how you can use it for your projects.
00:00:35.270 - 00:00:59.242, Speaker A: So first, why do we build TLS NoTree? So I assume everybody knows what TLS is the transport layer security. So it allows for a secure way for Alice to get data from a web server. And TLS guarantees that the data indeed originates from the origin and that the data was not tampered with, so that the data is authentic.
00:00:59.242 - 00:01:20.470, Speaker A: But what TLS does not help you with is make that data portable so you can share it with somebody else. And so that's where TLS Notary steps in. So TLS Notary gives you a way to make your data portable and also use your data with a third party.
00:01:20.470 - 00:01:37.194, Speaker A: So this is more or less what TLS Notary looks like. So the magic sauce is that we introduce multiparty computation. So before we go move further, no confusion here.
00:01:37.194 - 00:01:42.766, Speaker A: So it's not man in the middle. So it's not that the verifier of Bob gets in the middle.
00:01:42.868 - 00:01:43.182, Speaker B: No.
00:01:43.236 - 00:01:52.270, Speaker A: Instead, multiparty computation. Alice and Bob have to work together. They each have a key share to communicate with the server.
00:01:52.270 - 00:02:17.554, Speaker A: That way, Bob knows that Alice follows the protocol and cannot cheat about the content of the data. And at the same time, Alice knows that Bob only sees encrypted information, so that Alice is in full control of what she shares with Bob in a later state. So this is also something very important for TLS Notary is privacy.
00:02:17.554 - 00:02:42.720, Speaker A: So TLS notary also supports selective disclosure. So Alice can redact parts from the data before sharing the plain text data with Bob. And this can also be further enhanced with zero knowledge tools, so that you also can share information about the redacted parts in a way that Bob only knows statements about it instead of seeing the actual text.
00:02:42.720 - 00:03:10.470, Speaker A: The concept of checking the TLS communication can also be generalized so that you can get generic notaries that check that the data is authentic. And in that way, Bob only checks the content of the data. But in this scenario, of course, Bob has to trust the Notary before he accepts that the data is trustworthy.
00:03:10.470 - 00:03:16.780, Speaker A: So that was very quickly, but now the more interesting part, how you can use it for your project.
00:03:21.890 - 00:03:46.514, Speaker B: Hi everyone. I'm just going to give a relatively short demo on how to use our project to query a server for some private information and generate a cryptographic proof that can be used to selectively disclose a discord DM to someone else without revealing the proverbs authentication token when doing so. First, let's hop over to our repo here.
00:03:46.514 - 00:03:58.002, Speaker B: So this example is in our repo and you can follow along if you want to. So it's under Tlsn examples Discord, and we have a README here for what's going to happen. So, yeah, I'm approver.
00:03:58.002 - 00:04:15.198, Speaker B: I want to prove to someone that I've received a private DM. I don't want to use OAuth, I don't want this server's help, but nonetheless, I want to be able to selectively disclose that I received a DM to someone else. So here's the Discord web app.
00:04:15.198 - 00:04:20.734, Speaker B: I'm logged in already and I received a message for myself here. Hi. Youth global New York.
00:04:20.734 - 00:04:41.826, Speaker B: So what I'm going to do to just get the access token here is refresh and I'm going to go into the browser and I'm going to find an API request that contains my authentication token. And you could definitely hijack this account right now if you wanted to once you see this, but please don't do that. So here's my authorization token.
00:04:41.826 - 00:04:54.074, Speaker B: So this is what the browser sends along with my request to the Discord server. I'm just going to grab that, I'm going to pull it out into my example here. So we just have an environment variable file here.
00:04:54.074 - 00:05:09.898, Speaker B: I've already got my access token loaded into it. And one more thing that I'm going to need here is the channel ID, or like, the conversation relevant to this message. So I'm trying to prove this message here from me, and the conversation ID is just up here in the URL.
00:05:09.898 - 00:05:22.574, Speaker B: So I'm going to generate a cryptographic proof that I received this message and I'm going to show it to someone else. So to do this, we need two different things. So there's going to be the prover and there's going to be a Notary.
00:05:22.574 - 00:05:31.250, Speaker B: So the notary is going to essentially help me do this. I will just fire that up over here. So I just started up a Notary server.
00:05:31.250 - 00:05:39.654, Speaker B: It's kind of generic. It just sits there listening for requests. And on the left side here, I'm just going to clear this out.
00:05:39.654 - 00:06:02.170, Speaker B: The left side here will be the prooper flow. So before I run this, I'm just going to quickly walk through what this actually looks like and how you could modify this to do something more interesting than disclosing a DM message. Essentially, you can query anything on the Internet and generate a cryptographic proof of its authenticity, disclose like, portions of it to a Verifier.
00:06:02.170 - 00:06:19.560, Speaker B: So any web server that supports TLS and any data that you can think of. So, yeah, I'm just going to use our approver library here. So, yeah, we're going to connect to Discord and we're going to connect to the local notary that I have running in that other panel there.
00:06:19.560 - 00:06:46.874, Speaker B: And we're just going to use basically just generic rust tooling, the hyper library, to construct a request and send it off to Discord server. But what we've done is you're essentially exposed to a generic TLS connection. So from your perspective, you just get this TLS connection, you pass it into the request library and you can just interact with APIs as you normally would with any other connection.
00:06:46.874 - 00:07:02.350, Speaker B: But then afterwards we're going to finalize it and get approved. So, yeah, I'm going to just set up some generic configuration for the prover here and it will connect to the notary. They'll perform some MPC related setup at the beginning.
00:07:02.350 - 00:07:15.154, Speaker B: And then after that, we're going to actually connect to the application server, send off the request, and get the response back. So, yeah, let's walk through that a little bit here. So here I'm just constructing the request.
00:07:15.154 - 00:07:35.294, Speaker B: This is just the API endpoint for discord's. API? And I'm going to query for this specific conversation and I'm going to pass in the user agent and Auth token that I just pulled out of the browser. Once I do that, I'm just going to get the response and it's going to print it out.
00:07:35.294 - 00:07:52.526, Speaker B: And from there we will finalize, I guess, the process with the notary. And from there we essentially do a bunch of finalization of MPC behind the scenes for you. What you get is this kind of succinct proof of the transcript of all the communications with the server.
00:07:52.526 - 00:08:03.510, Speaker B: And then once we get that proof, we can selectively disclose portions of it to a verifier. So I'll just run it here. You're not really going to see anything interesting, but hopefully it works.
00:08:03.510 - 00:08:15.282, Speaker B: This is a live demo. So I'm querying discord's API right now. And done.
00:08:15.282 - 00:08:23.620, Speaker B: So, yeah, I just connected to a notary. You see an error there? Let's just sweep that under the carpet for a SEC. It did actually successfully complete.
00:08:23.620 - 00:08:36.278, Speaker B: So, yeah, now it's saved this JSON file here. This is essentially just the notarized session. So this contains all the private data of the session as well as a signature from the notary.
00:08:36.278 - 00:09:11.046, Speaker B: And using all this data, you can construct proofs from it. I will go down to the actual proof generation section of this code and you can see that we essentially where's the so we're identifying all of the ranges in the TLS transcript that actually contains public data and private data. We need to differentiate between that when it actually commits.
00:09:11.046 - 00:09:42.150, Speaker B: So essentially what I've done is just implemented a simple helper function here, but it just looks for the Auth token in the TLS transcript, identifies the ranges in the transcript there, and then we commit to the surrounding data as well as the Auth token itself. And we get a bunch of different commitment IDs from this. And then later when we actually generate our proof down here, we just say, okay, we want to reveal the data that corresponds to only the public ranges and we're going to redact specifically just the Auth token from the proof.
00:09:42.150 - 00:09:55.820, Speaker B: So, yeah, it builds the proof. And that also just got saved down to a JSON file here. Once again, just a small JSON file that just contains essentially just the proof itself.
00:09:55.820 - 00:10:13.262, Speaker B: And then we have another example here is what does the verification process look like for a proof? Like this? This is just a simple Verifier. It just deserializes the proof from the JSON file and it Verifies it for you. So it's pretty simple.
00:10:13.262 - 00:10:24.302, Speaker B: You essentially just need to provide the notary's public key. So in this situation, we used a notary. So the Verifier actually does need to trust the notary that the data is authentic.
00:10:24.302 - 00:10:50.220, Speaker B: So we pass in its public key and it essentially Verifies the server certificate. And then it also is going to print out the redacted TLS transcript, run the Verifier and it's done. And I'll just show you the output here so you get the general gist of what just happened.
00:10:50.220 - 00:11:10.030, Speaker B: So this is the entire TLS transcript that occurred with the Discord server. So the prover revealed essentially everything except here you can see that the authorization header in the request which would allow you to hijack their session if they had this. This has been redacted out and replaced it with X's.
00:11:10.030 - 00:11:21.182, Speaker B: So the Verifier here has done a few things. One, they verified the identity of the server. They checked the server's TLS certificates, so they know that this actually came from Discord server.
00:11:21.182 - 00:11:52.270, Speaker B: They verified the notary's pub key and in this case they trust the notary so that they know that the data is authentic. And now you can just parse this data out and I guess your application here could be like a DM Verifier and it would just parse the contents of the server response and say, oh, look, this message was in fact sent to this account at this time and this is the content of it. So again, you can think of replacing this DM flow with basically any information on the Internet.
00:11:52.270 - 00:12:02.366, Speaker B: And yeah, that's essentially the demo. I'm glad that it worked for the most part. So, yeah, you can go to our GitHub repo.
00:12:02.366 - 00:12:18.326, Speaker B: We have a couple other examples. We have a Twitter DM example and just some example code for how to set up a notary and such. And then yes, that's essentially yeah, repo, you can find our docs and stuff.
00:12:18.326 - 00:12:34.550, Speaker B: Where's the station? Here we go. Yeah, so Tlsdry.org, you can find us there and you can also find our docs as well.
00:12:34.550 - 00:12:45.960, Speaker B: Great, thank you. Do you have a question? Yeah. Do you separate the fundamental app? Well, you have to commit to it first.
00:12:45.960 - 00:13:04.320, Speaker B: So before the notary gives you the signature, you essentially say, these are the ranges that I'm going to commit to. The notary doesn't see any of the private data, but you still have to identify where it is and then commit to it. Then the notary will sign your commitments and then you can take those commitments over to a Verifier and open specific commitments to the Verifier.
00:13:04.320 - 00:13:12.556, Speaker B: Are there any other questions? I think I only got five more minutes or so. So we do have a prize here. Hackathon.
00:13:12.556 - 00:13:24.850, Speaker B: We have five K. Our project is very early stages, so you're going to be pretty brave and ambitious if you're going to try to use our libraries. But we thought that we'd come here and see if anyone has any cool ideas, can just hack on it, see what you can do.
00:13:24.850 - 00:13:36.250, Speaker B: And yeah, any kind of application. Of course it will be super interesting, but any sort of tooling as well. If you want to build anything that just complements or integrates with the protocol generally, that would be extremely helpful as well.
00:13:36.250 - 00:13:39.130, Speaker B: And all right, I think I can end it there.
