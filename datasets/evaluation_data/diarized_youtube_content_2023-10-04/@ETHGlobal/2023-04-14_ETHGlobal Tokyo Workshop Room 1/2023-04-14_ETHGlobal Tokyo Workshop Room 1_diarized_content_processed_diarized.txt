00:12:30.390 - 00:12:33.500, Speaker A: It test.
00:12:35.630 - 00:12:36.700, Speaker B: Hello. Hello.
00:12:37.390 - 00:12:38.140, Speaker A: Good.
00:12:48.340 - 00:12:52.530, Speaker B: Anytime. All right. Hi everybody.
00:12:52.530 - 00:13:01.850, Speaker B: Oh, come on in if you want. Yeah, I'm going to kick this off. It's 430 now and if people are joining meeting later, that's okay.
00:13:01.850 - 00:13:07.096, Speaker B: I'm going to talk to you about Celo. So thank you for joining. I appreciate you folks being here.
00:13:07.096 - 00:13:17.180, Speaker B: Looking forward to seeing what kind of ideas you have. And if you need any help, look for people with bright yellow shirts. We are in one of the main halls.
00:13:17.180 - 00:13:32.336, Speaker B: I want to talk about Celo today. Celo is a blockchain protocol. I can't move this blockchain protocol that is built for what we believe is prosperity for all.
00:13:32.336 - 00:13:44.804, Speaker B: The blockchain started with a focus on mobile user experience. So trying to help people reach people through their mobile devices. It being the most common computer that people have access to.
00:13:44.804 - 00:13:55.416, Speaker B: And first off, I just want to say who I am. My name is Eric Nakagawa. I'm actually from San Francisco and I'm happy to be here in Tokyo and looking forward to meeting each of you.
00:13:55.416 - 00:14:09.070, Speaker B: I lead the developer relations team for the Sela Foundation. And I have here Anna and a bunch of folks at our booth who are here to help out throughout this whole thing. So we'll be here with you as long as we can.
00:14:09.070 - 00:14:32.628, Speaker B: We've got Anna Harpal, daniel and Viral. So I'll talk about what's Sello I'm going to do some demos, then we'll talk through Bounties because I think you folks are going to want to know how to maximize your chances for winning a bounty from Cello, from the Cello prizes. So like I said before, Sello is kind of built with a focus on prosperity for all.
00:14:32.628 - 00:14:49.256, Speaker B: We actually launched a project back on Earth Day, which is coming up, by the way, next week, back in 2020. And when Solo started, we didn't have the word regenerative finance. What we had kind of focused on was social impact, climate and things like that.
00:14:49.256 - 00:15:14.896, Speaker B: But now with the word regenerative finance, it's allowed us to have a better word or term to use to kind of describe the work that we do. And the way that we look at the work that we do on Sello is to focus on more than just the financial impact. We also want to figure out a way to have an additional change that in many cases can be climate, it can be helping your community.
00:15:14.896 - 00:15:36.612, Speaker B: And some of the projects that have been built on Sello focus on refi. And actually some of the early kind of leaders in the space have been around the concept of universal basic income. It's a project on Sello that I love called Impact Market, which helps to distribute money to people all around the world through a UBI kind of concept.
00:15:36.612 - 00:15:40.932, Speaker B: Another one that recently joined Cello. It's a project you should take a look at. It's called good dollar.
00:15:40.932 - 00:16:03.436, Speaker B: Good Dollar is also another project that helps to distribute money to people where they need it. And actually one of the projects here, if you're looking at bounties, superfluid launched on Sello to support good dollar's migration to Sello. And so if you're looking for bounties to stack, take a look at Superfluid.
00:16:03.436 - 00:16:10.336, Speaker B: They are launched on mainnet, not on testnet right now. But if you folks need some help, come find us. We can help you get set up with Celo.
00:16:10.336 - 00:16:27.716, Speaker B: You don't need a lot of tokens to deploy your contracts. Other things that Sello has helped focus on has also been national capital backed currencies. And that means things like land and trees and tokenizing that and this is very common nowadays.
00:16:27.716 - 00:16:40.984, Speaker B: But just remember two years ago nobody was really talking about this and we're happy to be a part of and have so many more people joining this community with us. Other things that actually attracted me the most to Sell was this concept of community currencies. I'm from Hawaii.
00:16:40.984 - 00:16:56.672, Speaker B: I live in San Francisco, but I'm from Hawaii. And the concept of the value of land being given to the people to do something with it, I think has been really powerful. And I've actually benefited from some people that have locked away land for native Hawaiians also.
00:16:56.672 - 00:17:11.604, Speaker B: Kind of creating money without debt or nurturing the community of people that are building these things that are either climate focused or social impact focused. We also won a prize, which is cool. We won a crypto award last year.
00:17:11.604 - 00:17:24.020, Speaker B: I'm very happy to be recognized. So what is cello? Sello is l one. So if you're thinking like, how does this help me? If you're writing solidity this weekend and you're going to be deploying your contracts, you can deploy to Celo.
00:17:24.020 - 00:17:48.144, Speaker B: It's EVM compatible and allows you to a lot of tooling that we'll get into that can help you to deploy your contracts. We also have a bunch of core contracts that can help you out. There are several stablecoins that are over collateralized stablecoins that can be used as a core part of your if you're building like a DeFi thing, you can support CUSD which is a USD type stablecoin, c Euro, c Real.
00:17:48.144 - 00:17:57.972, Speaker B: So you have some support for Brazilian users out there. And then as I'd mentioned before, Celo was launched with a focus on mobile. And what we mean by that is everybody here has a phone.
00:17:57.972 - 00:18:10.728, Speaker B: I'm pretty sure of it. But how many people have you met with a phone that don't have a crypto wallet? It's actually very common. So one of the cool features that Cello had built from the beginning has been a concept of being able to send money to a phone number.
00:18:10.728 - 00:18:27.452, Speaker B: And the way that it works is very straightforward. If the phone number you do a lookup and if that phone number has a wallet address, you just send to that wallet address. If it doesn't have a wallet address, you can set up an escrow so that when that phone number is attached to a wallet, it can then release those funds.
00:18:27.452 - 00:18:32.416, Speaker B: And so it's a great way to onboard a lot of people. So again, I don't know. I'd love to hear some of your ideas, kind of areas of focus.
00:18:32.416 - 00:18:48.816, Speaker B: But if you're trying to build for global south or any sort of like emerging market or you're looking for ways to help onboard new people into the space, not just people that have been in crypto space for a long time or they still call it crypto, like me, but into the web. Three space. Then take a look at some of those tools.
00:18:48.816 - 00:19:13.790, Speaker B: And one of those tools would be called Otis, which is a way to securely prevent people from kind of just like attacking the service to figure out who's in your address book. And Social Connect, which is phone number support. And then we've also started adding support for things like GitHub and other social accounts that just help you to send money on Sello without needing a wallet address.
00:19:13.790 - 00:19:40.036, Speaker B: If you look at how many people are using, are these numbers a little bit outdated? Over a million unique wallets and seeing where people are based, it's quite a large number of people. Again, spread in Latin America, across Europe, in parts of Asia. And we're really proud of the number of people that are using Cello in addition to the people that are using it.
00:19:40.036 - 00:20:11.120, Speaker B: There's a lot of companies that also support this. So Cello has over 200 members of alliance for Prosperity, which is a commitment for organizations to support reaching Cello's goal of prosperity for all from, I think within the first month of launch, cello introduced the concept of carbon offsets. So from the beginning we've had a bunch of offsets in place and it's offset a large number of CO2.
00:20:11.120 - 00:20:34.144, Speaker B: There are actually some new proposals coming out that will actually increase the amount that goes towards offsetting through both validator awards opting in, as well as increasing the amount of the amount that's being burnt towards the offset fund. There's over a thousand projects built on Sello. Again, these numbers are very round.
00:20:34.144 - 00:20:44.836, Speaker B: It sounds big, but there's a lot of real people building projects on Sello. And I mentioned projects like Good Dollar Impact Market. There's a lot of games, there's a lot of all sorts of projects.
00:20:44.836 - 00:21:05.136, Speaker B: And again, these numbers a little bit outdated, but over 200 million transactions on Sello, I think last time I saw it was like around 250. So a ton of people throughout the world here's, just a kind of a quick glimpse of users across over 150 countries. So when you're building on Sello, you're building to potentially help people in all these different countries all over the world.
00:21:05.136 - 00:21:35.144, Speaker B: And we're really excited to see what you can build. So as I mentioned before, Celo is l one, it's proof of stake. And what that means is nowadays it's a little bit different but it means there's very fast finality so if you make a transaction it gets settled very quickly and it can be useful for people that are building financial services and they want to make sure that when something is completed, it's completed and submitted on chain.
00:21:35.144 - 00:21:56.508, Speaker B: I'd mentioned the optimization for mobile first development. In addition to the phone number mapping, we also have some mobile ZK type support for lightweight mobile clients. I don't know if you can really work on that in a hackathon to be honest, but something to think about when you're trying to build out your growth plan for your project if you do decide to turn it into something bigger.
00:21:56.508 - 00:22:13.872, Speaker B: One cool feature that I like about Solo is again, when you're starting with somebody who doesn't have a wallet and they only have a phone number and they then associate their mobile phone with their mobile number with their wallet and tie that together, how do they transact?
00:22:13.936 - 00:22:14.164, Speaker A: Right?
00:22:14.202 - 00:22:57.360, Speaker B: Like how do you start from no tokens or no gas? How do you pay for gas? One of the things that Sello does offer is being able to pay for gas with some of the stables so you can pay with CUSD CRO CRL and the Main cello token. And the reason that this is, I think, really cool is, again, you could say onboard some person take their number, deposit, I don't know, a penny, and then have enough gas to transact as much as you need in that short amount of time until they actually either bring in some funds or do something of value on the chain. So yeah, paying with ERC 20 tokens is a great benefit and that number of tokens that are supported can expand.
00:22:57.360 - 00:23:16.376, Speaker B: In fact, Good Dollar right now is looking to include their token as a method for paying for gas and the reason I think that's exciting is that could help to onboard tons of more people just with good dollar to pay for their tokens. It's not here yet, it's a covenants proposal that's coming together and very exciting. We also have a bunch of Regent or Refi type building blocks.
00:23:16.376 - 00:23:29.836, Speaker B: So Tucan recently announced retirement of carbon and that's pretty cool. I've never actually done that until recently. I've heard about the concept of carbon but never actually did something with it.
00:23:29.836 - 00:23:58.504, Speaker B: I mean, even still today I can't even what does it look like? Is it in my it's hard to touch and reach but if you can do something on chain like that and this interests you, take a look at Toucan, who's deployed on Mainnet and available to you to build this weekend. The community is decentralized. And just like every project, I mean, it seems obvious, but there's a lot of community proposals that actually I think someone here, juan from the community is actually here.
00:23:58.504 - 00:24:19.424, Speaker B: He's a volunteer has been helping to create a Dao to focus on Latin America. So people that are trying to start things in Latin America can go directly to the people that know the problems they're trying to solve and allows them to propose to those groups. We have also a bunch of cross chain interoperability out here.
00:24:19.424 - 00:24:41.110, Speaker B: There's Hyperlane. Hyperlane is another project you can consider as if you're trying to stack your bounties. If you're building for Hyperlane, include the they supported Cello kind of early on and some of the team from Celo started that company and it's a very friendly space.
00:24:41.110 - 00:25:00.200, Speaker B: I mentioned the stablecoins and then transaction fees are very low. It's proof of stake so it's extremely low and really I think good for just doing either high volume of transactions or not impacting the user. So you're not like spending a lot of you're not having to second guess how much you're going to spend on these transactions.
00:25:00.200 - 00:25:26.656, Speaker B: We have a bunch of primitives I know this is very hard to see which projects are supported on solo but some of the ones that I'm most excited about is our recent work around chainlink is still not launched yet but working on that I mentioned Impact Market. There's full MetaMask support so you can just swap in the chain quite easily. If you're looking for a mobile wallet, take a look at Velora Valora and then also Opera.
00:25:26.656 - 00:25:58.364, Speaker B: Again, there's tons of little icons that if you zoom in I'm sure you've heard of these projects and protocols. There are several AMMS like SushiSwap, we have Uniswap as well and I mentioned some of the other projects like Good Dollar and others like that. So there's a lot and I think you have all the tools you need to build in addition to the tooling that's there, there's also a lot of projects or companies helping to kind of again commit to the alliance for Prosperity.
00:25:58.364 - 00:26:13.780, Speaker B: I mentioned 200 of them. Some of them include Mercy Core T Mobile runs validators on cello, Grammy and foundation. Impact Market now runs a validator so a lot of great projects helping to secure the network in addition to building on top of Zello.
00:26:13.780 - 00:27:01.380, Speaker B: And then as you're thinking about refi and what that means, think about building your smart contracts with some purpose beyond of course it's a hackathon but can it do more than just accrue value? Can it actually have an impact? Beyond that there are also upon launch I mentioned that a portion of the reserve was going to offset carbon and right now I think the amount is like 0.5%. With some of the new changes that are coming it's going to be much larger. I'm excited about that and if you're building into the refi space consider building your project and pitching it to Climate Collective which is a fund that actually invests in climate projects.
00:27:01.380 - 00:27:18.588, Speaker B: Again, I had mentioned on chain carbon assets if you go to selloreserve.org you can see the full list of where that's all going and you can double check in terms of actually building this weekend you can launch on Infura. infera supports cello.
00:27:18.588 - 00:27:29.736, Speaker B: There's also QuickNote, I think they might be a sponsor. And then lava. If you're looking for a more decentralized endpoint infrastructure in terms of refi or tools to use, take a look at Toucan.
00:27:29.736 - 00:27:49.516, Speaker B: I mentioned Impact Market and one of my new favorites called Spirals, which actually takes staking rewards and actually just redirects them for you to a bunch of climate protocols or climate options for cross chain messaging. They don't like you saying that, calling everything a bridge. Take a look at hyperlane.
00:27:49.516 - 00:27:55.364, Speaker B: There's also Allbridge Portal and XLR support. And then Oracle's chainlink. Coming soon.
00:27:55.364 - 00:28:05.748, Speaker B: We also have Redstone, Pith and Band and some others. And Superfluid. I mentioned superfluid? And for Wallets, if you're building, I would be building using MetaMask.
00:28:05.748 - 00:28:13.288, Speaker B: It's so easy. But if you're trying to get into multi sigs, of course include Safe at Safe Sello.org deployed by the Safe team.
00:28:13.288 - 00:28:26.744, Speaker B: And then finally when you're troubleshooting your transactions, ether Scan is on Sello. But we call it Cello Scan because everything has its own name. So use that for troubleshooting your smart contracts on both testnet and mainnet.
00:28:26.744 - 00:28:36.112, Speaker B: And then? Same thing for Explorer Sello.org. That's the alternative blockchain explorer. So what I want to do is just show a Quick project.
00:28:36.112 - 00:28:52.016, Speaker B: I know you folks can't really build until eight, so you got a couple more hours. But if you're looking to just prototype and build something really quickly, I wanted to demonstrate. So what we call sello, it's actually called ETH global Tokyo.
00:28:52.016 - 00:29:10.120, Speaker B: You can scan this QR code if you're looking for a starter project. And this is just it running. What you'll get when you start it up is going to be a simple starter page with a video explainer a storage protocol running I think on both mainnet and testnet.
00:29:10.120 - 00:29:26.620, Speaker B: And this is really simple, it just takes numbers. And the reason that we pulled this together was Scaffold ETH is here and Cello Composer, which this project is built on, is based off of Scaffold ETH. We just added a bunch of changes to make it a little bit easier.
00:29:26.620 - 00:29:37.190, Speaker B: So if you're trying to build for React, we got you. If you're trying to build React native both expo or non expo, you can use that. If you want to use Flutter, because some people prefer building in Flutter, you can use that.
00:29:37.190 - 00:29:50.360, Speaker B: And then we also have angular support too. Here's just a quick example. The reason that we wanted to give you folks this is you don't have much time and anything we can do to kind of help out is great.
00:29:50.360 - 00:30:00.892, Speaker B: We also embedded in this. We expose a subgraph just to help with iterating through the responses. And it's very simple.
00:30:00.892 - 00:30:26.164, Speaker B: So it's already a published subgraph on the graph. And of course, demos don't work ever in real life, but trust me, these images are there. And you can use this to kind of jumpstart your project if you're going to be kind of doing NFTs or something like that, or if you're going to be publishing data in some sort of fashion that may need a way to iterate kind of quickly through that data without parsing it yourself.
00:30:26.164 - 00:30:57.064, Speaker B: Take a look at the subgraph support and then this is a little bit out there, but Masa Finance recently launched on Sello and we've introduced just a quick lookup for let me just kind of this will not work. I think I own this one. So it's just a way to quickly look up similar to like ENS, Masa Finance.
00:30:57.064 - 00:31:04.364, Speaker B: Take a look at that. And again, these are just some example projects. There's more that we've included in the repo.
00:31:04.364 - 00:31:20.630, Speaker B: So there's a couple of branches if you want to take a look at spiral's implementation, we have that as well. We didn't want to include it here because it was still kind know, these things are they might be not ready for production per se, but enough for a hackathon for sure. And then going back to my slides real quick.
00:31:20.630 - 00:31:50.656, Speaker B: So yeah, I wanted to show you folks this and then I wanted to show you Cello Composer. So if you're thinking that project seems a little bit too basic, you can use Cello Composer. And what Cello Composer can do is just like with just like with Scaffold ETH, you can quickly spin up like a bare bones project.
00:31:50.656 - 00:32:04.850, Speaker B: Just want to run through this real quick. Give me a second. So you can run this.
00:32:04.850 - 00:32:20.004, Speaker B: I'm sure it'll work for you. It may not work for me, but you just run a command line and you can just quickly choose let me scroll down. Quickly choose what you want to build.
00:32:20.004 - 00:32:25.300, Speaker B: So you got React, react native flutter and Angular. And we built this to speed up time. This can get you started in like 5 seconds.
00:32:25.300 - 00:32:37.772, Speaker B: I'm sure you don't need that much time. You can use two projects for accessing the cello network. Either react cello or Rainbowkit and then hard hat or Truffle support.
00:32:37.772 - 00:32:53.296, Speaker B: And it can come with kind of a basic subgraph. Again, it depends what you're trying to build. But we're just trying to help you folks speed up the time to launch your project and make sure you folks don't get kind of caught up with stuff because it's based off of Scaffold ETH, they can help you out.
00:32:53.296 - 00:33:05.110, Speaker B: But we are happy to answer any questions you folks might have. And another fun thing actually is I wanted to show you this. I wanted to show you folks this project.
00:33:05.110 - 00:33:27.112, Speaker B: This one is funny. So someone in the community actually built a chat GBT based off of our docs. And so you can quickly ask it like which libraries support fee, currency fee? Currency Support is paying gas with ERC, 20 tokens.
00:33:27.112 - 00:33:35.452, Speaker B: So you can just ask it. Let's see if this demo works. Oh my gosh.
00:33:35.452 - 00:33:50.448, Speaker B: Of course anyway so you can ask questions about how many validators are on cello. You know, how demos work. Oh, here we go.
00:33:50.448 - 00:33:54.692, Speaker B: It actually came back. Okay, great. So it tells you any sort of information you might come up with.
00:33:54.692 - 00:34:10.692, Speaker B: You can ask us, we're happy to help you out, but if you just have a quick question, just ask the Cello GPT project. The link is here in the presentation and then I think we can also include it in our Notes on the hackathon information page. So let's talk about Bounties.
00:34:10.692 - 00:34:23.564, Speaker B: Sorry for taking so long, but we're here. So we have five different prizes that we're going to be giving out. Climate Refi focus, as I mentioned earlier, payments, DeFi or any utilization of stablecoins you'll be good.
00:34:23.564 - 00:34:34.976, Speaker B: There public goods and sort of community type efforts. If you're trying to build something that's more Dao focused, consider the Dao NFT gaming section. And then finally wild card, we're just going to choose the best project comes through.
00:34:34.976 - 00:35:06.780, Speaker B: If you're looking for ideas for the climate refi bounty, take a look at topics like natural capital Tokens. If you're building an oracle, if you want to add incentives, if you want to add liquidity for natural capital tokens, staking, regenerative, finance or anything that offers stability for payments, it could be lending front ends use cases for cross border payments. Cross chain lending protocols using superfluid will count here specifically.
00:35:06.780 - 00:35:24.944, Speaker B: And then low liquidity asset pricing auctions and then finally using mental stable. So I'd mentioned CUSD CRL CRL for public goods. We are looking for projects that either have educational elements to it, some sort of content production either from the community or from your team.
00:35:24.944 - 00:35:45.956, Speaker B: Increasing awareness about cello that's more obviously helping benefit get the word out about cello. And then for DAOs, most of these Are going to Be dow focused, but ways to kind of create the concept of more fractional dows, more education. Some of these May overlap, and you can apply for both if you think your idea fits the concept of dissolvable dowels.
00:35:45.956 - 00:36:13.356, Speaker B: Like what happens when our job is done and we're able to move on. What does that look like? And then in the concept of NFTs, more dynamic type NFTs, we're interested in seeing those, especially if there's a refi component, especially with refi having a change in our planet, it should be able to reflect that on NFT, some sort of carbon NFT mechanism, play to earn, but with an offset component, some sort of carbon offset. And then final wild card, we're going to look for things that are more experimental, maybe more researchy.
00:36:13.356 - 00:36:32.532, Speaker B: So like offline transactions, anything that deals with privacy. Take a look at Plumo, which is our project that helps to create a lightweight client, mobile client, ZK mobile Client we've been looking for ways to see someone in the community build a WASM like client. Some sort of better way to kind of estimate gas.
00:36:32.532 - 00:36:58.936, Speaker B: So like gas estimation is generally hard, but something that could be better than what we currently have on chain would be nice and then some sort of method for in the community like voting on proposals, things like that. And as I mentioned before, when Solo started, we aimed for the mobile use case. And the challenge with mobile use case is you're dealing with people who might not be technology literate or number literate.
00:36:58.936 - 00:37:23.640, Speaker B: And so how can you design a browser that can work for folks that aren't familiar with English kind of designs and layouts and then finally, again, these are more researchy but like referral rewards or cashback programs for the specific criteria. It's actually not that complicated for us. We're just looking that your project matches one of the Solo bounties.
00:37:23.640 - 00:37:32.528, Speaker B: If you have a question, come and see us. If you are stacking your projects, here's a couple here that we're happy to talk to you about. So superfluid hyperlain.
00:37:32.528 - 00:37:56.224, Speaker B: As I mentioned, safe, uniswap and graph subgraphs. The main technical criteria is I'm expecting really cool projects, but you got to deploy your contract to testnet or mainnet and demonstrate it to somebody on our team. There's about five of us, so you should definitely have an opportunity to find someone to demonstrate and that's pretty much it.
00:37:56.224 - 00:38:13.210, Speaker B: So we wish you all the best of luck. We will be hanging out both physically here and for folks who are working remotely or if they're not here right now, they're watching the stream. We'll be in the cello sponsor discord channel and that's it.
00:38:14.060 - 00:38:14.810, Speaker A: Cool.
00:38:18.700 - 00:38:33.822, Speaker B: I think I have a little bit of time for Q A if anybody has specific questions and if we run out of time, I think we only have like three minutes. Happy to have a conversation outside or away from the next speaker. Any questions? No?
00:38:33.976 - 00:38:34.630, Speaker A: Okay, cool.
00:38:34.700 - 00:38:37.206, Speaker B: All right, thank you very much.
00:38:37.228 - 00:42:35.750, Speaker A: Everybody's ready to go?
00:42:40.780 - 00:42:41.530, Speaker B: Good.
00:42:43.040 - 00:42:57.872, Speaker C: All right guys, if I could have you guys have a seat here. Thank you so much. All right, thank you guys so much for coming.
00:42:57.872 - 00:43:04.508, Speaker C: My name is Kevin Jones. I am also Aka Shutterblock ETH. You may see me running around taking photos.
00:43:04.508 - 00:43:16.916, Speaker C: I'm also a photographer for the event, so I do a little bit of both and I'm also a developer advocate for Scaffold ETH the that's why we guys are here today. We're talking about scaffold ETH. I don't actually have any slides.
00:43:16.916 - 00:43:28.876, Speaker C: This is all going to be like live demo and we're going to go through and actually do a live demo and show how it works. This is all my contact information if you guys want to save my contact info. But everything we're going to do is going to be live demo.
00:43:28.876 - 00:43:33.484, Speaker C: And if you're looking to get started with Scaffoldeth can you guys see that?
00:43:33.522 - 00:43:34.110, Speaker A: Okay?
00:43:34.560 - 00:43:34.972, Speaker D: Yeah.
00:43:35.026 - 00:43:47.840, Speaker C: Okay. If you do a Google search for Scaffold ETH, you're going to get one of the first links that's going to come up is going to be the docs or the actual GitHub repo. So everything you really need is in those two pages.
00:43:47.840 - 00:44:05.092, Speaker C: If you actually go to the GitHub repo, it's going to have a README that's going to walk you through how to get up and running. We're going to do that in real time and we're going to kind of build a DAP and show kind of what the process looks like here as you go. So let's go ahead and just kind of dive right into it.
00:44:05.092 - 00:44:16.948, Speaker C: I'm using tmux, which is basically a terminal multiplexer. It's just going to allow me to have multiple windows open at the same time. You pretty much always need like three windows open to get started with Scaffold ETH.
00:44:16.948 - 00:44:33.464, Speaker C: And that's because you're running Hard Hat in a chain window and you're running your front end. So in React and then that third window is kind of where you're doing like your deploys and your other command line stuff. Okay, so I've already gone ahead and basically checked out the repository, so we're good to go.
00:44:33.464 - 00:44:48.032, Speaker C: I've also gone ahead and I did a yarn install because that takes a little while to do. That's actually going to go out and get all the dependencies and install everything you need to get up and running. Once you're there, then the next thing all you need to do is just do Yarn Chain.
00:44:48.032 - 00:45:10.476, Speaker C: So Yarn Chain is going to spin up a copy of Hard Hat. Hard Hat is this kind of like virtualized ethereum, virtual machine that you're running locally and it's going to come with all of these kind of like play accounts that have some play ether in there. And so we can start kind of taking that Ether and kind of testing our assumptions of our smart contract, right? So you're always going to kind of keep that first window open.
00:45:10.476 - 00:45:24.816, Speaker C: That window is where you're going to just kind of see your console output for Hard Hat. In the next window, you're going to do a Yarn Start. Okay, sorry, what's going on? There we go.
00:45:24.816 - 00:45:32.540, Speaker C: Yarn Start. Okay, so Yarn Start is going to spin up a copy of React. So another core component of Scaffold ETH is react.
00:45:32.540 - 00:45:50.452, Speaker C: So that's going to take a second to kind of get up and running. But once you get up, this is exactly what you're going to see. It's going to spin up on Port 3000, a copy of Scaffold ETH, and you can kind of think of Scaffold ETH as this kind of like UI and this front end that's kind of already plugged up for you with your smart contract.
00:45:50.452 - 00:46:03.736, Speaker C: So it actually comes, scaffold ETH comes with a smart contract. But if we go here to this second tab, which is the Debug contracts, which is kind of like the sweet sauce of Scaffold ETH, you'll see here that it's not loading and that's because we haven't done a deploy yet. So we got.
00:46:03.736 - 00:46:20.508, Speaker C: To go back to here. And like I said, we're always going to have these two windows open, our back end, which is Hard Hat, and our front end, you can see that we got some console output from Hard Hat, and we can see that react started up successfully. So all we need to do is come down here to this next window and do a yarn deploy, okay, so I can do yarn deploy.
00:46:20.508 - 00:46:30.932, Speaker C: And it's going to do exactly that. It's going to deploy my smart contract. It's going to tell me the address for the account, and then it's also going to show me how much gas and how much time it took.
00:46:30.986 - 00:46:31.444, Speaker B: Right.
00:46:31.562 - 00:46:45.544, Speaker C: So we're up and running, and now we should have a copy of our smart contract here, which we do. So what do we got here? It's a very basic smart contract. It's got a purpose, so it's got one variable, and then it's got a function already written for us that's going to allow us to update that.
00:46:45.544 - 00:46:50.712, Speaker C: Right? And one of the cool things about Scaffold ETH is it comes with what's called burner wallets.
00:46:50.776 - 00:46:51.052, Speaker D: Okay?
00:46:51.106 - 00:47:12.560, Speaker C: So if you're building a DAP, you're going to have to hook up some kind of provider and then do all that stuff. This is kind of already done for you inside of Scaffold ETH, inside of the browser. So if we look up here in the corner, we get a copy of a private key and a public key that's in the browser, and we have the address and we could actually go to it if it was on a main net.
00:47:12.560 - 00:47:23.460, Speaker C: And then we could also just grab some funds so we can take some funds from Hard Hat and basically add them to our DAP. We're up and running, and then we can start interacting and interact with our DAP.
00:47:24.600 - 00:47:25.350, Speaker B: Sorry.
00:47:28.520 - 00:47:36.564, Speaker C: Thank you. All right, so we see here we have a purpose, okay? And it's just a variable. And then we have an ability to update that purpose.
00:47:36.564 - 00:47:41.788, Speaker C: So if I come over here and just say like foo, like this and hit send, it's going to allow us to change that state.
00:47:41.874 - 00:47:42.316, Speaker D: Okay?
00:47:42.418 - 00:48:00.096, Speaker C: So we've spun up our DAP, we've interacted, we've got some gas from Hard Hat, and we've made some changes to that smart contract. We could also come over here and get a new copy of the contract by doing a yarn deploy reset. So reset, and that's going to force a new copy of the contract, and then it's going to revert the state.
00:48:00.096 - 00:48:12.084, Speaker C: So you can almost think of it like the deploy as this kind of way just to kind of reset your smart contract and then kind of test your assumptions as you start building, which is exactly what we're going to do next. Right. So let's load up our smart contract here.
00:48:12.084 - 00:48:25.384, Speaker C: So let's go code and let's load that up. The first time that you load here, if you're using vs code. It's going to ask you to trust the contract or basically trust the repository, which I recommend you do.
00:48:25.384 - 00:48:51.728, Speaker C: And if you have highlighting for Solidity, it's going to show you exactly what your smart contract is going to look like here. And when we look at the project for Scaffold ETH, there's this Packages folder, okay? And inside that Packages folder there's essentially like two main places we're going to spend majority of your time. One is the Hard HAP folder and that's going to be inside the Contracts folder and the Deploy folder which we're going to get to in a second.
00:48:51.728 - 00:48:59.748, Speaker C: And then you can find your contract. So this is a copy of the kind of Hello World smart contract. And we can see here's the purpose that we have.
00:48:59.748 - 00:49:11.992, Speaker C: And then we have like an empty constructor and then we have this function that allows us to update that purpose. Okay, so it's a real basic smart contract. It's almost like a hello world, right? And then we have below that we have the React app as well.
00:49:11.992 - 00:49:24.124, Speaker C: So if you go under Hard hat, there's also the React app which we're going to go into a little bit but we're not going to touch that too much in this demo. But really majority of time you're going to spend probably is here in the Contracts folder. So we could hard code a change like this.
00:49:24.124 - 00:49:40.770, Speaker C: Like hard code awesome apps or something like that. If I can type today like that, save it. And then we could do a redeploy and then you will see that it was successful and then we can see that that change is reflected in our front end so we could start doing some changes.
00:49:40.770 - 00:49:52.128, Speaker C: So one of the first things that you learn when you're writing a DAP is you probably want to have some kind of like access control. So let's do something here. Let's create a new variable.
00:49:52.128 - 00:50:04.120, Speaker C: So we're going to make it an address variable. We're going to make it public and we're going to call it Boss, okay? And we're going to basically grab our burner wallet which is right here inside the browser. Again, we're not using MetaMask or anything like that.
00:50:04.120 - 00:50:11.804, Speaker C: And then we're just going to basically paste that in here and then save it and then redeploy. Let's do that. Sorry, let me close these out.
00:50:11.804 - 00:50:21.320, Speaker C: These are going to get in the way the whole time. Okay, so let's go reset. So now we are going to have a new variable.
00:50:21.320 - 00:50:37.604, Speaker C: So we see that the UI is automatically transformed. We see we have a new variable, it's called the Boss and it matches what our burner wallet is. So what you're going to want to do then at this point, let's say you wanted to create some kind of function that only that particular boss could call, right? Let's do that here.
00:50:37.604 - 00:50:50.808, Speaker C: Let's create a require statement. So the next thing you'll learn is you can do like a require and you can do message sender. So with Ethereum you have access to or with Solidity you have access to the variables for who's calling that function.
00:50:50.808 - 00:51:11.820, Speaker C: And so message sender is anyone who's going to sign a transaction for that function, right? So we're going to require that the message sender is equal to the boss, otherwise not the boss. Something like that and sorry, like that. And then let's close it off, save that and redeploy so you can kind of see what we're doing.
00:51:11.820 - 00:51:33.924, Speaker C: We're kind of automatically been able to get up our instance, start making some changes to our smart contract and start testing our assumptions. So let's try to test that. So now what I want to do is I'm going to bring up an incognito window, okay? I'm going to go to localhost 3000, same DAP and we're going to go to it and then we're going to try to make a change on this kind of new user account we have.
00:51:33.924 - 00:51:52.552, Speaker C: So here we have this kind of like purple blocky guy and then here we have this kind of like green blocky guy. And so if I get some funds from the faucet and I try to make a change to foo like this and then hit send, it's going to tell me not the boss. So we've been able to kind of implement some access control on the smart contract.
00:51:52.616 - 00:51:53.132, Speaker D: Okay?
00:51:53.266 - 00:52:07.472, Speaker C: So that's actually not the proper way to do access control. There's a much easier way and so what you can do is you can utilize what's called ownable which is an open zeppelin contract. So we're going to do that instead.
00:52:07.472 - 00:52:25.564, Speaker C: So let's kind of revert what we did. Let's get rid of this here and let's also get rid of this hard coded address here like this and let's save and instead you'll notice up here there's like a commented out section where it allows us to import another smart contract. So with Solidity you can import a smart contract.
00:52:25.564 - 00:52:42.248, Speaker C: So in this case we're going to import the open zeppelin ownable smart contract. And when you do that you can then inherit that smart contract in here as an inherited wood like this. So we're going to import it, inherit it and then we get access to essentially all of the functions.
00:52:42.248 - 00:53:19.428, Speaker C: We get access to the modifiers, the variables that are defined when that particular smart contract is deployed. So let's save that, okay? And then let's go ahead and redeploy. So Scaffold Ethers is kind of like I said, continuous loop where you're kind of testing some things, deploying your changes, going back to your UI and then kind of like testing your assumptions so we get to this point and then what's different here? Anyone notice we don't have the boss variable anymore because we got rid of that but we have this new owner variable, okay? So owner should be the owner of the smart contract, right? But we would expect maybe that it's going to match our burner wallet.
00:53:19.428 - 00:53:28.020, Speaker C: But it does not. It's a random private key or public key that's there. That is the very first account that comes from Hardhat.
00:53:28.020 - 00:53:50.076, Speaker C: So because we're using Hard Hat to deploy our smart contract, the very first contract or account is the deployer. Okay? So what we need to do now is we need to actually adjust the Hard Hat deployment configuration script. So if you look inside the Hard Hat folder, right below that, there's a deploy script, right? So we can go here and we can actually start making some changes to our deploy script.
00:53:50.076 - 00:53:56.544, Speaker C: So we want to have access to this smart contract. So we don't want it just to be this random Hard Hat config. We want to use the burner wallet.
00:53:56.544 - 00:54:14.328, Speaker C: So if you go to this file, it's going to show you exactly how the smart contract is being deployed and it's going to show you what the parameters are. And then you'll notice here there's a section that's already kind of like grayed out that you can just kind of copy from that allows us to get a copy of the deployed smart contract. So we're going to do that next.
00:54:14.328 - 00:54:45.928, Speaker C: So we're going to create a variable called your contract and we're going to use Ethers to get that contract that's here with the deployer, which is, again, it's the very first account of Hardhat. And then you'll also notice that I mentioned it earlier, but when you inherit a smart contract, you get access to all of the functions and you get access to the modifiers and the variables. And so you'll notice that our smart contract Debug contracts tab has automatically adjusted again to add some new functions.
00:54:45.928 - 00:54:58.528, Speaker C: And the most important one that we're going to be using today is the transfer ownership one. And that's going to allow us to transfer the ownership of the smart contract basically out of the Hard Hat deployer account. So let's call that.
00:54:58.528 - 00:55:16.728, Speaker C: So we can just come in here and basically we can grab this, which also is just kind of already written for us, and we can paste it right below. And then this allows us to use that variable, call the transfer ownership, and then input whatever private or public key that we want to here. So we can grab this here, right? This is our burner wallet.
00:55:16.728 - 00:55:31.696, Speaker C: We can paste it here and we can hit save and then we can go ahead and redeploy again. So now during the deploy, not only did it deploy the smart contract, but it should have also transferred it. So let's see if it did, it did.
00:55:31.696 - 00:55:44.810, Speaker C: So now the owner is going to match our account here. So we kind of are starting to build our smart contract. So we're going to kind of close out the deploy script because we're kind of good with that right now.
00:55:44.810 - 00:56:02.776, Speaker C: But I do want to show how you would use that ownable smart contract earlier we did the require statement, but Ownable also has the only owner modifier. So we actually need to add that if we're going to do anything that's access controlled here. So we can put it as a modifier.
00:56:02.776 - 00:56:16.064, Speaker C: Basically all a modifier is, is it's another function that gets called before that existing function is executed. So it always checks to make sure that only the owner could call this function. We're not going to use that yet.
00:56:16.064 - 00:56:31.110, Speaker C: So let's go ahead and close that. Because it's not really too interesting to have a function that only you can call on your smart contract, right? You want to make it publicly available and publicly open, right? That's the whole purpose. So instead let's kind of build something else.
00:56:31.110 - 00:57:16.100, Speaker C: Let's do another require statement here, but this time let's also require instead of we're checking the message sender, let's require that there's a value passed, right? So let's do message value is equal, equal to a price, otherwise not enough, something like that. Now we need to set that that price, right? So UN public price equals so we can just type in here like exactly what we want. So we're going to do zero one ether like this and then we're going to go ahead and redeploy.
00:57:16.100 - 00:57:35.496, Speaker C: Okay? So now again, we have our contracts modified. We have this new price variable which is interesting. And then now if we want to call this purpose to like foo like this and hit send, it's going to say we haven't sent enough money, right? We need to send some value.
00:57:35.496 - 00:57:52.976, Speaker C: So what we can do is grab this kind of like amount that we want to send. And you would think you could just put it in like this, right, and send that. But we have to deal in Way instead of decimals, right? So what's cool about Scaffolds that has this little green button, you can just click that and it's going to do the math for you.
00:57:52.976 - 00:58:07.156, Speaker C: So it's going to multiply that times ten to the 18th power and it's going to give us what we need in Way and then we can hit send. And I don't have enough gas. So here's where we can say, all right, well maybe that little $20 that we got from the faucet was not enough.
00:58:07.156 - 00:58:29.612, Speaker C: So we can grab our address, we can come down here to the corner to this little other wallet and it's just unlimited supply of ETH. Basically we have almost 10,000 ETH so we can paste our address here and we can get like $1,000 and hit send. Or if we want to, we could also do it in ETH as well, right? So you have this kind of ability to just grab as much money as you need and then get going.
00:58:29.612 - 00:58:36.040, Speaker C: So now let's hit send. There we go. So now what's cool is our smart contract is acting as a bank.
00:58:36.040 - 00:58:55.430, Speaker C: We've actually established this cool like vending machine, right in our smart contract. So I could actually come over here to this kind of incognito guy. I could come over here, get some funds, also send $1,000 over here and I could say I am cool or something like that and 0.1
00:58:55.430 - 00:59:07.716, Speaker C: send. And then anyone can use it, right? We have this kind of like cool vending machine. But what's the problem? We can't get the money out.
00:59:07.716 - 00:59:13.016, Speaker C: How are we going to get the money out? So let's figure out what we need to do to do that, right? We need to create a withdraw function.
00:59:13.118 - 00:59:13.624, Speaker D: Okay?
00:59:13.742 - 00:59:22.910, Speaker C: So let's write that real quick. So we're just going to do like a function called withdraw like this. And we're going to make it public.
00:59:22.910 - 00:59:37.952, Speaker C: But this time we're going to use the modifier. We only want the owner to be able to call it, right? So now we can do a so we'll set a boolean called success. Otherwise we won't set that.
00:59:37.952 - 00:59:53.768, Speaker C: And then we'll do a message sender. So whoever's calling this function, we will do a call and we will pass the value as the entire balance basically of the contract. So we'll do address of this smart contract and we will take the balance like this.
00:59:53.768 - 01:00:01.450, Speaker C: And then we need to close this off. Did I type that right? Hopefully we did. Let's save that, make sure it works.
01:00:01.450 - 01:00:03.320, Speaker C: Deploy.
01:00:04.540 - 01:00:05.096, Speaker D: Cool.
01:00:05.198 - 01:00:19.420, Speaker C: So we get this word error, but for the most part it's going to work at this point. So let's take a look at our DAP. So now if we kind of come over here and we make a change to it, say foo like this and hit send, we're able to put the money in there.
01:00:19.420 - 01:00:29.296, Speaker C: And if we come over here to the incognito account so let's do that. And then we kind of try to try to get those funds from here. We have the withdraw function.
01:00:29.296 - 01:00:41.552, Speaker C: It's going to tell me, no, I'm not the owner, right? So I don't have access to withdraw that. But if I come over here and I hit send, then boom, I'm able to withdraw those funds. And those went from the smart contract into my wallet.
01:00:41.552 - 01:01:10.530, Speaker C: Okay, now what's interesting is we could actually just make one small minor change with the smart contract. And just to show what's interesting is, we can take we have that variable, that's price, right? We're setting the price up here above we could do something like this where we could say price equal price times 100, I don't know, divided by sorry, times 101 divided by 100, something like that. Yeah, let's do that and then let's redeploy that change.
01:01:10.530 - 01:01:27.030, Speaker C: Okay, so now if we come over here and we make our change, we say what's up and hit send. What do we see? That happens. Now the price is it's got a curve, right? We've got this cool.
01:01:27.030 - 01:01:43.112, Speaker C: Not only is it able to accept value and anyone can interact with it, but it's also on a price curve and we can start doing some really interesting things with our smart contract. Okay, so at this point, I do want to kind of show a little bit more. Let's see here.
01:01:43.112 - 01:02:11.600, Speaker C: So if you kind of are just getting started with smart contracts or writing smart contracts, scaffoldeth is just a good solution because, like I said, it comes with kind of all the stuff you need really quick. Shill is if you guys are interested in kind of like testing your ability and kind of going through the process of building different kinds of apps, I would recommend checking out Speedrun Ethereum. Speedrun Ethereum is cool because you can just connect your wallet and you can kind of go through various challenges.
01:02:11.600 - 01:02:13.316, Speaker C: Need to unlock this real quick.
01:02:13.338 - 01:02:14.150, Speaker B: Let's see.
01:02:15.720 - 01:02:29.864, Speaker C: So it's got obviously a Web three type of experience where you can check in with your MetaMask. I don't know why it's not working right now. Make sure I'm on the right 1 second here.
01:02:30.062 - 01:02:30.472, Speaker B: Okay.
01:02:30.526 - 01:02:33.112, Speaker C: Connect wallet. MetaMask. All right, there we go.
01:02:33.112 - 01:03:20.052, Speaker C: It's got this cool experience where you can actually go through and do different challenges, right? So like the very first challenge is you build an NFT, deploy an NFT, then you do a decentralized Staking app, a token vendor, and then eventually you actually get invited to what's called the Build Guild or the Biddle Guild. The Biddle Guild is a collection of developers myself, and there's some other build guilders here that are trying to help the ecosystem and bring it forward by providing value as enhancing Scaffold ETH or just doing things in the environment to help support Ethereum. And the cool thing is, if you actually become a part of the Build guild, you can do some work for the Build Guild and you can be incentivized to do that and actually get streamed ETH if you become a core contributor or someone that's involved in the Build guild.
01:03:20.052 - 01:03:40.892, Speaker C: So since the Build Guild has been out, there has been over 353 ETH that has been streamed to other developers and we have about 700 other builders or people that have interacted with the Build Guild and about 700 different builds of Scaffold ETH. So it's a really cool way for if you guys are trying to get involved in a community to kind of do that. So that's my real quick shill on if you're getting started.
01:03:40.892 - 01:03:57.748, Speaker C: Those are kind of great next steps for you guys even after the hackathon. But if you're building a hackathon project, build it on Scaffoldeth because it's going to be a huge head start for you. And another thing too is if you go to Scaffold ETH and you go to the core GitHub repository, there's two things.
01:03:57.748 - 01:04:10.808, Speaker C: One, there's a Scaffold ETH Examples directory which has a bunch of starting points for like ERC, 720, 111, 55, you name it. You can just come over here and just do a search. So let's say I want to search like 721.
01:04:10.808 - 01:04:32.844, Speaker C: It's got an example of what that would look like. Or you could just do like NFT and then there's some NFT examples in here as well. So check out that and you can essentially fork that specific version and then you have a starting point for your project so that you don't have to reinvent the wheel and it really gives you a leg up on getting started with the hackathon.
01:04:32.844 - 01:04:55.024, Speaker C: So that's my recommendation. Now there's another couple of things I always get asked, like, okay, well, what if I like Next JS versus React? Or what if I like TypeScript versus JavaScript? There is a new version of Scaffold ETH, so it's called Se Two and I'd recommend checking it out. It's a special GitHub repository.
01:04:55.024 - 01:05:12.380, Speaker C: You can come down here and do a search for it. It's Se Two, so it's in a test, so it's still being tested. It's not the full on replacement for Scaffold, so it doesn't have a lot of the forks that you would find with the original version, but it is a little faster.
01:05:12.380 - 01:05:33.732, Speaker C: And if you feel more comfortable with Next JS and with TypeScript, that might be something that you guys can try out if you're competing in the hackathon. I would recommend though to probably use the very first version of Scaffold just because it's a little more vetted and it's got more starting points right for you. I want to show you what Scaffold Two looks like real quick.
01:05:33.732 - 01:05:42.868, Speaker C: So I'm going to have to just shut down this R1 quick. So let me do that. And then I've got copy of here.
01:05:42.868 - 01:05:46.216, Speaker C: So I'm going to do the same thing. I have se. Two already checked out.
01:05:46.216 - 01:05:58.620, Speaker C: I'm going to do a yarn chain. Again, this is if you're using just separate windows. Second window I'm going to do a yarn start, right? And then in the next window I'm going to do yarn deploy.
01:05:58.620 - 01:06:09.200, Speaker C: Okay, so contracts deployed. Looks like it's up and running. Let's take a look.
01:06:09.200 - 01:06:13.038, Speaker C: Boom. Locals 3000, same port.
01:06:13.124 - 01:06:13.886, Speaker D: There we go.
01:06:13.988 - 01:06:23.506, Speaker C: So looks completely different. So pretty much all the demo that I did is not going to make sense. But it's got the same concepts, right? It's got the burner wallet, right? You can do the same thing.
01:06:23.506 - 01:06:38.682, Speaker C: You can press a button to grab funds from the faucet. You just have the debug contract folder, or a tab I should say, where you can actually test your read and write functions. You can see your variables listed, you can see the contract and how much balance it has.
01:06:38.682 - 01:06:56.382, Speaker C: And then there's an example UI as well, which is a little bit more enhanced and it's built again on NextJS. So depending on, like I said, how comfortable you are with dealing with maybe some caveats with Se Two, this would be an option for you guys as well. So leave that up to you guys.
01:06:56.382 - 01:07:00.190, Speaker C: You guys can decide. So that's awesome. All right, so we got five minutes for questions.
01:07:00.190 - 01:07:03.330, Speaker C: So I know there's going to be some questions, so let's tackle those.
01:07:03.400 - 01:07:12.862, Speaker B: Yes, I like how Scaffold helps out people like me who enjoy solidity writing smart contract, but I hate front end development.
01:07:12.926 - 01:07:13.762, Speaker A: I hate all.
01:07:13.896 - 01:07:24.258, Speaker B: Yeah, and I know you didn't want to go into it, you didn't want to go into it, but I'm wondering, is there some kind of demo you can show on how somebody like me can get started with the front end using Scaffold?
01:07:24.434 - 01:08:06.050, Speaker C: Yeah, it definitely is a little bit of basically the question was for people that are more into writing smart contracts and more interested in the backends and not necessarily front end developers, where do you get started? So some of the challenges have some the Scaffold Speedrun Ethereum challenges have some level of stuff you do with the UI. But let me just give a real quick run through of it so you can kind of have a start. So here in React app, we have the React app folder, and then we have the SRC folder, and then inside of there, there is basically not the Components folder, but the Views app.
01:08:06.050 - 01:08:23.002, Speaker C: JSX is kind of like Scaffold ETH app, right? So you can think of this as kind of everything that's already written for you. All the variables that are defined, all the functions, all the hooks and stuff like that are already loaded for you. And so a lot of the magic sauce that you see is what you see here.
01:08:23.002 - 01:08:29.814, Speaker C: Inside of the Views folder is where your home JSX files. So let me go back to Scaffold. I don't have the other one loaded.
01:08:29.814 - 01:08:49.874, Speaker C: But you saw earlier there was some tabs, right? The very first tab is kind of where you would build your app, so you would focus on doing stuff inside of that kind of like home folder. And then the Debug Contracts is like for that. So home JSX is that kind of first tab that just has some kind of like examples for you and it just kind of gets you up and running.
01:08:49.874 - 01:09:21.758, Speaker C: Well, it's getting dark in here. And then there's an example UI area, which is probably what I would recommend for you because that's going to give you some examples of how you interact with signing a transaction or sending a transaction, or getting some kind of value from the smart contract or reading a value. So example UI, and then there is also some stuff in Hints, but really example UI is probably what you're looking for as kind of that help that handholding and it gives you some examples as you go through here and you can see what they look like.
01:09:21.924 - 01:09:23.086, Speaker A: Yeah, thank you.
01:09:23.108 - 01:09:25.600, Speaker C: Yeah, no worries. All right, what do we got? What else?
01:09:26.130 - 01:09:54.406, Speaker B: Just to add to that question, because I know in the Scaffold ETH organization, there's some very work in progress repositories for extracting out some of you guys, like the hooks and components that are being used in Scaffold ETH. I haven't read anything about it in terms of what the long term goal is, whether or not that is something for kind of someone with the same profile of making it really easy to have an address input or all these other things that I think I've seen being actively developed on the yeah, I.
01:09:54.428 - 01:09:59.500, Speaker C: Mean, I don't know what the goals are. I don't know if awesome ones come up here. Not to throw you under the bus there.
01:10:02.350 - 01:10:03.978, Speaker A: We thought that E hooks was going.
01:10:03.984 - 01:10:05.626, Speaker B: To be a thing in Scaffolding One.
01:10:05.648 - 01:10:06.618, Speaker D: And we pulled out the hooks and.
01:10:06.624 - 01:10:26.242, Speaker B: Components, and then Wagme made the same thing and made it popular, so we threw our joy there. Okay, so we use Wagme, but when you're talking about that address input component, there's a really good one in Scaffold too, but it's still in Scaffold. We need to make it into NPM components eventually, so you can just install just the address input if you want it.
01:10:26.242 - 01:10:33.570, Speaker B: So there are components, but they're still built into Scaffolds right now. But feel free to steal them and take them out. Sorry.
01:10:33.570 - 01:10:39.730, Speaker B: Yeah, TLDR Scaffold Two has good address input, and we're using Wagme.
01:10:39.810 - 01:10:40.546, Speaker C: Wagme.
01:10:40.658 - 01:10:41.320, Speaker A: Yeah.
01:10:42.010 - 01:10:46.220, Speaker C: I like youth folks. All right, cool. What are the questions?
01:10:47.870 - 01:10:48.620, Speaker B: Oh.
01:10:52.430 - 01:11:02.350, Speaker C: Which libraries are we using for Scaffolding too? It's probably actually scaffold NextJS for next. JS okay. Yeah.
01:11:02.500 - 01:11:07.578, Speaker B: Wagme Rainbow Kit and then a bunch.
01:11:07.594 - 01:11:12.982, Speaker D: Of our own components, right? For, like, CSS and tailwind.
01:11:13.146 - 01:11:21.314, Speaker C: Tailwind, yeah. And there also is a next JS build of Scaffold ETH one. So you can use that.
01:11:21.314 - 01:11:31.960, Speaker C: If you just go in here, there's a next JS TypeScript build. It works pretty well. So if you don't want to use Scaffold E Two, you still want to use Scaffold ETH, that might be another option as well.
01:11:31.960 - 01:11:38.060, Speaker C: Awesome. Thank you guys so much for coming. And if you guys have problems, let me know.
01:11:38.060 - 01:11:49.774, Speaker C: Yes. Get some swag with some stickers. I don't even have these.
01:11:49.774 - 01:11:50.960, Speaker C: You guys got to get this.
01:15:09.370 - 01:15:13.400, Speaker A: Hello. Okay. Hello, everybody.
01:15:13.400 - 01:15:21.370, Speaker A: Hello. My name is Roche. I work with the Ethereum Foundation on account abstraction.
01:15:21.370 - 01:15:43.970, Speaker A: So I'll start by saying, what is account abstraction, what we abstract and why? So before talking about account abstraction, let's think. What is an account ethereum account? First of all, of course, is an address where we put tokens, NFTs, whatever. This is our account.
01:15:43.970 - 01:15:57.366, Speaker A: Obviously, we have an authentication, which is a private key. ECDSA private key. This account can execute stuff like send transactions, send ETH, send tokens, whatever.
01:15:57.366 - 01:16:13.770, Speaker A: And it pays for gas. It pays for gas using its own Ethereum balance. And all of these is defined by the Ethereum protocol, which means every node on the system knows it, know how to do it, and do it exactly the same like any other node.
01:16:13.770 - 01:16:24.122, Speaker A: So what we abstract, what. We try to abstract, okay, basically almost everything. The account itself will become a contract.
01:16:24.122 - 01:16:38.834, Speaker A: So we have the contract address the authentication in order to abstract it, to extract it out of the system is a method call. It's a method call on the account. We call it we will hear it several times in this talk.
01:16:38.834 - 01:16:48.322, Speaker A: It's called validate user op. The execution can be abstract to whatever you like. Okay? We provide sample execute method or execute batch method.
01:16:48.322 - 01:17:07.194, Speaker A: You can add more if you like, and gas payment. We also select that we have a Paymaster contract which again, once it validates the request, it accepts to pay for this transaction. And the cute thing about all of this is that this is all done without any change to the core protocol.
01:17:07.194 - 01:17:25.598, Speaker A: It is live on testnets on Mainets today. So what can we do with it? Okay, this is a very short summary of what we can do. Authentication.
01:17:25.598 - 01:17:37.938, Speaker A: With a normal account, you have exactly one way to authenticate. That is sign a transaction by a single signer. And if you want multiple, you have problems or you have MPC or something fixed.
01:17:37.938 - 01:17:46.686, Speaker A: But with account abstraction, you can do a wide range of authentication methods. You can choose different signatures. And I gave an example two edge cases.
01:17:46.686 - 01:18:05.246, Speaker A: One of them is a simple gaming system where you want the browser to sign each transaction as long as it's to this limited contract account. So you want very easy signing for gaming account can support that. On the other extreme, you have a corporate account in which different roles have different access.
01:18:05.246 - 01:18:20.526, Speaker A: Some are multi sign, some allowed only to transfer ETH, some have limits, some allowed only to vote I don't know, whatever. So you can have account of any of these. And by the way, when I'm saying use cases, these are use cases that can use account abstraction.
01:18:20.526 - 01:18:32.870, Speaker A: We don't support any of these. You as developers are here to try and find use cases that you can do all of this stuff. Payment again, the account can pay for itself.
01:18:32.870 - 01:18:39.878, Speaker A: This is the default. But there can be a paymaster. And the use cases for Paymaster again are endless.
01:18:39.878 - 01:18:51.378, Speaker A: I gave you two highlights as an example. One of them is onboarding Paymaster. Let's say someone has adapt and he wants to sponsor the sum request.
01:18:51.378 - 01:19:02.206, Speaker A: All requests, I don't know of its users. It's possible you can have a Paymaster that will accept under some condition. It can decide what the conditions are and accept these requests.
01:19:02.206 - 01:19:17.346, Speaker A: And these requests are approved by the Paymaster. Another example, very common, very thoughtful example is a token paymaster. A Paymaster that will pay the transaction.
01:19:17.346 - 01:19:33.686, Speaker A: The transaction is in native token in east. But the paymaster will make sure the user has enough balance, will convert this user's tokens into the native token and pay for the transaction. So from the user's point of view he is paying with tokens.
01:19:33.686 - 01:20:02.846, Speaker A: But again, it's not the system, it's a specific paymaster that decide if and how to do it. Other use cases you can do is we think of are in a recovery mechanism the first and foremost actually most people don't talk about it at all is change your key. Think about that with normal private key once you have an address it is impossible to be changed even if you think it might have been leaked, you're screwed.
01:20:02.846 - 01:20:42.274, Speaker A: You either replace it completely or go and hope that no one will ever use it with account abstraction, account can support change key every normal web two application have changed password and if you even suspect that your account address credentials were compromised replace it with something new. Other, more complex recover mechanism like social recovery can also be created like you trust friends to replace your account or do deadmill recovery or other examples. We have a full talk about half an hour.
01:20:42.274 - 01:20:53.800, Speaker A: A full hour of examples of use cases like I described here and more so you can look there. By the way, it's a QR code of the presentation. You have everything.
01:20:53.800 - 01:21:14.140, Speaker A: Now I'll try to jive and explain the components we have with account obstruction. The first component, of course, is an account. An account is a contract that performs the logic of validation and execution we'll see it in work.
01:21:14.140 - 01:21:42.230, Speaker A: The second component we call it an entry point users don't see the entry points at all developers know about its existence this is where the magic happens this is the on chain contract that performs all the validation and it is trusted by the contracts. The next component again, it's a contract is the Paymaster. As I said, a paymaster is a contract that accepts to pay the gas fees of some transactions.
01:21:42.230 - 01:21:55.010, Speaker A: On the second row, we have user operation. Actually, I'm saying in this talk transaction interchangeably with user operation. We call our account abstracted transaction.
01:21:55.010 - 01:22:04.410, Speaker A: We name them user operation. So a user operation is equivalent of transaction. You filled all the data in it? Some more data than normal transaction.
01:22:04.410 - 01:22:19.674, Speaker A: You sign it using your account signature whatever signature system it uses and you submit it. The next component we have we call a bundler. As we said, we didn't change the ethereum network.
01:22:19.674 - 01:22:32.210, Speaker A: We didn't change the protocol. There are still nodes to run the system. But in order to put user operations on the network we had to add another off chain component we call a bundler.
01:22:32.210 - 01:22:45.690, Speaker A: You can think of a bundler as a node. We actually believe that in a production network it will be run adjacent to a node. It's a functionality of a node to put user operations on chain.
01:22:45.690 - 01:23:16.526, Speaker A: Lastly, the last component like in any Ethereum decentralized network there is a mempool again, it's a mempool of user operation, not a mempool of a transaction and it is important to understand the system but usually are not interacted directly by users or developers. Now let's look at the flow, how user operation is executed. The big component here, this is my wallet.
01:23:16.526 - 01:23:29.506, Speaker A: This is an off chain. Think of MetaMask or sole wallet or any other wallet that implements account obstruction. And the wallet creates a user operation.
01:23:29.506 - 01:23:50.590, Speaker A: It has many fields, as I said, like normal transaction and several few new fields we'll see later. But like Paymaster and the signature, depending on my account, the user operation is sent into the mempool like normal transaction. But this is a user operation mempool.
01:23:50.590 - 01:24:10.730, Speaker A: The bundlers are looking approving this mempool and they pick up the user operations they want to put into the next bundle, the next block they want to sorry, bundlers, as I said, are off chain. Think of node. It's a node.
01:24:10.730 - 01:24:39.428, Speaker A: It's a node with a special functionality for supporting user operations, supporting account obstruction, anything you ask Alex, for you to use Ethereum, do you need to be a node? Okay, same answer. Because as I said, user operation is a transaction. Bundler is equivalent, it's a little different, but it's equivalent to a node.
01:24:39.428 - 01:25:04.508, Speaker A: So you don't have to be there has to be nodes in the system, or there has to be bundlers in the system to support it. So the bundler picked up user operations. And just like a node, if you think about it, a node takes a set of transactions validates that the balance is correct, the signature is correct and the nonsense correct, and then create a transaction.
01:25:04.508 - 01:25:11.216, Speaker A: The bundle does just the same. It validates a transaction. But the way it does a validation is a bit more complex.
01:25:11.216 - 01:25:28.296, Speaker A: This is the simulation phase. It calls a method in our entry point, which calls the validation function the validation of the account and the validation of the Paymaster. If both these methods say okay, this is a valid transaction, it means the signature is okay.
01:25:28.296 - 01:25:36.956, Speaker A: It means the nonsense okay. It means it will pay for the transaction, someone will pay for it, the entry point will validate it. It's a call on the entry point.
01:25:36.956 - 01:25:51.532, Speaker A: It knows that this user operation is valid. So the next phase, after validating, actually each of these user operation, it will go into the execution phase where it creates a transaction. We call it it's a method called handle ops.
01:25:51.532 - 01:26:10.948, Speaker A: It gets an array of user operations and it creates a transaction with it and put it on chain. What this transaction will do it first repeat the validation of each user operation because we don't trust nobody to do anything off chain. Recall the validation, all the validation.
01:26:10.948 - 01:26:51.990, Speaker A: Repeat the exact same validation we did the bundler did previously off chain, of course, revert, if any of them revert, and if they all succeed, we continue to the execution phase. We call the execute method of the account, whatever it's written there, and then you can see that for a Paymaster, we also call what we call a post op a post operation so that a paymaster has a method called before and after the transaction. The method before first validates and then it can do other stuff like reduce the user's tokens to make sure that it will be used and at the post op it will refund whatever the excess that was not in use.
01:26:51.990 - 01:27:33.120, Speaker A: The account execution of course executed transaction so this flow is done for each user operation? Yes. What is the message sender for the transaction? The message sender is the bundler of the entire transaction but for each user operation, the execution is an execute method of the account. So if the account executes token transfer because I want to transfer tokens, the token sees me the account contract as a sender the transaction origin will be the bundler.
01:27:33.120 - 01:27:40.396, Speaker A: The MSG sender will be the account. Yes, the account is wrapped. There are two gotchas.
01:27:40.396 - 01:27:54.600, Speaker A: Okay, I'll get them in a moment. Okay, this is one of them. General don't use yes TX origin if you can avoid it, it's deprecated for a reason and with account obstruction it becomes even more useless.
01:27:54.600 - 01:28:08.350, Speaker A: There is no good reason. All the good reason to use TX origin are actually wrong. If you think you're protecting yourself by somehow using TX origin you are wrong because it doesn't protect you.
01:28:08.350 - 01:28:20.304, Speaker A: So if you want to block account abstraction or contract accounts, then use it, go ahead. But if you want to protect yourself against replay against bots, again you are.
01:28:20.342 - 01:28:20.930, Speaker D: Not.
01:28:23.320 - 01:28:35.568, Speaker A: Yes use message sender. Okay. The transaction itself is paid by the bundler because it is the one who put the transaction on chain.
01:28:35.568 - 01:29:00.700, Speaker A: But the logic of validate user op, as we will see in a moment that the account is supposed to pay for itself. So the account pays the bundler? Yes, the bundler pays the node and as I said, a bundler and a node that distinguish is blurred and they're usually the same entity. So yes, it pays for itself for the execution and gets an extra by the account itself that pays for the transaction.
01:29:00.700 - 01:29:20.384, Speaker A: Now, if you think about the incentive model of Ethereum why do transaction get included? Why do transaction cannot be censored? Because there are nodes out there that eventually will take out of the mempool transaction. The same is true for bundlers. These are bundlers are not ours.
01:29:20.384 - 01:29:29.108, Speaker A: We define the spec, we create a reference. There are already five implementations of bundlers. We are working on a code that they will work with the mempool.
01:29:29.108 - 01:29:47.880, Speaker A: Yes, it is still work in progress, but they're usable as they are today. So again to recap EOA against user operation. As I said, account itself with account it's a contract.
01:29:47.880 - 01:30:05.824, Speaker A: Instead of ECDSA, it is secured by its own code to do the validation. A wallet with normal account can do a single operation which is approve approve everything because you sign whatever it is with account obstruction. You have custom UI.
01:30:05.824 - 01:30:12.372, Speaker A: You have custom logic in the account itself to do whatever you like. Mempool mechanism generally it is the same. It is different.
01:30:12.372 - 01:30:38.060, Speaker A: Object and block builder is equivalent to bundler and its verification is a little bit more complex because it does a view call but otherwise it does just the same. Now I go linked a little into the contract itself. The only method an account has to implement is validate user op.
01:30:38.060 - 01:30:58.420, Speaker A: Yes, of course it need to do some execution, but it is not. We as we write the ERC four, three, seven we define the interface, the concrete interface between actually the entry point and the accounts, how they call the accounts. So we define that an account has to have this validate user of method.
01:30:58.420 - 01:31:08.116, Speaker A: This method received the user operation itself. It received the hash of the user operation. The account can calculate it, but we already need it.
01:31:08.116 - 01:31:21.428, Speaker A: So we pass it to the account itself and someone asks about payment missing funds. The account has to pay its sender which will always be the entry point. It will receive the amount it needs to pay how much is already missing.
01:31:21.428 - 01:31:34.640, Speaker A: We maintain a balance deposit within the entry point. If you have enough, or if there is a paymaster, you will get zero for these missing funds. Otherwise you have to pay at least this amount to cover your user operation.
01:31:34.640 - 01:31:43.216, Speaker A: This is the code of the base account. It's the base contract. You don't have to use it, but we think it's very easy to use it.
01:31:43.216 - 01:31:53.510, Speaker A: It templatizes several of the things you need to do. So we of course require the call is from entry point. You will get griefed and someone will steal your money if you don't do it.
01:31:53.510 - 01:32:08.200, Speaker A: We call the stub method. We'll see in a moment to validate the signature. It will validate the nons if needed and pay prefund is pay this amount if it is not zero back to my owner.
01:32:08.200 - 01:32:23.984, Speaker A: So validate signature is the method I need. Pack validation data is a helper method needed for use cases like gaming. If anyone want, I will not go deeply into that.
01:32:23.984 - 01:32:42.948, Speaker A: But you can define that a validation is valid for a specific range of time. Like if you have a game and you want that your transaction will be valid only for half an hour from now. There is a way for a wallet to convey that information back to the entry point.
01:32:42.948 - 01:33:07.772, Speaker A: It is not allowed to use directly the timestamp opcodes but it can return it using this method. So, as I said, this is the base account we have. And we also have a simple account which is a concrete implementation that uses it and tries to emulate an EOA as much as possible.
01:33:07.772 - 01:33:21.116, Speaker A: It uses a simple signature. It uses the same signature using ethereum signed message so that you can even use MetaMask signed message to sign it. So this is the actual code of validate signature.
01:33:21.116 - 01:33:31.200, Speaker A: It takes the user operation hash it adds the ethereum signed message prefix. This is an open zeppelin helper. It does easy recover.
01:33:31.200 - 01:33:43.000, Speaker A: If it is the wrong sender, it fails, otherwise succeeds. A little note about this method it can revert. Revert is also a way to say okay, I failed.
01:33:43.000 - 01:34:08.656, Speaker A: We did add a different mechanism to report a signature failure because we do want to be able to do the equivalent of ETH call. You want to be able to take a transaction and call like you call the node, you call ETH call to make sure that the transaction succeeds. You want to be able to do the same with to estimate or simulate the user operation before the user signs it.
01:34:08.656 - 01:34:26.916, Speaker A: And there is no way for us to tell the account itself that it doesn't need to sign that we give it a transaction with wrong signature. The hand doesn't know it is called it's very important in our system. It doesn't know it is called off chain or on chain.
01:34:26.916 - 01:34:41.448, Speaker A: It behaves exactly the same. So what we say is that if the signature is wrong, it simply return an error. It is the entry point to decide which knows this is a simulation.
01:34:41.448 - 01:34:57.856, Speaker A: Okay, I return it even though it's a signature failure or is it a real execution, I will revert this transaction because it's a wrong signature. These are the basic execution methods. These are actually very simple.
01:34:57.856 - 01:35:25.144, Speaker A: Again, they require from entry point so that only the entry point can call it. It can be entry point owner because we make our wallet also callable directly by its owner without account subtraction. And there is an execute batch we created which get an array of destinations, array of function and someone might say okay, why don't you pass value here? I said you are completely right.
01:35:25.144 - 01:35:33.324, Speaker A: You are free to take this simple account, add a different execution method and use it. This is not part of the framework. This is a sample sample account.
01:35:33.324 - 01:35:44.960, Speaker A: You can add as many functions as you like to the account. Okay? This is the implementation of a base paymaster. Just like an account.
01:35:44.960 - 01:36:00.512, Speaker A: We have a template method of validate paymaster and postop. Okay? These are the contracts. Now, the contracts can't work alone.
01:36:00.512 - 01:36:18.712, Speaker A: Each contract has to have a wallet that works with with the normal EOAS you have exactly one account type. So every wallet work with that just one account type which is EOA with account abstraction. We have different account and each account need a wallet.
01:36:18.712 - 01:36:30.396, Speaker A: And by wallet I mean the desktop, probably chrome extension or whatever. And the account is the contract. So each account need a contract, sorry.
01:36:30.396 - 01:36:57.560, Speaker A: Each account contract needs a wallet to work with. So to help hackers, we created a project, a boilerplate chrome extension we call Trampoline which can help you create a new account. It is inspired by tallyho and MetaMask, but it is written from scratch.
01:36:57.560 - 01:37:11.550, Speaker A: So within this framework. You can replace the account contract and you can replace the UX that works with it. This is the UX that works with the standard simple account.
01:37:11.550 - 01:37:34.048, Speaker A: So the basic component, we have an account API that gives high level JavaScript APIs we need in order to work with the account. And we also provide three UX react components. Onboarding is a UX that will pop up when you create the account.
01:37:34.048 - 01:37:47.880, Speaker A: Like if you want to collect some information from the user or nothing. If you are silent, you don't need to collect anything. Transaction is the UX that will pop up whenever you send a transaction and of course, sign when you create a signature.
01:37:47.880 - 01:38:13.600, Speaker A: Now, a simple account has to implement several things in order to support a contract. The first is the init code because very important part of an account is to be able to deploy itself. So it is this account API that knows its account implementation and know how to create the constructor, so it creates the constructor signature.
01:38:13.600 - 01:38:27.860, Speaker A: Now, in order to create a transaction, it needs first to get the Nuns, the next Nuns, to be used. Again, this is not some standardized. This is the account to implement this method underneath.
01:38:27.860 - 01:38:53.020, Speaker A: And we need to encode the actual transaction. Once it creates a user operation with this method, we need to sign it again. There's an onboarding, which is an asynchronous UEX that have a method to call if it needs to collect data in order to send a transaction.
01:38:53.020 - 01:39:05.212, Speaker A: And then the transaction itself can modify the transaction just before it receive. Okay, it is called just after send transaction is called by the application. The application calls send transaction.
01:39:05.212 - 01:39:28.010, Speaker A: This provider received this transaction. Now, this looks like a transaction, but we convert it and create out of it user operation that will look like CTCM from the account and it's submitted into the blockchain. So let's see how it looks here.
01:39:28.010 - 01:39:45.756, Speaker A: Okay, first of all, in order to install it, I'll need to disable my MetaMask, enable developer extensions. And where am I? Okay, I'm here in the trampoline project. I should do yarn start.
01:39:45.756 - 01:40:03.992, Speaker A: I already started it, so I can do it. And inside this trampoline project, I load this unpacked. I load the build folder as a Chrome extension.
01:40:03.992 - 01:40:15.268, Speaker A: The Chrome extension is built as a framework as NSN extensions. So this is the framework that I want to create an account. This is the first customizable page.
01:40:15.268 - 01:40:21.716, Speaker A: As I said, this is the onboarding page. You can put whatever you like here. You can see this is the onboarding.
01:40:21.716 - 01:40:44.370, Speaker A: I can open it and add if I want to collect more information. The output of this is a context, and this context is passed to the account to create. This sample doesn't need any no, it create a private key and address and pass it back to the account.
01:40:44.370 - 01:40:59.376, Speaker A: Now, out of this account, I can see its address, and it is not deployed. I don't have a sample here with a paymaster. So what I will do is I will send little ETH so it can be deployed.
01:40:59.376 - 01:41:37.334, Speaker A: You can see how much it's a max limit, how much it needs to be deployed, why it doesn't switch it. I will send some ETH to it. Okay.
01:41:37.334 - 01:41:52.364, Speaker A: I hope Gary will get it fast now. Okay, good for the demo. Okay, now I have some if in my account I can deploy it here.
01:41:52.364 - 01:42:06.560, Speaker A: But instead of deploying, I want to send the first transaction. I open ether scan. This is a pre deployed standard greeter sample and I will use an application.
01:42:06.560 - 01:42:14.508, Speaker A: I want to call this said greeting. I will connect SSCAN to my account. It says MetaMask.
01:42:14.508 - 01:42:35.290, Speaker A: Sorry for that. And this is our extension. Pop up a connection request, we will accept it and then we can send and I can put some message in again.
01:42:35.290 - 01:42:48.460, Speaker A: This is a stub sign in account. We can remove it completely or put if we want to collect more information. Now I see again the transaction data that I want to approve.
01:42:48.460 - 01:42:56.610, Speaker A: I could have skipped the framework can be set. So you will not show this transaction. Oh, it said I didn't pay.
01:42:56.610 - 01:43:06.688, Speaker A: Just a second. Okay. It means it is a little more expensive than what I passed.
01:43:06.688 - 01:43:20.340, Speaker A: It great for sample. Sorry. We are out of time already.
01:43:20.340 - 01:43:21.012, Speaker A: Out of time?
01:43:21.066 - 01:43:22.390, Speaker D: Yes, we are right now.
01:43:22.780 - 01:43:31.000, Speaker A: Okay. They tell me we are out of time. I want to show you some transaction.
01:43:31.000 - 01:43:41.020, Speaker A: We didn't build it alone. We have a lot of partners who worked with us. Stack app alchemy and others.
01:43:41.020 - 01:43:47.256, Speaker A: Build bundlers zero dev candidates, sol wallet already. Build an ether spot. Build some SDKs and tools.
01:43:47.256 - 01:43:52.368, Speaker A: You can use a trampoline. You can do those SDKs. If you want more resources, you have them here.
01:43:52.368 - 01:44:00.050, Speaker A: If you didn't copy the QR code before, this is the bigger one that you can use. We will be here outside if you want to ask more care questions. And thank you.
01:48:15.850 - 01:48:16.502, Speaker D: Hi there.
01:48:16.556 - 01:48:31.820, Speaker E: Okay, so I'm Jason and I'm from airstack. And we have Depesh and Sarvish, two of my co founders. So today we're going to tell you a workshop on how to build more data ware applications using Airstack's technology.
01:48:31.820 - 01:48:45.194, Speaker E: We're going to make this very hands on demo show the APIs, show you how to work with them. If you have any questions on the way, raise your hand. And so overview of airstack.
01:48:45.194 - 01:49:19.930, Speaker E: So we provide web three data APIs that enable developers to easily integrate blockchain data transactions, token balances on chain off chain activities into your applications. And the idea is that you can just rather than having to run a lot of infrastructure on your own, you can just query our APIs and integrate directly into your systems or into your front end. The agenda we have today is I'm going to do a quick show of the cheat codes the AI.
01:49:19.930 - 01:49:46.990, Speaker E: And then Depesh is going to show you how to use the APIs, the way writing, basically how they're formed what's in the APIs and be able to use the full functionality of them. So we'll go through after the AI overview how to get your API key, the rate limits that we currently have the docs for developers headers. What's in the APIs how to create queries with nested queries pagination.
01:49:46.990 - 01:50:02.770, Speaker E: How to run queries directly through your API key. How to run scripts if you want to if you want to add, let's say, hundreds or thousands of addresses at the same time and get responses. And then we'll conclude by showing everyone just a review of the ideas and bounties using airstack.
01:50:02.770 - 01:50:11.210, Speaker E: Any questions before I get started? Okay, so how do I get to a browser?
01:50:13.390 - 01:50:14.140, Speaker B: Cool.
01:50:15.310 - 01:50:32.640, Speaker E: All right, so if you go to airstack XYZ, is our Internet working? Let's start with that. There we go. Let me make sure the WiFi is off first.
01:50:32.640 - 01:50:38.240, Speaker E: There we go.
01:50:42.270 - 01:50:43.146, Speaker B: There we go.
01:50:43.248 - 01:50:48.720, Speaker E: Okay, so if you go to airstack XYZ, can everyone see? Should we turn the lights down a little?
01:50:49.970 - 01:50:52.400, Speaker B: Yeah, better?
01:50:53.010 - 01:51:07.502, Speaker E: Okay, so if you go to airstack XYZ, it's App. airstack XYZ. You'll see, the home page is if you want to learn, basically start with other people's queries.
01:51:07.502 - 01:51:13.234, Speaker E: You can see there's a community shared query. So after you create a query, you can publish to the community. You don't have to.
01:51:13.234 - 01:51:27.114, Speaker E: So by default, your queries are public. You can save them to your own account, but if you're proud of your work and you want to share it with others, you can just click the publish button afterwards and share your query publicly for other people. So, for instance, here's a query that Sarvesh did earlier today.
01:51:27.114 - 01:51:40.910, Speaker E: So it's the collection stats for Moonbirds, and I'm going to run this query. And so if I wanted to, I can just fork his query and use it or edit it. So you don't have to start from scratch if you want to start with a community query.
01:51:40.910 - 01:52:00.576, Speaker E: And then just to show you, I'm going to sign you want to sign in real quick. I just want to show the AI. So just want to show everyone the cheat codes real quick.
01:52:00.576 - 01:52:22.600, Speaker E: If you're on the Query Explorer page, you can use our AI engine to create a natural language query. We're running GPT four. We've been training for the last four weeks or so on our GraphQL, which Depesh can go into in detail, but you can write a natural language query on the airstack system.
01:52:22.600 - 01:52:54.260, Speaker E: So I can write, for instance, show me all NFTs currently held by Vitalik ETH, and the images of the NFTs and the AI will generate the query for you. It is about 98% accurate on anything that we have an API for, and it's about 0% accurate on things we don't have an API for. So if you ask it what tokens is Obama holding? It's probably going to come back with nothing.
01:52:54.260 - 01:53:16.584, Speaker E: But if you ask it, let's say, to give you information about any NFT collection, any Ethereum wallet, any ENS it'll, get it right. So here's the query and there's the response. And then you can see in the response here, there's also images resized in.
01:53:16.622 - 01:53:17.210, Speaker D: The.
01:53:19.100 - 01:53:24.540, Speaker E: Internet, but usually we can hover over and see the image as well. There you go. So this is one of Vitalik's NFTs.
01:53:24.540 - 01:53:43.010, Speaker E: So the AI Assistant is intended as a way for you to get started very easily. So if you're not comfortable with GraphQL, you can just use the AI Assistant. Or even if you are comfortable with GraphQL, you can start with a query through the AI and then edit it and kind of add other dimensions to it.
01:53:43.010 - 01:54:00.536, Speaker E: But let's back up a little bit and Depesh will show everyone the nitty gritty details of the APIs, what's in them, and as a developer, how to make use of them sound good. Any questions before we roll into it? I talk very fast. You can slow me down if you want.
01:54:00.718 - 01:54:01.576, Speaker D: All right, go ahead.
01:54:01.598 - 01:54:03.130, Speaker E: Dimesh over you.
01:54:05.260 - 01:54:18.668, Speaker F: Thank you, Jason. Sure. So let's see what is possible with these APIs and how as a developer can make use of these resources available.
01:54:18.668 - 01:54:32.336, Speaker F: So as a developer, this is the starting point where you have to come to app SDC XYZ. The different functionalities are already you already know. Jason already talked about it.
01:54:32.336 - 01:54:42.420, Speaker F: So here you can see there is API Docs. So once you click here, you will be taken to the doc page. Is it better?
01:54:42.490 - 01:54:43.110, Speaker A: Yeah.
01:54:43.960 - 01:54:57.924, Speaker F: So here you can see first of all, I would like to encourage everyone to join this telegram group. We have a developer chat. So if you have any questions related to SDAC, that's our best place to contact us.
01:54:57.924 - 01:55:06.990, Speaker F: And we will make sure that we reply to each and every messages. Let's jump in. So this is a quick start.
01:55:06.990 - 01:55:22.610, Speaker F: So the UI which you saw here, right, the Explorer. So this is our GraphQL client. But in case you want to use any other client, even that, you can use it.
01:55:22.610 - 01:55:45.236, Speaker F: But we recommend everyone to use App airstack XYZ. In case you want to use Apollo Studio or any GraphiQL clients, you can just use this API endpoints. This GQL is the endpoint where you can hit the queries.
01:55:45.236 - 01:56:03.440, Speaker F: Currently, if you are not logged in, you have not created any account. So current the rate limit is 50 request per five minutes. But if you log in, once you log in, you will get a header key, authorization key that you can use it with every queries.
01:56:03.440 - 01:56:08.080, Speaker F: So there you will get the rate limit of 50 requests per minute.
01:56:09.940 - 01:56:10.688, Speaker A: Okay.
01:56:10.854 - 01:56:25.596, Speaker F: And if you want any higher rate limit, then definitely you can reach out to us and we will provide that currently one information. Like currently we have Ethereum synced that. Can be used for development in the hackathon.
01:56:25.596 - 01:56:49.016, Speaker F: And currently we are syncing polygon. It's still syncing, but we have made sure that we have the live transactions available so that hackers can use the live transactions and create some apps on top of it. Any transaction that happens, it will appear in Aztec APIs in less than a minute.
01:56:49.016 - 01:57:07.636, Speaker F: So it is pretty fast. Like a minute is also a very high thing, but it should be in some seconds itself. All right, moving ahead, I will give you a walkthrough of the APIs that is available and I will describe you what these APIs are capable of.
01:57:07.636 - 01:57:32.270, Speaker F: So, before going to these APIs, I would like to give you a walkthrough on how our schemas are built. There is a certain pattern which we follow and there is also a nested queries, how we can get multiple information in single query. So let me give you a quick walkthrough here.
01:57:32.270 - 01:57:47.804, Speaker F: So here you can see all the queries are listed. One common pattern you will see everywhere is this input. So this is where we provide the input.
01:57:47.804 - 01:57:55.984, Speaker F: We have basically four fields. One is blockchain on which blockchain you want to query. Currently here we can see Ethereum.
01:57:55.984 - 01:58:03.220, Speaker F: But after sometime you will get polygon as well. Then there is cursor. The cursor is more related to Pagination.
01:58:03.220 - 01:58:18.252, Speaker F: We have a limit of 50 records in one query. But you can get more data using Pagination. So this is where a cursor is used.
01:58:18.252 - 01:58:43.432, Speaker F: So it's just a string, you can just add it and you can get some other page. Then we have filters. The format here is we have and or if you want to query something which is give me something, some token whose address is exactly equal to given address, then this is where we use equality.
01:58:43.432 - 01:59:01.080, Speaker F: And if you want to use multiple addresses, you can just provide an array. So we use this in operator and similarly we will have more operators like depending upon the use case. Let me go to stats.
01:59:01.080 - 01:59:11.916, Speaker F: Here you can see there is greater than, less than in all. These are the comparators. So you can use this as well.
01:59:11.916 - 01:59:26.556, Speaker F: So this is the format which we have in our schemas. Any question here? All right, I will move forward. Now, in this document you can see we have various APIs.
01:59:26.556 - 01:59:37.380, Speaker F: So let me give you a very high level walkthrough one by one. So token API. So token API is if you want to get information about any token, high level information.
01:59:37.380 - 01:59:55.076, Speaker F: For example, name, symbol, decimal, total supply. This is the API which you are going to use. It here you can see there are more details, but in majority you will need name, symbol, decimals.
01:59:55.076 - 02:00:14.300, Speaker F: So this is something I can show you. I can just run this query. So here you can see I have provided the address on Ethereum.
02:00:14.300 - 02:00:39.256, Speaker F: And I got this name, symbol, decimal, total supply, loss, transfer, block and loss transfer timestamp. So yeah, token related information you can get it from token APIs in addition to tokens. So tokens can be like ERC 272-1155 if you want more details about 721 and 1155.
02:00:39.256 - 02:00:49.740, Speaker F: This is where we have the token NFT APIs. Here you can get some off chain data as well. For example metadata generally they are kept on IPFS.
02:00:49.740 - 02:01:09.360, Speaker F: Also the images generally you will find the images on IPFS so you can query all this data through our APIs. One more thing we provide is the images, the NFT images you can get it in a four version. So we resize the images and provide you in the four sizes.
02:01:09.360 - 02:01:27.780, Speaker F: To give you an example here, let me take first this example. This is a very interesting example so I will just spend some more time here. Let me explain this query.
02:01:27.780 - 02:01:51.352, Speaker F: So I'm trying to get token NFT its name, its symbol then I'm trying to get its metadata, its attribute type then images. These are the four dimensions predefined dimensions available. In addition to that we are also trying to get NFT sale transactions.
02:01:51.352 - 02:02:00.192, Speaker F: So this is a nested query. This is an example of nested query. So the NFT sale transaction is something you can have a different query itself.
02:02:00.192 - 02:02:35.272, Speaker F: But here in this example you can see within one query you can just query a lot of information related to that token NFT. One more interesting thing I would like to highlight here so here I'm querying based querying the I'm trying to fetch token NFT based on this criteria. That is I'm saying give me token NFT for this collection where its metadata trait type is equal to background and its value is orange.
02:02:35.272 - 02:02:50.972, Speaker F: So here is a best example how you can query an NFT based on its traits values as well. Let me run this. I think internet is slow.
02:02:50.972 - 02:03:10.520, Speaker F: Trust me guys, APS are fast. Got it. So here you can see we have the metadata information trade type, its value we have the images extra small, large, medium, original.
02:03:10.520 - 02:03:40.090, Speaker F: Then we have here you can see sale transactions at what price it was sold. So these are the information which you can extract from token NFDS API then token balances. So here you can query what are the different balances a particular valid holds.
02:03:40.090 - 02:03:55.114, Speaker F: So you can get ERC 20 balance. You can get what are the different token NFDS they have a particular valid have and what are the token transfers. So this is a very straightforward API.
02:03:55.114 - 02:04:05.010, Speaker F: I can just run one of the example here. I think we already have seen this one. I will just copy paste it.
02:04:05.010 - 02:04:26.310, Speaker F: I will run it here you can see we are getting very detailed information like what's the token type, what's their name and how much amount they hold. So this is how you can use token balance API. Then we have Domain API.
02:04:26.310 - 02:05:07.910, Speaker F: So this is more like you can run the queries using very user friendly names instead of address to give an example, ENS is one of the projects, so ENS is one of the project which we have indexed. We will be indexing more. So all the APIs which we have, they can also work with ENS and here I can get more information related to ENS project like what was the payment token used, at what price it was bought, when it is expiring, what's the name, what's the primary ENS name? All this information we can get from domains API.
02:05:07.910 - 02:05:23.802, Speaker F: Then we have wallet API. So this is a very powerful API. Here you can get a comprehensive data, just provide a specific address and it will give you many information.
02:05:23.802 - 02:05:49.574, Speaker F: Example what's their different social profiles? What's the token balance, what were the token transfers, NFT sale transactions? All this information, you can get it. I will give you one example here this is a very nice example. So here we can see here we are providing an identity key.
02:05:49.574 - 02:06:21.120, Speaker F: So here it is like when we provide an input, we can provide either address ENS name we can also provide social profiles name or ID. For example, if you have forecaster, you can provide forecaster name or forecaster ID and then our APIs will just take this name, it will resolve what are the addresses that name has and then it will give all the data. It will go and fetch the data and provide you the information.
02:06:22.850 - 02:06:29.090, Speaker D: How do you feel? Sorry, can you filter between a camera.
02:06:31.990 - 02:06:35.938, Speaker F: Sorry, I did not get it. For the transfer?
02:06:36.104 - 02:06:38.302, Speaker D: Yeah, let's say for the wallet balance.
02:06:38.366 - 02:06:40.238, Speaker B: Let'S say we have time range and.
02:06:40.264 - 02:06:42.230, Speaker D: From January.
02:06:46.650 - 02:06:47.654, Speaker B: Yeah, or block number.
02:06:47.692 - 02:06:49.650, Speaker D: Yeah. How do you filter for tam range?
02:06:49.810 - 02:06:51.798, Speaker F: You want to know like if you.
02:06:51.804 - 02:06:55.334, Speaker D: Can use that example you can use that example. But how do you filter that for the tam range?
02:06:55.382 - 02:06:58.220, Speaker A: Let's say January to April or something.
02:07:02.350 - 02:07:04.186, Speaker D: I see. So you have to basically convert the.
02:07:04.208 - 02:07:06.810, Speaker B: Block range into Unix timestamp.
02:07:09.070 - 02:07:14.446, Speaker D: But you have to figure out the block number by yourself, I guess Unix timestamp or something.
02:07:14.548 - 02:07:26.850, Speaker F: Yeah. So if your question is that I want to get a token balance between a particular time range or historical value, right?
02:07:26.920 - 02:07:27.442, Speaker B: Yes.
02:07:27.576 - 02:07:50.118, Speaker F: So that is something we will be enabling that. That is the balance snapshot where you can query any valid historical balance. So it will be possible for you to provide the block range like start block number and end block number and what was the balance between this range or even it can work with block timestamp.
02:07:50.118 - 02:08:03.406, Speaker F: So it will be like you don't have to know what's the block number of a given timestamp. Everything will be taken care of it. So this is the API which is under development and we will have this API very soon.
02:08:03.406 - 02:08:10.910, Speaker F: So that will be possible. We call it as historic balance or balance snapshot.
02:08:11.070 - 02:08:12.020, Speaker D: Thank you.
02:08:18.310 - 02:08:24.206, Speaker F: Query transfers with the block number during creation.
02:08:24.238 - 02:08:25.300, Speaker D: You can get it.
02:08:28.310 - 02:08:38.822, Speaker F: Right. All right, moving ahead, social API. Using Social API you can query the data of social apps.
02:08:38.822 - 02:08:56.890, Speaker F: For example, Forecaster. We are also indexing lens that you will get it after some time. So the details which you can get it from the Social API is like what are their profile names, IDs and what are the different connected addresses or associated addresses with that.
02:08:56.890 - 02:09:15.750, Speaker F: So, this is what Social API is, token transfers. So this is quite straightforward. Like any token transfer, you can just query it what was the token which was transferred between the addresses.
02:09:15.750 - 02:09:43.290, Speaker F: Then we have NFT sale transaction. So currently, if you want to know if a token was sold in a particular marketplace, for example OpenSea or Rarible, this is the API which you can get the data from. So currently we have indexed OpenSea and Rarible.
02:09:43.290 - 02:10:16.854, Speaker F: And here you can get what was the payment amount, what was the fees paid for that transfer and what was the royalty fees, what was the platform fees. And we also convert it into USD value and just provide all this information, all this data using these APIs. Then there are stats related APIs.
02:10:16.854 - 02:10:50.466, Speaker F: So basically you can just get the information like what's the highest sale price, what's the lowest sale price, what's the average sale price of a particular collection? And these stats, you can get it daily basis, weekly basis, monthly, yearly and lifetime. And to just give you a high level detail, like daily starts, like everything is in UTC timestamp and daily starts from 00:00 a.m. Like midnight and ends at 11:59 P.m..
02:10:50.466 - 02:11:02.166, Speaker F: Similarly for the weekly, it starts on Monday and ends at 11:59 P.m. On Sunday and monthly. You can just understand that this is the first calendar date and end calendar date.
02:11:02.166 - 02:11:27.566, Speaker F: So this information is also available. We also have information related to data related to marketplace stats. So you can also query what's the highest price, lowest price on OpenSea or on Rarible? So this API works at the marketplace level.
02:11:27.566 - 02:11:47.394, Speaker F: So you can get this marketplace data as well, all the stats. Similarly, we have NFT stats at the token NFT level. You can also get the similar stats coming back to this identity API.
02:11:47.394 - 02:12:16.400, Speaker F: This is very powerful. So all the queries which we saw, wherever you see where we have the owner address, you can make a query based on either ENS name or if you have forecaster, ID, forecaster name, you can just provide this and all the APIs would work. All right, let me take one more example.
02:12:16.400 - 02:12:30.580, Speaker F: Suppose you want to query on multiple chains. So you have to query some information from the ethereum chain as well as polygon chain using one EPA call. Even that is possible.
02:12:30.580 - 02:12:39.480, Speaker F: So currently this is not deployed on the production. So you can't see this. But this is something we will push it very soon.
02:12:39.480 - 02:12:53.580, Speaker F: So you can see the query here, right like I'm trying to get token balance of vitalik. I'm providing his ensname on Ethereum. And the second query is in the same.
02:12:53.580 - 02:13:09.514, Speaker F: We have this aliases where we have ethereum and polygon as our labels. And here you can see we are changed the blockchain to polygon. And if I will run this, you can see this ethereum and polygon.
02:13:09.514 - 02:13:19.726, Speaker F: This is how you will get the data and the token balances. You can see this is a blockchain and different tokens and its amount. Similarly for the polygon.
02:13:19.726 - 02:13:30.438, Speaker F: If you will see we will get the similar data. So using one query itself, you can get data of the multiple blockchains. So whenever we will enable more blockchains, you will get all this data.
02:13:30.438 - 02:13:34.134, Speaker F: There now coming to do we have time?
02:13:34.252 - 02:13:35.174, Speaker E: Three minutes.
02:13:35.372 - 02:13:36.360, Speaker F: Three minutes.
02:13:37.690 - 02:13:41.194, Speaker E: Sorry, but anyone who's interested can find us afterwards. The best will be right outside and.
02:13:41.232 - 02:13:42.758, Speaker D: Walk you through and also come to our table.
02:13:42.854 - 02:13:43.546, Speaker B: Good.
02:13:43.728 - 02:13:44.954, Speaker D: Have a question.
02:13:45.152 - 02:13:46.970, Speaker C: Are you centralized servers?
02:13:50.050 - 02:14:05.314, Speaker D: Hello, I would ask a question. Are you centralized servers? So I can't run my indexer on my own computer. All right, now and do you plan.
02:14:05.352 - 02:14:08.078, Speaker E: To centralize it in the future sometime?
02:14:08.254 - 02:14:09.540, Speaker D: Okay, thank you.
02:14:11.190 - 02:14:37.534, Speaker F: All right, so there was one example which we wanted to I will just take just 1 minute and I will just say how you can quickly do this. So what you need to do is you just sign in. After signing in, you go to profile setting, go to view API key.
02:14:37.534 - 02:14:52.690, Speaker F: This is where you will get the API key. So this is something we need to pass this in the header against key authorization. And this is where your APIs would work with good rate limit.
02:14:52.690 - 02:15:04.914, Speaker F: And very quickly here, this is an example. This is a node JS code. This link is available like it's a GitHub repository.
02:15:04.914 - 02:15:16.810, Speaker F: It is available in the GitHub repository. You can just have a look there. So this is a query where we are trying to get all the NFTs of multiple owners.
02:15:16.810 - 02:15:41.500, Speaker F: And there is some Pagination logic as well. If you will just run it. Yeah, here you get all the response.
02:15:41.500 - 02:15:44.828, Speaker F: All right, I will just all right.
02:15:44.834 - 02:15:45.708, Speaker D: So thank you everyone.
02:15:45.794 - 02:15:59.824, Speaker E: If you have any more questions, Depesh and Sarvesh will be outside. And at our table we also have bounties that are available. It's linked to from the ETH Global Prizes page as well.
02:15:59.824 - 02:16:09.600, Speaker E: As if anyone asks, just come up. We'll send you a notion page that has information. We also have suggested ideas and projects to work on if you're looking for inspiration.
02:16:09.600 - 02:16:14.904, Speaker E: All right, any questions real quick? All right. Thank you everyone. Appreciate it.
02:16:14.904 - 02:16:15.690, Speaker E: Thank you.
02:19:20.330 - 02:19:21.080, Speaker A: Hello?
02:19:28.750 - 02:19:29.500, Speaker F: It.
02:19:33.670 - 02:19:50.070, Speaker D: GM Tokyo, everyone. My name is Tommy WA and I work at Safe and I'm going to talk today about how to make a group wallet for buying things with friends using smart contract accounts and SafeCore account abstraction SDK. So a while back, me and a couple of our friends, we went on a ski trip together.
02:19:50.070 - 02:19:59.702, Speaker D: And the trip itself was fun. We went skiing, we had some great food, we had to stay in a nice airbnb. But there's one part of the trip that I really didn't like and I found super annoying.
02:19:59.702 - 02:20:12.902, Speaker D: Anybody know what it is? Whenever you're gone a trip with a bunch of friends, what is the most annoying part of the trip? Splitting bills. Exactly. So this is some screenshots that I messaged text group chat that we had of trying to organize the payments and the bills.
02:20:12.902 - 02:20:16.326, Speaker D: Hey, pay me this for the food. Don't forget to pay me back for the tickets. Airbnb.
02:20:16.326 - 02:20:31.730, Speaker D: Why would you pay me back? And I was part of the problem too. About a week after the trip, a friend messaged me saying, hey, you still haven't paid me back. And so let's figure out why is splitting the bill so hard? So let's say, for example, me, what's your name? Bankless brazil.
02:20:31.730 - 02:20:41.122, Speaker D: Joan. John and what's your name? Saki. Me, John and Saki want to go on a ski trip to Mount Fuji together in beautiful Tokyo.
02:20:41.122 - 02:20:42.600, Speaker D: What do we have to do?
02:20:43.130 - 02:20:43.810, Speaker A: Tickets.
02:20:43.890 - 02:20:57.706, Speaker D: What else do we have to figure out? Logistics, food, where we're going to stay, right? So just the three of us, we want to go on a trip together. We have a lot of payments we need to figure out. So maybe I say I'm going to pay for food.
02:20:57.706 - 02:21:04.826, Speaker D: John you're going to pay for housing? Maybe. What's your name again? Masaki. You're going to pay for the tickets, so you pay me back for this and I pay you back for this.
02:21:04.826 - 02:21:16.066, Speaker D: And it's just a huge mess. And this is why we have these kind of text imessage group chats where we're just trying to figure your stuff out. Now what if we could just basically create a group wallet, right? Where you know what? Forget all this stuff.
02:21:16.066 - 02:21:32.434, Speaker D: We just create a shared bank account where we all send our money into and then one of us can say, hey, I'm going to take money out of our shared account and pay for the food. Or you can pay for the housing, you pay for the tickets. And then we could just basically create something like a group wallet and another name for a group wallet is called a multi SIG.
02:21:32.434 - 02:21:43.610, Speaker D: Exactly. And this is a very simple concept, but you can actually think about it has very powerful implications. So one example of this is you could do the same thing and instead of maybe using to pay for a trip to Fuji, we buy the US constitution.
02:21:43.610 - 02:21:55.466, Speaker D: Sounds crazy, right? But then a group of people used exactly the same concept to constitution dow they raised $42 million in seven days. That's $6 million a day. But let's take it a step even further.
02:21:55.466 - 02:22:14.146, Speaker D: What if you created a group wallet for investments? And what if this group wallet had $10 trillion assets under management. What am I talking about? BlackRock. So a lot of people don't think about it, but BlackRock is a $10 trillion investment company that actually has that basically functions exactly like a group wallet.
02:22:14.146 - 02:22:38.054, Speaker D: Here's another fun example for you guys. What if this group wallet at $800 billion, 125,000,000 people contributed to it and it had 700 signers. Anybody know what kind of wallet I'm talking about? Finn, do you know Japan? Japan is basically a group wallet.
02:22:38.054 - 02:22:54.180, Speaker D: It's a multi SIG, right? You have the parliament, that's about 700 signers, population of 120,000,000 people. You take money out of the account to pay for pension, student loans, military or self defense force, things like this. So with this very powerful concept, you can basically create things all the way from paying for an airbnb trip to basically running an entire country.
02:22:54.180 - 02:23:03.646, Speaker D: So how does it work at a fundamental level? Let's make it simpler. Again, back to the group wallet example. So the first thing we need to do is create a group wallet, then propose a transaction.
02:23:03.646 - 02:23:16.434, Speaker D: And transaction can literally be anything, which is, I want to pay for food, I want to pay for military. Anything you want to do, you can propose a transaction, someone confirms it. So, for example, I say, hey, John, I want to pay for the tickets to Mount Fuji.
02:23:16.434 - 02:23:25.370, Speaker D: Then you say, yes, I approve this transaction. It gets executed and the money gets sent out. So we're going to talk about how to do that using the Safe Core account abstraction SDK.
02:23:25.370 - 02:23:49.358, Speaker D: So we're going to start first of all, start off with the protocol kit. And the beauty of the protocol kit is that who here does not understand solidity very well? Okay, so the beauty of the protocol kit, it allows you to basically deploy smart contracts and even interact with smart contracts without having to write any solidity code. As long as you understand TypeScript, you can basically write not write smart contracts, but interact with smart contracts.
02:23:49.358 - 02:23:56.178, Speaker D: Auth kit onramp kit. Auth Kit for authenticating we'll get to these later. But focus on the protocol kit for now and then.
02:23:56.178 - 02:24:08.230, Speaker D: Yeah, so these are all the docs, and I'll have some slides up later on that you can link to the QR code. So the first thing is, sometimes one of the things that holds a lot of people back is, hey, I'm looking for a design. I'm looking for a front end developer.
02:24:08.230 - 02:24:20.966, Speaker D: You can just clone this repo that we have, which is a super, super simple UI kit that you can basically just use to add in additional features. So that basically takes care of the UI for you so you can focus on the functionality. So the first thing you want to do is install some kits.
02:24:20.966 - 02:24:30.034, Speaker D: So the protocol kit API kit for basically interacting with our API service. And then the SDK types. If you're using TypeScript, which I recommend also super important if you're going to use Ethers 5.7.26
02:24:30.034 - 02:24:34.946, Speaker D: .0 came out, which is still not compatible with a lot of stuff. I see you're nodding your head.
02:24:34.946 - 02:24:41.700, Speaker D: Yeah. So this is one of those things that if you don't know, it's a very hard bug to fix. So make sure you use 5.7.2.
02:24:41.700 - 02:24:47.922, Speaker D: Then you want to basically start using the regular packages. So this is actually outdated. We're not using Safe Service Client anymore.
02:24:47.922 - 02:24:51.874, Speaker D: This just changed like literally a couple of days ago. So it's API. Kit not Safe Service client.
02:24:51.874 - 02:24:58.002, Speaker D: And it's going to be protocol. Kit not core SDK. The next thing you want to know is configure the Blockchain network.
02:24:58.002 - 02:25:12.090, Speaker D: So one super cool thing about Safe is that if you want to basically support polygon inosis chain, and by the way, a little bit of alpha, you probably should, because then you can basically get two bounty prizes. All you have to do to get it qualified for additional bounty prize is one thing. RPC URL.
02:25:12.090 - 02:25:17.878, Speaker D: The rest of your code can be the same. You can support multiple chains with just that simple thing. This slide says twelve plus networks.
02:25:17.878 - 02:25:34.430, Speaker D: We're actually on more chains as well, but from UI perspective, these are the chains we support. But if you go to the Safe Deployments repo and you can find that linked as well, we support, I think, almost 100 chains. So if you guys are trying to get a lot of money, win a lot of bounty prizes, you can easily stack up by deploying on Safe because we support so many different chains.
02:25:34.430 - 02:25:39.860, Speaker D: Cello as well. We support Cello as well. All the different chains that are EVM compatible, we support most of them.
02:25:39.860 - 02:25:47.126, Speaker D: So then you import your packages. This part is pretty self explanatory. The next thing you want to do now is basically get the ETH adapter.
02:25:47.126 - 02:26:01.046, Speaker D: So the beauty of Safe is that you don't have to do a lot of connections yourself. If you already have MetaMask installed, this one line of code will basically take care of everything and it'll figure out the chain, the network you're on, things like this. All right, so then first thing I want to do is basically create the wallet.
02:26:01.046 - 02:26:10.074, Speaker D: So like I mentioned earlier on, you want to get access to basically whoever's currently logged in in your MetaMask. You basically can get the ETH adapter from that. And then you want to basically then just deploy the Safe.
02:26:10.074 - 02:26:24.014, Speaker D: And so as you can see here, once you've gotten the ETH adapter, deploying a Safe is just literally one line of code. Safefactory deploysafe and then you have your Safe deployed. And then another little pro tip I'll give you guys for when you're debugging your code is put lots of console log statements.
02:26:24.014 - 02:26:36.810, Speaker D: So for example, one thing I always try to do is I have the Block Explorer, the transaction service and then the Safe app. So this way if you're trying to figure out making sure it's actually deployed. You have basically three different sources of truth you can check to make sure that it was actually deployed.
02:26:36.810 - 02:26:45.866, Speaker D: So viewing the deployed safe yeah. So then you can check it on the Safe app or then Ether scan. All right, so then back to the example.
02:26:45.866 - 02:26:59.434, Speaker D: So now we've created our wallet, but now we need to talk. We propose a transaction. But the problem with this is that a lot of this interaction currently right now still requires you to be very familiar with blockchain web three technologies.
02:26:59.434 - 02:27:10.226, Speaker D: But what if you wanted to create something super simple, like so simple your mom could use it? What if you wanted to create okay, proposal. Okay, I got a little ahead. So proposing transaction as well.
02:27:10.226 - 02:27:19.090, Speaker D: So like I mentioned earlier on, you have to propose, hey, I want to send money out of this. You have to confirm that, yes, I want to confirm this transaction. And then you want to have someone execute the transaction on the blockchain.
02:27:19.090 - 02:27:29.206, Speaker D: And the beauty of this is that none of this stuff actually happens on chain until you actually execute the blockchain. So you don't need any gas fees. Anybody can just basically create a transaction, sign it basically using the following steps.
02:27:29.206 - 02:27:44.186, Speaker D: Get the transaction hash, you can sign it afterwards, and then you confirm the transaction. So basically to verify and this is also like a two factor this is like a kind of a way of having two factor authentication, right? Because even if my private keys get hacked, the money can still safe because then your private keys are safe. Your private keys are safe.
02:27:44.186 - 02:27:54.102, Speaker D: So you can swap owners things like this. So it's basically convenience and security. So you can confirm the transaction using the Safe API kit to get all the pending transactions.
02:27:54.102 - 02:28:03.720, Speaker D: And then you can basically execute the transaction on the blockchain. And like I said, again, when you're writing your code, I really recommend use lots of console log statements. It'll make it a lot easier to debug things.
02:28:03.720 - 02:28:24.714, Speaker D: So then you can also get the list of pending transactions to see what you want to confirm or deny. And then again, you can always basically verify things on Safe on our transaction service or on Ether scan as well. So now let's go back to the analogy I mentioned earlier on, right? So with this simple technology, like I said, you can do things like buy the US.
02:28:24.714 - 02:28:39.534, Speaker D: Constitution, literally buy the constitution and run a country. But again, this still requires you to understand private keys, understand all these kinds of hive, gas ETH, all these kind of stuff. But what the goal should aim for is that we want to basically create an app.
02:28:39.534 - 02:28:56.686, Speaker D: And the challenge I have for all of you hackers here today is, can you make an app that you could just basically take a phone, give it to your mom and be like, mom, use it is that possible right now? Not really. But now with Safe counter traction SDK, it's possible, and I'll tell you how. So like I mentioned earlier on, maybe again we want to go to Mount Fuji.
02:28:56.686 - 02:29:13.658, Speaker D: Maybe instead of Majuki, we go with Majuki's mom. So me, Majuki, Majuki's mom, or you, your mom and your dad want to go, right? So hey, mom, we're going to do a group. So you ask your mom, create mom wallet, right? Okay, so do you have a MetaMask? Do you have seedface? What's that? Do you have a Google account? Perfect.
02:29:13.658 - 02:29:20.714, Speaker D: You can use the Auth kit. Okay, next we need to send some money. Do you have gas? Do you have a matic? Do you have ETH? Do you have BNB? No? What's that? Okay.
02:29:20.714 - 02:29:26.022, Speaker D: Do you have a credit card? Perfect. Use the onramp kit. Okay, now it's time to pay for the execute the transaction.
02:29:26.022 - 02:29:35.858, Speaker D: You know what gas fees are, right? What are gas fees? Okay, don't worry about that. Used a lot of relay kit. So every single thing that you would have to learn to use a Web Three app has been abstracted away.
02:29:35.858 - 02:29:47.940, Speaker D: If you can use a bank account, if you can use a WhatsApp account? If you can use a Facebook account, you can use a Web Three blockchain. So it's like web two UX with web three tech. So let's dive into a bit more detail on how that works.
02:29:47.940 - 02:29:57.494, Speaker D: So now we're going to talk about the Auth kit for authenticating ourselves on Ram kit. And then we're going to talk about the relay kit. And I think the beauty of this too, is that a lot of times people think safe is just for multisigs.
02:29:57.494 - 02:30:08.140, Speaker D: You can even use a safe for like a one of one. And so, for example, you could have a safe. So why would you do a one of one with a safe? If your private key gets compromised, you can just swap private keys without moving all of your assets out.
02:30:08.140 - 02:30:19.482, Speaker D: So let's start with the Auth kit, right? So again, maybe your mom doesn't have she doesn't even know what a seed phrase is. She doesn't know what a MetaMask is, but she has a Google account or she has an email address. Log in with the Auth kit.
02:30:19.482 - 02:30:32.210, Speaker D: And again, it's very few lines of code. You can basically customize the modal, use the open login adapter, and you can just basically initialize. And then once you're initialized with Web Three Auth, you can basically just sign transactions using the provider and the current signer.
02:30:32.210 - 02:30:48.610, Speaker D: Okay, now, next part is basically on ramping. So again, a huge problem with crypto is how do you get people on ramped? Well, most of us already have credit cards. So with Stripe and using the Onramp kit, you can basically just use Stripe to basically have easy on ramping.
02:30:48.610 - 02:31:01.754, Speaker D: It's only available in us. So then you can basically use the on ramp kit and. Then this one's even easier because a lot of the work has been taken care of by the stripe iframe modal.
02:31:01.754 - 02:31:12.708, Speaker D: So it's literally just two lines of code really init and open and boom. Just like that you can on ramp people with a credit card. And then finally the gasless transaction speech.
02:31:12.708 - 02:31:24.940, Speaker D: So again, another huge problem people have is gas fees, right? Even if okay, now I've on ramped with the credit card and I bought USDC. Now I need to have manage, I need to have polygon, I need to have ETH. Well, now with the sponsored transaction, you don't have to do this.
02:31:24.940 - 02:31:41.280, Speaker D: So you can basically just say that anybody who wants to interact with my blockchain, I put maybe three USDC or five USDC and I say all the transaction fees have been covered so we don't have to worry about this. And and then so this is kind of an idea of what it will look like. So basically here you can basically see the steps involved.
02:31:41.280 - 02:31:53.220, Speaker D: So basically just defining the and the beauty of this too, is that when you look at the code, actually everything that you would do to create a regular transaction is going to be the same for Relaying. The only difference is the operation call. I forget where that line of code.
02:31:53.220 - 02:32:01.488, Speaker D: Yeah, right here. So operation type call, everything else is going to be the exact same as you would pass in for a regular transaction. And you probably want to increase the gas limit as well because it's going to be a little bit more complex.
02:32:01.488 - 02:32:17.676, Speaker D: But but besides that, if you can execute a regular transaction, you can do a sponsored transaction as well. And then this is kind of just like a little bit more detail on what data you're encoding in the execution transaction call. And then this is an example of what it looks like.
02:32:17.676 - 02:32:32.390, Speaker D: And again, so the really cool part about this here is you see account three executed this transaction, but they literally had zero matic in their bank account. We can still see here the contract was the Gelato network. Relayer basically moves from our multisig to our destination address.
02:32:32.390 - 02:32:54.300, Speaker D: Yes. And so with all of that auth kit taken care of onram kit taken care of, relay kit taken care of, we now have a mom wallet. Mom wallet get a trending hashtag mom wallet.
02:32:54.300 - 02:33:03.990, Speaker D: And then so that kind kind of concludes the bulk of the talk. And then so now we can have lots of time for questions, answers, things like this. A couple of things I want to give you guys.
02:33:03.990 - 02:33:06.770, Speaker D: These are some developer docs, if you guys want to scan that real quick.
