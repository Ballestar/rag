00:00:06.330 - 00:00:23.742, Speaker A: Up next is Tom and I'm super excited for this talk because Tom is going to talk about WalkMe. This has been a tool and an SDK that I've been using more and more personally too. And I can't wait to have Tom share about some of the internals and what's possibly next.
00:00:23.742 - 00:00:25.574, Speaker A: So without further ado, let's welcome Tell.
00:00:25.692 - 00:00:49.850, Speaker B: Hey everyone. Super excited to be here and I'm going to talk about getting started with Wagme. This is the first time I've probably talked about Wagme and I'm really excited to share how to get started, maybe some more advanced details and ways to use library and then talk about sort of what's coming up next on the roadmap.
00:00:49.850 - 00:01:04.720, Speaker B: 1 second I just have some stuff on my screen trying to move the zoom stuff out of here. Okay. So, yeah, I'm Tom.
00:01:04.720 - 00:01:19.462, Speaker B: I'm the author of Wagme, currently front engineer at Mirror, and you can find me on GitHub and Twitter at these handles. What we're going to talk about today is maybe a quick overview of Wagme for those aren't familiar. Walk through an example of how to get started quickly.
00:01:19.462 - 00:01:49.710, Speaker B: If you're working on the hackathon or a side project, this will be helpful for you and then some pro tips and things that people aren't always super familiar with when they get started using Wagme, but they'll help save you some money with RPC clients, make it easier to develop DApps and move quickly when you're building. And then lastly, we'll just go through a little sneak peek of a feature that I'm really excited about and should help everyone be more productive. So yeah, if you're not familiar with Wagme, it is a reactwix library for Ethereum.
00:01:49.710 - 00:02:15.522, Speaker B: Takes a bunch of commonly used functions, patches them up into hooks so that way you can use them for a variety of different things. Initially released this on January 4 of this year and since then it's grown quite a bit. A bunch of projects have adopted it from ENS Foundation, Sujiswap, Stripe, Crypto, a bunch of others and it's been cool to see lately some folks building developer tools on top of Wagme.
00:02:15.522 - 00:02:38.586, Speaker B: So if you've seen Rainbow Kit, connect Kit, or third webs SDKs, you know what those are all about. Wagme itself is great, but what these folks have done is took the library and added their own twist and abstraction on top of it to make it really easy to connect a wallet, deploy interactive smart contracts and similar things. So you should definitely check those out if you're not familiar.
00:02:38.586 - 00:02:50.020, Speaker B: And yeah, I mean, it's grown a lot. So quite a few GitHub stars and downloads per month now. And hopefully we'll keep growing as we add more stuff that people are excited to use.
00:02:50.020 - 00:03:06.470, Speaker B: And here's some quick links if you want to check it out as I'm discussing or if you want to check it out later. Doc Site we don't have a discord. Everything is mostly done asynchronously on the GitHub repo so you can check it out there or follow us on Twitter to get updates.
00:03:06.470 - 00:03:32.960, Speaker B: So yeah, right now Wagme has 25 plus hooks dealing with things like wallet connection, ENS information, interacting with contracts, signing data and sending transactions. So I just like highlighted a few here. Use Connect is really great and quick way to connect wallets to your application.
00:03:32.960 - 00:04:03.580, Speaker B: Use ENS name is really good for fetching ENS name for an address. We have this hook called Use Contract Reads which behind the scenes does multicall and which will save you a lot of money on your RPC requests and falls back to just regular reading if the chain that you're using doesn't support multicall. Use Sign Message is useful for signing basic messages with personal sign, but also if you're trying to do anything with sign with Ethereum, you should check that hook out.
00:04:03.580 - 00:04:36.042, Speaker B: And then another really cool hook is Use Wait for Transaction which you can pass a transaction hash to it and it will update the status as the transaction goes from submitted state to the network as it's mining and then as it's confirmed. That way you can show some updates to your users and we'll talk about that one a little bit later. But Wagner isn't just about hooks, it does actually quite a bit more there's built in wallet connectors for MetaMask wallet, Connect, coinbase wallet, injected wallets.
00:04:36.042 - 00:04:51.506, Speaker B: These are the most popular covers. Most of the use cases people have. There's been some community Led efforts for additional connectors like Gnosis has worked on and has a separate NPM package you can install for their connector.
00:04:51.506 - 00:05:11.726, Speaker B: And it's exciting to see people add more and more. So that way if you have different use cases or want different wallets to be supported, all you have to do is extend an interface and implement a few methods and you're good to go. There's also quite a bit of caching and request enhancements that we released a few months ago.
00:05:11.726 - 00:05:45.658, Speaker B: This way you don't have to run into situations where you're spamming your RPC something like Alchemy so you can keep your bills down and make sure stuff is pretty snappy and fast for users. So if you fetch their ENS name once and they come back and reload the page later, they'll automatically be there so you can use it. We also do some things where we're able to automatically update data as wallets change, as blocks are mined and as users switch around and use different networks in your application.
00:05:45.658 - 00:06:06.070, Speaker B: The other really cool thing that some people have been playing with lately is Wagme has a Vanilla JS client. So mostly people interact with the React hooks. But what you'll see in a moment as we go through the quick start is there's a Vanilla JS client you can use which allows you to use Wagme in instances where you aren't using React.
00:06:06.070 - 00:06:42.478, Speaker B: If you're trying to use it outside of the react tree, or if you want to use it with a different framework like Spelt or View or something like that. And another interesting thing that you can check out in the repo is Wagme has a pulled test suite running against Ethereum which uses anvil behind the scenes to spin it up. So if you're interested in testing your DApps, wagme has a connector which you can set up to use anvil or hardhat or something like that, just to make sure that when you're deploying things, everything out there is working.
00:06:42.478 - 00:06:56.482, Speaker B: So move on to go through how to get started with Wagmean here. So the first thing you want to do is install Wagmean Ethers. You can do this inside of an existing project or a new project when you're getting set up.
00:06:56.482 - 00:07:13.574, Speaker B: This example uses Pnmp, but you can use NPM, Yarn or anything like that. I've set the versions here explicitly so that way if you're trying to follow along later, you make sure you're using the same version. Wagme hasn't hit 1.0
00:07:13.574 - 00:07:27.514, Speaker B: yet and there's been some API changes over time as we move to get to 1.0, just so we can make sure the developer experience is getting better and better. So if you're following along with this later, just make sure you're watching what versions you're on.
00:07:27.514 - 00:07:41.242, Speaker B: So yeah, once you install, we'll just create a client. This is the vanilla JS client talking about earlier. The only option that you need to provide out of the box is the provider, which is just an Ethers JS provider.
00:07:41.242 - 00:08:14.300, Speaker B: Wagme is built on top of Ethers and so by supplying a provider here, you make sure the Wagme client can connect to the network. And the other thing that I've added here is AutoConnect true, most people probably want to set this on. And what this does is allows whenever someone refreshes your app, if they're connected with their wallet before the refresh or they come back later, it'll make sure that the connection is restored so that way they don't have to sign back in when they reload the page.
00:08:14.300 - 00:08:28.590, Speaker B: So yeah, you create your client and then you wrap your app in a context provider. So you just import Wagme config which react context provider, pass the client there and then you're good to go. You can just start using the hooks.
00:08:28.590 - 00:08:52.646, Speaker B: Like I said before, there's a bunch of them here's, two of them as an example. Say we have a profile component and we want to render out the connected wallet address and also optionally it will fetch the ENS email when address is defined. So yeah, it's pretty easy to get started and most people should be able to add this into a new app right away.
00:08:52.646 - 00:09:16.080, Speaker B: And if you have an existing app, something like Web three react or used app, it shouldn't be that hard to migrate over. So here are some pro tips I wanted to walk through. The first one is setting a chain aware provider so what this means is before you can see we just had a static provider added here.
00:09:16.080 - 00:09:43.074, Speaker B: Get default provider is an ethers method which has a whole bunch of RPC providers behind it and sets it up so it's automatically on main net. And what you want to do is make sure your provider is initialized with a chain ID. And so the create client provider function has a chain ID argument that then you can pass into your provider.
00:09:43.074 - 00:10:11.034, Speaker B: So that way if you're connected to one chain, let's say VNet, and then you switch to optimism, the underlying provider which Wagme uses to fetch and update data will then be on the right network. So yeah, in this example I'm using Alchemy provider, just passing it the chain ID and now that's chain aware and it's good to go. And what this means is when you're using hooks here by default, so I'm using this use contract readhook by default.
00:10:11.034 - 00:10:32.178, Speaker B: This will read on the chain that the wallet is connected to, but you can also set it to read from a specific chain if you want. So this is only going to be making requests for a main net so it's set to chain ID. One, the next pro tip here is for configuring chains.
00:10:32.178 - 00:11:25.750, Speaker B: So it ends up becoming if you have a MultiChain app, it becomes unwieldy in your provider function when you're creating your client to make sure that you're using the right providers for certain chains. So for example, in this case for mainnet, I'm trying to use Alchemy for optimism, I'm trying to use Infura and for optimism burly I'm trying to use Alchemy again and this is like a super contrived example, but sometimes you do want to use different providers for different chains. Either an RPC provider doesn't support the chain that you're using right now or you want to use a different RPC provider, maybe a different API key for an RPC provider for like a test network or something like that.
00:11:25.750 - 00:11:37.478, Speaker B: So you could go about doing this in sort of the way that I have out here. You probably clean it up a bit. But instead of that, we created this API called configure chains.
00:11:37.478 - 00:11:55.970, Speaker B: And what this allows you to do is specify a list of chains that you want to use ahead of time. So in this case, mainnet optimism, optimism gurley, and then a list of RPC providers that you want to use. And what's great about this is a couple of things.
00:11:55.970 - 00:12:19.618, Speaker B: One, it spits out all the chains that you passed in a provider object and a websock provider. What it actually does is it takes the RPC providers you've listed out and it creates them in like a fallback ethers provider. So that way let's say Alchemy goes down, then it will fall back to the public RPC provider.
00:12:19.618 - 00:12:51.940, Speaker B: So this is really good because sometimes RPC providers go down, inferior will go down and you can fall back to alchemy or vice versa and it will set this all up for you. All you have to do is put them in order that you want them to be used inside of the second argument of configure chains. And then like I said, instead of having like a provider or a WebSocket provider function block where you're having to list out a whole bunch of different cases here you can just pass the results directly there.
00:12:51.940 - 00:13:21.566, Speaker B: And similarly you can take the chains that is spit out from configure chains and pass it to any connectors that you're trying to set up. So in one go here I'm able to set up MetaMask, set up my provider and WebSocket provider and all I do is call a function telling it how I want it to be set up that's configuring chains. So another tip that touches a little bit on React and can help with performance in your application is using Account.
00:13:21.566 - 00:14:08.026, Speaker B: Callbacks use Account is a hook that shows the current address, the connector and some other flags on whether or not you're connected. And something that a lot of people commonly do is if they want to check to see whether someone's logged in or logged out, if their wallet is connected or disconnected and how that state changes, they'll just use an effect from react and they'll manage all this on their own, which, if these can start piling up, you could have a bunch of these in your app if you're trying to constantly inspect whether someone's connected or not. But what you can actually do instead is Use Account has these built in to them.
00:14:08.026 - 00:14:31.250, Speaker B: So there's on Account and on Disconnect and whenever these fire off, whenever these change, you'll be able to use that data instead of having to manually track this on your own. So that's a pretty useful one to get started with. The last pro tip that I wanted to go over is the transaction cycle.
00:14:31.250 - 00:14:47.682, Speaker B: So likely if you're doing something in your app, once you've connected your wallet, you might want to be sending off transactions to the Ethereum network. And so this sort of follows three steps. The first is preparing your transaction.
00:14:47.682 - 00:14:59.340, Speaker B: What this allows you to do is set up the request you're going to be making. Maybe you have some arguments that you want to have set up. You have like a Minting site or something.
00:14:59.340 - 00:15:28.366, Speaker B: And what this allows you to do is once the user hits like Mint, by preparing the transaction, you've already done some of the computation ahead of time of what the wallet is going to receive. So that way on the second step send transaction, you'll see a prompt right away and so you'll be able to confirm and submit that to the network. And then last year, once you've sent your transaction to the network, you can wait for the transaction.
00:15:28.366 - 00:15:58.058, Speaker B: We was talking about this a little bit earlier with the Use wait for transaction hook which allows you to sort of watch as the transaction is mining, maybe show like a view on Ether scan or view on Block Explorer link while that's happening. And then once it's succeeded, you can show a link to the Block Explorer, show a confirmation state, that type of thing. So what this sort of looks like is you use the Use pair Contract Write hook.
00:15:58.058 - 00:16:24.262, Speaker B: Here you pass in an address to your contract the contract interface. So here's the basic example of Mint function name and then if that function has arguments, you can pass those into. So what this will do is once this component Mint NFT loads it will take this data, format it into a request which can then be sent off to the network using Use Contract Write.
00:16:24.262 - 00:16:36.486, Speaker B: This just takes that config that's returned. And then once the user clicks mint, presses the mint button. Write will send it off to the network.
00:16:36.486 - 00:17:22.650, Speaker B: And then as it relates to waiting for the transaction to confirm, what you can do is use the Use Wafer transaction hook and it takes a hash from Use contract rights data and then you can use as loading success flags along with some additional information that isn't pictured here to show some different states to users of your application. So that's sort of like the steps that you want to walk through when you're doing this. You want to prepare the transaction, you want to send it to the network and then you can optionally but probably best practice from UX perspective, make sure you're showing the status of the transaction, whether it's loading, if it's exceeded, or if it's failed.
00:17:22.650 - 00:17:46.370, Speaker B: So lastly here I wanted to go over a quick sneak peek of something that I'm really excited about. I think it's going to make it a lot easier for folks to work on their apps, make sure everything is more safe and easier to get started working with contracts. So what this is, is some Abi type inference.
00:17:46.370 - 00:18:16.554, Speaker B: There's great tools out there, one of them Typechain, which you can use to generate types at compile time. Yeah, it's just CLI tool you can use based on your Abis. But something that's coming to wagon soon is the ability to just use the TypeScript compiler to automatically provide static typing for your different contract ones.
00:18:16.554 - 00:18:32.090, Speaker B: So this is using Use Contract Read but you could imagine the same concepts being extended to Use Contract Write and all the other contract interaction hooks. So here's an example. I have this Abi here which has two functions.
00:18:32.090 - 00:18:47.814, Speaker B: One that is owner of, one that is balanced, has some inputs and outputs associated with them each. And then you can see that Use Contract Read takes in a function name and some arguments as well. And this is all actually typed right now.
00:18:47.814 - 00:19:13.838, Speaker B: So if I misspelled owner of, what happens here is I get some feedback from TypeScript that says owner of is not assignable to you and then it tells me the correct ones so I can change it back here. Works similarly well for arguments. So if I made this a string instead of a number, then I get some feedback too, just to show you that this actually is working.
00:19:13.838 - 00:19:29.860, Speaker B: If I change this to string, then it is valid. If I change this to an address, you can see here that it doesn't follow the address format. So that is some work.
00:19:29.860 - 00:20:00.602, Speaker B: And then similarly, one of the greatest things about TypeScript is the autocomplete that you can get in development. So you can see here that all my function names are autocompleted. If I'm working on arguments here, you can see that these are typed as well with the library we're using here too, which we wrote for this specific case.
00:20:00.602 - 00:20:10.414, Speaker B: And we'll be open sourcing as well. It works for a lot of complex types too. There's like 100% coverage here of the API spec.
00:20:10.414 - 00:20:30.998, Speaker B: So let's say we change this input value here to a Tuple type. Just do this on the fly real quick, which just follows the API spec. So we can grab let's just grab this.
00:20:30.998 - 00:20:51.306, Speaker B: We'll grab address here and we'll grab actually, let's grab Owner. What we see here is forgot a comma. All right, so now this function needs to have a Tuple as an input.
00:20:51.306 - 00:21:00.080, Speaker B: So we see here that these are both the same. So let's change this to token. ID.
00:21:00.080 - 00:21:23.430, Speaker B: Can make it uint 256. All right, so now we see that the arguments need to be Owner and Token ID so we can go ahead and add those in. So owner and Token ID, and we're good to go.
00:21:23.430 - 00:21:41.610, Speaker B: And so this works even on the arguments inside here, the type difference. And also we can have like deeply nested Tuples. Another cool thing, if we switch this over to balance of we have fixed support for fixed length arrays.
00:21:41.610 - 00:21:59.662, Speaker B: So I can make this input an address of fixed length array of two. So I can add in here I only have one address. It says requires two addresses.
00:21:59.662 - 00:22:12.930, Speaker B: So now if I add in another one, if I add in too many, it gets mad at you. So all the same stuff and then other cool stuff. Here is the response type data is also typed.
00:22:12.930 - 00:22:36.894, Speaker B: So if I change balance here to an array, then you can see that the data here is an array of like a number or big int return type. So, yeah, that's the Abi type imprint stuff. Super excited for this to come out.
00:22:36.894 - 00:22:58.390, Speaker B: It's going to be a great way for people to add end to end type safety to their Ethereum applications. And yeah, works for overloads follows the contract Abi spec, all these good things. Oh yeah, to review, yeah, end type safety for contract interactions make it really easy.
00:22:58.390 - 00:23:15.814, Speaker B: This way you don't end up deploying a change where you've misspelled the function name or sent an argument in the incorrect format. Covers the entire API spec with TypeScript. There's an open library that we wrote for this that'll be open source, so you can use it in your own apps.
00:23:15.814 - 00:23:34.660, Speaker B: You don't have to just use it with Wagme and supports more complex types like fixed length arrays, tuples with keys, addresses, any combination of these things. Also supports function overloads, stuff like that. So, yeah, you can keep on the lookout for that.
00:23:34.660 - 00:23:42.770, Speaker B: Very excited. Hopefully we'll be releasing that soon. And lastly, I just want to say thanks to E Global.
00:23:42.770 - 00:23:59.554, Speaker B: Yeah, it's pretty awesome that you all are doing this. And then also huge shout out to Family and Context to our two of the GitHub sponsors for Wagme. And then lastly, if you're interested, Gitcoingr 15 kicks off next week, so you can go to Wagme sh.
00:23:59.554 - 00:24:09.210, Speaker B: Gitcoin if you want to support or check out what's going on for that. And that's it. Thanks for tuning in.
00:24:09.360 - 00:24:18.014, Speaker A: Amazing. Well, thank you so much, Tom, and this was great. That's a pretty amazing preview on the autocomplete that'll save all of us a lot of time.
00:24:18.014 - 00:24:20.880, Speaker A: My obvious question is when.
00:24:23.910 - 00:24:34.980, Speaker B: Exactly? Yeah, probably not going to commit to a certain deadline, but yeah, definitely looking forward to getting this out as fast as possible. Yeah, we're just on vacation this year.
00:24:35.610 - 00:24:38.600, Speaker A: Okay, so in the next two to three months.
00:24:40.330 - 00:24:41.640, Speaker B: Definitely. That's great.
00:24:43.530 - 00:25:15.614, Speaker A: And maybe another one would be that obviously the library has become such a kind of rapid sort of integration into a lot of the new apps recently. I'm curious, what are some of the most common questions that you get in terms of feature support requests or just kind of patterns that you would like people to sort of take away? Given that everything is still largely malleable, how should people think about using the library in terms of best practices or things that you may consider in the future or would not consider in the future and just getting some clarity around, that would be great.
00:25:15.732 - 00:25:42.282, Speaker B: Yeah, totally. The first thing I'll say is just because everything is still so early as it relates to the library, there's still stuff we're figuring out, edge cases people might run into. And so I would encourage anyone that's using the library and runs into an issue or feels like something is like a little bit of a sharp edge to drop a note in the GitHub discussions or create an issue just because we take the feedback to heart and really want to make things very good.
00:25:42.282 - 00:26:00.366, Speaker B: Another thing is a lot of people want specific hooks for things that you can actually already do with the contract related hooks. So people want a hook for reading NFT balances or setting a token allowance. You can actually already do these things.
00:26:00.366 - 00:26:14.420, Speaker B: Maybe it's not quite as obvious, but if you just pass in an Abi and a contract address, you can just call Function and go right ahead. I think once we have the type inference, it's going to make it a lot easier for people to get started with those things.
00:26:16.390 - 00:26:21.858, Speaker A: No, that makes a lot of sense. I feel like the abstraction here is like the hoax piece, not the ability.
00:26:21.954 - 00:26:22.310, Speaker B: Right.
00:26:22.380 - 00:26:27.346, Speaker A: And the fact that you get to use it easily is kind of the aim with React apps.
00:26:27.458 - 00:26:43.758, Speaker B: Totally. And then one other thing I'll mention too, is this is all starting with React, and we're definitely very focused on React right now just to sort of get to a certain amount of coverage that we need. So that's really good tool for everyone, but definitely have plans in the future.
00:26:43.758 - 00:27:03.022, Speaker B: I think if anyone's been paying attention to what React query and that stuff has been happening there, they've switched to being a Framework agnostic. Definitely something we're very interested in. We have like, a vanilla JS core, which the React package uses, but be great to be able to support other Frameworks in the future, like View or Svelte.
00:27:03.022 - 00:27:05.574, Speaker B: So, yeah, keep on the lookout for that.
00:27:05.612 - 00:27:19.062, Speaker A: Nothing soon, but yeah, well, the teaser is good enough. This is exciting. Well, I appreciate this and I'm really happy that you're able to kind of talk about the library for the first time here.
00:27:19.062 - 00:27:35.420, Speaker A: And it seems like a lot of what's going to happen in the future is probably closer related to our next talk, which is Rick Moo. And given you're going to get a preview of what's going to be possible in Ether's V Six, you may want to stick around and also listen to what he's up to. So thank you so much, Tom.
