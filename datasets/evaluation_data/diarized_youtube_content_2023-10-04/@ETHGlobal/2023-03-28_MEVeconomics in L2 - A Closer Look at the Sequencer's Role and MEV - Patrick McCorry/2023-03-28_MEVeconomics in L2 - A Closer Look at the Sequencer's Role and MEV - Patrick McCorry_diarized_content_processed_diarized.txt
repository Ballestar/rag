00:00:06.650 - 00:00:21.326, Speaker A: And we will now transition on to the next talk. We're going to have Pat McCorry coming on and he's going to be talking about a closer look at the sequencer's role in MEB trying to unmute myself. I was enjoying that by the way.
00:00:21.326 - 00:00:26.390, Speaker A: I was happy to be delayed. That was great, Kyle. Let's get started then.
00:00:26.390 - 00:00:43.126, Speaker A: So today what I'm going to talk about is layers of layers of layers, hopefully taking inspiration from layer one and a plan of the layer two. And what we're mostly going to look at is the sequencer and how we can think about mev around the sequencer. So as we know, just a bit of background.
00:00:43.126 - 00:00:52.242, Speaker A: In mev land there's typically three agents that we care about. One is the honest user. All the honest user wants to do is buy and sell their mooncap.
00:00:52.242 - 00:01:18.150, Speaker A: We have a proposer and the proposer's job is to take a list of pending transactions and decide the final ordering of those transactions. And third, we have the searcher, those mev bots, those people living in their bedrooms where they're looking for these mev opportunities, they bundle it up and they pay the proposer to include this bundle in the list of transactions in the ordered list of transactions. So that's mev land in a nutshell.
00:01:18.150 - 00:01:43.382, Speaker A: So let's begin with Ethereum Mainnet and let's look at the lifecycle of a transaction and let's see what we can extract from this scenario. So we have a user, Alice, again, who wants to buy and sell Mooncats and we have the proposers. So the question is, how does the user get their transaction and communicate it to the proposer? So we have to consider the communication channel by default.
00:01:43.382 - 00:01:59.566, Speaker A: We will use a gossip protocol or the peer to peer network. Alice will send a transaction to a peer. They'll take the transaction and pass it on to their peers and eventually, within one to 2 seconds, every peer in the network will get a copy of this transaction, including their proposer.
00:01:59.566 - 00:02:23.242, Speaker A: They'll take this transaction and hopefully include it in their block. Now, the issue is that it's a peer to peer network, so anyone could be on it, including a searcher, so they could listen out for the user's transaction, inspect it, find an mev opportunity and then front run the user and steal the profit. So it's a bit like a dark forest in a way.
00:02:23.242 - 00:02:43.470, Speaker A: And there could be not just one searcher, but many searchers that are all competing for exactly the same mev opportunity, the same profit. And this leads to something called priority gas auctions, which I'm sure people have spoke about already, where the searchers will bid each other up. Transaction fee 123456.
00:02:43.470 - 00:02:58.006, Speaker A: And it's up to the proposer to pick the transaction with the largest fee that pays them the most money and decide who wins the auction. Now, I stole this from a blog post by Tolklasoda E. I probably didn't butcher that name a little bit.
00:02:58.006 - 00:03:10.760, Speaker A: But you can see here in the graph within a ten second period there's basically like hundreds of transactions being sent. Then eventually Mr. Blue wins and he wins the option and gets the movie opportunity.
00:03:10.760 - 00:03:23.166, Speaker A: Now there's two problems of this approach. One is wasteful of gas. You have one transaction that's successful followed by a list of failed transactions and that's a waste of block space.
00:03:23.166 - 00:03:35.454, Speaker A: And two, it's unrestricted mev. You're taking the user's transaction, throwing it to the wolves and just hoping it gets to the other side. Okay? Because it's completely unrestricted what these bots can do.
00:03:35.454 - 00:03:49.150, Speaker A: So a few years ago, a wonderful company called Flashbot, I wonder who they are. They came along and tried to solve the problem for Ethereum. We give the transaction directly to the Flashbots and they'll give it directly on to the block proposer.
00:03:49.150 - 00:04:07.830, Speaker A: So then the MVV bots or the searchers, they can't find the opportunity and they can't extract value from the user's transaction. So stepping back a bit, what can we extract from this scenario? Well, we have to consider the proposer's ordering policy. In this case, they're picking the transactions based on the fee.
00:04:07.830 - 00:04:18.270, Speaker A: Highest fee first, lowest fee at the bottom and then around 12 seconds to do this. As we saw with the priority gas option. What we need to consider as well is the communication channel.
00:04:18.270 - 00:04:43.202, Speaker A: How does the block proposer learn about the transaction and how do the searchers find it as well? And finally, sometimes we forget about the poor little user, but we have to think about the user experience. How long does it take for a user to be informed that their transactions confirmed and how it was executed? Because at the end of the day they want to execute and participate on this network. So that's Ethereum in that in a nutshell.
00:04:43.202 - 00:04:55.958, Speaker A: We took some cool ideas from that. So now let's move on to layer two and roll up land. And in roll up land there's typically three actors the honest user, the sequencer and the executor.
00:04:55.958 - 00:05:08.810, Speaker A: Now for once we're not going to talk about the executor. They have very little to do of mev. We care about the sequencer, who's basically the proposer and gets to decide those lists of transactions and their ordering.
00:05:08.810 - 00:05:19.774, Speaker A: They have everything to do of mev and the lifecycle is pretty similar. Alice gives their transactions to the sequencer. The sequencer will have a list of pending transactions.
00:05:19.774 - 00:05:28.230, Speaker A: They'll run some ordering policy. They'll decide the ordering of the transactions. Then they'll post that onto Ethereum, into an inbox and then picked up by the breach.
00:05:28.230 - 00:05:36.370, Speaker A: Now in this scenario we have this direct communication channel. There's no gasa protocol. Alice can communicate directly with the sequencer.
00:05:36.370 - 00:06:08.434, Speaker A: And what we need to be concerned about is when does Alice get a response from the sequencer and what type of response do they get? And that's really going to depend on how the sequencer decides the order of these transactions, then of course what we care about is the sequencer's ordering policy. They can keep the transactions private for as long as they want, decide the ordering and then eventually make that public once they've made their decision. So what ordering policies could the sequencer implement? So we're going to go through three.
00:06:08.434 - 00:06:15.662, Speaker A: The first is has extraction first. The second is has fee first. And the third is first come, first serve.
00:06:15.662 - 00:06:34.634, Speaker A: So let's just dive right in and see what we come up with. Has extraction first and basically when you talk about sequencers in mev and layer two, this is the first ordering policy that everyone talks about. And the reason is that sequencer has ample time to extract value.
00:06:34.634 - 00:06:46.650, Speaker A: They could wait a minute or hours before they have to publish that transaction publicly. So a practice both Arbitram and optimism. They typically publish these transactions in about 20 or 30 seconds.
00:06:46.650 - 00:07:00.354, Speaker A: But according to the smart contracts, Arbitrum can hold it up to something like 24 hours. And the optimism, I couldn't actually find the value. Someone could probably drop it in the chat, but I'm pretty sure it's like 24 hours they could keep these transactions private for.
00:07:00.354 - 00:07:23.482, Speaker A: So if you can hold a transaction pending transactions for 3 hours, let's say, well, you have this big basket of transactions. You have your mev extraction algorithm, you run it on the batch and then you could order your transactions according to the ones that you can extract the most value from. Now in terms of user experience, there is a benefit to this.
00:07:23.482 - 00:07:38.378, Speaker A: We can have a Robin Vogue style experience. The user could transact for free because later on their transactions used to compute some mev reward. So from the user's perspective it's a free transaction, but they're really paid for it through MPV.
00:07:38.378 - 00:07:49.886, Speaker A: Now, the issue with this approach is really the long delay. If we allow the sequencer to extract value for two to 3 hours, well, that sucks for the user. Think of bitcoin.
00:07:49.886 - 00:08:01.080, Speaker A: You have to wait 1020 minutes on Bitcoin and everyone gets that it's a terrible user experience. So imagine waiting 2 hours just so someone can go extract value from your transaction. That's not a great user experience.
00:08:01.080 - 00:08:09.382, Speaker A: Now you could solve this problem. A lot of people think, okay, Sequencers can extract mev. Let's solve this and stop that from happening.
00:08:09.382 - 00:08:20.074, Speaker A: So they could implement some fair ordering protocol. Maybe the sequencer can't see the transaction content, maybe you introduce a consensus protocol. What does fair mean in this context? I don't really care.
00:08:20.074 - 00:08:27.626, Speaker A: It's not important for this talk. I think Tarun's going to talk about a linear it's going to be pretty spicy. But for now I'm going to argue differently.
00:08:27.626 - 00:08:41.346, Speaker A: I'm going to argue we don't need to solve the problem. Because if you look at proof of stake ethereum today, you have this open market of searchers PBS and you have the stakers who are basically competing in a lottery. The searchers do all the hard work.
00:08:41.346 - 00:09:05.020, Speaker A: They extract the mev, they pay a bribe to the proposer, the proposer gets a transaction fee, then they include the bundle. And so there's a very good chance that a sequencer can make more money by having an open market of searchers do the hard work as opposed to trying to extract the mev themselves. And if that's the case then their financial incentive is not to extract the value but allow someone else to do it.
00:09:05.020 - 00:09:19.280, Speaker A: So we don't have to worry about the fair ordering problem for now. And if asked the Kias well that means the sequencer's ordering policy is the order transactions by transaction fee. Whoever pays the has fee will get ordered first in the list.
00:09:19.280 - 00:09:40.294, Speaker A: And so this is basically payment for order flow. Maybe some mev people hate me for saying that but it's basically that anyway, the sequencer will get the list of pending transactions and give it to the searchers. The searchers can crunch and crunch and crunch, extract as much mev as they want and then eventually send a bundle to the sequencer with a payment.
00:09:40.294 - 00:09:57.930, Speaker A: And they'll say sequencer, if you clear my bundle you'll make this amount of money then the sequencer takes that bundle, they take the payment and of course they order it according to the payments they receive. Very much similar to what happens on Ethereum today. You're sharing the mev between the sequencer and the searchers.
00:09:57.930 - 00:10:12.138, Speaker A: And again user experience stuff very different to the previous case. Users could still have free transactions because the transaction fee is actually the mev that's extracted. But again, this could have a long delay.
00:10:12.138 - 00:10:32.178, Speaker A: Users don't want to at least I don't want to build a layer two where users are waiting for two to 3 hours for their transaction to be confirmed. So this is why most rule apps implement first come, first serve because they want to prioritize the user experience. What do I mean by this? Well, the user will send their transactions to the sequencer.
00:10:32.178 - 00:10:41.690, Speaker A: The sequencer will timestamp this and then simply order the transactions according to the timestamp. And this has a wonderful user experience. It's a bit like transacting on Coinbase.
00:10:41.690 - 00:10:56.474, Speaker A: You send your transaction to the service provider and they return back a response to say it's confirmed. This is how it's executed under a second. Typically when people talk about first come, first serve they say oh well there's no mev here hiding under the covers.
00:10:56.474 - 00:11:18.490, Speaker A: Well of course there's mev, there's mev everywhere, you'll never get rid of mev. So anyway, how do we have mev? So what happens in practice at least with Arbitram and I assume is the same for optimism. When a user gives their transaction to the sequencer the sequencer will create a little block within 250 milliseconds and then publish that off at a feed.
00:11:18.490 - 00:11:35.610, Speaker A: Now the reason to have a sequencer feed is because external service providers like Etherscan, Coinbase or infuriat they could pick up the block and present it to the user. So a user could send the transaction to the sequencer, then look at Etherscan and say oh, my transaction was confirmed. According to Etherscan.
00:11:35.610 - 00:12:01.886, Speaker A: Now, what happens when you have a data feed that's releasing data about transactions in real time? Searchers connect to it, they listen for the transaction. If there's an mev opportunity, they'll backrun it and send it immediately to the sequencer. This leads to the rise of latency dims because you don't end up with one searcher, you end up with 150,000 WebSocket connections.
00:12:01.886 - 00:12:27.462, Speaker A: Because whoever gets the data first, whoever gets that transaction data first is the one who wins the mev opportunity and can back run the user. And there is in theory this happened the arbitram and I guess it's probably still happening, I don't know. They had this post where they had 100,000 to 150,000 connections because the mev bots are competing on a latency game to extract mev or any spec run transactions.
00:12:27.462 - 00:12:35.438, Speaker A: The short term solution proposed was to implement hashcatch. So you create 50 dedicated connections. The searchers do proof of work.
00:12:35.438 - 00:12:47.890, Speaker A: Your rest of lowest dunce wins one of those connections. And so then the searcher's game is to have do proof of work as opposed to creating the thousands and thousands of web connections. WebSocket connections.
00:12:47.890 - 00:13:13.142, Speaker A: Now, that is a solution. But I think there's a more interesting solution that comes out of this and sort of motivated by Ed Felton's proposal, which we'll talk about in a second. Why didn't you combine first come first serve with the has to be first? What do I mean by this? So, basically similar to before user gives their transaction to the sequencer, the sequencer may collect one or two transactions and then pass it on to the searchers.
00:13:13.142 - 00:13:31.962, Speaker A: The searchers will take this small bundle, extract as much mev as they can, participate in an auction, and then submit their bundle with a payment to the sequencer. The sequencer will take whatever bundle pays the most money and then confirm that. Now, the point here is that this bundle auction is configurable.
00:13:31.962 - 00:13:43.086, Speaker A: The auction window could be really short. It could be 500 milliseconds, two milliseconds, 5 seconds, whatever, a really short period of time. And the sequencer can constrain the mev.
00:13:43.086 - 00:14:01.734, Speaker A: The sequencer can say oh, I'll only let you front run transactions or back run transactions or sandwich transactions or all of the above. So what's cool about this is one, if we have these short rapid options, then we get a fast confirmation for users transactions. I submit my transaction within 3 seconds.
00:14:01.734 - 00:14:13.246, Speaker A: I'm told that it's confirmed. I may have got front runner background runs, sure, but my transaction was confirmed. Two, if it's open market for searchers, admittedly it's smaller bundles that they're working with.
00:14:13.246 - 00:14:32.834, Speaker A: So you are constraining what extraction they can do. But again, you still have this open market where they can probably find the best extraction and finally, it's configurable the sequencer can decide what mev is allowed, as opposed to having this crazy dark forest that's really unconstrained. Now, this is sort of the idea coming out of I don't want to say sort.
00:14:32.834 - 00:14:51.990, Speaker A: It's basically the idea coming out of Ed Felton's post about time boost here. I basically described it as having a queue where you can immediately front runner background, or, of course, sandwich. In this proposal, you could convince the sequencer with a payment to say, well, here's a transaction ordered 500 milliseconds in the past.
00:14:51.990 - 00:15:14.718, Speaker A: And then you could, depending on the timestamps of the transactions, you go front runner back, so you're paying for time as opposed to a position in the queue. But my main point is, this is a really cool research question, a really cool open problem, and it's sure to get the best of both worlds fast confirmations, but still having this open market for searchers. And so I guess that's my last slide, I guess, since time.
00:15:14.718 - 00:15:24.010, Speaker A: But I just wanted to present this idea because I've been thinking about it a lot and I think it's a really cool idea. So, yeah. Gigi or GM? I guess GM.
