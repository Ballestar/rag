00:00:07.130 - 00:01:09.410, Speaker A: So querying and indexing smart contract data on Ethereum with the graph. I start here really with the basics. That is what is actually then a smart contract anyways. And I have like an interesting, like an example you can think about of a smart contract that it has two things. Basically it has storage like data and you can think about the storage in a smart contract as a simple Google Sheets or Excel sheet where you have just rows and columns with data in it. When we look at the NFT contract, it's my main example because it's such simple in terms of technology in a very simple way. You have an ID, the Token ID of the NFT and then you have an owner, which is an Ethereum address.
00:01:09.410 - 00:01:53.554, Speaker A: And then you might or might not have a metadata Uri and other stuff. But in a nutshell the NFT, the Esxn 21 contract defines Token ID and an owner. So that's the data view on it if you want to. Yeah, the problem is with the data is that the smart contract and the blockchain, it usually holds the state. As of now, it is a good tool to see who has which NFT, who owns which NFT. But it is not very good in knowing who owns the NFT before. And that's exactly what's going on here.
00:01:53.554 - 00:03:12.730, Speaker A: That's a problem that we don't see who owned it before in the smart contract state by itself, this is where the graph jumps in that it actually helps to also find a way into the history of the smart contract and on top of that making the current state actually also easier to access. So you can think about without the graph it is just this and with the graph we have a history, but we'll go a little bit deeper. The second thing that a smart contract does besides holding state or data is it also has rules how to change that data. And that's very important because you don't want everybody just changing who owns which NFT. It follows certain rules which can be encoded in the smart contract and that's also why it's called smart contract because the data can only be changed according to the rules. So let's define quickly the concept of a blockchain. Again, so basically a blockchain is a distributed data storage secured by cryptography.
00:03:12.730 - 00:04:01.594, Speaker A: That means that all the transactions, they are in blocks and then the hash is coded all over those transactions. That makes a block and then the block is always linked to its previous block. That makes the whole thing tamper proof. So you can never change one thing. Distributed means that the blockchain runs not on one server. It is basically copied over thousand or 10,000 times all across the world. That makes it so censorship resistant that you would basically need to shut down every single node that runs the Ethereum blockchain on it or whatever blockchain in order to stop it.
00:04:01.594 - 00:05:04.906, Speaker A: And that's basically impossible because we have not that global jurisdiction where you couldn't force such a thing. That makes it very interesting. But going forward we think of the blockchain as one thing we do not care about, that it is distributed across all these machines. So we think of it as a logical one unit. So that's just the blockchain. And then the smart contract, as I said before, is the data and the logic how to change the data that is stored on blockchain. How does it work? If you want to change the data, you send a transaction to the blockchain which is then distributed across all these copies, but you sign it cryptographically with your secret key or your wallet so that everybody knows that this is a legit transaction and then the transaction is included on the blockchain.
00:05:04.906 - 00:06:14.500, Speaker A: We will look at that later on. But there is a problem with the data on the blockchain, as I said before, but the user interfaces, as we initially saw, they want to read, they want to write to the blockchain and as we saw before, it is incentivized. So if you send a transaction to the blockchain you pay some gas or you have to put some gas on top of it and the gas is consumed by the miners or now it's the proof stake by the validators and then that's why you pay and by paying for it the whole thing works. But when you want to read from blockchain there's no incentivization for anybody to provide you that data per se, not in the protocol. So that's why when you go on Ether scan you see a lot of advertisements which sometimes are also a little bit shady in order so that Etherscan can fund its own business. Or the same is also with alchemy. If you do a lot of requests to Alchemy or infura, you need to pay for them.
00:06:14.500 - 00:07:14.614, Speaker A: So they're jumping into it. But the protocol by itself incentivize reading, that's a big problem. Going back to the analogy from before, each of these things here is one transaction. And also a bigger problem with the theorem blockchain especially is that we have all these smart contractor DApps that have stuff on the blockchain and every time someone sends a transaction it just laid on top of each other. So in the end, if you want to see, okay, what was actually going on, let's say in foundation, then you would need to go through all these transactions and pick the ones out that are according to foundation. And that's quite tedious work and it takes a lot of time. That's not something that you want to have in the front end and this is also what we see currently or before the graph that front ends do.
00:07:14.614 - 00:08:33.578, Speaker A: This is really code from a project that I was advising how they were trying to get the data out. So for those that understand JavaScript or TypeScript, that reads as follows you try to get a contract. But all these await methods, especially those that we see here. And these here, they all take 200 to 300 milliseconds to resolve because you always call back to some node, which you usually need to pay somehow, that they give you that data and then you wait and you go through. So this code, if you own, let's say, ten or 20 NFTs, easily gets five to ten or 20 seconds to load, just to show you a list of the tokens that you hold. And this is super inefficient and users just move away after a while, say like whatever, I didn't have time to wait 20 seconds for my staff to resolve. Yes, that's actually now we had already two reasons why the graph exists.
00:08:33.578 - 00:09:33.090, Speaker A: So for one, to get the historical data, but for two, also to have a very good access to the data on the website. You probably know it's indexing protocol for green networks like your IPFS. There's also support for RBE, near Cosmos and others. So in the end, the graph will index all blockchains more TM on those services. Currently one point or 1 billion queries per day, or even a little bit more depends. So it is really powering a lot of the debts that we see currently uniswap is the most famous example that uses but we also others like enzyme or audios or yeah, there are a bunch of them. And it's not only the host service, it's also decentralized indexing network protocol.
00:09:33.090 - 00:10:25.638, Speaker A: So there are more than 180 indexes, I think currently worldwide, owned by individuals oops and that means these are independent indexes that run with things. Or it is similar to what we talked about before, but ethereum or a blockchain general is that we have a distributed network. There is this redundancy. So if a subgroup is indexed by one indexer across the world, if one goes down, another is still around. It also gives you fast and cheap reliable access to that data. And yeah, the whole mission is that we go towards a global open API of the data that we need. Yeah, that's very cool.
00:10:25.638 - 00:10:56.990, Speaker A: Then in the end we can now build truly decentralized apps. That's what we try to do here. So quick into the subgraphs. So I've told you before about subgraphs. subgraphs in general are just a database. A database is the same as you saw before in these Google slides, just multiple of them. So a database consists of multiple tables and you can define the tables as you wish.
00:10:56.990 - 00:11:51.514, Speaker A: Then you have the mappings, which is this gear here, that's a logic of how to get data out of the blockchain into that database and in the end you make it available. And the subgraph by itself only subgraph by itself is only the code that defines how this is done. But it doesn't do it necessarily by itself. The indexers then need to index the subgraphs, which by indexing. That means they create the database and they run the code how to fill that database. So yeah, that's a subgraph. So what happens is that we saw this mess of transactions that are just layered on top of each other that they are created like very nice and neat buckets for each of the protocol in a database per each protocol.
00:11:51.514 - 00:12:36.798, Speaker A: So we can easily query that data and make much more sense about what's going on. In the end we end up with to go back to the screenshot from before that we have a very nice and neat GraphQL query. So we send one query that has a round trip of 100 to 300 milliseconds. Usually it's much quicker. That's what we expect to get that data out. All right, I was just reading the chat, so I will also share with you that presentation afterwards. All my presentations are open, you can use them even if you want to give that presentation to someone.
00:12:36.798 - 00:13:33.226, Speaker A: Maybe you want to remove the edge and node logo then. But yeah, it's public goods. So we end up with this modern DAP architecture where we have the user interface on top and then the blockchain on the bottom that we knew already. In between is this indexing protocol that is incentivized and built for data reading and that sits in between and reads data from the blockchain and stores it in this indexing layer. All right, so how does it look like then? How can you think about it? This is the illustration, that's the official one, how the graph node works. So again on top is the Depth adapt can be like in its purest sense adapt. It's just HTML, CSS and JavaScript that defines the DAP.
00:13:33.226 - 00:14:18.746, Speaker A: It could be also other programming language, but that's what you currently see. As we talked before, when they send transactions to the smart contract, you can change state. So that is buying an NFT on an NFT marketplace or swapping something on Uniswap or open LP position. Whatever cool thing you can do in the transactions transactions, they emit events. And with events, the smart contract basically tells the outside world what happened. We can look into this later what an event is, but that's basically what Smart contracts emit. So you can watch the blockchain or watch Smart Contracts for those events.
00:14:18.746 - 00:15:34.246, Speaker A: These events are then ingested into the graph node which will then according to those events run mapping which is in WebAssembly module and put then stuff into the store. So here is the listed database where the data is stored for later retrieval. Then the other way that we had also in this image from above is that the Depth also needs queries. So if you go to Uniswap at the analytics page, it needs to load data somewhere. So it sends queries to the graphical API which sits on top of the graph node and that graphical API will get data from the store and then send it back to the it's very neat right. Also a very funny GIF that we used to displace this one like how subgroups work. So you have this mass of transactions again and then magically somehow they are sorted into this pocket so that they know what's going on.
00:15:34.246 - 00:16:21.320, Speaker A: Have an overview. All right. So now when you think okay, that's very cool but now how can I actually find data tool query? The best thing in my opinion is these subgraphs XYZ from Missouri. They are writing very sophisticated subgraphs. Okay, I also send you this thing here in the chat that's currently for me the best entry point. I mean you can also go to the Graph graph.com and go here to the Graph Explorer and then you see also subgraphs here.
00:16:21.320 - 00:17:21.786, Speaker A: But the one from these are the ones that write for themselves or also some of necessarily see they're also in the tops here. But subgraphs here are very good. So we can for example say cool, let's have a look at I know so they have some on the decentralized network and some on the hosted service. So you can look through them and find out they have like hundreds of subcrafts. What is it? Okay, 27 production, 47, 74, 4700 development and 106 deployment cost. Why is that? Because they deploy to different chains curves. They are usually the same on all cool.
00:17:21.786 - 00:18:24.780, Speaker A: So when you want to look into one of those another good example actually is this one is the CryptoPunk subgraph here. You need to be careful to take the one with the highest correlation because somehow all the people just deployed subgraphs. That's downside of a decentralized network. Now if you want to query that subgroup then you can just go here and go into the playground and start to play around with that subgroup. But what I like to do and that's where I think it makes sense to see this workshop is to actually open up a little bit more sophisticated playground. Although a revamp of this one is in the works. But I can show you how this work works.
00:18:24.780 - 00:19:42.996, Speaker A: So what we do if you want to query a subgraph on decentralized network what you need is kind of this query URL. You can copy this query go here then you can go to explore like this and paste it. Now the problem with subgraphs on the decentralized network is that you need to have an API key and that's inside of that URL is placeholder for the API key we first need to find one. So let's do this together. What you do is you go to the subgroup studio, actually connect the wallet and I will just create a new account connect and then sign in. I use tips already to deploy some test subcraft. But what's important for you is that you go to API keys and not subgroups and then create a new API key.
00:19:42.996 - 00:20:29.300, Speaker A: Click here, say like demo and then I can receive free queries that would is by giving an email that these are optional fields so I can claim the queries. And now I have 2000 free queries on this API key. That's very good. And I already have the API key here, so I can just copy here, go back, go here and paste it. Feel free to just abuse that one. Everybody can have thousands free query. Cool.
00:20:29.300 - 00:21:14.510, Speaker A: Now what we have here is on the top we have the subgraph and on the bottom we have the explorer and the documentation. So the cool thing about GraphQL is because it is very strongly typed query language that we can have this explorer. On the right you can also have the docs. A GraphQL query has so called root types and here we have the root type query and root type subscription. Although subscriptions do not work currently. So we go with query. If you go on query then you see a detailed documentation about what you can query.
00:21:14.510 - 00:22:03.854, Speaker A: So in this example, when you look at the crypto punk subgraph it has accounts which are holders of punks. Then we have the actual punks and we have metadata of the punk. And all of these you see there is this repeating pattern of account and then account with S. So the first one is to get just one and then you need to provide an ID or you can have many and then you can have a filter. We will look into this and then the result is an account or just one account or a list of accounts. Same with punks and CP account punks, metadata, trades, asks bits and contract and so on so forth. That's what's going on.
00:22:03.854 - 00:23:13.270, Speaker A: So now what do we want to do? A funny thing to do with the crypto punks actually is to say I want to know which was actually the most expensive sale ever happened on a punk. And you could go to crypto punks normal apps here. Okay, cool. I think you can try large sale. So cool. They say the largest sale ever happened is this 15822 for 8000 e. Always funny for me to see like the people actually pay that much money for a pixel but that's how it is.
00:23:13.270 - 00:24:00.036, Speaker A: Now we could try to reproduce this one and that would be cool. We go here to the sales and I like this explorer. We will have soon something like this. Also on the graph.com it always looks the same. We can say okay, what we want to do, we can actually order by the amount of the sale and the order direction we make it descending so that says it will sort the list of results by amount and the highest amount to be on the top. Then we can say, okay, in which hash it happened.
00:24:00.036 - 00:24:39.810, Speaker A: We can say which ID it is and we want to see also the amount actually want to see the transaction hash. And then we maybe want to have the from and to let's see and see. This is for me a very explorative. That's why it's also called Explorer. I can just click around here and read stuff and trying to figure out what data is here and then I can send it. Cool. Now we see.
00:24:39.810 - 00:26:22.660, Speaker A: So the highest according to that chakra is actually this one and funny enough when we go back here we see this is eight k but that's the second one. Maybe I should also get pulp out. Let's send this again can remove this one a little bit better view so 5822 yes that's what we saw here for eight k. But a funny thing is that actually the highest sale ever is this one kicked with turbo and let's try again. Cool. And why is that what happened here? So when we go to way by the way usually it's underway so what happened here? This is interesting vista eight K is the highest sale and that's what they say here. But actually we also see when we look on the blockchain that it is one hundred and twenty four k e for one punk.
00:26:22.660 - 00:28:05.810, Speaker A: And now you wonder like why is it displayed here? We can start to do investigations and that's what I think is the graph perfect for and say there is this transaction hash go to either scan actually new compute so autocomplete not there yet and actually start to look into this thing and what you see here is that someone made a flash loan. I think here we see someone got what is this? 500 million die in a flash loan. I think from compound change in abrupt e. That's why we end up with this weird number and then buys punk and then gives it all back and sells punk again. This person tried to fake this transaction and interestingly, on the official side they censor this but they talk about it in an interesting way so we can try to see the punk with the number and go here and see they say I gave this blah blah blah. They are flash loan and they send it on their website. Cool.
00:28:05.810 - 00:28:10.740, Speaker A: Yeah, I think this explains how to query the graph.
