00:00:06.490 - 00:00:18.202, Speaker A: All right. With that, we are ready for our next incredible speaker. I want to bring on Raul to talk about a lot more intricacies of the Fem.
00:00:18.202 - 00:00:22.986, Speaker A: So without further ado hi. Hi. Kartik.
00:00:22.986 - 00:00:33.558, Speaker A: Hi, everybody. Very excited to be here. I'm just going to quickly share my screen and going to be talking through understanding the Podcoint EVM today, just to give you a little bit of information.
00:00:33.558 - 00:00:42.298, Speaker A: I know you were all focused on building, but it's ideal to have just a second. There you go. I think we're good with a share now.
00:00:42.298 - 00:00:47.002, Speaker A: Fantastic. All right, so, hey, my name is Raul Kablani. I'm the Fem project lead.
00:00:47.002 - 00:00:58.334, Speaker A: Very excited to be here. Very excited about everything that's going to happen over the course of the next weeks. We have been working on the Filecoin project for, as Molly said, for little over a year.
00:00:58.334 - 00:01:10.420, Speaker A: We launched in July. Last year, we launched the Fem to the Filecoin network. So really the Fem is already powering all state transitions and Mainet, I'll talk more about that in a second.
00:01:10.420 - 00:01:31.078, Speaker A: But this is the next big milestone, is just around the corner, 40 days away, Febim. If everything goes right, Favim will hit Mainet in the first week of March in that time period. So, yeah, really excited to be here and to get all of this ecosystem in this realm of opportunities kick started.
00:01:31.078 - 00:01:57.550, Speaker A: So I won't go into too much detail because I only have 15 minutes, but my goal today is to touch on the things that I think you need to know as an ethereum developer onboarding into the Ficoin EVM. Honestly, our goal was to make things just work and to deliver that kind of experience. So we don't really expect a lot of divergence and we don't expect a lot of kind of like, hey, what's going on here? Moments.
00:01:57.550 - 00:02:15.400, Speaker A: But I think it's really important for you to know how things work under the hood because it will make your journey easier and more frictionless as you're moving forward. So, having said that, as Moni mentioned, the FVM project delivers on chain compatibility to the five point network. I just wanted to lead with that.
00:02:15.400 - 00:02:30.678, Speaker A: And this is basically what the Fem looks like. As I said, the Fem was really introduced to the Filecoin network in July 2022 with Milestone One. It is a WebAssembly based execution environment.
00:02:30.678 - 00:02:42.878, Speaker A: It is using WASM time under the hood. It has been conceived and built from the ground up to support multiple runtimes. So it's really inspired by the concept of hypervisors from the realm of virtual machines and so on.
00:02:42.878 - 00:02:55.870, Speaker A: And the EVM. A testament to that is that the first runtime that we're actually programmable runtime that we're shipping to the Fem is the EVM runtime. But we will have further runtimes down the line, like, for example, the WASM Native.
00:02:55.870 - 00:03:16.614, Speaker A: We also call it Native Runtime. Secure my script and other potential things that could be layered on top of the Fem so that it's possible to run different kinds of programs on top of the Fem and on the Falcon network. Now, the Fem itself is very much inspired by the Unix architecture and is built around the concept of syscall.
00:03:16.614 - 00:03:35.646, Speaker A: So basically, everything that is running inside the Fem, whenever it needs access to the environment or it needs to escape that sandbox, it would perform a syscall. And some of those primitives are, for example, data accesses which all revolve around the concept of IPLD, which stands for Interplanetary Link Data. That is our data model in the Falcon blockchain.
00:03:35.646 - 00:03:59.906, Speaker A: It is also the data model of IBFS and all state reads and writes translate into IBLD states and writes by. Also, the Fem also has we're introducing foreign addressing support. So this is the ability to assign addresses that actually mean something that respects some semantics of another chain.
00:03:59.906 - 00:04:13.210, Speaker A: Like, for example, Ethereum addressing And I'll go into that in a second. It is also prepared or we're paving the way to introduce the concept of abstract accounts. And it also has the ability to perform resource metering via gas accounting.
00:04:13.210 - 00:04:42.098, Speaker A: So having said that, we're launching EVM compatibility, right? And EVM compatibility is enabled by six key elements. First of all, the ficoin EVM runtime which we nicknamed Febim for a short name ethereum address Support ethereum Account Support ethereum Transaction and Signature Support. And the Ethereum JSON RPC which allows for seamless compatibility with tooling and libraries.
00:04:42.098 - 00:05:02.390, Speaker A: And also after events, I'm going to cover the first five just to kind of give you a little bit of a glimpse into how things work under the hood. I won't cover the 6th, but if you want more information on how that works at a protocol level, just ping me on Slack or Discord. Now let's dive into the filecoin EVM runtime.
00:05:02.390 - 00:05:32.722, Speaker A: What you need to know is that the EVM runtime is basically an actor on the filecoin chain. An actor is code that lives on the chain on the filecoin chain and it is WASM code that gets run within the WASM runtime which is the Fem. Now, the EVM runtime itself is, as I said, one more actor and it contains a slimmed down EVM interpreter which has been specifically which we've specifically optimized for Waltz and environments.
00:05:32.722 - 00:05:47.558, Speaker A: It is Ethereum Paris fork compatible and it supports all no codes and all pre compiled. So basically EVM bytecode that you deploy to the filecoin EVM runtime should just work. And this is the experience that we're really trying to target.
00:05:47.558 - 00:06:15.214, Speaker A: There are some caveats which I'll talk about later on, but if at one point you find that there is some contract that you're trying to deploy that doesn't just work and it's not due to those caveats, just let us know because our goal is to make that portability seamless. Now, it integrates with the fivecoin environment and basically it performs, reads and writes via Fem syscalls. I mentioned those earlier.
00:06:15.214 - 00:06:37.334, Speaker A: It maps the storage of the EVM storage into the IPLD data model. We've introduced a new data structure called the Camp to support this. And it also introduces, besides the Ethereum standard precompiles that are available in the Paris fork, it also introduces a number of filecoin specific pre compiles that give you access to filecoin system features.
00:06:37.334 - 00:06:58.050, Speaker A: I'll also cover those in a few minutes. One important thing is that the EVM runtime does not perform Ethereum gas accounting. Everything related to when is your contract going to halt, how is gas going to be charged, how is gas use going to be measured and so on is all based on filecoin gas usage.
00:06:58.050 - 00:07:16.242, Speaker A: This EVM runtime is introduced by Fit 54. So if you want to take a look at that and kind of like go into the deep details of how things work, that is a really good reference for you. Now, just to talk about Ethereum addresses.
00:07:16.242 - 00:07:32.694, Speaker A: So the key headline here is that filecoin is able to work and recognize Ethereum addresses. How do we make this work? Filecoin, since the beginning, has had the ability to have multiple addressing schemes. And we use this before the EBM already.
00:07:32.694 - 00:07:43.882, Speaker A: So we've got F zero addresses, addresses that start with F zero or T zero. If you're working with a testnet, t stands for test. So f zero t zero are ID addresses.
00:07:43.882 - 00:07:55.282, Speaker A: F one addresses are SECP two five six k one accounts. F two addresses are non account actors and F three addresses are BLS accounts. We've introduced a new address class which is F four.
00:07:55.282 - 00:08:18.090, Speaker A: So every address that you see prefix with F four belongs to this address class and we're calling it the delegated Address class. So basically this address class has F four and then it has a number which in the case of Ethereum is ten. And this maps to the ID of another actor which is designated as the address manager for that entire space.
00:08:18.090 - 00:08:39.218, Speaker A: So basically every address that you see starting with F four 10 is an Ethereum address. So I've put an example down here. This F 410 address maps to this Ethereum address and it looks like completely different, but really the payload of that address is exactly the same.
00:08:39.218 - 00:08:47.186, Speaker A: It's just encoded with base 64 in our case. So that's why it looks slightly different. There are all explorers.
00:08:47.186 - 00:08:54.594, Speaker A: Most explorers are actually prepared to display the ETH address to recognize ETH address as they exist. The JSON. RPC.
00:08:54.594 - 00:09:11.046, Speaker A: Endpoint also recognizes and translates ETH addresses transparently. It just works. So everywhere that you would use an address, you could use a ETH address, whether it's an Explorer or whether it's the Ethereum JSON.
00:09:11.046 - 00:09:15.134, Speaker A: RPC. Endpoints. Ethereum addresses are introduced by the specification up there.
00:09:15.134 - 00:09:30.718, Speaker A: So if you want to take a look, if you want to understand a little bit more, then that's the link cool. So we've also introduced the ability, we've also modeled Ethereum accounts. So there's a new kind of actor in Filecoin.
00:09:30.718 - 00:09:47.790, Speaker A: It's called the Ethereum account and it represents Ethereum externally old accounts. So these are accounts that are backed by a key. And basically what happens is that when you first send to an Ethereum address, what the protocol will create is what we call a placeholder actor.
00:09:47.790 - 00:10:13.518, Speaker A: And a placeholder can transition into an Ethereum account or it can transition into an Ethereum contract depending on what happens next. So if something deploys a smart contract onto that address, it will magically convert into an Ethereum account. If that address suddenly sends a transaction that is assigned transaction to the chain, it will automatically transition into an Ethereum account.
00:10:13.518 - 00:10:26.574, Speaker A: And this is completely transparent. You don't need to know about this. But when you go to an Explorer, when you first send funds to yourself through faucet and hyperspace or whatever, you go to an Explorer, you will likely see that your address is a policeholder.
00:10:26.574 - 00:10:48.620, Speaker A: And the first time that you send a transaction from that address through your MetaMask wallet or any other wallet, it will transition into an Ethereum account. Another thing worth mentioning is that we support Ethereum transactions of type two. So these are RLP encoded signed Ethereum transactions with the original EC DSA signature scheme with SEC p two five six.
00:10:48.620 - 00:11:11.102, Speaker A: And we only support key mentioning this. We only support EIP 1559 transactions. And this is because Filecoin, since the beginning has been using a base fee model, has been using the dip 1559 in Filecoin terms and translate it into the filecoin blockchain.
00:11:11.102 - 00:11:27.890, Speaker A: And that's why we only support this kind of transaction. So most tools and kits and so on that Zach and others are going to tell you about after this presentation. Already sending type two transactions to Ficoin.
00:11:27.890 - 00:11:46.010, Speaker A: But I just thought it would be worth to mention here. Now, at the RPC level, we also support ETH has to make gas max priority feeba gas and fee history. So I completely implemented and usually tools call these methods to automatically return Gas values.
00:11:46.010 - 00:12:18.506, Speaker A: Now, when you submit an Ethereum transaction through the JSON RPC endpoint, these behind the scenes are translated to finecoin messages carrying a delegated signature. In the future, I mentioned that we're going to be implementing account abstraction. This is a key part of that transition towards account abstraction because in the future, when the protocol sees a delegated address it will just hand off that signature validation to an actor on chain, which can be anything.
00:12:18.506 - 00:12:33.134, Speaker A: So this will allow actors, arbitrary actors to work as senders. However, right now the validation during this transition period is performed directly in the protocol. But this whole process should be entirely transparent to you.
00:12:33.134 - 00:13:00.834, Speaker A: Once again, if you have any troubles around this, make sure to ping us via your support channels. So I also mentioned that a key element of making Filecoin work with existing Ethereum tools and libraries so that deploying on filecoin can leverage the very rich ecosystem of tools and libraries that exist for Filecoin automatically is the JSON RPC endpoint. So the lotus.
00:13:00.834 - 00:13:15.462, Speaker A: The reference implementation of the filecoin protocol supports the ethereum JSON RPC API. Lotus is also the client that's currently powering the hyperspace testnet. We expect other clients like Forest and Venus and so on will also join that testnet.
00:13:15.462 - 00:13:26.538, Speaker A: But for now, we know that Lotus is implementing this JSON RPC. As I said, this enables immediate Ethereum tool compatibility. Things like Hard hat remakes, Foundry, Brownie.
00:13:26.538 - 00:13:36.846, Speaker A: They just work with filecoin. And there are the URLs for hyperspace down here. There's a list of the methods that we've implemented in that RPC.
00:13:36.846 - 00:13:53.000, Speaker A: These are the standard methods. We are aware that other Ethereum clients have specific methods which then tools end up relying on to do specific things. If at one point you're missing a method, then let us know.
00:13:53.000 - 00:14:47.222, Speaker A: Okay? So another key element that I wanted to stress about the Filecoin protocol and building on Filecoin is that much of Filecoin's verifiable storage, crypto economy, and basically everything that happens at Filecoin today concentrates around the concept of built in address. So these are implicit smart contracts that exist in the protocol. So it's very likely that when you're building file print specific use cases like data dows or lending pools that integrate with a minor actor or you're building computer networks or you're building things like that, you will want to interact with these built in actors to query what is the power of this storage provider or what is the current status of this particular deal and storage deal on the network? Right, so there's a list of the actors that you likely want to interact with.
00:14:47.222 - 00:15:00.026, Speaker A: These are also defined in the Filecoin spec. And there is a YouTube talk. There's a talk on YouTube that one of our core developers, zen gave a few months ago that goes into this.
00:15:00.026 - 00:15:19.620, Speaker A: So if you want to check that out, he does a really good deep dive into all of the actors and how all of this works. And I think it could serve as a really good tutorial to get bootstrap really quickly. Now, to interact with these built in actors, you might be asking, well, how do I call out to these built in actors? We wanted to make it really easy.
00:15:19.620 - 00:15:48.378, Speaker A: So what do we do? We worked with Zondax to build a set of solidity libraries that just behave expose a number of solidity functions that behind the hood, do all the plumbing work to call these built in actors. So basically, what you'll see this library is pretty it's very like a one to one mapping with the methods exposed by built in actors. So this means that it's slightly low level.
00:15:48.378 - 00:16:09.854, Speaker A: And what I expect maybe happening as a result of this hackathon is that we'll see higher level libraries built on top of these solidity libraries that do kind of like common recipes and do higher level actions using those direct calls into the built in actors. So check out the solidity libraries. That's the URL.
00:16:09.854 - 00:16:40.610, Speaker A: I know that Zach is going to go into this as well after this talk, so I'm very excited to see his demo as well, because he's building with these solidity deployed. So for this hackathon and perpetually we have deployed a network called Hyperspace. This is a developer testnet filecoin up until now had a testnet which was called Calibration Net, but is mostly targeted towards storage providers.
00:16:40.610 - 00:17:01.998, Speaker A: And Hyperspace is a testnet that is built for developers. Before reaching Hyperspace, the Fem team had been delivering almost on a weekly or every two weeks between during kind of like that range. We were constantly deploying new versions of the Fem.
00:17:01.998 - 00:17:16.726, Speaker A: And by the way, the Hackfebb hackathon was running on alpha versions of the Fem. So that was in November, just two months ago. It's crazy to see how it just happened in just two running.
00:17:16.726 - 00:17:31.786, Speaker A: Those kind of like alpha releases were being delivered on a testnet called Wannabe. So if you participated in Hackfebbim, then you were targeting all your development against Wannabe. This hyperspace is a new testnet that is deploying beta.
00:17:31.786 - 00:17:56.766, Speaker A: Quantity Releases. So while Wannabe was deploying Alpha Quality Releases bleeding Edge Hyperspaces is deploying beta Quantity Releases And one key difference is that Hyperspace is a testnet that will upgrade instead of resetting. So we're striving to preserve all of the state and contracts without breakages that you deploy on Hyperspace.
00:17:56.766 - 00:18:21.422, Speaker A: So when there's a new upgrade, when there is a new release brought out to Hyperspace, it will be through an upgrade, and we're actually expecting two of those in the next weeks. We're expecting the Carbonato Three release, which is the feature freeze release, and we're expecting the final release as well, which is the candidate, which is the one that will go into Mainnet. Now, a few resources there.
00:18:21.422 - 00:18:35.698, Speaker A: You've got filecoin. You've got that channel on filecoin, slack. If you have any problems with RPCs, with Explorers, or with the testnet itself availability or whatever, transactions are slow, whatever, just ping us on that channel.
00:18:35.698 - 00:18:59.958, Speaker A: You can very easily add this network to your MetaMask wallet or to other wallets that support the Web Three library via chainless.org. So just go into there, search for Hyperspace and tick include testnets because Hyperspace is a testnet to get that you'll be able to add it quickly. And also there is the status page for Hyperspace testnet.
00:18:59.958 - 00:19:31.710, Speaker A: Two things worth mentioning is that Hyperspace has miners that are very happy to do deal making with you. So if you're a data dows or whatever neat you want to have deals in the network to test against, then they can work with them because they'll be very happy to create deals for you, even though there are already a number of deals in the network. So if you go into the Filfox Explorer, which I'll introduce next, and go into the Deals tab, you'll see all the deals that already exist in the network.
00:19:31.710 - 00:20:02.086, Speaker A: Also this network has miners with different faulting patterns. So these are miners that fail to prove during the deadline and so on, so that their sectors go into fault, are marked as faulty, so that you can test things like lending pools and things that depend on the status and the reputation and the quality of service of a miner. So these are the explorers and hosted endpoints that are available for hyperspace.
00:20:02.086 - 00:20:22.574, Speaker A: You've got lift, you've got Bereps and you've got Phil Fox. As explorers that are currently operating with hyperspace, there are other explorers that we expect will also that are supporting wannabe, but we expect them to transition to hyperspace soon as well. And there are the URLs for the hosted RPC endpoint.
00:20:22.574 - 00:20:39.990, Speaker A: So we've got Glyph serving an endpoint and we've got Chainstack serving an endpoint as well. Cool. So, as I said, tools that we know work well with Filecoin are MetaMask, Remix, Hard, Hat are all working seamlessly with Filecoin.
00:20:39.990 - 00:20:56.302, Speaker A: We are aware as well that Foundry works. We have some tests people have tested with Foundry and the reports are good. But we would like, if you're inclined and work with Foundry, if you encounter any troubles with it, let us know.
00:20:56.302 - 00:21:24.262, Speaker A: Same with Brownie. And having said that, I wanted to kind of like start ending my talk with some highlighting some notable differences that I think as a developer you need to know when you develop for Falcons EVM. So some notable differences with regards to versus the Ethereum EVM is that concerning execution bare value sense.
00:21:24.262 - 00:21:40.662, Speaker A: So this is transfer of values which in the Falcon protocol are mapped to the method number zero. Two smart contracts will not trigger a smart contract logic. So just a bare sent to a smart contract logic that is not a method call, will not trigger and will not trigger any smart contract logic.
00:21:40.662 - 00:22:00.622, Speaker A: This is a small number of cases that this is a feature that is rarely used in the Ethereum protocol as far as we're aware. But it's a difference that you need to be aware of. There is also concerning Opcodes, we've got the call code opcode is not supported.
00:22:00.622 - 00:22:26.860, Speaker A: It has been deprecated in Ethereum in our case, because it's deprecated, we decided not to support it and to drop support for it. And there are some small differences with regards to self destruct behavior which we believe make the behavior safer than it is in Ethereum. Like for example, if a self destructed contract gets funds after it calls self destruct, but before the transaction ends in Ethereum, those funds would be lost and filecoin they're not.
00:22:26.860 - 00:23:00.178, Speaker A: And there are some other Opcodes that behave slightly differently but should be things like difficulty because we don't have the concept of difficulty, things like Coinbase and other things behave differently, but we believe those should not cause any functional divergence. And one big one that I did want to mention is concerning gas. Gas metering and execution halt are performed according to the filecoin gas model and not according to the Ethereum gas model.
00:23:00.178 - 00:23:38.286, Speaker A: So this means, and the filecoin gas model is meant to be updated very in a very agile manner such that it tracks with high fidelity the real execution costs of code. And as well, the FUNCoin gas model actually charges per bytecode of WASM instruction. Sorry, it charges per WASM instruction, which also means that over time the EVM runtime is going to be changing its bytecode as we go through different network upgrades.
00:23:38.286 - 00:24:03.866, Speaker A: It's going to become more optimized, it's going to introduce new functionality, libraries are going to change. So it is not a good idea to hard code specific gas values in EVM smart contracts that you deploy to Filecoin because the gas model is very, very dynamic in Filecoin as opposed to Ethereum. So this is a really important point that I wanted to highlight and a few other so that's the third point here.
00:24:03.866 - 00:24:29.454, Speaker A: Filecoin gas costs are not stable over network upgrades. And the second point there is that gas limits set when calling pre compiled do not apply in Filecoin. So just to almost end this talk, and I'm a little bit overtime, just wanted to say there are some advanced kind of like functionalities that we've added to the Filecoin EVM implementation are filecoin precomputs.
00:24:29.454 - 00:24:32.926, Speaker A: There are four filecoin precomputs. There is resolve address. Lookup.
00:24:32.926 - 00:24:35.258, Speaker A: Delegated address. Call actor and. Call actor.
00:24:35.258 - 00:24:43.206, Speaker A: ID. These are exposed through the Solidity library. So you see an example of that on the right.
00:24:43.206 - 00:24:55.526, Speaker A: They're specified on this fit. If you have any questions about these, we will be adding more documentation in the next days. But if you have any questions about these for now, just ping us on Slack.
00:24:55.526 - 00:25:26.642, Speaker A: And also there is the ability to handle native messages in Filecoin. We have this concept of a method number which is part of the message that indicates which method in the aptor should be called. And in order to handle arbitrary messages sent to Ethereum contracts that carry method numbers, arbitrary method numbers, you need to implement this function in your Solidity smart contract.
00:25:26.642 - 00:25:53.150, Speaker A: Currently, I only expect this to be necessary if you're creating a deal client contract because the market actor will call into the deal client to validate the client the deal proposal through a native call. And there is already a example repo and a template that does this for you. I believe Zach is going to be introducing it.
00:25:53.150 - 00:26:10.462, Speaker A: But if not, ping us on Slack, it's the deal client. So this you could use the code in that contract to handle these kinds of calls that are performed over native calls into your Solidity Spark contract. Cool.
00:26:10.462 - 00:26:19.270, Speaker A: So that's everything from me. Good luck and have the hacks and I'll be on Slack. You've got my Twitter there if you want to contact me.
00:26:19.270 - 00:26:27.240, Speaker A: And I'll also be on discourse. Sorry? On discord, not discourse. Yes.
00:26:27.240 - 00:26:33.510, Speaker A: Thanks, Mel. That was great. So very comprehensive view on everything that's happening.
00:26:33.510 - 00:26:34.580, Speaker A: This should be really fun.
