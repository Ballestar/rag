00:00:06.330 - 00:01:03.780, Speaker A: Hello, my name is Dorothy Roche, I'm from the Opengsn team. We've done lot of gasless and lately we're working on account abstraction with the EF from the EF. And I'm here to describe account abstraction with a specific stress on how to build a wallet. On this framework, I will go with a brief overview of what account abstraction is, what we abstract, security, the architecture of our implementation of EIP four, three, seven, some cool features we think can be built and should be built above it. And then I will go into the SDK we have how to use it, how to use this API. To create a wallet, we do need knowledge both in solidity and ether's API in JavaScript. I hope everybody here has it.
00:01:03.780 - 00:01:50.254, Speaker A: Okay, first of all, before we do account abstraction, as I said, it's doing for security, what is the basic account security? Account security does three things authentication, replay protection, and Dos protection. Those gas payments we are paying the other mechanism used by the system for Dos protection, they're not just fines. And when we say account abstraction, what we basically abstract is all of these. So we have a wallet. A wallet is a contract. And the contract can abstract the authentication. It can do whatever, it like, replace the signature, whether it can use ECDSA, it can use BLS for aggregation or other things.
00:01:50.254 - 00:02:11.880, Speaker A: It can do quantum resistance. We as accounters action don't care what signature scheme is used, except of using different scheme. It can use to change the signer. You're not bound to this signer address. The signer is separate from the account itself. You can use multiple signer and.
00:02:13.770 - 00:02:14.182, Speaker B: Access.
00:02:14.236 - 00:02:39.022, Speaker A: Roles, whatever, and you can do recovery. A lot of features you can do with authentication. For replacement, you still need to use somehow nonce. You can use normal, sequential nonces like our sample. But if you like, you want to use parallel, that is, transactions that can be sent on chain regardless of the order. You can do it also. And for payment, yes, you can do the normal payment.
00:02:39.022 - 00:03:18.810, Speaker A: The account pays for itself. But we also provide an API to let an external contract to perform the payment opening cool features like onboarding, where some external contract application pays for the deployment, or using token paymaster to pay with token for transactions. Briefly, the components we have for account abstraction, first and foremost is the user operation. This is our transaction. The replacement for a transaction structure is user operation. We'll see it later. Then there's a wallet, the account, which is built, of course, from a contract.
00:03:18.810 - 00:03:53.720, Speaker A: There's a second contract we call the deployer. This is the contract that deploys new contract. Again, through the system and the wallet software, the UX. We see either browser extension or other software that shows the UX, the transaction to the end user and let it sign the transaction. It has to know the contract signature, of course, to sign using the right signature. The next component of our system are the paymaster. The contracts that can pay for transaction if they want.
00:03:53.720 - 00:04:44.834, Speaker A: That is, they verify transaction and decide whether this transaction is valid for their own payment system. Bundlers are the nodes that support account abstraction and put these user operations on chain and the entry point. This is the one contract we deliver that executes on chain. The transaction perform all the validation, orchestrates all the system. If we look briefly about how we add it to the system, we have an application that uses the wallet software and send the RPC. But you can see here that account abstraction doesn't come to replace in one shot a normal transaction. Some nodes of the system continue to work with transactions.
00:04:44.834 - 00:05:27.378, Speaker A: Some nodes no normal transaction, but also user operation. User operations come from a separate mempool. So when a wallet sends a user operation into some nodes and bundler, it will get into the network. Yes, we would like all the nodes in the system to support user operations and account abstraction. But the system will work fine even if only part of the nodes support it. If you look at the flow on chain, once a node sends a user peration, there's a single method in enterpoint called handle ops to send a transaction. Transaction goes through four steps.
00:05:27.378 - 00:06:05.090, Speaker A: First step, if needed, optional is to create this wallet. If it has an init code, it will deploy this wallet contract if needed. Once it is deployed, the validate user op method is called. This is the main method. We'll see it later that a wallet has that validate the signature, nons and everything, and pays if needed. If there is a paymaster, the paymaster is consulted whether it wants to pay for this transaction. Otherwise the transaction will be rejected and finally the transaction will be executed on chain.
00:06:05.090 - 00:06:40.750, Speaker A: And as I said, it's called handle ops. It can be a bundle. That's why we call it a bundler with multiple ops in a single request. But I will not stress on this because this is something that a wallet doesn't care about, something that the system does for its own optimizations. If we look at a transaction, the way we see it is that an application how we add account abstraction, how applications start to interact with it. So an application is probably stay unmodified. It uses a wallet, it will continue to use a wallet.
00:06:40.750 - 00:07:36.270, Speaker A: The wallet will be modified, of course. Instead of creating a transaction, it will create a user operation and display to the user with the added fields, ask user to sign it and eventually send it to the node through a different RPC call the send user operation. The node bundler will accept it. It verifies it unlike normal node that knows the signature scheme and everything to check it. It makes the view call to this validate user op. Not directly, but it makes a view call to the entry point to validate this user operation and it added to the mempool later on a bundler what used to be called in the past. A miner will collect all this user permission from the mempool and will create a handle ops transaction and put it on chain.
00:07:36.270 - 00:08:36.066, Speaker A: Okay, let's see what we have in a user operation. User operation first, it has all the fields that you see from a normal transaction. The call data itself, gas limit, gas values, signature and nons. Except that the definition of nonsense signature are completely open to the wallet implementation. Then there are some extra fields that we add. We put the sender since we can't assume this signature is ECDSA, which you can recover the address of the sender from the signature, we have to specify the sender addresses specifically if the wallet is not yet deployed, we have the init code, which is the code that is used to create this wallet. And we have several extra gas fields that we have to add.
00:08:36.066 - 00:09:25.742, Speaker A: We have a verification step, so we have a limit on the gas verification step can take. And there is some gas value that has to account for all the things that you can't check on chain, like call data, costs, et cetera. And finally there is the paymaster information. If there is a paymaster, it will be specified on the paymaster. What a wallet has to define the API. We provide specified function validate user operation in the Iwallet interface. This is the only function we mandate by its name, by the wallet it received, the entire user operation and the request ID, which is basically a hash of this user operation.
00:09:25.742 - 00:10:04.106, Speaker A: This is what gets signed and it needs to validate the signature. An aggregator not relevant for this talk, for a separate talk about signature aggregation, highly relevant for L, two S, not relevant at the moment. And missing wallet funds. This is the top up value the wallet has to pay. If no one else pays and there is no balance that it already has. It has to pay this to the entry point for this transaction to succeed. If this valid user op reverts, the transaction will fail.
00:10:04.106 - 00:10:38.700, Speaker A: It will not pay anything. If it succeeds, then later on the entry point will call the call data. There are two wallet specific functions. We don't mandate their name, but the wallet has to provide them. One of them is nons. To return the current nons value when we create transaction we need to know the current nouns and the other is the method that will be executed from the entry point. So in our sample wallet we call it exec from entry point, which I think is a good name.
00:10:38.700 - 00:11:29.210, Speaker A: It has to have implementations for these two methods. Okay, now I'm going to the client side. I want to create a transaction. I need to have a wallet. But today we don't have a wallet that support account obstruction. So we created a method where we can use an existing injected wallet like MetaMask and still use the account abstraction with it. What we do is we take your Ethos provider, the current provider you have, we have an API to wrap it with the account abstraction specific provider.
00:11:29.210 - 00:12:12.220, Speaker A: When you send a transaction through this provider, it will go through the logic of create a user operation for it and to send it on chain. So if you add this code to your client application, it will go through an account obstruction. One thing that is missing here is that, you see, we have the wallet address. This wallet address exists even before the wallet itself is deployed on chain. The wallet is able to pay for itself, for its own creation. So we need to fund it to send some ETH into this address. Or if you use the paymaster, the paymaster can handle this payment.
00:12:12.220 - 00:12:49.198, Speaker A: But this address, the signer address of our provider, this is the address of the wallet itself. And then I create a contract and call some method. And the method will get called. And the first time the wallet is called, this method will also create the contract. The difference from a normal wallet? Yes, it will take a little more gas because you need to deploy this contract just before making the call. This is the high level API. Underneath this API we provide, we'd call a base wallet API.
00:12:49.198 - 00:13:37.810, Speaker A: This is the API that lets you create user operation. You pass the parameter to it, it will create the user operation. But creating user operation is highly dependent on the contract. So this Base Wallet API, which is an abstract class, provides four abstract methods. How to create an init code for this specific wallet, a method to sign the get nons. This is the method that reads from a vehicle from the onchain value of the current nons, and a method to create the execution function to make this call. And in our sample contract, we have a contract we call a simple wallet.
00:13:37.810 - 00:14:35.050, Speaker A: So we created Simple Wallet API. It uses this base Wallet API and implemented for our contract double for methods. So you create a Simple Wallet API, and then you can call it to create a transaction or unsigned transaction and then send it on chain. The owner we see here also on the base class is a signer. This is the owner of the wallet, which is the class will get called to sign this user operation. Okay, if you have any question, I can go back. Yes.
00:14:35.050 - 00:15:27.932, Speaker A: Okay. When you create a Simple Wallet API, a specific Wallet API, it is for a specific instance, you can pass it here. The address. I didn't specify if it is pre configured. You can pass here also the address of the wallet contract itself. The API, as I call it here is it is not yet created. So I create this object.
00:15:27.932 - 00:16:19.330, Speaker A: I specify the owner the signer and I have get wallet address. I have a method here to get the address of my wallet which will probably the one I will use on the next call. Yes, the sample here shows only the first creation for an already created wallet. Yes, you will specify the address of the wallet obviously also you can have it is possible to add account abstraction support for an existing wallet. Like we have an example how to take Ignosisafe and to add it interface to be called through account abstraction. So obviously if you didn't create it this way you have the address of the wallet. It is not created through the system but once it is created you can use it as your address.
00:16:19.330 - 00:17:39.078, Speaker A: Yes. Both here and the high level API you can specify the address of the wallet sender it is called Sender because sender is the contract that will call the call data. Call data is the encoded call and I will call it on the sender. So I like to call it a wallet. Okay, the same the wallet is the same. Naming is problematic. Yes, like what do you mean change the parameters? I think that people smart contract wallet you can specify, for example yes, you can have whatever you like.
00:17:39.078 - 00:18:16.834, Speaker A: I think the best way to do it is make a transaction that you as the owner of this smart contract make to make some changes. You can have an API that will be used only through entry point but if you want to call it directly for example you don't want to use for one transaction you want that the owner can also call directly this contract. Then you will want that to change owner, change entry point all this function will be callable the same way. So this is the way we suggest to do it. You are the owner allowed to make execute from this smart contract and also make changes on itself.
00:18:17.032 - 00:19:03.662, Speaker B: Yeah. So I think the normal flow for reconfiguring, whatever type of reconfiguration you want to do, whether it's to set a new entry point or even let's say it's a multi SIG and you want to add a signer, then the correct way to do it will be through a user operation. Where? In the call data? You can specify. It's actually a self call. The wallet is calling itself so it will still go through the same validation flow. Your validate user op implementation gets called and then after the wallet says yeah, I accept this sign or I accept this operation and then it will be executed on the wallet. So we don't mandate which there's no interface for what other functions the wallet needs to implement.
00:19:03.662 - 00:19:16.260, Speaker B: You can have an exit function, you can also have configuration functions but you should make sure that they can only be called by the wallet itself or by entry point depending on the model you use, not by anything else.
00:19:21.110 - 00:19:49.040, Speaker A: Any more pressure. It's like let's say one smart wallet contract on one. Then if I want to sell, how can you use mark wallet for what?
00:19:53.490 - 00:20:42.642, Speaker B: Yes, you would have to deploy if you wanted to have the same address, then you would have to deploy. You would have to send the first transaction on each of the chains which would deploy the wallet. If you use the provider, then this is transparent to the user, it just gets deployed. But the caveat is that both of the chains need to have the deployer in the same address in order for the created wallet to also have the same address. Yeah, it's all counterfactual. You can assume that you own the address. You can assume that you own the address.
00:20:42.642 - 00:21:33.410, Speaker B: You can even send assets to it without having the contracts. And then the contract gets created the first time you transact with it. So it's created lazily or optimistically, when you need to start using it, it's actually the way you're supposed to do it because the wallet is supposed to pay unless there is a paymaster involved. So putting the paymaster use case aside, the wallet needs to pay for its own creation. So you need to have some ETH inside the wallet, inside the wallet address before the wallet even exists. You send ETH to the address before after getting the wallet address and then when it gets deployed, the first thing it's going to do is during its validation, it will pay for its own creation. And if it doesn't, then the creation gets reverted.
00:21:34.230 - 00:22:34.238, Speaker A: Yes. And if you want to use it cross chain as a wallet creator, you have to make sure that the deployer contract is the same on all chains and this way it will create the counterfactual address for this signer will be the same on all networks. Yes, we don't mandate how to use it, but yes, it has to be deterministic. As you have said, the wallet can't pay for its own creation unless you as a wallet creator can counterfactually know the address and put funds into it. So if you look at the high level API, you see I use normal methods code. I created our provider, the signer in our provider, it's not a real signer, it's the component that sends it a user operation. But it has a method get address in normal account.
00:22:34.238 - 00:23:31.890, Speaker A: It is the account address which is really the signer. In our case, it will return the counterfactual address that you can use to send funds to but again, it depends on the deployer that will work. Yes, we provide a sample deployer that is counterfactual that creates the address exactly based on the basically it means that the deployer has to create the address based on the current signer. The first signer you are using, you have the signer, the component that will sign this create and the next request of this wallet and based on the deployer itself and this address, we create the address of the wallet. If you later change the address, it doesn't matter because then you will already have the address and you will keep the same address. You don't care the counterfactual address only need for the initial creation?
00:23:35.690 - 00:23:37.560, Speaker B: No, sorry. Go on.
00:23:42.110 - 00:23:45.660, Speaker A: Create two. Yes.
00:23:55.150 - 00:24:53.480, Speaker B: So this is not a hard fork, it's an ERC, meaning that we need some bundler to support it and ideally it would be great if all nodes support it, if all block builders support it, but we can start without it. So we are starting a network of bundlers and we hope it will expand over time because it's going to be profitable for block builders. So when a block builder includes such a bundle in the transaction, the block builder gets paid for it. So block builders are incentivized to participate in this mem pool and include these operations. It won't happen in one day, but it's okay, it can happen over time. I'm sorry, I couldn't hear you.
00:24:56.330 - 00:25:42.490, Speaker A: Right now. Right now there's an implementation of Nethermind that is a full fledged node. It runs currently on the girly network we have our own bundler. It's somewhat limited from a wallet's perspective, it's fully functional, it receives a user period RPC and it puts them on chain. From the bundler's perspective it can be docile, it can be attacked large part of the ERC are made. How to make this network of bundlers resilient our specific bundler? It's simple, but it's not as resilient as it should. We are working on it with Nethermind and others.
00:25:42.640 - 00:26:38.810, Speaker B: Yeah, ideally functionality yeah, ideally it should be part of nodes. Any node that is used for block building has the information in order to also build these bundles. And as nevermind implemented it in their own client and they also implemented it into mev geth. So there's actually a geth fork that also supports this and we hope to see a lot more of those. And another way you can currently run a bundle safely is by having it is by connecting it to Flashbots or to Mev boost. So you know that you cannot be attacked in certain ways because you can use the protection granted by Flashbots to submit the bundle.
00:26:42.430 - 00:27:47.238, Speaker A: Do you offer any censorship resistance guarantee other than a wide network? Like for example charges? I think we provide the sensory resistance that the normal ethereum nodes gets. It's a mempool and nodes take entries from the mempool that are profitable and put them on chain. Anyone? You have actually another layer that if you have a specific application, you can easily run your own bundler. You know you will not attack itself because in order to be protected a bundler has to make view call to make sure it will succeed and they make the transaction. So general purpose bundler cannot trust components not to front run itself, but if it is your bundler, you can always trust it. So you have a way to make always your transaction, but for general use, I believe it is as censorship resistance, as nodes Ethereum network.
00:27:47.274 - 00:28:20.540, Speaker B: Yeah, but you actually have a fallback. But as a last line of defense, let's say all the bundlers decide to send or you and you're not running a bundler and everything. You can always just put a bundle since the bundle itself is just an Ethereum transaction. So if you have an EOA with gas, you can use it to act as a one time bundler and put your bundle on chain. So it is always as censorship resistant as Ethereum itself.
00:28:30.540 - 00:29:19.016, Speaker A: It has some guide. Is it cheap? It has some overhead? Yes, the overhead of the system is 20 or on top of the normal 21K. It's not a big deal. You will lose because it's not a bundle. You will send a bundle of one so you can't split it with others. Or if you do have, you can it's less than a single uniswap operation. This is the simplest way to do it.
00:29:19.016 - 00:29:53.570, Speaker A: It is possible to manage multiple addresses, but it's going to be very difficult to manage. Yes. In order to be questioned, you want to have the same address. Okay. First, it's not a problem for account abstraction itself. It's a use case that you want to support it. We do see ways that you can use the same address on multiple chains.
00:29:53.570 - 00:30:21.950, Speaker A: All it requires that you put the same deployer on all chains and then you have it. This deployer can be deployed using Createo using some counterfactual deployers that are out there or using your account. Like the deployer of Gnosisafe is deployed by their own private key on all chains, so they will always be able to support new chains. So you can use that method. Once you use it, you have a mechanism to have the same address on all chains.
00:30:22.370 - 00:30:47.180, Speaker B: But technically, if you are on chains where you can't have the same address, I can see a use case, for example, for having a registrar. Suppose you have a single tone contract where on the chain where you initially create the wallet, you could have a mapping you could have a mapping that says you can send it from a certain wallet. Okay. Yeah. So you could build solutions around it.
00:31:01.180 - 00:31:39.840, Speaker A: Yes. We added support for a signature aggregation, mostly for BLS, and we have a reference implementation of BLS using it. The idea is that you send a bun, a bundle of multiple user operation, but with empty signature in all of them. As long as they use the same aggregator, you have a single aggregated signature. And there is yet another contract that you have to use, which is called a signature aggregator you interact with. If you want to go deeply, we can talk about it later. Right now it is not deployed anywhere.
00:31:39.840 - 00:31:46.250, Speaker A: There's a sample that works with this, but we didn't make any further progress with it yet.
00:31:47.260 - 00:31:49.384, Speaker B: Yeah, but it is only valid for.
00:31:49.422 - 00:32:26.930, Speaker A: L two S because there is a requirement that the cost of Aggregating a single signature is less. And on Ethereum, the cost of pairing Aggregating, a single signature of BLS, is more expensive than EC recover, so there's no point of using it on any chain with the L One gas limits on L two S, where there is a huge gap between call data cost, which is very expensive, and CPU gas cost, which is very low. There it makes sense very much to be used.
00:32:27.620 - 00:32:36.390, Speaker B: Yeah, I think we are a bit over time, so we can continue to take questions if you want to keep discussing it.
