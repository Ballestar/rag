00:00:07.770 - 00:00:42.862, Speaker A: Welcome to another ETH Global hackathon. I'm Matthew Davis, I'm here with Ceramic, the developer advocate on the team. You're probably interested in Composedb or decentralized data as a whole here in Web Three. So today I'm going to show you how to like get up and running with Composedb. If you've attended ETH Global events before, some of this might be a refresher. But we just recently shipped a developer preview that added even more features to Composedb. Now we can build relations between documents very similar to what we would see in a left join from a regular SQL table.
00:00:42.862 - 00:01:20.790, Speaker A: So I'm going to show you how to get that up and running. I'm going to do a little bit of schema design with you here in GraphQL. And then we'll go ahead and we'll fire up some of the new developer tools like the GraphQL server that we ship along with the command line interface just to help you get up and running with some of the new stuff that we ship. So join me over in the editor and we'll get started. All right, over here in the editor. It's just going to be the editor. I'm going to kind of keep my face out of it, but I'm going to walk you through all of the steps necessary to get up and running with Composedb quickly if you're new, as well as to get the latest feature set if you're not new.
00:01:20.790 - 00:01:55.826, Speaker A: So the first thing we need to do is install some dependencies. So the first dependency we're going to install, and we're going to want to make this a global install, is the Composed DB CLI. But very specifically, we're going to have this tag at Next. We want that tag to be in there. That's going to give you the latest, greatest release candidate. Now this is a release candidate, so it's not suitable for production use and that's very important to keep in mind. The other thing we're going to install is the release candidate for Ceramic itself.
00:01:55.826 - 00:02:37.486, Speaker A: So the Ceramic network CLI at Next as well. So this will give us the latest and greatest of the Ceramic protocol and the latest and greatest of the libraries and necessary tooling needed in order to interact with that protocol. So we're going to go ahead and install those by hitting Enter and PMPM is going to run through and do its job. Now, I highly recommend that you use PMPM as your package manager. It tends to work a lot nicer with the packages that we have out. So now that we have that, we can continue on with the setup. The first thing we're going to need is to generate a private key.
00:02:37.486 - 00:03:09.442, Speaker A: This private key is going to help us create a decentralized Identifier or a did. And to do that, we're going to use the Composedb, which is one of the things that we just installed. So Compose DB did generate private key. Now this private key is going to get blown up at the end of the video, but I am going to blur it either way. But I'm going to show you a couple of shortcuts I use in order to make this easy. So I'm going to go ahead and hit enter. And you'll see now I have a private key.
00:03:09.442 - 00:03:37.086, Speaker A: Although mine's a little blurry for you on purpose, you can then use this key in the next step. What I find valuable is I'm going to create a file in my workspace right now. But you need to be careful when you do this. I'm going to call it Private Key and I'm going to copy and paste my key up there. Now, do not commit this to a repository ever. Not today, not tomorrow. Make sure you save that file.
00:03:37.086 - 00:04:05.494, Speaker A: This is a private key for a reason. So right now this is a bad practice, but it's a little bit helpful for development. So in your git ignore file or whatever, make sure you're ignoring this private key. All right, the next command we're going to need now that we have a private key is we actually need to take that private key and create a did from it. As you can see here's, a private key I used in the past. This is not the one that just got generated. So this command takes an argument.
00:04:05.494 - 00:04:45.782, Speaker A: You could just paste your private key in right there like we just saw my terminal auto filled for me. But you could also use a little command line kung fu here, which is why I stored it in a file and it's a whole lot less to keep track of. I don't have to constantly go back and copy and paste this private key over and over again. But you'll see, now I have a did. This is a whole lot less secret, but still, you don't want to let this get into the wrong hands. This is what's going to be your controller for Data, so make sure you protect this as well. I'm actually going to go ahead and copy mine and store it in a file as well, which you don't need to do.
00:04:45.782 - 00:05:03.870, Speaker A: For this demo, I'm going to name mine Did Key. I'm just going to paste it in there. You don't need to do that for this demo. It might make it easier for you to work with things though, as you're doing some development work. But again, do not commit this to a repository. Super danger. Don't commit this to a repository.
00:05:03.870 - 00:05:44.540, Speaker A: All right, the next thing we're going to do is we need to set an environment variable. You'll see, it's ceramic enable, experimental composedb. This environment variable basically allows us to use the new features that ship with composedb. Now here's the thing is this environment variable needs to be set in the terminal that you launch the ceramic daemon from. So if you set this in some other terminal session and then launch the daemon, it's not going to be able to see that. So it's very important to know. So we can go ahead and we can start the ceramic daemon now by typing ceramic daemon, this will make sure that we get configuration files along the way.
00:05:44.540 - 00:06:08.350, Speaker A: You'll see, it's now running, which is great. And I have some previous models and things in here, so it's actually indexing these. We'll end up removing them as we go forward. So ignore this if you see this. I'm going to go ahead and open a new terminal. Now I'll rename this one just to keep it simple so that we can see what's happening. Ceramic daemon.
00:06:08.350 - 00:06:27.510, Speaker A: Cool. And over here, we're going to go back to being able to run commands. So this is going to be a super useful, beneficial spot for us. So ceramic still running. That's important to know. And now I have a new terminal and a new workspace. So for the Sega organization, I'm going to go ahead and I'm going to create a new folder called Schemas.
00:06:27.510 - 00:07:13.526, Speaker A: And in that folder, I'm going to create a new schema for an address book. I thought it'd be really cool if we could start building an address book. So I'm going to show you how to do the world's most basic address book. But I'm going to go ahead and create a file in here called Addressbook GraphQL. And now I'm able to work on the schema using GraphQL's schema language for my address book. So instead of typing this all out all crazy like, I'm just going to go ahead and copy and paste it in here from a previous run of this. But I'm going to go ahead and say that this is a demo address book.
00:07:13.526 - 00:07:43.402, Speaker A: So I'm going to change this just a little bit so that we can see it. So a simple demo address book. And right here, basically what we're doing is we're naming the schema. We're running a directive on it that's going to go ahead and create a model for us. And in there it kind of has some metadata about where it's going to live. Basically, we're saying any did can have more than one of these. So you could create more than one address book if you wanted for a given Identifier.
00:07:43.402 - 00:08:34.946, Speaker A: And then we've given it a simple description, which is helpful for us when we go to search for it, if we want to reuse it somewhere. And here it's just the name of the address book. So you might want to have a friend's address book or a coworker's address book or whatever. It's just got a property of address book name with a string. And I decided that 100 characters is probably enough for you to name it. So once we have that in place and that file is saved, we can now go ahead and use the composedb CLI in order to create a composite from this, right? And which is how composed DB works. So we'll do composedb and that's going to be composite create.
00:08:34.946 - 00:09:17.680, Speaker A: And as you can see, done this just a few times here. We're going to say that's in schemas and it's address book, right? And then I need an output file. So I'm going to say output. And that output file is going to be ETH address book, really just for the hackathon. And that's a JSON file, right? So we're going to want to make sure that we're including that file extension. And then the last thing we're going to pass in is the did private key. And this is where our command line Kung fu can come in again for us.
00:09:17.680 - 00:10:06.046, Speaker A: And we can just cat that private key file. And this is going to create a composite for us. You'll notice that we now have a new file up here in the left hand side and it is basically a big JSON representation of our GraphQL schema. We can hang on to this for later. We're not going to need it right now at the given moment. Now that we have our address book set up, what good is an address book unless we add entries to said address book? So I'm going to come over here and we're going to create yet another GraphQL schema and I'm going to call it Addressbook Entries GraphQL. And in here is where we're going to start outlining the shape of an entry for an address book.
00:10:06.046 - 00:10:36.358, Speaker A: But the first thing I'm going to do is I'm going to grab the previous GraphQL schema that we have. So I want to get this demo address book into this file. So I'm going to go ahead and do that. We need to add demo here, but you'll notice now the directive being used is a load model. Whereas when we developed this, we said create model. So what we're telling this portion of the schema to do is say, hey, load model. And then we need to pass it an ID.
00:10:36.358 - 00:11:16.626, Speaker A: This is an incorrect ID for what we're using. So the question becomes, well, how do I get that ID? Because without the ID, I can't actually use this at all. The way we get that ID is, again, using the composed DB CLI. We're going to go grab our composites and we want to see the models in the addressbook JSON, which is incorrect for us because we actually named ours something different. So this is the output file. So it's going to be ETH addressbook JSON. And you'll see here we get a field that says ID.
00:11:16.626 - 00:11:50.586, Speaker A: It's right on here. It's kind of tough to highlight, but it begins with KJZ and it's just this random string. So we're going to copy that and we're going to paste that up here into our schema itself. So now we're off to a good start. We are loading that previous model, so we're reusing that shape. So if for any reason the address book itself changes, more fields get added to this. They will become available into these models once you rebuild the composites.
00:11:50.586 - 00:12:32.746, Speaker A: It's not going to happen unless you rebuild the composites, but it's less to actually type in. So the next thing we need to do is let's use that. Let's create our intrigue, because right now, all we did was load that demo address book model. So we're going to name this a demo address book entry. Now, this demo entry has a create model directive. And just like before, it's a list because many entries can belong to an address book on this account, right? And it's a simple demo address book entry. And in this case, we're going to do a little magic here in order to make this work.
00:12:32.746 - 00:12:58.194, Speaker A: So the first thing is we're going to say the address book ID, I just made that up. It could be anything. We could call it the address book. We can drop ID altogether and that's fine. As a matter of fact, let's do that. I think it makes it a little more readable, has a type on it, a data type called a stream ID. And if you use the document reference and point to the model we just created.
00:12:58.194 - 00:13:45.598, Speaker A: So the demo address book, which we have right here on line one, two, three, you're going to say, hey, go get the reference for this document. So basically, we want all the key value pairs that exist inside of the address book. Go get those and bring them into this shape right here and store them as something called address book. And this is great. It would allow us to get just the stream ID, which is basically this crazy string up here, the KJZ L, Six, whatever. They would store that here, which is fine if all you need is a mapping to an ID. But if you want direct access to all the key value pairs within that shape, you need to do this line here, which is create a new property.
00:13:45.598 - 00:14:26.290, Speaker A: In this case, I'm going to call it Book. Rather than Book ID, we're just going to call it Book. And the address book is going to contain both the ID as well as the key value pairs that exist. So we're going to say, hey, that's a demo address book. That's the data type, right? It's a demo address book. And what we really care about is extract all the properties from this model. So this address book string is mapped to this property here, and then we can add the custom fields for an entry, which in this case, the entry name.
00:14:26.290 - 00:14:49.362, Speaker A: So, like, I don't know. Matt Davis right? And then my wallet address and wallet addresses, you'll notice, is also its own shape. So let's go ahead and bring in a wallet address. Now, this is called an embedded type. Notice how it does not have a directive. Up here we have like create model. Up here we have load model.
00:14:49.362 - 00:15:24.580, Speaker A: But for wallet addresses there is no directive. So this type is embedded, meaning these two things are in the same file. This just allows it to be defined in a little bit more readable way. But a wallet address contains an address which is a string and contains a network which is a string. So we can type ethereum, we could type solana, we can type whatever, but basically a list of addresses can exist inside of this entry. Because if I have a friend, maybe I want to add all of their wallet addresses. I could do such a thing.
00:15:24.580 - 00:16:05.394, Speaker A: This is our schema for an entry. So let's go ahead and create a composite from it. To create a composite from it, we're going to use composedb composite create and then that's going to be schemas. And that for us is an address book entry. This time addressbookentries GraphQL. We need to set an output file and that's going to equal ETH address book entries. You could name this whatever you want JSON and that's going to then need a private key to work.
00:16:05.394 - 00:16:35.018, Speaker A: So did private key. And back to our command line kung fu. You can now see why I did this. I don't have to keep track of and copy and paste that did. But you'll see now over here we just got a new file generated which is address book entries. It's just like the other JSON file we had, only now we have build time representations of each of these composites. That's nice.
00:16:35.018 - 00:17:30.038, Speaker A: But now we kind of need to put them together. And in order to put them together, we are going to use the Composed DB CLI to merge them. So let's take a look at that. Next to merge composites, we are going to use the JSON files. So we're going to do composedb composite merge and then we are going to specify ETH addressbook JSON and ETH addressbookentries JSON. And lastly, we're going to supply an output file which is going to be our demo address book composite, or let's actually call it merged JSON. You'll notice there was no need for a private key this time.
00:17:30.038 - 00:18:15.274, Speaker A: And now we have another file here which is the merged version of our composite. So it contains everything we need to know, everything ceramic needs to know, all in one file for these two models to work together. Now that we have them together, let's deploy them over to our ceramic node. We haven't done anything to our ceramic node yet, so let's go ahead and deploy them over. And just like before, composedb is going to be the tool for that. It's going to be composite deploy and then we're going to say demo addresses, merge JSON. And again, no private key necessary for this.
00:18:15.274 - 00:19:10.660, Speaker A: But what is necessary is that we capture the output. So don't capture the brackets, but each of these is the stream ID for the model or the composites that we have deployed for indexing to take place. We need to copy these because we need to now edit our ceramic configuration in order to tell our ceramic node to index these models and pay attention to them. So in order to change the configuration, I needed to move back into my home directory. By default, the ceramic daemon will create the config files. In your home directory there is a folder called Ceramic and it's hidden so it's ceramic. And if we move into that, you'll find a file called Damonconfig JSON.
00:19:10.660 - 00:19:43.764, Speaker A: So let's actually go ahead and open that config file here in Vs code. Damonconfig JSON. And if you scroll down into this file, you'll see that I already have some models in here. So I'm just going to add mine here to the end and we'll save that. So I'm going to add mine here to the end. And now my node is indexing those stream IDs, which is really nice, but it's not really doing much at the moment. So let's go ahead and change that.
00:19:43.764 - 00:20:20.112, Speaker A: Let me go ahead and delete this terminal. We won't be needing it. All right, now that our configuration file has indexing ready to go, we need to come back over to where we were running the ceramic daemon. I'm going to hit CTRL C to stop its operation and I'm just going to go ahead and restart it here and let's just make sure it starts up effectively. You'll see now we have a whole lot more indexing taking place. So we're going to leave this running and it's fully configured to pay attention to our new composites. And now we can move on with actually interacting with these newly created composites that we have.
00:20:20.112 - 00:21:02.620, Speaker A: It's important to note that everything we've done up to this point has been what we'll call a build time step. So this was just preparing the data and our schemas for our applications to use and for us to interact with. We're almost done with that. We actually need to take a step now to go from build time to runtime. And we do that using composedb and we're going to say composite compile. And what we want to compile the composite file, this merged file that we have and we're going to turn that into a runtime file. So for ours, it's demo addresses and we're going to say the output is demo runtime JSON.
00:21:02.620 - 00:21:45.084, Speaker A: And you'll see we now get another file here, this demo runtime and it looks very similar but it just has a little bit of different metadata into it and helps take care of the GraphQL scalers and things that we need, right? So now we have a runtime representation that we need to use. This is what we would pull into our application. We would say like, hey, read this file. This contains all the data you need to access the other files that we've created along the way. And that's exactly what we're going to do. Here. We're actually going to start a server called graphical which ships with composedb, but we need to pass this file to it so that it knows what to look for.
00:21:45.084 - 00:22:17.184, Speaker A: So in order to do that compose DB, we're going to say GraphQL server and that's going to be graphical. A lot of this is going to be very similar. We're going to put it on port, I'm going to put it on a different port. For me, I had some trouble with port 5000. If for some reason you're running something on port 5000, you can change this. It's not going to ruin anything by you doing so. And then we point it to the runtime file which for us is demo runtime.
00:22:17.184 - 00:22:54.172, Speaker A: And lastly we are going to do a did private key like we have been and we can continue using our command line Kung Fu in order to make this easy for ourselves. Now we need to pass in the private key so that graphical uses our did. Without doing that we won't be able to write data down to ceramic. That did is the controller for our data streams. So meet me over in the browser. Let's go ahead and take a look at this thing. You'll see in order to get there, we're going to copy and paste this URL that just came through in the output and it'll take us to a graphical explorer.
00:22:54.172 - 00:23:40.476, Speaker A: Okay, you should see something very similar to this if you have followed along to this far and you've opened that graphical explorer in your browser. So now we can actually start making queries for things. I think the easiest thing to do is actually query to see if we have the demo address book. All right, so we can write a very simple GraphQL query. You'll see that demo address book is what we're calling on. And I'll go ahead and I'll write this query right here for you just so you can see how awesome graphic Hill is with this. If for any reason you don't know what to type, you can just type the word demo because we know that was in our address book and you'll see that we get the demo address book index.
00:23:40.476 - 00:24:35.900, Speaker A: So right now we're concerned with the address book. So let's go ahead and grab that and let's go ahead and say we want the first five of these things. Okay, so show me the first five demo address books that are attached to this account because remember we said you could have more than one and now it's just a matter of standard GraphQL to make this query. So we're going to say edges, nodes and then we can pull the ID which is automatically generated for us when we create an address book. So that's why you didn't see that field in the schema, but what you did see in the schema was the address book name field. So if we come back into this and we look at our address book, you'll see we have this address book name field and that's where I'm getting this from. So we can go ahead and run this query.
00:24:35.900 - 00:25:01.272, Speaker A: Another cool thing with graphical is if you hover over this you can get some documentation about your types. You can come back here, you can look at the schema itself, you can look at different queries. You'll see we have the demo address book index. All this stuff is nice, which is kind of built into graphical. Well right now we don't have anything. It did return a value but it's empty, right, because we haven't made one of these. So let's go ahead and actually make one of these.
00:25:01.272 - 00:25:55.964, Speaker A: And to do that we'll call it a mutation and the mutation is going to be called create new Demo Address book. I know that's a mouthful and we're just going to go ahead and pass in a variable for input and that's going to be a type of create demo address book input. The data type is the exact name of your mutation plus the word input, right. So that's what you need to pass and that needs a fancy exclamation point. Once you have that, we can now call one of the methods that were created for us. We typically get a create method that's automatically created when we do the runtime part of the composite. So we can say we start typing create and you'll see we get create demo address book auto fills for us.
00:25:55.964 - 00:27:00.928, Speaker A: We're going to pass it some input and that is going to be the value of I which is up here, right. We wrote that on line one and from there we can then auto fill all of this and say, hey, the document, go ahead and return us the ID, the address book name after this runs. But now we want to actually fill in this data and to do so down here in the bottom left hand corner you can open this query variables tab and you can paste in an object. So since I is the variable that we need, we're going to go ahead and paste I and then we're going to say the content of I is the address book name is we're going to name this address book ETH Bogota, right? That's going to be the name of our address book. Notice how we're not passing ID that's auto generated for us. And if we go ahead and hit the play button, you'll see we get a document created for us. So now we have an address book, it has an ID of this, a stream ID of this and it has a name of that.
00:27:00.928 - 00:27:29.688, Speaker A: So if we were to go ahead and run that query as before, like we had, so we can go ahead and we can delete this and we can come up here, we'll say query. That query is going to be demo. Address book index. Show me the first five of these things. And then we'll say, edges, nodes. And really, I just want the address book name. I'm not really hard pressed about the ID right now.
00:27:29.688 - 00:28:14.650, Speaker A: And you'll see, we do in fact get an address book returned. Let's go ahead and create an entry. So just like before we named our mutation, we could have named this anything we wanted to. We grabbed the automatically generated scalar for us, which is Demo Address Book Entry input, right? And that's because we have Demo Address Book entry as the name of the shape. So if we come over to this and we look at our schema, it's Demo Address Book entry, right? And that's how we're getting that. So now that we have that, all we need to do is fill in our variables that match the shape. So I'm going to go ahead and paste these in just to be a little bit quick here because this video is getting long.
00:28:14.650 - 00:29:07.240, Speaker A: We did need the ID from the address book that we want to put this in. So let's go ahead and run a quick query to get that. Now we went back to the query, so we're just going to go ahead and query the one. We're going to copy this, and we're going to replace this string down here. And now we can put our other query back in. Okay, so you'll notice that the content is now address Book entry name and an object containing wallet addresses, right? And that's because that was the shape that we had outlined in our schema file over here for a demo address book entry. You'll see, there's address book, there's entry name, there's wallet addresses, right? Each address has an address and a blockchain network associated with it.
00:29:07.240 - 00:29:33.692, Speaker A: So that's all we have going on down here, right? We wrote these in. They're strings a demo entry we'll call this. And if we go ahead and do that now, we're interacting with this composite. But where it gets really cool is when we query this. So let me show you that. And we'll wrap this video up so this query gets a little bit more complex. We're going to go ahead and grab the entry, which is the key here, the address book entry.
00:29:33.692 - 00:30:09.036, Speaker A: Show me the first five of them. And in here, I'm specifying book. And I get to do this because over in our schema, we extracted that address book object itself into a field called book. And this is the real power of relations at the current moment. So we've extracted that in the book so I can get the name of the address book that this entry belongs to, as well as the ID to that address book. And I'm actually going to come down here and I'm going to add ID. So this bottom ID is going to be the ID of the entry, which we see here.
00:30:09.036 - 00:30:49.064, Speaker A: And the top ID is going to be the ID of. The address book that it belongs to. And all the rest of this should just show us very similar to what we already have. So you can see this is the address book object, and it's been embedded into our schema, really simply by just loading it in and then specifying these two lines here to reference that document and then create a relation to that document. So now we can expand that entire document as a part of this object and we get enhanced composability. The rest of this is just data from the entry itself. So that wraps up getting started with relations.
00:30:49.064 - 00:31:04.008, Speaker A: If you guys are here live in Bogota, look me up. Grab me on discord names right here. You can go ahead and ping me on Discord. Let's link up. I'd love to talk to you about your projects and what you're working on. I look forward to meeting all of you. Keep your eye out for the prizes.
00:31:04.008 - 00:31:30.560, Speaker A: There is the equivalent of $5,000 in cryptocurrency available for grabs for prizes for the projects that you build. So Happy Building, hit us up in the discord. If you need help, check out our forum, all the typical spots, but most importantly, try to link up with us. We got a bunch of team members here in Bogota right now, so hit us up on Discord. Try to link up with us. We would love to meet you. And happy hacking.
