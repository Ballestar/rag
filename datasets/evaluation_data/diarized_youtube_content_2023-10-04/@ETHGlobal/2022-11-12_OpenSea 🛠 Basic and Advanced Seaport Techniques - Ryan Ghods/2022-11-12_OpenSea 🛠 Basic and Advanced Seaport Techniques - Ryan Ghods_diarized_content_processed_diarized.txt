00:00:06.170 - 00:00:43.894, Speaker A: Thanks for coming. All right, so I'm going to talk about basic and advanced Seaport techniques. If you guys aren't aware, seaport is a base protocol that Openc has developed and it's our marketplace that can transfer and handle NFTs and ERC 20s. So let's get started. So the way Cport works is you have an order, and an order has two main components to it an offer and a consideration. An offer is what you are offering and a consideration is what you expect to receive back for that order. There are two other components.
00:00:43.894 - 00:01:25.986, Speaker A: One is called a zone and one is called a conduit. So a zone can be an external contract that basically gives an approval or disapproval if an order is valid or not. And that can be used several ways. We'll go in toward the end of the presentation and then a conduit is who you're giving your token approvals to, to help transfer and manage your tokens and the approvals. And the reason that the conduit is nice to have separate than the Seaport contract itself is that Seaport can be upgraded or changed or moved to another address, and then the conduit can still be used for the approvals. So you don't have to reapprove the conduit. If the Seaport contract has changed.
00:01:25.986 - 00:01:55.746, Speaker A: The Seaport contract would just use the same conduit. Two other components of a Seaport order. First is the salt, which is kind of like a randomness factor. But lately what we've been doing is we've been including our four byte domain hash. So openc IO. If you kezak hash it and take the first four bytes, we've been prepending that to the salt. And that helps kind of with order attribution and finding out who is fulfilling or creating the order.
00:01:55.746 - 00:02:28.054, Speaker A: And then the counter is an account level thing. Every order you create will be set to your current counter. And if you increment your counter, it's a way to kind of bulk cancel all the orders that are below that counter. So here's a diagram of how Seaport kind of works under the hood. It's a little bit complicated, but it goes over at the very top. The things we've kind of gone over already, which is the offer and consideration and the zone. And the conduit key, which is a way to reference the conduit, is standardized.
00:02:28.054 - 00:02:50.718, Speaker A: But the conduit key is like which version of a conduit you're using. Not version, but which kind of operator that has created the conduit. So all those go into the order. And then when you have an order, you can do several things with it. You can fulfill the order. You can do a match order, which will go into which is kind of like an advanced kind of matching. You can validate the order on chain.
00:02:50.718 - 00:03:47.218, Speaker A: And what that does is you can pay some gas up front to validate it on chain. And then if someone fulfills that order later, the gas cost to fulfill is actually cheaper. And then you could cancel an order which renders it invalid. When you fulfill or match an order, it goes into this left part of the diagram, which is just kind of a series of contracts that help combine and set up the order for the fulfillment. And then as kind of the last part, the order is verified and the time, the signature, the order status are all verified before the tokens can be transferred. So if you've ever gone to the Cport repository, we have a set of optimized contracts and a set of reference contracts. So if you're kind of trying to learn what's going on, it's nice to go to the reference contracts and see to read the code and it's quite digestible.
00:03:47.218 - 00:04:19.854, Speaker A: The optimized contracts use a lot more kind of inline assembly and kind of little tricks to help reduce the kind of gas usage of the contracts. So, creating Orders so if you've ever created an order on OpenSea, you sign something like this. And this is kind of what we went over. It's all the components of what an order looks like. It starts with the message and the offerer. The offer which in this case it's an NFT. And the ID of it is ID 31.
00:04:19.854 - 00:05:03.094, Speaker A: And then the consideration is the first consideration item is the one that goes to the owner of the NFT, so that's what they're getting paid. And then the second one is the OpenSea marketplace fee. If there was a crater fee here, the third component of the consideration item would be the crater fee payment. And then you have the start time, end time zone, zone, hash, salt and conduit key and the counter which we kind of went over. So validating order on chain is pretty cool because as I mentioned, it makes it cheaper to fulfill later. It also emits an event called order validated on chain. So this is something you can do with contracts.
00:05:03.094 - 00:05:45.190, Speaker A: If you have a contract that automatically wants to list the NFT on Seaport, you can do this. And then other people can understand that the order has been kind of made available to be fulfilled. And then there's EIP one two seven. So that was EIP seven one two, which is kind of manually signing an order, which you've probably seen like with MetaMask, it pops up and you sign it yourself. That's with an EOA. If you have a contract that's signing an order, there's this EIP 1271 which is a standard interface that provides is valid signature and that's how a contract can create an order on seaport. And yes, that allows smart and multi SIG wallets.
00:05:45.190 - 00:06:28.188, Speaker A: If you did order validated that's on chain, you pay a little bit of gas. But if you sent it to the OpenSea API, that would be off chain and it wouldn't cost any gas. And then canceling an order. If you've validated on chain, you can cancel it even if you created the order off chain. In most cases you still want to cancel it on chain because if someone found that order or got it later, they could kind of execute it as they want. And then the other option is incrementing the counter, which is account level kind of nonce all right, fulfilling orders. So the very kind of basic way to fulfill an order is fulfill order.
00:06:28.188 - 00:07:15.212, Speaker A: Fulfiller is a caller and it takes all the offer items and matches them with consideration items. So this is very standard way to fulfill an order. The other type of fulfillment is a fulfill basic order. And what this does is it puts certain constraints on what a basic order is. In this case it's orders that have like a single offer item and have consideration items and they're all in ERC, 20 or native. But what this does is allow us to use the call data in the method signature and access that more so that it costs less gas to use. For batch fulfillment there's fulfill available orders and you supply an amount of orders and you supply the max amount you want to fill.
00:07:15.212 - 00:08:14.640, Speaker A: This is helpful if for example, you're putting in ten four orders and you say I'd like up to five of these, then if certain ones are taken during the processing, then you can still kind of allow the transaction to go through. And with the fulfill available orders you supply a fulfillment array which optimizes for fewer transfers, which also helps on the gas usage. One kind of advanced method that's available on the contract is match orders. And it's not used very often. But what you can do in this case is an Mev searcher who finds orders that they can match together. If there's remaining amount after what you can do is create a consideration item to pay yourself the leftover kind of amounts at the end of the end of the order. If you didn't do that, the amount would just stay with the person who offered it and they would only be charged the amount that the order was matched.
00:08:14.640 - 00:09:35.816, Speaker A: Okay, and then we'll talk a little bit about Zones. Zones are really cool because it kind of allows for pre or post order kind of validation or ratification. So some ideas of zones is like a dynamic NFT metadata zone. And what that could be is as an experimental concept, if you had an NFT that had metadata that if it changes, it changes the value of the NFT itself, then you might want to cancel the orders that are out for the NFT. So if you had a zone that had kind of a registry of knowing when an NFT's metadata changed, then when Seaport calls out to the zone to ask if the order is valid, then it could deny kind of the parameters of the order based on what the contract with the zone itself kind of knows. A compromised NFT registry is another interesting way of creating a zone because a zone, because it has control to say whether an order is valid or not. If you had a zone that had a registry or a merkel route of understanding which NFTs may or may not be compromised, then if it was marked as compromised, then it could deny the order and not allow people to transact for it.
00:09:35.816 - 00:10:30.696, Speaker A: On the marketplace for front running resistance, this is another cool idea for a zone. So if you take a zone and you do kind of a commit reveal where you tell the zone, okay, I'm interested in this seaport order, I want to kind of reserve it. Then the zone would make sure that only that caller would then maybe in some time frame, ten or 15 minutes, only they could complete the order. And then after that period, it could be open again, kind of to the public. But that'd be a cool way to kind of create a more kind of a secure way to use the public mempool but not allow people to get their NFTs kind of snatched in the process. And then another cool zone would be like Oracle based price validation. So if you could find an Oracle that has NFT floor prices or the price of NFT based on its Rarity, then the zone could enforce that.
00:10:30.696 - 00:11:14.132, Speaker A: If the value is too low, it could deny the order being fulfilled. And sometimes that helps. In the case where NFT is stolen and it's listed for much lower than floor just to kind of get rid of it, this could help protect in those kinds of situations. So a little bit of alpha. We're working on Cport V Two, and one of the concepts in there that we're working on now is an order type that is a contract. So this allows us to do kind of more advanced contracts that can handle orders. Right now as we kind of went over, an order either has to be signed by an EOA or a contract.
00:11:14.132 - 00:12:00.900, Speaker A: And in Cport V Two, we're exploring ideas how it can make contracts more powerful to kind of create orders on the fly based on different parameters and custom logic that a contract itself could hold. So yeah, here's some helpful links. The Cport repository, the discussions page is a great place where a lot of people have asked questions. And while you guys are here, if you can't find me, you can post questions in there and we'll try to get to them and help you kind of answer any problems or questions you may have. Cport JS is also a great kind of accessory. Utility Library has a lot of helpers if you're working in Node or JavaScript. It has a lot of things already built out like driving order, hashes and things that can be helpful utilities.
00:12:00.900 - 00:12:23.612, Speaker A: There's a Cport order validator as well. It's an on chain contract that you can call out to that can do that does like, almost 50 to 60. Kind of on chain validations for balances and approvals that we recommend. Kind of checking out. It's pretty cool. So, yeah, thanks for attending. Love to open them up for any questions.
00:12:23.612 - 00:12:28.840, Speaker A: If you guys have any about Cboard or building on it. And yeah, bye.
