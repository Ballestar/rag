00:16:54.410 - 00:17:00.160, Speaker A: Feel like the flashlight's coming. I feel like a deer in headlights right now with this one, but okay. All right.
00:17:00.160 - 00:17:04.926, Speaker A: Do I start? Camera rolling. Just kidding. All right, great.
00:17:04.926 - 00:17:12.730, Speaker A: It's a pleasure to be here. I guess this is my first east global, so I'm not sure what to expect. There's no code over here, but this is a business, I guess, workshop.
00:17:12.730 - 00:17:20.854, Speaker A: I'm going to talk about two things. One, I'm going to talk about how to leverage apecoin dao. And then we're going to have a little announcement about the prize pools later on.
00:17:20.854 - 00:17:33.478, Speaker A: And also I want to explain about the Asia opportunity, which I think is relevant since I'm finding that in this part of the world, people do not know the opportunity that exists in Asia. And there's a lot that could be done here. All of you are building great projects.
00:17:33.478 - 00:17:44.074, Speaker A: You want to raise money, you want to go and get new audiences. Asia is where it's at, we think. So let me just very quickly, I'm actually wearing an apecoin hat today.
00:17:44.074 - 00:17:51.978, Speaker A: I used to be a special council member. But very quickly, just telling you a little bit about myself and the business. We're very focused on digital property rights.
00:17:51.978 - 00:18:02.500, Speaker A: We've been trying to advance Web Three for a while. We've done over 450 investments in the space. So, yes, if you are interested in getting some money for your Web Three projects, you can come talk to me and my team later on.
00:18:02.500 - 00:18:08.058, Speaker A: And we're one of the sort of biggest investors in the space. All right, let's get into it. Asia.
00:18:08.058 - 00:18:12.066, Speaker A: I'll start with that first. So. South Asia, southeast Asia.
00:18:12.066 - 00:18:23.850, Speaker A: North Asia represents over 54% of the entire crypto market today. And it's really growing very fast when it comes to total volume of trade. India, Thailand, Vietnam, singapore are top.
00:18:23.850 - 00:18:32.250, Speaker A: And Japan. Obviously, Korea and Hong Kong are coming along very quickly. And again, they represent actually the majority of crypto trading.
00:18:32.250 - 00:18:46.286, Speaker A: One of the reasons why Asia is so big in crypto is actually it's a digital first culture. So you can't really see the screen quite well here. But what you see here are basically two beggars, actually all beggars in China, basically beg with WeChat pay.
00:18:46.286 - 00:18:54.174, Speaker A: So instead of asking for cash, they ask you to put money in their digital wallet. And that's been going on basically for years and years and years. And so this is not unusual.
00:18:54.174 - 00:19:13.986, Speaker A: So the culture is so digitally first that everything is very natural to basically go into sort of a crypto culture. As a result, Thailand is only top in terms of hours spent online. But here's the opportunity.
00:19:13.986 - 00:19:33.802, Speaker A: Asia represents about 54, actually more now percent of the world's global internet, which obviously is critical for people doing stuff on the web. There's more than half of the world's gamers are in Asia at this moment in time, and it's growing rapidly. But in terms of adoption, still there's only 67%.
00:19:33.802 - 00:19:49.514, Speaker A: So roughly two thirds of the sort of internet penetration in Asia. So this is in contrast to the US for instance, or Europe which has almost full saturation. So you have a market that basically is already the biggest market when it comes to internet penetration and crypto adoption.
00:19:49.514 - 00:20:24.554, Speaker A: But like in places like Vietnam, it's actually 70% of the nation. But when it comes to actual growth path, it's not just the fact that people are adopting crypto, it's also that people are experiencing basically the internet in a digital first culture and nature for the very first time because they're still being onboarded. And one of the other areas of onboarding also comes from the fact that payment systems in Asia actually have a real good sort of crypto rail necessity because of the fact that there's a big portion of people in Asia that remain unbanked because they're basically not making that much money.
00:20:24.554 - 00:20:46.366, Speaker A: Whether they're in the know, they get the stories know. If you heard about Axie Infinity, many people signed up basically for crypto wallets over there to play the game, but they didn't have a bank account, they were technically unbanked, they didn't have any financial education, actually don't even have a bachelor's degree, never went to college. And here they are basically buying crypto and basically playing a blockchain play to earn game for example.
00:20:46.366 - 00:21:02.514, Speaker A: So that sort of represents that opportunity in places like Southeast Asia, which continues to grow rapidly and also in this year and the coming years, pretty much all of the global growth is going to come from the region. So this is a macro trend. So it's not even just a specific crypto trend, it's a macro macro trend.
00:21:02.514 - 00:21:18.890, Speaker A: Asia is going to represent roughly 70% of global growth this year and continue to grow from that. So again, it's a market not to be ignored, but there's some other things that are relevant to think about which is also the regulatory climate. Unlike there's been a lot of focus on looking what the US is doing.
00:21:18.890 - 00:21:37.330, Speaker A: Obviously the Ripple case is good news for most people, but generally speaking, unlike the US, asia's regulatory climate for crypto and digital assets has become much clearer and much more friendlier. So for instance, in Japan you can actually do a legal IEO. That's approved by the JFSA, which is a financial regulator.
00:21:37.330 - 00:21:50.770, Speaker A: You can actually do that through a proper process. It's probably the only country or one of the few countries in the world where you can do that outside of Singapore. Hong Kong has been very forward as well in terms of basically crypto regulation.
00:21:50.770 - 00:22:09.878, Speaker A: You can basically get exchange licenses, you will have clarity in terms of retail trading, which I'll go into some further details and I'll explain a little bit why that is the case. But even places like Japan have made Web Three and the Metaverse part of their national agenda. So you have a very friendly regulatory climate on top of friendly user adoption versus other markets.
00:22:09.878 - 00:22:18.282, Speaker A: So again, I urge people to take a look at that. So these are some of the major hotspots. I'll make this presentation available online, so you can have to sort of take notes.
00:22:18.282 - 00:22:33.438, Speaker A: But I think the one thing to note here is particularly for Hong Kong and the reason why I think Hong Kong is so valuable now is because it's not just about what Hong Kong does. It's really about China in some place, which I'll explain later. Hong Kong has now put together a Web Three task force.
00:22:33.438 - 00:22:50.406, Speaker A: That task force comprises of business leaders in the industry, including myself, as well as people from government, whose main job is to basically push Web Three and metaverse development. In Hong Kong, there's also a marketing budget, it's about 50 million. Hong Kong, it's about six or $7 million.
00:22:50.406 - 00:23:10.490, Speaker A: So if you want to make an event, if you want to sort of promote stuff in Web Three, you can actually get money from the government to do that specifically for Web Three. Again, this is the other thing which is interesting. It's probably the only regulator in the world that has sent a message to their banks and said you need to do business with crypto exchanges.
00:23:10.490 - 00:23:30.414, Speaker A: So just imagine the US. Treasury doing something like that, sending a message to Citibank saying, hey, you got to do business with Coinbase and stuff, right? Not going to happen, probably. But in Hong Kong, the HKMA basically went out and sent messages to basically bank of China, HSBC and told them you need to basically support crypto businesses in Hong Kong.
00:23:30.414 - 00:23:54.314, Speaker A: So again, first, the HKMA also issued, which is the monetary authority also issued the first tokenized green bond. So, just to demonstrate just how aggressively they're trying to push Web Three, meaning that if you still can't open a bank account wherever you are in the world as a crypto business, you can try Hong Kong. Okay, so outside of licenses, there's crypto ETFs, you can actually buy Bitcoin ETFs.
00:23:54.314 - 00:24:07.910, Speaker A: Basically at HSBC today, you have basically a retail trading framework. There's now 16 tokens that are available for retail trading in Hong Kong. More importantly, though, there's a very clear way in which your tokens can trade in crypto.
00:24:07.910 - 00:24:30.966, Speaker A: So, unlike the lack of clarity that you might have in other places around the world, as long as the tokens are listed in two major indices, you can basically apply for essentially having the token be traded for retail trading in Hong Kong, for instance. And Hong Kong is the fifth or 6th largest financial sort of, I guess, center in the world. So again, we're not talking about a small place that's adopting this.
00:24:30.966 - 00:24:42.918, Speaker A: This is a major, major sort of area that's adopting this. So we think this in the next year, a lot of growth will happen from there. Now, why is this relevant? Well, Hong Kong has always been the financial intermediary for China.
00:24:42.918 - 00:25:15.558, Speaker A: In the same week when these rules came out and when retail trading was allowed in Hong Kong, which was in June, beijing released a white paper for basically Web three innovation and Development, which is basically a strategy paper on web three in which they actually specifically said that Web three is the future of the Internet. So Beijing is putting quite a bit of capital and money in to promote, basically blockchain and Web Three development, which is very confusing for a lot of people because people have sort of conflated the issue of China as, oh, aren't they anti crypto and so on. We can maybe discuss this a little later.
00:25:15.558 - 00:25:59.518, Speaker A: But I think the other thing which is relevant is that for those of you who know about China, CCTV, which is basically like the national broadcaster that every Chinese person sees in China, basically started talking on public TV in that same week how you can buy Bitcoin in. You know, what does it really mean? Well, I mean, I think one of the big trends here is about the fact that China is looking to promote, we think, this whole digital asset space, but through Hong Kong, in the same way that Hong Kong has always been the financial intermediary for China, for foreign sort of stock purchases, for foreign exchanges in terms of currencies and so on. So we also think that that becomes a mechanism where ultimately people from China will be able to sort of participate in the digital assets market, but through Hong Kong.
00:25:59.518 - 00:26:11.894, Speaker A: So that's, again, where we think a lot of the growth will happen. And of course, another big thing is that Apefest is coming to Hong Kong in November. So if you haven't made plans to come visit, go check it out, since we're going to talk about Apecoin very soon.
00:26:11.894 - 00:26:34.686, Speaker A: And that's also the same time when we have basically Fintech Week, which is the week in which you have a lot of general sort of Web Three activity happening in that time. So expect a pretty good time if you can make it out in Hong Kong places outside of talking to companies like us, you can go to invest Hong Kong, they'll give you support. Sometimes they pay for your tickets for you to come to Hong Kong to do stuff.
00:26:34.686 - 00:26:46.434, Speaker A: So again, they're trying to sort of help you come there. It's probably one of the most active governments right now that are trying to promote Web Three. So this is your opportunity to take advantage of if you're so interested.
00:26:46.434 - 00:26:54.454, Speaker A: And of course, there's accelerators in Hong Kong and so on. I won't go into the details of this, but again, if you want more information, I'm happy to share that later. Now.
00:26:54.454 - 00:27:05.446, Speaker A: Why is Asia so friendly to Web Three? I think this is important when we think about product market fit and about sort of philosophy a little bit. So I'm talking about this here in the context of Asia. This is an example of Korea.
00:27:05.446 - 00:27:23.774, Speaker A: But the same is true for China, for Taiwan, for Southeast Asia about 40 or 50 years ago. South Korea, which you all know today because of BTS and Kpop and all that type of stuff, was actually a nation that was poorer than North Korea. It was one of the poorest nations in the world.
00:27:23.774 - 00:27:43.186, Speaker A: But today it has a GDP of probably the twelveTH or 13th largest country in the world. And why is that? Well, that story is the same story for most Asian countries during those decades, because they adopted property rights. They embraced a form of, I guess, democratic principles and they basically went capitalist.
00:27:43.186 - 00:27:56.410, Speaker A: And that was a very big deal. So in living memory, for instance, my parents generation, and for most, let's call it Asian, call it Chinese or Korean people or Southeast Asian, our parents didn't have anything. They didn't own anything.
00:27:56.410 - 00:28:06.054, Speaker A: They lost their property, they didn't have any rights whatsoever. And they saw the benefits of capitalism. So even if there's inequity they actually generally are big believers in capitalism.
00:28:06.054 - 00:28:10.942, Speaker A: They see it work. It doesn't matter if this person makes more money than the other person. Broadly speaking, we do better.
00:28:10.942 - 00:28:37.958, Speaker A: This is important to understand because that means the framework in Asia is they're pro capitalists, which is how we look at crypto, is a kind of digital capitalism. The other thing is, because of the last 30 or 40 years in Asia, there's been a lot of instability this has caused because of civil war, because of the Cold War, because of the Vietnam War, the Korean War. All these things have caused a lot of immigration from these places to go outside of the world, to look for better pastures, but at the same time also a lack of security.
00:28:37.958 - 00:28:47.098, Speaker A: So that means they're all looking for ways in which they can enhance their self sovereignty. So one of them is to buy real estate overseas. That's a very classic, I guess, Chinese thing to do.
00:28:47.098 - 00:29:04.266, Speaker A: But the other thing is also to have sort of other forms of self sovereignty which crypto starts to represent. I can hold my own assets, self custody of my digital assets, the government can't take it away. These things start to become very important and also payment rails that I can control as opposed to being gated.
00:29:04.266 - 00:29:19.794, Speaker A: So again, that's another reason why crypto is so popular. This is in stark contrast to what we see in places like the US. For instance, which over the last 30 years has moved away from this pro capitalist narrative, which is still America, could still be called, I think, the center of capitalism.
00:29:19.794 - 00:29:44.570, Speaker A: Except for in the recent study, I think it was a Pew study showed that Americans under the age of 30 majority started to skew socialist, whatever that might mean to them, because capitalism hasn't worked for them. And so we see this effect. So for instance, in Asia, all major gaming companies are pro NFT, whether it's Square, Enix, whether it's Krafton, the makers of PUBG Nexon, Netmarble, US, whatever.
00:29:44.570 - 00:29:57.854, Speaker A: All these companies are all pushing NFTs and Web Three and digital ownership, whereas in the US. It's the opposite, right? Many of the gamers are rejecting it. And we think it doesn't come from a perspective of sort of it's a very emotional response.
00:29:57.854 - 00:30:13.314, Speaker A: Their rejection on sort of crypto is more about a rejection on capitalism broadly, on the sort of idea that you can make money playing games. That seems wrong. And it seems wrong that someone should be able to sort of pay their way into it, which is very different from the Asian perspective.
00:30:13.314 - 00:30:42.666, Speaker A: So the thing we sometimes say is that the American dream is more alive and well in Asia than it is in the US. So I think it's again an area to look at for growth and opportunity. And I think the final thing I'll say about Asia before I start talking specifically about Apecoin is obviously there's an ecosystem there, you can raise money from it, there's very active VC investing, but also that influence that Asian, let's call it, I guess, capitalist sort of property rights narrative has spread through the Asian diaspora.
00:30:42.666 - 00:31:06.530, Speaker A: So we're in France, so the example here would be there's more overseas Chinese as in Chinese diaspora than there are French citizens in France. So it just gives you an idea of just the scale and size. And of course there's many more Indians and Japanese and Korean and they all sort of embody that same they all embody those same values and they communicate back with their sort of families back in their countries and so they create that bridge.
00:31:06.530 - 00:31:27.360, Speaker A: And it's therefore not a surprise that from a ratio, it is those same communities that also have a higher proportion of crypto ownership, or NFT ownerships, for instance. Asian Americans have a higher proportion of NFT ownership, for instance, in crypto ownership than, let's say, other groups as an example. And again, it comes back to sort of that cultural past that I just described before.
00:31:27.360 - 00:31:33.562, Speaker A: All right, so that's Asia. Pay attention in case you're interested. Now let's talk about Dows.
00:31:33.562 - 00:31:49.186, Speaker A: I'm going to focus on Apecoin Dow, but I just wanted to illustrate why Dows are so relevant for this. It's not just maybe because you want to build a Dow, but also because Dows are funding avenues for your businesses. There's about 160 active Dows or so, give or take, in web three.
00:31:49.186 - 00:32:05.302, Speaker A: And the collective amount of money that is under the community governance of these Dows is somewhere between twelve to $14 billion, which is very significant. So could look at raising money for your business in a classic VC route. You can ask your mom and dad too, of course, or you can try a Dow.
00:32:05.302 - 00:32:29.566, Speaker A: And so I'm here to sort of give you a little bit of sort of insight as to in the case of Apecoin Dow how you could possibly raise money from them and budgets have been approved in the millions of dollars but also in the tens of thousands of dollars. And later on we'll hear about a prize of $10,000 worth that you can earn but you could get so much more if you are able to sort of sort of appeal to the Apecoin Dow. All right, so am I out of time? Oh, shoot.
00:32:29.566 - 00:32:31.870, Speaker A: Damn. All right. Okay, go faster.
00:32:31.870 - 00:32:45.586, Speaker A: So working group structure basically you've got the Special council I won't name them all out there. The role of the special Council is basically to vet essentially many of the proposals that come through. But maybe I won't talk too much about the governance and I spent too much time on Asia.
00:32:45.586 - 00:33:00.202, Speaker A: But let me just explain to you maybe the process. When you want to make a proposal, you basically submit an idea to the Dao. There is basically in discourse a proposal where you basically discuss it with a community that can be very active, which I encourage you to take a look at.
00:33:00.202 - 00:33:13.242, Speaker A: That then enters into a draft stage. The working group basically helps you with the drafting and then basically it goes to a vote in which Apecoin holders basically vote to basically get a proposal approved. I would say it's a little bit like political lobbying.
00:33:13.242 - 00:33:17.982, Speaker A: These are the proposal categories. You can go to basically Apecoin.com and learn more about it.
00:33:17.982 - 00:33:44.134, Speaker A: There's multiple allocations and multiple sort of missions. One of the things that is really important is when you go and apply for funding in this Dow, you have to ask them how does it benefit the Dao ecosystem? Now this, I think, is the one point that's not often discussed and not often written about, which is that if you want to basically get a vote passed, you do have to basically engage the community. You do have to basically not talk about just individuals but also address the delegates.
00:33:44.134 - 00:34:03.150, Speaker A: And the delegates are the ones who are basically like your quasi super PACs, basically of Apecoin. And that's something that means you have to engage with them and talk to them. And essentially I see it as no different than you basically appealing to venture capitalists except in this case you're going to different delegates and appealing to the end to communities to vote for your proposals.
00:34:03.150 - 00:34:14.830, Speaker A: Okay, so I'll just skip through this. This is an example of sort of something that was approved in the Apecoin Dow. This is basically thank Ape.
00:34:14.830 - 00:34:32.290, Speaker A: So when you end up doing something in the Apecoin community, you get rewarded activities and you get rewarded in Apecoin to sort of increase engagement. Here's something that's a little bit more tangible. It's an accelerator that was approved for half a million dollars in funding where if you were building something with Apecoin, you can basically get half a million.
00:34:32.290 - 00:34:49.694, Speaker A: They were funded with money to basically fund and accelerate a program that would basically support Apecoin projects, or projects that utilize Apecoin, for instance. And of course, we have a proposal that was also approved that basically allows Apecoin to be here at ETHGlobal, for instance, for marketing and so forth. Yeah.
00:34:49.694 - 00:34:56.386, Speaker A: So there's many ways to get involved at Apecoin dial. I know that I'm short on time, right? Yeah. So we moved to Q A.
00:34:56.386 - 00:35:15.394, Speaker A: So I'm apologies for not sort of spending more time on Asia than on Apecoin, but maybe do you want to announce quickly the prize? Yes, we're giving away $10,000 in prizes. There's two different categories. So one is the best use of Apecoin and adapt.
00:35:15.394 - 00:35:25.642, Speaker A: And so think about Apecoin as more like a consumer application. I mean, you talked about Asia and payments a lot. Like, anything related to that, anything related to consumer games, in game currency, things like that.
00:35:25.642 - 00:35:41.742, Speaker A: And then the second category is something that contributes to the ethereum ecosystem, but in a way that also benefits NFTs and the Apoin community. So think about that as like 6551 NFT ownership or account extraction. Four, three, seven, anything related to security, things like that.
00:35:41.742 - 00:35:48.930, Speaker A: So each category gets $5,000. We're giving away $5,000 in each. And so you can apply to either.
00:35:48.930 - 00:36:00.526, Speaker A: And then just a little bit really quickly on just the technical stuff around Apecoin. So it's an ERC 20. There's a test token on Girly in order to qualify for the prizes.
00:36:00.526 - 00:36:11.218, Speaker A: If you do use Apecoin, you can use it on Polygon, you can use it on testnet. You don't have to deploy it on main net right now. And there's like maybe 5% who are actually contributing, whereas the rest of them are just like writing GM once a day.
00:36:11.218 - 00:36:34.458, Speaker A: And that's pretty much well, thankfully, in the case of Apecoin, I would say that the community is quite active. We just finished our last special council election where I basically stepped down and we had a few new members, two new members join, and we've had almost, I think it was 25 to 26 million sort of tokens voted, which is today's equivalent value of about 50, or at that time, $60 million. So it's still quite active.
00:36:34.458 - 00:36:53.330, Speaker A: Part of it has to do with the fact that I think Apecoin has become quite mature in terms of its working group structure. So when I gave you this example here, you can see that there's an actual sort of community structure which isn't just upheld by essentially a special council group, which you could almost consider like a leadership, which in the case of special counsel, it is not at all. But you have working group levels.
00:36:53.330 - 00:37:12.202, Speaker A: At these levels, you have different teams. The metaverse team and the treasury team, they're actually elected members. So the way I think of a successful Dao is the more you create more democratic rails, as in you force people to say, look, I'm electing this person in this position to run in a certain way they become campaigners of that as well.
00:37:12.202 - 00:37:21.806, Speaker A: So they engage the community. I think one of the problems that a lot of Dows have is they don't have actually that much, let's call it true distribution shall we say. Right.
00:37:21.806 - 00:37:35.918, Speaker A: There's often criticisms that some of these Dows have sort of a few holders that can control the vote for instance. Well at that point it's not really a Dow. It may appear to be like a Dow but it's actually not that different from, I guess some people call themselves democratic but they're not truly democratic.
00:37:35.918 - 00:37:49.174, Speaker A: So I think it's the same thing and people become cynical. And I would say that for Apecoin in the beginning people were cynical but if you take a look at for instance, the delegates here as an example, this is just the top. That means there's a lot more and there's a lot more voting power.
00:37:49.174 - 00:37:57.382, Speaker A: Even if you look at the special council last election, 25 million tokens were voted. The top delegate with Mochavers is about 1.7 million tokens.
00:37:57.382 - 00:38:07.978, Speaker A: Yeah sure it's a big chunk, but it's still a very very small chunk in comparison to swinging sort of that vote. So I think that is important. So I think people feel like they have a voice.
00:38:07.978 - 00:38:27.486, Speaker A: I think that's the most important thing. I think in any democratic structure, which in the case of a Dao would be the same. Finally of course it helps that you have a billion dollars of potential funding in a Dao, right? So if you want to raise money from the Dow then there's a good incentive to do so and the community turns out to be quite careful.
00:38:27.486 - 00:38:43.318, Speaker A: This criticism that oh if you don't give it to professionals they're just going to go throw money at parties turns out to be all bullshit. Which is what we thought anyway, right? In fact the community is very vigilant. Proposals that are trying to raise money that are ridiculous never get approved for instance.
00:38:43.318 - 00:38:53.820, Speaker A: So it's just an example that actually sort of wisdom of the crowd does work very well when applied correctly. Okay, that's all we have time for. Thank you yat, thank you.
00:38:53.820 - 00:43:11.750, Speaker A: If you're going to stick around for the next presentation, we'll begin in five minutes. Otherwise thanks for joining us for this one. Hello.
00:43:11.750 - 00:43:27.660, Speaker A: Okay, first of all, big thanks to all is Global Crew. Let's appreciate them for fantastic job to putting this all together. And my name is Vadim, I'm from NIR and I'm an engineer so I will have some live coding session in the end.
00:43:27.660 - 00:43:45.292, Speaker A: But today I came to present the Bos which is blockchain operation system. I will show how it works, why will you use it and actually how it works. So from the beginning we're all here because we believe in the same principles.
00:43:45.292 - 00:44:27.390, Speaker A: We want users to have their own data, actually their own identity and obviously we want them to have their own decisions. But right now we are quite far from this point because most of our for example laptops or software applications are running on a large company servers and actually data belongs to those corporations and we are using bank accounts every day and similar as money is sitting in the bank and banks are doing whatever they want with our money. Similar rush corporations are using our data themselves actually.
00:44:27.390 - 00:44:54.200, Speaker A: And the problem that they have these siloed identities for example the reputation you built in one application does not translate the reputation in another application. In this case for example Uber reputation and Lyft application has no link. Corporations can remove features, they can increase some fees or maybe block your account, block your data, remove your social graph.
00:44:54.200 - 00:45:54.936, Speaker A: Every day we have some news about new censorship corporations like Twitter Reddit, they increase some download rate limits, remove API functionality and speaking about data leaks because all the data is sitting in one place and human eye making mistakes, there are a lot of leaks and some potential problem of that data leaks. So here well here actually to fix this problem, most of those problem we are doing crypto stuff, we are building some amazing functionality and I have an example of bingo game. So if you have like three terms from this bingo game in your pitch doc then probably you will have some success in token sale or maybe you will attract some liquidity actually you'll have some profit.
00:45:54.936 - 00:46:26.070, Speaker A: But our final target is mass adoption and there is no any clear plan how to bring actually big amount of people to our web three applications. So usual plan is like we are just building cool stuff then dot dot, dot and then figures out that at one point we have millions or billions of users and web three until now has a lot of problems. We have similar problems with web two is disjointed experience.
00:46:26.070 - 00:46:47.580, Speaker A: Our apps and networks has different identities and as far as we introduce new technology, new layer ones, new side chains, new roll ups, it became more complex. Nobody knows how much accounts they have, how much wallets they have. For sure there is no any direct link between different chains.
00:46:47.580 - 00:47:10.630, Speaker A: Applications are not really decentralized because most of them are using centralized services. Imagine you have something like an asset management system and you connected a lot of wallets there and obviously everybody who controls this service, they can create this link. What account do you own and you don't have any access to this data actually.
00:47:10.630 - 00:47:39.084, Speaker A: And the biggest problem from my understanding is the lack of common services which we used to have in web two. For example search. There is no any simple way to have to search on chain applications right now using on chain services and for example notifications like if you want to find what events happens with your assets, with your identity, you don't have this option.
00:47:39.084 - 00:47:47.170, Speaker A: But imagine say. Twitter without search and notification there is nothing to do there. But this is how web three works right now.
00:47:47.170 - 00:48:21.720, Speaker A: And newer is representing now blockchain operation system which is common layer for browsing and discovering this new open web experience. And actually it's compatible with any blockchain. So Nier for a long time is doing not only like block sales, it's blockchain itself development, it creates a lot of features to enable simple onboarding.
00:48:21.720 - 00:48:53.860, Speaker A: Now we have this fast OS, we have Login with Biometrics. Nier prepared a lot of developer tools to create really versatile applications and make it simple. And now we introduce this new idea of discovery layer which will give access to make search and find new applications and attract user by giving them some chat and social functionality notifications.
00:48:53.860 - 00:49:10.330, Speaker A: And if you will see the scheme bring the best part from web two and web three. Combine them together and build this as a fully decentralized in a fully decentralized way. So this is how it works actually.
00:49:10.330 - 00:49:33.196, Speaker A: It has base layer of blockchain which is security layer, data layer and this is where near blockchain or Ethereum or any other blockchain sits. On top of it we have a data platform. Our engineers created a lot of we brought together different data sources.
00:49:33.196 - 00:50:26.880, Speaker A: Think about it like combination of infuria different indexer databases and they are aggregated in a way which be easily accessible by any application uploaded on chain. And on top of it new concept which is discovery layer instead of siloed websites it has fully composable components written in a very simple language and they are giving the full web three experience right now. Why Neur is doing it because it has very fast finality imagine some social network where you have to wait like 12 seconds until your like will arrive to the destination is not really realistic.
00:50:26.880 - 00:50:52.836, Speaker A: New York has Sharding so it can really scale to billion users and we really have amazing functionality about account model with these functional access keys, with metatransaction, with guest accounts. I will show it to you and probably you will be impressed. This is the concept how it works overall.
00:50:52.836 - 00:51:08.732, Speaker A: So there are a lot of gateways where you can access this bos data. You can do it through the browser. For example near the official website of near blockchain now is this bos gateway.
00:51:08.732 - 00:51:41.876, Speaker A: So every data, every piece of data which you will find there every document like developer tutorial or maybe help or something all of it serves from the chain. There are partnerships with different wallets, different browsers. For example in a browser you can put like coma and some component address that will load it for you and it is actually MultiChain as you can see here, you can connect any account like there is a data abstraction layer.
00:51:41.876 - 00:52:08.740, Speaker A: User will even don't recognize which blockchain is he using. But if he has any wallet integrated injected into his gateway he will be able to read his data and obviously send transaction to the chain. Bos handles all this infrastructure management, handles identity routing.
00:52:08.740 - 00:52:23.480, Speaker A: It integrated popular libraries to give the developer simple developer experience. Now, I have a screenshot of Neur.org right now.
00:52:23.480 - 00:52:40.510, Speaker A: So it has as you see, different social mechanics. I made these screenshots several days ago and if you will see on the right panel I have a bit different design just because I composed myself like a no code experience. I just put some videos which I prefer to have there.
00:52:40.510 - 00:53:07.796, Speaker A: We have quite a lot of users right now, quite a lot of components. So this is near based experience but I will show now Ethereum based development on both. So, great part about it, it has a lot of GitHub like functionality because you can see the code, the source code of every component which you see and which you use.
00:53:07.796 - 00:53:27.484, Speaker A: You can see the name of user who uploaded it, when he uploaded it, and even you can see, for example, the code div like what he changed, and you can roll back. And, for example, use the previous version. Of front end if you don't like new version of front end.
00:53:27.484 - 00:53:55.626, Speaker A: And for sure you can fork any components. If you don't like it, you can introduce your own functionality and use in your own way or maybe submit this functionality to the initial component author. So, speaking about Ethereum, we have different components like this is component to stake ezers using lido.
00:53:55.626 - 00:54:19.282, Speaker A: You can find it, you can actually see the code, how it works. There is an injected Azure's JS library so you can read and write data in a way you're familiar with. There is also swap components, you can see how uniswap works like Pancake, like Quickswap.
00:54:19.282 - 00:54:33.930, Speaker A: A lot of networks are connected there. There is an AABE component, there is a balancer actually it's quite straightforward. This is like a final scheme how it works.
00:54:33.930 - 00:54:55.330, Speaker A: So user navigates through a different gateway to his user experience. For example, he can go to the internet or using his wallet, he selects which D app he wants to use. Then there is a request to near blockchain and near blockchain returns some compressed JSX code.
00:54:55.330 - 00:55:35.470, Speaker A: It renders in the virtual machine inside the browser into the final user interface. So user can interact with it and as soon as he wants to send any transaction from his browser using his injected wallet, he can just create transaction and send to the blockchain he is working with. Okay, because for sure some hackers will want to use actually and we have price pool $10,000 for hackers who will build some applications during the hackathon.
00:55:35.470 - 00:55:59.320, Speaker A: And I want just to show give you some initial experience how we can work. So let me just open your torque. So this is a social network and usually it should be faster.
00:55:59.320 - 00:56:20.810, Speaker A: For example, I can go to maybe for the beginning I can just like something so it will be on chain transaction. If I will refresh you will see my likes there. And if I go to the wallet you will see that it was a real transaction there.
00:56:20.810 - 00:56:36.364, Speaker A: Okay maybe it's a better example. Let me go to the profile. This page.
00:56:36.364 - 00:56:53.552, Speaker A: What you see is a component is written on a JavaScript. And I can go to discover and develop and view the code of this component. So profile page let me open another screen.
00:56:53.552 - 00:57:08.580, Speaker A: So there is several tabs like components I built NFT I own. For example my followers. I can go back and I can go to the source code of this component.
00:57:08.580 - 00:57:26.424, Speaker A: And for example there is a dependencies what we are using. If I go to followers list. I will see that there is a set of widgets which are running in a loop.
00:57:26.424 - 00:57:43.200, Speaker A: And for example if I will copy this one. And I will create a new component right now create a new component. So now it's empty one and it will just return the hello world.
00:57:43.200 - 00:57:57.256, Speaker A: I can remove this and put for example it's account ID. I will replace it. I will put a value for example root near.
00:57:57.256 - 00:58:17.208, Speaker A: And if I will preview you will see just an account of one guy who has actually a name root near. Okay and maybe I can put another widget. I prepared just example here for example we have a public text like another scan.
00:58:17.208 - 00:58:31.184, Speaker A: You can put any tag for any address. And we can put also for example see the text of root near. So now you'll see his profile as I showed before.
00:58:31.184 - 00:58:39.812, Speaker A: And his public tax. And just to don't put this hard coded. Let me put it.
00:58:39.812 - 00:58:57.850, Speaker A: For example I can create in the top const account ID. And I will read it from props is a react based way how you can get some values inside your components. So like account ID.
00:58:57.850 - 00:59:14.610, Speaker A: Or by default I can put maybe some other component. So now probably you'll see another guy. But let me now save this code.
00:59:14.610 - 00:59:33.580, Speaker A: Publish it to the blockchain. I can probably can rename it data I'll put like that. So this will be the name of my component.
00:59:33.580 - 00:59:43.650, Speaker A: So my component which shows user profile and his public text. Now I send blockchain transaction. And if I create another application.
00:59:43.650 - 01:00:02.350, Speaker A: And I will return now widget widget. So how it works. First it is your new account.
01:00:02.350 - 01:00:33.680, Speaker A: Then world widget then the name of the application. So now it shows I created application and as it is it can be used in another application. And you can just create this wave of complexity as you like.
01:00:33.680 - 01:00:48.050, Speaker A: So somebody can just use it there and put his own data. Okay speaking about ethereum. I created an example.
01:00:48.050 - 01:00:56.882, Speaker A: I don't have actually too much time. I can just go through. I made an example how you can use for example wrapped ethereum contract.
01:00:56.882 - 01:01:32.210, Speaker A: And see the balance of current user and wrap and unwrap ethereum and use different chains to do this operation. So at the beginning you need use actually you can host it somewhere or you can use it for example, I just used to block scout using the API methods you can send any account address and receive API there. So then you fetch this API.
01:01:32.210 - 01:01:45.938, Speaker A: Using azure. JS you can create an interface using this API and encode transaction to get balance of receiver. So here I put receiver.
01:01:45.938 - 01:02:04.940, Speaker A: You see it again reads from the browser, reads it from the Azure JS library which is using MetaMask or wallet connector wherever. And this is my balance of this user in azers in wrapped ethereum. Sorry.
01:02:04.940 - 01:02:22.510, Speaker A: And I put a button here which has event on click and it loads function unwrap. With this unwrap button you can read the balance which you want to unwrap. And in similar way you create a contract.
01:02:22.510 - 01:02:43.186, Speaker A: Using Azure's. JS you provide token ID which is contract of Raptor serum and Abi which we read above you have signer from the MetaMask. And then using this Raptor Serum contract you can run any method which exists in abi.
01:02:43.186 - 01:03:05.178, Speaker A: In our case it's withdraw and you just put amount of what you want to withdraw. So if you click this button unwrap, it shows you the MetaMask and it allows you to make transaction. So now, let's say we want to create the same application but for polygon ZKY sync.
01:03:05.178 - 01:03:20.494, Speaker A: So this is the name of token wrapped ethereum on polygon Zksync. I will copy this address, I will paste it here. Now, it doesn't work because this address does not exist on the ethereum blockchain.
01:03:20.494 - 01:03:58.762, Speaker A: But if I switch to polygon network and if I switch to another account where I have some wrapped ethereum let me refresh the screen. It was this wrong account I think I have here. Yeah, so you see it loads my balance from the polygon ZK EVM.
01:03:58.762 - 01:04:13.474, Speaker A: And again I can click this unwrap button and it works. Now in Zke EVM, like the same code, the same functionality, but as you can see, just much smaller the transaction fee. So, and this is the power of this kind of development.
01:04:13.474 - 01:04:27.098, Speaker A: You can create like real blockchain agnostic applications. I hard coded. Here the address.
01:04:27.098 - 01:04:49.620, Speaker A: But you can easily add similar code. For example, you just check chain ID and you can create wrap and wrap functionality on every network you want. And if you will for example create any other application where you need such a functionality, you can just use different code from another developer there.
01:04:49.620 - 01:05:25.280, Speaker A: So let me now go back to Ethereum mainnet and I want to show this. So this is a LiDAR component. Again, you can see the code and you can fork it and you have a swap component MetaMask.
01:05:25.280 - 01:05:53.010, Speaker A: Sorry, this coin geek API doesn't work. So okay, sometimes it happens. So the code is there.
01:05:53.010 - 01:06:24.600, Speaker A: You can contact near booth with your questions and use this way to handle a blockchain layer, security layer and create these unstoppable applications. I can give some example of how this can be used. For example, imagine if application like Tarnada cache deployed on Bos and then at some point some regulator is coming and trying to close it using the court.
01:06:24.600 - 01:06:40.240, Speaker A: What can he do? He cannot remove smart contract from the blockchain because it's decentralized. He cannot write to the hosting provider because there is no any hosting, there is no any place you can send an email and ask to block this application. There is no domain name to block.
01:06:40.240 - 01:07:16.504, Speaker A: Okay? There is a way to contact gateway operator and ask them to blacklist some access to some URL, but there are a lot of other gateways remains and user can easily launch his own local gateway. And in the worst case, like Last Hope, regulator can ask developer of this application to override his code with empty code. But in this case, users can just roll back to the block height because as you know, the blockchain keeps the whole history for the whole time.
01:07:16.504 - 01:07:33.570, Speaker A: And just you can watch, you can actually see the UI even it was completely deleted from the current state of chain. So if you have any questions, yeah, I will be happy to answer, maybe on the boost. Yeah, if I don't have time.
01:07:33.570 - 01:08:20.916, Speaker A: So once you build all that, how do you actually show it as domain to end user? The LiDAR thing you just showed, what do you type into your browser so an actual user can yeah, what is the routings here? If I go just to any application configured by any gateway owner, this is the way how you can configure a gateway. So first it has the name of the user who deployed this application and then the name of the front end. It rows like that.
01:08:20.916 - 01:08:46.600, Speaker A: And if you want, I can just copy it and open on a different gateway. It will have the same application. And if you don't want, if I'm not wrong, I can put something like embed and you see, like without interface, you can integrate this to, for example, to iframe or, I don't know, wherever.
01:08:46.600 - 01:09:19.568, Speaker A: And just one thing to notice, I also participate in a lot of hackathons and usually hackers are deploying their front end somewhere on where cell or something and just in a very small period of time, those fronts just disappear because they became unavailable. And if hackers will host this on a similar way on the blockchain, it's very cheap, but it will stay forever. Thank you, Vidim, that's all we have time for.
01:09:19.568 - 01:09:32.230, Speaker A: Appreciate that. So sit tight for the next presentation which will begin in two minutes. Otherwise, thanks for coming by.
01:09:32.230 - 01:11:26.428, Speaker A: All right, thank you everyone for coming to my talk. So we're going to be talking today about count abstraction and how you can get started using count abstraction in your devs. Today with the Biconomy SDK.
01:11:26.428 - 01:11:33.684, Speaker A: So a little bit about me. My name is Rahat, head of Developer Relations at Biconomy. Be here throughout the week to help you out.
01:11:33.684 - 01:11:46.196, Speaker A: As you're hacking through this, answer any questions that you might have. Formerly been a front end engineer, did some solidity former founder, didn't really work out, but yeah, also a former hip hop artist. I'm retired.
01:11:46.196 - 01:12:03.628, Speaker A: I do not do freestyles anymore because I'm not good at them anymore. But yeah, so I usually look like one of these two things, usually the first one. So wanted to kind of talk a little bit about the current UX of Web Three.
01:12:03.628 - 01:12:32.176, Speaker A: If I were to try to bring my mom into using a D Five protocol, she would have no idea what to do. She would have no idea how to onboard herself onto a wallet, go to an exchange, get some funds, transfer them over to the EOA, and then go and finally, at that point, start to interact with a DAP. Right? And this is an exact set of steps that every single person who is not native to Web Three needs to go through before they actually even use your DAP.
01:12:32.176 - 01:12:53.576, Speaker A: If you're trying to actually get users for your DAP, which is probably something you should do if you're building something, get users, make it as easy as possible for them to do so. So there's a lot of things wrong with that general kind of feeling. The first part is like that onboarding onto a wallet, right? There's this fear of losing private keys.
01:12:53.576 - 01:13:26.040, Speaker A: A couple of weeks ago, I unfortunately got my own account hacked and got drained of a significant amount of funds. But this whole private key situation, this whole saving a bunch of words of nonsense that need to be written down somewhere, it's not a great UX complicated Web Three UX, I just explained having to go through so many different significant hoops in order just to get started doing your very first transaction on any DAP. And then there's the whole thing about paying too much gas fees.
01:13:26.040 - 01:13:40.860, Speaker A: So how can we actually improve the Web Three user experience, incomes, account abstraction, EIP Four, which you'll see on my shirt. We have some more of those downstairs. If you're hacking on by economy, definitely pick up a shirt.
01:13:40.860 - 01:14:00.804, Speaker A: But what exactly is account abstraction? You can define it as the ability to add arbitrary logic to the process of validating a transaction. So any transaction adds some additional information to it. That information helps you do whatever other type of logic you want to do when you add this information to it.
01:14:00.804 - 01:14:14.556, Speaker A: This new data object is called a user operation. So this is like a new way of looking at transactions through the scope of account extraction, specifically through four, three, seven. So user operations live in what's called an alternative mempool.
01:14:14.556 - 01:14:38.860, Speaker A: And you have service called a bundler, which will take a look at this alternative mempole. Take these user operations send them to what's called an entry point contract that lives on each chain and handle actually executing them into regular transactions. So all of this stuff is achieved with using smart accounts or smart contract wallets.
01:14:38.860 - 01:14:47.308, Speaker A: Normally wallets are secured by code. Well, not normally. These wallets are secured by code instead of the ECDSA.
01:14:47.308 - 01:15:16.460, Speaker A: So this allows for you to actually execute that additional logic on top of your transactions. So the main thing you want to ask yourself is how do I want to authenticate a transaction? What additional logic do I want to add on top of it, that's kind of like the most basic way of thinking about account abstraction, just taking a transaction and figuring out what else you can add before you validate or let it actually go through. Quick diagram just to show kind of like the lifecycle of how this works.
01:15:16.460 - 01:15:37.620, Speaker A: In the green box kind of represents a smart contract wallet secured by code. It can be owned by an EOA externally owned account, which is like your regular wallet account that you might be used to. It can be secured by hardware, devices, pass keys, which is going to be coming soon to our SDK, currently in audit.
01:15:37.620 - 01:15:54.676, Speaker A: But these are what actually executes those user ops that live in this mempool. And a bundler is simply a service. It can be written in TypeScript, rust, whatever, is going to be looking at that mempool and sending it to that entry point contract.
01:15:54.676 - 01:16:06.044, Speaker A: Now, I mentioned the user op mempool can have additional information in it. One bit of information that it might have is data regarding a paymaster contract. A paymaster is simply going to allow you to do a couple of different things.
01:16:06.044 - 01:16:23.932, Speaker A: A, it can let you sponsor transactions on behalf of the user, so from the user perspective, they don't have to pay any gas. You can also decide to let the user pay in, ERC, 20 tokens. So it depends on what kind of user journey you want to build out for folks.
01:16:23.932 - 01:16:43.720, Speaker A: And eventually the entry point contract is going to handle the execution phase of the transaction. So all of this is basically governed through this entry point contract that lives on each chain. The Infinitism team deployed the entry point contract a few months ago.
01:16:43.720 - 01:17:03.964, Speaker A: On the ethereum mainnet. There are entry point contracts across polygon and optimism, et cetera, several other chains as well. If you ever want to just get another quick breakdown of account abstraction, I've done a few Twitter threads that have like a little whiteboarding session going through them.
01:17:03.964 - 01:17:21.750, Speaker A: Definitely take a look at that without any code, just kind of like goes through, explains some of the principles. These also exist in blog form on our blogs. So if you go to Biconomy IO, head over to the blog, you can read the blog form out of this as well.
01:17:21.750 - 01:17:36.996, Speaker A: So I explained a whole bunch of stuff to you, but to actually leverage count abstraction. You probably don't want to code out all those contracts yourself, build out all those services yourselves. So we give you a solution in the form of the Biconomy SDK.
01:17:36.996 - 01:17:51.640, Speaker A: So the Biconomy SDK comes in mix and matchable packages. So these are the three main packages that are going to help you actually building out your projects as you're building this weekend. First is our accounts package, which is going to help you deploy your smart accounts.
01:17:51.640 - 01:18:07.680, Speaker A: It's also going to help you creating user operations. We have a bundler service in the background so you can use the bundler package to interact with that same for our Paymaster. So, like I said, Paymaster can sponsor gasless transactions or allow users to pay gas with ERC 20 tokens.
01:18:07.680 - 01:18:35.656, Speaker A: The bundler is again what's going to look at the user ops that are created from the accounts package and send them to the entry point contract that exists on the chain that you wish to interact on. The cool thing with the Paymaster and bundler, you don't have to actually use our services to use the SDK. If you want to plug and play different services, as long as they are four, three seven compliant, you just need a URL of a Paymaster of a bundler and you can plug and play it into our SDK.
01:18:35.656 - 01:18:45.100, Speaker A: So it's completely mixed and matchable with other services. I said that I guess too soon. That was my slide explaining that.
01:18:45.100 - 01:18:58.844, Speaker A: But let's dive into a demo and some code. So on the screen here, you'll see I have this is actually a live website. You can go to it now aaswap Versaille app, but it is a miniature version of Uniswap.
01:18:58.844 - 01:19:24.570, Speaker A: This app is using the Uniswap V three router under the hood and is also using the Biconomy SDK in order to add a couple of functions to it. So I'm going to connect to web three and I'm going to pretend I'm actually just a user who has never onboarded onto a wallet before. So since I don't have a MetaMask, I don't have any wallet, I'm going to use Google to log in and I'm going to sign in using my email.
01:19:24.570 - 01:19:40.704, Speaker A: And once I've done that in the background, this is using web Three off under the hood to create an EOA for you. And that EOA is actually going to be an owner of a smart account that is deployed by the SDK. So this address here is actually the address of the smart account.
01:19:40.704 - 01:19:56.790, Speaker A: I have some funds on it from before. So you'll notice I have some wrapped ether link USDC and I have Nomadic, even though this wallet is deployed on the Polygon Mumbai network. So, just a thing to keep in mind if I wanted to onboard quickly.
01:19:56.790 - 01:20:11.610, Speaker A: If I had no funds whatsoever, I can hit buy crypto, I can use bank account, credit card, anything. I want to add funds directly to my wallet. I already have some so we'll just not enter my card details there.
01:20:11.610 - 01:20:24.380, Speaker A: So I have some USDC here. So maybe I want to swap some USDC for some wrapped ether. I'm going to hit the swap button and in the background so there's nothing I have to sign.
01:20:24.380 - 01:20:40.688, Speaker A: There's no metamass pop up that you have to go in, approve transactions, things happening for you in the background, everything is being signed for you. What's happening in the background is there's two transactions actually running at the same time. There is the approval and the swap.
01:20:40.688 - 01:20:46.870, Speaker A: Okay, I forgot to actually click on the link. Let me see. I hope I console logged it.
01:20:46.870 - 01:21:03.380, Speaker A: Okay, I have a transaction response. Okay, but this is on polygon scan. This is a main net transaction.
01:21:03.380 - 01:21:18.904, Speaker A: Let's just do the transaction again. This time I'll remember to click it. So basically in the background it is approving and swapping one USDC all at the same time.
01:21:18.904 - 01:21:33.388, Speaker A: So that's two transactions being batched into one. So as a brand new user to web three, I don't have to worry about approving x amount of tokens to be swapped. It's just done it for me and it's only being done for the exact amount that I need to swap.
01:21:33.388 - 01:21:44.640, Speaker A: And you'll see here, this is a transaction happening right now on mainnet, on polygon, mainnet refresh. Okay, cool. So you'll see here, it was completely successful.
01:21:44.640 - 01:21:59.944, Speaker A: I swapped one USD coin for the equivalent in wrapped ether. I had no matic in my account, so that was completely gasless. If I wanted to, I could switch this so that I paid for the swap using my USDC as well.
01:21:59.944 - 01:22:13.288, Speaker A: So that's another option that I could have enabled for my users. So again, it's up to you. Which side of the UX do you want to work with? You might come to the conclusion that it'll cost too much to sponsor all your users gas.
01:22:13.288 - 01:22:39.920, Speaker A: So maybe the USDC payment is something you would prefer. Or maybe if you're using something like polygon where the transactions are low enough, where it's totally fine, you can just completely sponsor it yourself. So how does some of this stuff work in the discord group? You'll see a bunch of links to our documentation, several blog posts, several example and quick starter tutorials.
01:22:39.920 - 01:22:59.460, Speaker A: So if you want to see how it works in react, how it works in NextJS vite, how it works with node, I'm going to go over the Node JS scripts right now, just because it's a little bit quicker to go through that in a workshop setting. But initializing it is really just copy pasting a bunch of boilerplate code. You initialize our bundler.
01:22:59.460 - 01:23:08.044, Speaker A: Like I said, you can use any bundler that you like. I'm just using our bundler here. Just pass the URL of the bundler that you're attached to.
01:23:08.044 - 01:23:14.732, Speaker A: Same thing for the Biconomy paymaster. I'm attaching our paymaster to this. These can be found on the Biconomy dashboard.
01:23:14.732 - 01:23:41.080, Speaker A: So that's dashboard Biconomy IO that's where you would go to get your API keys, authorize your smart contracts and everything there. And then the last part is just creating this Biconomy smart account configuration. So you're just going to be passing the signer which is your wallet, your EOA, because you're able to pass just any signer object.
01:23:41.080 - 01:23:49.444, Speaker A: You don't actually have to use our social login. You can use any social login that provides you an Ether JS object. So you can use magic.
01:23:49.444 - 01:24:04.044, Speaker A: You can use web Three Auth, which is what we use under the hood. Anything that you like that you're used to, it is compatible with our SDK as long as you have that Etherjs transaction object. So here just a quick thing.
01:24:04.044 - 01:24:26.408, Speaker A: I'm initializing the Biconomy account, I create the account and I'm just logging out the owner. So the owner is the EOA that is used to actually put this to actually, sorry, the notification messed me up. That is actually used to create this smart account.
01:24:26.408 - 01:24:39.752, Speaker A: So right now, all of our smart accounts have to have an owner. We are in audit to have future versions where you can have an ownerless smart account. So definitely keep an eye out for that.
01:24:39.752 - 01:24:52.480, Speaker A: But for now, you do have to have it owned by some external EOA. In the case of Web three Auth, they do create an EOA for you in the background that owns everything. So let's just take a look at Minting, an NFT.
01:24:52.480 - 01:24:59.040, Speaker A: Pretty basic kind of thing. Example. So I have this interface of a safe mint function.
01:24:59.040 - 01:25:12.516, Speaker A: I have the NFT address here. One of the main things I need to do really is just basically get information about this specific function that I want to execute. And there's a couple of ways to do that.
01:25:12.516 - 01:25:33.768, Speaker A: So this is one of the ways the Docs has different examples how you would do this on front end. It'll be slightly different, but you're just going to get some information about the actual function that you want to execute, pass it any parameters that it needs. Once you have that info, you're going to start building out the actual user operation.
01:25:33.768 - 01:25:57.584, Speaker A: But the only part of the user operation you need to build out is this two and this data field. The two is just going to have the address that you're interacting with and the data is just going to have this information here about the transaction that needs to be executed. So we have this build user op function attached to our smart account, which is just going to take an array of these constructed transactions.
01:25:57.584 - 01:26:09.860, Speaker A: So you can put one transaction in here, you can put several transactions in here. If you put one transaction, it'll just execute that one. If you put several transactions in this array, it will bundle those together into a single transaction.
01:26:09.860 - 01:26:16.212, Speaker A: So that's how I did that. Approve and swap on the uniswap demo. These are just some typings.
01:26:16.212 - 01:26:28.540, Speaker A: And then the other. Main thing to see here is this Paymaster and Data is going to take that user op. It's going to take data that you can build out using RSDK.
01:26:28.540 - 01:26:35.660, Speaker A: And there is a mode. There we go. So there's a mode here for how you want to sponsor.
01:26:35.660 - 01:26:50.640, Speaker A: If you want to sponsor completely gasless, you just use a sponsored tag if you want to sponsor with ERC 20 tokens, meaning let the user Pay. In ERC 20 tokens you simply switch this flag. It's just a flag that you switch.
01:26:50.640 - 01:27:07.556, Speaker A: Nothing too difficult there. And the last part, this is specific to ERC 20 sponsorship is just getting fee quotes. So what are the quotes for the different types of swaps that they can do? Currently we support a few different stable coins.
01:27:07.556 - 01:27:24.600, Speaker A: You can get a full list of that on our docs to see which coins that we support. I usually just use USDC for demos, just the easiest one. So let's go ahead and execute this.
01:27:24.600 - 01:27:33.334, Speaker A: Take a look at that. So yarn dev. I'm just going to log out the owner the address.
01:27:33.334 - 01:27:47.950, Speaker A: This code is also available on the links that are shared in Discord. You'll see that a user op hash is printed on the screen as well. Let me actually make that a little bit bigger.
01:27:47.950 - 01:28:06.606, Speaker A: Cool. So this is not on main net, this is on Polygon Mumbai, I think from the chains that are sponsoring this time. We support Polygon as well as linear.
01:28:06.606 - 01:28:23.062, Speaker A: So those are two different chains that you can launch on. And you'll see here that there were two NFTs Minted all in one transaction. I passed that transaction twice in the array and let's just confirm that.
01:28:23.062 - 01:28:38.560, Speaker A: So that is Token 149 and 150. I'm going to grab the address from here. Let's head to openc and verify that that was done.
01:28:38.560 - 01:29:05.868, Speaker A: And we have 149 and 150 here. Cool. So all of this code you can definitely take a look at on our docs as well as the notion pages that we've provided in Discord that show you some examples of how you can go through and build a lot of these things out.
01:29:05.868 - 01:29:27.796, Speaker A: We have tutorials and starter kits that show you how to actually use other sponsors technology along with our tech, as well as just like different variations of how you would do this in NextJS, how you would do this in React or using Vite. So whatever flavor of front end you kind of like to use, we have a couple of different tutorials for doing that as well. So definitely explore that.
01:29:27.796 - 01:29:55.452, Speaker A: There is one other, I guess, our larger prize that we have. So if we take a look at the prizes, you'll see that there are two $2,500 prizes for the best use of session keys that are built on top of our smart accounts. We have a tutorial that will go through how to build your own session key module on top of our smart account.
01:29:55.452 - 01:30:10.524, Speaker A: As well. So definitely take a look at that if you're interested in building with session keys for anything else. We do have three $1,000 prizes for best consumer use cases in Web three, as well as a $2,000 pool prize.
01:30:10.524 - 01:30:26.656, Speaker A: To be eligible for the pool prize, you just have to successfully execute a single user operation. So as long as you do that, you are eligible to be part of the pool prize. If you need any dev support, myself and Yash will be here in person.
01:30:26.656 - 01:30:36.760, Speaker A: He's the guy right now at the booth. And we have another person, Vanchika on Discord who you can tag and ask for questions as well. If you need to refine your pitch or your idea.
01:30:36.760 - 01:30:45.980, Speaker A: We have Tommy and Ahmed who are both around. Ahmed is our CEO. Tommy is part of our content team and is amazing at weaving stories together.
01:30:45.980 - 01:31:01.204, Speaker A: So if you need help on your ideas or refining your pitch, definitely these guys are cool people to go to. And yeah, if you're excited to build, definitely let us know at Biconomy on Twitter or at hotcodes on Twitter. And thank you.
01:31:01.204 - 01:31:33.610, Speaker A: If there's any questions, happy to answer those. Do you have mobile SDKs coming? So you can use our SDK with react native with some configuration, but right now it's just mainly a JavaScript SDK. But we do hope to have more support for other mobile.
01:31:33.610 - 01:31:53.310, Speaker A: The SDK has upgraded to version two from version one. So what's the main difference between version one and version two? So version two is more modular. So one of the things I was kind of talking about is how you can use mix and match different packages with other services.
01:31:53.310 - 01:32:06.162, Speaker A: So we opened it up so that you can use any bundler, any paymaster service. We do, of course, offer the full suite. You can definitely just use ours if you want to, but if you have any specific use cases that you want to use, like other services with, that's what it opens up with.
01:32:06.162 - 01:32:24.264, Speaker A: We also made it a lot easier to execute user operations than our previous version, so a lot of improvements on the developer experience side as well. Thank you, Rahat. Please stay seated.
01:32:24.264 - 01:42:12.032, Speaker A: If you're sticking around for the next presentation, it'll begin in about two or three minutes. Otherwise, thanks for stopping by. Hello.
01:42:12.032 - 01:42:16.400, Speaker A: Hello. I won't touch that. Hi everybody.
01:42:16.400 - 01:42:25.312, Speaker A: Thanks for coming out. Excited to talk to you today about Celo. So my name is Eric Nakagawa, based in San Francisco.
01:42:25.312 - 01:42:31.364, Speaker A: Very excited to be here at East Global. It's been a long week. A bunch of our team are also here.
01:42:31.364 - 01:42:41.604, Speaker A: We got Harpal, who's going to be talking in a little bit, and a bunch of folks down by our booth. So if you have any questions after, come ask us questions. We're also handing out a little starter sheet.
01:42:41.604 - 01:42:47.320, Speaker A: A few folks are hackers. How many here are hackers? Great. So before you leave, please grab one.
01:42:47.320 - 01:42:57.070, Speaker A: It says a starter guide to help you folks save some time. So what is cello? So Celo, if you haven't heard, is a blockchain focused on prosperity. It's what we like to say.
01:42:57.070 - 01:43:12.276, Speaker A: And we are building a very large global community of both builders, founders that believe in this concept of prosperity for all. There's who we are again. We have a bunch of folks here to help you folks out.
01:43:12.276 - 01:43:25.350, Speaker A: We have folks who can give you mentor around ideas. Come talk to me about that. Community aspects, technical from the solidity and the front end dev side and then some product feedback as well.
01:43:25.350 - 01:43:33.720, Speaker A: First let's talk about what is cello. So when I say building for purpose, we want to build for real people. And we've been doing this for several years.
01:43:33.720 - 01:43:49.368, Speaker A: When Celo launched, it was carbon negative from the beginning. So if you've ever heard of regen refi, regenerative finance, we didn't know that word was going to become a word. And back then it was more like about climate and social impact.
01:43:49.368 - 01:44:10.150, Speaker A: So a lot of people have been building with that and have embraced Celo when it comes to refi projects. We think a lot about the planet and we want people to be building for real world use cases, trying to help a lot of people. And what that means is people in Latin America, people in Africa, and our focus has been there for quite a long time.
01:44:10.150 - 01:44:22.024, Speaker A: What kind of features to talk about if you're a dev? Well, we start with mobile. So a lot of times if you're building, you want to start with mobile. And the reason for that is everybody here has a mobile phone, everybody in the world.
01:44:22.024 - 01:44:40.396, Speaker A: Most people have access to a mobile phone, but they don't have access to a computer. And the user experience of that, I think it's really important to be thoughtful when you're building your projects. And again, like I said, regenerative finance, that can be things like it's not just climate credits, it can be community tokens.
01:44:40.396 - 01:44:58.036, Speaker A: And if you want a book to read if you're into this stuff, secure Economics is a great book to learn more. As I mentioned before, carbon negative built into the protocol. We actually have a hard fork coming that will make every transaction carbon negative and very excited about that coming soon.
01:44:58.036 - 01:45:14.584, Speaker A: A bunch of other features. In terms of how many people use the project, there are almost or over 30 million wallets bunch of mobile users that we're targeting. We've given out a lot of grants and as I mentioned before, we offset a bunch of carbon since day one.
01:45:14.584 - 01:45:20.312, Speaker A: We really believe in that. A lot of transactions. There's also a bunch of with 1000 projects that are building on sello.
01:45:20.312 - 01:45:37.468, Speaker A: There's a lot of recently large uptake in a lot of people doing things on chain. So right now we have stablecoins things like CUSD, C, Euro and Crayl. We have an ultra light client for helping with mobile phones that might not be that strong a bunch of bridges.
01:45:37.468 - 01:45:47.540, Speaker A: Fiat Connect actually helps to connect on ramps for the users no matter where they are in the world. Excited about that. And Social Connect is something that Harpault is going to be talking about.
01:45:47.540 - 01:45:52.500, Speaker A: As I mentioned, the ultra green hard fork. Very excited for this to happen. Coming in August.
01:45:52.500 - 01:46:04.200, Speaker A: And then if you've watched the news, you've heard about the proposal in the community for turning cello into an L two. So there's a governance call that is about 40 or 55 minutes from now. Excited to see what the community wants to say.
01:46:04.200 - 01:46:09.960, Speaker A: We want to be more aligned with Ethereum. When we launched, we were proof of stake. So we've been proof of stake from the beginning.
01:46:09.960 - 01:46:24.016, Speaker A: And now that Ethereum is in that Ethereum is proof of stake, I think it makes sense to come back home. A lot of focus on interoperability going to quickly run through our boundaries. If you're building, we are giving out 3000 for first 2001 thousand for second and third.
01:46:24.016 - 01:46:37.540, Speaker A: And then we're also looking for people to implement Social Connect and account abstraction on Sello. So without further ado, here's Harpal to talk about each of these pieces. GM everyone harpal here.
01:46:37.540 - 01:47:09.436, Speaker A: So let's talk about Social Connect because this is one of the theme bounties we have. So first of all, rather than learning about Social Connect, let's learn why we need Social Connect in the first place, right? This is how my Ethereum address looks like. Personally, I don't even remember it myself, but imagine in the future as we go more mobile and we use a lot of applications which will involve our friends and our contacts and family, you might have to memorize Ethereum addresses of all the people in your contacts, right? And it's going to be very tough.
01:47:09.436 - 01:47:31.348, Speaker A: I mean, I don't remember myself, the address, my own address. How am I going to remember everyone else's address? Unless you are this guy who is like eight time memory World champion, I'm pretty sure he's going to be also having problems at some point. But let's talk about Identifiers, right? We have email.
01:47:31.348 - 01:47:41.700, Speaker A: We have Twitter, LinkedIn, Discord, Telegram, ENS, Facebook. I don't remember because I haven't used it for a while. And now we have a new thing called threads.
01:47:41.700 - 01:47:45.512, Speaker A: Yeah. Too many identifiers. Right? Too many things to remember.
01:47:45.512 - 01:48:17.830, Speaker A: Oh, I want to send crypto to my friend. I don't remember his Ethereum address, I don't remember his cello address, I don't remember his yeah, you get the point, right? So what if we can make it possible to let users use their existing Identifiers as their wallet address, right? What if the user can just know, I want you use my Twitter handle as my wallet address from now on. So if my friend wants to do something with my wallet, if send tokens or just use my address somewhere they can just put in my Twitter handle, right? And that's what Social connect is.
01:48:17.830 - 01:48:33.080, Speaker A: So it's a simpler way of sending value between wallets but it can be expanded into other things. It's basically ENS, but you can decide what the Identifier can be. So here's the GitHub repo for that in case you're interested.
01:48:33.080 - 01:48:41.608, Speaker A: And this is a screenshot of how it looks like in an app. It's already live and these are some apps which are already using it. Valora is a wallet node.
01:48:41.608 - 01:48:48.600, Speaker A: Finance is a developer tool. Libra and Kala are also wallets that you can check out. They are using Social Connect right now in production.
01:48:48.600 - 01:49:01.984, Speaker A: And here's a cheat sheet. I highly recommend that you scan this QR code but if you don't want to, we have a physical cheat sheet that you can take here from Lyle which is in the Slo t shirt. But yeah, let's move it.
01:49:01.984 - 01:49:17.764, Speaker A: So how does social connect work? So there are three parties in this protocol. One is Issuers, second is DApps and then there's an on chain contract which keeps track of the Attestations. So what are issuers? Issuers can be anybody who wants to attest users based on Identifier of their choice.
01:49:17.764 - 01:49:30.060, Speaker A: So for example, let's say I want to make it easy for users to use their Telegram handle as their wallet address. So I can become an issuer for Telegram and it's up to me. You don't have to take permission from anyone.
01:49:30.060 - 01:49:54.500, Speaker A: It's open for all. You can become an issuer and yeah, you can just start authenticating users and getting their telegram and just verifying if a user holds it. And once you do, you can basically use that obfuscated Identifier and put it on the smart contract on chain and then you are issuers.
01:49:54.500 - 01:50:22.952, Speaker A: So what is the second party? The second party is DApps. So let's say you're a DAP builder and you know that there exists an issuer already for the Identifier that you want to use or you want your users to use, then you can just trust those issuers, right? Issuers could be seller foundation testing some form of Identifier. It could be your own protocol contributing for other DApps to use an Identifier.
01:50:22.952 - 01:50:35.164, Speaker A: So DApps basically trust issuers. They can trust issuer or they can become an issuer themselves so they don't have to do the overhead of doing authentication, et cetera. And then there's an onchain contract.
01:50:35.164 - 01:51:04.276, Speaker A: This is the part where once you are done with authentication of the Identifier, you need a place where it cannot be changed without the permission of the issuer. That's where the Onchain contract comes into place, where you are basically whenever you want to store something on this on chain contract, which is the Attestations contract, you will have to sign with your issuer keys. So everybody knows who did the process of authentication, who is responsible for this, et cetera.
01:51:04.276 - 01:51:21.664, Speaker A: And these Identifiers are not stored as plain text, they are encrypted to preserve privacy. So what to build? Right? Since this is a hackathon, what are you supposed to build? Using Social Connect, you can become an issuer for a new Identifier. It could be something that you use for your own product.
01:51:21.664 - 01:51:32.964, Speaker A: It could be an internal Identifier of your choice. There are many Identifiers that don't have issuers on the cellular network. Discord, Telegram, these don't exist right now.
01:51:32.964 - 01:51:49.864, Speaker A: So opportunity is available for you guys. And you can integrate Social Connect into existing DApps for issuers that already exist. Or you can enable walletless onboarding using an Escrow contract that we already have on Cello right now.
01:51:49.864 - 01:52:04.270, Speaker A: It supports ERC 20 tokens. So basically, if you want to send some ERC tokens to a user of your app, they don't even need a wallet and we don't have an Escrow contract for NFTs. So that's also an opportunity for you guys.
01:52:04.270 - 01:52:19.644, Speaker A: Cello Composer so this is a template that we have built internally for you guys to get started quickly. This is for hackathon people, right? Get started in less than 1 minute. You just run one command and you will have an option to select whether you want to use React.
01:52:19.644 - 01:52:32.452, Speaker A: You want to use React native, you want to use Expo without expo, angular flutter, any framework of your choice or library of your choice. You can just start building in less than 1 minute. And Rainbow Kit is already in there.
01:52:32.452 - 01:52:43.764, Speaker A: Wallet. Connect V two is already in there. So you don't have to worry about going through the docs of these technologies and figuring out and losing those essential early hours of the hackathon.
01:52:43.764 - 01:52:50.232, Speaker A: So I highly recommend scanning this QR code as well. So social connect with cello composer. Just five steps.
01:52:50.232 - 01:52:58.110, Speaker A: Scan this QR code. You will get these steps in more detail in the QR code. We also have a physical version of the same year.
01:52:58.110 - 01:53:15.124, Speaker A: It's just five steps to get started and you will be up and running with Social Connect in your DAP. So the second bounty we have, the second team bounty is account abstraction 2000 USDC. So let's see, raise of hands.
01:53:15.124 - 01:53:25.476, Speaker A: How many of you know about account abstraction already? Right? Okay, a few people. Great. So why do we need AA, right? This is how popular wallets are onboarding.
01:53:25.476 - 01:53:54.656, Speaker A: If you must have already been through the screen maybe a couple of times. Nothing against MetaMask, I personally use it, but it's not friendly. For a person who does not know about tech, a normal user, a person who uses Twitter or Telegram or all these social apps, might not want to learn how to do all the secret recovery phrase, where to put it, why to write it down, and they might not even write it down and just throw it away.
01:53:54.656 - 01:54:06.212, Speaker A: And later, when they have issues, they will be looking around for help, but nobody will be able to help them. And even other onboarding is done. You still need native tokens to start.
01:54:06.212 - 01:54:17.908, Speaker A: So that's another barrier for that user, barrier to entry for that user. Right. And as you move towards MultiChain DApps, the complexity will keep on increasing, making the experience worse, difficult to operate.
01:54:17.908 - 01:54:27.612, Speaker A: And these complexity will just not allow Web Three to express the full potential to the user. That what it can let you achieve. Right.
01:54:27.612 - 01:54:47.570, Speaker A: And this is where account abstraction comes into play. It's a way to solve problems by allowing users to flexibly, program their wallets with more security and create better user accounts. Obviously the developer will do it, but if we do this work, then the user will have a much better user experience using Web Three products.
01:54:47.570 - 01:55:03.636, Speaker A: Cool. So a lot of people might know about the 4337 EIP. It's not exactly account abstraction, but because account abstraction is actually a general concept, a lot of people have been working on it before the ERC even came up.
01:55:03.636 - 01:55:23.416, Speaker A: But it does give you some basic rules and standards that we can adopt to enable account abstraction at the application layer of ethereum some people have achieved on the protocol. Yeah. How does it work? We have four parties in this ERC that was proposed that one of them is Account Factories.
01:55:23.416 - 01:55:37.728, Speaker A: It helps you create smart accounts. You can create your own account factory based on the account factory, the accounts will be created. So if you want to use a different type of account, then Account Factories is what you want to build.
01:55:37.728 - 01:55:53.860, Speaker A: Bundlers. These are like validators or nodes who can process user operations. Now, emphasis on the word user operations, this is different from transactions because the structure is different, but they are similar to transactions, but not exactly transactions.
01:55:53.860 - 01:56:07.068, Speaker A: Entry Point is like the central place where all the user operation flow takes place. Entry .1 of the main objective of Entry Point is to make sure that the bundlers are paid for the work that they do.
01:56:07.068 - 01:56:17.112, Speaker A: And paymaster is an optional part, but a very useful one. It helps you sponsor gas fees for accounts. So let's dive more into details.
01:56:17.112 - 01:56:30.972, Speaker A: I guess I talked about Account Factory, that it lets you create different types of accounts. If you want to create a different type of account, account Factory is what you want to build bundle. So they have a special mempool for operations.
01:56:30.972 - 01:56:47.176, Speaker A: They're always keeping an eye on those mempools. And whenever user operations come in, they process them, they order them, they make sure that the user operation is not valid. They also check whether the user operation will lead to fees getting paid to the bundler or not, because they are doing the work they need to get paid.
01:56:47.176 - 01:57:09.224, Speaker A: And Entry Point basically coordinates the entire process of the user operation, going from the user to execution. And one of the crucial roles it plays is that bundlers are paid for their work, because bundlers need to voluntarily participate in this system. If there are no bundlers, there is no account abstraction paymasters.
01:57:09.224 - 01:57:20.296, Speaker A: Paymasters are basically smart contracts which are already deployed on the blockchain. They are willing to sponsor gas for the execution of user operation. Sponsorship does not always mean that it's free, it's just an alternative method.
01:57:20.296 - 01:57:39.080, Speaker A: Paymasters could be taking tokens in. Let's say they are taking token X and they are willing to pay the native token for you on your behalf. But you can basically build any type of method to accept tokens as a paymaster and pay for the user.
01:57:39.080 - 01:57:52.300, Speaker A: But yeah, it could also be free, it could be app specific as well. So we will talk more about it. So how do you build account abstraction? DApps on sello right, you can use Third Web SDK right now.
01:57:52.300 - 01:58:06.544, Speaker A: Third Web SDK is right now supported and it allows custom account factory. So if you want to build custom accounts account factory, if you want to build custom Paymasters that's also supported. If you want to use their bundlers, feel free.
01:58:06.544 - 01:58:17.968, Speaker A: Third web is already running them up. You can just send a transaction to the user operation to their bundler and it will go through, I mean if it's valid. And it also supports all popular connector types.
01:58:17.968 - 01:58:34.180, Speaker A: So you might be surprised that not all the SDKs out there for account abstractions support Rainbow Wallet Connect but Third Web does. So yeah, use that and transaction batching is also supported. And what to build for the bounty? Right, here are some ideas.
01:58:34.180 - 01:59:04.736, Speaker A: You can build social recovery based wallets combining both the bounties Social Connect and account abstraction and create a wallet which can be recovered using Social Connect. You can create family accounts where there are multiple owners with different limits. So a wallet which is owned by the family where kids have a limit of let's say $10 or $20 per day and the adults in the family have more limits and they can choose which apps they can use or not use, et cetera.
01:59:04.736 - 01:59:16.164, Speaker A: Account where the transaction validation is done using fingerprints or Face ID. That is also possible. I've seen already this being built and session based keys in accounts.
01:59:16.164 - 01:59:38.720, Speaker A: So this is where you would create a special type of account which can be suitable for gaming or social media specific use cases where the social media app or the gaming app says I'm going to take over for your account for the next 30 minutes. So whatever action you are trying to take in my app, I won't ask for your signature, I will just do it myself. So something like that.
01:59:38.720 - 01:59:56.944, Speaker A: And you can build custom paymasters token paymasters for good dollar. Good dollar is a UBI protocol on sello so everybody gets a small amount of UBI or you could say a good dollar every day. Maybe you can build a paymaster which uses those small amount of UBI for paying gas fees.
01:59:56.944 - 02:00:11.560, Speaker A: Since people are getting that every day, they will always have something to pay for gas staking reward tokens. Maybe you have a protocol where there's some staking mechanism and the reward tokens that they get can be used for gas fees. Pretty simple.
02:00:11.560 - 02:00:27.720, Speaker A: Or you could have referral based transaction sponsoring, which is, let's say you are just into production and you want user adoption. Then you tell if you bring five more people, I will sponsor gas for you. If you bring ten more people, I will sponsor more gas for you.
02:00:27.720 - 02:00:48.176, Speaker A: Something like that. You could have app specific sponsoring. So maybe you are something like Ave, where you have multiple apps on the blockchain and you want to say if you want free gas, then you can get free gas if you're using Aave products, ave or Lens Protocol, et cetera.
02:00:48.176 - 02:00:56.810, Speaker A: So free gas for you. If you're using any Ave products, you can build paymasters that can do that as well. And use Cello Composer for a quick head start.
02:00:56.810 - 02:01:07.100, Speaker A: So account abstraction with cello composer. Again, only five steps. Scan this QR code, you will get details about what those steps are.
02:01:07.100 - 02:01:16.252, Speaker A: We also have a physical copy. You can get that one on your exit. And again, to summarize, we have three bounties in total.
02:01:16.252 - 02:01:28.210, Speaker A: Five bounties. So if you are first place, you get 3002nd place, 2003rd Place, 1000 USDC and two theme bounties. Social connect and account abstraction 2000 USDC each.
02:01:28.210 - 02:01:47.092, Speaker A: So I was a hacker, I am a hacker and I will forever be a hacker. So you want to stack bounties, right? You are not going to just build on Celo and be like okay, I just build on Celo. Just one bounty? No, you're going to target other folks who are already here in the cello ecosystem and who are also part of the hackathon.
02:01:47.092 - 02:01:52.136, Speaker A: So build with chainlink. Chainlink price feeds are available on Cello. Use them.
02:01:52.136 - 02:02:03.256, Speaker A: Build something with safe on the Cello network. Use the Graph protocol if you need any indexing in your app. Use hyperlane bridges to make cross contract calls.
02:02:03.256 - 02:02:11.344, Speaker A: Cross chain calls, sorry. And use MetaMask snaps. Or obviously you want to use Wallet Connect at some point.
02:02:11.344 - 02:02:30.340, Speaker A: You can use lit protocol if you need any encryption, and I highly recommend using Quicknode RPC Endpoints, but that's there. And some other folks who are not part of the hackathon, but I highly recommend that you use them. Valora third Web masa finance good dollar superfluid and toucan protocol.
02:02:30.340 - 02:02:36.180, Speaker A: And that's it. Good luck to everyone here in the room who is hacking. And find these faces.
02:02:36.180 - 02:02:44.996, Speaker A: I know you might not be able to remember names, but I hope you remember faces. One of them is me. Eric is here and there are a bunch of more folks at the booth.
02:02:44.996 - 02:02:55.310, Speaker A: So if you have any questions, just feel free to trouble us and yeah, that's it. If you have any questions, please. Thank you.
02:02:55.310 - 02:11:48.420, Speaker A: Any questions? Cool. Thank you guys. Hi everybody.
02:11:48.420 - 02:12:01.656, Speaker A: How's it going? I'm Marcus, developer relations at Edge and Node. Developer success and this is going to be a quick start to subgraph development and querying. Really getting you guys started for the hackathon as soon as possible.
02:12:01.656 - 02:12:19.720, Speaker A: And the best way to get started with subgraphs is to start from the beginning, and that's really understanding where you are in the hackathon. So if you would like to scan this to understand our prizes. Also to have a hacker help telegram group, quick Start videos, repos these slides.
02:12:19.720 - 02:12:34.564, Speaker A: I really tried to put a lot of information in this QR code, so that can be very helpful for you. And once I see phones down, I will move on. Good, everyone got it? Phone up.
02:12:34.564 - 02:12:41.510, Speaker A: Okay, I got you. All right. And real quick, I'll go over the prizes for subgraphs as well.
02:12:41.510 - 02:12:51.220, Speaker A: Three main prizes. We got best new subgraph with those prizes, best use of existing subgraph and then pool prize. Also, we just announced substreams literally yesterday.
02:12:51.220 - 02:13:01.980, Speaker A: So if you want to dive into substreams and what that is, that's also in this QR code? substreams are cool. That's the summary dive in if you can. It's the same QR code as before.
02:13:01.980 - 02:13:08.980, Speaker A: If you already got it, cool. You got it. Okay, cool.
02:13:08.980 - 02:13:15.342, Speaker A: All right. So if anyone wants a live code, you can join along right here. And then this is the repo with all the links.
02:13:15.342 - 02:13:22.342, Speaker A: No more QR codes after this, I promise. We'll just get through all this real quick. All right, everyone's good? Let's go for it.
02:13:22.342 - 02:13:28.140, Speaker A: So this workshop, there's going to be an introduction. Oh, sure, I got you. Sorry.
02:13:28.140 - 02:13:41.534, Speaker A: Yeah, I'll wait. Workshop repo, live coding links pretty much. If you want to do this along with me or have anything that you learned from today be displayed in front of you, use that my phone.
02:13:41.534 - 02:13:50.270, Speaker A: There we go. No more QRS, I promise. All right, so this workshop overview, it's going to be an introduction to the graph we'll start with.
02:13:50.270 - 02:13:58.718, Speaker A: Then what exactly are subgraphs? We're going to define those. We'll actually deploy a subgraph live. We'll compare queries with two different subgraphs.
02:13:58.718 - 02:14:17.318, Speaker A: We'll use a subgraph that is pointed to a smart contract, and we'll use another subgraph that's a little bit more well built out, looking at the exact same contract, and we'll see how it's a little bit different. And then finally we'll finish with a little plug for Scaffold E 20, which connects very nicely with subgraphs now, which is pretty cool. So let's get into the introduction to the graph.
02:14:17.318 - 02:14:23.930, Speaker A: First thing, when you go to thegraph.com, you see this access the world's blockchain data. So let's dive into that.
02:14:23.930 - 02:14:43.998, Speaker A: Really, the data storage of a smart contract is very similar to this. It's just very, very isolated if you only look at it in its one point. However, if you want to understand how that smart contract has existed in time, how do you actually do that? How do you look at how it has existed over timestamps? Well, you want.
02:14:43.998 - 02:14:55.986, Speaker A: To know about the provenance, you want to know about the history, you want to index that data. So something like this, very simple. But we're actually looking back in time just like this Apple mock up for the backups.
02:14:55.986 - 02:15:13.542, Speaker A: And really we're seeing this kind of data layer backing up, backing up, backing up over time and having all of this timestamped information over time in a disorganized way just because it's so write optimized. We have so much data being piped in at any given second. It has no organization, it needs indexing.
02:15:13.542 - 02:15:24.942, Speaker A: All right, so that eventually you think is an issue. Well, there's also another issue. We have a read issue with the blockchain where if we're going to be writing to the blockchain, so disorganized, okay, so that's fine.
02:15:24.942 - 02:15:33.150, Speaker A: We're going to be getting a lot of data back. Also, it's not just a write issue, it's a read issue. We got disorganization on the way in and a lot coming back out.
02:15:33.150 - 02:15:42.370, Speaker A: For example, who here used Instagram today? Anybody? Who posted on Twitter today? Anybody? I post on Twitter. There we go, twitter. All right, so that was one post, that was one write.
02:15:42.370 - 02:15:54.214, Speaker A: And how many followers do you have? Or anyone have 1500 followers? That's potentially 1000 reads to one write. And that's the exact same thing we're seeing with data retrieval from the blockchain. So it's a problem.
02:15:54.214 - 02:16:02.458, Speaker A: So there's a Web 2.5 solution for reading, which is centralized indexing, indexing being organizing of the data. And that works.
02:16:02.458 - 02:16:13.758, Speaker A: It totally does. You're able to get your data from a certain block and actually get it to your front end, totally fine. However, if that centralized indexing service goes down for whatever reason, we are sad, that's not a fun time.
02:16:13.758 - 02:16:28.462, Speaker A: Okay, so the question was in the beginning getting introduced to the Graph, the Web 3.0 read solution. We have a lot of indexers working permissionlessly in the Graph ecosystem and they are all providing you options for your data retrievals.
02:16:28.462 - 02:16:39.750, Speaker A: All right, so they're all indexing that same data piece that you want on the blockchain and you can get it through the graph, and that's the graph right there. So if any of the indexers, for whatever reason go down, you have other options. Okay.
02:16:39.750 - 02:16:46.280, Speaker A: All permissionlessly working through the tokenomic system of the Graph. So I love this. Hope you guys do too.
02:16:46.280 - 02:16:58.538, Speaker A: It really provides a foundation for truly decentralized apps. If you're really needing indexing and you want to be decentralized and have that security guarantee also with incredible speed and uptime. It really is there.
02:16:58.538 - 02:17:05.130, Speaker A: That is the Graph network 450 indexers worldwide. It's permissionless, redundant, fast, cheap and reliable. And a global API.
02:17:05.130 - 02:17:13.202, Speaker A: So let's go into subgraphs. Who here has heard of subgraphs built with subgraphs? Okay, who here has never built with subgraph before? Cool. Awesome.
02:17:13.202 - 02:17:19.422, Speaker A: So we're just getting started. Awesome. So we now know we are swimming in blockchain data all the time as developers.
02:17:19.422 - 02:17:27.954, Speaker A: It's disorganized horribly but we can index it. How is that happening? This is basically what a subgraph does. It takes all the data and puts in nice clean little buckets.
02:17:27.954 - 02:17:36.982, Speaker A: That's basically it. All right, so let's go ahead and put this to words. subgraphs are permissionless customizable instructions for indexers to organize your data.
02:17:36.982 - 02:17:49.226, Speaker A: If you build these instructions awesome, they are going to be sent to indexers for you to get your data back. And here's basically the pathway it goes through. You have on chain data and off chain data that's IPFS that is available today.
02:17:49.226 - 02:17:59.790, Speaker A: And it goes into subgraph YAML, which is your manifest. All right, you define exactly how your subgraph should look like from a high level. And then it gets a little bit more into like a medium level, almost.
02:17:59.790 - 02:18:07.470, Speaker A: It's kind of like the mappings and the logic. And then eventually you present your data. You have your schema, which you send queries to, and they're nice clean little buckets.
02:18:07.470 - 02:18:18.834, Speaker A: Okay. And when you have that all of these subgraphs exist in a permissionless market. Each of these subgraphs are valuable and have incentivizations mechanisms that exist within the tokenomic system of the graph.
02:18:18.834 - 02:18:23.286, Speaker A: It's super duper cool. So that's a high level overview. It can go super deep into this.
02:18:23.286 - 02:18:34.060, Speaker A: But let's keep on going about how subgraphs work. Eventually it all comes to this. You guys want query responses, so we use GraphQL, send out a query, and then we enjoy that.
02:18:34.060 - 02:18:41.498, Speaker A: So that's the high level summary of the graph. And subgraphs 1.1 to 2 billion queries per day are running through the graph.
02:18:41.498 - 02:18:53.534, Speaker A: There's over 1000 subgraphs published on the graph network, which is super cool. Those are the individual subgraphs in the marketplace, and there's over 450 indexers. Okay, I said no more QR codes.
02:18:53.534 - 02:18:55.940, Speaker A: I lied. You could take that or not. That's fine.
02:18:55.940 - 02:19:05.160, Speaker A: Okay, I feel bad now. All right. Once phone's down, we'll go on.
02:19:05.160 - 02:19:17.974, Speaker A: Okay, nice on time. Okay, so let's go ahead and get into the code. We're going to deploy a starter subgraph and then we're going to compare that to a published there we go.
02:19:17.974 - 02:19:32.900, Speaker A: We're back. We're going to compare that to a published subgraph that's both subgraphs are going to be looking at the same smart contract, so you can see how different it's going to be to get data back from a basic subgraph. Hi.
02:19:32.900 - 02:20:08.640, Speaker A: Good. Well, how's everyone doing today? All right. Anything I could do up here's? Sorry, everyone.
02:20:08.640 - 02:20:25.568, Speaker A: Yeah, this is how it goes. Yeah. Should I just bring my laptop up and just I don't know.
02:20:25.568 - 02:20:32.480, Speaker A: That's kind of weird. That's kind of weird. That'd be tough to do a live coding with one hand and tabs.
02:20:32.480 - 02:20:35.696, Speaker A: Hi there. There we go. Okay, let's go quick.
02:20:35.696 - 02:20:42.084, Speaker A: So we'll go into it. This is the subgraph that we're going to pair thank you, guys. That we're going to be comparing our starter subgraph to.
02:20:42.084 - 02:20:51.448, Speaker A: We're going to look at a little bit more well built out subgraph. So you have a learning environment where you can see a basic one and a little bit more advanced one. To start, we'll go to the Graph.com
02:20:51.448 - 02:21:02.988, Speaker A: studio if anyone's along, and also Miniscan. All these links are available to hop into. And throughout this little next section, all you're going to do is just trace the Punk transfer event.
02:21:02.988 - 02:21:10.124, Speaker A: That's all I want. And we're going to look how the Punk Transfer event goes all the way to your Schema GraphQL. From there you'll learn how a subgraph functions.
02:21:10.124 - 02:21:19.120, Speaker A: Let's deploy a subgraph, everyone. So what we're going to start with is we will go to the graph.com and make this a little bigger.
02:21:19.120 - 02:21:42.024, Speaker A: We'll go to products subgraph studio and we're going to create a subgraph and we'll call live ETH Global Paris Demo And we know this smart contract that I'm indexing, like I said, is CryptoPunks. We know it's on ethereum, so I chose ethereum. And then we have this dashboard pop up and you're free to actually populate this as you would like.
02:21:42.024 - 02:21:50.844, Speaker A: Like I said, these subgraphs exist in a marketplace so other people will see them. It's good to have good documentation and also good dashboard etiquette. So fill that out.
02:21:50.844 - 02:22:13.280, Speaker A: If you are looking to join in a published way, let's go ahead and initialize the subgraph. So go into this copy paste and we'll go ethereum automatically populates the subgraph slug from the actual CLI and then it'll create a directory automatically as well. We know this is on Mainnet, so we'll select Mainnet.
02:22:13.280 - 02:22:26.704, Speaker A: Now we find the contract address. So I've already pulled up the Cryptopunk's smart contract address and I'm going to bring that right in here. It's going to fetch the Abi automatically.
02:22:26.704 - 02:22:32.360, Speaker A: Sometimes, depending on the chain, there might be an issue with that. And that's okay. There's totally a solution for this.
02:22:32.360 - 02:22:42.492, Speaker A: You need to get the Abi manually. So you'll actually go to Miniscan, which is all linked in the repo, and you can get all that information very easily. So you go to Ethereum, put in the contract address.
02:22:42.492 - 02:22:49.144, Speaker A: I love miniscan. Of course you can go to Ether Scan, but it provides everything right there in front of you. Very useful for subgraph development.
02:22:49.144 - 02:22:56.080, Speaker A: Miniscan is awesome. You got the Abi, the code, all the different events which are awesome. So let's go ahead and go back.
02:22:56.080 - 02:23:02.396, Speaker A: There we go. It did it automatically. It automatically also found the start block in which the smart contract was initially deployed.
02:23:02.396 - 02:23:11.472, Speaker A: So you don't want to index from block zero. You want to go where the smart contract was deployed, finds it for you and then the contract name. Once again, Etiquette.
02:23:11.472 - 02:23:21.636, Speaker A: Because we are making a subgraph that is public, we want to actually have good naming. So guess what the name of the smart contract is? It's right there in miniscan. So copy and paste, a lot of copying and pasting.
02:23:21.636 - 02:23:27.572, Speaker A: We try to make this as easy as possible for you guys to get up and running. Okay. Index contract events as entities.
02:23:27.572 - 02:23:39.900, Speaker A: This is now we're going to be talking about that kind of portal that goes through the subgraph and how we define it, how we have the mappings, and then we get the schema. This is automatically generating that for you right now. Crossing fingers on the WiFi.
02:23:39.900 - 02:23:53.644, Speaker A: We'll see. All right, so while that is spinning up, we'll see. There we go.
02:23:53.644 - 02:23:57.296, Speaker A: Okay, awesome. So here we could also add more contracts. We're not going to do this.
02:23:57.296 - 02:24:02.800, Speaker A: This is just a starter subgraph press. No. Now it has information on the CLI you could follow through.
02:24:02.800 - 02:24:13.700, Speaker A: I personally like to go right back to my dashboard and a little bigger. Just copy paste. Once again, a lot of copy pasting authenticate in your CLI.
02:24:13.700 - 02:24:24.100, Speaker A: Paste authenticated and enter the subgraph paste. Very easy. And then code gen, which is actually compile.
02:24:24.100 - 02:24:32.892, Speaker A: It's actually doing type safety. And then graph build is compiling. So we have that going through, putting everything together.
02:24:32.892 - 02:24:46.160, Speaker A: And then now we'll deploy. All right, awesome. So uploading to IPFS and there we go, the dashboard.
02:24:46.160 - 02:24:55.970, Speaker A: All right, that's okay. We'll just keep on going. So just in case it happened, I have a recording of this.
02:24:55.970 - 02:25:16.730, Speaker A: There we go. We'll just go through this together like so we got right to here, to the deploy. And that was not working very well earlier, so I was having some difficulty on that.
02:25:16.730 - 02:25:25.212, Speaker A: All right, we went through this. We went through this and here we are. Okay, so we got the deploy going through.
02:25:25.212 - 02:25:43.330, Speaker A: So at this point we have the dashboard loaded and we could actually see the different entities that have been populated. Let's go ahead and dive into those entities right now through Vs code. Can you guys see that? Awesome.
02:25:43.330 - 02:25:52.416, Speaker A: Cool. So I'll just look at the screen and we'll go through this together. So we have the subgraph YAML, which is also known as the manifest of the subgraph.
02:25:52.416 - 02:26:04.240, Speaker A: It really defines at a high level what the subgraph is. I'm opening up all the three files right here so we could all just go one by one. The subgraph YAML has the smart contract in there that we defined through the CLI.
02:26:04.240 - 02:26:12.516, Speaker A: It also has a start block in there and has high level. You're naming the entities, you're not really going into all the properties of them. Also you're naming the event handlers.
02:26:12.516 - 02:26:20.296, Speaker A: It's just a high level overview to just understand what your subgraph is doing. It really is the manifest. So you can see we have that punk transfer defined.
02:26:20.296 - 02:26:30.192, Speaker A: Not defined, just named right there. Let's keep on tracing that punk transfer. So we'll go down to the automatically generated punk transfer handler which is named Handle punk transfer.
02:26:30.192 - 02:26:42.932, Speaker A: So you have an event being emitted from chain. And then from there, this is going to start populating the entity of which you will start querying. So you can see it's right here a Let entity equals new punk transfer type.
02:26:42.932 - 02:26:55.396, Speaker A: And now we have the entity being populated. The event params from becomes transferred or assigned to the entity from property. And literally it's just assigning blockchain data directly to the entity for your query.
02:26:55.396 - 02:27:04.280, Speaker A: Okay, so let's go ahead and look at where your front end queries will go. You have the Schema GraphQL. This is how you will query using GraphQL queries.
02:27:04.280 - 02:27:19.052, Speaker A: You have an entity with the ID from to punk index bytes, all that good information there for your front end to gather information from historical data. So once again, here we transfer. We went through the punk transfer event that is there for reference.
02:27:19.052 - 02:27:36.292, Speaker A: If you need ideas of kind of how to go through a little bit more advanced. Let's go into some queries right now, guys. So if you guys have time to start to learn a little bit more about subgraphs, use these questions and compare the questions that are here.
02:27:36.292 - 02:27:57.932, Speaker A: Could I answer these questions using the starter subgraph or do I need the more advanced subgraph? And like, how do you figure that out? How do you actually dive into that? Let's start with figuring out the punk transfers. The first ten in the history of crypto punks. So just going on to the right here through the Explorer, you can just go ahead and start sending some test queries and go.
02:27:57.932 - 02:28:12.844, Speaker A: And I wanted the first ten, so I ordered by the block timestamp and then I had order direction being ascending. And then we're going to send out that query for a test query. And this is the exact shape of the query on the left that you would send out to the API endpoint.
02:28:12.844 - 02:28:24.064, Speaker A: So you're just testing the queries in the playground, seeing what you want to do with that. So that was pretty basic question. The first ten transfers in the history of CryptoPunks.
02:28:24.064 - 02:28:36.970, Speaker A: Oh, yeah, I wanted to convert the timestamps to show you guys it actually is accurate. So you could actually confirm that this is the timestamp of the first transaction in crypto punk's history. 2017 on that date, on that time.
02:28:36.970 - 02:28:46.590, Speaker A: And what about the next one? Find the total value in e sales of all punks ever. Let's just start with that. All right, that's a pretty cool question.
02:28:46.590 - 02:29:03.936, Speaker A: Now with a starter subgraph, you're like, well, how do we get that? How do we actually compute that in this next subgraph? Through Jerry Ocolo, he developed this subgraph and extended it a little bit. And in a subgraph you can do a little bit of computation, you could actually do some processing. And in this subgraph he does that.
02:29:03.936 - 02:29:19.812, Speaker A: So what I'd recommend for you guys, figure out how he was able to compute that in his mappings. You can do that too. You can gather data from the blockchain and actually say, hey, I want this information to have a little bit of computation and publish this to the query, and then you can actually gather that data.
02:29:19.812 - 02:29:25.384, Speaker A: It really does the work for you in that way. It's really nice. So let's go ahead and go.
02:29:25.384 - 02:29:35.032, Speaker A: I'm looking for the question here. Find the total value in ETH sales. Jerry did very good documentation, and I'd recommend that if you are going to be going through this, you want to remember your computation.
02:29:35.032 - 02:29:48.352, Speaker A: So you go to the Schema GraphQL. Remember, this is the last point where you actually send your queries to your GraphQL queries. And on this, I'm looking for the total ease sales in the history of this.
02:29:48.352 - 02:29:52.480, Speaker A: I'm going through, going through. And I'm like, Wait a minute. Where is it? Where is it? I know it's here somewhere.
02:29:52.480 - 02:29:58.812, Speaker A: And there it is. Total ETH sales for Punk. So total sales forever.
02:29:58.812 - 02:30:18.250, Speaker A: That's not going to be on the blockchain. That requires some computation done in the mappings, and we don't have to dive into that right now, because what I want to do is just show you how you can go to the Schema GraphQL, query his subgraph, and we know it's on the contract. There we go.
02:30:18.250 - 02:30:30.492, Speaker A: And the ID is going to be the contract ID. He defined it like so not the ID, the contract address. There we go.
02:30:30.492 - 02:30:40.368, Speaker A: And we want the total amount traded ever, and then total Sales and total supply. He named these through the mappings TS file. He organically created these and documented very well.
02:30:40.368 - 02:30:51.252, Speaker A: Please go into his documentation and see how he did this. I want this to be a learning opportunity for you guys to see how a basic starter subgraph does it and how a little bit more advanced does it. A little bit of math, a little bit of diving into that.
02:30:51.252 - 02:31:19.618, Speaker A: So let's go ahead and continue on with the slides before I go on. We're doing good on time. Any questions thus far? Yeah, my question is just about the delay between the event publication on chain and the recording in the graph index four.
02:31:19.618 - 02:31:50.906, Speaker A: So how long does that take to have it indexed? How long does it take to index? Yeah, depends on how much you want to index. I mean, if you have a smart contract deployed, at a certain point, you define that start block, and then it'll start indexing. I mean, once it's already deployed, if you want systems that want very near real time information, like how fast is the response time? Yeah, last I heard on the network is around I think it's 42 milliseconds.
02:31:50.906 - 02:31:52.750, Speaker A: So it's pretty good. Okay. Yeah.
02:31:52.750 - 02:32:07.910, Speaker A: Okay, cool. And just one other question is about the tokenomics. If you want to run user graph, what does that imply? Good question.
02:32:07.910 - 02:32:11.142, Speaker A: It's removed at some point. Great question. Great question.
02:32:11.142 - 02:32:21.670, Speaker A: I'll go for this really quickly. Essentially, when you publish a subgraph to the network, you have to incentivize indexers around the world to get to work. So essentially you're saying, how much do I want decentralization in my stack.
02:32:21.670 - 02:32:33.146, Speaker A: If you only put a few tokens, you're not going to have a whole lot of indexers. Hop in and start indexing your subgraph. If you put in a good number that we're seeing across the board of 10,000 GRT, that gets many indexers to hop in and start indexing.
02:32:33.146 - 02:32:43.134, Speaker A: So it just depends on the indexer, their hardware, and the subgraphs that they want to index. They want to make sure their hardware can handle. Maybe you're deploying a massive subgraph, so you want to make sure that the indexer can handle that.
02:32:43.134 - 02:32:48.318, Speaker A: And so they have a choice on if they index or not. With 450, the market is pretty healthy. With diving in.
02:32:48.318 - 02:32:54.360, Speaker A: With any subgraph you publish and have a reasonable amount of GRT, you're going to get indexed. Yes. Thank you.
02:32:54.360 - 02:33:09.918, Speaker A: How can I integrate it into my dev? Do you have any SDK or whatever? So we have an API endpoint, and you can use we have what's called graph client Apollo. Those are two different options for you. And you can send queries through very it's nicely designed.
02:33:09.918 - 02:33:17.590, Speaker A: So, yeah, check out Apollo or graph client API key. Yes, there's an API key as well, and so I can go through that in a little bit as well. I'll help you out.
02:33:17.590 - 02:33:21.360, Speaker A: Yeah. Okay. Yes.
02:33:21.360 - 02:33:32.420, Speaker A: Quick one, how is the Schema designed? Is it a standard schema? Yeah, I mean, I can quickly go through that right now. Let's do that. So this is the schema right here.
02:33:32.420 - 02:33:43.250, Speaker A: Does that help answer your question? You can definitely customize it. You can extend it to your heart's content. There's reverse lookups, there's a lot of things you can do with this.
02:33:43.250 - 02:33:46.374, Speaker A: Yeah, that's a lot of power in there too. Yeah, good question. Cool.
02:33:46.374 - 02:33:49.240, Speaker A: All right, let's keep on going. I got seven minutes. Awesome.
02:33:49.240 - 02:34:07.658, Speaker A: Okay, so we're able to go through the punk transfer event all the way through, and you can see how just with the boilerplate code of subgraph being spun up, you have a lot of power already. To do a little bit more mathematics, you need Jerry's subgraph or your own creativity. Let's keep on going.
02:34:07.658 - 02:34:19.038, Speaker A: Like I said, these are for your reference. Go into this, slideshow that's in that repo, and you can actually learn a little bit more about patterns that you're commonly seeing in subgraphs and how people are using them. I'll just skim through these really quickly.
02:34:19.038 - 02:34:30.974, Speaker A: Please dive in on your own accord. And we already compared queries with two different subgraphs. And then finally, this is something that I'm really excited about because you guys are all builders.
02:34:30.974 - 02:34:35.718, Speaker A: Scaffoldeth two who's tried it, or even scaffold e one. I love it. It's amazing.
02:34:35.718 - 02:34:47.066, Speaker A: Yeah, there we go. Kevin. So Kevin back there has put in an amazing and also Simone has worked very hard together at building this repo right here.
02:34:47.066 - 02:35:04.362, Speaker A: I don't know why I said no more QR codes. That's just I apologize again, but this is a blog entry written by Kevin Jones specific to combining a Scaffold e two repo with a subgraph. It's all dockerized, it's all contained, and it has super fast feedback loop happiness.
02:35:04.362 - 02:35:15.774, Speaker A: That feels really good. When you are able to deploy your smart contract on hard hat, you're actually able to see the exact front end respond immediately and have a subgraph respond as well right away. It's this really amazing feedback loop.
02:35:15.774 - 02:35:23.800, Speaker A: So, Kevin Simone, cheers to you guys. Great work with this. And if I were starting in a hackathon, this is where I would go.
02:35:23.800 - 02:35:33.394, Speaker A: So workshop takeaways decentralized indexing is love. That's a good one. Deploy a starter subgraph in subgraph studio.
02:35:33.394 - 02:35:42.522, Speaker A: All right, just deploying a starter subgraph and querying it in your hackathon project is enough to get some money. So that's pretty cool. You don't have to do anything crazy, just a starter and query it.
02:35:42.522 - 02:35:47.050, Speaker A: That's awesome. You can trace an event. That's a really good way to learn.
02:35:47.050 - 02:36:06.586, Speaker A: You could start from front to back from the Schema all the way down to the blockchain, or go from the blockchain all the way to Schema and see how that is handled all the way through. Hopefully this video helped, this interaction helped. And then also really good way to learn subgraphs and subgraph development is just to play a starter subgraph looking at a smart contract and look at one a little bit more advanced.
02:36:06.586 - 02:36:16.200, Speaker A: And I provided that for you today so you could see how that's done. Compare how a little bit more advanced one is done with some good documentation and just you're off to the races, you're good to go. And Scaffold ETH is helpful too.
02:36:16.200 - 02:36:23.800, Speaker A: Okay. So if you would like to join the graph ecosystem, jobs, network roles and community, go ahead and scan here. I'll never say that QR code thing again.
02:36:23.800 - 02:36:35.690, Speaker A: And once phones are down or up okay. Oh, there we go. Cool.
02:36:35.690 - 02:36:40.750, Speaker A: We're good. All right. And Q and A.
02:36:40.750 - 02:37:02.044, Speaker A: All right. Yeah. I was just wondering, is it possible to have any access control over the entity mappings that you were showing? So there is the authentication that you have, so it is on your computer authenticated.
02:37:02.044 - 02:37:08.710, Speaker A: And so if there's anyone who's going to be hopping in, they need that authentication key. I showed mine publicly because that's my developer key. I don't really care.
02:37:08.710 - 02:37:20.320, Speaker A: But that would need authentication code. You just need to authenticate another computer role based access as well. So you could have access into the subgraph.
02:37:20.320 - 02:37:42.868, Speaker A: There are ways to have like a gnosis multisig that has access into a subgraph and can actually use it and alter it at the dashboard level. And also at the code level, you have the authentication that I copy pasted into the CLI. So anyone that has that authentication code got it by logging in appropriately either through the multi SIG and that allows a lot of people to use it and then copy paste into the computers that are appropriate.
02:37:42.868 - 02:37:50.146, Speaker A: Cool, thanks. Yeah. Yes.
02:37:50.146 - 02:38:23.758, Speaker A: I was wondering, is there a way to ask the indexer to simulate an event so that simulate an event? So to simulate the transaction and index the resulting event, this will have use cases like, for example, in uniswap, when you want to get the fees that are accumulating, you could just ask the indexer to simulate at several times. That's a good question. Let's talk I want to open that up a little bit.
02:38:23.758 - 02:38:25.386, Speaker A: That's a good question. Let's talk afterwards. Afterwards.
02:38:25.386 - 02:38:32.282, Speaker A: Is that cool? Perfect. All right. Thank you, Marcus.
02:38:32.282 - 02:38:45.760, Speaker A: Thank you so much. Hope you're here for the next presentation. Please keep your seat, and if not, thanks for stopping by.
02:38:45.760 - 02:42:29.970, Speaker A: Welcome to the Zikibob Workshop. Yeah, I'm Kiril Fidasev, one of the core developers at the Zikibob Protocol. And let's talk about how you can use Zigibob and how you can integrate it into your privacy applications using our privacy enhanced smart contract wallet, which is what Zigibob really is.
02:42:29.970 - 02:43:07.512, Speaker A: So at Zigibob Protocol, we really believe in this fundamental concept of personal financial privacy. We believe that it's crucial to have a choice to have this privacy and for people for users to have this option to decide which transactions they want to keep public and which they would prefer to really keep hidden private from the outside observers. We also believe that given though currently all the available blockchain infrastructures mainly support only public transactions and all the information is publicly available on the blockchain explorers.
02:43:07.512 - 02:43:45.480, Speaker A: And everybody is able to see the balances, the addresses, the transaction amounts, the history that is really inconvenient for most of the people who are getting onboarded from the traditional finance world where something as important as financial privacy is something that really exists. And yeah, we believe that this is one of the reasons that prevents the crypto world from getting widespread adoption, which is the lack of privacy. So at Zikibob, we are trying to address this lack of privacy by building our own privacy protocols, which allows to overcome these challenges.
02:43:45.480 - 02:44:17.876, Speaker A: So, yeah, let's dive into it. The Zigibov application is built on top of Zksnarx, and it really allows you to make these privacy preserving transactions which are fast and easy payments within all supported tokens, which you can perform by generating locally the Ziggy proofs. And yeah, within the Ziggybop, you can make the private deposits, you can transfer tokens freely within the pool, which are completely private and hidden from outside world.
02:44:17.876 - 02:44:52.190, Speaker A: And then you can also withdraw it back to the public blockchain, to your public wallet and continue using it in the DeFi from the already privacy enhanced tokens. The way it works is that once you send a transaction on Zikibob to perform some deposit transfer of withdrawal only you. And as a sender and the receiver of those operation which can be yourself or a friend of yours only they are able to access, decrypt and actually get something useful from this data.
02:44:52.190 - 02:45:28.200, Speaker A: And to understand what really happened within this transaction. So right now the Sikibob is available on Polygon and optimism layer twos, with more chains coming within the nearest future. And it supports BOP and USDC stable coins which are mainly used for salary payments and ETH token on the optimism for anything that requires privacy for Ethereum native currency, which might be the private contract deployments, which happens to be useful in some specific cases.
02:45:28.200 - 02:46:00.596, Speaker A: And we plan to add more chains and more tokens within the upcoming future whenever we are finding the demand for the Ziggybot privacy. So that's the sneak peek from our UI, we'll have a live demo of how it works later in the workshop. But really, yeah, our UI is quite simple and by using it you can deposit, transfer and withdraw freely by just as you would normally do within the MetaMask or any similar wallet, just through other web browser app, without any need to download anything.
02:46:00.596 - 02:46:34.616, Speaker A: All the Ziggybop proofs, Ziggy snark proofs are generated locally. So that is really that simple and convenient UI to use for your everyday needs to achieve this, a little bit of privacy. Of course, the opportunities you can use the Zikibob for are nearly limitless, but we trying to come up with a certain way of use cases for which people are already using Zikibob and what are we endorsing them to start using the Zikibob for? And these use cases typically involve anything related to the peer to peer transactions.
02:46:34.616 - 02:47:02.920, Speaker A: For example, when you want to split the dinner bill with your friends after hanging around, after the if global hackathon, you can use it for receiving and paying salaries and wages to your employees, both from the employer side and employee. It can be used for anything related with the grants, donation, fundraising crowdfunding or really any other use cases. You just want to make your payments in stablecoins ETH or any other tokens private.
02:47:02.920 - 02:47:35.040, Speaker A: So yeah, let's take the most common example for now, the way how the salaries can be transferred with Tikibob. So let's say we have our employer, Carl, who really wants to pay his employees on the public blockchain because he doesn't trust any centralized exchanges and he wants to keep all his budget, accounting and the salaries on the blockchain. But his employees really ask him to do this privately and that they would prefer to receive the salary also on the blockchain, but in some private way.
02:47:35.040 - 02:48:01.636, Speaker A: And so Carl found out about Zikibob and now he wants to start using it for salary example. So the way it works is that Carl just chooses the stablecoin he wants to use and can be Bob and can be USDC directly. Then he deposits this stablecoin inside the Zikibob pool, let's say once a month, and when on the salary day he's able to distribute all the salaries within one multi transfer transaction to his employee addresses, he obtained.
02:48:01.636 - 02:48:43.156, Speaker A: From the invoices and yeah, so he just needs to send once a month a single multi transfer within the Zikibob through our UI and then employees are able to freely withdraw in any amounts their salary on their public wallets once they want to do that. One of the features at Zikibob we think is really important for third widespread blockchain and privacy adoption is the good support for mobile devices when you can send and receive transactions on the fly when you don't have access to your desktop or laptop. So we spent quite the time to actually optimize Ziggybop application for mobile devices.
02:48:43.156 - 02:49:32.090, Speaker A: We made sure that the Ziggybop is usable on the mobile, that the proof generation works fast enough and now it takes only ten to 15 seconds to actually generate the completely private Ziggy proof in your browser on a mobile modern smartphone. Also, one of the cool feature we have with Zikibob is the integration with LiFi which allows you to actually perform any cross chain interactions from the chain and to the chains which are not natively supported by the Zikibob application. So you can really deposit and withdraw freely, not only from optimism and polygon, but you can simply connect to any other asset or chain within the same UI just by opening up the LiFi widget which is really cool and we are really happy to see how it all works.
02:49:32.090 - 02:50:12.896, Speaker A: And then the last point I wanted to discuss throughout this workshop is our accent on compliance side of things. So as regulatory requirements, as we've seen in the past couple of months, they became stricter towards any privacy enhanced application or protocol. We believe that's something that should be taken into account and as our mission, we see this goal of finding right balance and the compromise between the level of privacy you get as a user of the Ckbo protocol and the way of compliance the government or different authorities can expect from such kind of protocols.
02:50:12.896 - 02:50:42.108, Speaker A: So everyone kind of get what they want without hurting each other's painful points. And so at Digibop we are trying to build this compliance friendly tool which still supports the privacy within these transactions but then meets certain regulatory. So the way it works is that we employ several techniques within the Zikibob to support this compliance side of things.
02:50:42.108 - 02:51:05.552, Speaker A: So the first one is the address screen. So anytime you make a deposit or withdrawal to the Zikibob, we make sure that your address and your wallet passes the necessary ML requirements. So this way we can make sure that Zikibob is safe from the different malicious parties and users that can try to access and use the applications.
02:51:05.552 - 02:51:40.636, Speaker A: And right now we are using the TRML Labs provider for such ML screening for automated checks. But we are always looking forward towards any other integrations and new protocols which does similar kind of things. Then the way it works is that our checks are not only employed on the UI side of things, they are deeply integrated within the sequencers code so that malicious party are not able to access the protocol by bypassing the UI somehow they instead integrate it with the sequencers.
02:51:40.636 - 02:52:04.660, Speaker A: And sequencer is the only party which is able to directly access the Zikibo pool contract. Then the next important feature we had at Zikibop is this notion of optional KYC. So basically KYC is not a requirement for the Zigibop user and you are able to freely use Ziggybop application to the certain limits without any need in KYC.
02:52:04.660 - 02:52:37.780, Speaker A: But then if you're a big business who wants to pay the salaries or you're a big user who wants to transfer big amounts in order to raise those limits, there is this concept of optional KYC, which is something that you can pass. You can mint some soul bound NFT on your wallet, and then the protocol will automatically use this NFT as your access key towards these enhanced and increased limits. And right now we're using this integration with the opium know your cut protocol and underneath that it uses the binance pub soul bound NFT token.
02:52:37.780 - 02:53:00.036, Speaker A: And further down the line, we are considering multiple approaches towards further improvements on the compliance side of the Ziki bob. We are looking forward how we can employ and implement the selective deonmatization of user transactions if they're willing to do so. How users can generate cryptographically Verifiable account statements with their transactions.
02:53:00.036 - 02:53:25.004, Speaker A: How they can export and give someone read only account access keys and yeah, how we can support multiple ways, not only the binance pub tokens, but more on chain KYCs. So yeah, let's have a few words about the hackathon bounty we have. So yeah, one of the bounty is related with this direct deposit feature.
02:53:25.004 - 02:53:52.324, Speaker A: Basically it's a way how you can integrate the deposits towards stickybob protocol into any third party protocol smart contract, open source wallet. And its purpose is to minimize the required effort and the entrance barrier quadrant requirements needed for accessing these sticky bob deposits. The cool thing about direct deposits is that in order to make one you don't actually need to generate or communicate with our SDK to generate any snark proof.
02:53:52.324 - 02:54:42.510, Speaker A: You just need to submit a simple smart contract call which is something that you can do from any smart contract integration, any third party protocol and you don't need any SDK for that. So yeah, the way it works is that we have dedicated a separate smart contract which aggregates all those direct deposits and then which may come from all of those protocols on the left, it can be anything related to taxes, breaches aggregators wallets, anything related to the payroll. And then after all of these direct deposits are aggregated on the special contract, the sequencer will on its turn generate the patch ZK snark proof and actually include those deposits in the Zkbo pool contract where the receiver of those deposits and users will be able to access them a few minutes later.
02:54:42.510 - 02:55:00.544, Speaker A: So, as I said, the first bounty is related with the implementation and the integration of those Ckbop direct deposits. So we have basically any best use of this particular feature will get the price. So we have three places free, two and one k for each.
02:55:00.544 - 02:55:34.384, Speaker A: And then the second way of pound if you are not feeling well about integrating the ziggypop deposits into your own application because you have a bit different project that doesn't involve any stablecoin transfers, let's say then we have this open track price pool for basically anyone. Any team that is able to just go through the onboarding flow in the Ziggybob application, generate the receiving address, open an account, then we'll ask you a couple of feedback questions during the chat in session. And it really takes five minutes to be a part of this price pool.
02:55:34.384 - 02:56:03.088, Speaker A: So what we're going to do is just we'll take this four k and distribute it across all teams which completed the onboarding flow and basically created a Zikibob account. And just once again, a few ideas how you can integrate direct deposits into your hacks is to integrate with any open source wallet, let's say MetaMask snaps. It can be integrated with different taxes, bridges, aggregators, or any other smart contracts.
02:56:03.088 - 02:56:23.784, Speaker A: And any awesome ideas, of course, are welcome here as well. So, yeah, let's have a small demo of the Zikibob UI to see how it all works and what we can really do with it. So, yeah, we're going to log in into our T app.
02:56:23.784 - 02:56:39.120, Speaker A: We're going to select we recently deployed the Ethereum pool for Ethoken on optimism. So let's use it for the purpose of this demo. But really all the pools are very similar and you can use any of them in your hacks and in your workflows.
02:56:39.120 - 02:56:57.750, Speaker A: So we're going to connect our ZK account by using our web three wallet. So the UI is going to ask me to sign the message and then use my signature to generate the private key for my account. I'm going to skip the password for now.
02:56:57.750 - 02:57:22.900, Speaker A: Yeah, my ZK account is now synchronized and in the right upper corner I can see that I have public balance of some ETH and frapped Ethereum. And then I have also private balance, which is completely hidden and is part of the Zikibob pool smart contract. So now that I'm connected with my Ziki account, I can make the deposits of both ETH and frappept.
02:57:22.900 - 02:57:40.996, Speaker A: I can transfer it to different people within the pool who also created Ziki account. So let's just make a transfer to myself. So in order to make a transfer, I need to ask the receiver side receiver person to generate a receiving address.
02:57:40.996 - 02:57:55.848, Speaker A: So each time I click this button in the account tab, it generates and outputs me a random address. So the number of total addresses is limitless. So you can just generate a new one each time somebody asks you to send it.
02:57:55.848 - 02:58:13.800, Speaker A: So this way it helps you to preserve some level of privacy as well. Let's transfer some ETH. So yeah, what right now is happening is my web browser is using our SDK to generate a snark proof.
02:58:13.800 - 02:58:30.096, Speaker A: So on the laptop it should take about five to 6 seconds. On the mobile it takes about ten to 15. So yeah, right now proof is generated, it is submitted to the sequencer, and now sequencer has sent his transaction and yeah, it's already included.
02:58:30.096 - 02:59:01.180, Speaker A: And if you go to the history tab, then we'll see all the actions I have done few hours ago and 20 seconds ago I have completed this transfer. And of course all the history I see here is only I myself is able to actually decrypt this history and access those details to see what amounts to what addresses have been sent. And so the rest of information to the rest of the blockchain is hidden and stays private.
02:59:01.180 - 02:59:22.560, Speaker A: So, yeah, I can access my history and see what have I done within my account. So, yeah, let's now see how we can make the track deposit and how they can be integrated to your application. So the simple way to test track deposits is to through the Block Explorer UI.
02:59:22.560 - 02:59:44.270, Speaker A: So basically that's all we need. So I'm going to go to this awesome BlockScout user interface to see how we can send a direct deposit from there. So basically in order to send a direct deposit, I also will be required to get this receiving address, which is a different one from the one we used before.
02:59:44.270 - 03:00:10.070, Speaker A: So I'm going to copy that, I'm going to select the direct deposit function. I'm going to pass my CK address here. Let's say I want to deposit 100 of ETH and as a fallback user, I'm going to specify myself as well.
03:00:10.070 - 03:00:38.942, Speaker A: So yeah, basically these three arguments is all you need to send direct deposits on chain. And as you can imagine, this function call can be easily incorporated into any smart contract application, any protocol, and it's really that simple. So yeah, I'm going to send the transaction, let's see its details and we see that 0.1
03:00:38.942 - 03:00:50.470, Speaker A: E were transferred to the direct deposit smart contract. Now it will take some seconds for it to be displayed in the history. So yeah, let's wait and test.
03:00:50.470 - 03:01:03.606, Speaker A: How much time does it take for the graph service to synchronize this deposit. So, yeah, it's already here. I'm able to see that 30 seconds ago I made this deposit.
03:01:03.606 - 03:01:15.360, Speaker A: So we deposited 0.1 east, but some fee was subtracted on the smart contract level. And yeah, now I'm seeing that my deposit is pending and it will be credited to my account in like ten minutes.
03:01:15.360 - 03:01:36.484, Speaker A: So, yeah, that's how the direct deposits work. And we have a more extensive documentation on all of that in our documentation page within our docs on the Zigibob portal. So yeah, feel free to try yourself.
03:01:36.484 - 03:01:54.080, Speaker A: The Ziggybob application create an account, apply for our Bounties, check out the documentation regarding direct deposits, the SDK and the rest of the application on our stickybop website. If you have any questions, please stop by our booth. We also have some cool merge.
03:01:54.080 - 03:02:26.830, Speaker A: You can ask questions, have a chat with us and if you are not on site, you can freely ask questions in the discord channel of the ifglobal. So yeah, and yeah, I think we have a couple of minutes for onsite questions so I will be happy to answer. If I understand correctly, direct deposit is anonymized transaction.
03:02:26.830 - 03:02:57.014, Speaker A: So with direct deposit, if I understand what you're saying is you can anonymize A transaction. So maybe if we make an app here in a decentralized app and we want users to run our functions from our smart contract without knowing who they are, could we easily plug this in to make it work or not really? Yeah, I think you can. So basically the track deposit is a very simplified version of the deposit plus transfer combination.
03:02:57.014 - 03:03:30.130, Speaker A: So if you want to do kind of similar thing in the UI, the way it works is that you first need to deposit in order for that you need to calculate a snark proof and then you can make a transfer. But direct deposit just allows smart contracts to bypass this complicated flow with the snark proof generation and just call a function on the smart contract level, pass in a few arguments and yeah, it will do this deposit and transfer to the receiver side. So of course the sender address is public because the deposit is coming from the public network.
03:03:30.130 - 03:03:57.466, Speaker A: The amount can also be seen, but then the receiver is actually anonymous party, so nobody can really know to whom this receiver address belongs. What if I want the opposite? Since I have my smart contract with a function, someone needs to call it. I just don't want anyone publicly to know who is calling my smart contract.
03:03:57.466 - 03:04:07.566, Speaker A: Yeah, for that. So in the Zikibob we are using our own sequencer and some sort of account. Yeah, for your own builds and smart contracts.
03:04:07.566 - 03:04:19.110, Speaker A: There are a few services that does the same kind of similar thing. So there are a few frameworks for account obstruction, for meta transactions. So yeah, you can connect to any of those.
03:04:19.110 - 03:04:24.200, Speaker A: I think they also have bounty on this hackathon. So yeah, it might be done. Yeah.
03:04:24.200 - 03:10:39.420, Speaker A: Got you. Okay, thanks a lot. Thank you guys.
03:10:39.420 - 03:10:46.650, Speaker A: Hello. Hello. So today I'm here to introduce you cortesi roll ups.
03:10:46.650 - 03:11:11.170, Speaker A: I'm going to give you a quick overview of Cortezi, how it came to be, and a little bit of how the rollups itself works, what is the basic infrastructure that makes it possible. And I'm going to show you a few projects that have been built using cortez and other hackathons such as this one. So a sneak peek this is a Python code.
03:11:11.170 - 03:11:26.266, Speaker A: It's kind of like a script at this point, but it's basically a Cortesi DAP already. This DAP is an Echo smart contract. So it will be the equivalent of having a solidity contract that whatever it receives, it replies it back as an Ethereum event.
03:11:26.266 - 03:12:03.106, Speaker A: But here you can see that we are importing Python libraries, we are using HTP requests and how the fuck is that possible? Right? So Cartesi here I feel like this kind of public we don't need to explain the trilemma again and what AVM brought to us. Basically Ethereum brought some very interesting properties but it came out of concept scalability and EVM itself. It's a really good machine to embody the necessities of the constraints of a blockchain, but at the same time it limits our content capability.
03:12:03.106 - 03:12:50.706, Speaker A: So meaning that even if you by some magical reason manage to get much more output from the EVM, you're still constrained by the format of the machine itself. So the idea is what if we can have complex computations and blockchain security guarantees and still add great tooling to it? So basically, what if we can have web two ecosystem going back towards the blockchain? So the basis for that is two pieces. First Cortex is application specific, meaning that you can deploy this on top of any other network or on top of any other roll up.
03:12:50.706 - 03:13:00.546, Speaker A: It can be a zero knowledge roll up, optimisec roll up. As long as EVM compatible, this could be deployed on top. So it technically is a layer end solution.
03:13:00.546 - 03:13:16.894, Speaker A: And the second one is the Risk five deterministic machine. Because of this platform processor, which is an open source competitor to some extent to Intel Med, you can have an OS. So meaning you can have Linux back.
03:13:16.894 - 03:13:48.034, Speaker A: And in this way basically you're enabling the ability of having JavaScript, Python, SQLite databases, any of the other framework and tooling that we are used to to support our applications. Because the Cartesian machine itself is deterministic, meaning you can do interactive fraud proofs back on the base layer that you chose to deploy. So to be more visual, this is what it looks like to be coding for the EVM ecosystem.
03:13:48.034 - 03:14:11.040, Speaker A: Right now you have a very good Plier and sets of Pliers, but that's it, right? If you need to nail, you cannot really do it that properly. And Cortez is trying to bring back all the tooling that we used to have and that really looks like this. Your Cartesia DAP at the end of day is a docker build.
03:14:11.040 - 03:14:35.778, Speaker A: You basically do your recipe, your docker file, you build a docker image bundle that to the Cartesian node. Now you've created a node that is specific to your DAP, meaning you now have your application specific roll up and that's what it feels. You can have your favorite language, you can use complex libraries to do things that we just take for granted.
03:14:35.778 - 03:14:49.100, Speaker A: Like for instance, logarithm, you can have all these other frameworks, even that one star repo that sometimes just comes in so handy. You cannot really use that with solidity, really. Right.
03:14:49.100 - 03:15:13.934, Speaker A: And here is like an attempt to compare what it means to code in such platform when compared to EVM. So being very generous to the Ethereum network right now, you can have a maximum of 30 million gas per block. And the less expensive useful upcode would be add a subtraction which costs free gas.
03:15:13.934 - 03:15:36.140, Speaker A: So we're looking at 10 million instructions per block. That's being very generous, right? And to boot Linux, and we know this because we have all the inspections here, it's kind of small to read, it's about 36 million instruction cycles. So that's just Linux booting and being ready to do whatever you program it to.
03:15:36.140 - 03:15:58.266, Speaker A: And just to be fair, then we limited the Cartesi machine to 13 seconds execution, which be the average block time, right? And in 13 seconds on a laptop such as this one, you can have 3.7 billion instructions being executed. So the power that it brings back is very huge and it's even difficult to grasp.
03:15:58.266 - 03:16:13.810, Speaker A: So here's an image that helps you with that. That little black box over there is the Tamil Instructions of EVM compared to the 3.7 billion ones of a 13 2nd execution on Cortesi.
03:16:13.810 - 03:16:36.942, Speaker A: So how is the roll ups itself, right? An overall architecture here for people who are not familiarized, things don't change too much. I realize now the white contracts didn't work too much, but basically you're going to have let me see if my pointer here works. Yeah, you still have your connection with the JSON RPC here because it's still a roll up.
03:16:36.942 - 03:16:58.366, Speaker A: So to a certain extent, you're committing your information. You're committing your information to the chain for the roll up. So you don't have the impasse of the data availability and then the node that you build here represented as cortez roll ups framework.
03:16:58.366 - 03:17:28.410, Speaker A: You'll be digesting this information and that might be you as a validator, that might be the user as well, trying to verify whether or not you're doing something wrong. And as it digestes, it can create new outputs that go back to the theorem chain. So it might be, for instance, just the merker root for the state of the machine or might be like new transactions that will do like withdrawals, for instance.
03:17:28.410 - 03:18:02.710, Speaker A: And inside I chose to make a little bit of a highlight of this HTP roll up server here. So this is still a machine, linux doesn't know what the fuck it is doing inside there. Right? So to deal with the drives, to deal with the low level communication of halting the machine, getting a new drive, inputting the information that came in this new digest from the chain, then halting the machine again, getting this binary information of the output drive, interpreting it, and putting as an output to the ethereum chain, for instance, will be too much.
03:18:02.710 - 03:18:07.814, Speaker A: So we created an abstraction there. We created this. API rest API.
03:18:07.814 - 03:18:20.830, Speaker A: It's four endpoints. The documentation you can read in 30 seconds. And just by hitting these endpoints, you can have an abstraction of how to input information and output information into the chain.
03:18:20.830 - 03:18:35.262, Speaker A: So then all you need to do as a developer is really choose your language, communicate through this API and there you go. You can have a smart contract in the shape that you like. It can even be like a microservice.
03:18:35.262 - 03:18:43.000, Speaker A: I don't know what for, but if you choose to do so, you could. So talk is cheap. Let's go back to that code.
03:18:43.000 - 03:18:59.850, Speaker A: Not trying to explain every little bitty nitty gritty detail here, but to this side, to the left side, we created this little helper tool. It's similar to what forge have been trying to do. So you can sign transactions easily and call contracts.
03:18:59.850 - 03:19:11.870, Speaker A: For now, we just create this custom one. And with this you can send payloads as input or as Ethereum calls to certain extent. And you can read all the outputs here.
03:19:11.870 - 03:19:19.898, Speaker A: Notices. We call them notices because there's just one singular difference from the ethereum events. Ethereum events are not provable.
03:19:19.898 - 03:19:53.478, Speaker A: If I give you a payload for ethereum event doesn't mean anything without the hash addression. And really it only means something if you go through the chain and verify that actually creates the output, right? And notice have merkel proof attached to it. So as long as you have the root tree of the mercurialization of the machine being committed to the chain, from that merkel root, you can create the merkel proof for anything the machine creates, such as the notice.
03:19:53.478 - 03:20:02.830, Speaker A: So you can prove notices on chain. And here is just listing the new notices created at this epoch. And here's the thing.
03:20:02.830 - 03:20:19.490, Speaker A: So this program here should do the echo thing I was talking about, right? So from there, like I was saying before, you import requests because you're going to be doing Rest requests. You get it from the environment variables. We already put it there.
03:20:19.490 - 03:20:26.802, Speaker A: Easy for you. And we have two top level handlers here. You can create as many endpoints as you wish.
03:20:26.802 - 03:20:42.858, Speaker A: But these two top levels here, obligatory. Why? Because just like Ethereum EVM, there is two states of how to run the machine. There's one that will change the state of the blockchain and there is one where you're just trying to digest information from it.
03:20:42.858 - 03:20:58.750, Speaker A: So it's ephemeral. So if you get inspect state here as your request type, it means that no matter how much change you do to the machine, all of it is going to be thrown away. Just like on a hypervisor and VMs.
03:20:58.750 - 03:21:18.790, Speaker A: And if you got an advanced state, you really should be careful with whatever you're doing. Because however you stop the machine there, it's going to be the state that the machine will be for the next transaction. So this is still code, right? If you throw and you lose your process, there is no way for you to restart this.
03:21:18.790 - 03:21:41.386, Speaker A: It's kind of like self destruction, a contract or putting in a bad state. Just like the Parity wallet hack. And the only last thing I think it's worth mentioning more specifically is that every time you get this new request, you should reply back what was the final stage of the whole processing.
03:21:41.386 - 03:22:08.310, Speaker A: So you should go back and say status accept. If you say status reject or you don't reply for a long time, the hypervisor, quote unquote hypervisor will understand that something went wrong and it will tag that transaction as a reverse, so to speak, and it will revert back the machine. So here in this case, we would get the information here, we would unroll the JSON request.
03:22:08.310 - 03:22:24.710, Speaker A: We got to the advanced stage top handler. We didn't register any other handler, just this global one here. You see like I'm getting the payload, I'm just creating a new notice with the same payload because supposed to just be an echo.
03:22:24.710 - 03:22:42.820, Speaker A: And finally I just go to slash notice with that payload. I'm creating it, you can call it as many times as you wish, return the accepting I was talking about before and you close your loop. It's an infinite loop program in this case.
03:22:42.820 - 03:22:55.666, Speaker A: So you're always waiting here at Finish. So Finish is a special endpoint that will halt the machine. You don't need to do anything else, especially because this machine is deterministic and single threaded.
03:22:55.666 - 03:23:27.150, Speaker A: You don't need to be managing these scenarios, these edge case scenarios. So the idea here is really like you can further decentralize your DApps because sometimes adapts are not so decentralized because they lack CPU power or they lack the expression capability of putting there all the rule sets, all the necessary corner cases, handlings and everything. You can of course then express more complex logic.
03:23:27.150 - 03:23:46.166, Speaker A: And this extra processing power lets you leverage the traditional stacks that we had before. And it also as a new project, you should be thinking sometimes that the talent pool for web three people is really short. So maybe you can get started with two, three people.
03:23:46.166 - 03:23:59.306, Speaker A: But as your project grows, you need to hire more people. And it's way easier to tap into the web two talent pool, so it's easier for them to be onboarded with such technology. So let's see them box.
03:23:59.306 - 03:24:18.670, Speaker A: So I collected two examples here from previous hackathons and attempts of building things with Cartesi. And one of them was just at East Global Lisbon just before. And she was actually a track winner, track finalist.
03:24:18.670 - 03:24:42.578, Speaker A: And what she did was to put an LLM inside a Cartesi machine so she could have verifiability on the outputs produced by the LLM. Her concern was kids very soon will be using Chinesept and likewise tools to be learning about things just like Google. And at some point they might be questioning something like, okay, I'm going to run a marathon.
03:24:42.578 - 03:25:17.970, Speaker A: What should I be drinking to maintain myself hydrated, right? And then she wants to avoid this scenario where it goes like, oh, you should drink Coca Cola or you shouldn't drink beer. And not having the proof that this is happening and not having where to start to backtrack and see where did in this case, Coca Cola influenced the LLM model to be producing such a propaganda instead of its responses. So she created this, how to say, sandboxed on chain version of LLMs that can have the Verifiability.
03:25:17.970 - 03:25:34.418, Speaker A: The second one is a couriers one. So this guy, he wanted to intervene in the situation of clocking and clocking out into government offices. So it happens in many places, but especially in Brazil.
03:25:34.418 - 03:25:59.940, Speaker A: These guys, they find ways around the system to not be there, take longer vacations or be late every day and still show on the system that they are there by using silicone fingers or by bribing the guy that's supposed to ensure that nothing's going on wrong with the machine. So what he did is twofolded. And here what I liked about his example, is just what he could use, not exactly the example.
03:25:59.940 - 03:26:27.050, Speaker A: He used OpenCV to do the biometrics so he can identify the fingerprint of people. And he used a machine learning model to avoid the spoofing of the information, so he can detect whether or not there was silicone fingers used or reuse of images and things like that. And that was all running on chain, actually off chain, but being proved on chain.
03:26:27.050 - 03:26:39.178, Speaker A: Here we have this community website of Rolluplab IO. There's several examples using Cartesi there, it might trigger your curiosity. There's things from Dows to games.
03:26:39.178 - 03:26:52.914, Speaker A: It's really cool, resource. And at East Global here we are track as well. So we have up to $10,000 of prize pool, and I hope I can see you there.
03:26:52.914 - 03:27:06.498, Speaker A: I'm going to be at the booth. Me and my friends, we're going to give you all the support that you need. One final announcement is that we are launching on main ads next month, probably with a Honeypot DAP.
03:27:06.498 - 03:27:28.286, Speaker A: So the foundation is supporting this initiative where they are going to be putting money inside this DAP just as a target for hackers and other developers to try to steal it as a showcase of the security and the Vrfallability of the rollout framework. I thank you for being here. This has been nice.
03:27:28.286 - 03:28:01.186, Speaker A: It's always really good to be at East Global talking to interesting people. But before I go, I have one more thing. So a few months ago, this guy went to Twitter to say, if Ethereum is the world computer, why haven't we seen Doom running on it? Like, how so? Right? And one of our collaborators, core developer Eduardo, he, actually took it on and he put Doom to run on the Cartesian machine.
03:28:01.186 - 03:28:06.150, Speaker A: If you want to check it. Out. We are running actually a leaderboard downstairs at a booth.
03:28:06.150 - 03:28:10.700, Speaker A: You can play there. There's fo apps and stuff. Thank you again, guys.
03:28:10.700 - 03:28:56.092, Speaker A: Does anybody have questions? First of all, my first question will be how do you handle upgradability? Upgradability? Yeah. In a roll up, I mean in a cartesi roll up once you deploy the first smart contract, the DAP yes. How do you upgrade? What do you need to upgrade? For sure, I feel like we are kind of like in 2016 2017 Ethereum situation, how we deal with upgradability for Katasia as well.
03:28:56.092 - 03:29:19.104, Speaker A: But we at least one layer out in abstraction so we have more recourse. So one of the things that we already support is when you deploy your DAP, you can enable it to be upgradable or not on the smart contracts deployed on the chain. So like Ethereum for instance, and there it can really just point towards a new cartesian machine.
03:29:19.104 - 03:29:53.730, Speaker A: So really like changing everything just like a proxy would. It's still a question like what happens to the data? Are you upgrading from another one that you messed with? Did you open the Cortez machine to stay with the data, change the code and bundle it and release it again? Or it's really open because with this is so many possibilities, it's still up for debate. Like what is the best practice of how to be more clear transparent with the community as you do it? But you really can do a lot.
03:29:53.730 - 03:30:15.390, Speaker A: There is no singular answer for now. Will you be here during the hackathon so that we can ask you question about how to deploy this? Yeah, thanks. Besides me, there's two other technical people here.
03:30:15.390 - 03:30:27.316, Speaker A: Congratulations on the talk. Thank you. Are you recording the high scores of the doom on chain? Not so far.
03:30:27.316 - 03:30:38.136, Speaker A: I mean indirectly because of the poaps but the leaderboard itself is not like a singular contract with everything there not really. It was more like a demo for its global. Should have a bounty for that.
03:30:38.136 - 03:30:47.390, Speaker A: Sorry? Should have a bounty for that. Oh, true. We should negotiate a good price and get it done.
03:30:47.390 - 03:30:59.132, Speaker A: Any more questions? Hello. Quick thing. What wallets are supported or how does the wallet interaction flow look? Sorry, I didn't hear everything.
03:30:59.132 - 03:31:20.948, Speaker A: Yeah, the wallets that you support and what does the wallet interaction flow look? Because this is very sort of tooling around building the sort of payloads of smart contracts actually. How would you then integrate a front end to something like this, for example? Okay, so far it's really like just like Ethereum. All the inputs go through the chain so that much doesn't change.
03:31:20.948 - 03:31:41.340, Speaker A: So technically everything is very customized. There is no hard hat or Ethers for Cartesia. So in that sense there is like the graphical and rest API connecting directly to the node so you can have easier access to the information, just like you would for Ethereum node.
03:31:41.340 - 03:32:07.466, Speaker A: And that could fit in front and then all the inputs, they are just signed transactions to Ethereum. So there is no change. There is like the Catalan machine, like locked, for example, in the example you showed that it is requesting data from an API.
03:32:07.466 - 03:32:26.046, Speaker A: So if I imagine, okay, I can call any API, I would be able to change the state inside the machine? Or is it like boxed and you can only call? No, that API is just an abstraction to the communication with a chain. That's the only API you can call that will be talking to the outside. Everything else is sandboxed.
03:32:26.046 - 03:32:32.440, Speaker A: Even the API itself is running inside that machine. It's just really an abstraction. Okay, thank you.
03:32:32.440 - 03:32:38.900, Speaker A: Please give another round of applause for Gabriel. Thank you. Thank you.
03:32:38.900 - 03:32:49.400, Speaker A: We'll have Trevor in about five minutes. If anyone wants to leave, please do so now. Thank you.
03:32:49.400 - 03:42:05.380, Speaker A: Thanks for coming, everyone. So, my name is Trevor Porter. I'm a protocol engineer at Hyperlane.
03:42:05.380 - 03:42:30.088, Speaker A: And today I'm going to talk to you about permissionless interoperability, what that means and how you can use it in your hackathon project. So I guess just to set the scene, what Hyperlane is, is we're an abstract message passing bridge. So we allow you to send arbitrary bytes between two different blockchains, so two different smart contracts can interact with one another that live on different chains.
03:42:30.088 - 03:43:01.190, Speaker A: Using hyperlane, kind of the thing that differentiates us the most from competitors, kind of in the same realm, is we allow you to deploy hyperlane onto whatever chain you want. So if you want to be on a certain chain that doesn't have interoperability built in into it, today you can go to our competitors and they'll say, give us hundreds of thousands of dollars and we'll deploy onto you. Or you can just go to our docs, run a script, run some infrastructure that we provide out of the box, and you get connectivity with a whole network of chains for free.
03:43:01.190 - 03:43:20.184, Speaker A: So, to start with some definitions, so we call ourselves a permissionless and Modular interoperability layer. So permissionless can mean a lot of things. I think it's usually a marketing term, but to me it means that you can do something without anybody else's permission.
03:43:20.184 - 03:43:39.836, Speaker A: Right? But some people will claim that permissionless means that anybody can propose a hard fork to a network, which is definitely true, but it's still gated on the node operators in that network in order to create a hard fork. The idea with Hyperlane is you literally don't need to talk to us whatsoever. You can just go to our docs.
03:43:39.836 - 03:43:43.220, Speaker A: You can deploy it. It's easy as that. That's why it's permissionless.
03:43:43.220 - 03:44:01.300, Speaker A: Anybody can use it. And then interoperability, it can mean a lot of things to different people, but to me, it just means some kind of interaction between two different blockchains. So for us, we are an interface for sending bytes over the wire between two different chains.
03:44:01.300 - 03:44:26.418, Speaker A: You can build things on top of this, like token bridging, but fundamentally just that communication is what interoperability is. So to set the scene, why this is even important, we can look at the history of blockchains and where it's led us to today. So at the beginning we had bitcoin, and this is really great for payments, but it was not too great for many other things.
03:44:26.418 - 03:44:42.178, Speaker A: So people got excited by the idea of what you could do with blockchains. If you look, before Ethereum existed, people had ideas like creating something similar to ENS, but that required creating an entirely new chain. I think it was called name chain or something along those lines.
03:44:42.178 - 03:45:01.550, Speaker A: And you couldn't use the same security layer for building unique applications with just bitcoin. So then Ethereum came, and that was kind of the first fragmentation, or major fragmentation, where now you had bitcoin and now you had Ethereum. And Ethereum gave you the ability to create applications with the same infrastructure based layer.
03:45:01.550 - 03:45:20.926, Speaker A: But pretty quickly, the limits of Ethereum were hit. There's some serious scalability issues with just having a single blockchain like Ethereum that also imposes some very prescriptive trade offs on applications that are on Ethereum. So Ethereum wants everybody with a laptop to be able to run the entire chain.
03:45:20.926 - 03:45:39.420, Speaker A: But that comes at the cost of people not being able to have really high throughput on Ethereum. So in 2019, around that time, there was a lot of talk about things like Plasma or Sharding or all these different ideas. Some of them eventually turned out to be what we call roll ups today.
03:45:39.420 - 03:45:58.846, Speaker A: But we also saw the explosion of alt L ones. And people were moving to these alt L ones like finance smart chain, like Avalanche, like Salana instead of Ethereum, not necessarily because there was anything special about these blockchains, but because there was cheaper block space. And then new communities were created around this cheaper block space.
03:45:58.846 - 03:46:17.970, Speaker A: And this was the first kind of step of scaling. But as you scale in the paradigm that we've chosen to today, you create more fragmentation. So to me, there are three valuable things about blockchains, and it's composability verifiability and censorship, resistance.
03:46:17.970 - 03:46:39.310, Speaker A: And as you scale and create new block space, you give up composability. So interoperability between all of these is extremely useful in order to preserve that composability. So during all of this, things like Cosmos or ecosystems like Cosmos and Polkadot pioneered app chains which have kind of evolved into the rollup thesis today.
03:46:39.310 - 03:46:56.974, Speaker A: So specialized chains that have their own block space that allow for scaling outside of just the world of Ethereum. And eventually today we're at roll ups and there are various roll up ecosystems. There's the Ethereum roll up Ecosystem.
03:46:56.974 - 03:47:08.440, Speaker A: There's the Celestia roll up Ecosystem. There are still app chains in the Cosmos world. I don't think Solana is going like there are still all of these ecosystems that are being built, new chains, new block space.
03:47:08.440 - 03:47:30.154, Speaker A: And I think it's just an unavoidable future and as these things get more complex and all these new ecosystems arise, there's no good way of interacting between all of these. That is kind of one size fits all and people are migrating to roll ups. So DApps, like Zora, they recently launched a roll up cello.
03:47:30.154 - 03:47:52.500, Speaker A: The L One is transitioning to be a roll up. There's a lot of effort on the ethereum side toward growing the roll up ecosystem and there's a lot of discourse around roll ups that are using the same DA layer. So data availability layer of having better and more trustless communication with one another.
03:47:52.500 - 03:48:01.960, Speaker A: But this is still like super early stages. There's a lot of research going on there. It's not a one size fits all situation.
03:48:01.960 - 03:48:33.446, Speaker A: So we need interoperability between roll ups, between chains, regardless of what they look like today. And we can't really afford to wait for a future where there might be more trustless communication. So incomes hyperlay and further to set the scene, I guess just to explicitly say the common path of roll up to roll up interoperability today, if you're on optimism and you want to go to Arbitrum, you pretty much need to wait seven days to go down to L One and then you go back to Arbitrum.
03:48:33.446 - 03:49:01.100, Speaker A: And that's just unacceptable for the vast majority of these cases. So on top of this, there have been different protocols that maybe use an external verifying set to sign off on these messages between these roll ups or people who provide liquidity upfront for the destination on the roll up, knowing that they can wait seven days in order to get it in the future. But yeah, the general idea is all of these different roll ups, they look so different.
03:49:01.100 - 03:49:23.730, Speaker A: You might be familiar with storage proofs, which is kind of a hot topic in the ethereum community of facilitating better roll up to roll up communication. And the way those work is a roll up will learn about the block header of another roll up. Inside that block header lives an attestation to all of the state that lives on that roll up.
03:49:23.730 - 03:49:50.090, Speaker A: And if you come up with this proof to find out maybe what the storage slot is at a particular place in a contract in that storage route, you can read the state of another roll up within this roll up. But the problem with these is it's so specific to the implementation details of these roll ups that it creates fragility. If one roll up creates a hard fork, what happens to that bridge? It's fragile.
03:49:50.090 - 03:50:25.298, Speaker A: So what hyperlain does is we don't want to wait for a future where there are all these different types of message passing paradigms that may be further along in research, but look totally different and we can't have them today. So how do we get this today? We separate the transport layer and the application layer. So what does that mean? It means that hyperlane is an interface that is constant for all chains.
03:50:25.298 - 03:50:45.974, Speaker A: But under the hood the actual security that is used for these messages can change. And it can be different for different chain to chain connections depending on what is seen as what the application wants. Or we provide a default security model which might be the most trustless security between two different chains.
03:50:45.974 - 03:51:09.140, Speaker A: So to give an example if I'm on Ethereum L One and I want my application to send messages to Optimism, to Arbitrum, to Polygon, to Salana the last thing I want to do is do the legwork of integrating with each of those the roll ups, their native token bridge. I don't want to know the interface and the implementation details of that. I don't want a massive switch case statement saying this is my destination and this is the code that I want to run.
03:51:09.140 - 03:51:23.910, Speaker A: I want to just have the exact same interface. I don't want to know the implementation details of how it gets there. I just want to know, sure, maybe the security of that message but I don't want to know the interface into using that bridge.
03:51:23.910 - 03:51:42.062, Speaker A: So what we do is we have a contract called a mailbox that lives on each chain. And this mailbox is the single interface for sending messages to other chains or receiving messages from other chains. And then applications and this is where the term modular security comes in.
03:51:42.062 - 03:52:09.800, Speaker A: Applications can opt into what security they want to use for messages that they receive. And this is super powerful because as new research comes out you can kind of just change configuration and you get the new research, the new products, the new fancy ZK proof completely for free. But today you can launch and still be equipped to use that in the future.
03:52:09.800 - 03:52:37.342, Speaker A: So concretely, if you use hyperlane between L One, Ethereum and Arbitrum today you'll be using the native token bridge, which is trustless, or the native bridge, which is trustless. But maybe if you were to go from Ethereum to avalanche there isn't a great trustless interoperability solution there. So you'll use a different type of security, other things you can do with this.
03:52:37.342 - 03:52:54.040, Speaker A: So I guess to go into the details of how it works on this destination side well, the general idea is you call in on the origin into the mailbox's dispatch function. That's how you send a message out from a chain. It emits that message.
03:52:54.040 - 03:53:15.290, Speaker A: There's some off chain infrastructure that you don't really need to worry about that listens for these messages and then comes up with the appropriate proofs in order to deliver these messages on the destination. And the way that they deliver this is by calling a function on the mailbox called process. And then that mailbox will call the recipient's handler.
03:53:15.290 - 03:53:42.082, Speaker A: And there's a step that I missed there which is the mailbox needs to know what kind of security that recipient requires and the way that a recipient defines, that is through this thing called an interchange security module. And all this is is a view function on the recipient that returns the address of some smart contract that encoded into it, has the rules of how to verify this message. And this is the step five right here.
03:53:42.082 - 03:53:49.954, Speaker A: So you pass in two parameters into verify. One is metadata. And this can be anything that is specific to this interchange security module.
03:53:49.954 - 03:54:11.950, Speaker A: You can imagine it as, like, validator signatures over a message or maybe a proof verifying this message. It's some kind of off chain data and then the actual message that was sent. And the cool thing here is that you can actually tweak the security that you want depending on the contents of the message as well.
03:54:11.950 - 03:54:50.460, Speaker A: So if my application is a token bridge that I've built on top of Hyperlane and somebody is sending $10, do I really require them to have the most stringent security for that if that security has, like, a monetary cost, probably not. So I could choose for a really low value transfer to maybe require, like, an M of N validator signatures over this message. But if there's a million dollars going over, maybe that's where I'm willing to put a cost onto the user, where they have to process a more expensive proof in order to verify that this is correct.
03:54:50.460 - 03:55:11.360, Speaker A: And like I mentioned, this is future proof. So as new things come out, you can really easily just change out the transport layer under the hood without having to make any changes to your application. So, yeah, this all kind of leads up to our special sauce, which is permissionless deployment.
03:55:11.360 - 03:55:41.336, Speaker A: So in a world which I think we're seeing, where there are countless roll ups as a service companies, a bunch of new roll ups being created each day, new chains, whether in the Cosmos ecosystem or elsewhere, there's just this explosion of chains that's occurring in this last year. Like speaking to so many people here, there are a lot of new chains being created as well. And there's this problem of, like, when you create a new chain, it's this entirely isolated ecosystem.
03:55:41.336 - 03:56:10.500, Speaker A: And the first question that clients of roll up as a service companies ask is, how do I tap into the rest of the ecosystem? And if you are, let's say, an Ethereum L Two, you get a lot of that through the native bridge. But if you're a Celestia L Two, because Celestia is just a data availability layer, they don't have any kind of smart contracts on the L One. You don't really get any benefit of that native token bridge to bring in liquidity into your chain.
03:56:10.500 - 03:56:25.320, Speaker A: So what Hyperlane provides is just go to our docs. You can do it. If there's a chain that you guys want to deploy hyperlain onto during this hackathon, it's as simple as just going to our docs, running some scripts, and then running some infrastructure.
03:56:25.320 - 03:56:42.252, Speaker A: I've talked with many, many teams who have asked our competitors to go under their chain. And the answer is pay us money. And I think that's just not quite in the Ethos of crypto.
03:56:42.252 - 03:57:03.120, Speaker A: If you look at Uniswap, for example, the reason why it got so big and why it's to this day still pointed to as a great example of what DFI is and can be for everything. It's the permissionless nature of it. It's the fact that I could just go to the Uniswap V Two factory, call a function and create a new pool.
03:57:03.120 - 03:57:30.470, Speaker A: So unlocking the long tail of assets and the long tail of chains, I think is going to be of extreme importance to this industry as we lean heavier into roll ups. So just to talk a little bit about things that you can play with and build on top of hyperlane, so it's all fine and dandy. Like, let's say you're a new chain.
03:57:30.470 - 03:57:43.500, Speaker A: You deploy hyperlane onto your chain. What you get out of the box is bytes over the wire. But what can you do with bytes over the wire? You can build applications on top of that and really anything that you want.
03:57:43.500 - 03:58:09.678, Speaker A: But an example of that is just basic token bridging. We have our own twist on token bridging called Warbrouts. And instead of like a classic Token bridge so a Token bridge when I say this, it's like a lock and mint kind of thing where on the origin side, let's say I have a Token, I send it into some contract where it's escrowed, some message is sent to the destination chain and then a new token is minted and given to me.
03:58:09.678 - 03:58:36.990, Speaker A: And that new token we generally call a synthetic token because it relates to the existence of a remote chain's, real canonical token. In a classic token bridge, they usually have a security model that they impose on the entire bridge. And it kind of turns into this honeypot of like this is like a specific one size fits all security model that is being forced onto this token bridge.
03:58:36.990 - 03:58:58.420, Speaker A: Whereas with warp routes, it works for permissionlessly deployed chains and it allows the deployer of a warp route. So the deployer of this bridge token to specify what security they want for it. So it's kind of like a tool in order to bring tokens onto your chain in the terms that you want to.
03:58:58.420 - 03:59:07.858, Speaker A: So we have three different classes of these. So there's a native warp route. And what this means is, let's say you're on L One Ethereum and you have ETH.
03:59:07.858 - 03:59:18.858, Speaker A: ETH is the native token. So there is a smart contract called a native warp route in which you just send your ETH in there you call a function. Your native ETH is escrowed in there.
03:59:18.858 - 03:59:37.250, Speaker A: And then that's where the message is sent to the destination chain, where then a synthetic token is minted. We have the collateral version, which is for an existing token that isn't the native token. Similar idea, escrowed and then Mint.
03:59:37.250 - 03:59:54.566, Speaker A: And these are particularly useful for chains. Let's say it's a roll up that maybe wants like, AVAX on its chain. So you have a bridge that is lock and mint in structure that you get to define the security parameters for and you get to deploy yourself.
03:59:54.566 - 04:00:04.858, Speaker A: So we offer scripts to deploy these things really easily. We offer a UI that you can customize to look however you want as well. That's what that screenshot is there.
04:00:04.858 - 04:00:44.952, Speaker A: And it all just kind of works end to end out of the box. Circle, how does that relate to yeah, great question. So, yeah, Circle supports native transferring between two different chains.
04:00:44.952 - 04:00:56.620, Speaker A: I think today it's Ethereum and Arbitrum or Avalanche and Arbitrum as well. Ethereum, avalanche and Arbitrum. So those three and yeah, this is great.
04:00:56.620 - 04:01:19.008, Speaker A: I think you should use this instead of warp routes because Circle is attesting to the validity of all of these tokens and they've blessed these tokens on all three of these chains. And I think you'll actually see a continuation of this for the very popular Fathead chains. These kinds of tokens will have canonical representations on those chains.
04:01:19.008 - 04:01:38.540, Speaker A: But for the long tail of chains, circle is not going to support some random roll up out of the box because they have no incentive to. So that's where hyperlain warp routes would come to play. And that kind of also plays into our eyes being set on permissionless deployment for these long tailor chains.
04:01:38.540 - 04:02:16.570, Speaker A: So in that scenario, the canonical USDC token on Arbitrum, you could bridge that to my roll up if you wanted. And in that scenario, the USDC would be turned into a collateral warp route on Arbitrum, and then it would be sent over to my roll up, and then it would be minted to me as a synthetic token. So I think these things aren't mutually exclusive, and I think the trend of long tail chains having canonical representations for these kinds of centralized stablecoins will continue as well.
04:02:16.570 - 04:02:47.262, Speaker A: Does that kind of answer it? Yeah. So, like follow up with USDC, that's not synthetic USDC? Yeah, exactly. If it's not the canonical one in our jargon, and some people use it differently, that's a synthetic token.
04:02:47.262 - 04:03:07.680, Speaker A: So it's like pegged to the value of a token that exists on a remote chain. Cool. So a couple of other things that you can build or play with, that we've built for you that are really cool primitives are these things called interchange accounts and interchange queries.
04:03:07.680 - 04:03:46.176, Speaker A: So this is borrowing from the Cosmos ecosystem where they have these same primitives, but for context, the Cosmos ecosystem, they have this really robust way of communicating between chains called IDC. But the implementations today are very specific to the Cosmos ecosystem. So it only really works for these chains that have the same kind of consensus mechanism, whereas hyperlain, it works anywhere in any kind of execution environment so we can look at kind of the cool primitives that they've played with and built already and then bring it to the rest of the ecosystem.
04:03:46.176 - 04:04:05.976, Speaker A: What interchange accounts are is a smart contract wallet that lives on remote chains that is controlled by a smart contract on an origin chain. So an example of this could be like a Dao, for instance, that lives on Ethereum. They can control a smart contract wallet on some remote chain.
04:04:05.976 - 04:04:31.060, Speaker A: They can own contracts through that, they can call contracts through that. They can own tokens, they can own native tokens, they can do anything. And another cool thing about this, there's this word called like counterfactual addresses, which are addresses that you can generate and know what that address is without actually creating it or requiring any action from the owner.
04:04:31.060 - 04:05:01.570, Speaker A: So an example of this is like if you're familiar with create two, if you know the bytecode hash and then assault in order to deploy this contract, you know that it'll exist at a particular address. And the importance here is then like the uniswap Dao, if they wanted to use interchain accounts, they don't need a Dao vote in order to create one of these. They can just know that they own this theoretical address that exists on a remote chain without any kind of action on their part.
04:05:01.570 - 04:05:26.036, Speaker A: And then there's this thing called interchange queries which allows a smart contract on one chain to query some state on a remote chain and then get it sent back to it. So maybe I'm on my roll up and I really want like chain link price feeds. I can use interchange queries to query the current chain link price feed that lives on Ethereum.
04:05:26.036 - 04:05:42.190, Speaker A: And then I get back a call into one of my functions with that value. Yeah, I'll leave it here for any kind of questions. I was thinking I could do a live demo, but I don't have the time.
04:05:42.190 - 04:06:06.224, Speaker A: But yeah, if I were to ask you guys to have one takeaway from this, it would be that hyperlane is the only permissionless interoperability project. And yeah, we're excited to kind of hear you guys feedback about it. If you're deploying any chains or if you have any cool ideas around modular security that you guys are going to play with.
04:06:06.224 - 04:06:18.330, Speaker A: I think there are just so many things that I would be doing during this hackathon on Hyperlane. So if you have any ideas that you want feedback on, feel free to let me know. Happy to take any questions if you guys have them.
04:06:18.330 - 04:06:50.938, Speaker A: Oh, we have a booth downstairs as well. Yeah, I have a question related to Bridging that you've called Warprod. Basically, what's your take on Bridging data? I mean, not just related to Tokens and NFTs, but everything else.
04:06:50.938 - 04:07:21.666, Speaker A: Like, how do you do everything else? Yeah, so Hyperlane just allows you to send anything over the wire so you can send if there's like KYC data on one chain or something like that, you can send that to a remote chain. You can even have applications that are natively multi chain, meaning that their state kind of exists on these two different chains or multiple different chains, kind of like a distributed system type deal. And yeah, I think there are just so many interesting things that you can do.
04:07:21.666 - 04:07:48.430, Speaker A: On top of that, you can have MultiChain liquidity layers, so you could have some kind of protocol where you have pools on different chains. And when you want to go from token X on chain A to token Y on chain B, you use an abstract message passing bridge to first do that swap, then send the message over to the destination, do another swap, things like that. So I think there are so many things that are super, super underexplored.
04:07:48.430 - 04:08:12.958, Speaker A: I will say once you add Asynchrony into building these applications, so when you just write a normal smart contract today, you have a lock on everything that's happening on that blockchain. And that means that you can interact with all these smart contracts and know that there is synchronicity in all of these interactions you have. And if it reverts that no state changes will occur.
04:08:12.958 - 04:08:29.274, Speaker A: Once you add Asynchrony in here, things get a bit harder. So it does require a little bit of careful design in what these messages do and maybe you'll want timeouts for these messages and like a failsafe, but yeah, there are a lot of cool things you can do with it. Yeah.
04:08:29.274 - 04:08:46.666, Speaker A: Thank you. That answers the question like do anything. Yeah, basically a round of applause for Trevor.
04:08:46.666 - 04:08:55.620, Speaker A: Thank you. We will be having one more talk at 630 by Safe. So please do stick around for that if you're interested.
04:08:55.620 - 04:11:55.762, Speaker A: Cool, thanks. Okay. Yeah, welcome to my talk.
04:11:55.762 - 04:12:07.080, Speaker A: If you've been here earlier at 330 at the talk, it will be the exact same talk. There was just an issue with the recording. So yeah, we are rerunning the talk.
04:12:07.080 - 04:12:23.530, Speaker A: I'm manu from safe. I'm working at Safe Wallet, so working as a front end developer for the wallet interface. And this talk will be mainly about building with SafeCore SDK, but we'll also shortly look into the Safe protocol kit.
04:12:23.530 - 04:12:31.680, Speaker A: Okay, sorry. Yeah, let's quickly talk about Safe. Like, most of you probably know Safe already.
04:12:31.680 - 04:12:44.846, Speaker A: If you never heard of Safe, you've probably heard of nosis Safe. It's an old school multisig wallet which launched in 2018, already in the first version. But it's way more than just a multisig wallet.
04:12:44.846 - 04:12:59.746, Speaker A: Basically, we are trying to push the account abstraction narrative because Safe is also an ecosystem and a protocol. So that means there's multiple depths already building on Safe or using Safe under the hood. For instance.
04:12:59.746 - 04:13:06.330, Speaker A: WorldCoin is also here. Like they're using safe. Every WorldCoin user is also a Safe user, so to say.
04:13:06.330 - 04:13:34.034, Speaker A: And this talk will be about Safe course decay. Safe course decay, simply put, is a TypeScript SDK so library just with helpful wrappers for better developer experience when you build on Safe or when you try to integrate with Safe contracts. Yeah, talking about Safe we restructured the company or the project a little bit.
04:13:34.034 - 04:13:43.030, Speaker A: So we split into two groups. SafeCore we will talk about it more in this talk and Safe Wallet. That's where I work at Safe.
04:13:43.030 - 04:14:05.430, Speaker A: Safe Wallet is mainly responsible for maintaining the interfaces. That means the web wallet or the web interface for the wallet and also the Android and the iOS app displayed here in the screenshots. While SafeCore is responsible also for multiple things, you can split it into like three groups.
04:14:05.430 - 04:14:33.758, Speaker A: The first is the SafeCore protocol. We will talk a bit more about it in a bit. It's basically the smart contracts powering Safe, then the SafeCore API that's mainly the transaction service, it's called some other services, but mainly It's services which for instance index save transactions, which index created Safes and which offer an API to quickly query which Safes are deployed.
04:14:33.758 - 04:14:54.540, Speaker A: What are the setups for a Safe so you don't have to fetch all the data on chain all the time and then the SafeCore account abstraction SDK yeah, I already mentioned it. It's like this TypeScript SDK just wrapper around the Safe smart contracts, wrapper around some account abstraction kits. We will talk about it in a little bit.
04:14:54.540 - 04:15:07.018, Speaker A: Let's start with the SafeCore protocol. It's quite new. Previously we also used to call SafeCore Protocol or Safe Protocol the set of smart contracts which are right now deployed in prod.
04:15:07.018 - 04:15:16.180, Speaker A: But we are pushing for a new SafeCore protocol soon. Right now it's in an alpha state. It was announced yesterday at ECC, the first time in public.
04:15:16.180 - 04:15:34.082, Speaker A: And it's basically this architecture. So it's a new framework or a new protocol around smart accounts. And the idea is that it's split between accounts registries and integrations where accounts are smart accounts at the beginning it will be Safe supported.
04:15:34.082 - 04:15:50.142, Speaker A: But the idea is that also other smart account developers or other smart account wallets could plug into this protocol and then also use the same plugins and registries. So it's not just bound to save. What are registries? It's quite simple.
04:15:50.142 - 04:16:07.390, Speaker A: Registries is just a registry where we have audited or sets of audited contracts. These contracts are these integrations. So it's always a bit tricky to know, okay, which of these plugins can I trust? Right? And that's why we need registries.
04:16:07.390 - 04:16:22.642, Speaker A: But there could also be multiple registries. It could be by multiple DAOs by multiple protocols just so that you know who audited it and who you can trust for integrations. Plugins are very similar to modules which already exist in Safe.
04:16:22.642 - 04:16:58.180, Speaker A: So it enhances a Safe by some new functionality which isn't there in the core contracts or in the native contracts hooks plug into or hooks hook in to the transaction lifecycle. That means there's like callbacks for lifecycle events for instance like pre execution or post execution and also some other events and you can implement what should happen or what should get checked there. Right, so you could build some security feature where you revert a transaction if some condition is not met, post execution or something similar.
04:16:58.180 - 04:17:24.438, Speaker A: Yeah, function handlers and signature verifiers is what currently is implemented in the fallback handlers in the compatibility fallback handler it's called in the current safe contracts. So for instance a signature verifier, that's where the 1271 signature check is implemented in. So if you want to build something more sophisticated in the signature check, for instance, you could use it for DEXes, for like, smart orders.
04:17:24.438 - 04:18:26.590, Speaker A: You could check some oracle if some price conditions are met, and only then you could say that the signature is valid and otherwise the one inch or the cowswap order would not be able to get executed or whatever other decks what is contained by the registry. Are there registry integrations? The registry basically registers these plugins hooks, et cetera so that you have like a source where you can check which plugins exist and the plugins also come with some metadata on chain like how's the plugin called, which version is it? So basically it's a way to find and discover these plugins also while at the same time bringing security because you could have a registry which is quite strict about that. Every plugin needs to be audited and whatever while another registry might be less strict but in a way if you trust the registry or if you know a registry with high security standards it's also a security feature but it's also for discoverability of plugins.
04:18:26.590 - 04:18:54.520, Speaker A: I will show a quick demo to a very quick demo. Yeah, if you want to more information, we updated the docs today so if you checked the save docs yesterday, please check them again. Also, there's some other changes because we just deployed a new version of the Con abstraction kit and yeah, for the demo, I will quickly switch to a new browser tab, make it a bit bigger, I hope you can see.
04:18:54.520 - 04:19:12.286, Speaker A: Yeah, basically the demo, which is also linked on the docs, so you can try it yourself. It's basically application, it's deployed on a GitHub page also, or you can run it locally and you can add it as a custom Safe app to your safe. Important.
04:19:12.286 - 04:19:25.486, Speaker A: As I mentioned, it's alpha, so it's only on Gurley right now, because we don't want a false sense of readiness for this feature. Right. So we don't want people to actually use it with actual funds because it's still in a very alpha stage.
04:19:25.486 - 04:19:47.350, Speaker A: So yeah, you can add it on the gurdisafe and then you can open it, you can see the available plugins. So this list of plugins that comes from one test implemented registry so that's why I meant it helps for exploring plugins, for instance, or hooks, for instance. And here you could now enable some of these sample plugins.
04:19:47.350 - 04:20:04.298, Speaker A: Or there's also an example for a relay plugin which relays transactions through gelato paying the fee from the safe and it can also pay in ESA 20 tokens. I will not show them more in detail because the talk should be more about the con abstraction kit. But I want to mention it because we have bounties about this safe core protocol.
04:20:04.298 - 04:20:23.906, Speaker A: So if you have further questions, please come to our booth or use our discord and then we can talk about them or check out the demo yourself and then you can also try to relay with it. Let's go back to the slideshow. Okay, let's talk about the account abstraction SDK.
04:20:23.906 - 04:20:44.358, Speaker A: So I mentioned it's a TypeScript library and it consists of multiple kits and every kit has multiple packs which are kind of the implementations. So the kit is kind of the interface for a certain feature while the packs there can be multiple for certain integrations with it. So the Oskit is the first as the name says it's for authentication.
04:20:44.358 - 04:21:11.342, Speaker A: That means it's a kit to create an ethereum address which then becomes a signer of a safe. So currently you can for instance use a social account or your Google account or your Apple ID to create a signer using MPC through a provider and use that as a safe signer for deployed safe. Then the protocol kit like the protocol again are the safe contracts.
04:21:11.342 - 04:21:40.606, Speaker A: So this is a wrapper around the safe like you need to give it a signer and then you can sign transactions, send transactions or deploy saves also to this kit. Or for instance you could also deploy a safe and already do a transaction in a batch with it. Then the Onram kit as a name says it's quite simple you can buy crypto with fiat and put it and fund your safe address through it.
04:21:40.606 - 04:22:04.866, Speaker A: And the relay kit I already also mentioned the provider like Gelato. The idea is that you don't pay gas from your EOA or from the executor of the transaction or from the signer of your safe but you for instance could pay directly from your safe or through something like a third party provider which offers to pay the gas for you. Here are some examples of the current existing packs.
04:22:04.866 - 04:22:19.930, Speaker A: We plan to also extend these packs by new providers as we go. So for the offkit currently we have the web three offkit. It uses Web three Auth IO to create a signer using NPC from your social account.
04:22:19.930 - 04:22:42.530, Speaker A: Like I mentioned, the Stripe pack it only works in the states currently because Stripe is only available in the states for on ramping. But that works and the Munarium pack is quite new. I don't know if you heard of Munarium but they are in Europe and they use a euro stable coin and you can on ramp to a bank account which is then connected to your Safe.
04:22:42.530 - 04:22:57.190, Speaker A: And the Gelato Relay pack uses gelato to relay. You can pay directly from your safe with it or you can also pay through one balance. Yeah, we also plan to add more kits in the future.
04:22:57.190 - 04:23:16.830, Speaker A: Like right now we're looking into recovery kits or a MultiChain kit. Like a recovery kit is, as the name says, to recover the safe if you lost access to a signer, for instance, or to add a custodian. If you use a custodian service, then it's like half not self custodian anymore.
04:23:16.830 - 04:23:39.570, Speaker A: And the MultiChain kit, we're also looking into supporting MultiChain better for Safes because right now Safe is only deployed on one address always. And it's a bit tricky to interact with multiple Safes on multiple networks. And of course, as the future will tell, we will also have more topics which are important and add more kits to this SDK.
04:23:39.570 - 04:23:52.962, Speaker A: Yeah, the SDK is deployed or is available on GitHub and on NPM. It's called Safe Core SDK from Safeglobal and it consists of these mentioned packages. Like, here's also another list of the packages.
04:23:52.962 - 04:24:06.250, Speaker A: And the only one I didn't cover before is the Save Core SDK types. The Safe Core SDK types are basically just like some TypeScript types which are used across the other kit so we don't have to copy paste them everywhere. So just some types.
04:24:06.250 - 04:24:13.680, Speaker A: Yeah. Let's also do a quick demo of the kit. Like we have a demo app, you can also try it yourself.
04:24:13.680 - 04:24:28.030, Speaker A: It's a small react app. I hope it's big enough. I'll zoom in a yeah, in this demo you can use some test network, for instance, like Mumbai.
04:24:28.030 - 04:24:34.766, Speaker A: You can start the demo I already did before. I hope the WiFi will work properly. And you can try out the different kits.
04:24:34.766 - 04:24:43.638, Speaker A: Like this is the Auth kit. So this is the Web Three Auth model which opens and you can say you want to continue with your Google account, for instance. Then you log in with your Google account.
04:24:43.638 - 04:24:55.750, Speaker A: It will create the signer key from it and the signer address and takes a bit. Okay, here now we see the owner ID. That's the signer connected to the Safe as an owner.
04:24:55.750 - 04:25:10.990, Speaker A: That's the ID generated with Web Three Auth and the Safe account is deployed with that owner. And we also see the address here in this small demo app. It also shows like some code snippets on how this is built.
04:25:10.990 - 04:25:24.318, Speaker A: I mean, it's not the exact code, but you can also check the demos, also open source to see the exact code. But this is basically to explain how they work. So here we import the Web Three kit or two objects from the Web Three Alt kit.
04:25:24.318 - 04:25:32.038, Speaker A: Then we need a bunch of options. They come from Web Three Al, so they required on Web Three also site, like the client ID. Like you need to register as a customer.
04:25:32.038 - 04:25:39.434, Speaker A: Then you get a client ID. You have to put it here. Or you also can configure which chains should be used.
04:25:39.434 - 04:25:54.154, Speaker A: And then some UI options which are not super important and self explanatory. Yeah, and some other small options for Web 3 hours. And then in the end, it's always a similar structure.
04:25:54.154 - 04:26:12.478, Speaker A: Like as I said, the interface is basically always the kit and the packs are the implementations. So here we initiate the Web Three o's model pack and then we initialize the kit with this pack. And then we have methods like sign in, sign out, get provider, et cetera.
04:26:12.478 - 04:26:25.560, Speaker A: I can use those to interact with the safe. Then next is the Onram kit. I can sadly not show it because right now we only integrated stripe in this demo app because Minarium just launched, I think last week.
04:26:25.560 - 04:26:42.046, Speaker A: But basically if you click on it, we can see the model, but it won't work because we're in Europe right now. If you want to try this, there will also be a link if your safe has no funds yet to the Mumbai Faucet. So you could also fund it with the Mumbai Faucet and then continue in the demo here.
04:26:42.046 - 04:26:58.850, Speaker A: It's similar how to use shows you a small snippet. So there's some variables required on stripe's end like the stripe public key, et cetera. Some session data also which contains the chain supported and which currency to use, et cetera.
04:26:58.850 - 04:27:18.502, Speaker A: And then again you create like you initialize here the kit with the pack and then you have functions which you can use like Save onram open will open the stripe onboarding model. Yeah. Next the relay kit.
04:27:18.502 - 04:27:24.762, Speaker A: Also a small demo. I will already click because it takes a bit. But all that happens if you click is the Web Three.
04:27:24.762 - 04:27:39.438, Speaker A: Our signer will be used to sign a transaction which transfers zero one matic from the safe to the safe itself and it relays the transaction cost from the safe. So as we saw here, it was just one click. I didn't need to sign a MetaMask or anything else.
04:27:39.438 - 04:27:49.362, Speaker A: And the transaction is being executed on chain. So this kind of shows the power also of account abstraction. Yeah, as we see it's success.
04:27:49.362 - 04:27:57.334, Speaker A: So we could check the transaction if it's included here for the gun. Scan is a bit slow. You have to trust me.
04:27:57.334 - 04:28:05.930, Speaker A: Just try it yourself. Okay, let's continue with the slides. I talk about the hackathon.
04:28:05.930 - 04:28:29.982, Speaker A: This year we have like $10,000 in hackathon bounties for the Safe Foundation and they're split between these two projects I presented. Like if you want to be eligible for the bounties, you have to build either on top of the SafeCore protocol or the SafeCore account abstraction SDK. The bounties have the same tiers on both projects, but it's separate bounties for each project.
04:28:29.982 - 04:28:50.054, Speaker A: So you can decide on what you want to build on if you want to build for Safe. Also important for the SafeCore protocol, it's the new protocol where I showed the diagram where we updated the docs for it's, not the old smart contracts like we would prefer if you try out the new protocol. Build a plugin, build a hook, be creative about what you could build with those.
04:28:50.054 - 04:29:03.946, Speaker A: Or you can also build a registry. Or alternatively, you could even build a new small wallet implementation which uses this new protocol to show that also other smart accounts could be used, and not just Safes. Yeah.
04:29:03.946 - 04:29:11.390, Speaker A: If you have any questions about this, please come to the booth. We'll be there all the time. I'll try to be there as much as possible to answer your questions.
04:29:11.390 - 04:29:29.198, Speaker A: And we also have a discord partner channel like partner safe on the ETHGlobal discord. Yeah. Here's some more links, like links to our docs, to our own Discord, our forum and our Twitter.
04:29:29.198 - 04:30:02.174, Speaker A: If you want to participate in some discussions around these topics, or if you want to just check out the docs or just need some help. We also have a small Hackathon Success Guide, which we try to always maintain between our hackathons, which has a lot of learning materials, has infos about past workshops or past hackathons, so you see which teams won in the previous hackathons. What did they build? Just to get some inspiration, but also to know what not exactly to build, because it would be good if it's something new and not just an old project.
04:30:02.174 - 04:30:08.874, Speaker A: Revamped. Yeah. This QR code leads to the notion page with this Hackathon Success Guide.
04:30:08.874 - 04:30:15.122, Speaker A: If you want to scan it. Otherwise you also have this QR code at the booth. Yeah, I will leave it on this page.
04:30:15.122 - 04:30:25.560, Speaker A: This was the presentation. If you have any questions, feel free to reach out or to ask them now or otherwise you can always come to the booth or ask on Discord. Thank you.
04:30:25.560 - 04:30:45.818, Speaker A: Hey, thank you. Have you considered building a MetaMask snap leveraging your SDK? Like to have contact abstraction with snaps? If you are aware about snaps. I'm aware of snaps, I guess, sure.
04:30:45.818 - 04:31:08.762, Speaker A: The only requirements to be eligible is that you use the SDK. And I think in the Snap you could also use the SDK as a dependency to for instance, if you want to sign a Safe transaction and you have MetaMask, you could fetch some context right, about the Safe transaction through Snap. So definitely the only requirement is to use the SDK or to build on top of the new core protocol.
04:31:08.762 - 04:31:28.420, Speaker A: So yeah. Would also be eligible. The smart accounts in the new protocol, is that a different contract than the current Safe account? No, it would be also the current Safe accounts.
04:31:28.420 - 04:31:43.560, Speaker A: Currently, as I mentioned, it's only deployed on Girly. Okay, so only on Girly testnet. And I think they use together with also the new Safe version, one four one, if I'm not mistaken.
04:31:43.560 - 04:32:09.560, Speaker A: Is that kind of based on the 443 37, the account abstraction standard or is that still a different thing. I think the new Safe version also supports four three, seven think also through a module, if I'm not mistaken. But it's a different protocol.
04:32:09.560 - 04:32:36.036, Speaker A: The Safe core protocol is not directly related to four three seven. It's more the idea to have a new framework or have a new architecture or protocol to include multiple smart accounts and have a way of a composable modular architecture to easily extend these smart accounts by new features. And then it would be cool to use them also across different smart accounts and not be bound to a Safe.
04:32:36.036 - 04:32:44.328, Speaker A: Like, for instance, this example we saw. All it does is it relays through Gelato. It's a plugin.
04:32:44.328 - 04:33:01.170, Speaker A: So if you send the transactions through this plugin, it will check the gas costs and transfer the amount of ERC, 20 tokens or the amount of native tokens to Gelato in the same transaction. And then Gelato can relay it. That's the demo.
04:33:01.170 - 04:33:10.620, Speaker A: If you want to check it, there's a repo. This is, for instance, this demo plugin, like the relay plugin. So it's linked on our docs.
04:33:10.620 - 04:33:17.252, Speaker A: You can find it there. And there's a contracts folder. And there you find the contracts used for this small demo which you saw here.
04:33:17.252 - 04:33:33.096, Speaker A: You can also try it. If you deploy Safe on Gurley, you can try to enable this relay plugin and then try to relay some transactions. Do these basically replaces module? Is that the right way to think about it? I think in the future, yes.
04:33:33.096 - 04:33:52.336, Speaker A: Because the modules right now only work with Safe, right. They're like part of the Safe contracts, but they're not part of, I don't know, the Argent contracts. So the idea is to at some point have a standard protocol or push for a standard protocol which can be used across smart contract wallets and build plugins for those.
04:33:52.336 - 04:34:07.712, Speaker A: So they are different implementations, but they're very similar in the short term. We will still have the module and safeguards and stuff like that. And in addition that you can also kind of enable plugin hooks.
04:34:07.712 - 04:34:23.020, Speaker A: Yeah, I think in fact you could build a plugin which is a module and a plugin, right. Because in this app, if you enable these, it will in fact just enable a module also. It's kind of both, but it will also be a plugin.
04:34:23.020 - 04:34:45.660, Speaker A: I didn't prepare a full demo with a one out of N Save right now. I can prepare a demo at the booth and then we can do it at the booth. Okay, yeah, we can take a look at it.
04:34:45.660 - 04:34:59.562, Speaker A: This is all very new. This was the first time, I think this demo was presented two days ago and the general presentation about this SafeCore protocol was given yesterday at ECC the first time. So it's all brand new, all alpha.
04:34:59.562 - 04:35:14.094, Speaker A: But we want to gain very early developer feedback to see if it's good to build on it or if you could improve something. Because right now it's alpha, we can still change it, right? Or if there's any issues with it. I'm not getting the enable.
04:35:14.094 - 04:35:19.574, Speaker A: I don't know. You have to open it as a custom safe app. That's important.
04:35:19.574 - 04:35:40.094, Speaker A: Like here, it's embedded in Safe, so it's like in the safe, you go to apps, then to custom apps, and then you add the URL of the demo app, and then you should be able to enable them. Otherwise you only see something else, which I don't have. It open right now, but yeah, you have to open it as a safe app.
04:35:40.094 - 04:35:57.010, Speaker A: Then it should work. Cool, thank you. I've seen on your website that you are deployed in twelve networks, is that right? The safe contracts? Yeah, the safe contract.
04:35:57.010 - 04:36:06.354, Speaker A: The safe contracts? Yes. So if you want to build on the count abstraction kit, you could build on those twelve networks also. I mean, there's even more networks, I think there's a repo.
04:36:06.354 - 04:36:22.518, Speaker A: It's called safe deployments. If you check that out, you see actually all the networks where we are deployed per contract. So if you go here to the nosis Save contract, you see this is a list of contracts where we actually of chains where we deployed.
04:36:22.518 - 04:36:33.946, Speaker A: So this is a lot of chains because whenever there's a new chain, we try to deploy them, but we don't support them in our interface yet. But it's just the idea that we still deploy them already. So this is the full list of contracts.
04:36:33.946 - 04:36:42.622, Speaker A: So if you want to hack on it, you could use any of these networks. Okay. But the new Swave core protocol, which with the plugins and hooks, that's only on Gurley right now.
04:36:42.622 - 04:36:59.506, Speaker A: So if you would want to use that somewhere else, you would have to deploy it yourself. Right? For now, because it's still alpha. But if you want to hack on the existing productive contracts, the better proven ones, they're deployed on all these chains, it's called safe dash deployments.
04:36:59.506 - 04:37:09.366, Speaker A: Have you planned to deploy lina, do you know the chain ID by heart? No. You can check in this repo. Yeah.
04:37:09.366 - 04:37:17.066, Speaker A: Okay. Linear was live yesterday. Yeah, let's see when the last update was here.
04:37:17.066 - 04:37:21.500, Speaker A: Four days ago, so probably not yet. Yeah. Okay, thanks.
04:37:21.500 - 04:37:48.950, Speaker A: Yeah, it's thank you. Thank you very much. Thank you, Manuel.
04:37:48.950 - 04:37:54.340, Speaker A: That concludes our workshops for the day. Happy hacking. Thank you.
