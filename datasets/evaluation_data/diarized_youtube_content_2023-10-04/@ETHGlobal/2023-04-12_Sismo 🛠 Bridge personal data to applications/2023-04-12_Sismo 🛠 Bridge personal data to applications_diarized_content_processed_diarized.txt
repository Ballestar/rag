00:00:06.250 - 00:00:20.346, Speaker A: Hey, in this workshop I will present you Sysmo Connect, which our crypto native SSO single sign on. I hope you will like it and you will like hacking on it. So I'm Leo.
00:00:20.346 - 00:00:24.994, Speaker A: I'm the CTO of sysmo. So at Sysmo. We use sysmore.
00:00:24.994 - 00:00:49.900, Speaker A: Next we want to bridge personal data to applications. So you have a user here with his own data, like you can see with gems, and he wants to bring this data to applications. So for instance, me, I have ENS, I have some follower on CISMO lens and this is my public and personal data.
00:00:49.900 - 00:01:18.214, Speaker A: I have also a very private wallet which contain all my bank account, some NFT, some transaction I made on Instagram. And I also have a more web to like account, for instance my Twitter account where I have all my followers and I follow Sysmo. For instance, for instance, an application will need this data.
00:01:18.214 - 00:01:35.510, Speaker A: Let's take the example of a Zkdrop. It's an AirDrop gated to seismo Twitter followers. So I want to bring the ifolo seismo data and only this data, the zkdrop will verify I own this data and get me the AirDrop.
00:01:35.510 - 00:01:58.580, Speaker A: Another example is Zkesub. It's a mailing list gated to NFT holders without knowing exactly which address owns this NFT. For instance, so I will send the fact that I am NFT ownership, for instance, a crypto bank ownership, and my email will be registered to a mailing list.
00:01:58.580 - 00:02:25.130, Speaker A: So how can this be possible? You have what we call the user data vault. It's like a password manager where you will generate a ZK proof of the data you own without revealing exactly the accounts that own it. You will send the ZK proof to the application and the application will verify this ZK proof.
00:02:25.130 - 00:02:49.150, Speaker A: So let's dig a bit into the data vault. So inside this data vault, I will add all my different accounts, I will sign a proof of ownership, a signature to prove that I own these accounts. So, I have my Lero 21 East, I have with all my data, inside I have my Twitter accounts.
00:02:49.150 - 00:03:16.940, Speaker A: And whenever I need to share a data with an application, I will generate this ZK proof. This ZK proof can be verified either on chain directly on a smart contract, so we provide some libraries for that and we will see it after during the workshop or off chain that can be verified directly into a back end of a more web. Two traditional application.
00:03:16.940 - 00:03:39.662, Speaker A: So this protocol communication between application and personal data, and the Sysmo data vault is called Sysmo Connect. It's a crypto native single sign on SSO. So with Sysmo Connect, I have mainly three features.
00:03:39.662 - 00:04:06.906, Speaker A: I can do an identification, that means I can bring the fact that I own my Leo 21 Twitter account and the application won't have to verify it again, just verify the CISMO Connect proof. I can do some data claims. That means I can claim that I own a crypto bank and without revealing in which account I have this crypto bank exactly.
00:04:06.906 - 00:04:25.294, Speaker A: Or I can do a message nature to signal something. For instance I can say okay, I vote yes, or I vote no, I agree, I disagree, et cetera. And we can do all of this into the same interaction flow with our data vault.
00:04:25.294 - 00:04:58.540, Speaker A: So inside the one proof I will have these three facts for instance, and I will be able to combine them. So Sysmo connect you have an application, let's say with the front end and the backend, the smart contract and you will add some snippet of code in each part to be able to interact with the user data vault. So in the front end you will add a button which is our sign in with Sysmo button.
00:04:58.540 - 00:05:23.170, Speaker A: By clicking on it you will do a Sysmo connect request to the user data vault. I will show you a demo after you will generate the ZK proof of the data requested inside job browser directly and you will send back this response to the application that can then verify it in a backend or in a smart contract. So either off chain or on chain.
00:05:23.170 - 00:05:47.420, Speaker A: Yes. What is interesting here in the data vault is like when you add your address, the data vault can infer all the data you own associated to this data vault. So for instance here we can see that we have this data gem inside that is added the more you add accounts inside it.
00:05:47.420 - 00:06:24.470, Speaker A: So the layerized structure of the data vault you have first another application you can made with the vault directly. So for instance, an application can request their user to connect with the data vault directly without needing the user to have added a different web two account. So just by the fact that you have a CISMO data vault, you can request your user to single sign on with it and you will have a user ID inside your application that you can use as a user ID to authenticate the user.
00:06:24.470 - 00:06:43.174, Speaker A: Then you have the other layer where you can add different type of data sources. So for now, we have Twitter account, GitHub account and EVM account. Then you have all what we call the data claims.
00:06:43.174 - 00:07:20.970, Speaker A: You can claims to have some data inside your data vault and this is due to the fact that you have added a lot of different type of data source. So if you add, I don't know, all your accounts inside the CISMO data vault, you will basically be able to prove a lot of different type of data jump. So this is the data ownership part and finally you will be able for each interaction between your application and the Sysmo data vault to add some message signature that you can approve or not inside the Sysmo data vault.
00:07:20.970 - 00:07:54.370, Speaker A: So let's dig into the authentication part. So from the app you do a Sysmo connect request and you request the authentication for being a Twitter account. So the systemo data vault will generate SDK proof and send back to the application that can see effectively the Twitter account user ID inside the app and the app will be sure that this Twitter account has been verified.
00:07:54.370 - 00:08:16.314, Speaker A: So it's like a web two SSO but you can request a lot of different type of web two accounts in the same time. So with the devex we have created it's very easily to ask for Twitter account, a GitHub account and an EVM account in the same proof. You can also authenticate with a Nissram account.
00:08:16.314 - 00:08:33.258, Speaker A: So it's the same, you do a request with this Ethereum account and you have the response from the sysmo connect. So it's like a sign in with Ethereum basically. So let's see now the data claims.
00:08:33.258 - 00:09:07.270, Speaker A: So data claims, what is it? Claims is like for instance I follow Sysmo on Twitter, I have contributed to the Sysmoco core organization on GitHub, I have an ENS, I follow Sysmo Lens Store Lens protocol and I have more than one Ether. So for instance the aggregation so this is all the different type of claims I can do from all my data that they have imported into my CISMO data vault. And with this data I can do claims.
00:09:07.270 - 00:09:36.310, Speaker A: For instance I have more than one Ether or I have made at least one transaction, or I have some comparator I can use to do some more granular request on this data. For now, this type of claims are basically group membership claims. So I will show you after we have a wall infrastructure that handle to create some groups.
00:09:36.310 - 00:09:57.500, Speaker A: And inside the protocol we are using zero knowledge proof. And this zero knowledge proof helps to prove that you are part of a group of a list of different type of users that have the same type of characteristic. For instance, we can see it with the same color here.
00:09:57.500 - 00:10:23.810, Speaker A: So if you want to add a new type of data claims inside the sysmo connect, you will have to create the group of all the users that share the same characteristics. For instance here we can see the ENS holders groups, a particular NFT owners group or Proof of Humanity registrance group. You have also the value.
00:10:23.810 - 00:10:43.222, Speaker A: So you can see the account Identifier, the Ethereum address here and the value. And you can inside your data claims request a value lower or equal exactly equal to the value you have inside the group. So let's request for instance prove NFT ownership with privacy.
00:10:43.222 - 00:11:14.318, Speaker A: So you do a Sysmo connect request to ask some particular data claims inside the prover. In the CISMO data vault we will generate a ZK proof to prove that you have this claim without reveling the account. And here it's a bank holder and it will be sent back to the application that will verify this ZK proof and can then use it for its own logic finally we have all the message signature.
00:11:14.318 - 00:11:39.014, Speaker A: So it's like signaling an information from your app you request with the message okay, I voted yes for this governance proposal. For instance, it's a message that is going to be signed from the user inside the prover. So in the CISMO data vault, the user will approve and generate a ZK proof with this message inside the ZK proof.
00:11:39.014 - 00:12:09.510, Speaker A: It will then be verified in the application and we are sure that the user agree with that. So now let's take a look in more detail into our devex for this crypto native single sign. So first, when you want to integrate it into your app, you need to create an app and authorize some domains in our factory IO.
00:12:09.510 - 00:12:25.180, Speaker A: So let's go here in the factory, when you arrive, we can see that you can create some Sysmo badge. So it's not in the scope of this workshop. But here you have the application.
00:12:25.180 - 00:12:36.800, Speaker A: It's currently called ZK Connect application. It will be renamed in Sysmo Connect. And you have here the Sysmo data groups that I will show you after.
00:12:36.800 - 00:13:01.570, Speaker A: So in the ZK Connect apps we can see that I have already different application and we are going to create a new one for this workshop. So for instance, here is Global Tokyo application and we will authorize the Isglobal.com domain and a localhost.
00:13:01.570 - 00:13:18.118, Speaker A: Because I'm going to do the demo in local. Let's create it. So when I have created my application, I will have an Nap ID here.
00:13:18.118 - 00:13:36.460, Speaker A: It will be used inside the Snippet tough code we are going to integrate into our app. And it will be used in the user sysmo data vault. That will verify that the app correspond to the domain that do the request, mainly for security reason.
00:13:36.460 - 00:13:59.536, Speaker A: Okay, so let's say now we want to integrate the Sysmo Connect into our application and this application will be the Zksub. So let me start by a demo. So you can go over there.
00:13:59.536 - 00:14:33.420, Speaker A: It's a demo zksub IO here we want to get the email addresses of all the contributor to the merch. So we have currently a group of all the contributors to the merge that was made by Tim Becko. And we are going to gate this mailing list with the fact that you are well into this group.
00:14:33.420 - 00:14:53.372, Speaker A: And we won't know exactly who you are inside the group, but at the end we will have the list of all the email address of the different users that enter the disease flow. So, I start by doing the sign in with CISMO. I'm directed to the Sysmodata vault.
00:14:53.372 - 00:15:10.024, Speaker A: Here I can see that the Sysmodata vault want to request some data. I need to have the merge contributor group to be part of this group. So, I can see here the list of all the accounts I'm going to show you that are inside this group.
00:15:10.024 - 00:15:27.256, Speaker A: I can go there and check and I can see here also the group generator. For the group generator is the code that is executed at a specific frequency. It's like infrastructure as a service that generates automatically the group and it can be dynamic.
00:15:27.256 - 00:15:39.810, Speaker A: So you can have a frequency here of daily frequency that will regularly update the group when we change it. So all here is open source. You can do a progress to update and so on.
00:15:39.810 - 00:15:48.248, Speaker A: So I do connect. It asks me to be eligible. That means to have the data inside my system data vault.
00:15:48.248 - 00:15:55.572, Speaker A: So I have well, the fact that I'm a merger contributor. So here I can see my all different accounts. So this is a demo.
00:15:55.572 - 00:16:22.556, Speaker A: So it's fake data, but you have vitalik ease. You have Twitter account, GitHub account, and some very private wallets. For instance, you do generate this K proof, once generated, is sent back to the application that verified it and I can enter my email and it will be added into the backend.
00:16:22.556 - 00:16:36.060, Speaker A: And by verifying also that the Ziggy proof is valid. So let me show you in more detail how it works. So, this repository is open source.
00:16:36.060 - 00:16:46.416, Speaker A: You have a link here, it's sysmocost Zksub. And we just have to add this sysmo connect button. It's a react button in the front end part.
00:16:46.416 - 00:17:04.476, Speaker A: And this package here to verify the sysmo connect response and to be sure that it's valid. So under the wood, it will verify the ZK proof that was replied by the sysmo DataBoard. So, let me show you a bit.
00:17:04.476 - 00:17:19.932, Speaker A: I have a local host instance here and we will update the code. So, here I am in the front end part. I have here the app ID I want to target.
00:17:19.932 - 00:17:29.110, Speaker A: So this is the ZK seven, the one I presented you. And now we will use the new one. We have just created it's here.
00:17:29.110 - 00:17:38.940, Speaker A: I can change it here. So we say this is Tokyo. Okay, let's go again here.
00:17:38.940 - 00:17:57.210, Speaker A: And so when I do sign in with CISMO, I can see that now it's the Is global Tokyo that are requesting to have access to this data. So now let's say we want to request some particular data. So this is the merge contributor.
00:17:57.210 - 00:18:13.746, Speaker A: We are going to create here in our sysmo factory a new data group. I think I've prepared. So here in this data groups, I can search for different data group.
00:18:13.746 - 00:18:24.374, Speaker A: For instance, let's say proof of we talked about proof of humanity, so let's find it. Proof of humanity. I can find it here.
00:18:24.374 - 00:18:42.702, Speaker A: So, you have 17,000 users. You can see here the group generators. This one is more interesting because it's updated at a weekly frequency and it will use data providers to get all the data.
00:18:42.702 - 00:19:07.046, Speaker A: So data providers as a way are a way to get all the data for the group. It can be, for instance, Rest call to a Rest API to GraphQL API to some BigQuery stuff that are indexed into the blockchain here it's subgraph data providers. So we request this subgraph ID.
00:19:07.046 - 00:19:31.058, Speaker A: We have our request, we map the result of this request and we generate our groups. So I showed you the code, but now let's create a new data group. So here I have in the factory directly.
00:19:31.058 - 00:19:44.734, Speaker A: So in no code you can create the name of your data group and add eligible accounts. So you can for instance, add your accounts inside the list. Let's add it here.
00:19:44.734 - 00:19:57.138, Speaker A: But you can also directly use the data providers that are here. So all the systemo app is open source. So when you create new data providers for the community, it will appear here automatically.
00:19:57.138 - 00:20:48.462, Speaker A: So we have also some bounties to create data providers and to let them add here. So let's say for instance, we are going to get also all my Lens follower Lens and I see that I have my eligible accounts and then I will have a union between my list, my manual list and this follower from Lens. I will say that I want a daily upgrade eligibility Description so groups for Edgobal workshop and the technical specification is how we can be inside this data group.
00:20:48.462 - 00:21:35.720, Speaker A: So having been added manually by Leo R following Leo Lens unlens okay, let's create this group and then we can see here that this group has been created. I have a pull request associated, it goes to the CISMO hub and we can see that the code has been automatically generated. So here we have group generators with the frequency of daily.
00:21:35.720 - 00:22:05.052, Speaker A: We can see that we have our static list where I added my Leo 21 address and I have also the use of the Lens provider to call all the followers from Leo 21 east. I design a union of these two data and it's used inside my group. So yeah, this was how we can use a group.
00:22:05.052 - 00:22:27.110, Speaker A: So now let's update here on our code. So we were doing the update of the local environment. So we want here when we click here to change the group ID.
00:22:27.110 - 00:22:40.840, Speaker A: So let's find a group ID that suits us. So we are going to take the proof of Poh group. I'm taking this so I can copy paste it here very easily.
00:22:40.840 - 00:23:02.210, Speaker A: Let's go to the code. I'm just changing my so here in the button we can see that I'm doing a not request to have a vault ID that will be used as a user ID into my application to register the email to this particular user ID. And to avoid that, the user can add a lot of different type of email.
00:23:02.210 - 00:23:18.322, Speaker A: I will do a claim of being member of this group. So I've just changed here. Let's go again doing the same in with CISMO and I can see that here.
00:23:18.322 - 00:23:39.254, Speaker A: Now I have the proof of humanity requested data. So yes, we have seen that it was very easy to integrate the sysmo connect button into the front end part. Let's go.
00:23:39.254 - 00:23:57.046, Speaker A: Now see the backend part. So in the same repository you have the front and back folder. Here you have the root which is the subscribe where you add your email at the end of the flow.
00:23:57.046 - 00:24:17.794, Speaker A: So you have your email and the sysmo connect response and you will verify it directly. So you use the Zkconnect library. So the sysmo connect library you will verify the sysmo connect response that corresponded well to the request you did and the group ID that you wanted.
00:24:17.794 - 00:24:38.178, Speaker A: Basically, when it's verified, you can extract your user ID and use it to store the associated email. So you can find the different piece of code here into this repository. And now you can do exactly the same thing but unchain.
00:24:38.178 - 00:25:12.334, Speaker A: And this is another demo which is our Zkdrop IO. So in this demo we are going to do Zkdrop to NFT, which is a non transferable NFT in this particular case. So you prove that you are part of this list and you can mint this NFT to any of your addresses.
00:25:12.334 - 00:25:24.294, Speaker A: And we don't know exactly where you are inside the list. So you click on get your pass, you add a destination, let's say italic is add destination. You do.
00:25:24.294 - 00:25:39.734, Speaker A: Then the sign in with sysmo we arrive on the CISMO data vault. We can see that we have a message signatory request. This is used to avoid front running of our ZK proof under our transaction.
00:25:39.734 - 00:26:35.868, Speaker A: So here we have encoded the destination account, will have this NFT at the end we do generate ZK proof, we are redirecting back to the ZK drop and we can in one transaction directly mint our merger pass NFT. So let's now dig a bit into the smart contract library. So here you just need to import the Zkconnect solidity library with Sysmodib to extend your contract with the Zkconnect and declare your app ID.
00:26:35.868 - 00:26:47.872, Speaker A: Like that. So it's a little bit like on the backend that we see just before. And now we are going to claim with sysmo connect to have our NFT.
00:26:47.872 - 00:27:18.080, Speaker A: So we just bring the sysmo connect response as a byte, it's already well formatted and the address where we want to have it, we verify. So this function is injected directly thanks to this Zkconnect library inside our contract. We verify this sysmo connect response and we verify that it corresponded well to our group ID, the group ID of our merge contributor.
00:27:18.080 - 00:27:43.610, Speaker A: Once it's verified, we can directly use our user ID, the user ID that comes from the vault that is specific to us. And so the user ID is computed into ZK as being the user ID equal hash of the vault secret and the app ID. So it's very specific to me inside the Zkdwap application.
00:27:43.610 - 00:28:01.628, Speaker A: But as I'm always using the same sysmoda tableau, it will be used as an authentication layer. My token ID I can then mint directly on this token ID the token. So yeah, same here.
00:28:01.628 - 00:28:37.768, Speaker A: All is directly open source, you can find it on this repository. So now to build on CISMO, we have our docs CISMO IO. The build CISMO IO will detail all the information on the easiest way to build on top of CISMO, you have also the builders CISMO IO, which is a telegram group where you can enter and ask for help.
00:28:37.768 - 00:28:51.550, Speaker A: Or you will see other CISMO builder there. And you have our GitHub organization where all what we are doing is open source. You have all our different repository and you can dig into it.
00:28:51.550 - 00:29:10.320, Speaker A: So yeah, thank you for your time. Hope you enjoy the CISMO connect and we also are hiring, so just have a good hackathon and enjoy your time. Hacking bye.
