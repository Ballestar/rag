00:00:07.370 - 00:00:19.642, Speaker A: All right, welcome. So today I'm just going to be talking a little bit about creating projects that use the risk zero zkvm for off chain computations. You're going to be using this through the Bonsai Proving service, which we are going to make available at the Hackathon.
00:00:19.642 - 00:00:31.042, Speaker A: So we're providing a little bit of early access. It's going to be temporary and I'll show you in a moment how to reach out and get that from us. I also want to show you our two bounties and help you get familiar with our dev templates.
00:00:31.042 - 00:00:45.500, Speaker A: So this is going to help you understand how to go from a local project setup to connecting to a real proving service. And we're going to save just a little room at the end to gently touch on zero knowledge proofs. So let's start talking about why you would want to use a zero knowledge proofing service.
00:00:45.500 - 00:01:09.102, Speaker A: So we're going to let you build better on chain applications because you can use general purpose CK computing to take care of the off chain bits that you don't want to have to run through the EVM. And I'm going to break down just a little bit the benefits of this. So the first one is obvious off chain computation, right? Everybody likes paying less for computations executed outside the EVM.
00:01:09.102 - 00:01:35.062, Speaker A: But because this is ZK, after we take care of the off chain computation, we're going to give you some results that anybody can easily validate without having to run the computation themselves. And because it's zero knowledge, you also don't need to know exactly what inputs were processed and what code paths were taken to trust the computation. So if you've played with Ckvm in the past, you might remember that you were restricted from running programs that were longer memory intensive.
00:01:35.062 - 00:01:47.742, Speaker A: I just want to give a quick shout out to a new feature. We now split your program into many tiny programs that can be proven and in fact they can be proven in parallel. So just a quick recap here.
00:01:47.742 - 00:02:09.510, Speaker A: We've got a fast general purpose VM lets you not only check your computation, but also assume everybody else is going to agree the computation was good and you don't have to stop until your computations are finished. So in fact, our new ability to split up work, we can basically parallelize the proving process. So if all that sounds good, let's go check out the Hackathon projects open this weekend.
00:02:09.510 - 00:02:22.858, Speaker A: So we've got a couple of bounties and the first one is obvious. Let's do some DAP development here. We're looking for kind of an interesting demonstration of a DAP that uses the Boneside proving services through our E three way.
00:02:22.858 - 00:02:48.514, Speaker A: And it doesn't necessarily have to be something that's an incredibly beefy off chain computation. It could just be something that allows you to make adapt that's slightly more complex. We also really love educational pieces that are really clean, well documented demonstrations of simple use cases and just as a quick heads up, we would love for you to try out our services at this hackathon, but if you want to do local development, it's also just fine to use our mock services.
00:02:48.514 - 00:03:06.018, Speaker A: So because we created something that has a pretty smooth process from doing local development to using the real proving service, we'd consider your submission of your local code check in good enough. You don't need to demonstrate that it runs. We can do that for you and we trust that it executes.
00:03:06.018 - 00:03:30.746, Speaker A: So how I just talked about a little bit, we have a dev template that I'm going to link to in a moment, and from that you're just going to have two files that you modify. So you'll modify the app contract, which is written in regular Solidity, and then the Provable Zkvm program that holds the off chain computation. So you'll be writing a little bit of rust, but just enough to perform your computations so there's no need to do any circuit construction.
00:03:30.746 - 00:03:41.570, Speaker A: And I guess I lied. You should probably include tests, but don't worry, those are included in Solidity too. We've gotten you started and you can run those right from the command line locally.
00:03:41.570 - 00:04:00.438, Speaker A: So here we're looking for kind of an interesting use of an off chain probable computation. But again, it can also just be something that allows your DAP to be slightly more elegant or is educational. And feel free to reach out to us on the Riscero Discord, which you can find off the main Risk Zero website.
00:04:00.438 - 00:04:17.530, Speaker A: We would love to help you work on something that's exploratory or inventive. And if you get to the end of the hackathon and you want to tell us what your experience was like, we have a second bounty for that. So this is our second bounty that we wanted to do just as a way to say thank you to folks who give us really rich feedback at the hackathon.
00:04:17.530 - 00:04:34.514, Speaker A: And the nice thing about this is you can actually apply to one or both. So if you go to work on a project, you get stuck and there's some really crunchy thing you want to give us feedback on. We prefer that was not the case, but you're still eligible for a bounty if you just want to give us really rich feedback about it.
00:04:34.514 - 00:04:49.282, Speaker A: We'll be rewarding the top two respondents with $500 each. So here you're going to be sending in an initial feedback form, and that form kind of implies consent to have a conversation that's up to an hour. We respect privacy.
00:04:49.282 - 00:04:57.594, Speaker A: Online is perfectly fine. Telegram Discord if you want to chat with us in person. It's a pretty tight window in between the 02:00 P.m.
00:04:57.594 - 00:05:35.720, Speaker A: End of judging and the 03:00 awards ceremony, so we will probably do some follow up contact rather than do things at the event. But I just wanted you to know that there is going to be a conversation expected as part of that follow up for feedback, and you won't be evaluated, obviously, on the conversation because it'll need to happen later. So just try to make sure that you fill out the form in a way that indicates that a you gave it a good shot and you really tried to work on a project, and B, you're committed to giving clear, instructive feedback about what your experience was, what you liked, what you didn't like, how you felt about it.
00:05:35.720 - 00:05:47.450, Speaker A: And all you have to do is provide feedback. So with that said, it's probably time to better understand what you can build at the weekend. So let's take a look at what you're going to be developing.
00:05:47.450 - 00:06:05.582, Speaker A: So what you're going to bring is pretty simple. You are going to bring an app contract, which we've already provided in our template. You just have to add a little bit of solidity code, a computation that you would like not to write in that app contract, and then a program to compute it, which we've gotten started for you.
00:06:05.582 - 00:06:15.326, Speaker A: You just need to add the computation there. By default, the template comes with calculating Fibonacci. It's just a silly example of something you might not want to do using the EVM.
00:06:15.326 - 00:06:31.980, Speaker A: So, again, the two languages you're going to be working with are rust and solidity. So just plain rust, no circuit development, and just plain solidity. There's going to be an invocation callbacks, but other than that, it just looks like a regular app contract making a regular function call.
00:06:31.980 - 00:06:57.490, Speaker A: So once you've built that, we're going to run the proof and handle the results, assuming that you are proving on our Bonsai Proving service, and we'll get to what you're building in a minute. But I just want to emphasize you're working on your contract and off chain program locally here, with full solidity tests and simple deployment steps. In this way, you can just focus on solving your problem this weekend instead of learning a new API at the hackathon.
00:06:57.490 - 00:07:09.874, Speaker A: So here's some things we're not going to ask of you. And I wanted to cover these because you only have 24 hours to work on a project. So you don't have to write a custom proof circuit in a weekend or at all.
00:07:09.874 - 00:07:19.430, Speaker A: You don't have to think about EVM performance for your off chain code. You can just go ahead and make sure you're writing. I mean, you still do have to care about performance, but you're trying to write good rust.
00:07:19.430 - 00:07:36.602, Speaker A: And you're not running this inside of the EVM. You're running it inside of a general purpose virtual machine that, for our purposes, you can think of as just being a coprocessor, an off chain coprocessor. You also won't need to make API calls directly to Bonsai.
00:07:36.602 - 00:07:59.846, Speaker A: So for this particular kind of project, you can leave the calls to our relay and we'll handle it for you. So you also don't need to develop with unfamiliar tools a lot of you will be familiar with Foundry. So we've done the local part here as a full, self contained foundry project with full access to foundry tools, including some forge tests, which we've gotten set up and started for you.
00:07:59.846 - 00:08:17.238, Speaker A: So what you're going to be doing is just modifying those forge tests and adding your own checks right now. We make sure you're accurately computing the Fibonacci sequence, and I'll show you more about the tests in a moment there. So you're also not going to need to spend a lot of time on your environment setup.
00:08:17.238 - 00:08:36.078, Speaker A: We're going to start out by mocking the entire proving service and let you essentially flip a switch with environment variables when you're ready to use the Bonsai proving service. So it's going to be pretty fast and easy, and you can go back and forth pretty cleanly. So we're pretty excited to not make you make any large code changes before you deploy.
00:08:36.078 - 00:08:47.730, Speaker A: So if that all sounds interesting, I'm going to start unpacking the project structure in this next section. So this is a very high level view. I'm going to have a little deeper architectural view in just a moment.
00:08:47.730 - 00:08:59.390, Speaker A: But for now, I just want to explain the basic moving parts and how they work. So it's a little bit cartoon, but here's the blockchain and here's Bonsai. Just FYI, bit of a tangent.
00:08:59.390 - 00:09:15.600, Speaker A: You won't actually be deploying your app contract to the blockchain for this weekend hackathon. What you're going to be doing is running everything locally here, using that local Foundry setup and calling out to our real proving service. So this is a picture of the final product.
00:09:15.600 - 00:09:45.640, Speaker A: In the final vision of this, your contract lives on the blockchain, talks to a relay contract also deployed on the blockchain. So we're going to start out reaching out through that relay contract, which will communicate through the ETH relay onto Bonsai, and we'll manage the calls between the blockchain and the proving service for you. And then we're going to run your program off chain using inputs from that smart contract call, prove your code was executed in a way that anyone can verify and get it back to you right in a callback function.
00:09:45.640 - 00:10:06.762, Speaker A: So it sounds like a lot of moving parts, but I just want to emphasize this contract on the left and the provable off chain computation on the right are the only two pieces of code that you need to be touching at any point in this hackathon. So with that said, let's take a little bit of a look at what you're going to need to set up. There's three basic steps.
00:10:06.762 - 00:10:18.814, Speaker A: You're going to need rust, you're going to need a foundry, and you're going to need the bone size starter template project. So you're not allowed to start early at the hackathon. So for this, I am going to be having moments where you can pause in this recording.
00:10:18.814 - 00:10:31.410, Speaker A: But I'm going to assume that if you're pausing and doing setup steps or writing code or making modifications that you are inside the hackathon window. All right. That said rust installation.
00:10:31.410 - 00:10:45.122, Speaker A: If you haven't got rust on your computer, you are going to need it for the next bit. So if you want to pause here, this is a good time to get that installation set up. And similarly, here's the Foundry setup.
00:10:45.122 - 00:11:03.566, Speaker A: I have shown the commands above. If you want to go ahead and pause and get that set up, I'm showing below what it should look like if you run the command Foundry up and you do have it on your local box, at least that's what it looks like on my machine. And then lastly, you're going to take a moment pause and get the template.
00:11:03.566 - 00:11:23.106, Speaker A: So you're just going to be cloning the project here or forking, whatever your preference is. And I've just gone into the template directory structure and I just want to highlight a few of the pieces you're going to need to care about. There's a lot of code here, but really you can just focus on the README that's got the setup steps.
00:11:23.106 - 00:11:45.230, Speaker A: We just went through most of the slide content to follow. If you really want to stop and just get right into it and use this video again, if you get stuck or you need more information, I won't be mad. In that case, just go ahead and go to our prize section and get information from there about how to get access to our proving service and find out more about the bounties.
00:11:45.230 - 00:11:57.730, Speaker A: That said, if you learn well from videos, let's keep going and talk about contracts. This is going to have your local app contract. You're modifying and methods folder with code for your off chain computation.
00:11:57.730 - 00:12:10.482, Speaker A: It's a little bit buried, but I'll show you where to find it there. And then finally a tests folder with, as I mentioned before, some forge tests written right in solidity. So in a moment, I'm going to walk you through running those tests in a few different modes.
00:12:10.482 - 00:12:24.326, Speaker A: But for now, let's just keep looking at the options for running. So we've given you four options for executing your off chain computation, and the first one is the default. It's the simplest.
00:12:24.326 - 00:12:35.290, Speaker A: You're just doing a local execution. We actually using our mock services, call out to the command line and just run the off chain computation right on your box. So you're going to get a local execution.
00:12:35.290 - 00:12:53.246, Speaker A: And it's pretty zippy because by default, we don't have any of the proving part. We can just do the execution part since we figure in the development in the early development loop, you don't need to prove to yourself that the code you just wrote does what you expect. And then the second mode you can think of as kind of a gentle test mode.
00:12:53.246 - 00:13:28.634, Speaker A: You're going to have a local contract that lives in Foundry and then a local proof that you're executing again from the command line using mock services. The deployed version, you're going to have a local contract still coming from everything contained in Foundry, but you're actually going to be proving on the Bonesai Proving service. And as a preview the final version, you're going to be able to use the deployed app contract with a deployed relay that's going to connect through our E three lay and prove on Bonsai.
00:13:28.634 - 00:13:41.486, Speaker A: And even though you can't do this this weekend, we really have the three options for you. We are planning on having it be fairly seamless. So if you write an app contract now, you would be able to deploy later and prove on Bonsai.
00:13:41.486 - 00:13:45.810, Speaker A: I mean, caveat caveat. This is a work in progress. We reserve the right to change all code.
00:13:45.810 - 00:14:11.530, Speaker A: We're not guaranteeing that you can do this immediately, but we think this is a really great start to having a live working contract that uses an off chain computation, I guess I should say. One final note, you don't need to proof on Bonsai to submit for our bounty program. We'll allow you to just write a local contract, run the local proof.
00:14:11.530 - 00:14:25.620, Speaker A: This is just to let you play around with the real proving service. So hopefully this should give you a rough idea of your developer workflow. Right, start with execution only, go to local proving, and then go to proving on the Bonsai Proving service.
00:14:25.620 - 00:14:47.110, Speaker A: With that said, let's go and figure out how to set up each of these modes. So I promised earlier it was pretty simple and we're going to stick to that. There's just three environment variables you're setting, so the first one is a bit of a toggle between those first three modes I mentioned the exact execution only local proving and proving on Bonsai.
00:14:47.110 - 00:15:07.742, Speaker A: And you'll notice that the empty string is to do local execution only and that's to give you kind of a really clean developer workflow. But you should be aware that by default, you are not running local proofs. So, second step, we're going to set the Bonsai API URL environment variable and the Bonsai API key.
00:15:07.742 - 00:15:33.414, Speaker A: And both of those are piece of information that will get to you if you fill out our whitelist approval form. It should be pretty fast turnaround during the hackathon. If you're watching this before the hackathon and you want to get a head start, we have included the URL in our contract or sorry, in our bounty information on the prizes page and we're also going to include it in just a second here.
00:15:33.414 - 00:15:51.306, Speaker A: So go ahead and get your keys by filling out that form. But if you don't have them yet and you want to get developing, it's pretty seamless to then set this URL and key later, set the Bonsai Proving mode and get started. Oh, and I apologize, I did not change this slide.
00:15:51.306 - 00:16:16.994, Speaker A: It actually says Set Bonsai Proving. So these are the three you're going to need. So here we've talked about the three different modes you can use if you are running the Bonsai Proving Service as the Bonsai Proving service, if you're doing a mock and just executing your off chain computation locally, or if you're doing a no proof version and just doing local execution.
00:16:16.994 - 00:16:32.010, Speaker A: So I'm going to show you here. Let's get the remote one first. I'm setting the Bonsai Proving environment variable to Bonsai and for this, I do need to set the URL and key environment variables as well.
00:16:32.010 - 00:16:51.486, Speaker A: For obvious reasons, I am not going to show that here, but please reach out a little bit later. In this workshop recording, I'm going to have a link to a sign up sheet you can do to get whitelisted and to get access with the URL and key. You can also find that off of our Bounty prizes page.
00:16:51.486 - 00:17:26.250, Speaker A: So with that said, we're going to run this remotely with the full setup. This should take a second and I just want to while this is running, I'm going to real quick pop over to code down in the guts and just mention it's experimental use at your own risk. But we are double checking that your results are coming from the computation you thought you were running and also that they're coming back from the relay that you expected it to be coming from.
00:17:26.250 - 00:17:32.686, Speaker A: So let's go back here. This should be just about done. Great.
00:17:32.686 - 00:18:04.100, Speaker A: So we've got just around 30 seconds and let's take a quick look at how this runs local. So something you're doing in Bonsai mode, where you're actually using the Bonsai Proving service that you're not doing here, is in the background. We do run a call to upload the off chain computation you're going to run to the service before we run it.
00:18:04.100 - 00:18:18.664, Speaker A: So then take another second. There we go. So our tests have passed and let's do the final mode.
00:18:18.664 - 00:18:31.776, Speaker A: So by default, we're going to run an execution only and the empty string will work. But if you want to get back, you can just set that to none and you'll see that this one is pretty zippy. So I recommend it.
00:18:31.776 - 00:18:56.570, Speaker A: As you work on your project, you stay in this mode while you're just figuring out what you want your off chain computation to look like. So you don't have to wait for the full proving and mocking cycle or proving and mock service cycle to complete. Let's go ahead and stop this and I'm going to jump back in and in just a moment we are going to take a closer look at what we're actually executing in this and let you walk through a little bit of the source code through here.
00:18:56.570 - 00:19:08.904, Speaker A: Okay, so now you've gotten a chance to see the test in action. And we're going to go through a brief code walkthrough. So this will get you an idea of how the setup actually works under the hood.
00:19:08.904 - 00:19:32.084, Speaker A: And I'm going to start with that finished product, which, again, we don't have here at the hackathon, but we have something pretty close to it. The finished product is where you actually deploy your contract to an Ethereum network and use our Bonsai Proving Service. So where you'll be able to get during this hackathon is working locally from your box with the app contract and connecting to the real Bonsai Proving Service.
00:19:32.084 - 00:19:44.212, Speaker A: So I've taken the Ethereum Bonsai interactions that we saw in the left right kind of cartoonish mode and made them vertical. And that's just to fit in a few more moving parts. So remember, there's going to be two files you'll be editing.
00:19:44.212 - 00:20:03.832, Speaker A: Here's the first one, it'll be your app contract. And if you're taking a look at this at the hackathon or before the hackathon, this might be a good time to pause and open up both of these files. So you're going to look in the contracts folder I mentioned for Bonsai Starter, Sol, and in the Methods folder I said it was a little bit buried.
00:20:03.832 - 00:20:18.130, Speaker A: We're methods guestsource bin fibonacci rs. So I recommend having both of them open for this next little bit. If you don't have it downloaded, just popping those open in a browser so you can look at the source and follow along and kind of see how all the parts fit together.
00:20:18.130 - 00:20:41.252, Speaker A: Okay, so this is a bit of a slide deck experiment here. We're working with both the infrastructure and the code, but I think because there's so many interactive parts, this is how I want to show you how everything plays out. And for demonstration purposes, like I said, we're looking at the upcoming fully deployed version with the contract down on an Ethereum network.
00:20:41.252 - 00:20:51.372, Speaker A: But it's going to look much the same when everything's running local on your box. So we're going to start with an invoking function. And let's take a quick look at that here.
00:20:51.372 - 00:21:02.930, Speaker A: So notice we're reaching out through the Bones I relay, and we've selected our callback here. It's going to be store result. So invoking function.
00:21:02.930 - 00:21:28.824, Speaker A: And just FYI, we are capping the gas cost here with that 30,000. So that said, our invoking function, which is out to the relay contract, bonesai relay to the Ckvm program, sorry, to the Bonesai Proving Service, which will hopefully execute improve the Ckvm program. So let's take a closer look at the source code for this.
00:21:28.824 - 00:21:48.940, Speaker A: It's going to have a few components, but I just want you to get an idea of the shape of an off chain computation, what it's going to look like and how simple it really is. I mean, caveat caveat again, if this is your first time coding in Rust, it might not initially look simple. But when I say simple, what I mean is you're not solving the problem of how to write a circuit.
00:21:48.940 - 00:21:58.732, Speaker A: You're not solving the problem of how to work with a custom DSL. You're just solving the problem of how do I write my computation. So here's the off chain computation.
00:21:58.732 - 00:22:16.570, Speaker A: The first thing we're doing is we are reading in the value that we passed in from our contract as input and decoding from the bytecode and storing it in a variable. So you are going to need to know what you used as encoding on the other side. But since you wrote the app contract, that's no big deal.
00:22:16.570 - 00:22:38.060, Speaker A: And now that you've got your variables, you can run your computation. So the off chain computation here again, it's a little bit silly, but we're just running Fibonacci to make sure that we can do a more complex off chain computation. And we're going to send the results back by committing this as a data slice.
00:22:38.060 - 00:22:55.940, Speaker A: And what that means is we're going to be sending back a piece of information that I will discuss later in the special ZK section. But for now, what matters is this is everything we want to get to the app contract. So every variable that you've committed at the end of your computation gets sent back to the app contract.
00:22:55.940 - 00:23:10.072, Speaker A: And I'll describe this later in the Gotcha section. But you want to make sure that you are sending those variables back just like any regular function. So we want to make sure they make sense off the wire on the ethereum side.
00:23:10.072 - 00:23:25.752, Speaker A: So also notice we're doing some ETH bi encoding here. Okay, so now we're done with the Zkvm program, which we called from the app contract through Relay contract, through the Bonsai three lay. We're going to go backwards up through E three lay, relay contract.
00:23:25.752 - 00:23:37.010, Speaker A: End of our callback. And now let's take a quick look at what the callback function looks like. So if you recall from the invocation, we picked store result and here's what it looks like.
00:23:37.010 - 00:23:51.576, Speaker A: So this is also in that app contract you should have open here. It's going to be storing the results of our computation. But first it's going to do a check.
00:23:51.576 - 00:24:09.596, Speaker A: Remember I said when I talked about running tests that we do do some checks here? This is where those come in. Now that we run those checks, we're going to store our values. We've Twicted cache just as a way to do this for demonstration purposes, but you don't have to make a cache for it.
00:24:09.596 - 00:24:41.770, Speaker A: You can do pretty much anything with the results that you wanted to do with the app contract. This is the final fully deployed form of the project, and I'm just going to show you real quick how the local project is set up, what it does, and how it differs from this final form. Okay? So now we're going to ask how the local development setup compares to a deployed project so that you get an idea of how you're going from what you're building locally to how you're using a real boneside proving service.
00:24:41.770 - 00:24:51.956, Speaker A: Let's take a quick look here. This is going to be the local version. So this is when you're running the execution only in the local proving modes.
00:24:51.956 - 00:25:10.528, Speaker A: You'll notice everything is contained in Foundry. You've got an app contract with Invocation and Callback functions. It's only making mock calls to Bonsai because what's really happening is from the command line, we are running the Zkvm program, we're generating the proof, and we're getting the results back to the callback function.
00:25:10.528 - 00:25:24.276, Speaker A: So everything here is happening locally, both the app contract side and the proving side. So here we're going to be. There we go.
00:25:24.276 - 00:25:54.296, Speaker A: So here's the Bonsai proof mode. And this part you'll notice that you still have everything contained in Foundry, but this time we're using the real relay contract, connecting to the Bonsai E Three lay and reaching out to Bonsai, which then generates a proof after running your off chain compute in the form of the Zkvm program. So once you turn on proofing with the Bonsai proof mode setting, you're still going to be using these contracts in Foundry, but you'll be hitting the real E Three lay and then running your Zkvm program on Bonsai.
00:25:54.296 - 00:26:20.064, Speaker A: So there's a bit of a middle step here we've handled behind the scenes. If you're wondering how the compiled version of your Zkvm program gets over there when you first make your request, we're going to do an upload to the Bonsai proving service behind the scenes to make sure your program can run over there. Now, this is just a preview, but you'll see it's pretty similar between what's contained in Foundry and what we're actually going to deploy on the ethereum network.
00:26:20.064 - 00:26:47.468, Speaker A: You'll deploy your app contract, we'll have a deployed relay contract, and everything else will proceed the same as it did when you were using a local setup that reached out to Bonsai. So here at the very end, I just want to add on a few programming gotchas and go a little bit deeper into some ZK knowledge, but not too deep, just enough to kind of understand a little bit of the magic we're adding here in the form of a ZK proven off chain computation. So the programming gotchas are between the relay and the ZK code.
00:26:47.468 - 00:27:09.796, Speaker A: So on the relay side, we do want to emphasize this is experimental. That means not only is it subject to change, but we prefer during this hackathon, you not run millions of dollars through it. The callback is only going to check for a value identifying the executed program, and also to make sure that it's coming from the relay that you think it's coming from.
00:27:09.796 - 00:27:30.108, Speaker A: And we went over that a little bit when we ran through the tests, but I just want to emphasize it here for security's sake. You technically still have some responsibilities over making these checks. And you should be aware that inputs aren't stored when you ask Boneside to execute the Zkvm program.
00:27:30.108 - 00:27:51.712, Speaker A: So for now, you're going to be needing to send them as parameters every. Time you run an off chain computation and then programming gotchas on the ZK side are pretty simple as far as the ZK code goes, you're going to have to decide what you want to send back to your app contract. So those results need to be explicitly shared back it is in Rust.
00:27:51.712 - 00:28:19.512, Speaker A: So you are going to be hopping out of solidity briefly, but we think it's, as Rust goes, fairly straightforward and you want to remember to set the Bonsai proving variable when you're ready for a proving run so that you're not just doing execution only. Now here, as promised, we're going to get into a little bit of zero knowledge information and I'm just going to start by describing what the VM does. Instead of building your own circuit, you're going to use our zero knowledge VM.
00:28:19.512 - 00:28:37.120, Speaker A: It has kind of a processor based architecture and one of the advantages is we've got assigned registers. We can expect some very predictable behavior and at a high level you know that you ran the expected computation, that you actually ran it. It's not just saying, oh, this would run on the EVM.
00:28:37.120 - 00:29:00.152, Speaker A: So when it comes to inspecting, we're actually demonstrating that each low level operation made changes in roughly the way we are in the way that we expected and that's going to tell us at a deeper level that our computation ran the way it's supposed to. And we can do that all without having you generate any custom circuits because it is a general purpose virtual machine. So for our purposes though, this step we can just consider sufficiently advanced technology.
00:29:00.152 - 00:29:19.600, Speaker A: What I really want to focus on is that when this is all complete, we're producing a receipt and this is the really important part for our purposes. You'll see the receipt referenced in some of the source code you're going to be playing with and I wanted you to understand what these pieces are and what the language is that we're using for these pieces. So this is the really important part for our purposes.
00:29:19.600 - 00:29:34.388, Speaker A: The receipt is just one artifact I want to focus on because it gets us two different pieces of information first. Anybody who has it and reads it knows your computation executed correctly, right, according to our off chain notion of correctness. And they're also able to see the results you chose to share.
00:29:34.388 - 00:29:58.120, Speaker A: So just like we saw with the Zkvm program's commit method, this is going to be how the app contract gets its return values that's going to be on the receipt as well as confirmation that your program ran the way it's supposed to. So with that said, you might be wondering where we're going to store these results and the answer is in a roll up. But we promise we're not trying to lock you in, that's just our scaling solution.
00:29:58.120 - 00:30:09.048, Speaker A: So you're also not under any obligation to use our roll up. These results can be stored anywhere, though possibly not in this hackathon weekend. We're also not trying to do an EBM style roll up.
00:30:09.048 - 00:30:26.016, Speaker A: So again, our proofs are independent of on chain logic and they just say your receipt checks out, which means your proof checks out, which means we're sure your computation checks out. And so with that in mind, let's get back to the hackathon. I want to do a quick review of the essentials for the weekend.
00:30:26.016 - 00:30:51.064, Speaker A: So here is what you're going to need. You're going to need Rust Foundry and the Bonsai Starter Template project and here is what it's going to look like when you develop locally and when you prove on Bonsai from a locally stored contract call. As a reminder, you don't need to do the system on the right to qualify for any of the bounty prizes.
00:30:51.064 - 00:31:03.632, Speaker A: So if for some reason you haven't gotten around to receiving an API key or URL for us by the end of the hackathon, please don't let us stop you from submitting. We'd much rather see an interesting creative piece. That said, we think the process should be pretty quick.
00:31:03.632 - 00:31:16.464, Speaker A: We'll try to get back to you and get you whitelisted and get you some URLs and keys. I just want to make sure that, you know, you don't have to wait for that. So here just to quickly review our two bounties.
00:31:16.464 - 00:31:31.144, Speaker A: The first one is DAP Development. And again, this could be an interesting DAP. This could be an interesting or powerful off chain computation, or this could just be a nice educational piece and we want you to try out our services.
00:31:31.144 - 00:31:39.992, Speaker A: But if you want to just do local development, that's just as eligible. The second bounty is going to be developer feedback. So again, use the link in our prizes section.
00:31:39.992 - 00:31:54.720, Speaker A: You're going to work with our developer template and provide us with feedback and then a commitment, a very brief one to follow up if requested. So this is going to be about providing some rich feedback about what it was like to work with our template. And with that said, let's see.
00:31:54.720 - 00:32:09.188, Speaker A: Hanging out at the hackathon, I'm going to be describing real quick here's a few ways to get in touch with us. We've got Discord, so if you go onto the Risk Zero webpage, you can quickly find our Discord and join. You can reach out and talk to us in person.
00:32:09.188 - 00:32:25.272, Speaker A: We are going to be hanging out during team formation. If you've got some project ideas and want to float them by us or bounce them off of us and try and get creative with it, we're more than happy to help you talk about ideas. That said, the project ideas do need to be your own.
00:32:25.272 - 00:32:45.504, Speaker A: So we're just there to answer questions. And if you want help during the hackathon, we're going to have folks there who will be floating around. If you'd like to come talk with us about what we're building before the hackathon, we will be hosting a side event on Friday that you can see linked via the prizes page.
00:32:45.504 - 00:32:56.640, Speaker A: There's going to be an event page there. And then lastly, if you want to talk to us after the hackathon, please feel free to join our community discord. Reach out, ask questions and keep playing.
00:32:56.640 - 00:32:57.340, Speaker A: Bye.
