00:00:06.330 - 00:00:08.462, Speaker A: All right. Hi, everybody. Thank you for being here.
00:00:08.462 - 00:00:20.510, Speaker A: I'm Jack, and I am a developer relations engineer at O of One Labs. We're the company that incubated the Mina Protocol. And now we continue to build tools for Mina.
00:00:20.510 - 00:00:40.140, Speaker A: And that's what we're going to talk about today, is Mina and Snarky JS, which is the smart contract language for yeah, here's our agenda. We have sorry, this is, like, in the way a little bit. I'm going to be like that.
00:00:40.140 - 00:00:52.506, Speaker A: Okay. So, yeah, first we're going to talk about Snarky JS, which is a TypeScript library that you can use to build zero knowledge proofs. And it's also the smart contract language for the Mina Protocol.
00:00:52.506 - 00:01:27.750, Speaker A: We'll go through an example, building a simple contract that will let you only increment a number if it's the next number in the Fibonacci sequence. And then we'll make it recursive, which is a strategy that we can use to allow this code to actually, we'll just cross that bridge. When we get to it, we'll talk about the Muna Protocol, which is sort of like a more general Snarky JS.
00:01:27.750 - 00:01:46.634, Speaker A: It's a TypeScript library for defining zero knowledge proofs, and it's also the smart contract language for the Mina Protocol. And it looks like this, but you don't have to worry too much about that because we'll dive in in a lot more detail in just a second. Everything is in TypeScript, so you can keep using the tools that you're familiar with, like prettier ESLint vs.
00:01:46.634 - 00:02:05.780, Speaker A: Code NPM, and it's very easy to learn. The IntelliSense is so good that I think probably most people can just dive into a repository of existing code and kind of make sense of it just by hovering over the things that they don't understand. And we have good descriptions of what it all does.
00:02:05.780 - 00:02:20.442, Speaker A: It's also extremely powerful, and this is for two reasons. The first is Kimchi, which is our proof system, and it's absolutely state of the art. It has a number of features that are really unique to it, and it's extremely well suited to this use case.
00:02:20.442 - 00:02:31.470, Speaker A: So, first of all, it has a fully trustless setup, so there's no ceremonies, there's no sort of toxic waste. It just works. We have custom constraints for poseidon, elliptic curves, and encryptions.
00:02:31.470 - 00:03:05.254, Speaker A: So this makes operations that you'll end up doing a lot dramatically more efficient. The proof size is constant, so you can do as much computation as you want, and the proof always stays the same size and is the same computational complexity to verify it's recursive, which means that you can actually create a proof and then verify that proof inside of the process of creating another proof. And that has a lot of really sort of cool implications that we'll talk about a little later.
00:03:05.254 - 00:03:16.198, Speaker A: And finally, it's plonkish so we can add new features like dynamic array access and a few other things we're working on. What about the Snarky JS library? So this is the other side of the equation. The Snarky.
00:03:16.198 - 00:03:34.002, Speaker A: JS. Library we've built to be as easy to use as possible and as expressive as possible method chaining makes it very easy for developers to think through their programs in a linear way. You kind of think like here's my data, here's what needs to happen to it, here's sort of where it ends up.
00:03:34.002 - 00:04:05.958, Speaker A: And it makes it more sort of apparent what's happening inside your contract versus what's just sort of happening in maybe code that runs prior to your contract's execution or something like that. So yeah, we can see what this looks like. If we want to know if this guess is not equal to zero, we can call this equals method and then just chain on to the end the not method.
00:04:05.958 - 00:04:24.270, Speaker A: And we can do the same thing if we want to add two values together. We can call just this add method on white pegs and pass in an argument. So custom circuit values provide a layer of abstraction that makes data a lot easier to think about.
00:04:24.270 - 00:04:34.900, Speaker A: This is basically a class that we have that you can extend in order to create. In this case, we have pegs. This is like four pegs as part of a board game.
00:04:34.900 - 00:05:03.118, Speaker A: Fundamentally zero knowledge troops require that everything that you work with is is represented in this type called a field. It's, it's basically very similar to unsigned 256 bit integer except for that division works a lot differently. And yeah, it's not too important to dive into why this is necessary, but it's universally required by all of the zero knowledge proof systems that exist today.
00:05:03.118 - 00:05:29.986, Speaker A: And it makes programming a little bit harder, especially when you're getting started. And so the circuit value abstraction will let you define basically a way to take some type that you're more used to working with. Like in this case, like a JavaScript object that has four values for each of these pegs.
00:05:29.986 - 00:05:46.550, Speaker A: And then it'll map it into these field elements for you and do the inverse when it comes time to take something from the representation in the circuit into a representation that's easier to work with. And finally, a lot of the stuff that you need is already implemented in Snarky. JS.
00:05:46.550 - 00:06:20.390, Speaker A: So what we have included today is all of these types efficient poseidon hash functions, efficient encryption and decryption, efficient signatures, merkel trees and their recursion API. And so all of these types are circuit values that are again constructed out of this field element. Ultimately they're composed of the field element but you can work with them just like you're used to working with like an unsigned 64 bit integer in whatever other language.
00:06:20.390 - 00:06:50.282, Speaker A: So why did we choose TypeScript? And the reason is because we're ecosystem focused. And $0 groups are cool because they open the door for cryptographers and stuff to build crazy new things that make things that seem intuitively impossible possible. But it's also really cool if we can then make this available to people who want to build protocols or products that are user facing.
00:06:50.282 - 00:06:56.210, Speaker A: And so that's kind of what we're going for. We're going for code reuse. That's as high as it is in the JavaScript ecosystem.
00:06:56.210 - 00:07:15.880, Speaker A: Yeah. So we'll also sort of touch a little bit more on this a little bit later. So here's kind of everything we talked about and just there for the sake of if you go back and look through the slides after, you can get like a condensed kind of view of everything.
00:07:15.880 - 00:07:28.390, Speaker A: So how does Snarky JS work? Oh, and also the slides will be available after there's a QR code. You'll be able to scan it and it has all sorts of information, everything I talked about it's good. So how does Snarky JS work? Here it is in five sentences.
00:07:28.390 - 00:07:41.902, Speaker A: It's a TypeScript library. All the information is represented in one of the Snarky JS compatible types, which is eventually all of them are composed of this field type. And then Snarky JS provides classes and functions that are compatible with the field type.
00:07:41.902 - 00:08:13.834, Speaker A: And it can represent anything that you do using these methods on these types as like what's called an Arithmetization, which is basically a math problem representation of the program, which is important because then we can feed it into the Xeronola true system, which is itself basically a math problem. And so a user that's interacting with Snarky JS program can run it as normal TypeScript. And then if they want to, they can actually pass all of these values that are computed as they're running it.
00:08:13.834 - 00:08:46.866, Speaker A: Basically, they can pass their execution trace into this math problem that we generated and use this to create a zero knowledge proof. And so, yeah, the developer experience feels very much like if you view something like react it's like, yeah, this is pretty much JavaScript, but we have maybe like another layer on top of it now that's expressive and kind of helps us do something specific. It's pretty easy to get started with.
00:08:46.866 - 00:09:09.094, Speaker A: Okay, so how did the smart contracts work? And yeah, developers write them in TypeScript and then they deploy just the verification key to a Zkap account. So the verification key is like a commitment to the code with the added property that it can be used to validate these zero knowledge proofs that are generated by the code. And so when we want to deploy a ZK app to Mina, we just send a transaction with this verification key to the MENA network.
00:09:09.094 - 00:09:20.042, Speaker A: And that's the only thing that's stored on chain. So the code actually doesn't live on chain only this verification key lives on chain. And then the users run the smart contract in their browser and they generate a zero knowledge proof of their interaction.
00:09:20.042 - 00:09:27.746, Speaker A: So the code doesn't run on the chain, it actually runs in the browser. And this is cool for a couple of reasons. Yeah.
00:09:27.746 - 00:09:41.634, Speaker A: So we send the transaction, it's a zero knowledge proof. If it's valid, then the transaction is applied, and if it's invalid, then it's dropped. So if the Mina blockchain can validate this zero knowledge proof, it commits any relevant state updates.
00:09:41.634 - 00:09:53.734, Speaker A: And this is kind of what this looks like from a higher level, is we have the Smart Contract method. We pass into it some arguments that the user generates some smart contract states. So this is actually the state of the Smart Contract.
00:09:53.734 - 00:10:05.870, Speaker A: It has to be passed in as an argument. The reason is because the Smart Contract doesn't run on the blockchain. And so, yeah, we have to grab the values, pass them in and run them ourselves.
00:10:05.870 - 00:10:19.074, Speaker A: And then we also get some values for the state of the world. So this would be things like block height, if that's something that's important in your transaction. And then what we get out is updates to the state of the Smart Contract and updates to the state of the world.
00:10:19.074 - 00:10:44.998, Speaker A: And so when we run a Smart Contract on Mina, what it ends up looking like, if we have something that has the net effect of transferring some balance from you to me, let's say what I'll actually do is I'll just send a zero knowledge proof as well as two new values. And so one will be your balance, which will be lower, and one will be my balance, which is higher. And as long as knowledge proof is valid, then we know that's legal.
00:10:44.998 - 00:11:11.220, Speaker A: And so we can just write these two values that's more on that. So how do ZK apps work? You can install your Smart Contract into your UI repository and deploy it and that's all there is to it. The Smart Contract is a bunch of TypeScript code, you can put it on GitHub or NPM or whatever, and then you can just install it into your front end repository with NPM install.
00:11:11.220 - 00:11:27.400, Speaker A: Very simple. Okay, so now we'll get into a code example. So the Fibonacci Sequence is a sequence of numbers that's each next number in the sequence is the result of summing the prior two numbers together.
00:11:27.400 - 00:11:39.526, Speaker A: And we'll write a Smart Contract that will compute the next number of the Fibonacci sequence. It'll have two pieces of state, n minus two and N minus one. And it'll have a single method update.
00:11:39.526 - 00:11:59.522, Speaker A: And this will let us update n minus two and n minus one if we pass in the correct number, the correct next number in the Fibonacci sequence. And so to write a ZK app, we can just extend the Smart Contract class of Snarkyjs. So we have a smart contract called Fibonacci Sequence here, and then we can define our on chain state.
00:11:59.522 - 00:12:15.938, Speaker A: And this is done, we just have these variables and we add this state decorator and pass in as an argument the type of the state. So here we're creating two pieces of state. Each one has a field type and this will live on the actual Mina blockchain.
00:12:15.938 - 00:12:49.074, Speaker A: And Snarky Jest will sort of do the work to say we changed this, we proved that we changed it the right way and we made sure that the MENA network got the request to change this. The next thing that we have is we have this deploy method and this is actually a method that gets called as the Smart Contract is being deployed. So this deploy ARGs is a thing that usually the Zkapp CLI, which is a piece of developer tooling we'll talk about in a second, will pass in.
00:12:49.074 - 00:13:08.150, Speaker A: For the most part this can stay exactly as you see it here. In most contracts it can be used to configure a couple things at deploy time like set permissions for the contract or for the contract account and stuff like that. And in this case we're going to actually also use it to initialize the value of these on chain state values.
00:13:08.150 - 00:13:40.366, Speaker A: And so we'll set N minus two to zero and N minus one to one. The next thing is we'll add our actual method that the users will call Update. And you can see Update takes N as an argument which is of the type field and we add this method decorator and the method decorator basically tells Snarky JS hey, this is code that users are going to call the same way that users would call like a method on an Ethereum Smart Contract.
00:13:40.366 - 00:14:09.900, Speaker A: And when users do call it, we should prove that it executed correctly and then send this on to the meta network. So something that's worth calling out here is that any argument that we pass into the method and anything that happens inside of the method is totally private. It happens in your computer and it doesn't leave your computer unless it eventually does something like emits an event or sets some piece of on chain state.
00:14:09.900 - 00:14:35.474, Speaker A: But even in those cases you could emit an event which is like a hash of the real value and have a commitment, or you could store a hash of the value. It's much easier to keep even permanent storage private in this way, but yeah, that's worth calling out. Finally we'll start to make the functionality of this method.
00:14:35.474 - 00:15:02.240, Speaker A: And so the update method here, we want it to grab the value of these N minus one and N minus two on chain state variables. And so we just call the get method on N minus one and N minus two and we set it into this constant current N minus one and current N minus two. And so when the Smart Contract runs, this get method basically says contact the amino blockchain, get the values, store them here.
00:15:02.240 - 00:15:25.366, Speaker A: The next thing that we have is we'll compute what the next number in the Fibonacci sequence should be and we do this just by calling the add method on N minus two and passing it as an argument n minus one. And so we have the sum of the last two values then in this new state. And then we assert that it's equal to the value that we passed in.
00:15:25.366 - 00:15:57.038, Speaker A: And so this assert equals statement means that if this condition doesn't hold true, it will not be possible to generate a zero knowledge proof that's valid. And so yeah, if you pass anything other than the next number in the Fibonacci sequence into this method, you just won't be able to get a valid zero knowledge proof out and so you won't be able to send a valid transaction to the munin network. Then finally what we can do is we can actually set this on chain state to something new.
00:15:57.038 - 00:16:24.370, Speaker A: And so we'll set N minus two to current N minus one and we'll set N minus one to the new state. And so this is just sort of shifting everything over one. And so when we do this also again, Mina will make sure that you can't call these set methods unless everything that's happened is sort of attested to with this valid zero knowledge proof.
00:16:24.370 - 00:16:50.560, Speaker A: And so yeah, this is just as secure as doing this directly on another blockchain setting some kind of state from within your contract. This is kind of like the general structure of this. Generally we define our on chain state sort of at the top we have our deploy method and then we add the actual user callable methods below that.
00:16:50.560 - 00:17:13.650, Speaker A: So this is cool, but what else can we do? Well, we can make it recursive. And so this is something that's unique to the way that Mina works and to our proof system, at least it is right now. And this is that our zero knowledge proofs can actually be passed as arguments into other zero knowledge proofs and validated inside of those zero knowledge proofs efficiently.
00:17:13.650 - 00:17:43.838, Speaker A: And so what this means is that I don't know, if I have a lot of computation, I might split it into ten different chunks, run each of these chunks, prove that we ran it correctly and then actually take those proofs and prove that we've aggregated them together correctly. And so yeah, we can embed recursive proofs into each other with arbitrary branches and merges and we can do it an infinite number of times. And this is made possible with this ZK program thing.
00:17:43.838 - 00:17:57.822, Speaker A: So this is basically a smart contract without it's like sort of a stripped down smart contract. It's just the program smart contract is kind of a superset of this. And so we define a public input, some methods.
00:17:57.822 - 00:18:32.362, Speaker A: But what we can see is that for our private inputs here, we're actually passing proofs in and we can see that the method here takes still an N value, but it can also take in this Fib One and Fib two, which are both proofs of the same kind that this will generate. So this thing makes a proof and then it can actually also take the proofs that it makes as arguments and make another proof from that. And so what we do is we verify these two proofs, and then we do basically the same thing that we did earlier.
00:18:32.362 - 00:18:52.294, Speaker A: This can be quite powerful in a lot of cases. It lets you do things like build if you want to do something like build a game, but you don't want to have users wait for blocks and pay gas every time that they want to make a move. We can set the game up in such a way that I make a move.
00:18:52.294 - 00:19:10.726, Speaker A: I prove to you that I made the move correctly. You actually look at the proof that I made my move correctly, make your move, and then prove that your move is correct, and also prove that you've verified the proof of my move correctly. And then we go back and forth this way, and at the end, we have a single proof the same size as each of its prior proofs.
00:19:10.726 - 00:19:23.134, Speaker A: We're not like, creating more and more information here. We're just back and forth this fixed size chunk. And at the end, we have this proof that attests to the entire history of the game.
00:19:23.134 - 00:19:35.634, Speaker A: And so we can actually submit that proof then to the Mina blockchain in the form of like a transaction or something, and settle the whole game in just one transaction. So no need. It's basically very good.
00:19:35.634 - 00:19:43.666, Speaker A: UX. Same as like in a normal game, because you don't wait for blocks and you don't pay transaction fees only at the end. And so it's pretty straightforward.
00:19:43.666 - 00:20:06.974, Speaker A: We can just wrap our ZK program inside a proof class and then we can pass it in with this, I guess. Yeah, we set the the type of the argument that we pass in to be this Fibonacci sequence proof, and then we just call verify. And as long as the proof is valid, then we go through.
00:20:06.974 - 00:20:19.474, Speaker A: If the proof is not valid, then again, it's impossible to generate a valid proof of this bit. So pretty cool. Okay, so now we get to kind of the interesting part.
00:20:19.474 - 00:20:34.550, Speaker A: This is a tool that you can use to build stuff and then you can use to build things for Mina. And Mina is a layer one blockchain that proves its entire finalized state using these recursive zero knowledge proofs. What this means is that it doesn't grow.
00:20:34.550 - 00:21:05.774, Speaker A: It stays a fixed size over time, or at least the amount of information that you need in order to validate the current finalized state of Mina stays a fixed size. And so that means that if I have an account, I can store the state route a proof that the state route was gotten to via a legal sort of path, and then all the information for my account that I need in this 22 KB. So this is really cool, but it's actually also really useful.
00:21:05.774 - 00:21:20.930, Speaker A: And there's quite a few reasons the first is privacy. So Ethereum smart contracts run on every single node and so the information is all public. Mina smart contracts run in the browser and so the arguments and the intermediary values are private by default.
00:21:20.930 - 00:21:33.894, Speaker A: You can see the only thing we send is our state update and our proof. And we verify the proof and then we update the state if it's a valid proof. It also opens the door to being able to scale things more easily.
00:21:33.894 - 00:21:58.606, Speaker A: So there's no gas model ZK apps run off chain and the amount of the computation does not affect the transaction cost. You can do actually as much computation as you want to inside of a single transaction. You can make these transactions asynchronous sorry, you can make this computation asynchronous you can do all kinds of crazy stuff because it's literally just TypeScript code that then proves that it ran correctly.
00:21:58.606 - 00:22:23.286, Speaker A: And we get this fixed size proof no matter how much computation we do. So that's pretty cool. And then you can also use this to build these application specific roll ups, which is this kind of idea like the game that we talked about a little bit earlier, we can build basically because we don't need the whole network in order to prove that we've sort of ran something correctly.
00:22:23.286 - 00:22:40.800, Speaker A: We're depending on cryptography instead of game theory. We can prove things in more narrow contexts and then only settle to chain when we need to. And so this makes it possible to build all kinds of things that would be too expensive to build them on even very scalable blockchains today.
00:22:40.800 - 00:22:52.974, Speaker A: Finally, it increases decentralization. And the reason is because it's possible to validate the whole mean estate using only the small zero knowledge proof. And so there's no need to rely on like a trusted third party node operator.
00:22:52.974 - 00:23:08.102, Speaker A: Like infura people can connect directly and it also makes bridging easier. And this is pretty cool. So smart contracts on other chains, they can bridge the entire amina state just by verifying the most recent proof.
00:23:08.102 - 00:23:28.686, Speaker A: So there's no sort of like multi SIG or weird sort of, I don't know. It's not like a normal bridge. It's basically like you can verify that the Mina consensus has worked correctly and worked up to a certain point just by taking this most recent proof and verifying it.
00:23:28.686 - 00:23:47.220, Speaker A: And so if you can write a smart contract that can do that on Ethereum, then you can bridge the whole MENA state to Ethereum without introducing any additional trust assumptions and without having to lock any kind of liquidity anywhere. There's nothing. It's very simple.
00:23:47.220 - 00:24:07.580, Speaker A: A user basically says, hey, here's the Mina state route and the zero knowledge proof of it. I'm just going to call this method on this Ethereum contract pass in the state route and the zero knowledge proof. This contract will verify the zero knowledge proof and if it's valid, and if the block height is higher than the last one, then we'll just update the state.
00:24:07.580 - 00:24:16.910, Speaker A: It's very cool. And actually the Nil Foundation is working on this and they have a demo on testnet. And so if you want to there's also a link to this in the QR code at the end.
00:24:16.910 - 00:24:29.230, Speaker A: You can experiment with this. This bridges the whole Mina state to I forget which testnet, but one of the Ethereum testnets and this is an audit. Now we also have oracles.
00:24:29.230 - 00:24:54.570, Speaker A: So users will be able to create TLS proofs that can bridge data from any website onto the MENA blockchain. And the way that this kind of ends up working is that right now when you go to a website you get the little lock in the side of your browser and this is the result of an interactive process and it basically guarantees like hey, I really am connecting to Amazon. They actually are Amazon, I'm sending them my credit card information and I know that nobody can see it basically.
00:24:54.570 - 00:25:21.010, Speaker A: And so it makes these guarantees but it's in an interactive process and so it doesn't work for something like a blockchain. Amazon can prove to me that they're Amazon and that we had the interaction we had, but they couldn't prove it to Ethereum because yeah, it would have to be this sort of interactive thing. They can't just generate a signature or something that says, hey, this all worked nicely.
00:25:21.010 - 00:25:56.366, Speaker A: But with zero knowledge proofs you can take these interactive processes and turn them into static non interactively verifiable proofs. And so doing this with Mina, this will allow us know basically you can go to whatever website you want to, you can prove that you really went to that website, that the website really was the know, they really had the certificates for their domain name or whatever and that they really sent you something. And so I could do something like, I don't know, prove that I logged into my bank account and they sent me a web page that says I have a balance with X number of dollars.
00:25:56.366 - 00:26:20.386, Speaker A: And then I could actually take that proof and I could feed it into another proof that says let's verify that Jack is a unique person by hashing his Social Security number or something and checking that it's not in a list. And then also let's check if Jack has more than $1 and then if I have more than $1 we spit out a Boolean true. And if I don't, then we spit out a Boolean false.
00:26:20.386 - 00:26:43.786, Speaker A: And so we can augment this information as much as we really want to. And actually also probably right after this presentation we'll have a tutorial live that lets you build something similar to this for it's like a fake credit score. Oracle, it's just API that returns a fake credit score and is signed.
00:26:43.786 - 00:26:59.666, Speaker A: And so you can do this today with signed data. But what ZK Oracles will allow you to do is also have sort of signed data that comes through a necessary exchange. So that's pretty cool.
00:26:59.666 - 00:27:18.520, Speaker A: And what else? Well, we actually don't know everything that's possible yet. And this is what we're hoping that people like you guys here help us figure out. There are a lot of things, like probably every six months it seems like we found out new things that are possible that we didn't know were possible six months ago.
00:27:18.520 - 00:27:29.434, Speaker A: So that's the point of coming to hackathons and having people like you build stuff. There's probably a lot of cool things that are possible to make that we haven't thought of yet. And you should build them.
00:27:29.434 - 00:27:34.510, Speaker A: And we have prizes. We'll give you money if you build them. Yeah.
00:27:34.510 - 00:27:44.174, Speaker A: So where to learn more in questions and answers? How do you get started? Super, super simple. Install the Zkap CLI. This is our only piece of developer tooling.
00:27:44.174 - 00:28:02.902, Speaker A: It's very powerful and it's very simple to use. You run ZK projects, call it something and it'll spit out a repository with some Scaffold code. The Scaffold code is just a smart contract that adds, I think, two numbers together and stores that on chain but testing stuff.
00:28:02.902 - 00:28:16.300, Speaker A: All set up, linter all set up. Everything good to go, basically. And then when it comes time to deploy it, the Zkap CLI will connect to a testnet and create a transaction that deploys this application.
00:28:16.300 - 00:28:43.410, Speaker A: So yeah, you can install this really easily and you can just get a project and like I said, the easiest way to get started, install it, get a project and just poke through the code using IntelliSense and see what's going on. It should be pretty straightforward ways that you can get involved with the community are we have ZK apps, building them, that's a good thing. You can make educational content or you can sort of do mentoring, like hanging out in Discord and stuff.
00:28:43.410 - 00:28:58.310, Speaker A: Mina foundation has quarterly grants that are backwards looking, so if you do something cool, maybe in like two months they'll give you money or something like that. And then finally, these are our social media pages. Here's the discord.
00:28:58.310 - 00:29:12.922, Speaker A: Here's the link to our docs. And you should definitely join the Zkapp Developers channel on our Discord. This QR code here has link to a notion page that has the slides for this presentation.
00:29:12.922 - 00:29:24.320, Speaker A: Links to a couple of other presentations that have information on other things. Link to the Nil Foundation stuff. Basically, all the information you want is behind this QR code.
00:29:24.320 - 00:29:28.510, Speaker A: I think that's all. Yeah. Thanks everybody, for listening.
00:29:28.510 - 00:29:31.180, Speaker A: Awesome.
