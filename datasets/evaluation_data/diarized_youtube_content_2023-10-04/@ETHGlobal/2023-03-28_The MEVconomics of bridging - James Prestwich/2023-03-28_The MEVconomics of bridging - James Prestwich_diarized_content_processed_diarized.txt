00:00:06.410 - 00:00:13.200, Speaker A: So we're going to move on now to James, who's going to be speaking on the meth economics of Bridging. How's it going?
00:00:13.810 - 00:00:40.170, Speaker B: Yes, I'm going to be talking about a specific Mev mitigation within the context of Bridging. I think I was required by Tina to put the word medkenomics in the title of the talk. So what we're really going to be talking about is using the structure of a bridge and partially ordering messages in order to mitigate mev in the crosschain context.
00:00:40.170 - 00:00:53.040, Speaker B: So I'm James. I've been working on Bridging and mev since late 2017. Early 2018? I've been around the block a few times.
00:00:53.040 - 00:01:15.380, Speaker B: You can find me on Twitter and GitHub. Generally speaking, when we talk about a bridge, we're talking about two one way communication channels between blockchains from chain A to chain B and a separate system to go back from chain B to chain A. The general pattern that these work in is chain A will dispatch a message.
00:01:15.380 - 00:01:33.930, Speaker B: Some off chain actors will pick up that message and deliver it to chain B. Chain B will do authentication and validation of the message and then deliver it to the application that receives it and handles it. So if you put it on a timeline, it looks a little bit more like this.
00:01:33.930 - 00:01:58.126, Speaker B: Each of these steps is atomic on chain or takes a very tiny amount of off chain time. And then there's these big in computer time gaps between the actions. It sometimes takes tens of seconds for an off chain actor to pick up a transaction from the blockchain, or they might wait several minutes for it to finalize in the proof of stake consensus.
00:01:58.126 - 00:02:25.510, Speaker B: So these gaps between the origination of a message and its handling by the off chain actors can be minutes. And the gap between the off chain actors getting the message and its confirmation of receiving chain can be several minutes as well. As we probably know, Mev is a result of time gap between committing to what you want to do and that being executed.
00:02:25.510 - 00:02:52.622, Speaker B: It's a result of people being able to insert, reorder or sandwich your transactions after you've committed before their process. And so crosschain bridging has a lot of opportunity for Mev to sneak in because there is such a long time gap from the perspective of each chain. So Mev in a sense is about early access to information and cross chain bridging.
00:02:52.622 - 00:03:15.930, Speaker B: That information is public so long before it gets acted on on the remote chain. So everyone has 10 minutes of warning on what this message does and what it's going to do when it hits the remote chain and how to front run that message most effectively. So from a perspective of the remote chain, the receiving chain, a message and a TX are equivalent.
00:03:15.930 - 00:03:37.682, Speaker B: The message comes into the chain, someone off chain submits it and it kicks off some amount of computation or smart contract running or whatever. So a message at a transaction can be included in the block essentially the same as transactions. Reordering and Sandwiching for crosschain messages work just the same.
00:03:37.682 - 00:03:56.550, Speaker B: But again, you have 10 minutes advanced warning instead of seconds. So mev pushes the ordering of a blockchain towards the maximally extractable ordering. The ordering in the block which provides the most value to the searcher builder proposer supply chain.
00:03:56.550 - 00:04:25.890, Speaker B: So everything gets shuffled, mev transactions get inserted and the proposer ends up making a bunch of money. So what we want to do is mitigate the impact that Reordering and sandwiching have on crosschain messages because crosschain messages are more vulnerable than the average transaction. So we're going to change the message flow a little bit that I talked about earlier.
00:04:25.890 - 00:04:47.510, Speaker B: Rather than immediately dispatching to the other chain, we're going to accumulate on the first chain on the sending chain a batch of messages. And this should be a batch of messages that touches the same application or the same state. And rather than committing each individual message, we want to commit to a batch.
00:04:47.510 - 00:05:39.130, Speaker B: So you take all of your cross chain messages and you put them into a single unit and then you dispatch that batch and process the batch on the other end. So what does this get us as a mechanism? Why do this at all? When you are extracting value from the remote chains block ordering, putting it in a batch preserves the relative ordering of those messages. It prevents the miner or the searcher or whoever from extracting value by reordering the batch and it prevents the searcher from extracting value by inserting within the batch.
00:05:39.130 - 00:06:06.210, Speaker B: They change to the semantic message handling of the bridge that mitigates the ability to extract mez by preventing insertion and reordering for specific transactions. And we do this by changing the bridge and the way it handles messages. This usually introduces a small amount of latency, but as a result, you can't be abstracted from it easily.
00:06:06.210 - 00:06:31.450, Speaker B: So we can extend this to reorder batches upon receipt. So when a batch hits the remote chain, the destination, we can reorder that batch on chain using a deterministic but difficult to predict ordering. This can be as simple as just shuffling based on the block hash of the destination chain.
00:06:31.450 - 00:07:07.398, Speaker B: Usually you don't want to use a block hash for entropy because it is in some sense predictable and manipulatable. However, we're not trying to prevent manipulation, we're trying to make it more expensive. So what this does is instead of delivering all messages in the order they were dispatched, you can shuffle all of the messages using pretty bad randomness and then make sure that the messages are delivered in the shuffled order.
00:07:07.398 - 00:07:20.010, Speaker B: And you might be thinking, can't a searcher just continually reshuffle until they get a good ordering that's more abstractable? And yeah, they can. But we have a word for that. It's called proof of work.
00:07:20.010 - 00:07:50.318, Speaker B: So the searcher now has to iteratively repeat some shuffle hash function and then try to extract upon that blob and it has to repeat that many times, trying to find the best shuffling. And so searching on these shuffled batches becomes a proof of work problem. It increases the cost to the searcher in a way that mitigates the amount of mev that the searcher can extract.
00:07:50.318 - 00:08:13.162, Speaker B: It is less profitable to do this because the batches can be shuffled by the remote chain and because all we're trying to do is increase the cost. We don't need good randomness to do so. We can rely on bad randomness that the searcher might be able to manipulate because manipulating the randomness is equivalent to doing the proof of work.
00:08:13.162 - 00:08:22.858, Speaker B: It increases the cost of extraction. So there are a few pros and cons trade offs to this. It's easy to implement and very little on chain overhead.
00:08:22.858 - 00:08:34.674, Speaker B: It mitigates specific extraction from crosschain messages. Like I said, the band aid. We're increasing the cost, we're not preventing it.
00:08:34.674 - 00:08:50.230, Speaker B: It's a mitigation, not a fix. And in order to be effective, it requires significant throughput. If all of the messages touch state, then shuffling the order has no effect on the outcomes.
00:08:50.230 - 00:09:15.520, Speaker B: This only works if you have several messages, a significant number that touch the same state, so that shuffling changes the outcome of those messages. The other major con is that some applications want a specific ordering. They want to know that messages are received in the order they're dispatched and this does not preserve that property.
00:09:15.520 - 00:09:35.810, Speaker B: So this is kind of a quick doodle on potential bridging mechanisms for me fee mitigation. It is not a full solution and it does not work for every use case, but it's still interesting and fun to think about. So that brings me about to the end of my slides.
00:09:35.810 - 00:09:53.798, Speaker B: There are a few things that I wanted to talk about, but this is a very short time slot, so I'm not going to get to. One of the things I wanted to say is that crosschain mev is almost exclusively statistical mev. It has risk involved because it plays out over multiple transactions.
00:09:53.798 - 00:10:11.680, Speaker B: And mev is the cosmic background radiation in crosschain comms in that it is going from everywhere to everywhere all at once. Every chain is being statistically Arped against every other chain in every sex at the same time. But you can't use that communication to carry any useful message.
00:10:11.680 - 00:10:24.434, Speaker B: I really wanted to make a joke about ordering discretion and ordering indiscretion. So when you're ordering a block, you have discretion. And Tina politely asked me to say the word MEP economics towards the end of the talk.
00:10:24.434 - 00:10:30.870, Speaker B: So this is me saying the word MEP economics and that is the end of my slides.
00:10:35.050 - 00:10:43.830, Speaker A: Awesome. Thank you very much for that. I think we have a minute before Shri Ram is coming on something vaguely related.
00:10:43.830 - 00:10:59.120, Speaker A: I'm curious for your take on the kind of conversation around. There's been a lot in the last week about roll ups and bridges. Are they really defined by the bridge? Or is the roll up this completely separate thing from the bridge and it's all just chains communicating with each other?
00:11:01.650 - 00:11:21.542, Speaker B: So this is something that I fight about a lot. A roll up site definitionally includes a bridge to the layer one. The question that we fight about is whether the bridge determines the correct state of the roll up or whether the nodes determine the correct state of the roll up.
00:11:21.542 - 00:11:42.560, Speaker B: And I land very firmly on the node side of things. I think that the bridge cannot force the nodes to accept any invalid block, but the nodes can force the bridge to accept anything. And as a result, I think that the nodes decide what the state of a roll up is.
00:11:42.560 - 00:11:50.320, Speaker B: Great in the context of.
00:11:52.210 - 00:11:52.794, Speaker A: Keep going.
00:11:52.852 - 00:12:01.534, Speaker B: Sorry. Oh, I can keep talking if we're still waiting. I'm really good at having opinions in the context of bridging.
00:12:01.534 - 00:12:22.454, Speaker B: In this sense, roll ups are special because they have this built in bridge and roll ups are a subclass of sovereign roll ups, which is a roll up without that built in bridge. So you take the sovereign roll up, you add an enshrined bridge and you have a roll up. We just came up with the terminology for these backwards, so the terminology is a little funky.
00:12:22.454 - 00:12:34.060, Speaker B: Sovereign roll ups are the general type. Roll ups are the specialized type with the built in bridge. Awesome.
00:12:36.110 - 00:12:40.206, Speaker A: I was going to say just in time. He through. Did just join the room.
00:12:40.206 - 00:12:47.600, Speaker A: Since we are running a few minutes behind, we will go over to him. Really appreciate the talk. This was great as always.
00:12:47.600 - 00:12:54.426, Speaker A: And we are now going to bring on true on. For the next talk. He will be talking about restaking an mev.
00:12:54.426 - 00:12:54.860, Speaker A: Thank you.
