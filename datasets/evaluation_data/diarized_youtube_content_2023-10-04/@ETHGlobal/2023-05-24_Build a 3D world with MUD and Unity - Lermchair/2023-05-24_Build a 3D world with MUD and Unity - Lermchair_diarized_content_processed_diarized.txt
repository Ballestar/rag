00:00:07.130 - 00:00:17.920, Speaker A: Hello, everyone, and welcome to the Lattice Workshop build a 3D World with Mud and Unity. Joining us today is Learnchair, who will be taking us through this session. And with that, I will pass it over to Learn chair to get the session started.
00:00:18.370 - 00:00:34.978, Speaker B: All right, everyone, I'm Learnchhair, as far as you know, and what we're going to be building today is a multiplayer game in Unity and Mud. So we're basically in this game, you can drive around the little tanks and drop bombs on top of each other. And all this is going to happen on Chain.
00:00:34.978 - 00:00:46.310, Speaker B: So first thing you're going to do is clone the repo. So the repo is named Tank, Mud tutorial, and you can find out this link. And we'll be working off the main branch.
00:00:46.310 - 00:01:03.390, Speaker B: But there is a pull request open called Final, and that has all finished code for the tutorial. And you should also have all the prerequisites like Unity net SCK installed as well. So once you've cloned that, we're going to go ahead and open the scene in Unity.
00:01:03.390 - 00:01:12.926, Speaker B: Go ahead and open the scene in Unity. And you should see something like this. If you don't see something like this, then you have to actually open the scene.
00:01:12.926 - 00:01:25.762, Speaker B: So you go into scenes over here and click on Main. So this project uses a package called Unimud, which you can find in the package manager. If you go here, it's installed from Git.
00:01:25.762 - 00:01:33.690, Speaker B: Note that this is pre alpha software. So it's not even part of the official Mud package yet. So you probably shouldn't use it for anything beyond this hackathon.
00:01:33.690 - 00:02:01.170, Speaker B: So just to make sure we have something that works in the beginning, let's go into our Resources folder here. One SEC, someone wants a link. We're going to go into our Resource folder here and we're going to drag in a Rtank prefab it's anywhere in the scene.
00:02:01.170 - 00:02:23.606, Speaker B: Now, if we just hit play in the editor, you see, I can left click to move my tank around. And I can also hold down e and have like a little targeting thing I can use. Eventually if I click on a tank, I can drop a bottom top of it.
00:02:23.606 - 00:02:34.650, Speaker B: But for now, this is what we have. None of this is on Chain, so we're actually going to delete this because we don't really need it yet. So I'll write some contracts.
00:02:34.650 - 00:03:00.466, Speaker B: So if you haven't done so already, we're going to do first is open the project in our terminal, and I'm going to run Pnpm install in the root. And once everything's installed, we're going to start modeling our data. My assumption is that you guys already have some understanding of Mud in Solidity, so we're not going to be spending too much time on this.
00:03:00.466 - 00:03:17.900, Speaker B: But basically the smart contract code you write here is exactly the same as in any other non unique project. So we want tanks that can move around and attack each other in our mud config. We're going to have a position table and this will have an X and a Y that is an 32.
00:03:17.900 - 00:03:33.952, Speaker B: We also have a health table. We actually don't need this schema thing as well. So for example we have a player player table as well.
00:03:33.952 - 00:03:52.150, Speaker B: You can also just write the type directly. If we only have one thing, you don't really need to specify the schema. And we also have a damage which is a UF 32 missing eight.
00:03:52.150 - 00:04:35.664, Speaker B: And finally we want to be able to perform reverse lookups on the position as well. So we're going to add the keys of value module for a position. This looks up like this anyway.
00:04:35.664 - 00:05:02.460, Speaker B: So now if we go back to our terminal we can CD into packages contracts and I'm going to run pnpm run tablegen. So tablegen also runs when you do like pnpm run dev in the root but that also does a bunch of other stuff. And right now we just want to generate the tables facility.
00:05:02.460 - 00:05:19.628, Speaker B: So now starting movement system. So open movement system in your editor and we're going to implement this move function. So the move function takes in a destination X and Y and basically moves our player to that destination.
00:05:19.628 - 00:05:53.142, Speaker B: We're going to be using the position table so we'll import that first. And we also need the keys of value module as well. So we'll start by getting the player's current position from the position table and then we'll use the keys of value module to check if there is a player at that position.
00:05:53.142 - 00:06:24.968, Speaker B: That is quite strange. We want to get the position from the position table and the value would be positioned in code X and Y and we will rename this to player positioned. So what this is doing is it's returning a list of all keys that have a value of X and Y in the position table.
00:06:24.968 - 00:06:49.978, Speaker B: If that list has keys in it, that means there's something at position X and Y. So basically we check to make sure no one's at that position and we just check the length of that table. So it will be require position length to be zero and if not then we'll tell them that the position is occupied and if everything goes well then we can set the position.
00:06:49.978 - 00:07:06.910, Speaker B: So that would be position set player X and Y. Look at the chat. Next thing we want to do is spawn player.
00:07:06.910 - 00:07:16.040, Speaker B: Pretty straightforward player key. Again we have to check if the player has already been spawned. So this is require not player dev.
00:07:16.040 - 00:07:34.290, Speaker B: So we'll get the value to player key. This bytes 32 value over here from the player table. If it doesn't exist in the player table that means the player hasn't spawned yet.
00:07:34.290 - 00:07:55.480, Speaker B: We also need to import the player table here and finally we'll just set all the components and that's how we create our player when they spawn in. So we'll set health to 100, damage to ten just because last smart contract to write is attacking. So we have an attack system here as well.
00:07:55.480 - 00:08:13.566, Speaker B: A player can attack at a certain x and y location because our bombs, we want our bombs to do damage in the radius. We're also going to get all the surrounding tiles within a radius of one from the center of whatever x and Y you input here. So that's nine tiles we're checking in total.
00:08:13.566 - 00:08:31.720, Speaker B: So you can just uncomment all this. And we have to make sure we import our tables as well. And basically all you have to do is uncomment everything.
00:08:31.720 - 00:08:49.854, Speaker B: So for each tile we'll check if there's a player at that position and we'll use the keys of value module over here. Again, check if there's an entity at the position we're interested in attacking. If there is, we'll perform the attack by subtracting the attacker's damage value from the defender's health value.
00:08:49.854 - 00:09:03.360, Speaker B: When health reaches zero, we just delete everything and that's how we despawn or kill the player. Okay, contracts are done. So back to unity.
00:09:03.360 - 00:09:19.780, Speaker B: So how do we connect unity to the chain? First thing you have to do is in your hierarchy. We're going to create a new empty game object in our scene by right clicking and hitting create empty. And we're going to name this network manager.
00:09:19.780 - 00:09:35.076, Speaker B: And in the inspector on the right, we're going to attach the network manager component to it. And this is a component that comes with the unimud package. And make sure you set the chain ID to 31337, which is the local chain.
00:09:35.076 - 00:09:56.000, Speaker B: And you don't have to worry about contract address or private key because these will be auto populated for us later. Okay, so now let's test if this works just to make sure we can connect to the chain. So we're going to open our project in our terminal again, back to the roots.
00:09:56.000 - 00:10:11.136, Speaker B: And in one tab you have to open two tabs. Open your project in two tabs. In tab one you run PMPM, PMPM run dev column node which runs the local chain.
00:10:11.136 - 00:10:35.736, Speaker B: In your other tab you run PMPM run Dev. And this might take a while because it's generating a bunch of files and it's going to deploy it to the local chain as well. Assuming everything goes well, then we hit play, we can see a bunch of logs in the console, then we'll be good to go.
00:10:35.736 - 00:10:57.280, Speaker B: So we're going to wait until our contracts get deployed. And now if I hit play, I should see a bunch of logs in my console? Yes, we have a bunch of logs in the console. WebSocket client created syncing and these are all component updates.
00:10:57.280 - 00:11:12.432, Speaker B: Now we know this works. So the next thing I have to do is actually spawn a player into the game. To do that, first thing you have to do is associate unity game objects with entity keys from mud.
00:11:12.432 - 00:11:33.980, Speaker B: So open your tank prefab just by clicking it in the resources folder. Double click on Tank and what you want to do is attach a player sync component to it. And what Player sync does is basically keep track of which key the game object has and whether or not it's a local player.
00:11:33.980 - 00:11:56.990, Speaker B: It's pretty simple. So we'll make sure change those save there and then we're going to create another empty game object in the hierarchy. We're going to call this the Player Manager and we're going to go into our Scripts folder and drag the Player Manager script into the spectrum on the right.
00:11:56.990 - 00:12:33.470, Speaker B: Make sure it's attached to the Player Manager object and let's open that file. So the first thing you'll see is that on Start we get the instance of the network manager and when the network has been initialized we call this spawn function. So in our spawn function what we have to do is first we're going to get our Burn wallet address from the Network manager and the next thing we'll do is we'll get the value of the current player from the player team.
00:12:33.470 - 00:13:21.144, Speaker B: So you might be wondering where does this player table actually come from? So when we run Pnpm run dev in our project in the terminal, you're actually auto generating a bunch of these table definition files that give us really nice things like strong types and subscriptions and querying interfacing with all the low level uni networking stuff. And then we can just do a one line call like this. So we're going to say if the current player doesn't exist, in other words, if we don't have an entry in the player table for our address, we're going to spawn the player by calling a we're going to make a transaction to spawn player.
00:13:21.144 - 00:13:55.800, Speaker B: So if current player doesn't exist, I'm going to call a function on the Network Manager called WorldsEnd and World send exposes something called TX Execute which takes in a generic type that was set as spawn function. Spawn function comes from the auto generated C sharp bindings for our world contract. So this is like basically a C sharp version of whatever Abi was generated from your world systems.
00:13:55.800 - 00:14:35.310, Speaker B: And finally the last thing we want to do is subscribe to further updates player table play. So what this is doing is saying every time someone inserts a new record into the player table we're going to call this on update players function which we have commented out here. Also good practice is you want to properly dispose of your subscriptions.
00:14:35.310 - 00:14:51.848, Speaker B: So on update players takes a player table update parameter. This parameter is also auto generated. It gives you keys, table ID values and type tuples from whatever update happened.
00:14:51.848 - 00:15:11.114, Speaker B: So in this case we're going to get the current value of the update. So update the update type returns has a type value parameter which say tuple. First item for tuple is the current value, second item for tuple is the previous site.
00:15:11.114 - 00:15:28.050, Speaker B: We only care about the current value here. So let's say if current value doesn't exist we're just going to bail out error because there's really not much for us to do there yet. And then we're going to get the player's position from the position table.
00:15:28.050 - 00:15:51.950, Speaker B: So remember that in the contracts we set the player's entry in the position table to whatever X and Y they spawn at. So we get that from the position table. Now we have to spawn spawn from that position.
00:15:51.950 - 00:16:46.640, Speaker B: Now that we know where we want to spawn we can actually spawn via player prefab. So I'm going to say player we're going to set it equal to the result of an instantiate call which is and we're going to instantiate the player prefab and we're going to instantiate it at the player spawn point and we just want it to have the identity rotation. Next thing you want to do is just add this thing which basically helps with the camera.
00:16:46.640 - 00:18:05.622, Speaker B: And now I should tell Unity which game module does this update key belong to? So we'll say this player that we newly instantiated their player sync component key is going to be equal to this key that we just received from the update and we're going to say if the updates key is the same as our burner wallet address then we will also say set the player sync local player key to this update key. Okay, now we'll go back into our editor and we're going to wire up this script. So all you have to do is go into resources and drag your tank prefab into this lot over here and when we hit play we should see ourselves automatically spawn into the world and there we are and I can move around.
00:18:05.622 - 00:18:47.760, Speaker B: Movement is not still not on chain so let's fix that. So I'm going to open the player controller script. So first we want the playersync component and on start we want to get the current game object's player sync component so player is equal to get component and this time we want to subscribe to both record insert and record update events in the position table.
00:18:47.760 - 00:19:38.708, Speaker B: So our subscription will be this and then we'll say set our disposer to observe on main thread and our call is going to be the on chain position update function. So what do we just do? Basically what we're saying is every time something in the position table gets updated, whether it's just the field which calls this or whether it's the whole row which calls this, every time either one of those two happens we're going to call this on chain position update function. And in here all we're doing is first check to make sure the player being updated is also the player in the current game object.
00:19:38.708 - 00:20:00.996, Speaker B: If we don't do this then basically all game objects are going to change position every time. Every time it's like get a new update which we don't want, we only care about the update for this specific game object and then we'll say if this is the local player we'll return early because we want to handle that locally. If I undo this then the player's position is going to update twice.
00:20:00.996 - 00:20:24.530, Speaker B: Once locally when we move and again when the position in the smart contract updates. And then we're going to get the value of this update, which is like the new position they moved to, and then we're going to set the destination to that new position that they move to. And in our update loop, we actually need to return early if it's not the local player as well.
00:20:24.530 - 00:20:48.860, Speaker B: Now let's write a small function to actually send the move transaction. It's going to be the same thing as like the spawn function before, but we're going to use the move function type from our abi bindings. So it's going to be await network manager instance.
00:20:48.860 - 00:21:08.092, Speaker B: We want WorldsEnd txq and this time and so spawn function is going to be move function and this takes an X and a Y. We see. We're actually wrapping this in a unitask return type just because I think it's a little bit nicer than doing inside a coroutine.
00:21:08.092 - 00:22:04.570, Speaker B: Sending a transactions is an async function uni doesn't really have a good native way to do async await unless you do coroutines this is just a little bit cleaner. So here we'll say send move transaction async and we want to make sure everything's of our proper type and you can see we have this yellow line that's warning us that it's not awaited and we don't really care so it's safe, forget and then no more error automatically make that problem go away. Anyway, if I hit play again in the unit editor you see that next time I move around you have a transaction event in the log as well so that means you're basically making the move transaction when you move.
00:22:04.570 - 00:22:33.310, Speaker B: So we have two more things to implement that's attacking and health. So we're going to start with attacking which is only a couple of lines in tank shooting in the file called Tankshooting CS. So first thing we're going to do is same thing as in the move function and call the attack function instead.
00:22:33.310 - 00:22:59.720, Speaker B: And attack function takes an X and a Y location, so use that as well. And then when I left Click over here, I want to send our transaction pretty much the same thing as what we did before. Now we're going to update our health when we get attacked.
00:22:59.720 - 00:23:29.712, Speaker B: So first thing we need to do get the player sync component and this time we need two subscriptions. We need two subscriptions. We need a subscription for when the health changes and when the health gets deleted.
00:23:29.712 - 00:23:51.416, Speaker B: In other words, when your player gets killed. So our health updated subscription will look like this we're looking for the on record update observable in our health table which fires every time a row in the table updates. And we're going to use callback with the on health change function for deletion.
00:23:51.416 - 00:24:23.910, Speaker B: It's the same thing. We're going to call this one health deleted and this time we want the on record delete and this callback will be on player death. So for the first one on health change we're going to say if the health changes, first thing we're going to do is drop a shell or a bomb above the player and that way people can see what caused their health go down.
00:24:23.910 - 00:24:53.370, Speaker B: So first thing we're going to do is we only care about the current game object's gene, and we want to initialize our shell position at current game objects transform. And we're going to put it a little bit up so it can actually drop down. And then we'll instantiate our shell prefab.
00:24:53.370 - 00:25:28.640, Speaker B: And we want this to point down. So we're actually going to do quantum look rotation vector three down and we actually have to change how health is played as well. So we're going to say the current value, current health value is the updates value, the first one and we're going to set our game objects health to that value.
00:25:28.640 - 00:25:53.370, Speaker B: Next thing we have to do is handle when your health row gets deleted. In other words when someone erases your health. Again, we only care about our current key.
00:25:53.370 - 00:26:24.096, Speaker B: Now let's just say if the updates value is null then we'll be playing the deft animation. If the first item in the value tuple is null, the current value is null. Usually that means the key has been deleted in the table and in our case the players row in the health table has been deleted.
00:26:24.096 - 00:26:44.062, Speaker B: They're dead. So let's go back to unity again and this time I want to test out with multiple players. So the way you have to do this in uni unfortunately is I have to create a local build.
00:26:44.062 - 00:27:18.270, Speaker B: So I'm going to save this and create a local build and basically it's going to open up the game in the new window and then I to play the game again in my editor at the same time. So here is our first game and here I will also play it in the editor. Hopefully you can see that kind of and when I move on one side it updates on the other side as well.
00:27:18.270 - 00:27:37.444, Speaker B: Same here. And now if I for example want to attack, if I'm this guy and I want to attack this other guy, I'll hold down e and just click on, click on them and we'll have a shell drop and they'll be dead. They won't be dead but if we keep doing it they will be.
00:27:37.444 - 00:27:55.442, Speaker B: So let's spend a couple of minutes doing that because we're running out of time soon. Almost done and they're gone. And now they no longer exist.
00:27:55.442 - 00:28:03.660, Speaker B: And if I'm back here I cannot control my player because my player doesn't exist anymore. I'm dead. So, yeah, that's it.
00:28:03.660 - 00:28:14.926, Speaker B: I will be around the rest of this week as well, so feel free to ask any questions in the discord as well. And yeah, thank you.
00:28:15.108 - 00:28:18.522, Speaker A: Cheers. Thank you. Learn Share, there was a question from Marvin.
00:28:18.522 - 00:28:22.110, Speaker A: Do you have to set the contract address in the network manager?
00:28:23.170 - 00:28:30.580, Speaker B: Oh, you do not. If you're using the template in the GitHub you don't because it automatically sets it for you.
00:28:32.470 - 00:28:41.430, Speaker A: Okay, and are there any known issues, limitations within the Uni Mode library? What kinds of community contributions would be most useful?
00:28:42.250 - 00:29:04.640, Speaker B: So right now, the Unimod library does not integrate with Latice's Mode package, so it's just reading events from the RPC, so it might be a little bit slow. It's not going to have the nice indexing features that Mode has. So that is one future potential feature you can add to the library as well, and that's probably one of the most important things.
00:29:08.660 - 00:29:14.400, Speaker A: There's another question. Can this system be incorporated with the Unity game that is already in development?
00:29:15.640 - 00:29:42.990, Speaker B: I guess it depends on how far along you are. So all you have to do is if you have a game that already exists, if you only have the client, you're going to have to put that client into the template, into the package repository, so you have access to the contracts as well and then you just import the Unimud package from Unity. So yes.
00:29:47.440 - 00:29:52.860, Speaker A: Awesome. Well, there are no other questions in the queue. We are at the top of the hour.
00:29:52.860 - 00:30:09.232, Speaker A: So thank you again, Learntra, for the presentation and workshop and thank you all for participating in the event as well. And this is our last workshop for Autonomous Worlds. And don't forget about the project feedback session tomorrow and good luck with the rest of packing.
00:30:09.232 - 00:30:19.476, Speaker A: Have a great Friday and have a good weekend. Oh, wait, there was one other question. Does that already have support for something like an Ethereum or do we need to add this ourselves?
00:30:19.668 - 00:30:31.960, Speaker B: So the Unimud package is already in GitHub, it's open source and it actually uses an Ethereum on the back end as well. So the answer is yes, it does have support for an Ethereum.
00:30:35.020 - 00:30:38.008, Speaker A: Great. Well, cheers everybody. And yeah, have a good Friday and.
00:30:38.094 - 00:30:39.220, Speaker B: Have a good weekend.
