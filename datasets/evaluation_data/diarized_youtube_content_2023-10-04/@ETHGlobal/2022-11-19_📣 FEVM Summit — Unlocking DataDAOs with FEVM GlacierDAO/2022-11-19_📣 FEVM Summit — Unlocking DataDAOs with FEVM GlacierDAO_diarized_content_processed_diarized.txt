00:00:06.250 - 00:00:22.458, Speaker A: Welcome back to the Fevm summit. Really excited to have everybody here and excited for this next set of talks. So we're going to be learning about basically unlocking data dows with the Fevam and being able to hear a little bit more from the teams behind Glacier Dow and LaGrange Dao.
00:00:22.458 - 00:00:47.686, Speaker A: And yeah, we're really excited to hear a little bit more about this use case. We just had Zach point to this as being a pretty interesting base layer situation that can be improved by the yeah, now, kind of great to hear firsthand from Inies and from Joel about first of all, I think for Glacier Dow. And then we'll also hear a little bit later from Charles from the LaGrange Dao.
00:00:47.686 - 00:00:56.682, Speaker A: So, yeah, when you're ready, feel free to turn on your cameras and unmute and I will stop sharing screen. I'll turn it over to you both. Hey, welcome to the stage.
00:00:56.746 - 00:01:03.310, Speaker B: Hello everyone. My name is inev. And together with Juan, we are here to tell you a little bit about Glacier Dow.
00:01:03.310 - 00:01:25.960, Speaker B: Do you remember this? When GitHub created Cold storage repository using an archival facility that was placed 250 meters deep in the permafrost of an Arctic mountain? What about this? When the same entity, GitHub, decided to ban tornado cache code and suspend its developers from their platform.
00:01:28.830 - 00:01:29.674, Speaker A: We believe that.
00:01:29.712 - 00:01:50.030, Speaker B: Code like data should be preserved in a censorship resistant way. And this is where Glacier Dao comes in. So Glacierdao is a decentralized autonomous organization that preserves code as a public good and Glacierdao's lifecycle evolves into a series of stages.
00:01:50.030 - 00:02:10.450, Speaker B: Each epoch starts with a call for funds at stage zero, followed by a call for votes. Afterwards, storage providers are allowed to make submissions which are then validated by Dow members. Stage four is considered to be more of a buffer in the epoch.
00:02:10.450 - 00:02:23.580, Speaker B: So it's essentially a time where users and storage providers can chill. And at the end of the epoch at stage five is when storage providers can collect their rewards. But let's go through each stage in more detail.
00:02:23.580 - 00:02:46.660, Speaker B: At stage zero, users are invited to commit funds to the current epoch. Currently this is done by committing FalcoIn, but it will be possible to commit funds using any ERC, 20 token in the future. In stage one, users who have committed funds are also attributed then voting power.
00:02:46.660 - 00:03:02.082, Speaker B: And this is done in the form of one vote per cell. They can either vote for a submitted repository or they can submit their own repository for its code to be preserved. So right now, users are only able to vote for one single repo.
00:03:02.082 - 00:03:17.930, Speaker B: But in the future, we want to allow people to vote for multiple repositories. And we also want to evolve into other forms of voting, potentially quadratic voting. All right, enter stage two and enter storage providers.
00:03:17.930 - 00:03:38.610, Speaker B: These make filecoin storage deals free. Filecoin storage deals with themselves and what they do is that they then submit the deal IDs and the PCIDs to the Dao Smart contract. These are then validated, that is, Dao members verify that the deal is legitimate and that the stored data corresponds to the submitted repository.
00:03:38.610 - 00:03:57.142, Speaker B: Since the epochs have a fixed duration, if everything from the previous stages is done, then the epoch will just continue to run. And it's time, like I said before, for everyone to just chill, both users and storage providers. Finally at stage five.
00:03:57.142 - 00:04:13.470, Speaker B: So at the end of the epoch, storage providers can claim their rewards. And what happens is that the Smart contract then verifies that the storage deal is healthy and that there was no breach of the deal. So if there was no breach of the deal, then the storage providers are able to collect their rewards.
00:04:13.470 - 00:04:21.840, Speaker B: All right, let's go for a demo now. I'll pass on to Juan for this.
00:04:22.630 - 00:04:23.540, Speaker A: Thank you.
00:04:24.470 - 00:04:36.320, Speaker C: So let me just share my screen. Everything good. Can you see my screen? The website? Yeah.
00:04:37.970 - 00:04:38.490, Speaker B: Nice.
00:04:38.580 - 00:04:49.970, Speaker C: So now we're now on the question website. I encourage you to view it. We have a video that really shows our smart contract interaction in more depth.
00:04:49.970 - 00:05:13.222, Speaker C: There's also some other information and we've set up like a little demo here. So essentially our application is not live yet because as we're going to discuss later, there are still some technical limitations as to what we can do with Solidity and Fevm. But we were like we've been working on this for less than a month so things are still fresh.
00:05:13.222 - 00:05:30.880, Speaker C: So we thought that for this presentation to be nice, to show you what the app will look like when everything is connected. And then we are also going to show you our roadmap to how we're going to replace the pieces to make it more and more decentralized over time. So let's assume we are now here on our app.
00:05:30.880 - 00:05:48.854, Speaker C: We created two users so we can switch between user one, user two or storage provider. Let's assume that user one wants to join the Dow and is going to commit like 250 fill for this epoch of storage. So he commits 150 fill.
00:05:48.854 - 00:06:20.714, Speaker C: Then we have user number two and maybe just commits 100 because he has a little less. So so far this epoch on the Dow has 350 fill committed. So if you're a storage provider, you know that okay, the cake is 350 fill big for this epoch, which will help you make a decision of do I want to participate in this? Is there enough incentive for me or not? Then as we go on to the next stage, users can vote on which repos they want to keep preserved.
00:06:20.714 - 00:06:31.410, Speaker C: So you can either submit a repo or you can just vote for one that exists. So let's say for instance, that user one wants to vote for the IPFS repo. He comes here and he clicks vote.
00:06:31.410 - 00:06:54.070, Speaker C: Now all of his votes were cast for this repo. Right now we are only allowing you to vote once and all your votes are cast just for simplicity in creating the contract later. We definitely want to evolve in the direction of for sure, being able to vote for multiple by splitting your votes, possibly even using quadratic voting.
00:06:54.070 - 00:07:09.622, Speaker C: It might make sense. In this case, it's really cool, we just didn't do it for simplicity's sake. So now let's say user number two, instead of voting for an existing repo, they prefer to vote for the JS IPFS repo.
00:07:09.622 - 00:07:35.750, Speaker C: So he can now come and cast his 100 votes. The storage provider can only see that these are the proposals that are ongoing. The vote button is just a bug here, I need to remove it because the storage provider is obviously not able to vote, but they can see like, okay, there are 250 fill in price for IPFS and there's 100 in price for Jsipfs.
00:07:35.750 - 00:08:00.718, Speaker C: So now on the next stage, the storage provider is probably going to be like, okay, this one has a bigger price, so I'm going to go for this deal. So they go on FalcoIn off Band, they create a deal with themselves for zero. The reason why they create the deal for zero is because the rewards for storing this data are expected to come from the Dao, right? Not from Falcoin's native rewards mechanism.
00:08:00.718 - 00:08:30.310, Speaker C: So in this case, what you're doing is like thinking, well, it's okay for me to do a deal for zero through FalcoIn because I'm going to get more rewards from the Dao on some native token from the Dao or even from Field directly from the Dao. So they can for instance, come here and apply for the IBFS one and then they put the deal ID and the PC ID. So these are two Identifiers that you get from Falcon deals.
00:08:30.310 - 00:08:47.294, Speaker C: If you go to Field Fox, which is like the Blockchain Explorer for FalcoIn, you can see this data there. But for now we can just put some chipperish just to make sure that it stays here. So they submit their application and at this point, users don't do anything.
00:08:47.294 - 00:08:58.770, Speaker C: It's just a source providers. Once they have done their applications, time goes on, we move to the next stage. And what they see here is that their application is now waiting approval.
00:08:58.770 - 00:09:33.934, Speaker C: This is because this is the time where the Dao members get to vote and why are they voting. So one of the limitations that we currently have is that it's very hard, I'm not going to say impossible because I'm sure someone might be able to do it. It would actually be a pretty cool hackathon project if you could, but it's really hard to verify that a filecoin deal contains exactly the zip file from the GitHub repo to start with.
00:09:33.934 - 00:09:58.390, Speaker C: You would need an oracle to know what the GitHub URL actually means, but I guess eventually the submissions for repos could include the repo hash as well. But still on chain you would need to hash the entire repo, which is an insane memory requirement obviously. And you would need to hash essentially the data available on IPFS and then compare it to the hash of the GitHub repo.
00:09:58.390 - 00:10:29.086, Speaker C: That's tricky. So what we are doing is we are calling on the Dao members to go on FalcoIn verify, go on FalcoIn, get the data from FalcoIn. So from the deal ID and the PCID get that from Falcon, hash that data, compare that against the hash of the GitHub repo and if they are satisfied that the storage provider is indeed maintaining the data that they say they are, then they vote yes.
00:10:29.086 - 00:10:45.110, Speaker C: Meaning, yeah, I checked, it looks legit. Once the vote reaches 50%, like if 50% of the Dow members vote that the deal is legitimate, it's considered to be approved. Meaning that the Dow has voted and they have approved this.
00:10:45.110 - 00:10:58.374, Speaker C: So in this case, user one has more than 50% of the votes. So it becomes automatically approved, this deal. So when we go to the next stage, the storage providers can see that their deal was approved.
00:10:58.374 - 00:11:08.094, Speaker C: So the Dow is voted, it has approved this deal. The potential reward here is 250 fuel for this deal. This value is incorrect here.
00:11:08.094 - 00:11:18.590, Speaker C: We have to fix it. You can see that the potential award is 150 fuel. So at the last stage they can collect their reward.
00:11:18.590 - 00:11:35.410, Speaker C: The way the reward collection works is there is a method on an actor, on FalcoIn. Actors on Falcon are like smart contracts. We're going to go over this after on the architecture but essentially the smart contract can verify that a FalcoIn deal is healthy.
00:11:35.410 - 00:12:03.310, Speaker C: What this means is that for the whole period of the deal duration the storage provider was able to provide the necessary proof of spacetime. However, if they have not done that the deal is not healthy, then they are not able to collect the rewards because obviously they did not keep their promise to the Dow so they would not be able to collect anything. But in this case, assuming that they did, they'd be able to collect here 99 is again the wrong number.
00:12:03.310 - 00:12:24.600, Speaker C: They'd be able to collect 250 fill and get that money sent to their wallet. So now let's look at the architecture of this and where we are going from here. So the way we want this to work is we have our little front end, which is what we just saw in this demo.
00:12:24.600 - 00:12:47.134, Speaker C: This front end is connected to a smart contract which is written in solidity the data. Maybe it gets data through some indexing server or maybe we deploy a graph on the FalcoIn network to get this data from a rest API or from a GraphQL API instead of going directly to RPC calls. But that doesn't matter.
00:12:47.134 - 00:13:07.250, Speaker C: So there's a solidity smart contract that handles the voting. The Dao funding, the storage provider rewards the deal making and the deal verification. The key pieces here is that the deal making and the deal verification need to talk with FBM actors which like I said, are like smart contracts on FalcoIn.
00:13:07.250 - 00:13:24.278, Speaker C: But unfortunately this part is still under construction so it's not ready yet. There is no Solidity library for Solidity smart contracts to interact with FalcoIn primitives. There is a mock library available.
00:13:24.278 - 00:13:35.002, Speaker C: You should search the Docs or search discourse for that or maybe I can send you the link later so you can see what the interfaces will look like. But it's not actually working yet. So there is that limitation there.
00:13:35.002 - 00:13:59.342, Speaker C: So we are keen to get this off the ground and get it working soon. So what we were thinking of doing right now oh, sorry. So just to summarize, the current roadblock that we have is that there are no Solidity libraries and also if you want to call actors on the FVM from Solidity, you have to encode the parameters in CBOR and that is a tricky encoding to do in Solidity.
00:13:59.342 - 00:14:09.970, Speaker C: I heard that there's already a library for that but I couldn't find it yet. But that's also a tricky part. So right now it's just hard to make those calls.
00:14:09.970 - 00:14:47.266, Speaker C: So what we thought we would do is to make the deal making and deal verification work for now is we would use Web Three storage which is also a product of protocol apps and essentially it is an abstraction on top of Falcon and IPFS where you can go you can store files very easily. I think they have a Rest API as well, so you can do it programmatically from some server. So our goal is to have the Dao, like some Dao members, Dow administrators, something like that, replace the storage providers for this intermediate period before the Solidity libraries are ready.
00:14:47.266 - 00:15:21.310, Speaker C: And what would happen is the Dow goes on as normal, but the proofs are submitted by Dow members who have stored this deal on Web Three storage. So they would just put some pointer to that data on the verification stage and the Dow would still vote if the deal is valid or not. And that's very easy to do because on Web Three storage you get not only the PCID and the storage ID, but also an Ipfscid, which makes it much easier to retrieve the file because it's pinned by their servers.
00:15:21.310 - 00:15:33.134, Speaker C: So that's what we're thinking of doing right now. So right now we have our demo app. We also have some smart contracts which work except for the part of talking to the FVM.
00:15:33.134 - 00:16:10.586, Speaker C: So even though they work, they're not very useful at the moment. So what we're going to do is replace some of those components with Web Three storage and then once the Solidity libraries are available, we are going to swap Web Three storage for native Falcon primitives in Solidity. So yeah, this is extremely exciting though I'm not sure if anyone here has experienced developing solidity, but it's really cool that you can just take all of your solidity knowledge and write a smart contract and deploy it on FalcoIn.
00:16:10.586 - 00:16:25.860, Speaker C: And even though the storage primitives are not there yet, you can still start playing around with it. You can go on the wallaby network, get some testnets FalcoIn, and just deploy it and see things running on FalcoIn. I was blown away when I tried it because it was super easy.
00:16:25.860 - 00:16:40.360, Speaker C: I wrote a little blog post on how to do, like, a Hello World on. So, like, if you want a link for that, you can just send me a message on discord. But, yeah, there's a lot of cool stuff to do.
00:16:40.360 - 00:16:51.626, Speaker C: So, yeah, thank you for your time. You can see mine and in his Twitter handlers here at the bottom, maybe hurry up. We don't know for how long Twitter will be running.
00:16:51.626 - 00:16:59.726, Speaker C: I'm just kidding. There's also a link to the website and yeah, let us know if you have any questions. I think we have some time for.
00:16:59.748 - 00:17:02.320, Speaker A: Q A, so that's it.
00:17:04.130 - 00:17:04.590, Speaker C: Awesome.
00:17:04.660 - 00:17:13.986, Speaker A: Thank you so much for that. And yeah, if anybody has any questions, feel free to drop them in the global TV chat. In the meantime, I had a couple that kind of came to mind as you were going through this.
00:17:13.986 - 00:17:46.890, Speaker A: One is you mentioned that the storage provider at one point would have to sort of open a storage contract for zero fill and then sort of count on the dow to pay them out that stream down the road. I think it makes sense to some degree why that's the case. Is the reason why we can't do that under the filecoin default kind of reward thing just because that missing library or is there kind of something else to it that the data dow kind of enables that is more interesting than doing it just with the base layer reward scheme.
00:17:48.830 - 00:18:14.840, Speaker C: There are probably more reasons to it. A reason that I think is compelling is that it makes it very easy for a group of people to come together and fund one specific thing. While I'm sure you can somehow do it on Falcon now, but it would be harder, as in, like, some doubts exist and they solve problems that could be solved before, but they make the cost of what's the word, cooperation much lower.
00:18:14.840 - 00:18:28.634, Speaker C: So that's kind of the idea here. You can come together with a bunch of friends if you feel very strongly about a certain piece of open source software. We like, everyone chip in $5 and maybe we can store this for a long time.
00:18:28.634 - 00:18:32.166, Speaker C: And I think that's pretty cool. Gotcha.
00:18:32.198 - 00:18:56.750, Speaker A: Yeah, I do too. I was thinking about even extending that. I wonder if you've thought of ways where you could actually do sort of like what GitHub had done and sort of actually incentivize storage of large amounts of different repositories, even if they don't have backers specifically the IPFS one, for instance, feels like a really natural one to want to back up, especially using Filecoin.
00:18:56.750 - 00:19:17.580, Speaker A: But my random repo that I care about, but maybe I don't have the funding to back up. It would be cool to see if there was a way where we could kind of have a kind of community pool that could go out and identify other repos that maybe don't have direct funding but could use a pool of funding to do so. I don't know if you've got any thoughts into that area as well.
00:19:20.670 - 00:19:48.850, Speaker C: Inez and I were discussing a few days ago, so if you participate in the Dao often, you could maybe get some loyalty points for being an active member of the community. So maybe, let's say if you have participated for five epochs, which might be, I don't know, three months, six months, whatever, maybe you get some tokens which for the next epoch gives you a vote with a higher weight.
00:19:49.510 - 00:19:50.066, Speaker B: Right.
00:19:50.168 - 00:20:11.638, Speaker C: So even though you're not committing funds on that one, you're a valued member of our community, so you can signal that this one really should be stored. Guys, I mean, I'm seeing danger here, so maybe that would be a way to do that. There are so many dows with so many amazing mechanisms nowadays.
00:20:11.638 - 00:20:21.520, Speaker C: I don't know most of them, obviously, but I'm sure there are some very bright people that thought about really cool ways to coordinate and do those things.
00:20:22.450 - 00:20:23.246, Speaker A: Cool.
00:20:23.428 - 00:20:23.726, Speaker C: Yeah.
00:20:23.748 - 00:20:40.580, Speaker A: Awesome. Yeah, I mean, that feels like almost like building in more of like a yeah, in that case, kind of feels a little bit more quadratic funding you where it's like one vote means a little bit more because of the actions that person had taken or like some civil resistant thing. Yeah, very cool.
00:20:40.580 - 00:20:42.194, Speaker A: Yeah.
00:20:42.232 - 00:20:53.686, Speaker B: This type of thoughts is really important for us as well. So maybe just a shout out to the people who are also listening if you have any ideas, things that you would like to discuss. I mean, we're on Discord, so feel free to reach out.
00:20:53.686 - 00:20:56.710, Speaker B: We're more than happy to talk more about glacier dow.
00:20:57.210 - 00:21:05.740, Speaker A: Amazing. And then I think I saw right at the beginning of the presentation you mentioned you've been working on this for a couple of weeks, but I think I also saw that this might have been a hackathon project at some point.
00:21:06.270 - 00:21:09.150, Speaker C: Yeah, two weeks ago. There you go.
00:21:09.300 - 00:21:15.562, Speaker A: Amazing. So there you go. So for everybody watching here's where you could be in two weeks, which is on the youth global stage.
00:21:15.626 - 00:21:22.482, Speaker C: There you go. Yeah, I think I would like to incentivize. So there's this open problem right now.
00:21:22.482 - 00:21:31.300, Speaker C: I see that rule is in the chat. He can also attest to this. There's this like before the solidity libraries are ready, you can do this thing.
00:21:31.300 - 00:21:38.098, Speaker C: You can write assembly code in a U file. Not in line assembly. It's had to be a U file.
00:21:38.098 - 00:22:05.950, Speaker C: And call the verbatim, which means you can just run arbitrary bytecode that you write by hand, like a maniac. Sounds safe. Yeah, but what I'm saying is, currently there is an actor on Falcon on some testnet that allows you to interact with the storage layer, but it's super hard to access it because you have to build, like, the bytecode by hand.
00:22:05.950 - 00:22:15.346, Speaker C: So you have to push all the arguments to the stack. Then you have to manually encode the data in Cbore from Rust. If you can make that work, that would be amazing.
00:22:15.346 - 00:22:27.940, Speaker C: We haven't been able to make it work yet, but if you go to our GitHub repo, you can see all my failed attempts with commented codes of, like, manual bytecode. But if someone wants to pick that up, that would be amazing.
00:22:29.990 - 00:22:47.100, Speaker A: Well, it's possible at the end of the day, did make roller coaster tycoon in assembly, so I'm sure we can do storage deals in assembly, too. But yeah, I think you need to be a special kind of developer to really want to put yourself through that. So if there's any of you out there, feel free to give these guys a hand.
00:22:47.100 - 00:22:53.160, Speaker A: All right, well, thank you very much. I think we're going to just move on to Charles's Chalk next.
