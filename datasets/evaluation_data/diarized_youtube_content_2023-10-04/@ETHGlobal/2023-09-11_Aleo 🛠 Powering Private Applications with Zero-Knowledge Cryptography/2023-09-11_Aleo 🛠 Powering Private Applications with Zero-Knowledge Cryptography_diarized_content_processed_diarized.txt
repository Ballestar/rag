00:00:08.090 - 00:00:42.810, Speaker A: All right, so, hey, everyone, let me just actually start some timers here. All right, cool. So hey, everyone. My name is Pranav. It's good to meet you all. And today I'm going to introduce the Leo programming language and show you how we can use it to develop private applications on the alias stack. So, over the past decade, we've really seen how Web Three has pushed the envelope of decentralization, really providing users with more control over their data.
00:00:42.810 - 00:01:31.850, Speaker A: In the Web Two model, your data was owned and managed by a centralized party. And in the Web Three model, your data is no longer managed by a centralized party, but it is effectively owned by the network. And what I mean by this is that many platforms fail to provide data privacy. And from a user experience, from a UX standpoint, this is insufficient. Now, one way we can remedy this problem is by leveraging cryptographic constructions like Xeronoledge proofs and building friendly abstractions on top of them. So today in today's talk, we're going to walk through how developers can build private applications using the Leo language on top of the alias Stack. We'll start first by building some intuition for cryptographic primitives and the state model that Alia builds upon.
00:01:31.850 - 00:02:09.174, Speaker A: And then we'll go into a deep dive of the Leo language and learn how we can build private programs. And then finally, we'll build our own private auction and survey some of the tools we have to test and deploy applications. So quickly, before we get started in the chat, we'll link some developer resources. They have some instructions on how to get your dev environment set up. And this may take some time, so feel free to run it while we go over some high level concepts. And I think there will also be people in the chat helping answer questions as things go on. And yeah, let's get into it.
00:02:09.174 - 00:02:57.494, Speaker A: So for decades, cryptography has really served as a powerful tool for building secure systems. And much of the cryptography we use today provides security guarantees about data. For example, Alice can encrypt a message and send that message to Bob and be sure that the contents of her message hasn't been leaked. And this is what we call confidentiality. She can also sign a message which Bob can later verify, and this gives authenticity for the message. And these techniques are really incredibly powerful and we see them used in a number of systems, but they don't provide guarantees about computation, the integrity of computation, they don't provide guarantees about the privacy of computation. And this is really where zero knowledge proofs come in.
00:02:57.494 - 00:03:45.300, Speaker A: Now, formally, zero knowledge proofs are privacy preserving cryptographic proofs of computational integrity. And that's a mouthful. But simply stated, with zero knowledge proofs, I can prove to you that I know some secret that without actually telling you that secret. And let's make this a little bit more clear. So suppose we have a publicly known function or predicate S and a publicly known output Y. A zero knowledge proof is a proof pi that allows me to claim me the prover to claim that I know some private input X such that F of X is equal to Y without actually needing to reveal X to you. And this is the core idea we'll build upon today.
00:03:45.300 - 00:04:32.450, Speaker A: In reality, zero knowledge proofs are way more complex and we're really glossing over some fancy math and some really deep technical details. But if you're interested in learning more, we'll have some resources for that as well. Now, there's a special type of zero knowledge proof called a ZK snark. And a ZK snark is a zero knowledge succinct, non interactive argument of knowledge. And let's break that down a bit. So a ZK snark is a proof that is zero knowledge, which means that the proof does not reveal anything about the private inputs that were used to construct that proof. Zero knowledge proof is succinct, which means that the proof is small in size and verifying the proof is fast.
00:04:32.450 - 00:05:15.700, Speaker A: This is super powerful because it ensures that the cost of verification is independent of the cost of computing that proof. And in other words, your proof could be over a very complex calculation but can always be verified in a short amount of time. And this really helps with scalability. As we'll see later, Azure knowledge proof is non interactive. So what this means is that the prover, the party generating the proof and the verifier the party verifying the proof do not need to talk back and forth for the verifier to be convinced that the proof is true. The verifier can independently verify without the need for communication. And a zero knowledge proof is sound.
00:05:15.700 - 00:06:00.122, Speaker A: This is a technical requirement. But at a high level, what soundest means is that any statement that can be proven true by the proof system is actually, in fact, true. So now that we have some really high level understanding of zero knowledge proofs, let's switch gears a bit and discuss decentralized ledgers. So blockchains, or more generally, decentralized ledgers have spawned a wide variety of applications that really weren't possible before. But these constructions have some significant limitations. Now, to understand where these limitations come from, let's kind of walk through how decentralized ledgers work. So the left here, we have a ledger.
00:06:00.122 - 00:06:49.070, Speaker A: On each row, you have an account or an application associated code and data. And this is over a network, a distributed network. So fundamentally, decentralized ledgers enforce, correctness and guarantee security by reexecuting computations on the network. And how does this work? So when a user submits a transaction containing an Identifier for the application, some input data and a signature authenticating that transaction. Each node on the network reexecutes the computation inside the transaction. If the computation is correct, the nodes agree and the signature is valid, the state is updated. Now, the problem with this model is that it hurts scalability.
00:06:49.070 - 00:07:29.690, Speaker A: Since every party needs to reexecute the transaction the network is essentially performing a massive amount of redundant work. So let's put this into perspective. Suppose you have 3000 nodes on an Ethereum, an ETH one style network and each block requires 5 seconds of compute. This amounts to 15,000 seconds or about 4 hours of compute redundant compute performed by the network. And this is extremely wasteful. Another fundamental problem is that ledger reexecution hurts privacy. So the core strength of decentralized ledgers really is also its weakness.
00:07:29.690 - 00:08:21.766, Speaker A: To provide correctness and security every node needs to reexecute. And for them to do that they need to be able to see user data, program data, inputs and outputs. And while this leakage might be okay in certain applications tolerable and maybe even desired in some applications there are a number of use cases that break under this model. Now, one natural example for us is banking and payments. So in traditional banking when you providing someone with your bank account number doesn't reveal information about your balance, who you transact with, what you buy when you spend and so on. But in Ethereum, when you give someone your Ethereum address they can see all this information and what's more is that they can track you till the end of time. So clearly we need to improve on some of these existing constructions.
00:08:21.766 - 00:09:04.970, Speaker A: But first we also need to see what's the fundamental cause of this problem. And when we take a step back and really look at the system or existing systems we see that these problems are really a byproduct of the account model. So what is the account model? The account model is a model for organizing account and application state on a decentralized ledger. In this model a ledger tracks each account by a global state. So on the left here we have a user and on the right a user with its associated address. And on the right we have a simplified model of global state. In it you see you have an account, its address, its code and storage.
00:09:04.970 - 00:09:43.880, Speaker A: And you can think of storage as persistent data here. So when a user creates a transaction transaction itself contains the address of the account. It's interacting with some data. A fee and a signature authenticating the transaction. When this transaction is included in a block every node on the network reexecutes it and induces a transition on the account state from its original state to a new one. Here in this transition we see that most of the stuff remains the same but the account storage, persistent storage gets updated. Now, this model is actually really nice to work with.
00:09:43.880 - 00:10:39.770, Speaker A: It's really easy for developers to understand and write programs that coordinate with each other, manage state and so on. It's a very simple model and it's one that we see today all over the place. But the issue, like we discussed before is that it's not scalable. If you suddenly get a spike in traffic and a bunch of people are submitting transactions, you end up with bottlenecks which result in fee spikes and so on. And like we also discussed, for this network to be able to execute these transactions, they need to know full state and that compromises privacy. So let's kind of walk through an exercise where we take this account model and see if we can improve on it, add some more privacy and see if we can get something desirable. And really what we're trying to work towards is private smart contracts.
00:10:39.770 - 00:11:45.654, Speaker A: So what we're going to do is maybe make some modifications to the original design. Here we have the original specification of the transaction and let's try to get some more privacy here. So first what we'll do is we'll encrypt the data under the sender's key and instead of providing a signature, we'll provide proofs that the transaction updates or produces correct, let's say updates the account state correctly and this will be a zero knowledge proof. And the remaining stuff remains the same mainly because you need to know which account that you're going to access or which account you're going to call, application you're going to call and your fee still remains the same. And then on the network side you have an account. Originally you have an account, it's code and storage. So what we'll do is we'll encrypt the storage separating each encrypted portion by indexed by user effectively.
00:11:45.654 - 00:12:33.680, Speaker A: So each portion of the account storage that is related to a user is encrypted under that user. And instead of storing code, we're going to store a predicate. And a predicate is essentially a mathematical representation of the original code. And we need to use this mathematical representation because we are reasoning about the correctness of the transaction or the correctness of the execution within a cryptographic proof. So when we take the original code, turn it into a predicate, it's actually a polynomial. And by doing so we can reason about it in a proof system and start constructing some snarks out of it. So let's put this all together.
00:12:33.680 - 00:13:26.910, Speaker A: So in this new model you have global state. Each account has its address and for each address, each address is indexed by user. And for each one of those is an entry. You see here some code and some encrypted storage of the old state, of the current state. Now when the user submits transaction, it submits the address it's interacting with, it submits some encrypted data, a fee and proofs. And these transactions effectively prove that each state transition is made on encrypted and committed state. And if the network verifies these proofs, finds them to be correct, then the account state is transitioned into the new one.
00:13:26.910 - 00:14:20.990, Speaker A: Note that storage is always encrypted. So we still have privacy here. Now the key component of this construction is, or really the key question is what is actually being verified in these proofs. So you have a transaction here and in the proofs we're going to take as input the code predicate and the old state. So it's the old encrypted state and produce new encrypted state. And what the proof will do is check that the program predicate the mathematical representation of the code that represented the state transition is actually satisfied, is actually executed correctly. And with this, if this proof is verified, a Verifier can be sure that account state was updated correctly.
00:14:20.990 - 00:15:22.446, Speaker A: But also a Verifier doesn't learn anything about what the account state was because it still stays encrypted through and through. So this seems like a pretty cool model. It actually doesn't work. So why doesn't it actually work here? First of all, the first problem is that you don't have concurrent access to program state. In this model that we have, before you have that, a user needs to take the entire program state, prove something about it in a transaction and then update that to the network. So if user one comes along, submits a transaction and while the network is verifying and updating it, user two comes along and tries to submit a transaction or reads the network state and tries to submit a transaction. If user one's transaction goes through, users two will fail because it has read old state effectively.
00:15:22.446 - 00:16:33.158, Speaker A: In this model, in order for you to get any sort of multitenancy, user one needs to read state, construct the transaction uploaded, the network has to get verified and then only after that user two can come along, read it, produce a transaction and upload that to the network. Furthermore, state updates in this model because you have to kind of pull the entire account state. It's extremely inefficient. And then another problem here is that we don't have privacy because you're still sending the address of the accounts that you're indexing in the clear, everyone can still see your access pattern. So even though I don't know what your data is, even though I don't know what your data is, I know when you interact with this program and I can infer things about your behavior. So this model doesn't work, but let's just sort of review some of the properties it gives us. So first of all, we did solve ledger reexecutions because we're computing state transitions.
00:16:33.158 - 00:17:43.298, Speaker A: In a zero knowledge proof off chain, the network only needs to verify the correctness of the zero knowledge proof, which is very quick. We have data privacy, we're encrypting our data, we're encrypting data on the chain itself. We don't have account privacy because in this account model the ledger requires the address that you are accessing or updating to effectively update global state over each transaction. So addresses cannot be encrypted under this model. And because of that you leak some information. And like we discussed earlier, we don't have efficient state updates because you need to take the entire account state reason about it and produce a proof and you don't have concurrency because like we discussed before, users would be reading old data, stale data effectively. So how can we do better? And really this is where we're going to kind of drop the core intuition here.
00:17:43.298 - 00:18:34.820, Speaker A: So the problem is that in this model, in this our augmented account model, every transaction requires the entire account state to must read the entire account state, create a proof and produces a new one. So that's inefficient there's no concurrency there. And then the other problem is that addresses are public. So the idea that we've come up with is that can we shard application states such that each user owns their own piece. And really if you build upon this idea, you arrive at the record model. So this is the model upon which Ilio actually is constructed on. So in the record model a decentralized ledger tracks each record by a global state.
00:18:34.820 - 00:19:45.000, Speaker A: Here you have a user, here you have some global state for the ledger. In here what we store is the program, its code and a set of records. And note that records are encrypted on chain so there's no data that's being leaked there. When a user submits a transaction, a transaction actually consists of a number of state transitions, each transition containing an ID of the program. It called the old records that were consumed, the new records that were produced, a fee and then a zero knowledge proof stating that given the input records, given the output and given the output records and the program predicate, everything was executed correctly. So if a transaction submitted it's contained in a block and the network verifies this, the network only needs to effectively throw out the old records and put in the new ones. And in doing so, it's actually a quite simple update model and it's the one that we use today.
00:19:45.000 - 00:20:40.954, Speaker A: So what does this give us? So here we have concurrency because application state is sharded for each user's context. A user only needs to operate on their own context the records that are only associated with their component of the application state. For program execution, you also don't have double spends and this is because the ledger can enforce that no record can be consumed twice. And the way you can do this is by revealing consumed record serial numbers after you accept every transaction. This is a high level overview of this construction and there's actually some more technical details. One great resource for this is the Zexi paper and really recommend if anyone's interested to check that out. But let's round this out.
00:20:40.954 - 00:21:29.370, Speaker A: So what do we actually prove in a transaction? You prove that given some code predicate and some old records and some new records as output, the program predicate is satisfied for all records that are taken in and produced. And with this we now achieve account privacy. There's no notion of addresses or global state. And within a record is effectively each user owns their own record and record owners are not leaked. So in this model, you have effectively account privacy. Oops, sorry, that's not it. You have efficient state updates.
00:21:29.370 - 00:22:10.742, Speaker A: Predicates only consume records that are actually being updated in their context. They don't need to reason about the entire state of the application to make an update. So updates are effectively sharded and just localized to the set of records that are being written. And you have concurrency because the application state is split apart. Two users, if they're operating on independent application state, can submit transactions and run them at the same time. And both will be verified by the network, and both will be consistent with with the semantics of the application. Cool.
00:22:10.742 - 00:22:56.258, Speaker A: So, kind of putting this all together a bit. We talked about zero knowledge proofs, we talked about the record model, and together these are instantiated in Alio. And what Alio is, is a new L, one that builds upon existing constructions to offer more privacy and programmability. So in this diagram here, we have Bitcoin being the least private and the least programmable. To its right is Ethereum, which improves upon Bitcoin by adding programmability. And above bitcoin, you have zcash, which improves on bitcoin. With privacy, alio effectively takes the top right quadrant here where we have privacy and programmability.
00:22:56.258 - 00:24:05.130, Speaker A: And we get this with our construction, with our usage of zero knowledge proofs and how it's used with our record model. So with that, now that we have an intuition for the record model, let's take a look at Leo and see how we can use it to develop private applications. So first let's recall our original definition of a snark, a ZK snark, or let's say a zero knowledge proof. It's a proof pi that attests that I know X such that Y is equal to F of X. Now, one question when you're actually using snarks is how do you encode F? How do you specify the program predicate? And this is where the Leo language comes in. Leo is effectively a high level programming language that's compiled into Alio instructions before it's serialized into AVM bytecode. And the compiled bytecode is deployed on chain and visible to all participants in the network.
00:24:05.130 - 00:24:41.814, Speaker A: The AVM, or the Alio Virtual Machine, is a virtual machine that executes AVM bytecode and produces a Zksnarc or proof. And the Alia Virtual Machine is essentially executed offline or off chain. A user, when they are constructing or creating a transaction, they invoke the Alio Virtual Machine. It produces a proof, they package that into a transaction and send it to the network. Now the details of Alio instructions. AVM bytecode alia virtual machines are actually really cool. We have some developer resources for that.
00:24:41.814 - 00:25:22.878, Speaker A: But for the purposes of this workshop, we're only going to focus on Leo code. And with that, let's dive a little bit into the language. So, Leo, like all programming languages, provides some data types for users. It has 16 primitive data types and also allows users to define their own composite data types. Now, some of these might be familiar coming from other programming languages. You have booleans, you have integers, you have structs, you also have strings. But the orange shading here indicates that strings have a limited set of functionality.
00:25:22.878 - 00:26:10.926, Speaker A: We're building upon this, but there's actually some subtle details in making sure strings work safely. In snark constructions, you also have algebraic data types called either fields, scalars, or groups. And these relate to some of the cryptographic primitives that Leo offers underneath or Leo offers to users to use. Fields also relate to the snark construction underneath and they're the fundamental representation of data in a snark. And then you also have addresses. And these are akin to ethereum addresses. Digging a little bit deeper, a struct is a composite data type which contains a number of fields.
00:26:10.926 - 00:26:46.270, Speaker A: Each of these fields could either be a primitive data type or another composite data type, another struct itself. So now let's look at some Leo code and actually see some of the familiar paradigms that Leo provides to users. So here's our hello, world Leo program. From line one through nine, you define a program scope and its associated name. Hello Alio. And on line two we have a function foo. And on line five, we have a function main.
00:26:46.270 - 00:27:38.878, Speaker A: Before going into the distinctions between a function and a transition, let's just walk through the logic a bit. So a function foo takes in as input x and y produces U 64 as an output and returns the difference between x and y transition main quite simple invokes foo and returns it directly. Now, the distinction between a function and a transition is that a transition forms the external interface of your contract. This is what are the transitions that are actually created in the record model. Transitions have the ability to take in records as input and provide records as output. And transitions also have the ability to declare visibility on its inputs as well. You can think of functions as effectively like helper functions in your code.
00:27:38.878 - 00:28:23.578, Speaker A: But when interacting with your program as a user, you are invoking transitions. So one thing to call out here is that Leo is a strictly type language. Every variable declared needs to have its type and this is mainly to enforce safety during programming. We're also investigating some techniques. We're also investigating implementing type inference to make this a little bit more ergonomic but more to come down the line. Another thing to call out is that Leah provides some primitive standard operations over primitive data types right here. One thing obviously it provides is integer subtraction, some integer arithmetic.
00:28:23.578 - 00:28:58.606, Speaker A: Now, Leo's arithmetic is safe by default. So all of these primitive operations actually check for overflow. So here you don't need any notion of safe math. Safe math is done by default. And if a user really would like to use a wrapped version or a wrapping version of integer arithmetic that is also available to them. They just have to explicitly call it within our standard library. And then the final thing to call out here is that like I said before, transitions have visibility modifiers on its inputs and outputs.
00:28:58.606 - 00:30:10.586, Speaker A: And this is especially useful because really in some cases you don't want everything to be private or in some cases you really want to say some inputs are public and really control visibility in a fine grained manner. And this is what transitions let you do. You can define modifiers on each of your visibility, modifiers on each of your variables and the compiler otters these modifiers when it actually produces the circuit, the compiled circuit underneath. So let's look at a little bit more complex example here we have an interest calculation that compounds for ten iterations or ten periods. We take in as input capital, a public rate and just calculate the interest via a simple for loop. I think this should be familiar to most programmers coming from any language here. One thing to call out is that loops in Leo and loops in Leo must be static integer literals.
00:30:10.586 - 00:31:24.066, Speaker A: And the reason for this is that when you're actually describing your program predicate in a snark, it needs to be deterministic and finite of a finite bound of a finite size. So we can't have non deterministic circuits or circuits or programs that change in size depending on input. So all of these constructions here, like loops need to be effectively unrolled into a sequence of instructions before being able to synthesize a circuit or a mathematical representation of that program. But this is not super desirable in all cases, right? Like some cases we're going to want to change the behavior of our program based on input. And one way you can get around this is by defining your circuit such that it accepts computation up to a certain size. So bounding the size of your computation and we'll see how you can do that right here. So this is the same interest program but in it you actually pass in another parameter iterations.
00:31:24.066 - 00:32:25.002, Speaker A: An iterations specifies the number of times you want to compound your interest. As you can see in the body of the for loop, the modification is that if the loop index is less than the number of desired iterations, you accumulate the sum, you accumulate the interest accrue interest. But if it's greater you don't do greater than or equal to, you don't do anything. And what this does is that it lets you define a larger circuit which describes possibly a larger set of computations you want to run and then you control with input what you're actually running. And this is some ways you can get around the limitations of circuit based languages. So one thing to call out here is this assert statement here. Effectively what this does is this gets compiled into alio instructions and when the AVM executes the corresponding program.
00:32:25.002 - 00:33:35.326, Speaker A: If this assertion is triggered, the prover will halt actually will fail to create a proof. So this is a construct in Leo that lets developers really add in safety checks and ensure that a prover can't create a proof for something that violates certain invariants cool. So we went through some familiar programming paradigms. Leo looks a lot like rust and TypeScript for those that are coming from those languages and provides some constructs that are sort of expected in all programming languages. Now, Leo also provides some more powerful concepts and we use these concepts to create private applications and we can do some fancy stuff with them. And the first thing is records like we described before Leo, because Alio is built on top of the record model, leo needs to have a way of interfacing with this model and you can do so by declaring records. So recall that we were able to declare composite data types called structs.
00:33:35.326 - 00:34:37.614, Speaker A: Records are very similar to structs except for the fact that they have two required fields an owner, which is the address that owns that record and it is the address to which that record is encrypted and Gates. And Gates is a native denomination of Alio credits associated with that record. So you can think of Gates is to Alio credits as Gway is to ETH as cents are to dollars. Now, with this model, application state is encoded in records and users exclusively own their records. Because records are encrypted under a user's address, they are the only ones able to see the information inside a record. And with this you have concurrency and privacy. So let's take a little know, just look at what we can kind of do with records, what we can define.
00:34:37.614 - 00:35:20.450, Speaker A: So records can contain any sort of other data type in Leo inside of them. So they can either contain in this case we see that a record contains a field message which is a struct and that struct payload here contains primitive data types but could also contain more composite data types and so on. The only thing you can't have is a record inside of a record. So that's the only level of nesting that isn't allowed. A record can also define more fields if they'd like. So in this case we only define one. But you could imagine a record that has any number of fields after that for any other application data that you want to encode.
00:35:20.450 - 00:36:25.560, Speaker A: So how do we use records on Alio? Suppose we have some transition foo. A transition can take in any number of records as input and produce any number of records as output. Now, how does this work in principle and in reality here? So we're going to instantiate and look at this record model under the context of tokens. So we're going to describe user defined tokens in Alio and in Leo and we'll see how the record model enables this use case so quickly. We have some record token which has an owner and gates as required and some balance for that token. And now we have a function, a transition sorry, transfer which takes in as input a token. So the sender's token, the receiver's address and the amount that the sender would like to send.
00:36:25.560 - 00:37:27.290, Speaker A: What transfer does is that it consumes the sender's token and produces two new tokens, one with the remaining balance and one with the new balance for the receiver. So in line two we calculate the difference between the sender's amount and the amount that we want to send. Recall that Leo is safe math by default. So if this operation would overflow, the execution layer would be unable to produce approved for it. And then on line three we actually construct a record for the remaining balance for the sender. And then on line eight we construct a record for the remaining balance for the or the amount for the receiver. And then on line 13 we send these out.
00:37:27.290 - 00:38:23.790, Speaker A: And let's take a look at with a better diagram of how this actually looks like. So here, let's suppose Alice wants to send some amount of money to Bob and she's going to invoke the transition transfer to do it. So she has a ledger where she has some record with some gates and some balance. And what Alice does is that she invokes the transition transfer with Bob's address and the amount she wants to send. The transition transfer produces two new records, one for Alice, one for Bob and a proof pi. I also see here that I have a typo and really in Bob's balance this should be a three U 64. So if this proof is verified and is accepted, then the two records are appended to the ledger.
00:38:23.790 - 00:39:14.110, Speaker A: Note that the Alice's original record N is actually grayed out. And what this indicates is that this record has been consumed. So technically, even though this record will always be stored on the ledger, it is updated with a flag or actually it's updated with its serial number which indicates that this record cannot be consumed again and this prevents double spending of application state or records. So that is the record model. This is a powerful paradigm. We can create private tokens and really can create a lot of applications in a different model that create privacy effectively. But we're going to sort of backtrack a little bit.
00:39:14.110 - 00:40:19.486, Speaker A: So earlier in the, in the presentation we, we talked about how the account model was bad and why leaks privacy, why it's bad for concurrency. But actually, you know, in certain applications having public or global state, this account based model can actually be useful. So on chain execution is actually sometimes a good thing, sometimes a desirable thing. One example is like Escrow. So when you put something in Escrow or you want to do it in a decentralized way on chain state can make this programming such a thing super easy. So is there a way we can combine the record model with onchain state and execution so that we have this hybrid model that lets users kind of choose a sliding skill of privacy and also get the best of both worlds here, really? And turns out we can. So mappings are an experimental feature in Leo and in Ileo.
00:40:19.486 - 00:41:21.554, Speaker A: But these are essentially similar to mappings like you have in Solidity. They're effectively maps from a key type to a value type. In this case, you have a mapping balances that maps from addresses to U 64s. So how do we actually interact with mappings? Here we have a modified version of the original transfer function or transfer transition. And yeah, let's walk through it, let's see what the differences are. So first of all, we added two public modifiers for receiver and amount. In this case, the way this transfer function is going to work is that it's going to take in a sender's record, return the sender a new record with the remaining balance, but then invoke some on chain execution, that updates a mapping on chain with the receiver and its new balance.
00:41:21.554 - 00:42:45.860, Speaker A: And effectively what this is doing is it's taking a private token, a private number of tokens, and transferring some to the receiver publicly so that everyone on chain can see the receiver's new balance. So on line two, we calculate the difference. We construct the record for the sender, the remaining record, and then on line eight, we return the record back to the sender and we use a then finalize invocation to indicate that after creating this record or doing your after performing your off chain execution on chain, you would like to invoke a finalized block with the receiver and amount as arguments. And a finalized block is a block of code, this block of code here and each transition function can have a finalized block associated with it. So you see how you have a transition transfer, you can have a finalized transfer here. The inputs to a finalized block must be public. And in this finalized block, what we're doing is we're taking balances incrementing receivers entry in that mapping with the new amount that we'd like to send.
00:42:45.860 - 00:43:37.810, Speaker A: So how does this work on chain? So here we have a network, there's some validators. The network contains a ledger with Alice's record and it also contains a mapping balances with keys and values, keys being addresses and values being the amounts allocated to each address. So first Alice will query the network for her encrypted record. Note that only Alice can see the data of this record. Then she will execute the transition transfer locally. So what that does is to do that she provides Bob's address's input the amount she'd like to send. The transition transfer produces a new record containing Alice's remaining balance and passes through the arguments to the finalized block.
00:43:37.810 - 00:44:16.810, Speaker A: And then the transition also produces a proof. So note that this is all done locally and this is all done within the body of the transition. So if we're looking at the original code here, everything that was just executed is from lines two to eight. So now that Alice has kind of executed a transition locally, she now produces a transaction and sends it to the network. So in this transaction, we have all the outputs of our transition. And what the network first does is that it verifies the proof. If the proof doesn't verify, the network drops the transaction.
00:44:16.810 - 00:45:12.270, Speaker A: No state is updated. But if the proof verifies, then the network stores the new record and then updates its mapping with Bob's new value. And this is effectively how we can combine off chain execution and on chain execution. And in the off chain world, we really can leverage privacy, scalability. You can define all kinds of computation off chain, run it in a snark and prove it in a short time. And with the on chain model, we can have some more complex interactions and now allow for some of their stuff that are originally possible in the count model at the expense of, in this case, still sacrificing some privacy, but getting you some more expressivity with it. All right, so that concludes the deep dive of the language.
00:45:12.270 - 00:45:36.770, Speaker A: For the purposes, it looks like we got about like nine minutes of time. So I think the best way we're going to do this is we're going to walk through an auction example. We won't do a live coding, but we'll at least walk through the application, get a feel for how it's designed, and then we'll look at how to deploy an application, like, hey, Pranav.
00:45:36.850 - 00:45:53.054, Speaker B: Also it's Joe. Just so you know, there's not like a particular hard stop, so if you want to keep going, you can. And I think many of the people in the audience would hang around. It's not just going to stop at eleven, but if you want a hard stop at eleven, we can do that too.
00:45:53.092 - 00:45:56.480, Speaker C: It's just totally just wanted to let you know. It's completely up to you, man.
00:45:56.850 - 00:46:18.834, Speaker A: All right, sounds good. I appreciate it. We'll just walk through the example. It should be pretty illustrative, I think, and I'll stick around for questions after because I'm sure there might be some lingering all right, let's see. Let me just switch this out. Cool. Sweet.
00:46:18.834 - 00:46:51.770, Speaker A: Okay, everyone can see this. So this is the auction example in the workshop repo, and this should be included in the developer resources. So let's just walk through it. Just step through the code a bit and step through the design. So we define a program auction alia, and with this application, we're going to define some records that are associated with this application. The record, we're going to call it a bid. The first two fields of a bid are owner and gates required fields.
00:46:51.770 - 00:47:55.410, Speaker A: And in a bid, the data that's important here is who the bidder is the amount that was bid and whether or not this is a winning bid. So with these three pieces of application state, we're going to be able to implement private auctions. Now, to clarify a little bit here, in this auction model, we are guaranteeing privacy with respect to the bidders, the auctioneer or the party running the auction is able to see all the bids. And we're assuming that the auctioneer is semitrusted here or is a trusted party. There's no collusion between an auctioneer and a bidder, so there's no cheating in that form. This construction could be improved to actually provide privacy against the auctioneer as well, but that's a little bit more complex and we're going to just keep it simple for now. So first we're going to define a transition which allows someone to place a bid.
00:47:55.410 - 00:48:36.478, Speaker A: The transition place bid takes in a bidder and amount as private input and produces a bid, a record. The only check is this is actually a very simple function. All it's doing is minting a record and the only thing it checks is that the party who called the function is in fact the bidder. And why we have this check is to ensure that another person can't come along. Let's say Alice bids some amount, bob can't come along and just up her bid maliciously. So this is how we can place a bid. And now let's define how we can resolve a bid.
00:48:36.478 - 00:49:13.840, Speaker A: So this function resolve takes in two bids as input. Both are private and produces a new bid as output. This function, we want to design this application such that it can only be called by the auctioneer. So here we've hard coded an address for the auctioneer and we check that the caller of this function can only be the auctioneer. And to resolve the bid, it's very simple, very straightforward. You check the amounts in each of the bid records and select the greatest one. And ties are broken by order.
00:49:13.840 - 00:50:12.430, Speaker A: So the person who submitted first or is inputted first will take it in the case of a tie. And then finally we have a function called a transition called finish, which takes in a bid and updates its state to indicate that it's a winning bid. And this function, we also want to restrict that it's called only by an auctioneer. So we check that only an auctioneer can call it and we just essentially return the same data that was in the original bid, except flip the flag is winner to be true. And in doing this, we actually kind of arrive at a pretty cool construction for private auctions. That's very simple. It doesn't require any sophisticated code, but really relies on the fundamental properties of the alio stack and some nice cosmetic stuff from the Leo language to make it really simple logic.
00:50:12.430 - 00:50:29.480, Speaker A: And let's kind of go through a little bit of how we can build these applications or use the leo language of the font size. Is the font size okay?
00:50:31.690 - 00:50:38.266, Speaker D: Yeah, I think it could maybe use a little zoom, especially for the people on mobile, but yeah, that's perfect.
00:50:38.448 - 00:51:04.820, Speaker A: All right, cool. So Leo provides a CLI. There are a couple of commands that you can employ. Leo new, essentially initializes a new directory with essentially a new Leo project for you with some templating. We won't need to use that for now. So what we're first going to do is do Leo clean. I'm going to clean my old build.
00:51:04.820 - 00:52:03.720, Speaker A: I'm going to do Leo build. So what this does is in that process that I described earlier, the Leo language translates this high level program into alio instructions. Alio instructions, essentially invokes the AVM, which parses and synthesizes a circuit, a mathematical representation of the program underneath. And really the synthesis process is actually quite involved and as you can see, dominates much of the execution time here. But you only do this synthesis when you're actually trying to submit a proof during development. You don't need to do this, but for this case, we will. So we build a alio program and what we have here is a directory build.
00:52:03.720 - 00:53:04.700, Speaker A: And in build we have some provers verifiers. So these relate to the mathematical representation of the program. We also have an alio instructions file and this is alio instructions. There's some more resources out there, but this is effectively what the intermediate representation looks like. So we also have in our repo, just to kind of make things a little bit easier, is a script run sh, which effectively invokes Leo to just make running this program a little easier. So what I'm going to do is I'm going to, let's see, max out this and then on the auction. So we have some commands to make this pretty, but in step one, the first bidder places a bit of ten.
00:53:04.700 - 00:53:33.170, Speaker A: We compile our program and execute aliode place bid. The output of this function is a record and as you can see, this record is owned by the auctioneer. So only the auctioneer can see what this record is. Let's see if I can. Yeah. And then the second bidder places a bid of 90. And again, this record is only owned by an auctioneer.
00:53:33.170 - 00:54:26.286, Speaker A: And then finally the auctioneer takes the two bids, calls resolve, and since bidder BD, a higher amount creates a new record, with bidder b being the owner here and returns, that is winner is true. So this example, we had to do a little quick one here, but it's all there in the workshop repo. You can step through it. We also have included a guide, so a step by step developer guide where you can actually walk through. We kind of give you a walkthrough of how to build this application, what the logic is and how the interactions work. But hopefully you got a taste for what using Leo looks like. One quick thing I want to do is show how we can deploy applications.
00:54:26.286 - 00:55:13.170, Speaker A: So for those of you have a little bit more time, I'm going to show you a prototype tool that we've been working on called Slingshot. And Slingshot essentially allows you to spin up a local development node and essentially run your programs locally, test them without having to do the heavyweight deployment of going to testnet and whatnot. And effectively what we're kind of envisioning for this tool is something like Anach. So let's take a look. So Slingshot is publicly available. It's a prototype and we'll also include a link for it in the workshop resources. But yeah, let's take a look.
00:55:13.170 - 00:56:15.350, Speaker A: So here on the left, we're invoking the Alio SDK with some command Alio account new. What this does is it generates you a new private key view key and address, which you can use when you're developing on the two left screens, we just looked at the program JSON, which is a file that exists in each Leo project. And that file contains some important data about for that program, what some development private keys are for each of them. So the important thing to note is that we have two addresses here, two private keys that are unique. And what we're going to do on the left is spin up a Slingshot node with a private key that we created earlier. So Slingshot will take some time to spin up. And then it's going to start a server to which you can initiate requests.
00:56:15.350 - 00:57:23.350, Speaker A: So Slingshot has a faucet which kind of helps spin up being able to deploy and run applications. So we're going to send to the account on the top right 100 credits. And on the left we see that the transfer transaction is executing. And just for kicks, we're going to also pour one more support, another 200 credits. And what this will do on the right is create another new record with 200 credits inside of it. So one thing you want to be able to do is query for the records that exist on chain here. I'm going to attempt to query Slingshot, but I'm going to mess up the command, as you'll see, and I figure it out.
00:57:23.350 - 00:58:35.660, Speaker A: So essentially with Slingshot, you have a couple of commands available to you to get tokens to your accounts and then also see the records that have been created across the execution of this development node. And you can use these records when you're also now executing new programs and whatnot. So what we'll do here is right now what we did was for the auctioneer, which is the top right, we have poured some amount of records for the auctioneer. We're also now going to pour some credits for Alice, who is going to try to make a bid. So on the optioneer side, we'll first deploy the program and this is done by invoking Slingshot deploy. And as you can see, once we've invoked that deploy transaction a bunch of stuff starts to go on inside the local node. It starts to read the program, create a mathematical representation of it, and store that on chain, or in this case, on the single node.
00:58:35.660 - 00:59:22.848, Speaker A: This process actually takes a bit of time. As you already saw earlier when compiling Leo programs, the synthesis process is very involved. But once it's done, let's see we're able to deploy the program. I guess it gets a little cut off here. That's too bad. So I don't know if you can see the bottom left or bottom right, but essentially we call slingshot execute. Yeah, auction place bid.
00:59:22.848 - 01:00:05.840, Speaker A: The first execution is a valid bid. We use it with Alice's address and you see up on the know, we execute place bid. The second invocation to place bid uses a different address, actually, the auctioneer's address and the node fails to run. And this is the check that we had earlier to make sure that only the caller is the person creating the bid. And yeah, this is still a prototype tool. There's a bunch of stuff we can workshop here. What we're really interested in is improving the UI, adding features that developers want to see when they're testing their local developments.
01:00:05.840 - 01:00:33.604, Speaker A: And we also want to really just kind of get feedback and explore how we can make this tool into something useful in the ecosystem. And with that, thank you for listening. Ilio is written in rust. It's all open source. It's all up on GitHub. There's also a workshop repo, like I said, that contains a bunch of stuff on how to get started on development. And we have a discord and Twitter.
01:00:33.604 - 01:00:44.892, Speaker A: So please join, please be a part of the community. And thank you so much for listening. Thank you.
01:00:44.946 - 01:01:06.836, Speaker C: Thank you. Pranav, that was know, as usual, you guys crushed it. So really appreciate it. I'm sure everybody in the audience really got a great understanding about how to work with Alio. This was definitely a great follow up on Anthony's. Kind of just like high level breakdown on what Alio is and what you guys are doing. Thank you.
01:01:06.836 - 01:01:39.784, Speaker C: Everybody in the audience who attended. This is generally the time where we just make room for questions. I do see actually, let me double check. Earlier on, there was somebody in the audience who had a hand raised. So what we do for anyone who hasn't been here before is you can actually raise your hand in the controls on the bottom of your screen or your phone. If you raise your hand, we can pull you up on stage to ask your question, to engage with the panel. And if you would rather just drop your questions in the room, chat a little more shy and just want to drop a question, please do.
01:01:39.784 - 01:01:50.576, Speaker C: I do think, Sean did we have some questions back in the feed. I thought, you know, we have a few to let's just yeah, so it.
01:01:50.598 - 01:02:05.224, Speaker B: Seems like josh, if I'm mispronouncing your name, I'm sorry. Josh Meyer. Meyer or mayor has some questions here. Did you maybe want to raise your hand and come up, Josh? Or if you don't raise your hand in the next 30 seconds, I'll just.
01:02:05.262 - 01:02:09.464, Speaker C: Ask your questions from chat. Where are you? There?
01:02:09.582 - 01:02:11.016, Speaker D: Just brought them up.
01:02:11.198 - 01:02:12.408, Speaker C: Okay, cool.
01:02:12.574 - 01:02:14.296, Speaker B: Josh, what's up, man? How are you?
01:02:14.318 - 01:02:15.400, Speaker A: Just unmute.
01:02:19.060 - 01:02:19.920, Speaker E: Can you hear me?
01:02:19.990 - 01:02:20.380, Speaker A: Yes.
01:02:20.470 - 01:02:21.600, Speaker B: You are audible.
01:02:21.760 - 01:02:29.476, Speaker C: Thanks for joining us. Thanks for asking questions and being let's. What do you have for us?
01:02:29.578 - 01:02:41.896, Speaker E: Yeah, that was a great presentation. I'm setting up a Leo learner group, and we're going to be doing some lower level basic starting for anybody who had trouble following along with that, we'll take this, we'll break it down.
01:02:42.078 - 01:02:43.284, Speaker A: We'll get your feet wet.
01:02:43.332 - 01:02:53.692, Speaker E: You don't have to be a programmer to learn. Leo can be your first language that you learn on, and that's okay. So we'll be coming out with that in the next few weeks. We're having our first meeting this week.
01:02:53.826 - 01:03:35.724, Speaker B: Hey, Josh, just before you continue, I would know for everybody in the audience, anybody who was know, new to this, trying to follow along, interested in the engineering side, is a builder or is in the hackathoner or not, and just interested in building on Alio. Connect with Josh through Entra. And Josh, I would like engaging the people in the room, make some connections. And actually, you can host that meeting digitally as well. If it's an in person thing, you can host it digitally here on Entra and kind of do like, a follow on. I know sometimes people have a tendency to do, like, event after. You know, if anybody wants to host, like, after party and get in and kind of discuss the content.
01:03:35.724 - 01:03:42.120, Speaker B: That's another thing people do. Just if you're interested in doing know, start a room and then drop the link here in the chat. But go ahead, Josh.
01:03:42.200 - 01:03:43.036, Speaker A: Okay, yeah, sure. Yeah.
01:03:43.058 - 01:04:14.384, Speaker E: So what we're doing, we're setting it up on Discord. We're going to make recordings. We're going to be posting them on YouTube. We're going to do a walkthrough for the people that are in there, get all the kinks worked out, and then we're going to set up a series of videos that you can watch in a weekend so you can go from zero to writing your first smart contract in a weekend. And then also we're going to teach mob programming, which is where you get a group of people together and you all know programming, so you can all be productive in making that happen. And I'm on discord. I'm at Josh on Discord.
01:04:14.384 - 01:04:32.972, Speaker E: I'm a moderator on the Discord. So you can reach out to me. Also. So my question I had you said about the transactions, and you can't have two transactions happening at once. So what's the throughput on transactions? How long would it take for one to clear? And is that something that's going to scale, or is it going to start.
01:04:33.026 - 01:05:25.388, Speaker A: Out kind of at the limit? Yeah, so I guess sort of clarify a couple of things there. So with the account, with that augmented account model, we didn't really have that much throughput no concurrency. So with this new record model, you now do have this concurrency, and I don't have the numbers off the top of my head. I think Colin has some rough numbers here in the chat, but effectively, I believe. So even though you have a certain number of transactions per second, you could actually really increase up the throughput by encoding more of your computation inside. That's done offline in the snark. So suppose that you can only do one transaction, but you actually make it a really big one.
01:05:25.388 - 01:05:49.620, Speaker A: Maybe it's a roll up, actually, of a bunch of other stake transitions. This is something that's possible, and that's how you can actually boost up throughput. That being said, I'm going to say that that's sort of an exploratory construct. No one's kind of instantiated yet, but it's still, like, natively or primitively, supported by our architecture. Okay, awesome.
01:05:49.690 - 01:05:51.216, Speaker E: And then the other question I had.
01:05:51.258 - 01:05:55.524, Speaker A: Was okay, so I'm kind of fuzzy.
01:05:55.572 - 01:05:58.660, Speaker E: I read the definition for the link that was post for transition.
01:05:58.740 - 01:06:00.116, Speaker A: It's still a little hazy.
01:06:00.308 - 01:06:07.580, Speaker E: Is there something that's similar in Rust programming that transition would be, or is this just a blockchain?
01:06:08.400 - 01:06:31.012, Speaker A: It's just a blockchain thing, really. If you think about it, both transitions and functions are functions. In the traditional programming sense, transitions just have this extra notion of doing something on the blockchain. Okay. All right, that's clear. Okay, thanks a lot. That was great.
01:06:31.066 - 01:06:32.324, Speaker E: I really like that.
01:06:32.522 - 01:06:47.880, Speaker A: Yeah, thanks. Josh also really appreciate kind of the interest in actually creating a Leo learning group. We love it when people take initiative and start learning stuff. So there's any stuff we can do to help support that, let us know. Super exciting.
01:06:48.460 - 01:06:56.716, Speaker B: Same here, Josh. We're all about learning community, and we love Alio, so if there's anything we can do to support you, please let us know.
01:06:56.818 - 01:07:03.814, Speaker A: Okay, great. Thanks, guys. Absolutely.
01:07:03.932 - 01:07:15.914, Speaker D: And I don't see any other hands raised or any more questions in the room chat, so if you guys have any questions, feel free to drop them or click that raise hand button. But with that said, more than happy to kind of wrap things up.
01:07:16.032 - 01:07:16.266, Speaker A: Got.
01:07:16.288 - 01:07:20.800, Speaker B: We got one more. I think we got time for one more. I'm going to pull up Andy over here.
01:07:21.570 - 01:07:22.314, Speaker A: Hey, Andy.
01:07:22.362 - 01:07:26.000, Speaker B: How are you? You're going to have to unmute bottom left.
01:07:31.320 - 01:07:33.156, Speaker F: Hey, guys, can you hear me?
01:07:33.258 - 01:07:34.790, Speaker A: Yep. How are you?
01:07:35.240 - 01:08:17.670, Speaker F: Yeah, it's nice to be here and listening to all of the things you just said. This is really yeah, I'm just having a quick question, actually. I'm not really a developer myself. I'm kind of a community builder. So I'm building communities of developers in Southeast Asia. In Vietnam, in Thailand, Philippines, and just wondering if you guys are interested in raising a community of Aliel builders in Southeast Asia for specific, or Vietnam. Because if you are interested in that, then we could probably discuss more about that.
01:08:18.680 - 01:08:55.120, Speaker A: Yeah, this is something we're definitely interested in. And actually, right here we have a link for the Alio discord. And in the discord, I think we have some channels already or some channels through which you can go through to start spinning up communities if they don't exist already. And our moderators on there and our community members and our head of community, actually Viv is super active on there. So that's probably the best way to go through and get the ball rolling on these discussions.
01:08:55.700 - 01:09:02.610, Speaker F: All right, cool. I would drop a WhatsApp there and we'll see what we could do next.
01:09:03.640 - 01:09:28.936, Speaker A: Yeah, that'd be great. Sorry, just saying. Yeah. One general plug on the discord. A lot of us are actually pretty active, especially the engineering team, for answering questions. That's probably the best channel to reach us if you need support, help. So, yeah, just kind of just throwing that out there.
01:09:29.118 - 01:09:42.480, Speaker B: I'm going to keep this one quick because I think we're running up on kind of a sensible time here. Andrew Rossborough dropped into the chat. He said, can you discuss a little more on the Asynchronous nature of finalized statements?
01:09:42.980 - 01:10:33.040, Speaker A: Yes, so that's a great question. So finalized statements essentially execute in the same way as Ethereum transactions execute or in a similar model. So while you can make a bunch of modifications to some on chain mappings via a number of finalized invocations, the order is essentially sequenced by the block producer, and they can all go through, but it sort of just kind of falls prey to some of the similar limitations, I think, consistency limitations that exist on Ethereum effectively. Does that answer your question, Andrew?
01:10:41.610 - 01:10:49.180, Speaker D: I think so. I think I was curious oh, he said, I think I was curious if there were any caveats to it.
01:10:51.550 - 01:11:05.680, Speaker A: I guess maybe this might be a little bit more of a back and forth, but if by caveat you mean like, Gotchas, maybe, yeah.
01:11:09.270 - 01:11:11.234, Speaker B: Will the data always be committed on.
01:11:11.272 - 01:11:12.610, Speaker C: Chain to the mapping?
01:11:13.910 - 01:11:47.082, Speaker A: Yes, it will always be committed. As long as there are a couple of caveats. It'll make it as long as the proof is valid associated with the finalized transaction, and then as long as the finalized transaction itself does not either error out or runs too long and halts. Okay.
01:11:47.216 - 01:11:48.970, Speaker D: Hi, Prana.
01:11:49.310 - 01:11:53.680, Speaker A: Hi, Andrew. Good to meet you. Actually. Yeah, we've been talking a little bit.
01:11:54.690 - 01:11:56.126, Speaker D: So I guess what I'm curious about.
01:11:56.148 - 01:12:11.490, Speaker A: Is Asynchronous, and if you're incrementing mapping and that would be the main function, I think finalize does, is let you issue increment statements and mapping. Would it be out of order? Like, would the order be preserved that the finalized statement was called?
01:12:11.560 - 01:12:12.274, Speaker F: You said it was.
01:12:12.312 - 01:12:14.358, Speaker B: Up to the lock producer to choose.
01:12:14.444 - 01:12:31.766, Speaker A: When to execute the finalized statement. Yeah. So what's going to happen here is essentially, let's say you have two transactions in a block that both increment the same entry in a mapping on chain.
01:12:31.878 - 01:12:32.540, Speaker D: Okay.
01:12:33.950 - 01:13:22.778, Speaker A: Let's say both of these transactions are sent to the network, their proofs verify, some person verifies both of their proofs and puts it all in a block. The order in which those mappings are incremented are dependent on the order in which that block producer included the transactions because that's the order in which the finalized blocks are going to execute. Now, one thing that's nice here is that increment and decrement operations are, or at least let's say this increment operations are monotonic. So ordering doesn't matter. Right. But this is an issue in the general case, when you start getting loads in stores, ordering does matter. Okay.
01:13:22.778 - 01:13:28.558, Speaker A: I was curious, if you're incrementing a mapping and then returning a record with the current count or something like that.
01:13:28.644 - 01:13:30.142, Speaker F: I guess you would want to access.
01:13:30.196 - 01:13:43.682, Speaker A: The mapping directly rather than copying it to a record because that record could become outdated with other transactions. Yeah, that's exactly right. Okay. Yeah. A great question.
01:13:43.736 - 01:13:44.500, Speaker F: Thank you.
01:13:48.950 - 01:14:03.160, Speaker D: Love it. Well, with that, I think we'll go ahead and wrap things up. As always, you guys had an amazing presentation. I'm surprised there are any questions. You guys literally answered all of mine. It was honestly a great presentation. Really appreciate you guys coming on.
01:14:03.160 - 01:14:10.490, Speaker D: If there's any final words, best way to reach you guys, any of that stuff, feel free to drop that now, and then we can go ahead and wrap things up.
01:14:10.560 - 01:14:16.780, Speaker B: I have one thing I'm going to share really quickly here. Just as kind of like.
01:14:21.590 - 01:14:22.018, Speaker A: That I.
01:14:22.024 - 01:14:34.730, Speaker B: Bought for my two year old, right? And pranav. Check this out. Ready? So he colored in it a little bit, but here we go. I'm just going to get down to it. Alice has the coin. Bob has the apple.
01:14:36.110 - 01:14:37.100, Speaker F: That's awesome.
01:14:38.430 - 01:14:42.874, Speaker B: So that definitely touched me with the Alice and Bob example.
01:14:42.992 - 01:14:44.140, Speaker C: I appreciate it.
01:14:45.630 - 01:14:51.280, Speaker A: Yeah, we should get your kid learning the alias stack, get him started early.
01:14:52.450 - 01:15:00.898, Speaker B: This is the I mean, he's got blockchain for know, electrical engineering for babies, all that stuff. So yeah, we're definitely putting them on.
01:15:00.904 - 01:15:02.260, Speaker C: The path, for sure.
01:15:04.150 - 01:15:06.562, Speaker A: Yeah. That's awesome. Cool.
01:15:06.616 - 01:15:23.894, Speaker B: Well, thank you so much, guys. Colin, actually, that's a great question. I know your Alio team. I also just want to give a quick shout out to Colin Chen. Thank you for sharing all the resources, staying on top of it, managing the chat, making sure everybody has access to all the docs and stuff and repositories. I really appreciate it, man.
01:15:23.932 - 01:15:28.218, Speaker A: It's definitely makes a dynamic experience. So thank you.
01:15:28.384 - 01:15:30.074, Speaker D: On top of it. It was awesome.
01:15:30.192 - 01:15:33.242, Speaker C: And the talk will be posted, so.
01:15:33.296 - 01:16:16.714, Speaker B: We process the recordings once the recording is processed. This is a little bit of a longer talk. It'll probably take a few hours know, maybe potentially overnight, depending on what's in the queue. But once it's processed, we'll shoot it over to Anthony via recorded files and then we also send it to Ellis at HackerEarth. So if you're on the hackathon page@hackerearth.com, which I will share really quickly, right here there is a workshop recordings tab where that will be available once they put it up. But other than that, if you're not in the hackathon and you want to reach out to anybody on the Alio team, they'll have a copy of that within the next day or so and.
01:16:16.752 - 01:16:18.700, Speaker C: Can probably share if they want to.
01:16:20.590 - 01:16:48.574, Speaker B: So thank you so much everybody. We really appreciate it. Hope everybody has an awesome know. Thanks again, Alio, for sharing and thanks for everybody for coming. And as I always say, this is the start of the conversation. So connect, continue, and let's keep the dialogue going and let's all hopefully build some really cool things for this hackathon, maybe submit a couple of game changers built on Alio. I definitely am quickly becoming an Alio fanboy.
01:16:48.574 - 01:16:51.794, Speaker B: You guys are putting it together and putting it down and it's really cool.
01:16:51.832 - 01:16:53.618, Speaker C: What you guys are doing, so I appreciate you.
01:16:53.704 - 01:16:55.202, Speaker B: Thank you everybody so much.
01:16:55.336 - 01:16:56.000, Speaker A: We'll see you soon.
