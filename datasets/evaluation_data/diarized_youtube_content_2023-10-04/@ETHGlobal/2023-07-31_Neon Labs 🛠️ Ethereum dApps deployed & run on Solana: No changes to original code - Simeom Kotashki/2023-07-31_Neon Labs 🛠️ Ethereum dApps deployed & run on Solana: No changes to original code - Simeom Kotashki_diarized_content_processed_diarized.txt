00:00:07.530 - 00:00:13.690, Speaker A: So hello guys. My name is Simeon. I'm leading integrations with Neon EVM.
00:00:13.690 - 00:00:35.730, Speaker A: So today we'll speak about what the heck is Neon EVM and what are we doing, and we're going to be conducting a really short demo. So in a nutshell, neon EVM is EVM inside solana. It's not like layer two, it's not like a side chain.
00:00:35.730 - 00:01:08.478, Speaker A: But because Solana provides a very scalable architecture, we have the opportunity to build the entire EVM execution layer inside a Solana smart contract. And how this is possible? It's possible because in Solana, in one account you can store up to ten megabytes of executable data. And actually the EVM that's pretty interesting is around two megabytes.
00:01:08.478 - 00:01:50.474, Speaker A: So we built the EVM inside Solana and we provide an Ethereum like interface for users and developer to use it. And basically from developer perspective and user perspective, you can use the scalability and low transaction fees from Solana infrastructure and at the same time you don't really need to change your context and from user perspective change wallets. Or if you're a developer, I know it's really hard to change your tech stack or to learn new blockchain mechanics.
00:01:50.474 - 00:02:15.542, Speaker A: So we abstracted away all the Solana complexity. And so what we are going to do today, I'm going to deploy one contract both on Sepolia and Neon EVM to show you what differences and what code changes we need to do. And also I'll show you one more thing and we're going to see.
00:02:15.542 - 00:02:37.690, Speaker A: So the best place to get more info is the developer documentation. And here you can for example, go to, let's say, Neon Faucet and get some testnet. Neons you can get from chainlist.
00:02:37.690 - 00:02:52.900, Speaker A: For example, you can just write Neon, include testnets and add Neon DevNet in your MetaMask. I already have it and I already have Neons. But let's just try it out.
00:02:52.900 - 00:03:17.462, Speaker A: So yeah, we can request 100 Neons and they should be here shortly. Yeah. So we have an Ethereum like blockchain Explorer.
00:03:17.462 - 00:03:37.620, Speaker A: So everything is EVM native and you don't really need to know about how Solana works and how transactions settle on Solano there. So let's look at the project I have prepared. Basically it's a very simple hardhead project.
00:03:37.620 - 00:04:09.814, Speaker A: If we go and check, you can see we have just two or three dependencies, like we have hardhead, two bobs hardhead and hardhead Etter scan to verify our contract. And also we have open Sapling and Temp to store our environment variables in different file that will not be committed in our repository. So let's see the first contract that we are going to deploy.
00:04:09.814 - 00:04:34.242, Speaker A: So we have a simple ERC 20 token that we have supply limit, burnt amount, storage variable and just for the sake of the demo, I just added zero decimals so we don't have to add all those extra decimals. For example, if we want to mint from the Explorer, so we don't need to count them. Yeah.
00:04:34.242 - 00:05:05.760, Speaker A: So let's try and deploy first this contract in Sepolia and verify it to see to verify that it works on just normal EVM. Yep. Okay, before running yeah, I'm going to just run it and show to you the hard head configuration.
00:05:05.760 - 00:05:24.652, Speaker A: So, as you can see, we have configured two networks. One of them is Sepolia and the other is Neon DevNet. Basically, as you can see, you don't need to do any extra configuration for this.
00:05:24.652 - 00:05:37.420, Speaker A: And we also have another configuration. This is for the verification of the smart contract. We have the API key for Sepolia and also for Neon DevNet.
00:05:37.420 - 00:05:46.384, Speaker A: As of now, you can just put any key so you'll be able to verify the contract. Yeah. It's strange.
00:05:46.384 - 00:06:29.660, Speaker A: We are waiting so much for this contract to get deployed on Sepolia, it usually takes 4 seconds. Okay, I just try again. It should be operational.
00:06:29.660 - 00:07:36.702, Speaker A: It always happens like this when you need your contract to be deployed. It doesn't yeah, okay, let's try to yeah, I mean, yeah, we can we can just try to deploy it to Neon DevNet. Yeah.
00:07:36.702 - 00:07:48.450, Speaker A: So which one of you has deployed contract on Solana? Only one. Okay. Only one person.
00:07:48.450 - 00:08:14.694, Speaker A: Okay, so which one of you has deployed on EVM chain? Okay, we have more. So that's for you. Yeah, so you don't really need I've never deployed contracts on Solana for the simple reason that I'm just too lazy and just to learn any other and to change my tech stack, to change the code, learn new tools, learn new blockchain mechanics.
00:08:14.694 - 00:08:39.410, Speaker A: So I really find it very fascinating what Neon achieved. So basically, I don't know why for Sepolia it doesn't really work, but let's try one more time. Maybe we can check some other maybe the public RPC.
00:08:39.410 - 00:08:58.500, Speaker A: Let's just get another I think that's right. Let's just get another RPC node. Maybe this one is down.
00:08:58.500 - 00:09:20.148, Speaker A: So we already deployed our contract on Neon DevNet. I just want to make sure that on Sepolia everything's right. But if not, we're going to just proceed with Neon DevNet.
00:09:20.148 - 00:09:30.670, Speaker A: It's just a simple contract. So as you can see, we just imported from Openseplion and should be no changes made. Actually.
00:09:30.670 - 00:10:08.070, Speaker A: Okay, spoiler is not that important. So the good thing is that we managed to deploy on Neon and let's just verify this contract. Just a second.
00:10:08.070 - 00:10:42.400, Speaker A: Let's try to deploy it again. And it says that it cannot find the built info, which is strange. Let's do it like this.
00:10:42.400 - 00:11:22.642, Speaker A: We're going to hack it sooner or later. Now we should have the correct build info. Okay.
00:11:22.642 - 00:11:28.706, Speaker A: Yeah. I forgot to clean the cache of hardhead. It always happens if there is a problem.
00:11:28.706 - 00:11:33.190, Speaker A: The problem is in your cache. Always. Yeah.
00:11:33.190 - 00:11:51.800, Speaker A: So we verified the contract successfully and let's just go in Neon Scan and see. Yeah, we can see we've deployed the contract. We have the contract here.
00:11:51.800 - 00:12:09.470, Speaker A: Maybe we can try and add it in our MetaMask. Yeah, let's import this token here. It is.
00:12:09.470 - 00:12:31.100, Speaker A: Okay. And let's maybe try to mint. Yeah, we need to connect and let's mint 100 tokens.
00:12:31.100 - 00:12:42.240, Speaker A: Okay, let's see. Did we no. Yeah, we need to provide a little bit more because I found a bug yesterday.
00:12:42.240 - 00:13:22.616, Speaker A: Neo scan doesn't yeah, we need to have this value as gas because otherwise the transaction just requires a bit more gas. But actually a pretty interesting thing is that Neon doesn't use Gas measurement from Ethereum. We use Gas measurement based on Solana and it's a bit different but we support all the RPC calls.
00:13:22.616 - 00:13:40.352, Speaker A: So most of the libraries they use estimate gas and then put this as gas limit. So we are fully compatible with this. And obviously Neon scan don't use estimate gas.
00:13:40.352 - 00:13:51.032, Speaker A: Maybe hard coded some value. Let's just check. Yeah, we coded two times.
00:13:51.032 - 00:14:28.112, Speaker A: So we have 200 tokens and yeah, basically, as you can see, it works. One more interesting thing is that maybe if we open the transaction you can see that there is like five, maybe more nine Solana transactions. And if we open even one of them, you can see those are all the underlying transactions that executed and that were wrapped in one Ethereum transaction.
00:14:28.112 - 00:14:43.712, Speaker A: Basically. Why is that? Is because in order to scale, solana has a completely different infrastructure from Ethereum and it's stateless. Ethereum is stateful.
00:14:43.712 - 00:14:52.424, Speaker A: It uses accounts. In a nutshell, Solana is like a big file system. So different kinds of accounts.
00:14:52.424 - 00:15:13.872, Speaker A: It has data account and executable account. And Neon EVM basically creates executable accounts for smart contracts and smart contract. State is saved in data accounts in different files and read from them.
00:15:13.872 - 00:15:37.448, Speaker A: So sometimes we need to create one or two transactions. When we are using, for example, SS store, we need to create a new data account in order to execute this opcode. And this is one of the reasons we have more than one transactions and there are more limitations that we can discuss.
00:15:37.448 - 00:16:12.592, Speaker A: For example, one Solana transaction actually has limited 256 memory per transaction and all the EVM primitives like memory call stack is saved in this transaction. Memory, all the metadata that is related to the transaction and EVM. And sometimes we need to make two or three different iterations in order to complete the Ethereum transaction.
00:16:12.592 - 00:16:32.108, Speaker A: Okay, so the other contract that we are going to deploy is a bit more interesting. So it's called ERC, 24 SPL. How many of you know what SPL token is? No one? Okay, one person.
00:16:32.108 - 00:16:41.416, Speaker A: Okay, that's good. So I will explain to you. So SPO token is the ERC, let's say the ERC equivalent in Solana.
00:16:41.416 - 00:16:58.416, Speaker A: So in EVM networks we have each ERC 20 as a separate contract. Right? But in Solana we have a token program that is like a centralized smart contract, centralized program for all of the tokens. It's like a registry for tokens.
00:16:58.416 - 00:17:25.064, Speaker A: So in order to create to transfer to Mint tokens, you need to call this centralized program that is native on Solana and perform some token operations. So what we are going to do here, we have the SPL token contract here. As you can see, we wrapped it in the SPL token interface.
00:17:25.064 - 00:17:38.540, Speaker A: This is the interface for Solana. We also have metaplex. Metaplex is where the metadata for all the tokens resides in Solana.
00:17:38.540 - 00:17:58.288, Speaker A: So we also need this to get the token name, the token symbol and so on. So we also need this contract in Solana. As you can see, we are using some pre compiles and we wrapped the ERC 20 interface.
00:17:58.288 - 00:18:23.100, Speaker A: We wrapped it to call the underlying either Metaplex or SPO token. And what we are going to do now is we are going to deploy an ERC 20 on Neon EVM that under the hood will basically create a Solana SPO token and we can transfer it back and forth. So let's just see our script.
00:18:23.100 - 00:18:34.012, Speaker A: It's just a straightforward script. We get the contract factory for ERC 20 for SPO mintable. As you can see in this contract we have two tokens.
00:18:34.012 - 00:19:02.536, Speaker A: One is ERC 20 for SPL and the other is yeah, ERC 24 mintable. The only difference is that we have exposed mint functions here and the deployment script is actually pretty straightforward. We take the contract factory, deploy it and then we mint tokens.
00:19:02.536 - 00:19:39.190, Speaker A: So why we put nine decimals here is because Solana don't store variables in 256 bits but 64. And basically we don't want to have a big decimal because otherwise we'll sacrifice to have really low cap of how much tokens we can have. So nine decimals is okay, let's just try and deploy it.
00:19:39.190 - 00:20:18.970, Speaker A: Sure. Okay, now the most the most interesting part and again yeah. Okay, so we deployed, let's try to verify it.
00:20:18.970 - 00:20:41.000, Speaker A: Oh, yeah, we need to provide arguments. Okay, we don't have more time. So let's just see the transaction and I want to show you the interesting thing.
00:20:41.000 - 00:21:02.294, Speaker A: Okay, so you can see we have two transactions. One is the contract created and the other one is the Min transaction. So if we go to the contract create transaction, you can see we have 25 Solana and this is actually the deployment transaction.
00:21:02.294 - 00:21:32.070, Speaker A: Nothing that interesting. But for the other transaction, you can see that here we transferred from zero address to our address 100 tokens. Right? And if we go and see and check the Solana transaction, you can see that on Solana again, we have mint.
00:21:32.070 - 00:21:50.154, Speaker A: So it means that we have created native Solana SPL token. We deployed it and we can natively from Neon DevNet access Solana liquidity. And if we scroll down a bit, we can see that.
00:21:50.154 - 00:22:24.420, Speaker A: For example, here we have the token program basically that mints those tokens. So that was pretty much it. And do you have any questions regarding Neon and yeah, yes.
00:22:24.420 - 00:23:07.902, Speaker A: So solana because neon EVM is inside solana contracts can interact natively with solana contracts this was actually the demo I wanted to show you how we interact with SPL token program. And basically that's a good thing because you can create composable modules for solana but writing solidity code and don't change your tech stack and that's pretty nice. Only maybe I can just tell you about one problem that is not compatible.
00:23:07.902 - 00:23:22.354, Speaker A: But I think most of the row Ops and l two S have it. You cannot use block timestamp and block number as mapping index. This is still not supported.
00:23:22.354 - 00:23:44.716, Speaker A: But it's not I mean I've never seen it. Protocols use block number and block timestamp as index, most probably as mapping value, but not as key. So I guess there is no more questions.
00:23:44.716 - 00:23:46.190, Speaker A: Thank you very much, guys.
