00:00:10.570 - 00:00:18.478, Speaker A: Look at that. If I talk, like, is it loud enough? All right, a bit closer. All right.
00:00:18.478 - 00:00:37.142, Speaker A: Yeah, that's good. All right, we got some stragglers. This is unrelated to the talk, but if you want to be added to my hackathon social graph, come talk to me afterwards and I'll add your address to this.
00:00:37.142 - 00:00:51.920, Speaker A: This is all the people that I've met at the hackathon. All right, here's what we're going to do. We're going to launch a roll up in 30 minutes.
00:00:51.920 - 00:01:01.040, Speaker A: This time, if I fail, I'm not going to shave my head. I already did that. So you're just going to have to trust me.
00:01:01.040 - 00:01:13.966, Speaker A: Yeah, exactly. Well, last time, to be clear, I did do a thing where I said I would do this in 30 minutes or I would shave my head and my computer crashed. So it was the computer's fault.
00:01:13.966 - 00:01:20.278, Speaker A: But whatever. My hair is growing back. So it is what it is.
00:01:20.278 - 00:01:40.778, Speaker A: All right, so some context here really quickly. Optimism has been building stuff for a long time. We've been building this blockchain Op main net, and we were like, hey, people are starting to use this code to run their own stuff.
00:01:40.778 - 00:02:15.640, Speaker A: Why don't we just make that official and make it really easy for people to spin up their own roll ups using our code? And then they can help us build the software because they'll be using the same code, and so then they'll be building the software too, and everyone kind of wins. So we came up with this thing called the Op Stack, which is basically the code that powers the optimism collective. It does a lot of things, but one of the most important things that it does is you can use it to run a roll up.
00:02:15.640 - 00:02:38.430, Speaker A: So there are easier ways in practice to actually run these things. People now have built tooling on top of this where you can really it's close to one click to deploy these things. There's things like Conduit and Caldera and these companies now that are spinning up that will help you run a roll up.
00:02:38.430 - 00:03:07.720, Speaker A: But if you want to understand kind of what's going on under the hood and the different components involved, it's nice to be able to do it from source and to kind of just spin up each of the components one by one and get a good sense of what's happening. So this is kind of the slightly more in depth version than in practice, what people would be running in production, but it's worth understanding this. So we're going to be doing it from source, which is always more fun.
00:03:07.720 - 00:03:27.470, Speaker A: Okay, so you can follow along with this if you want. If you go to Stack Optimism IO and you go to the Getting Started page, I'm going to keep this on the left here, but I'm really just going to be talking about it so you don't have to see that. And maybe I should make my Vs code a little bigger.
00:03:27.470 - 00:03:35.174, Speaker A: Okay. Yeah. So a lot of the Op stack code lives in the optimism monorebo.
00:03:35.174 - 00:03:41.074, Speaker A: Big old monorebo. So just clone it. Start with that.
00:03:41.074 - 00:03:49.270, Speaker A: Pretty easy. And the monorepo has some stuff that you need, some stuff that you don't need. So we're just going to build some of it.
00:03:49.270 - 00:03:55.030, Speaker A: But it's really pretty straightforward. This is going to like I don't know. Who knows if we even take 30 minutes.
00:03:55.030 - 00:03:57.074, Speaker A: We'll find out. All right. Boom.
00:03:57.074 - 00:04:01.740, Speaker A: Optimism, right? We got the mono repo here. There's a bunch of stuff in it. Don't worry about it.
00:04:01.740 - 00:04:07.740, Speaker A: We'll get there. This is too small. Should I make this bigger? All right, good.
00:04:07.740 - 00:04:16.170, Speaker A: Obviously, install dependencies, whatever. That's going to take a minute. It always takes a minute.
00:04:16.170 - 00:04:28.900, Speaker A: Whatever. How's everyone doing? You good? Life good? Okay. I swear to God, I'm not shaving my head again.
00:04:28.900 - 00:04:35.954, Speaker A: All right. As long as I can have 40 minutes. All right.
00:04:35.954 - 00:04:50.620, Speaker A: So all right, we're done. Right, so we installed our dependencies, and then we're just going to make some of the components. So I'll tell you in a second what these are.
00:04:50.620 - 00:05:10.106, Speaker A: So generally speaking, an Op stack system or just a client for this system, is broken up into two key components. Just like in Ethereum, you have a consensus client and an execution client. We essentially have the same split.
00:05:10.106 - 00:05:23.214, Speaker A: There's this thing called the Op node. The Op node that serves as the consensus client. And then there's another component that serves as the execution client.
00:05:23.214 - 00:05:39.946, Speaker A: And now there's actually multiple implementations of this. So we have two implementations of the consensus client that's Op node and Magi, which is the version that a 16 Z built. And then we also have two execution client options.
00:05:39.946 - 00:06:01.630, Speaker A: There's Op Geth and Op Aragon, which are just slight modifications to Geth and aragon that make them work as our execution client. So you can mix and match between these things. You can run Op node with Op Geth or you can run Magi with Op aragon or whatever combination you want, just like you can in Ethereum.
00:06:01.630 - 00:06:16.914, Speaker A: Right now, we're going to use op node and Op geth. That's just sort of the reference implementations that Op Labs has been working on. And so every single client in the network runs these two services for itself, right? Just like in Ethereum, you run a consensus client and an execution client.
00:06:16.914 - 00:06:32.586, Speaker A: We're doing the same thing. And then there's these other things called the batcher and the proposer. So the batcher is a process that talks to the sequencer node and it gets all the data from the sequencer and it puts it on l One.
00:06:32.586 - 00:06:54.954, Speaker A: In this case, we're going to be using Gurley. So it puts it on Gurley. And the proposer is something that exists for now but won't exist relatively soon, which is something that sort of proposes what the output of the l Two is to the main bridge, which allows users to then withdraw funds from the main bridge for testing.
00:06:54.954 - 00:07:10.210, Speaker A: You technically don't need to run the proposer, but why not? But you do need to run the batcher, and you need to run one Op node. Op guest pair together, which forms one node. We're only going to be running one node right now, which is the sequencer node.
00:07:10.210 - 00:07:20.380, Speaker A: But you can also just attach more nodes. Then they'll communicate over, like a peer to peer network and share blocks with one another. And that all just happens kind of automatically, which is nice.
00:07:20.380 - 00:07:39.806, Speaker A: So the only other thing is that we've separated Geth out into its own repo. We usually do everything in the monorepo, but Geth specifically, we like to have a very minimal diff on top of Geth. That's what keeps things simple.
00:07:39.806 - 00:07:52.946, Speaker A: So there's actually a website that you can go to, which is Opgeth optimism. IO. There we go.
00:07:52.946 - 00:08:04.710, Speaker A: We go to Op. Geth, optimism IO. You can see a detailed description of every single line of code that we have changed inside of Geth and what it does.
00:08:04.710 - 00:08:28.190, Speaker A: So if you're curious as to what the diff actually achieved, go to Op, Geth, optimism IO. You can see every single line of code with a detailed description of why that line was changed. Okay, so we've separated out geths and we have to make Geth same way you make Geth normally.
00:08:28.190 - 00:08:43.148, Speaker A: It just builds, so that takes a second. And we'll also need access to a Girly node. So we're going to be attaching this to Girly.
00:08:43.148 - 00:08:53.540, Speaker A: But you can attach this to any chain as an L one. Any EVM chain could put it on polygon, put it on whatever you want. It doesn't really matter as long as it's an EVM blockchain.
00:08:53.540 - 00:09:00.244, Speaker A: You can use it as the L one. Gurley is just easy. And if you need Girly ETH, just ask me.
00:09:00.244 - 00:09:09.812, Speaker A: I have an enormous amount of Girly ETH to give away, so just let me know. All right, cool. So we've built most of the software.
00:09:09.812 - 00:09:22.990, Speaker A: Now it's just sort of about configuring it and running it, which is really simple. For the sake of this demo, we're going to generate some keys. There we go.
00:09:22.990 - 00:09:44.680, Speaker A: So if you go to the contracts Bedrock repo bedrock is our upcoming upgrade that runs all this stuff. We have this command, this re key command. The re key command just generates random private keys for you.
00:09:44.680 - 00:10:00.362, Speaker A: So I'm just going to take a copy that you don't need to use this. You can use your own keys, your own accounts. This is just a useful thing to quickly generate private keys and accounts that you can use and you need to fund them.
00:10:00.362 - 00:10:13.040, Speaker A: So these numbers here are pretty high. I don't think you actually need this much ETH in them right now. But Girly sometimes gets very expensive at random points.
00:10:13.040 - 00:10:28.514, Speaker A: Like last week when it was like 10,000 Glay, which is ridiculous. I recommend probably doing this on Sepolio like some other network other than Gurley, just because Gurley is kind of a mess sometimes. But yeah.
00:10:28.514 - 00:10:39.426, Speaker A: So you need to fund all of these wallets with a certain amount of ETH. There's an admin key that deploys all the smart contracts. There's the proposer key, which is going to propose those outputs.
00:10:39.426 - 00:10:51.740, Speaker A: And then there's the batcher key, which is going to post that L Two transaction data to L One. Each one of them needs a slightly different amount of ETH. These are suggested numbers, but you can do more or less or whatever.
00:10:51.740 - 00:11:08.820, Speaker A: So we've just generated keys. The next thing to do is to configure the network. So to configure the network, we've kind of done a lot of the work for you as part of this demo.
00:11:08.820 - 00:11:28.566, Speaker A: Where are we? So packages, contracts, bedrock. And so if you go to the deploy config folder, inside of contracts bedrock, there's a Getting Started network. And the Getting Started network has what you need to fill in all you need to fill.
00:11:28.566 - 00:11:47.558, Speaker A: Well, you need to fill in a couple of things. And most of this is pretty simple. You fill in the admin, what says admin with the admin key that you got whatever says proposer with the proposer key, whatever says batcher.
00:11:47.558 - 00:11:52.570, Speaker A: With the batcher key, it's just fine and replace. So that part is pretty simple. We'll do that in a minute.
00:11:52.570 - 00:12:12.710, Speaker A: The other thing is that every bedrock chain needs to sort of tie itself to an L One block that it sort of starts from. That's where the chain starts looking at data after that L One block. So we're just going to go ahead and find that block.
00:12:12.710 - 00:12:27.660, Speaker A: I'm realizing now that I need to get myself an alchemy endpoint. All right, give me a second here. Okay, so girly, right? Great.
00:12:27.660 - 00:12:45.714, Speaker A: Copy that. Okay, so it's usually recommended to grab a finalized block. Just why not? And then we're just going to grab some of the fields.
00:12:45.714 - 00:12:52.780, Speaker A: So we want the timestamp, the hash, and the block number. Pretty simple. So we pull that out.
00:12:52.780 - 00:13:10.282, Speaker A: So we're just going to use block 8,988,274 as our starting block for the network. This is the hash of that block and this is the timestamp of that block. So we're going to take that hash and we're going to stick it into this thing that says L One starting block tag.
00:13:10.282 - 00:13:22.770, Speaker A: And we're going to take that timestamp and we're going to stick it into the thing that says L two output Oracle starting timestamp. And then the rest of this is pretty simple. We just kind of go back and forth, finding and replacing.
00:13:22.770 - 00:13:33.160, Speaker A: So we got admin here. We're going to find and replace that with the admin address. Don't worry about it.
00:13:33.160 - 00:13:49.594, Speaker A: We've got sequencer. Going to replace that with the sequencer address, proposer and batcher. We could probably automate this more, but again, like in practice, you aren't really going to be doing it like this.
00:13:49.594 - 00:14:00.080, Speaker A: You'll be using more tooling to automate all this stuff. This just gets you a sense of where the config actually comes from. So that's the first step.
00:14:00.080 - 00:14:11.220, Speaker A: Now we have a configured network. We basically just need to deploy our contracts. So that's simple enough.
00:14:11.220 - 00:14:22.870, Speaker A: We're going to create a env file, or you can copy this env file, I guess, whatever. I don't really care about any of that. We need two things.
00:14:22.870 - 00:14:37.594, Speaker A: We need the RPC that we got from Alchemy, that the L one RPC. And we need the private key of the account that's going to deploy everything. In this case, the private key of the account that's going to deploy everything is the admin key.
00:14:37.594 - 00:14:52.320, Speaker A: So that's simple enough. The last thing is just you need to send money to the admin key, otherwise you can't do anything. So I'm going to have my whale account send some money to the admin key.
00:14:52.320 - 00:15:03.120, Speaker A: Come on. What's it doing? I blame the internet. Okay.
00:15:03.120 - 00:15:11.688, Speaker A: All right. ETH on op girly. Wait, that's op girly.
00:15:11.688 - 00:15:21.516, Speaker A: I don't want op girly. I want ETH on girly. What is it doing? Do I not have chains? Girly.
00:15:21.516 - 00:15:23.810, Speaker A: There you go. That's why. Okay.
00:15:23.810 - 00:15:36.510, Speaker A: Oh, this is frame. This is a very good wallet, if you're interested. Worth trying, in my opinion.
00:15:36.510 - 00:15:49.730, Speaker A: All right, we're going to send girly ETH. I'm going to send five girly ETH to Oops to my admin wallet here if I can find it. Jesus.
00:15:49.730 - 00:16:01.082, Speaker A: Must. What is it doing? All right. Yeah, great.
00:16:01.082 - 00:16:05.250, Speaker A: All right. Sign send. Fantastic.
00:16:05.250 - 00:16:10.222, Speaker A: Done. Okay, so my admin key has ETH now. Pretty simple.
00:16:10.222 - 00:16:18.034, Speaker A: Now I just deploy a bunch of contracts. There you go. All right, so hopefully that was enough.
00:16:18.034 - 00:16:44.826, Speaker A: E and I can just start deploying stuff maybe. Okay, so this is the part that kind of takes a while, which is really annoying. We basically just sit here and deploy a bunch of smart contracts.
00:16:44.826 - 00:16:50.750, Speaker A: So that's just going to start happening. In the meantime, I can kind of talk about what we're going to do next. It's pretty straightforward.
00:16:50.750 - 00:17:19.286, Speaker A: Where are we? Yeah, once all these smart contracts get deployed, we basically just have to configure the op node and configure op Geth. The op node is going to generate a genesis JSON file, which is the same, or it has a command to generate a genesis JSON file. That's the same type of genesis JSON file you would expect for any network.
00:17:19.286 - 00:17:34.482, Speaker A: Same thing. And a roll up JSON file which just has some config values in it. And then we need a JWT token for the communication between the op node and op guest.
00:17:34.482 - 00:17:40.510, Speaker A: That's exactly how it works in Ethereum as well. It's not different. So same concept.
00:17:40.510 - 00:17:59.250, Speaker A: And then we're going to initialize op Geth. We're basically just going to insert the sequencer key into Geth, which we can actually do now while this is happening, to save some time here. So we can make a directory.
00:17:59.250 - 00:18:08.582, Speaker A: We're just going to call it datadir. There we go. We're going to create a password.
00:18:08.582 - 00:18:28.480, Speaker A: In this case, the password is password, so probably use a real password in production, but whatever. And then we're going to take the sequencer key and we're going to dump it into a file. Easy.
00:18:28.480 - 00:18:36.938, Speaker A: And now we're just going to import that sequencer key. So should just be able to import it. Boom.
00:18:36.938 - 00:18:53.400, Speaker A: So now we've imported the sequencer key. You can see this address here is the same address that's been imported. And then once we're done with the other thing, we're going to initialize GIF with the Genesis JSON, which is how this is exactly how you would initialize geth in Ethereum as well.
00:18:53.400 - 00:19:04.058, Speaker A: So we're almost done here. Once all the smart contracts get deployed, this is actually really fast. Gurley is usually not this fast, so I may actually make it today.
00:19:04.058 - 00:19:19.250, Speaker A: We'll see. Well, in the meantime, while this is happening, we can also set up the command for initializing the op node. We won't run it yet, but we'll get there.
00:19:19.250 - 00:19:27.670, Speaker A: So, you know what? I'm just going to copy this. You can just copy paste this. I don't know why I'm pasting it like that.
00:19:27.670 - 00:19:48.698, Speaker A: Oh, and I forgot my where's my Alchemy scene? All right, whatever. Copying it, we're just going to paste that in there too. All right, so once this is done deploying, I'll just run this command.
00:19:48.698 - 00:20:03.360, Speaker A: We're almost there. This is the slow part. So close.
00:20:03.360 - 00:20:11.680, Speaker A: We'll be there in a minute. I don't know. Any questions in the meantime? Probably got like five minutes.
00:20:11.680 - 00:20:29.746, Speaker A: It's pretty simple. You just follow the instructions and then at the end of this, you have a roll up. The fun stuff, though, is to go in and actually hack on it, which you can do inside the op stack.
00:20:29.746 - 00:20:46.266, Speaker A: Docs, there's a lot of explainers for what we call op stack hacks, which are things you can do to mess with the op stack. So you can do things like add a pre compile. You can manipulate the derivation function.
00:20:46.266 - 00:21:15.378, Speaker A: So the derivation function is the piece of code that looks at the transactions on L One and figures out what the L Two blockchain should look like as a result. But you could do stuff like one of the examples that we give is have something that automatically tracks the burn on L One. So every single block track how much gas is being burned in that block and automatically update a smart contract on L Two to reflect that new thing.
00:21:15.378 - 00:21:28.274, Speaker A: So essentially the way you can think of all these chains is that they're really just indexers on the L One state. And we made it really easy to modify the indexer. So you can index all sorts of stuff.
00:21:28.274 - 00:21:55.680, Speaker A: You could create like, a blockchain that only exists to index uniswap trades, or you could have like, an Oracle on layer two that automatically pulls in chain link updates from L one and makes them immediately available on L two. So there's a lot of different things you can do, but in order to do that, you just need to modify the derivation function. And there's a tutorial in here about how you can modify that derivation function.
00:21:55.680 - 00:22:07.846, Speaker A: Indexed. Yeah. So the question was, if you wanted to index, like, every block and every you want to index every transaction as well.
00:22:07.846 - 00:22:22.540, Speaker A: You can index literally whatever you want. Text. Yeah, you could build like, a whole block explorer that's actually a roll up.
00:22:22.540 - 00:22:47.380, Speaker A: Like a roll up that indexes a whole bunch of stuff on L one and then pipes that data into smart contracts on this layer two. And then the cool thing is that the whole thing is you can fault proof it, right? Like, you could run these optimistic fault proof. So then not only can you have a roll up that's actually an indexer, you can also have smart contracts on layer one that read the data from the roll up and act on that data.
00:22:47.380 - 00:23:18.218, Speaker A: So it depends on how fast you want your proving time to be. If you're okay with the security properties, you can make it like 30 minutes or an hour or something like that, and eventually you'll have ZK proofs to be able to do the same thing, to be able to prove it pretty much immediately. So the future of this is that you have these very detailed indexers that then report data back to layer one.
00:23:18.218 - 00:23:45.954, Speaker A: So the layer one smart contracts can just access all of the information of every other smart contract in an extremely efficient way. Okay, great. Wait, what is this phase two? Did they change? So here's the other thing about this, is that we're also modifying this at the same time.
00:23:45.954 - 00:23:55.014, Speaker A: I'm not surprised if they did not update my no, wait, phase two. Wait, phase two. Oh, okay, wait.
00:23:55.014 - 00:23:57.014, Speaker A: I think this is good. I think we're good. We're done.
00:23:57.014 - 00:24:01.260, Speaker A: We're done. Okay, great. So I should just be able to configure this now.
00:24:01.260 - 00:24:09.622, Speaker A: Boom. All right, so I have my Genesis JSON file that I just generated. I'm going to generate a JSON web token as well.
00:24:09.622 - 00:24:20.030, Speaker A: So I've done that. I'm going to copy that. So I'm going to copy Genesis JSON into Opgeth.
00:24:20.030 - 00:24:31.854, Speaker A: I'm going to copy the JWT into Opgeth. All right, we might not get around to running the batcher, but you'll get there. Okay, now we just initialize geth.
00:24:31.854 - 00:24:34.938, Speaker A: That's easy enough. I just run that initialization thing. Boom.
00:24:34.938 - 00:24:46.674, Speaker A: We're done. Initialized. Okay, so the next thing is to run Op geth.
00:24:46.674 - 00:25:05.046, Speaker A: I just need to export a couple of things into export whatever. Come on. All right, we have to automate this a little more.
00:25:05.046 - 00:25:32.892, Speaker A: The thing is, we didn't want to automate the tutorial too much because then people would be really confused about what was happening under the hood. But I don't know, that's the wrong thing, too. Thus chad all right, just follow this.
00:25:32.892 - 00:26:00.400, Speaker A: Export all the things that you need to export, and the address of the L two output Oracle is the last thing that we need. I don't know why we need this. Deployments getting started.
00:26:00.400 - 00:26:09.780, Speaker A: L two output Oracle proxy. Okay. All right, so hopefully this just works now.
00:26:09.780 - 00:26:29.876, Speaker A: All right, so Geth is running. That's simple. And now we just need to run the op node, hopefully.
00:26:29.876 - 00:26:58.890, Speaker A: And of course that doesn't work because it's in a different terminal. Okay. All right, let me minimize this.
00:26:58.890 - 00:27:12.092, Speaker A: So we have the two things running. Yeah, so pretty simple at this point. We have op Geth running.
00:27:12.092 - 00:27:23.632, Speaker A: We have the op node running. It's essentially iterating over the chain and figuring out when it's just loading bits of the chain. Right now, it has to catch up.
00:27:23.632 - 00:27:40.040, Speaker A: So we're at three, two, seven I don't know what the current girly, what's the current block? Current block is three, nine, seven. So if you give it a second, in a few seconds, it's going to start producing blocks. At this point, it's going to start producing empty blocks.
00:27:40.040 - 00:27:52.904, Speaker A: And I've been told that we have to kill it there. But if you keep following this at that point, we have a sequencer running at this point. So then we just start submitting it.
00:27:52.904 - 00:28:04.124, Speaker A: You just have to run this batcher program and that's it. You just make sure that the batcher has some ETH, start running, and you have a roll up, and then you can do whatever you want. So start messing with it.
00:28:04.124 - 00:28:08.344, Speaker A: There you go. It's producing empty blocks. Start sending it transactions.
00:28:08.344 - 00:28:22.480, Speaker A: It'll produce non empty blocks. All right, I'm getting kicked out, but if you want to keep chatting later, go to Stack, opt IO, have fun, mess around, do crazy stuff, and I'll be here. All right, bye.
