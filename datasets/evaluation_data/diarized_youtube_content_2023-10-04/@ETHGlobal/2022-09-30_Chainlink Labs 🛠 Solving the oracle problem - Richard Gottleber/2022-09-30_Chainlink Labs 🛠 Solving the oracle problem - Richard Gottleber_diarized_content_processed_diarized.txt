00:00:06.570 - 00:00:08.586, Speaker A: Hi, I'm Richard, one of the developer.
00:00:08.618 - 00:00:17.930, Speaker B: Advocates at Chainlink Labs. And today we're going to take a look at what is chainlink and what are a few of the products that Chainlink offers.
00:00:18.090 - 00:00:23.082, Speaker A: So let's dive in. All right, so first question what is chainlink?
00:00:23.226 - 00:00:39.414, Speaker B: In order to understand that, we need to make sure that we have a base understanding of a couple of concepts, the first of which is what exactly are smart contracts and what's the purpose of them? A basic definition is that a smart contract is a digital contract.
00:00:39.542 - 00:00:41.290, Speaker A: It's stored on a blockchain.
00:00:42.270 - 00:01:04.466, Speaker B: It automatically executes when certain parameters are met. Now, why are they important? Well, they're important for two main reasons, in my opinion. First, they're transparent. That means anyone can see what the terms of the contract are, and they enable you to know exactly what's going to happen when those conditions are met.
00:01:04.648 - 00:01:08.398, Speaker A: Additionally, they're distributed. Combined with transparency.
00:01:08.574 - 00:01:10.802, Speaker B: The fact that they're distributed means that.
00:01:10.856 - 00:01:14.580, Speaker A: You remove trust from the situation.
00:01:15.910 - 00:01:31.894, Speaker B: In a traditional world, contracts rely on a third party, and they rely on trust that the parties involved in the contract are going to do what they say and honor the terms of the contract. Even when legal systems are fairly robust, this isn't a guarantee.
00:01:32.022 - 00:01:35.242, Speaker A: It's a almost always, most likely things.
00:01:35.296 - 00:01:58.046, Speaker B: Will work out type of promise. And that is something that smart contracts can remove. Smart contracts replace that third party, they replace the trust. No longer do you have a trust based system of agreements. Now you have a system of agreements which allows users to rely on cryptographic truth. So we have a truth based agreement.
00:01:58.078 - 00:02:00.514, Speaker A: System instead of a trust based one.
00:02:00.712 - 00:02:09.974, Speaker B: So that's why smart contracts are so important and so powerful. That transparency, the removal of trust being necessary for them to function, and the.
00:02:10.012 - 00:02:14.886, Speaker A: Distributed nature of them. Now, in order for smart contracts to.
00:02:14.908 - 00:02:29.226, Speaker B: Work, they live on a blockchain. And blockchains rely on the different nodes within the chain, reaching something called consensus. What about consensus? How do we reach an agreement within.
00:02:29.408 - 00:02:33.550, Speaker A: A network of nodes for certain values?
00:02:34.050 - 00:02:36.560, Speaker B: Let's take a look at a simple example.
00:02:37.250 - 00:02:43.534, Speaker A: What's one plus one? We can all agree that one plus one is two. It doesn't matter when I ask you.
00:02:43.572 - 00:02:50.802, Speaker B: That question, it doesn't matter where you are when I ask you that question. It doesn't matter about any other input into the system.
00:02:50.936 - 00:02:52.690, Speaker A: One plus one is two.
00:02:52.840 - 00:03:01.270, Speaker B: This is a deterministic value, and blockchains work exceptionally well. In fact, they rely on deterministic values to reach consensus.
00:03:01.610 - 00:03:05.686, Speaker A: If you think about us as a network, when you ask me what one.
00:03:05.708 - 00:03:11.130, Speaker B: Plus one is, I'll tell you two. And when I ask you the same question, you'll give me that same answer.
00:03:11.280 - 00:03:12.742, Speaker A: That means we can reach consensus.
00:03:12.806 - 00:03:15.690, Speaker B: We could come to an agreement on what the answer is.
00:03:15.840 - 00:03:34.354, Speaker A: We all agree that it's two. Now, what if I were to ask you a little bit different style of question. What's the current temperature? It depends. I mean, it depends on where you are when I ask you this question.
00:03:34.552 - 00:03:58.862, Speaker B: There are other factors that determine the answer to that question. That's a nondeterministic value anytime that you can ask a question. And the answer could be, it depends, you know, that it's a nondeterministic value. And the real world is full of nondeterministic values. In fact, pretty much everything in the real world when it comes to data is nondeterministic.
00:03:58.946 - 00:04:01.020, Speaker A: It's going to depend a lot.
00:04:01.390 - 00:04:04.262, Speaker B: This brings me back to smart contracts.
00:04:04.406 - 00:04:09.958, Speaker A: They have phenomenal power, much like genie, phenomenal cosmic power.
00:04:10.144 - 00:04:13.578, Speaker B: But deterministic values mean much like genie.
00:04:13.754 - 00:04:15.790, Speaker A: Itty bitty living space, right?
00:04:15.860 - 00:04:45.830, Speaker B: They're confined to blockchains. Traditionally, smart contracts can't reach out to the outside world. That's referred to as the Oracle problem. Now, this isn't a limitation that we can't overcome, right? We can do something about that. We can help our smart contracts interact with the real world. And Oracles are a solution to the Oracle problem. And that's exactly what Chainlink is.
00:04:45.830 - 00:04:50.570, Speaker B: It's an Oracle network. In fact, it's a distributed Oracle network.
00:04:51.390 - 00:04:52.918, Speaker A: So, just to make sure that we're.
00:04:52.934 - 00:05:05.710, Speaker B: All clear, an Oracle is a device that interacts with off chain data to provide that data to smart contracts. Essentially, this unlocks the full potential of smart contracts.
00:05:06.450 - 00:05:10.330, Speaker A: Now, you may be wondering, could I set up my own Oracle?
00:05:10.490 - 00:05:14.570, Speaker B: The answer to that question is yes, you could set up your own Oracle.
00:05:14.650 - 00:05:15.538, Speaker A: And it would work.
00:05:15.624 - 00:05:28.226, Speaker B: You could bring off chain data on chain and you could own that. But I see that as a bit of a limitation because if you notice, we have a decentralized network that is the blockchain.
00:05:28.338 - 00:05:35.686, Speaker A: And now you're effectively centralizing it with a centralized node for your Oracle. If something were to happen to that.
00:05:35.708 - 00:05:37.206, Speaker B: Node, or if that node were to.
00:05:37.228 - 00:05:43.210, Speaker A: Be a bad actor, well, you're kind of in trouble because you have centralized that.
00:05:43.280 - 00:05:51.562, Speaker B: And that again, is what Chainlink offers. It offers a decentralized Oracle network. So the Oracle network that Chainlink offers.
00:05:51.706 - 00:05:55.598, Speaker A: Is much like the network of a.
00:05:55.604 - 00:05:58.270, Speaker B: Blockchain where there are multiple nodes participating.
00:05:58.690 - 00:06:03.610, Speaker A: But they are participating in a decentralized fashion.
00:06:03.770 - 00:06:16.478, Speaker B: So there's three main things that we're going to talk about today when it comes to what chainlink offers. The first is data feeds. Next is VRF or Verifiable, randomness functions. And the third is keepers.
00:06:16.654 - 00:06:17.926, Speaker A: So let's take a look at each.
00:06:17.948 - 00:06:19.494, Speaker B: Of these and walk through a quick.
00:06:19.532 - 00:06:21.400, Speaker A: Demo of how to use them.
00:06:22.010 - 00:06:35.178, Speaker B: We'll start with data feeds. Data feeds, as the name implies, are about bringing data on chain, feeding that data into a blockchain. And what does this data look like? It can be any data.
00:06:35.264 - 00:06:39.286, Speaker A: It could be market data, bank payments, retail payments.
00:06:39.398 - 00:06:43.018, Speaker B: It could be anything that's available via an API.
00:06:43.194 - 00:06:44.814, Speaker A: The most common use case that we.
00:06:44.852 - 00:06:53.310, Speaker B: See are asset pairs. So let's take a look at data chain link and what this looks like in practice.
00:06:54.210 - 00:06:56.706, Speaker A: If you head to Data Chain Link.
00:06:56.808 - 00:07:06.834, Speaker B: You'Ll see various data feeds. I mentioned that these are asset pairs and if you take a look here, the first one you'll see is ETH in terms of USD.
00:07:06.962 - 00:07:08.600, Speaker A: Let's dive into that one.
00:07:10.890 - 00:07:33.418, Speaker B: What we have on this page is the trusted answer that's going to be the aggregated response from various Oracles. On the right side of the screen you can see all of the different Oracles and the price that they're reporting. There's a few things to look at on this screen. The first is that trusted answer that's going to be the aggregate answer based upon all of the different values reported by the Oracles.
00:07:33.594 - 00:07:36.062, Speaker A: This is how you can overcome the.
00:07:36.116 - 00:07:51.122, Speaker B: Issue of bringing non deterministic value into a deterministic landscape like the blockchain. Each node reports the price that it thinks is the proper answer to the question of what is the value of ETH in terms of USD for this.
00:07:51.176 - 00:07:52.210, Speaker A: Data feed.
00:07:54.310 - 00:07:55.846, Speaker B: We take those prices and.
00:07:55.868 - 00:07:58.566, Speaker A: We use the median value to bring.
00:07:58.668 - 00:08:16.858, Speaker B: The data that is nondeterministic into a deterministic answer. Given various inputs. When taking the median, you now have created a deterministic question. Given a set of inputs, what is the median value? That will always come out with the same answer. So this is how you've taken a nondeterministic value and brought it into the.
00:08:16.864 - 00:08:20.698, Speaker A: Blockchain and made it deterministic. On the left hand side, we can.
00:08:20.704 - 00:08:30.686, Speaker B: See that trusted answer as well as the trigger parameters. Those are going to be what causes this price to update on Chain. So if the price deviates outside of.
00:08:30.708 - 00:08:36.610, Speaker A: The threshold that's set, or if the heartbeat comes up, that will be just a time based trigger.
00:08:37.110 - 00:08:40.994, Speaker B: If we scroll down on this page, we can find more information about this.
00:08:41.032 - 00:08:44.354, Speaker A: Including the history, as well as more.
00:08:44.392 - 00:08:46.918, Speaker B: Information on each Oracle node and the.
00:08:46.924 - 00:08:48.390, Speaker A: Data that it's reporting.
00:08:49.690 - 00:08:52.530, Speaker B: At the bottom, we'll find the users of this data feed.
00:08:52.610 - 00:08:58.540, Speaker A: These are the people who are vested in keeping this data feed accurate and up to date.
00:09:00.590 - 00:09:03.340, Speaker B: Let's head back and talk about the next product.
00:09:07.560 - 00:09:11.956, Speaker A: Verifiable randomness Functions now, you may have.
00:09:11.978 - 00:09:39.148, Speaker B: Gone through a course or learned about how to get a random number on the blockchain using some sort of seed like the block hash. This works to create a fairly random number, but there's a small issue with that and the issue is that those values can be known before they're mined onto the block. What that means is that a malicious actor who is adding blocks to a.
00:09:39.154 - 00:09:45.964, Speaker A: Blockchain can know the outcome of that random number ahead of time. And based on that, they can decide.
00:09:46.012 - 00:09:47.808, Speaker B: Whether or not to add that specific.
00:09:47.894 - 00:09:50.396, Speaker A: Random number to the block that they're mining.
00:09:50.588 - 00:10:13.972, Speaker B: Essentially, I like to think about this as if you are rolling a dice and you can't necessarily determine what value is going to be rolled when you rolled it. It's still random, but a malicious actor could essentially reroll that dice until they get the outcome that they would like. That's an issue, especially when you need random numbers that are verifiably random.
00:10:14.116 - 00:10:16.076, Speaker A: That's where chainlink comes in.
00:10:16.258 - 00:11:00.646, Speaker B: Chainlink will provide a verifiably random number from the Oracle network to a smart contract, and this prevents the miners from being able to act in that malicious fashion. Additionally, I mentioned that it was verifiably random. There's a cryptographic proof included with the random number that will demonstrate how that number was generated. Next, let's take a look at Keepers. Chainlink keepers are a way to automate smart contracts. We talked earlier about how smart contracts are like genie from Aladdin. And one other factor about smart contracts is they are exceptionally lazy.
00:11:00.646 - 00:11:08.634, Speaker B: They're not going to do anything without an input. Something needs to call a function within a smart contract in order for it to execute.
00:11:08.762 - 00:11:13.646, Speaker A: That's where Keepers comes in. Keepers will allow you to take a.
00:11:13.668 - 00:11:16.782, Speaker B: Smart contract and based upon either time.
00:11:16.836 - 00:11:21.314, Speaker A: Based or a custom function, execute the.
00:11:21.352 - 00:11:23.330, Speaker B: Code within that smart contract.
00:11:23.670 - 00:11:27.330, Speaker A: Now again, you could create your own.
00:11:27.480 - 00:12:00.590, Speaker B: Node that would call smart contracts, much in the same way as you could use your own node to get a piece of information off Chain on Chain. But the keeper's network again brings that decentralized network where you have again the benefit of decentralization, and you can ensure that your contract will be executed in the same fashion. Now, let's dive into some code and take a look at each of these products a little bit more closely and see how you'd actually use them in a smart contract.
00:12:01.090 - 00:12:08.446, Speaker A: So the first thing to know is that when it comes to examples and code with Chainlink, you're going to want.
00:12:08.468 - 00:12:18.830, Speaker B: To go to Docs Chain Link. This is the best place to start when it comes to finding up to date information as well as examples. We'll start with data feeds.
00:12:18.990 - 00:12:20.178, Speaker A: If we head down here, we can.
00:12:20.184 - 00:12:40.700, Speaker B: See that the supported blockchains is broken up into two different areas. The first being EVM chains, the second being Solana. Solana is separate because it's kind of a different beast. If you've ever used any of the programming tools around the Solana ecosystem, you'll know they are much different than Solidity. So that's why it's broken off into its own space.
00:12:41.390 - 00:12:43.290, Speaker A: Let's start with data feeds.
00:12:43.630 - 00:12:50.910, Speaker B: If we head to data feeds, we can learn about data feeds and we can learn about using data feeds. That's where we'll head using data feeds.
00:12:51.250 - 00:12:53.166, Speaker A: Right here on this page you can.
00:12:53.188 - 00:13:17.430, Speaker B: See an example contract. And this contract will allow you to get the price feed for ETH in terms of USD. Let's go ahead and open this in Remix. Now, if you're not familiar, Remix is a web based IDE for Solidity. This means that we can both deploy and interact with contracts on Blockchains. It's pretty great. And you can do it all from your browser.
00:13:17.430 - 00:13:39.440, Speaker B: Let's take a look at this contract and see what exactly we're doing. The first thing you'll notice is that we're declaring the Solidity version. Then we're importing a contract called Aggregator v Three interface. That's going to give us the interface to the price feed aggregator contract. We have our contract called Price Consumer v three.
00:13:40.530 - 00:13:41.422, Speaker A: On line eight.
00:13:41.476 - 00:14:05.366, Speaker B: You can see that we are setting up a price feed that is one of those aggregator interfaces. There's some notes talking about what network we're going to be using, as well as what the aggregator is and an address, something to keep in mind. Each asset pair aggregator has its own address. You can find those in the documentation. I'll show you that in just a moment. We have our constructor which goes ahead.
00:14:05.388 - 00:14:07.426, Speaker A: And sets up the price feed.
00:14:07.538 - 00:14:48.674, Speaker B: And keep in mind, constructors are only run when a contract is deployed. They kind of set up things that need to be configured when that contract is deployed. And finally we have our function get latest price. It's going to return one value, the price. Now this looks a little strange. We have all of these commented out values and the reason for that is, within Solidity, you need to account for every single value that a function returns. This latest round data function will actually return a round ID the price when the round started a timestamp and what round it was answered in.
00:14:48.674 - 00:14:59.382, Speaker B: But we're only interested in the price. So you can either comment them out or just delete them completely. It looks a little strange because essentially the signature for this function would be.
00:14:59.436 - 00:15:02.546, Speaker A: Comma int price comma comma comma.
00:15:02.738 - 00:15:11.340, Speaker B: Again, those are commented out there just for readability and understandability of this example contract. Finally, we take that price and we return it.
00:15:11.870 - 00:15:12.554, Speaker A: That's it.
00:15:12.592 - 00:15:18.670, Speaker B: It's a pretty straightforward and simple contract, but let's take a look at how to deploy it. If we head on over here to.
00:15:18.740 - 00:15:22.238, Speaker A: The Deploy and Run transactions, we'll need.
00:15:22.244 - 00:15:29.966, Speaker B: To ensure that our environment is our injected provider. That will take the wallet from your browser and inject it into remix so.
00:15:29.988 - 00:15:34.338, Speaker A: That you can interact with the blockchain. In this example, I'm using Brave and.
00:15:34.344 - 00:15:51.510, Speaker B: I'm also using the Brave wallet. But it functions basically the same as MetaMask. We'll also need to select the correct contract. Anytime you have a contract that imports other contracts, they will be available here to be deployed. So just keep that in mind and make sure that you're selecting the correct contract.
00:15:51.850 - 00:15:58.794, Speaker A: And finally we can click Deploy. We'll need to approve the transaction and.
00:15:58.832 - 00:16:02.506, Speaker B: Wait for it to actually be deployed. We should see a green checkmark down.
00:16:02.528 - 00:16:05.770, Speaker A: At the bottom of our screen once it is deployed.
00:16:07.790 - 00:16:28.786, Speaker B: All right, we've got that green checkmark and we can see on the left hand side we have our deployed contract. If we open that up, we can see all of the functions that were deployed within our contract. Now we only have one. It's get latest price. Let's see what it returns. When we click it, we can see that we get this price. And this price seems like it may be a bit out of line with.
00:16:28.808 - 00:16:33.906, Speaker A: The current price of ETH. But there's something to remember when it.
00:16:33.928 - 00:17:10.734, Speaker B: Comes to pricing data. Solidity doesn't have the concept of decimals. That means that we need to somehow account for decimals. And the way that we do this is by multiplying a result by ten to the 8th power in this case. So we'll need to insert our decimal to understand what this price actually is. If we were to go 1234-5678 places and insert a decimal point there, we would see that the price returned is actually 1917. So just like that, we have gotten a price data from an off chain resource on chain.
00:17:10.862 - 00:17:11.490, Speaker A: That's awesome.
00:17:11.560 - 00:17:22.486, Speaker B: And I think it was pretty simple and pretty quick. Next we're going to take a look at VRF or Verifiable randomness functions. Let's go ahead and take a look at that.
00:17:22.508 - 00:17:23.080, Speaker A: Now.
00:17:24.970 - 00:17:42.106, Speaker B: Again we'll start at the documentation page. So docs chain link. If we scroll down we'll go to randomness or VRF. Now, here again we can learn about how to use randomness how chainlink VRF works. But I'm jumping straight into get a.
00:17:42.128 - 00:17:45.562, Speaker A: Random number for this one.
00:17:45.616 - 00:18:05.874, Speaker B: We're going to need another asset. Not only will we need testnet ETH, but we'll also need testnet link tokens. This will allow us to create a subscription that we can fund in order to get our random values. So if we follow the instructions here, we can open our wallet and make sure that we are on the Go.
00:18:05.912 - 00:18:11.394, Speaker A: Early test Network I am. We can then go to the Go.
00:18:11.432 - 00:18:13.990, Speaker B: Early Faucet and get some testnet link.
00:18:14.060 - 00:18:23.606, Speaker A: Or ETH if we need them. And then we can go to the subscription manager. Now, subscription essentially the way I like.
00:18:23.628 - 00:18:29.500, Speaker B: To think about it is it's a bucket of link that we can allow other contracts to use.
00:18:30.110 - 00:18:32.762, Speaker A: So we'll create a subscription, it will.
00:18:32.816 - 00:18:37.726, Speaker B: Auto fill our address if we've connected our wallet. You may have been prompted to connect your wallet when you came to this.
00:18:37.748 - 00:18:39.294, Speaker A: Page the first time.
00:18:39.492 - 00:18:41.646, Speaker B: We'll create our subscription and we'll need.
00:18:41.668 - 00:18:43.790, Speaker A: To approve that subscription.
00:18:46.370 - 00:18:55.666, Speaker B: Once that's approved and verified, then we can go and fund our subscription. And while we're waiting for this to.
00:18:55.688 - 00:19:00.994, Speaker A: Approve, something to keep in mind is the way that subscriptions work is we.
00:19:01.032 - 00:19:48.930, Speaker B: Need to create a subscription, we'll get a subscription ID, then we'll create our contract to interact with that subscription and when we deploy it, we'll let our contract know about the subscription ID. Once we have deployed our contract, we'll come back to our subscription and let our subscription know about the address of the contract we've created. Essentially we need to let the contract know about the subscription and let the subscription know about the contract. All right, so we've got our subscription created and now we can add funds to it. I'll go ahead and just add five link. Again, we'll need to approve this transaction as well. While we wait for this to happen, let's head back to the documentation and take a look at what we need to do next.
00:19:48.930 - 00:20:06.854, Speaker B: We've gone ahead and created our subscription. We've added funds. After we add funds, we'll need to add that consumer. That's going to be the address of the contract that we deploy. But we haven't deployed a contract yet. Let's scroll down and see if we can find an example. Create and deploy a VRF v two compatible contract.
00:20:06.854 - 00:20:33.890, Speaker B: Fantastic. We'll go ahead and open this contract in remix and take a look at what it does. So again, kind of similar to the other contract. We're declaring the version of solidity to use and we're importing a couple of contracts from chainlink. The first is a coordinator that will allow us to request that randomness value. And then we have a consumer that's going to be helping us here in this contract. Go ahead and consume the values returned from the coordinator.
00:20:33.890 - 00:20:47.186, Speaker B: We see that our contract here is using that consumer base V Two. We set up the coordinator interface. We have a few values here. We have a subscription ID that will be that subscription that we just created.
00:20:47.298 - 00:20:49.442, Speaker A: We have the address for the coordinator.
00:20:49.586 - 00:20:59.370, Speaker B: One thing to keep in mind, this address again will change based on the chain that you're on at the end of this demo. I'll go ahead and show you where you can find these different addresses.
00:21:00.670 - 00:21:02.422, Speaker A: We have a key hash.
00:21:02.566 - 00:21:04.538, Speaker B: The key hash is also going to.
00:21:04.544 - 00:21:06.890, Speaker A: Be dependent upon the network you're on.
00:21:07.040 - 00:21:18.286, Speaker B: We have a callback gas limit. This limit is going to be the maximum amount of gas that the fulfill random words will be allowed to use. Depending on what your fulfill random words.
00:21:18.388 - 00:21:21.566, Speaker A: Function does will determine how much you.
00:21:21.588 - 00:21:32.360, Speaker B: Need to set this to. For the example, this will work just fine. We have our request confirmation that's how many blocks need to be confirmed before the request is sent back to us. Number of words.
00:21:32.890 - 00:21:34.550, Speaker A: In this instance it's two.
00:21:34.620 - 00:21:58.006, Speaker B: That means we'll get two random values back. Now, words is a computer science term that is technically correct, but sometimes I think it can be confusing to people when they first come to these contracts. When we're talking about VRF and you see words, just think random values. We have an array to store the random values returned.
00:21:58.118 - 00:22:00.542, Speaker A: We have a value to keep track.
00:22:00.596 - 00:22:11.218, Speaker B: Of our request ID. We don't really do much with it in the example here, but if you had multiple calls for different things being made, you could map a request ID.
00:22:11.304 - 00:22:12.466, Speaker A: To a specific thing.
00:22:12.568 - 00:22:27.506, Speaker B: Take for instance NFTs if you are using random values with an NFT, you may want to map the NFT ID to the request ID to keep track of which request is for which NFT. And then we also have the owner of the contract.
00:22:27.698 - 00:22:30.706, Speaker A: We have our constructor, which remember, constructors.
00:22:30.738 - 00:22:40.426, Speaker B: Are run when the contract is deployed. This constructor takes a value in we'll need to supply our subscription ID. Then we set up the coordinator, the.
00:22:40.448 - 00:22:44.140, Speaker A: Owner, and we also set that subscription ID to what we passed in.
00:22:46.350 - 00:23:03.426, Speaker B: Next, we have our request. Random words function. This function essentially reaches out to that VRF coordinator and says, hey, I'd like some random values, please. And it passes in all the information that we've set above, like the key hash, the subscription ID, the number of confirmations, the gas limit, and the number.
00:23:03.448 - 00:23:05.060, Speaker A: Of words that we're looking for.
00:23:05.510 - 00:23:23.160, Speaker B: Once that coordinator actually generates the random values, it will then come back to our contract and call the Fulfill Random words function. This is where you would use those random values. In this case, we're just storing them. But if you wanted to do something with the random values, you'd put that in here.
00:23:23.610 - 00:23:25.650, Speaker A: And finally, we have a only owner.
00:23:25.730 - 00:23:38.026, Speaker B: Modifier just to make sure that only the owner can request random words. All right, so let's take a look at deploying this again, make sure your environment is correct as well as your contract.
00:23:38.218 - 00:23:40.734, Speaker A: You'll notice this contract, it needs a value.
00:23:40.772 - 00:23:44.702, Speaker B: It needs that subscription ID. So let's head back to the Create.
00:23:44.756 - 00:23:50.686, Speaker A: Subscription and grab that subscription. It's asking us for a consumer address.
00:23:50.868 - 00:23:59.634, Speaker B: That'S going to be the address of the contract that we're about to deploy. But our subscription ID for this example is 101. Now, when you create a subscription, your.
00:23:59.672 - 00:24:03.782, Speaker A: ID will be different. We'll head back here, we'll give 101.
00:24:03.836 - 00:24:06.006, Speaker B: To our deploy, and we'll go ahead.
00:24:06.028 - 00:24:10.950, Speaker A: And run this transaction, confirm it, and we'll wait for that green checkmark.
00:24:11.290 - 00:24:13.990, Speaker B: That means that our contract has been deployed successfully.
00:24:16.490 - 00:24:19.146, Speaker A: While we wait, let's go ahead and.
00:24:19.168 - 00:24:22.970, Speaker B: Take a look at where you would find the different values for the different chains.
00:24:23.550 - 00:24:25.546, Speaker A: I mentioned in Data feeds that we.
00:24:25.568 - 00:24:35.390, Speaker B: Could take a look at that as well. Here under Data feeds in our documentation, you can see contract addresses and all of the different chains on which we have data feeds.
00:24:36.050 - 00:24:38.458, Speaker A: You can see each of the chains.
00:24:38.554 - 00:24:42.980, Speaker B: And the asset pair as well as the address that you would need to provide.
00:24:43.670 - 00:24:47.266, Speaker A: Similarly, under Using Randomness for VRF, we.
00:24:47.288 - 00:25:03.030, Speaker B: Have a contract addresses section as well. This will include the coordinator, the link token, some different hashes depending on which gas lane you would want to use. If you're on a main net, there's multiple gas lanes. Most of the testnets just have one gas lane.
00:25:03.370 - 00:25:04.870, Speaker A: But you can find the different information.
00:25:04.940 - 00:25:08.250, Speaker B: That you need for different networks here in the documentation.
00:25:08.910 - 00:25:15.020, Speaker A: All right, we should be deployed and we are fantastic. So there's a couple of things to look at.
00:25:15.550 - 00:25:22.526, Speaker B: Once we have given our contract address back to our subscription. So we'll copy our contract address. This is the contract that we just.
00:25:22.548 - 00:25:25.950, Speaker A: Deployed and we'll put it here as a consumer.
00:25:27.090 - 00:25:29.658, Speaker B: Again, we'll need to approve this transaction.
00:25:29.834 - 00:25:31.586, Speaker A: And once this is approved, we can.
00:25:31.608 - 00:25:54.338, Speaker B: Go and actually look at our subscription. It'll have some interesting information like the history, what our current link balance is, how much each consumer has used of that balance, and information like that. All right, our consumer has been added. Let's go ahead and view our subscription. So, as I mentioned here, you can see all of the information about the.
00:25:54.364 - 00:25:59.546, Speaker A: Subscription and let's go ahead and call our subscription here.
00:25:59.648 - 00:26:02.380, Speaker B: So we'll request random words.
00:26:03.150 - 00:26:06.486, Speaker A: We'll approve this transaction and once it's.
00:26:06.518 - 00:26:08.606, Speaker B: Been successfully submitted, we should be able.
00:26:08.628 - 00:26:16.926, Speaker A: To see it in our subscription. All right, it's been submitted. Before we head to our subscription, we.
00:26:16.948 - 00:26:17.966, Speaker B: Can take a look and we can.
00:26:17.988 - 00:26:25.246, Speaker A: See our request ID. Cool. Let's head to the subscription and refresh.
00:26:25.278 - 00:26:26.978, Speaker B: This page and take a look at what it says.
00:26:27.064 - 00:26:31.390, Speaker A: Now, so you can see we have this pending transaction.
00:26:31.550 - 00:26:48.198, Speaker B: That means that we are requesting randomness, but it hasn't been fulfilled yet. Remember, we have to wait for those block confirmations. The amount of time that this takes can vary depending on which blockchain you're on, how fast blocks are mined, as well as how many confirmations.
00:26:48.294 - 00:26:51.706, Speaker A: You're requesting confirmations, you can increase the.
00:26:51.728 - 00:26:55.002, Speaker B: Number and end up with a more secure random number.
00:26:55.136 - 00:26:58.414, Speaker A: But the tradeoff is speed, so more.
00:26:58.452 - 00:27:04.926, Speaker B: Secure but slower, or a little bit less secure but faster. Again, it's a verifiably random number, so.
00:27:05.108 - 00:27:12.952, Speaker A: You can trust that it's random when it comes in. All right, so we refresh the page.
00:27:13.006 - 00:27:55.832, Speaker B: And we can see now our history. No longer is it pending, we have our randomness and we can see that we've gotten a response back in our subscription page. We can see how much link it cost, and we can see that our one consumer has spent that same amount. One nice thing about this subscription interface is you could add another contract from the same subscription and have two consumers or more using that one source of link. If we head back to our contract in Remix, we can now take a look at the random words. Something to keep in mind, this is an array, so it's going to have two values because that's how many requested in this contract. Arrays work with a zero based indexing system.
00:27:55.832 - 00:28:05.196, Speaker B: So the first value would be zero, the second would be one. So if we look at the first value, zero, we can get the result of our random number. Again, if we take a look at.
00:28:05.218 - 00:28:10.268, Speaker A: Number one, which would be the second value in the array, we'll see that.
00:28:10.274 - 00:28:14.416, Speaker B: It'S a different random number. So just like that, we've set up.
00:28:14.438 - 00:28:23.728, Speaker A: A subscription and deployed a contract to generate provably random numbers in Solidity. That's awesome.
00:28:23.894 - 00:28:50.280, Speaker B: Let's head to the final thing, chainlink Keepers. All right, as always, we're going to head to Docs Chain Link as our place to start and then we'll head to automate contracts because that's what we want to do. We want to automate a contract with chain Link Keepers. Now when it comes to contract, Automation.
00:28:50.440 - 00:28:52.732, Speaker A: Keepers version one two just came out.
00:28:52.786 - 00:29:06.316, Speaker B: And there are two ways to automate contracts. Now the first is time based. If you're familiar with operating systems that are Linux based, you may be familiar with a command called Cron. Cron is essentially a time based triggering.
00:29:06.348 - 00:29:09.548, Speaker A: System for Linux Unix systems.
00:29:09.724 - 00:29:24.000, Speaker B: Chainlink Keepers uses the same sort of interface to generate the time based automations. If you're not familiar with what a Cron tab looks like or how to set up a Cron tab, I recommend a website, Crontab Guru.
00:29:24.160 - 00:29:26.248, Speaker A: It will take you through everything you.
00:29:26.254 - 00:29:30.776, Speaker B: Need to know and explain what the different values in a Cron tab are. We can take a quick look at it.
00:29:30.798 - 00:29:35.832, Speaker A: Now this website will let you pick.
00:29:35.886 - 00:29:50.156, Speaker B: Random Cron tab values and it puts them in what is essentially plain English at the top. Cron tab is broken down into five different sections. It's going to be the minutes, the hour, the day, the month, and then the day of the week.
00:29:50.258 - 00:29:53.264, Speaker A: The first day being the date of the month.
00:29:53.462 - 00:29:55.596, Speaker B: This is a great resource if you'd.
00:29:55.628 - 00:29:57.776, Speaker A: Like to look into it more, but.
00:29:57.798 - 00:30:16.692, Speaker B: Just something I've found helpful when it comes to ensuring that a Cron tab I create is doing what I think it's doing. But let's head back to the documentation. We're going to take a look at time based automation first and then we will take a look at custom logic and we will do the same thing.
00:30:16.746 - 00:30:17.688, Speaker A: In both of them.
00:30:17.774 - 00:30:25.660, Speaker B: And what we're going to do is we're going to deploy a contract that has one value, a counter, and it will increment that counter on a regular basis.
00:30:26.400 - 00:30:32.910, Speaker A: So the first thing we need to do is we need to head to Keepers Chain Link.
00:30:33.600 - 00:30:50.290, Speaker B: Again, this is going to be similar to VRF in that we'll need to create a new upkeep similar to VRF subscriptions, but slightly different. So let's register a new upkeep. And I mentioned that we're going to do time based. Now we're running into the first problem.
00:30:51.000 - 00:30:52.224, Speaker A: We need a contract.
00:30:52.352 - 00:30:54.340, Speaker B: So let's head to remix.
00:30:56.360 - 00:31:08.660, Speaker A: So it's remix Ethereum.org and we will create our own smart contract. We'll just call it Count Soul.
00:31:09.580 - 00:31:28.780, Speaker B: All right, what do we need for our basic smart contract? The first thing we'll need to do is tell it what version of solidity we need. And we can just kind of follow along with the same values that we've been using. We also need to name our contract.
00:31:28.940 - 00:31:30.400, Speaker A: We'll call it counter.
00:31:31.620 - 00:31:34.912, Speaker B: And within counter we can create a.
00:31:34.966 - 00:31:38.640, Speaker A: Value, a UN called counter.
00:31:39.220 - 00:31:43.430, Speaker B: And we can make this counter be public. That means anyone can access it outside.
00:31:45.320 - 00:31:50.826, Speaker A: We'll need our constructor and we don't.
00:31:50.858 - 00:32:05.220, Speaker B: Actually need to do anything in our constructor here. So we'll just have it other than set counter equal to zero. So when this contract is deployed, we'll set our counter equal to zero and then we can create a function and we can call it Count.
00:32:06.890 - 00:32:08.806, Speaker A: It'll take nothing in and what it.
00:32:08.828 - 00:32:25.546, Speaker B: Will do is it will say counter equals counter plus one. This will allow us to increment our counter. Now this function, we're going to need to call it from outside of our contract, so it will be external. That means that we can call it.
00:32:25.568 - 00:32:28.250, Speaker A: From outside, but not inside. And that's it.
00:32:28.320 - 00:32:43.386, Speaker B: This is our entire contract. It looks like I'm missing a semicolon up here. Make sure you have your semicolons and yeah, we've got our contract, so let's go ahead and deploy this contract again. We'll make sure that we inject and we pick the right one and we'll.
00:32:43.418 - 00:32:44.850, Speaker A: Go ahead and deploy.
00:32:46.550 - 00:33:04.406, Speaker B: Now when this is deployed, we can then have the address and give that to our new upkeep that we're creating. That upkeep is going to need to be informed what can actually be done with our contract. If you verify a contract on the.
00:33:04.428 - 00:33:07.906, Speaker A: Block Explorer of that network, the Keeper.
00:33:07.938 - 00:33:29.994, Speaker B: Interface can go ahead and read that information in this contract's not verified, we'll copy the address of it and we'll come here and we'll take a look at what we need to do next. It couldn't fetch the Abi because the contract's not verified. So we'll need to provide the Abi. That's the application binary interface. Essentially, it lets other programs know what can we do with this contract.
00:33:30.122 - 00:33:31.706, Speaker A: Where do we find the Abi?
00:33:31.818 - 00:33:41.710, Speaker B: In Remix, right here under our compiler, we can make sure that we pick the correct contract. And then there's this Abi button right here. When you click it, it will copy the Abi to your clipboard.
00:33:41.790 - 00:33:44.020, Speaker A: So we'll head back and paste it in.
00:33:44.390 - 00:33:50.726, Speaker B: We can see it gives it some information about what the inputs are and what the different functions are and we can do next.
00:33:50.908 - 00:33:53.206, Speaker A: Now that we provided the Abi, the.
00:33:53.228 - 00:33:57.762, Speaker B: Keeper's interface is aware of what functions there are available in our contract.
00:33:57.906 - 00:33:59.234, Speaker A: This is a pretty simple contract.
00:33:59.282 - 00:34:03.020, Speaker B: It has one function, so we'll select that function and click Next.
00:34:03.470 - 00:34:05.274, Speaker A: Here's where Cron comes in.
00:34:05.392 - 00:34:11.434, Speaker B: So this Cron will give us some things that we can do, like every 15 minutes, every hour, the first of.
00:34:11.472 - 00:34:13.742, Speaker A: Every month, we'll pick every 15 minutes.
00:34:13.796 - 00:34:19.614, Speaker B: To start with and then we'll change it to be maybe a little bit faster. So we'll say every minute we want.
00:34:19.652 - 00:34:23.546, Speaker A: This Keeper to execute, so every minute.
00:34:23.578 - 00:34:29.300, Speaker B: We should see an increase in our counter. We'll name this upkeep, we'll say Count.
00:34:29.750 - 00:34:31.426, Speaker A: We'Ll give it a gas limit and.
00:34:31.448 - 00:34:36.702, Speaker B: We can go ahead and just go with the default here. Again, this is going to be a limit based upon the amount of gas.
00:34:36.766 - 00:34:39.222, Speaker A: That your function needs, we do ask.
00:34:39.276 - 00:34:46.134, Speaker B: For an email address. This is to provide information based on your upkeep. If you have an issue, like you're running out of link or something like.
00:34:46.172 - 00:34:46.760, Speaker A: That.
00:34:51.100 - 00:34:55.656, Speaker B: And we can register our upkeep. Again, this will take some confirmations from.
00:34:55.678 - 00:35:01.000, Speaker A: Your wallet and it will also transfer some link from your wallet to your Keeper.
00:35:03.580 - 00:35:14.376, Speaker B: This does take two confirmations and once they have been confirmed, our upkeep should be ready to go. All right, our upkeep has been registered.
00:35:14.408 - 00:35:17.800, Speaker A: Let's take a look at it. We can see here all of the.
00:35:17.810 - 00:35:25.760, Speaker B: History and all of the information, as well as a projected time of next execution. This one's pretty straightforward because it's running every minute.
00:35:26.260 - 00:35:28.748, Speaker A: Once our upkeep has run, we should.
00:35:28.774 - 00:35:30.660, Speaker B: See that our counter has increased.
00:35:31.640 - 00:35:35.136, Speaker A: Now, while we're waiting for this upkeep.
00:35:35.168 - 00:35:47.812, Speaker B: To run, let's head back to the documentation and take a look at custom logic. Again, we'll need to register a new upkeep and we'll need to have a contract that is deployed that's a Keeper compatible contract.
00:35:47.956 - 00:35:49.256, Speaker A: So if we look at creating a.
00:35:49.278 - 00:35:56.340, Speaker B: Keeper compatible contract, it requires two things, the first of which is a check upkeep function that will return a Boolean.
00:35:56.420 - 00:35:59.036, Speaker A: As well as possibly some data that.
00:35:59.058 - 00:36:29.152, Speaker B: Lets us know if we need to actually perform upkeep. And that tells us what the second function is. It's perform upkeep. So with a check upkeep function and a perform upkeep function, we have a Keepers compatible contract. Now, there are example contracts here and we can scroll down and see one. This contract essentially does the exact same thing as our other contract, but it's a little bit more involved because we are using that custom logic. So let's open this example in remix.
00:36:29.296 - 00:36:31.764, Speaker A: And take a look at it as well.
00:36:31.962 - 00:36:52.776, Speaker B: So again, we have our solidity version and we import Keeper compatible interface. We set up our contract named counter, and we create our public value of counter. We create two other variables as well. The first is an interval that's going to be how often we want this to run. In this case, remember, we're doing the same functionality, but we're using custom logic.
00:36:52.808 - 00:36:55.128, Speaker A: Instead of strictly time based logic.
00:36:55.304 - 00:36:57.724, Speaker B: We keep track of the last timestamp.
00:36:57.772 - 00:37:02.364, Speaker A: That's going to be the block timestamp in our constructor.
00:37:02.412 - 00:37:30.472, Speaker B: We'll pass in the interval in seconds of how often we want to update this. And we'll set our last timestamp to the current block's timestamp, as well as setting our counter to zero. We then dive into two functions. The first is check upkeep, which takes in some call data as well as providing the upkeep needed and the performed data if we have it. In this example, we're just passing back upkeep needed that Boolean value. True.
00:37:30.526 - 00:37:31.252, Speaker A: False.
00:37:31.396 - 00:37:57.008, Speaker B: So upkeep needed will be determined by looking at the block timestamp subtracting. The last time that we did something, the first time this runs, that'll be when the contract was created. But as we'll see in Perform Upkeep, it could be the last time that we had performed upkeep and seeing if those two time variances are greater than the interval. If it is, that value is going to be true and we need to Perform upkeep. So what does Perform Upkeep do?
00:37:57.094 - 00:37:57.344, Speaker A: Again?
00:37:57.382 - 00:38:20.584, Speaker B: It takes in that perform data and it checks once more to ensure that we actually need to do our upkeep. And it's important to do this because you always want to make sure before you make a change on chain that you are actually needing to do it. So we check again that block timestamp minus the last timestamp, is that greater than our interval? If it is, we'll update the last.
00:38:20.622 - 00:38:25.320, Speaker A: Timestamp and we'll add one to the counter. It's doing the exact same thing.
00:38:25.390 - 00:38:29.896, Speaker B: It's a little bit more involved because this Perform Upkeep and check upkeep methods.
00:38:29.928 - 00:38:33.196, Speaker A: Allow you to have any validation that.
00:38:33.218 - 00:38:47.440, Speaker B: You need to check if you actually need upkeep. You could look at things like pricing, wallet balances. Essentially the sky's the limit when it comes to what you can do with custom upkeep functions. So before we dive into adding this.
00:38:47.510 - 00:38:51.090, Speaker A: To a Keeper, let's deploy it first.
00:38:52.120 - 00:39:09.960, Speaker B: Same thing that we've been doing this whole time, injected. And we'll make sure that we pick the correct one here. We'll send it an interval. We'll say 60 seconds and click Deploy. We'll confirm this and while we're waiting for this to deploy, we'll head back to our other time based Keeper.
00:39:11.740 - 00:39:13.992, Speaker A: If we head here and refresh our.
00:39:14.046 - 00:39:53.648, Speaker B: Keeper details, we can see that, hey, it's actually run twice while we've been waiting. So if we look at our contract that has been deployed and we take a look here at what our counter is set to, you can see our counter has now changed to two. So this contract is incrementing itself automatically on a time based interval of 1 minute, roughly. Again, the time based intervals of very low values like that can be less than perfectly accurate just because we're requiring a block to be mined when we check. So depending on what chain you're on, that could be a little bit tricky when it comes to very small time based values.
00:39:53.744 - 00:39:57.816, Speaker A: Just something to keep in mind. All right, so this counter is working.
00:39:57.918 - 00:40:00.280, Speaker B: On a time based interval. That's amazing.
00:40:00.430 - 00:40:04.824, Speaker A: We'll go ahead and close this down just to keep things simple. And we'll head back here.
00:40:04.862 - 00:40:11.752, Speaker B: Our contract is deployed now, so we'll copy this contract and we'll head back to creating a Keeper.
00:40:11.816 - 00:40:17.950, Speaker A: So where do we need to go? We need to go to Keepers chain link.
00:40:18.880 - 00:40:40.096, Speaker B: All right. And we'll register a new upkeep here. And this time we'll pick custom logic. We'll enter the address of the contract we just deployed and it'll try to verify it as well. If our contract was verified, it would be able to ensure that it was a keeper compatible contract because we haven't verified it. We can still deploy this Keeper, but it's relying on us now. To make sure that the Keeper contract.
00:40:40.208 - 00:40:46.608, Speaker A: Is a Keeper compatible contract, we'll provide a name again. So we'll just say count two, we'll.
00:40:46.624 - 00:40:55.630, Speaker B: Give it a gas limit, and we'll go ahead and give it the same one we gave it before we'll give it some link to start with. We don't need any check data, but we do need an address.
00:41:00.190 - 00:41:00.874, Speaker A: And we.
00:41:00.912 - 00:41:03.370, Speaker B: Can register our upkeep.
00:41:06.730 - 00:41:10.906, Speaker A: Once this has been confirmed, we should.
00:41:10.928 - 00:41:21.356, Speaker B: See upkeep kick off pretty quickly. I often get questions about upkeep and how can we ensure that someone doesn't.
00:41:21.388 - 00:41:29.204, Speaker A: Call perform upkeep other than the Keeper. In my mind, one thing to keep in note is best practice is why.
00:41:29.242 - 00:41:34.884, Speaker B: Wouldn'T you want someone else to call perform upkeep? That's going to be the function that costs gas. If someone else wants to pay my.
00:41:34.922 - 00:41:37.236, Speaker A: Utility bill for me, awesome.
00:41:37.338 - 00:42:05.052, Speaker B: Let them do it. But make sure that you have your perform upkeep set up in a way that it will not be a problem if someone else calls it or if it's called repeatedly. That is why in this example, we are checking again to make sure that upkeep needs to be run. It's always good to make sure that that one only runs when it's actually needed. So just something to keep in mind. But locking that down so that only the Keeper's network call it, I think that's not something to worry about. You should focus on it from a.
00:42:05.186 - 00:42:06.576, Speaker A: How do I make sure that no.
00:42:06.598 - 00:42:08.400, Speaker B: Matter who calls this, it only actually.
00:42:08.470 - 00:42:12.176, Speaker A: Does what I want it to do? We head back here, we can see.
00:42:12.198 - 00:42:14.316, Speaker B: That our upkeep has been registered.
00:42:14.508 - 00:42:16.560, Speaker A: We go ahead and view our upkeep.
00:42:17.380 - 00:42:22.550, Speaker B: We can see here we've funded it, we've created it. We'll need to wait for it to actually run.
00:42:23.960 - 00:42:25.924, Speaker A: All right, we refresh the page and we can see.
00:42:25.962 - 00:42:46.836, Speaker B: Hey, look, it actually did run and we performed our upkeep. Fantastic. Let's head back to our contract and take a look. If we open up our contract and we check the counter hey, our counter is one. We have an incrementing counter. Again, in this case, it's based on time, but using custom logic that we defined, not just strictly based on a Cron tab.
00:42:46.948 - 00:42:50.568, Speaker A: And this really opens up the opportunity.
00:42:50.654 - 00:43:08.608, Speaker B: For automating anything that you can come up with. So that is some of the products that chainlink has to offer. I really appreciate you taking the time to walk through this, and if you have any questions, feel free to reach out. You can find me on Twitter. I'll put my Twitter handle right here. And yeah, have fun building.
00:43:08.774 - 00:43:09.936, Speaker A: I look forward to hearing from you.
00:43:09.958 - 00:43:12.030, Speaker B: And seeing what awesome projects you come up with.
