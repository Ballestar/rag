00:00:29.330 - 00:00:39.240, Speaker A: Hello everyone in workshop data feeds and CCIP. Joining us today is Richard Galliber, who will be taking us through this session. And with that, I will pass over to Richard to get the session started.
00:00:41.290 - 00:00:45.986, Speaker B: Thank you. So I'm Richard Galliber. I'm one of the developer advocates at Chainlink Labs.
00:00:45.986 - 00:01:03.182, Speaker B: And this is going to be a pretty fast and furious little workshop here. So I'm going to assume that everyone is knowledgeable, comfortable with Web Three at a basic level while everybody's coming in. If you want to pop in where you're from, that'd be awesome.
00:01:03.182 - 00:01:21.620, Speaker B: I love seeing where everybody's from in the chat and these things because it's always such a global audience from the chat, too. If you have questions, feel free to drop them in there as we're going through this. I'll do my best to put on my live streamer hat and answer all those questions as we go through this.
00:01:21.620 - 00:01:29.382, Speaker B: But yeah, so let's go ahead and get started. I guess we got somebody from Columbia or Bogota. That's awesome.
00:01:29.382 - 00:01:55.860, Speaker B: See, I'm in Texas, so we already know multiple continents represented. So let's get started talking about decentralized Oracle networks, hybrid smart contracts, chain link, what is it? I'll start off with acknowledging that Web Three is amazing, right? It solves some really tough problems. It gives us the ability to have cryptographic truth instead of relying on just trusting third parties entities like that.
00:01:55.860 - 00:02:12.022, Speaker B: But it does have a problem. And that problem is consensus, right? Reaching agreement. So we think about most blockchains, they're going to be comprised of multiple nodes and those nodes will need to reach agreement on things.
00:02:12.022 - 00:02:23.926, Speaker B: Easy way to illustrate this to everyone who's here in the audience listening. If I were to ask you a question like, what's one plus one in the chat? Go ahead and pop your answer in. There not a trick question, seriously.
00:02:23.926 - 00:02:26.330, Speaker B: Just know one plus one equals.
00:02:28.030 - 00:02:29.242, Speaker C: And yeah, two.
00:02:29.296 - 00:02:38.894, Speaker B: Like Felix said, right? So Felix and I have reached consensus. He and I both agree one plus one is two. Doesn't matter when we ask this question, doesn't matter where we are when we ask this question.
00:02:38.894 - 00:02:56.180, Speaker B: We can reach consensus a little bit more. Interesting question to ask is what's the current temperature? It depends, right? I'm in Texas and I use fahrenheit. It's like 107 degrees or something like that.
00:02:56.180 - 00:03:08.570, Speaker B: If you use Celsius, you're going to give me a different answer. And that is a problem when it comes to reaching consensus. That gives the appearance of blockchains, having this phenomenal cosmic power, all these benefits.
00:03:08.570 - 00:03:26.992, Speaker B: But they've got this itty bitty living space of needing to reach consensus, right? So this is like the massive downside of blockchains, phenomenal cosmic power, itty bitty consensus based living space. It's referred to as the Oracle problem. Reaching consensus on real world data.
00:03:26.992 - 00:03:43.200, Speaker B: Like that where it depends type of question. Ironically, the Oracle problem has a solution called Oracles, and that is what Chainlink is is it's an Oracle network. So Oracles are a method of bringing that off chain data on chain.
00:03:43.200 - 00:04:06.140, Speaker B: You can see here you can create your own Oracle, right? If you have a centralized Oracle node, you could do that. I could have a little server sitting here in my office and I could bring off chain data on chain like temperature, for example. But that does take decentralized benefits of blockchains and essentially centralizes them in whatever application is using that Oracle because you've introduced a single point of failure.
00:04:06.140 - 00:04:23.024, Speaker B: Now, chainlink is a decentralized Oracle network, or dawn as we call it. You can see that here, it looks similar to a blockchain, right? And it kind of replicates some of that. We have multiple nodes that then reach consensus on questions that are non deterministic, like temperature as example.
00:04:23.024 - 00:04:29.250, Speaker B: Another good example is the price of an asset, right? If I were to ask you what's the price of ETH currently?
00:04:29.780 - 00:04:30.748, Speaker C: It depends, right?
00:04:30.774 - 00:04:42.660, Speaker B: It depends on where you're looking at that price and it depends on exactly when you look at that price. That's one of the common use cases that chainlink sees is data feeds. So bringing that off chain information back on chain.
00:04:42.660 - 00:04:53.260, Speaker B: So that's what data feeds is. The most common example there is using that price feed information. So it's going to be an asset pair like ETH in terms of USD, Bitcoin in terms of USD, something like that.
00:04:53.260 - 00:05:10.284, Speaker B: We will take a look at a code example and deploy a contract using data feeds. In this workshop we also have VRF, which is Verifiable randomness function. Essentially it provides you with verifiably random numbers in your smart contracts.
00:05:10.284 - 00:05:39.268, Speaker B: That's important because when it comes to blockchains, again, there is the possibility for nodes within the blockchain to manipulate when you're generating a random number on chain, such that I think of it like rolling dice, right? If I'm rolling dice, I can't determine what the outcome of that roll is. But if I have the ability to continuously reroll until I get the result I want, I can effectively control what that random value is. This is something that can happen on blockchains.
00:05:39.268 - 00:05:58.288, Speaker B: That's why something like chainlink BRF is very important to enable you to have actually verifiable random numbers. Another product that we have is chainlink automation. Smart contracts, while extremely powerful, are also extremely lazy in that they won't do anything by themselves.
00:05:58.288 - 00:06:14.848, Speaker B: Now, what that means is that you need something to actually run the functions within a smart contract. That's where chainlink automation comes in again using the dawn or distributed Oracle network to actually execute those on chain function calls. We also have chainlink functions which came out just recently.
00:06:14.848 - 00:06:37.660, Speaker B: I like to think of this as opening up the entire world of the Internet to your smart contracts is probably the most powerful piece in my opinion, of chainlink functions. What chainlink functions does is it allows you to run code in a compute environment within that Oracle network. So the Oracles will run in a little sandbox environment JavaScript code.
00:06:37.660 - 00:06:54.012, Speaker B: That JavaScript code could be something like an API call, giving you access to all of that off chain data. It could also be complex computations if you had a mathematical computation that you wanted to run, like some sort of interest calculation, for example. It can be really expensive to do that on Chain.
00:06:54.012 - 00:07:07.264, Speaker B: Channeling functions. Lets you take that computation, run it in the sandbox environment, still using that Oracle network, and then get those results back on Chain. And finally, the newest thing that we just announced would be Channeling CCIP.
00:07:07.264 - 00:07:18.650, Speaker B: It's a cross chain interoperability protocol. Basically, it allows you to send messages, send tokens from one blockchain to another. And we'll take a look at an example of this today as well.
00:07:18.650 - 00:07:23.150, Speaker B: So before I dive into samples yeah.
00:07:23.760 - 00:07:28.584, Speaker A: Looks like your face is kind of frozen. Maybe are you able to maybe restart your camera?
00:07:28.712 - 00:07:29.630, Speaker C: Oh, no.
00:07:31.520 - 00:07:33.596, Speaker A: Audio. Is that better? Okay, yeah, we can see now.
00:07:33.618 - 00:07:34.476, Speaker C: All right, cool.
00:07:34.658 - 00:07:39.728, Speaker B: Zoom doesn't like my camera. I don't know why it's the only one that does this, but I just disable and re enable it and it's good to go.
00:07:39.894 - 00:07:41.330, Speaker C: But thanks for letting me know.
00:07:42.820 - 00:08:09.580, Speaker B: Before we dive into the demos, are there any questions? I know I just blazed through all of that fast and furious. All right, I will assume I'm the world's best presenter and you have zero questions because I've answered them all already. And we'll dive into the documentation.
00:08:09.580 - 00:08:27.764, Speaker B: If you go to Docs Chain link, it's the best place to start for all things Chainlink. It has examples, as you'll see in just a moment that you can click and just immediately open them and remix and deploy from there. I'm going to walk through a little bit different than the examples we provide.
00:08:27.764 - 00:08:40.708, Speaker B: I'm going to use different chains than what in the examples just to kind of show you how you go about navigating through that. For the first example, I'll be using data feeds on the base testnet chain. So it's the coinbase chain, their testnet.
00:08:40.708 - 00:08:53.068, Speaker B: And then for the second example, I'll be doing that on optimism. Their testnet going to Sepolia. So for data feeds, if you click on this first one here, this is what we'll be talking about.
00:08:53.068 - 00:09:05.440, Speaker B: And got a bunch of information here on data feeds with addresses and stuff like that, which we'll take a look at in a minute. We'll look down here at using data feeds. From here you'll see that there is a sample contract.
00:09:05.440 - 00:09:16.884, Speaker B: And this sample contract is pretty straightforward. I'll go through it, but I'll open it and remix first. So if you just click this open and remix button, it will pop open a remix window just like this.
00:09:16.884 - 00:09:33.428, Speaker B: Let's walk through this contract really quick. You can see that we are importing in an aggregator V Three interface. What is that? An aggregator interface in this case is what's going to be taking the responses from the Oracle nodes and aggregating them together to get that response.
00:09:33.428 - 00:10:08.068, Speaker B: So we mentioned that it is difficult to answer a question like what temperature is it? This example is answering the question, what's the current price of Bitcoin in terms of USD? It's difficult to answer that right to come to consensus. So how this works is each Oracle node gets their response back to that and then those nodes then give you a set of answers. From that set of answers, you can turn it into a deterministic question by saying what's the median value in this set of responses? So that's how you turn a non deterministic question like what's the price into a deterministic one.
00:10:08.068 - 00:10:27.656, Speaker B: So that's kind of a little bit of a peek behind the curtain of how things work when it comes to reaching consensus from the Oracle network. In this example you'll see here, we set up our contract, we set up a data feed and it's going to be an aggregator interface. And then we pass in an address to that aggregator interface.
00:10:27.656 - 00:10:54.028, Speaker B: Now each asset pair has a specific address on each network. What does that mean? So here you can see that this one's set up for Sepolia Bitcoin USD. It's e 43, right? If we go back to the documentation and we were to take a look at the price feed addresses here, and we were to go to the base chain like we were talking about using in this example, and we wanted to look at Bitcoin in terms of USD.
00:10:54.028 - 00:11:02.292, Speaker B: You can see the address is different, right? So since we're using this chain, we need to use this address. Let's go ahead and copy that address. Click on that little button right there.
00:11:02.292 - 00:11:15.416, Speaker B: We'll come back into remix and we'll change both these values to that new address. So that's letting it know that, hey, we're going to use this address because we're on a different chain. Then we've got our function here, get latest data.
00:11:15.416 - 00:11:23.390, Speaker B: So the way that price feeds works is on a regular heartbeat. And probably the easiest way to see this is if we go to data chain link.
00:11:25.760 - 00:11:27.276, Speaker C: And we'll just look at.
00:11:27.378 - 00:11:37.996, Speaker B: Bitcoin in terms of ESD because that's what we're using. So you can see here on this page just kind of like a visual representation of what's going on. On the right hand side, we have all the different Oracles and the prices that they're reporting.
00:11:37.996 - 00:11:52.372, Speaker B: And you can see like, just look at these first two, right? There's a difference in the price that's being reported. Each of these Oracles reports their price and that price gets updated on chain. When does it get updated on chain? It depends on which feed we're looking at.
00:11:52.372 - 00:12:07.112, Speaker B: If you go to specific feed, you can look at the trigger parameters like what we have here. So if the price changes by half percent, that will cause an update to happen or if the heartbeat time elapses. This is basically being controlled by chainlink automation.
00:12:07.112 - 00:12:25.388, Speaker B: So either we're checking a value on chain or we're using a time based update as well. So it's pretty straightforward, like when it gets triggered, but when something happens to trigger an update, then the actual value on chain is updated. We're back to remix.
00:12:25.388 - 00:12:35.524, Speaker B: Look at Gitlatus data. Gitlatus data is going to query that on chain value. It returns a bunch of different values and that's why we have these common it out sections here.
00:12:35.524 - 00:12:47.416, Speaker B: If you're not familiar with Solidity and when you have a function signature like this, technically the right way to do this is just to have like comma int answer. Comma, comma, comma. It's really confusing when you see that and you're trying to understand what's going on.
00:12:47.416 - 00:13:00.300, Speaker B: So we have kind of an explanation of what the different values are that are not being used within the smart contract. So we're getting back our answer. That's going to be the value of Bitcoin in terms of USD and we're going to return that back.
00:13:00.300 - 00:13:06.284, Speaker B: So how do we deploy this? Right, we're in remix. We've got the autocompile turned on. That's why I have my green check mark.
00:13:06.284 - 00:13:14.640, Speaker B: If you didn't have that, you just click compile and everything would be awesome. There you compile it. We'll change our injected provider to MetaMask here.
00:13:14.640 - 00:13:19.684, Speaker B: And again, I'm using the base go early chain here and we just click.
00:13:19.722 - 00:13:20.420, Speaker C: Deploy.
00:13:22.680 - 00:13:24.484, Speaker B: And this is ridiculously large.
00:13:24.522 - 00:13:33.306, Speaker C: Now we'll confirm this transaction and we.
00:13:33.328 - 00:13:47.730, Speaker B: Can see we've got our green check mark back. So the transaction went through and we have our consumer contract deployed. Now what's really cool about this contract is because this is a view function, you can get the latest price data without spending any gas.
00:13:47.730 - 00:14:03.058, Speaker B: You may also notice that this price is really large, right? Like woof, that's a lot different. Solidity doesn't have the concept of decimal places or floats. So these numbers are artificially enlarged for accuracy.
00:14:03.058 - 00:14:14.730, Speaker B: This one, for instance, is eight times ten to the 8th power. So 1234-5678. If you put a decimal place in there, that's going to be the actual value that's returned.
00:14:14.730 - 00:15:08.138, Speaker B: So pause here for a second. Data fees we just like blazed through deploying a contract and we're getting back an on chain answer to the price of what's Bitcoin in terms of USD. Any questions so far? Can I try to build up a custom oracle to feed my data into multiple blockchain networks using the chainlink API? So if you're interested in actually adding to the data calls, the old way of doing this I think would be to create like a job using any API.
00:15:08.138 - 00:15:24.242, Speaker B: It's something that we had previously to functions. That was the way to get information on chain and do it that way. If you're just interested in having your information available via chainlink oracles, anywhere where chainlink functions exists, if it's an API, you could make a call to it.
00:15:24.242 - 00:15:36.150, Speaker B: So that it's. Answering your question, if you're more interested in actually running an Oracle, if you look at our docs about that in the nodes section, it'll explain more about running an Oracle.
00:15:44.730 - 00:15:45.430, Speaker C: Cool.
00:15:45.580 - 00:15:54.474, Speaker B: Any other questions, feel free to pop them in. I'm going to keep going over to CCIP. So CCIP is brand new.
00:15:54.474 - 00:15:56.906, Speaker B: We just announced it a couple of weeks ago.
00:15:57.088 - 00:15:59.802, Speaker C: I think it's a pretty big deal.
00:15:59.856 - 00:16:04.766, Speaker B: I don't know. Again, I work for Chainlink, so everything's amazing and awesome and the best. But this is pretty cool.
00:16:04.766 - 00:16:16.974, Speaker B: You can send tokens between chains. You can also send information data between chains, which is really awesome. So let's take a look at how to transfer tokens between chains.
00:16:16.974 - 00:16:27.650, Speaker B: What that looks like. So back at our Docs page, scroll down to CCIP. We're going to look at transferring tokens between chains here in similar fashion.
00:16:27.650 - 00:16:43.446, Speaker B: There is a contract that we can open up in between them. For this one, not only are you going to need if you want to follow this whole tutorial along yourself, you'll need what native tokens for whatever chains you're using. You'll also need link tokens, which is the chain link token.
00:16:43.446 - 00:17:00.938, Speaker B: It's what the Oracle nodes are compensated in for doing work. You'll also need CCIP test tokens, which are tokens specifically for these examples on the testnets, there is CCIP, BNM, which is burn and mint. There's also lock in mint.
00:17:00.938 - 00:17:08.846, Speaker B: So you can generate those. You can mint those to your wallet right here. I'm going to change to optimism.
00:17:08.846 - 00:17:26.866, Speaker B: Go early, real quick. So here you can either add the token to your wallets, you can also mint some of the token right from our Docs page into your wallets. You also need to make sure that you are working on a network that is supported by CCIP.
00:17:26.866 - 00:17:30.170, Speaker B: Just kind of a limited number right now since we just launched.
00:17:32.590 - 00:17:33.274, Speaker C: Is Base.
00:17:33.312 - 00:17:43.210, Speaker B: And Dora supported by CCIP. So Base is not supported by CCIP yet. The supported chains are right here under supported networks.
00:17:43.210 - 00:18:05.982, Speaker B: If you have more, it's basically ethereum, optimism, avalanche, arbitram and polygon currently. So in similar fashion, I already have this open, but this contract will not walk through all the code because it is a massive contract. Kind of the approach that we've taken with this tutorial contract is this is like the everything and the kitchen sink contract.
00:18:05.982 - 00:18:21.146, Speaker B: It does a ton of stuff. We're going to go through one use case here. But in remix, we'll need to open this up, compile it, we'll need to deploy it, we'll need to give it some native token and some of the BNM token as well.
00:18:21.146 - 00:18:24.700, Speaker B: So let's go ahead and get going with that. So I've got the contract here.
00:18:26.590 - 00:18:26.954, Speaker A: Just.
00:18:26.992 - 00:18:51.780, Speaker B: To kind of walk through a few of the things. You can see we're importing our CCIP contracts up here at the top in our constructor there's two things that we're interested in. It's the router which will be determining that's basically the contract that determines what network we're sending these messages or tokens to and then also the address for the link token on the current network that we're deploying on.
00:18:51.780 - 00:19:04.598, Speaker B: If we're using link token to fund this, that becomes more important. The example I'm going to walk through is going to use native token. We also have a whitelist function to whitelist the chain that we're sending to.
00:19:04.598 - 00:19:18.742, Speaker B: So that's something that we need to be aware of. And then we have a function to transfer token and pay a native. So this will actually allow us to transfer that BNM token from Optimism's Gorely to Ethereum's Folio.
00:19:18.742 - 00:19:37.730, Speaker B: So we'll see how that works here in just a minute. All right, so we've got this compiled again, if you don't have the green checkmark and you're following along, you'll need to turn on autocompile or actually click compile. And we will change this to be our injector provider.
00:19:37.730 - 00:19:54.214, Speaker B: And when we deploy here now we'll need our router address and link token address. Where do we find those? If we go back to the documentation and to the supported networks page, we are on Optimism go early. So the router address is here.
00:19:54.214 - 00:20:10.190, Speaker B: We can copy that, put it in here and then the link token address is right here for us. Snag those two items real quick. So we'll deploy this contract.
00:20:17.600 - 00:20:19.372, Speaker C: All right, we've got it deployed and.
00:20:19.426 - 00:20:21.052, Speaker B: Like I mentioned, this is kind of.
00:20:21.186 - 00:20:23.692, Speaker C: Everything sync contract here.
00:20:23.746 - 00:20:36.220, Speaker B: We've got a lot of stuff going on. We are going to focus on whitelist chain first. So we'll need to whitelist the chain that we're going to in this example, we're going to Ethereum Sepolia.
00:20:36.220 - 00:20:39.668, Speaker B: So we'll use the chain selector for that.
00:20:39.834 - 00:20:43.990, Speaker C: So we'll copy that value, keep it in here.
00:20:51.940 - 00:21:10.120, Speaker B: All right, so we've whitelisted that and now we're going to do the transfer tokens pay native. But before we can do that, we need to fund this contract with some of the tokens and some of the native balance. So how do we do that? Well, it's as simple as just sending to this contract.
00:21:12.700 - 00:21:17.224, Speaker C: So open up MetaMask to send, give.
00:21:17.262 - 00:21:32.586, Speaker B: It our contract address, make sure that's right. And in this case we'll send it some of the BNM. So we'll just send it a little bit.
00:21:32.586 - 00:21:44.430, Speaker B: We can send it like zero two and then we'll also want to send it some ETH.
00:21:47.880 - 00:21:49.972, Speaker C: And we can send it zero one.
00:21:50.026 - 00:22:15.778, Speaker B: Should be plenty. Okay, so we've deployed our contract and we have funded it with token that we're going to be sending and we've also funded it with the native token so they can actually run transactions on its own. Now we need to get our destination chain selector again, which would be the same value that we whitelisted.
00:22:15.778 - 00:22:29.926, Speaker B: So this will be for Sepolia for the receiver. This could be another contract or it could be an EOA, a wallet, for example. So I'm just going to use my wallet address for this, the token.
00:22:29.926 - 00:22:42.442, Speaker B: So now go and make sure that we put in the right values here. So transferring tokens, paying in native. So the token is going to be the token address on the source chain.
00:22:42.442 - 00:22:53.710, Speaker B: So this is the chain that we are coming from. So if we go to our supported chains, we're coming from optimism. Go early, and we need the CCIP BNM token.
00:22:53.710 - 00:22:55.620, Speaker B: So we'll get the address here.
00:22:58.070 - 00:22:59.346, Speaker C: Paste that in.
00:22:59.448 - 00:23:12.390, Speaker B: If we go back to the documentation, we're going to send zero, zero, one, or one, followed by a bunch of zeros. I'm going to copy it just to make sure I don't mess that up. And we will run this transaction.
00:23:12.390 - 00:23:25.730, Speaker B: All right, so it's been successful. Our transaction has been mined. We have our transaction hash here.
00:23:25.730 - 00:23:30.594, Speaker B: We're going to grab this. It's important. I got to this by opening up the little debug menu to grab the.
00:23:30.632 - 00:23:34.802, Speaker C: Transaction hash right here.
00:23:34.936 - 00:23:39.046, Speaker B: You could also get it from your wallet. You'll see why we need this in just a minute, though.
00:23:39.228 - 00:23:43.926, Speaker C: So if we go back, the fact.
00:23:43.948 - 00:23:55.434, Speaker B: That we have our CCIP Explorer, so we go to CCIP chain link, you'll see our Explorer. And this is where you'll put your transaction hash in, right here. This will actually take you to this.
00:23:55.472 - 00:23:58.138, Speaker C: Transaction in this, so you can kind.
00:23:58.144 - 00:24:16.066, Speaker B: Of see what's going on. So basically what happens is we have reached out to the router and we said, hey, we want to transfer these tokens that we gave you over to this other chain. So it's going to burn those tokens and it's going to mint new tokens on Zapolia while it's waiting for a few things to happen, though.
00:24:16.088 - 00:24:18.500, Speaker C: So this does take time.
00:24:18.950 - 00:24:28.118, Speaker B: So we're waiting for finality. What that means is we're waiting for things to get to a point where they can't be reverted back before we continue forward. A security feature, if you will.
00:24:28.118 - 00:24:38.422, Speaker B: So I like to think of this as like a baking show. We're going to put this in the oven and let it bake. But surprise, surprise, I already have one that I baked before that was in the oven.
00:24:38.422 - 00:24:57.802, Speaker B: So this is what it looks like when it's completed. You can see here the status is success. Instead of waiting for finality when it comes to this, you can see also what token was transferred, how much of it was transferred, how much cost in link we did pay in native tokens.
00:24:57.802 - 00:25:07.410, Speaker B: There's like conversion process there. So it ends up paying the Oracle nodes in link, who it went from to and the amount, how long it took when it happened.
00:25:07.560 - 00:25:09.362, Speaker C: So I don't know.
00:25:09.416 - 00:25:26.102, Speaker B: It makes it really simple to walk through this tutorial and be like, yeah, you just click a few buttons. But essentially with CCIP, we're sending tokens from optimism Gorely to ethereum Sepolia and it's ridiculously fast. Like, I haven't even been talking for 30 minutes yet and this is only a small part of it.
00:25:26.102 - 00:25:36.718, Speaker B: In order to set that up and do that, you can also send data. You can send data and tokens as well. If you head back to documentation, we have examples how to send tokens with data.
00:25:36.718 - 00:25:54.610, Speaker B: Send just data transfer tokens between EOAS or externally owned accounts, wallets. So, yeah, that is the basics of chainlink data feeds and CCIP, like a super quick introduction to them and what chainlink is. We've got time for questions.
00:25:54.610 - 00:25:59.140, Speaker B: If you have questions, I'm more than happy to answer any questions y'all have.
00:26:02.410 - 00:26:02.882, Speaker C: Cheers.
00:26:02.946 - 00:26:12.220, Speaker A: Thanks, Richard. Yeah, feel free to type them in the chat or to take yourself off mute and ask live. We got a few questions coming in.
00:26:12.220 - 00:26:17.580, Speaker A: Eduardo asks when main net.
00:26:18.350 - 00:26:29.902, Speaker B: That's too big of a question, Eduardo. When mainnet for what? CCIP. It's already in a limited beta there for mainnet.
00:26:29.902 - 00:26:34.420, Speaker B: If you go to Chain Link.
00:26:36.630 - 00:26:37.090, Speaker C: And.
00:26:37.160 - 00:27:15.040, Speaker B: Products and CCIP, you can sign up for access right here. Super tiny, but you can sign up for early access right there. How efficient is CCIP compared to native bridging? I think probably the way that I'll answer that question is by saying CCIP is focused on security and ensuring that you can transfer and have that reliability that is inherent to chainlink in your transfers and your communications across chain.
00:27:15.040 - 00:27:30.470, Speaker B: Not only is it Bridging tokens, it also adds the ability to bridge data, if you will, to send messages cross chain. I think, too, for your specific question, it depends on which specific bridges we're talking about.
00:27:38.090 - 00:27:39.146, Speaker C: I don't know if I missed this.
00:27:39.168 - 00:27:46.540, Speaker A: But did you answer Bruno's question about the fifth source of any kind of tokens? ERC 20 or ERC 721.
00:27:48.190 - 00:27:50.202, Speaker C: Yeah, let's see here.
00:27:50.336 - 00:28:37.818, Speaker B: If we go to where was I was back docs here. So in order for this to work supported tokens wise, we have the testnet tokens, right, that are supported by the routers and in our examples, natively. If you wanted to set up your own token, essentially, it can support any token because what it's doing in my mind, I think of it as you can create the functionality such that any token you wanted can be sent to the contract, either locked or burned on that side as it's sent across.
00:28:37.818 - 00:28:57.586, Speaker B: And it's that data going across that can generate the minting of tokens on the other side. Right. So the logic of it, if you were to look at this and what's happening when you do this, is it's going to make sure the tokens to burn before it mints them on the other side and it's passing that data along through there so you can kind.
00:28:57.608 - 00:28:58.180, Speaker C: Of.
00:29:00.550 - 00:29:03.220, Speaker B: Build your own ability for each token, basically.
00:29:03.670 - 00:29:04.754, Speaker C: Does that make sense?
00:29:04.872 - 00:29:06.820, Speaker B: I feel like I'm stumbling through that answer.
00:29:07.530 - 00:29:14.880, Speaker C: It doesn't make sense. Bruno, let me know. Okay, cool.
00:29:14.880 - 00:29:25.470, Speaker C: Okay.
00:29:25.540 - 00:29:31.650, Speaker A: We still have some time. If anybody has any questions, feel free to type them in the chat or take yourself off mute.
00:29:51.720 - 00:29:53.030, Speaker C: Oh, there we go.
00:29:58.620 - 00:30:16.990, Speaker B: As far as new chains go, that would be part of chainlink would need to support the different chains. When it comes to what you can do once the ability to send the message across is there, it's pretty open as far as what you can create with it.
00:30:18.880 - 00:30:19.292, Speaker C: Right.
00:30:19.346 - 00:30:36.276, Speaker B: Because if you think about it, like when you're sending tokens across Chain, any sort of bridge isn't actually sending that information across, right. It's not like the token is here and it's actually the token is moving, it's just a data that's moving across. Right.
00:30:36.276 - 00:30:47.640, Speaker B: So saying over here I got rid of ten tokens and over here I need to mint ten tokens. So it's just a data exchange that's happening across chain. That's how I think of it, personally.
00:30:55.480 - 00:30:56.592, Speaker C: Awesome. Cheers.
00:30:56.656 - 00:31:17.020, Speaker A: Well, I think we're a little bit over time now, but thank you, Richard, for this great workshop and thank you everybody else for attending. This will be on YouTube as well, in case you have friends that missed. But yeah, oh, Base and Zora will be supported in CCIP from NDB.
00:31:17.680 - 00:31:25.550, Speaker B: Yeah, more chains will be supported in the future, I'm sure I'll answer it that way.
00:31:27.520 - 00:31:27.980, Speaker C: Great.
00:31:28.050 - 00:31:28.620, Speaker A: Awesome.
00:31:28.770 - 00:31:29.144, Speaker C: Cheers.
00:31:29.192 - 00:31:33.616, Speaker A: Well, thank you all, everybody, for attending and thanks again, Richard. And yeah, hopefully everybody has a great.
00:31:33.638 - 00:31:36.636, Speaker C: Rest of the day. Cheers.
00:31:36.748 - 00:31:37.410, Speaker B: Thanks.
00:31:38.180 - 00:31:47.110, Speaker D: Bridge data, if you will, to send messages cross chain. Thank you for your specific question. It'll depend on which specific bridges we're talking about.
00:31:54.850 - 00:32:03.220, Speaker A: I don't know if I missed this, but did you answer Bruno's question about the source of any kind of tokens? ERC 20 or ERC 721?
00:32:04.790 - 00:32:09.106, Speaker D: Yeah, let's see here. If we go to or was I.
00:32:09.128 - 00:32:14.480, Speaker B: Out of that docs here?
00:32:15.010 - 00:32:29.330, Speaker D: So in order for this to work supported tokens wise, we have the testnet tokens, right, that are supported by the routers and in our examples, natively.
00:32:30.630 - 00:32:32.914, Speaker B: If you wanted to set up your.
00:32:32.952 - 00:32:37.202, Speaker D: Own token, essentially it can support any.
00:32:37.256 - 00:32:40.886, Speaker B: Token because what it's doing in my.
00:32:40.908 - 00:32:58.858, Speaker D: Mind, I think of it as you can create the functionality such that any token you wanted can be sent to the contract, either locked or burned on that side as it's sent across. And it's that data going across that can generate the minting of tokens on the other side.
00:32:59.024 - 00:32:59.402, Speaker C: Right.
00:32:59.456 - 00:33:25.026, Speaker D: So the logic of it, if you were to look at this and what's happening when you do this, is it's going to make sure as the tokens to burn before it mints them on the other side and it's passing that data along through there so you can kind of build your own ability for each token, basically. Does that make sense? I feel like I'm stumbling through that answer. It doesn't make sense.
00:33:25.026 - 00:33:26.260, Speaker D: Bruno, let me know.
00:33:41.760 - 00:33:42.184, Speaker C: Okay?
00:33:42.242 - 00:33:48.340, Speaker A: We still have some time. If anybody has any questions. Feel free to type them in the chat or take yourself off mute.
00:33:48.340 - 00:33:57.580, Speaker A: Oh, there we go.
00:34:03.130 - 00:34:23.822, Speaker D: As far as new chains go, that would be part of chainlink would need to support the different chains. When it comes to what you can do once the ability to send the message across is there, it's pretty open as far as what you can create with it. Right.
00:34:23.822 - 00:34:35.122, Speaker D: Because if you think about it, like when you're sending tokens across chain, you're not actually any sort of bridge isn't actually sending that information across.
00:34:35.176 - 00:34:35.298, Speaker C: Right.
00:34:35.304 - 00:34:40.802, Speaker D: It's not like the token is here and it's actually the token is moving. It's just a data that's moving across.
00:34:40.856 - 00:34:41.026, Speaker C: Right.
00:34:41.048 - 00:34:52.150, Speaker D: So saying over here I got rid of ten tokens, and over here I need to mint ten tokens. So it's just a data exchange that's happening across chain. This is how I think of it, personally.
00:34:59.970 - 00:35:00.526, Speaker A: Awesome.
00:35:00.628 - 00:35:01.094, Speaker C: Cheers.
00:35:01.162 - 00:35:14.050, Speaker A: Well, I think we're a little bit over time now, but thank you, Richard, for this great workshop. Thank you, everybody else, for attending. This will be on YouTube as well, in case you have friends that missed.
00:35:14.050 - 00:35:24.762, Speaker A: But yeah. Oh, Base and Zora will be supported in CCIP from Eddie B. Yeah, more.
00:35:24.816 - 00:35:30.060, Speaker D: Change will be supported in the future, I'm sure I'll answer it that way.
00:35:32.030 - 00:35:32.490, Speaker C: Great.
00:35:32.560 - 00:35:33.130, Speaker A: Awesome.
00:35:33.280 - 00:35:33.654, Speaker C: Cheers.
00:35:33.702 - 00:35:39.100, Speaker A: Well, thank you all, everybody, for attending. And thanks again, Richard. And yeah, hopefully everybody has a great rest of the day.
00:35:40.430 - 00:35:42.470, Speaker D: Cheers. Thanks, y'all. Bye.
