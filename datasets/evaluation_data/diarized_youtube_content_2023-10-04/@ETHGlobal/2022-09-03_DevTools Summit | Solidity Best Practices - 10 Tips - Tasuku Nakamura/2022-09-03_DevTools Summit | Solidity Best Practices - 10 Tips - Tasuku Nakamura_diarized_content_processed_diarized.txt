00:00:06.090 - 00:00:17.370, Speaker A: I'm super excited to welcome Taz smart contract programmer to talk about validity, best practices and ten tips to become better at developing Solidity. So without further ado, let's welcome Taz.
00:00:17.530 - 00:01:13.410, Speaker B: So for today I'll be talking about ten Solidity best practices. They're not an any particular order, they're not in any particular importance, they're just some maybe things that I learned while learning slidy and I'll share them with you guys today. So the first one is to lock compiler version. So the bad practice is to have a compiler version set like this with a carrot and this will mean that your Solidity version can be anything from 0.8 and less than 0.9. And the good way to do it is to lock the compiler version and it means to set it to a specific version. For example, here we're setting it to 0.8.13
00:01:13.410 - 00:02:09.430, Speaker B: and the reason why we want to log compiler version is I'd say that it's mostly for when you deploy a contract and then try to verify it. By the time you deploy a contract you might have forgotten which version you deployed it with. So it's really helpful that you lock your version, you go back to your code and say oh, so I know that I deployed it at 0.8.13 so you'll remember it and you'll have an easy time verifying smart contracts. The other reason is sometimes Solidity will announce bugs and if you know your version, then you would know if your contract has a bug or not. So that is one recommendation to lock your compiler version. Okay, so the next one is multiply before divide.
00:02:09.430 - 00:03:17.340, Speaker B: I see a lot of developers, new developers asking the question if I have a number like x, how do I get like 90% of x? So one way that you might think that you would do it is to say x times 90%, so it'll be 90 divided by 100. And here we're dividing 90 over 100 and then multiplying x. And the reason why this is bad is because in Solidity numbers there's no decimals. So numbers round down. So when you divide 90 by 100, this will evaluate to zero and zero times any number will be equal to zero. So the better way to do this will be to first multiply your number x by an ID and then divide by 100. There might be some rounding errors, but this way you'll get close to 90% of x, assuming that x is maybe greater than 100.
00:03:17.340 - 00:04:15.120, Speaker B: So that's multiplying before divide. And in the real world you might see code something like this, something like calculate ratio of shares. The bad way to do it will be to maybe okay, so first of all here let's say that we have a contract and it keeps track of the total shares in the contract and the number of shares per user. And the bad way to calculate the ratio of shares is to simply divide the shares of the user by the total shares. Total shares will be most likely be greater than the shares of the user. So this will most likely return a zero. So this is the bad way to write your code.
00:04:15.120 - 00:05:02.590, Speaker B: A good way to do it is to say that 100% will be equal to ten to the 18. And then you will first multiply the shares of the user by the multiplier. Here the multiplier we define as ten to the 18. So here we're multiplying the shares by ten to the 18 and then dividing it by the total shares. You'll see code something similar to this inside the curb AMM contract. So they would multiply by some large number and then divide by another number so that their numbers wouldn't round down to zero. So that is multiply before dividing.
00:05:02.590 - 00:06:04.228, Speaker B: So the next best practice that I learned is to don't name local state variables the same. And what do I mean by this is let's say that we have some smart contract and it has some state variable. We'll say the state variable name is Total supply and we have some function. And inside this function we might declare another local variable also the same name as the state variable. And let's say that we set it to some number one, two, three and there will be a lot of code in here. And at the end of the code maybe our intention was to update the state variable total supply to four five, six. But when we execute this code, total supply inside this function refers to this local variable.
00:06:04.228 - 00:06:49.940, Speaker B: So what we're doing here is setting the local variable to four five, six instead of our intention being to set it to the state variable total supply. So this is back practice to have the same name for the local variable and the state variable. And the solidity compiler will give you warnings. So be sure to read the warnings. And the better way to do this is to just simply have a different name from the state variables and the local variables. Now I want to mention that in byper all state variables. So this will be in byper all state variables.
00:06:49.940 - 00:07:50.370, Speaker B: Start with self my state variable so you wouldn't have this trouble of keeping track of which variable is a state variable and which one is a local variable. So this is one useful feature of Piper, okay? So as a bonus, when you're dealing with peer functions, again, peer means that the function does not read any state variable or any data from the blockchain. So one benefit of using peer function is that inside the peer function you know that it's not going to touch any state variable. So there is no name collision between local variables and state variables. So that was tip number three. Let's move on to tip number four. Keep contract simple.
00:07:50.370 - 00:08:42.252, Speaker B: This applies to a lot of programming and especially also applies to smart contract programming. And the reason why you want to keep your code simple is that complex codes are hard to analyze. So it probably means that the code might be less secure and there might be bugs that are hard to find. So you would want to keep your code simple. And what are some examples of complex code? Well, it might be like inside a function it's calling many other functions and contracts, so it's hard to keep track of what's going on inside this function. So this will be a complex code. Another example of a complex code might be that the contract is trying to do many things.
00:08:42.252 - 00:09:45.670, Speaker B: For example, this contract might represent AMM, so you'll be able to swap tokens and it might also represent like DeFi lending and borrowing. So inside this AMM contract you might have other functionalities to lend and borrow and liquidate tokens. So trying to do many things inside one contract is not good practice. This is my opinion. But when I see a lot about bu functions inside the smart contract, I think it's, I think it's unnecessary complexity inside the code for view functions you can usually move it to another contract. So we'll see in a second what I mean by this. So good code will be simple contracts, it will be simple code.
00:09:45.670 - 00:10:42.390, Speaker B: And inside the contract, what I try to aim for is to do as little as possible. And if I need to ask the question do I need this function or do I need this view function inside this contract, the answer is most likely no. And the way I would know it is if I'm asking that question, then the answer is probably no. If I don't have to ask that question, then it's probably obvious that I do need that function. So that's how I decide which function goes inside the contract or not. And one thing that I always like to say to myself is Yagme, which stands for you aren't going to need it, you're not going to need that extra B function, you're probably not going to need another function inside your contract. Keep it as simple as possible.
00:10:42.390 - 00:11:36.548, Speaker B: So a good practice that I noticed in some contracts, in some D five projects, like uniswap B three, where they split some of their core logic from view functions. So they will split the logic of a price oracle into another contract. From the AMM contract. For example, you have some kind of core contract and then as another contract you have a view contract, the core contract. If there's a bug, then you can't really fix it. But if there is some kind of bug inside the view contract, then you can't throw this one away and rewrite another one and then deploy it. So I think this is a good pattern to split the core contracts and the view contracts that was keeping contracts simple.
00:11:36.548 - 00:12:31.456, Speaker B: And the next tip is to prioritize security over gas. So for example, what I mean by this is that sometimes you would see code that are optimized for gas, but it becomes really difficult to read the contract. So there might be bug, but you can't really see the bug because the code is complex. For this example here, I have some kind of loop and it's trying to optimize for gas. So if I take a look at this loop, it looks like a regular for loop. But instead of having an increment of the counter inside here, I do like an uncheck and then increment the counter inside the loop. This code is a little bit hard to read, but it does save gas.
00:12:31.456 - 00:13:28.920, Speaker B: On the other hand, the good practice will be to prioritize for code readability and security. So what you might do is write a regular for loop that everyone is used to seeing so that's security over gas. The next tip is avoid unbounded loops. And what I mean by unbounded loops here is that there is no upper limit to the number of loops. And why is this bad? This is bad because there's a limit to the amount of gas that can be inside a block. And unbounded loops means that it's going to consume more gas than the block gas limit. So at some point, your transaction will fail.
00:13:28.920 - 00:14:18.480, Speaker B: So let's take a look at some examples of an unbounded loop. Here I have a state variable called accounts and have a mapping called balances. So it will map from account to the balance of the account. And to make this array of addresses accounts unbounded, we have a function called join and it pushes an address into the account state variable. So example of an unbounded loop will be to loop over all of the accounts. And here we're just updating the accounts by adding one. Why is this bad? Well, imagine if ten accounts, if there are ten addresses in the account, then it might use certain amounts of gas.
00:14:18.480 - 00:15:28.904, Speaker B: If there are 100, then it's going to use more gas. And if there are thousand accounts, then it's going to use more gas than that and at some point you'll hit the block gas limit and this function will always fail. A better way to handle unbounded loops is to have some kind of upper bound to the number of loops. For example, here inside the input we're saying start the loop from start and end it at end and we do a loop. So this function will never be, it will never fail because we can always bound it from start to end. Another example of an unbounded loop, this is a subtle one, but let's say that we have some kind of function and then inside the function it calls another function calls test two. And inside the function test two, it takes in array of addresses.
00:15:28.904 - 00:16:59.330, Speaker B: And notice that here we're passing in a state variable address array of array of addresses. But here we're passing it as memory so what this means is that all of the addresses inside the state variable accounts will be copied over to memory. So basically we're running a for loop here. So this is an example of an unbounded loop and to show you this I wrote the test, let me try opening it loops test file and what I did was the first test I called join three times and then run the test. Next I call join ten times and then run the test. So what you'll see is that calling going back here, what you'll see is that when there are three addresses in the accounts it will use certain amount of gas but when we have ten addresses in the account it will use more gas. So I'll copy this then open my terminal and then paste it and then you can see here that test gas two.
00:16:59.330 - 00:17:54.688, Speaker B: This is a test with where we have ten addresses in the account it used up more gas. This was a subtle example of an unbounded loop. Try to avoid it. Okay, so the next one is to don't trust user inputs. What I mean by this is that if you have a function where any user can call and let's say that it takes in some kind of address of a contract and then inside it here we can see that it's calling into the token and calling the function transfer from. But since we're passing in user input, the user can put in any contract address as long as they have a function called transfer from. So, which means that they can execute any arbitrary code.
00:17:54.688 - 00:19:19.176, Speaker B: And for example, what we can do here is have a user, the user might have deployed a malicious contract and then they will call this function and inside that function transfer from that malicious user will put their malicious code inside here. For example, for this example, we just put log the message called hacked. And what will happen is that when the user calls the function deposit, it will execute and then they will pass in the address of this malicious contract. It will call transfer from and execute this code. So this is what I mean by don't trust user input and I cannot remember from the top of my head but I do remember that there were several DeFi hacks where the user were able to put in their contract address to do some kind of hack. The next tip is checks effects and then interaction. So what I mean by this checks means that first check the inputs effects means that next update the state variables or do some kind of change inside your smart contract.
00:19:19.176 - 00:19:59.224, Speaker B: And interaction means call other accounts or contracts. So the best practice here is to first check user inputs next to update your state variables and lastly to call other external contracts. So first of all, let's take a look at a bad example. A bad example would be to see over here called withdrawal bad. Notice that instead of checking, it does no check. And then next it calls into another contract what transfers the e to message sender. And then lastly it updates the balance of message sender.
00:19:59.224 - 00:20:24.432, Speaker B: This is the effect part. What you want to do instead is to have something like this check effect and interaction. The check will be to check the user input. For example, amount is greater than zero. Next will be the effect. So updating something inside this contract. Here we're updating the balance of message sender.
00:20:24.432 - 00:21:01.524, Speaker B: And lastly to call external contract. For example, here we're sending the eve to message sender. This way. Yeah, this code is now vulnerable to reentry attack. However, this withdrawal bad is vulnerable to reengency attack. Okay, the next tip is to use reengency guards. So in the previous tip we said to use check effects and then interaction.
00:21:01.524 - 00:22:16.730, Speaker B: But this does not guarantee that your code is safe from reentrancy attack. So whenever you're in doubt, then, or at least for me, whenever I'm in doubt, I always put like a reentrancy log so that I feel safer that my contract is probably more secure. So what do I mean by a reentrancy guard? Reentrancy guard is a simple modifier that first checks that the state variable locked is set to false and then it sets it to true and then executes the code. And then after the code executes, it sets it back to false so that if there was a reentry, it would execute this part of the code, come back in and since the lock is true, this part will fail and this is how it protects from reentrancy. Let's take a look at an example. So here I have a bank you can deposit into it and you can withdraw. Notice that this function does not have a reentry guard whereas this one does.
00:22:16.730 - 00:23:06.730, Speaker B: To show you example, I wrote a hack to do a reengency and to do a Rengency run this command. So I'll be calling this withdrawal function once and if the test passes, then it means that the reengency was successful. So I'll execute this test and the test was successful. So that means that the reengency was successful. Next, I'll put a reengency lock on this function called withdraw and then we'll execute the test again. This time the test will fail because the reentry lock is protecting that function. And you can see here that the test failed.
00:23:06.730 - 00:24:04.190, Speaker B: So that's reentry lock. If you're uncertain if your contract is vulnerable or not vulnerable to reentry attack, then just put a reentry lock and feel safer with your contract. Okay, the last tip is pull over push. So what do I mean by push and pull? Push means that the contract sends ETH or token to some address. On the other hand, pull means you allow the caller to withdraw ETH or token. And why do we recommend Pull over push? Well, first of all, if you do a push it might be vulnerable to reentrancy and there's also a chance that you accidentally send it to the wrong address. So let's take a look at some code.
00:24:04.190 - 00:25:19.058, Speaker B: So a bad way of example of this will be an example of a push will be to directly sending ETH to some address. But notice that if we were to put in some wrong address here then this would send ETH to the wrong address. Another example might be to send ETH many, even though let's say that most of the addresses inside this receiver are regular users, but one of them is a malicious user and this person decides to reject all sent to this address, then this function will fail even though most of the users are regular users. So that's another reason why pushing ETH to another address is not recommended. So here's an example of sending token. A better approach is to let the user pull the token. And what do I mean by this? Well, it's going to take two steps.
00:25:19.058 - 00:26:21.754, Speaker B: First the contract approves the user to withdraw from the contract. So here for example, I have a function called Gabe and it will increment the e balance for the address too. And if for some reason we put in the wrong address then we can easily fix this. And once this e balance is incremented, the user can call withdraw ETH and this will only decrement the amount of ETH that was allocated to them. So this will be the user pulling some EF into their address. And the same example for ERC, 20 tokens, we can increment the balance of the token for address two and let the user pull token. And that completes the ten best practices that I picked up.
00:26:21.754 - 00:26:23.050, Speaker B: Learning solidity.
00:26:26.540 - 00:26:46.040, Speaker A: Amazing. That was great. And also very concise and to the point. Now people were super excited. There's two kind of common questions that came up. One is in your Pure functions example, we want to clarify if that's a typo, where it says total supply. I think it just says tota supply.
00:26:46.040 - 00:27:09.750, Speaker A: So want to see if that's where the collision wasn't coming from or was actually like a typo. So we'll get that cleared for the person who asked that question. And the second request is if you are able to share these ten examples. So the code, whether it's through a slide deck or just a GitHub repo, they'd much appreciate it because they want to themselves as well.
00:27:10.200 - 00:27:12.296, Speaker B: I'll send you the links or you.
00:27:12.318 - 00:27:19.416, Speaker A: Want me to put it on to me directly or in the chat too? And we can also communicate that to all the hackers on discord too.
00:27:19.598 - 00:27:21.450, Speaker B: Okay, I'll do that.
00:27:22.140 - 00:27:28.956, Speaker A: Well, thank you. Yeah, sorry. In case you want to address the first one, you're more than welcome to.
00:27:28.978 - 00:27:35.388, Speaker B: But yes, maybe create a GitHub issue because I think we're almost on time.
00:27:35.554 - 00:27:42.584, Speaker A: Yes, well, thank you so much and this was great and thank you for doing this thing and doing this thing super late in kind of your time zone.
00:27:42.632 - 00:27:47.360, Speaker B: Really appreciate it. Yeah, that's all right. No problem. Yeah. Thanks for inviting me. Bye.
