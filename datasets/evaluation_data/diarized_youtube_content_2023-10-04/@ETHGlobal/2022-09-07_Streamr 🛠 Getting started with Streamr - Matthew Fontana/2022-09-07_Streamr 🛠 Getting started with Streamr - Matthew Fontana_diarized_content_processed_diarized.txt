00:00:07.530 - 00:00:29.510, Speaker A: Hey everyone, welcome to this workshop about streamer. In this, in this workshop I'm going to explain what the network is, how to use it, jump into some code, give you some ideas for what to hack. So let's start off with some background theory.
00:00:29.510 - 00:00:55.870, Speaker A: So the network is a pub sub messaging system. So off chain communication, it's not a blockchain, but it's built with a lot of the primitives of ethereum that can kind of natively be sewn into your ethereum based decentralized application. It's fast and scalable.
00:00:55.870 - 00:01:39.500, Speaker A: So typically live data flows through the Internet via Google cloud, some kind of big data center where you hand over your credit card details and they provide this decoupling service between publishers, which is usually your app or yourself, that is publishing data. Instead of making direct connections to all your subscribers, you just push it to one centralized point, which ends up being some company's data center and they handle the data propagation with the streamer network. That middleman is replaced by a topology of nodes that can be run by anybody.
00:01:39.500 - 00:02:06.520, Speaker A: And yeah, there's quite a diversity of the types of nodes that can run on that run the streamer node software on the network. And yeah, here's a few examples here. So what is the unlock here? So, as I mentioned, it's a fast and scalable messaging network for web three.
00:02:06.520 - 00:02:32.560, Speaker A: All the good things that come from decentralization are here, censorship resistant and permissionless, of course, secure. So every message on the network is cryptographically signed by the ethereum private key. There is end to end encryption if you want it, but you can also have open data streams as well.
00:02:32.560 - 00:03:04.050, Speaker A: And the one part so this is classical networking technologies, the data flows through WebRTC, if you're familiar with that PTP technology. But the one touch point that we do have on the blockchain is the on chain stream registry and that holds basically the accounting of the streams and their access control policy. So which ethereum identities can publish and subscribe to the streams.
00:03:04.050 - 00:03:21.790, Speaker A: So it's on polygon at the moment and it's the source of truth for the network. It's a serverless technology. So the nodes run anywhere that JavaScript runs, including the browser, and it's free to use as well.
00:03:21.790 - 00:03:40.270, Speaker A: So there is one very small cost of ascent or two to create the stream on the polygon blockchain. And any sort of updates to the access control will require a central two of matic. You can reach out to us for this matic if you wish.
00:03:40.270 - 00:03:57.746, Speaker A: End call is to sponsor this transaction, so then it would be purely free to use. But at the moment there is that one tiny little cost up front of a cent, basically. And you can monetize these data streams if you wish.
00:03:57.746 - 00:04:31.970, Speaker A: So owning your own data is a cliche, but on the network it's technically provable that you do own your own data and you can sell access to that data if you wish. And we've built what's called well, there is a framework available called the Data Unions Framework which is a crowdsourcing and crowd selling way of monetizing that data. It is external to streamer, but if you do build a data union, then that's totally eligible for any sort of hackathon.
00:04:31.970 - 00:05:08.590, Speaker A: Okay, so then there is the Access Control, which I mentioned. So Ethereum identities can have anyone or any combination of these permissions which grants them some sort of role in the stream. So what can you use this network for? So there's kind of two key use case scenarios that I'll talk to decentralized communication and data sharing and monetization.
00:05:08.590 - 00:05:39.190, Speaker A: Communication is any sort of generalized messaging between humans, machines, scripts, IoT, objects, nodes in a decentralized network, anything you can imagine. This bi directional messaging can all flow through the network. One cool use case of course is quite hot at the moment is chat over these web three networks.
00:05:39.190 - 00:06:03.950, Speaker A: You can do this natively on streamer very easily. So this is a chat app that we've been building, theorem based. Every single message is cryptographically signed by the MetaMask account and the group chats are essentially listening or are controlled by the access control of the streams.
00:06:03.950 - 00:06:30.538, Speaker A: So every chat room is a stream and the participants in that stream are publishers and subscribers as per the access control of the stream onto data sharing and monetization. So you can share open data about absolutely anything. It's a great thing to do because you can build the developer ecosystem on top of this data.
00:06:30.538 - 00:06:49.706, Speaker A: And essentially data wants to be free. And if you can make data accessible to as many people as you can, there's a lot of public good benefits to this. But as well, you can also monetize the data if you wish.
00:06:49.706 - 00:07:06.870, Speaker A: A subset that you consider to be kind of premium. You can make pay to access data streams that earn revenue when someone buys access. A time based subscription or a permanent subscription to some sort of data stream.
00:07:06.870 - 00:07:51.860, Speaker A: Taking that a step further, you can create very expressive data dows that allow anybody in the world to contribute their data into a shared firehose of data that has this great data density that could be used for all sorts of kind of AI and machine learning. And these Data union smart contracts, they're programmed in a way that when access is sold, those funds go back equally to everybody that helped contribute to that data set. So it's a way to incentivize crowd data.
00:07:51.860 - 00:08:12.246, Speaker A: So some hackathon ideas. So group chat on Lens Protocol would be really fun. So Lens Protocol is like this NFT Social graph and we have an instant messaging group chat.
00:08:12.246 - 00:08:33.890, Speaker A: So combining the two making the Access Control Policy talk to the Lens Protocol is actually quite low hanging fruit and it would be pretty amazing to accomplish in this hackathon. So that would be awesome. Any sort of decentralized wallet to wallet communications.
00:08:33.890 - 00:08:56.470, Speaker A: So if you know wallet connect, you can kind of do the same thing with Streamer very easily. You can set up that decentralized secure pipeline between a wallet and adapt that are not necessarily in the same environment. You can do those signed transaction and request communications over a stream.
00:08:56.470 - 00:09:15.322, Speaker A: Then there's off chain multisig chat and conviction voting. So. Think Gnosis safe here? You have a bunch of multisig participants that are looking to sign proposals, but they need to talk through those proposals.
00:09:15.322 - 00:09:37.346, Speaker A: So having an off chain chat where you're absolutely certain that the communication is happening over a secure channel and they can kind of get this pre conviction before the final on chain vote is very useful. So that would be awesome. Decentralized network communications.
00:09:37.346 - 00:10:04.362, Speaker A: So this is a big one, but blockchains can actually leverage Streamer to propagate the blocks of their chain on streamer. This is a very legitimate use case. And not only this, but in other decentralized or peer to peer protocols, there is often a need for some sort of signaling server.
00:10:04.362 - 00:10:49.030, Speaker A: Signaling server adds centralization, but if you do the signaling through Streamer, then you can combine two decentralized networks and have an end to end decentralized experience. Another interesting one is to validate decentralized wireless networks with your own proof of coverage algorithm. So we've seen folks from the Helium community, in the Mappers community specifically that are very interested in bringing in that coverage, that real world coverage, data network coverage data into the Streamer network.
00:10:49.030 - 00:11:19.586, Speaker A: And it's a fantastic technology choice as the data transport to bring into the proof of coverage oracles of say, the Helium network or some other decentralized wireless network. So this is another fun open data use case, essentially. And then there are others like your MetaMask excuse me, your metaverse character is moving through the metaverse.
00:11:19.586 - 00:11:34.902, Speaker A: It's creating this data exhaust. So maybe push that onto Streamer and potentially monetize some parts of it. One that's not included here that probably should be is some notifications protocol.
00:11:34.902 - 00:11:48.474, Speaker A: That would be fantastic. It's quite similar to Chat, but it's essentially a mechanism. You can have the Streamer network as the data transport layer for any sort of scalable notification.
00:11:48.474 - 00:12:13.314, Speaker A: So if you wanted to send a notification out to a million subscribers that all have a certain token in their wallet, this can be very easily accomplished using Streamer. You could build multiplayer gaming on Streamer as well. It's sharing the state, sharing the position of characters.
00:12:13.314 - 00:12:44.720, Speaker A: We've had chess apps built in the past on Streamer and you can think of all different ways to include a Streamer network there. And you can also build these data unions, which I mentioned, which are these monetizable pay to access crowdsourced, firehose data streams. Okay, so that was the start and let's get into some code and some real world examples now.
00:12:44.720 - 00:12:59.650, Speaker A: So I'm on the Streamer network website here. Streamer network in the top right there is use core which is our connect. So I'm going to sign in on MetaMask.
00:12:59.650 - 00:13:17.370, Speaker A: This is the polygon network, so it might ask you to change if you're on the main net. And here I see my dashboard, a list of my streams that I've already created. And for this session, let's create a stream.
00:13:17.370 - 00:13:38.100, Speaker A: I'm going to call this ETH online, two, three, four. If you have a ENS identity, you can also see it here. And then your stream ID will be, for example, Mattfontana Ethonline, two, three, four.
00:13:38.100 - 00:13:53.270, Speaker A: But I don't have an ENS identity on this MetaMask account, so I'm just going to create it as is. As mentioned, this is an onchain transaction. It'll cost one cent and it'll take a few moments to mine.
00:13:53.270 - 00:14:22.094, Speaker A: What I'm creating here is a stream that we can it's like a topic in PubSub, if you're familiar, and we are going to push some data into it and subscribe to that data in a different window. So now we saw the transaction was mined and the stream is created. And I can just run through quickly some of the other things.
00:14:22.094 - 00:14:35.910, Speaker A: On this page, there is code Snippets, which we'll jump into shortly. Status? Don't worry about status. This is just a UI thing.
00:14:35.910 - 00:15:00.538, Speaker A: Most streams remain gray, so you don't need to worry about making them green. We have a live data preview, so live data points will flow through here, emphasis on live, so make sure they're live data storage. So streamer does offer storage for streams, but it's a little bit centralized at the moment.
00:15:00.538 - 00:15:14.298, Speaker A: So we only have one node here and you can choose how many days the data will be stored for. So this is another transaction. It's totally optional, but it does give the resend ability.
00:15:14.298 - 00:15:31.640, Speaker A: So if you need the last message of a stream, then you can get that there and we will be decentralizing parts of this in the future. And then there's stream partitions, which is like a sharding for very high volume streams. You don't need to worry about this.
00:15:31.640 - 00:15:50.574, Speaker A: Okay, so next let's jump into a project that I have started. So this is very simple. So it's just a node NPM project.
00:15:50.574 - 00:16:06.706, Speaker A: So you run NPM init and NPM install streamer client. And I have the M environment package as well, just to help me out storing a private key. But that's it.
00:16:06.706 - 00:16:18.930, Speaker A: That's it. Just make sure this streamer client version is at least six and we are good to go. So I have two scripts here, a publisher and a subscriber.
00:16:18.930 - 00:16:37.340, Speaker A: And I'll make this a little bigger. So what I'm going to do is going to go into our code snippets here. I'm going to copy the light node JS and let's paste it into the main function.
00:16:37.340 - 00:16:51.070, Speaker A: So let's have a look here. So we've already included this section, so we don't need that. It's just requiring the library.
00:16:51.070 - 00:17:27.434, Speaker A: And then for the private key, I'm pulling this from the environment file so process M private underscore key is how I've named that variable inside that file. And you can look through the NPM package for docs on how to use that if you are unfamiliar. Otherwise, you can just paste in the private key from the MetaMask account that you were using and that's totally fine.
00:17:27.434 - 00:17:35.050, Speaker A: As well as a string there. So this is our publisher script. So we don't need the subscriber.
00:17:35.050 - 00:18:02.280, Speaker A: I'm going to cut that out and paste it into our subscriber function for now, back to the publisher. Let's just have a quick look at this. So instead of just sending one message, let's send a message every second with the set interval function.
00:18:02.280 - 00:18:16.998, Speaker A: Great. So the publisher script is ready. So this brings in the streamer client package.
00:18:16.998 - 00:18:31.920, Speaker A: So it's actually running a light node. As part of your application, we're authenticating with the private key that created the stream. And then we're calling streamer publish stream ID.
00:18:31.920 - 00:18:49.350, Speaker A: Stream ID is this guy here. And we are publishing a data point, Hello World. So at the moment, data points on streamer need to be of JSON type.
00:18:49.350 - 00:19:13.680, Speaker A: So this is Field Hello World as the value and we repeat this publish every second in the subscriber script, we do something pretty similar. It's actually something I've missed out here. Need to copy over setting up the object.
00:19:13.680 - 00:19:29.250, Speaker A: And so we do a streamer subscribe to this. And we need to do something with the message. So let's do something very unimaginative.
00:19:29.250 - 00:19:41.430, Speaker A: Let's console log it. Great. Okay, so now we're ready to run our publisher script.
00:19:41.430 - 00:20:05.738, Speaker A: And then we should see something happen in our preview as well. So I simply run node publisher JS and a few things should happen from here. So first we get some logging of connection into the network.
00:20:05.738 - 00:20:15.940, Speaker A: So this is very normal. You might even get some warnings from the RPC. This is all normal and fine.
00:20:15.940 - 00:20:53.546, Speaker A: But MetaMask also popped up as well on our preview screen. And what this is, is a key exchange mechanism on the network. So the publisher is basically asking this subscriber, hey, are you actually authorized to view this stream? And so MetaMask says, yes, here is my signed key which says that I'm a valid subscriber on this stream.
00:20:53.546 - 00:21:01.870, Speaker A: So I'm going to click sign. And here we are. So we see the messages flow through as a subscriber.
00:21:01.870 - 00:21:32.490, Speaker A: So that's great. And I can also show that if we run node subscriber JS, we can create as many of these subscribers as we want and they will ingest that raw stream of data. So every second, a new Hello World is being propagated from this publisher node script to our two subscribers.
00:21:32.490 - 00:22:14.034, Speaker A: So next thing I want to show you is that we have a Network Explorer. It's sometimes useful for debugging and sanity checking it's at streamer network network Explorer. I can simply paste in my stream ID and I'll click on the first returned result and it shows three nodes and so this is the publisher node, the subscriber node and it's also this browser tab.
00:22:14.034 - 00:22:33.870, Speaker A: So this browser tab is a light node in the decentralized network and it's helping to propagate data around. So it shows these three nodes in Zug, in Switzerland, which is where I am at the moment. So that is publishing and subscribing.
00:22:33.870 - 00:22:55.482, Speaker A: You can do a lot more with the streamer client. So I encourage you to have a look at the docs play around with the access control while I'm here. One other thing that I can show you is that we can make the stream publicly readable.
00:22:55.482 - 00:23:27.930, Speaker A: So in the top right section there is this Share button, it's currently set to private. If I set it to public and save it will be another transaction but then anybody will be able to view or subscribe to the stream and in that case the end to end encryption is turned off. But you still need to be a valid publisher.
00:23:27.930 - 00:23:54.390, Speaker A: So if you want to add new publishers you can go to this share section and add in publishers or you can do this through the streamer client as well. It's quite straightforward to change the permissions and do all sorts of things here. So the next application is the streamer broker.
00:23:54.390 - 00:24:51.690, Speaker A: Now you don't need to use this of course, but if you are bringing in data from a different programming language or device that cannot run JavaScript or some sort of node environment, then you will need to run a broken node and open up an interface. WebSocket, Http and MQTT interfaces are all available and essentially from your application or device you start pushing into these interfaces of a broken node that you are running and that becomes the entry point into the streamer network. So we have docs here, streamer network, docs, streamer network, installing a broken node.
00:24:51.690 - 00:25:15.650, Speaker A: You can run the broker node through Docker, image or NPM. You can even stake some tokens on here and earn some rewards. But the developer use case is to then interface into that broker node and use it as an access point into a network into the network.
00:25:15.650 - 00:25:43.180, Speaker A: So that's the streamer broker and we also have the CLI tools. So this is a handy debug tool so you can do in the command line streamer, stream, subscribe and then your stream ID for example. And that can help you debug any sort of issues you might have.
00:25:43.180 - 00:26:14.420, Speaker A: Okay, so that is the streamer client, the streamer broker. Next I wanted to show you our GitHub, it's at streamer dev. So the action happens in our network monorepo repository and you can see the packages here if you want to dig deeper into the code.
00:26:14.420 - 00:26:39.660, Speaker A: And we also have an examples repo. So if you have some trouble getting started, we have some ready made flows and tutorials here to help you out. Lastly, I can give like a quick little demo of the chat app.
00:26:39.660 - 00:27:01.170, Speaker A: So every single message here, as I mentioned, is being signed by the MetaMask wallet. We have a clever way of doing this where we have a hot wallet stored into the local storage of the browser. But, yeah, it's fully decentralized.
00:27:01.170 - 00:27:18.490, Speaker A: And, yeah, you can build quite amazing things on this. Token gating is something that we're working on. But if you want to build your own version of this, this is also really awesome.
00:27:18.490 - 00:27:38.960, Speaker A: And this would be very useful. Or the way to connect to the Lens protocol with their NFTs. So these chat rooms could be gated by a Lens protocol NFT, for example.
00:27:38.960 - 00:27:57.910, Speaker A: And lastly, to mention, there is the data union Dao, which builds on top of Streamer. So if you build a data union, it's very much a valid submission. And big businesses have been built on this framework.
00:27:57.910 - 00:28:25.354, Speaker A: Swash is a browser plugin. Demo is a physical Raspberry Pi style device that you connect into your car and ingests the car data and finds useful ways of sharing that data. And so, yeah, this is the smart contract flow for these data unions.
00:28:25.354 - 00:28:58.578, Speaker A: It's a bit too much to go into this session, but I guess the takeaway is that anything is possible with these composable smart contracts that interface with the network and access control policies. Yeah, so I think that's about all. Hopefully you've learned a few things about Streamer and yeah, we can see you in the discord.
00:28:58.578 - 00:28:59.380, Speaker A: Okay, thank you.
