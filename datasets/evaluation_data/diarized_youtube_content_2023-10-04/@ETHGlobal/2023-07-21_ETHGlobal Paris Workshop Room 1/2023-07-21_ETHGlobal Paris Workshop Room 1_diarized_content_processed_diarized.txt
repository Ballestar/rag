00:00:01.690 - 00:00:42.860, Speaker A: Oh, something's doing something. I see something over. Yeah, just say that you're and then because I just killed the intro slide because it was I have I have this one, too.
00:00:42.860 - 00:05:31.450, Speaker A: All right, bonjour. I sent some winners in here for the hackathon. Just a few.
00:05:31.450 - 00:05:40.492, Speaker A: So my name is Bryce. I'm part of the core team of Ethereum Attestation service. So my role is really around product development, product design.
00:05:40.492 - 00:05:45.612, Speaker A: I do some of the front end dev stuff. And then we also have Steve here. I'll let Steve do his intro.
00:05:45.612 - 00:06:11.412, Speaker A: I'm just the CTO full stack dev for EAS. And so today, what we're going to go through is we're going to spend the first couple of minutes just explaining why we built EAS, and then we'll go through some examples that have been built, and then we'll really spend a lot actually making some schemas together so you get a better idea of how to start using AAS for this hackathon. We'll also give you some inspiration of some ideas that could be hacked with and go from there.
00:06:11.412 - 00:06:26.860, Speaker A: We want this to be interactive, and I know we probably won't cover all the questions that you have, so we will be at our booth to help interact with you throughout the rest of this weekend. So how many of you know what Attestations are to start? Nice. Good.
00:06:26.860 - 00:06:38.336, Speaker A: It's a newer primitive that is catching a lot of the narrative today. And so we're excited to introduce a little bit more about how we see them. So Attestations are simply just a digital signature of some structured data.
00:06:38.336 - 00:06:51.284, Speaker A: And that might seem pretty abstract, right? Like, okay, about what? Right. So we're going to go into that. What we were noticing in the ecosystem is that there was a lot of identity protocols being built.
00:06:51.284 - 00:07:20.750, Speaker A: And while EAS isn't distinctly an identity protocol, what we were recognizing is that there's a lot of projects that were trying to solve digital identity because it can unlock so many new and powerful use cases. And so we were thinking, well, with all this fragmentation as devs, we have to learn all these new protocols, right, just to try to come up with a more comprehensive view of what an identity is. So each of these entities are creating their own type of Attestations, but none of them are really communicating with each other.
00:07:20.750 - 00:07:42.740, Speaker A: And so we were thinking, well, what actually is identity? What was your first identity? And so we went through that kind of first principles approach, and we're thinking, well, when you're born, you didn't have an identity, and then you did. So what happened? It's when your mom named you, right? She said, this is my child, Bryce. And then throughout life, other entities started testing about different aspects of who you are.
00:07:42.740 - 00:07:55.892, Speaker A: The doctor could have attested to your date of birth. Your identity card could have been attested to by the government you go to school. And the teacher attests to your grades, your employer, attests to your job and your skills.
00:07:55.892 - 00:08:05.080, Speaker A: And you start also attesting to other entities. You attest to the friends that you like, the food that you like. So you're not only receiving, but you're also issuing Attestations.
00:08:05.080 - 00:08:26.448, Speaker A: And so we realized you can actually represent identity as an aggregate of Attestations about someone over time, or an entity over time. And so if you actually want to solve for digital identity, it's really difficult to start with just a service or a protocol that just focuses on that. We first have to start as a base layer where any entity can make Attestations about anything.
00:08:26.448 - 00:08:38.576, Speaker A: Those could be identity related or it could be much more. So that's what we built. We built an open source infrastructure, public good for making Attestations on chain or off chain, so it's completely open source.
00:08:38.576 - 00:09:03.196, Speaker A: We have an SDK and a bunch of DevTools to make the process really easy. We realized that if you want to solve for trust online and using these digital signatures for things like identity or verifications of any type, it's extremely important that it wasn't monetized at the infrastructure layer. Because then one person would have some advantage or try to game the ecosystem, or someone eventually would just fork the protocol and then just take it to zero.
00:09:03.196 - 00:09:12.768, Speaker A: So we built it as a public good. So it's funded through grants. And the whole idea is to make money on top of the protocol, not from within.
00:09:12.768 - 00:09:22.964, Speaker A: So Es is completely open source, free to use. It runs on two simple smart contracts. And we'll get into some examples here, but just understand it at a high level.
00:09:22.964 - 00:09:42.184, Speaker A: There's a schema registry contract which allows you to register any structured data about any topic. So that structured data could be, imagine we're at this hackathon, right, and you wanted to Attest to the hackathon location. You might think like, okay, well, what type of data would be important? Maybe it's the hackathon name, maybe it's the hackathon start time.
00:09:42.184 - 00:09:55.496, Speaker A: So you might use, like, start time. UN 64 So you start to create the structure of the data and then the second contract allows you to make Attestations on that. We also allow you to set an optional resolver.
00:09:55.496 - 00:10:15.700, Speaker A: So if an Attestation is made on a particular Schema type, you can make it mint an NFT or do any sort of smart contract functionality based off of the Attestation being made with that schema. The traction has been pretty great. So optimism, they were building their Attestation station that you might have heard of in the market.
00:10:15.700 - 00:10:28.184, Speaker A: They actually deprecated their V zero contracts and upgraded to the EAS standard. So we're part of like the native core contracts there. With that we're deployed on base.
00:10:28.184 - 00:10:48.668, Speaker A: Any of the Op stack chains will have EAS and we're excited to continue to unite the ecosystem towards a unified Attestation layer. So Attestations that go beyond identity, that can be used anywhere, trust or verification are needed. And I'm going to be showing you some examples on our EAS scan Explorer.
00:10:48.668 - 00:11:14.648, Speaker A: It's kind of like the EAS scan for Attestations, sorry, the Ether scan for Attestations. So if we think about Attestations, a social network is simply just a network of Attestations, right? So when you post something on Twitter, that's just an Attestation of you making a statement. If someone likes that post, that's also just a like of your post, right? They're attesting that.
00:11:14.648 - 00:11:28.104, Speaker A: They like that piece of content. If they follow, reply, repost, update, all these interactions are just one entity saying something about some other subject or event. And so we built this sample UI.
00:11:28.104 - 00:11:40.370, Speaker A: It's called speaketh. And you can see that there's some posts. Is the screen size good? Yeah, go a little bit more.
00:11:40.370 - 00:11:47.760, Speaker A: You can see that there's these posts being made. Here's one from Tim. He tested GM.
00:11:47.760 - 00:11:57.380, Speaker A: And then there's a reply. There's one reply and a like. So if we inspect this Attestation underneath the hood, this is all running on Attestations.
00:11:57.380 - 00:12:21.564, Speaker A: So if we click on the Attestation record, it brings us to the EAS scan, which is like Ether scan, and we can see that Tim attested GM at this time. And then each Attestation record has its own unique identifier and that can be used to reference things. So if we scroll down, there were two other entities that referenced this UID, that they liked it, and that there was a post.
00:12:21.564 - 00:12:44.270, Speaker A: So if we click on the like, it goes to a different Attestation record and it shows this person Attesting like true and then referencing that previous Attestation UID. So you can start to build very composable networks of statements people are making. And you can do that all off chain, too.
00:12:44.270 - 00:13:06.720, Speaker A: One other use case is around content authenticity. So imagine with all this AI generated content that's being produced, how do we actually know what's being made by the creator is real? So if you've seen these TikTok videos with Tom Cruise, he's like running around smiling, doing his Tom Cruise thing, but it looks just like him. And I'm pretty technical and I was pretty convinced.
00:13:06.720 - 00:13:22.004, Speaker A: So imagine our non technical friends and family in the next year or two. It's going to be extremely scary on how people can actually trust the information that they're viewing online. And one way to do that is through a digital signature, right? Attesting to the authenticity of content being produced.
00:13:22.004 - 00:13:43.008, Speaker A: So we actually built a way for you to hash any piece of content and then attest to it. But this is just an idea of if you're exploring some projects for this hackathon, thinking about attesting to the authenticity of information and building graphs around that is a unique idea. This is an attestation record of fake Tom Cruise.
00:13:43.008 - 00:13:55.536, Speaker A: I actually just changed it in the UI. So this isn't his ETH address, but it's Tom Cruise ETH. Attesting to a hash of his content and then people can verify that content against the hash independently.
00:13:55.536 - 00:14:16.920, Speaker A: This could all be done through a really pretty UI, but the idea is having a digital signature from an authority like a Tom Cruise saying this is my content. If you see us by the booth we're showcasing, this is an open source app that's part of our repo that you can access. You can fork it for this hackathon if you'd like.
00:14:16.920 - 00:14:29.816, Speaker A: It'll show you how the SDK works in pretty good detail, but allows you to attest to people that you meet in real life. It's called Metirl.org and if you want, we'll be down at the booth.
00:14:29.816 - 00:14:51.990, Speaker A: But you can scan this and it'll take you to Metirl with my ENS on there and you'll need to make a digital signature with that. So you just attest, hey, I met Bryceallen ETH and then I make a two way Attestation confirming that. So on that Attestation record, what you'll see is this is actually an off chain Attestation that was made public.
00:14:51.990 - 00:15:09.896, Speaker A: There's a UID and then a couple of timestamps here. And so one thing with off chain Attestations is that they don't have a verifiable timestamp because there's no consensus from the network that says this existed. And so what we've done is we took the UID, right? And we just timestamped that on chain.
00:15:09.896 - 00:15:33.612, Speaker A: So you can basically timestamp an off chain Attestation on chain giving it proof of existence that it was seen, so it gives it a more trustworthy historical record of it. So here's DAC attesting to me that we met IRL True and then I re attested to him and I can show you that in a second. And then from this type of data you can start to build these pretty cool like social graphs.
00:15:33.612 - 00:15:42.432, Speaker A: This was actually one built by Kelvin from the Optimism team. It's called Coolgraph ETH catalog. I'll actually load it here, but this was people are just Attesting.
00:15:42.432 - 00:16:01.288, Speaker A: This is kind of a mimi one, right, attesting to cool people. So they were walking around just attesting to people and then other people at the event were attesting to each other as well. But you can start to see this pretty cool interactive graph of these nodes that were attesting Cool to these other entities, these other ENS addresses.
00:16:01.288 - 00:16:16.560, Speaker A: And then you'll see like this one node over here is receiving a lot of Attestations. I'm not sure if you can see it through the color, but this one is receiving a bunch of Attestations coming in, but no Attestations are going out. And so oh, it's actually this one.
00:16:16.560 - 00:16:51.292, Speaker A: This one has more, but that's Vitalik's address, right? He's receiving cool person Attestations but not issuing any. So you can start to see that there's all these nodes that kind of hang out outside of the network, which if you think about aggregating Attestations for silver resistance, you can start to see these nodes that kind of hang out alone, right? So if someone issued like 1000 new addresses and they were just attesting to each other, if they're not actually a part of the trusted network graph, then you can start to wait them however you'd like. So this was the actual Attestation record.
00:16:51.292 - 00:17:05.696, Speaker A: It was Kelvin attesting to Vitalik true on chain with the UID. And then the schema that was used was called Cool Person. Private data is extremely important, especially if you're working on identity related things.
00:17:05.696 - 00:17:17.536, Speaker A: It's really important to think through what actually needs to be on chain or not on chain. So we built a way to attest to basically a merkel route hash on chain. And then you can selectively disclose data against that merkel route.
00:17:17.536 - 00:17:45.388, Speaker A: That could be more privacy preserving things. So this is kind of an alternative to like a ZK proof, but it's just allowing you to attest to one entity attesting to like, let's say it's a document verifier for your driver's license, right? They could hash all the different fields on your driver's license attest to the merkel route and then give you that data. And then you could give people leafs of that data to selectively validate against the merkel root after.
00:17:45.388 - 00:17:53.010, Speaker A: So it kind of looks like this here's the merkel root hash. You get approved, you verify against it. I can show you how this works downstairs too.
00:17:53.010 - 00:18:03.244, Speaker A: So there's a lot of use cases that can be built. We have a use case sheet at our booth if you're looking for some inspiration. But Attestations are not an identity protocol.
00:18:03.244 - 00:18:26.600, Speaker A: You can do way more than that with it because it unlocks a very composable and interoperable network. So you can build registries anytime you need to prove compliance in a process, notaries proof of anything like proof of attendance or proof of solvency, things like that. Anytime an entity needs to use the digital signature to build some sort of trust in an interaction is when Attestations are valuable.
00:18:26.600 - 00:18:42.480, Speaker A: So here's some ideas that you could hack. We're not judging against these, but just to give some inspiration, hopefully you can think, hey, if I could do this, perhaps I could also do something else. So social graphs, knowledge graphs, dynamic NFTs based on Attestation data.
00:18:42.480 - 00:18:59.510, Speaker A: Civil resistance, zero knowledge attestations generating an Attestation based off of. So generating an Attestation, then generating a proof off of that Attestation would be really cool. Attesting to roles kind of get the idea there.
00:18:59.510 - 00:19:12.212, Speaker A: So one other thing. Are these private attestations? I'm going to make one really quick. So first to start, if you want to make a schema, you can interact with the SDK pretty easily.
00:19:12.212 - 00:19:44.950, Speaker A: But if you want to do a no code way, if you go to the EAS scan on the chain of your choice, then you can use this no code builder. So it could say like event name and maybe this is just a string, but you can choose the Abi in the field type that you want and so I'm going to make just this one make a statement and it's just going to be a recipient is to no one. But I'm just saying, nice chatting with you all.
00:19:44.950 - 00:19:58.200, Speaker A: And one core thing with an attestation is you can also apply an expiration time. So if you want them to automatically revoke, that's possible. And so I'm going to make this off chain which is just a seven one two type signature.
00:19:58.200 - 00:20:25.330, Speaker A: So I just signed it and it's completely encoded in the Uri fragment of the URL and Oops. And you can store them wherever you want locally, you can store them in a centralized place, pass them portably, but EAS doesn't even know that this existed. But there's a lot of really cool things you can do with private off chain access as well.
00:20:25.330 - 00:20:51.700, Speaker A: So we have a few minutes left but would love to hear kind of your reactions and feedback questions. Go for it. How would you address things that are like option, let's say, do you want to answer because I've been talking a while.
00:20:51.700 - 00:21:31.006, Speaker A: So in the case of a university getting an attestation from a reputable entity, you would actually want that attestation from the university or from someone that's capable of verifying university degree. So the value of the attestation is based on who actually attests. So if I attest that Bryce has passed KYC, it might not mean much to most people, but if Coinbase does, then it would you could create a schema structure for the diploma or types of whatever information is important and then the digital signature would be made by a trusted authority on that data type.
00:21:31.006 - 00:21:56.662, Speaker A: So the schema matters less. The person who's signing the data is what gives the attestation value, unless there is a resolver or a hook on the schema. Another question, does the chain really matter? In the case of off chain attestations, does the chain ID really matter? No.
00:21:56.662 - 00:22:24.350, Speaker A: Right. Technically as far as bringing off chain attestations on chain then yeah, you can actually read any EIP seven one two signature and just care about whatever chain ID you want or none. So the Met IRL app that we showed you for a testing that people met is an off chain attestation on mainnet.
00:22:24.350 - 00:22:30.900, Speaker A: So zero gas, but the contracts are on Mainet. But we are also on chain and off chain. Yes.
00:22:30.900 - 00:22:49.330, Speaker A: The on chain attestation data is public. Correct. So if you're focusing on things like identity and stuff then you should think either to use private data attestations right, or go completely off chain.
00:22:49.330 - 00:23:09.226, Speaker A: Just make sure you're not putting actual private data on chain. So you might want to put private data off chain and pass an off chain attestation to some entity where they can share it on a need to know basis. But in general if you're going to put something on chain then you maybe want to put some sort of hash that has some sort of salt with it so no one can break it.
00:23:09.226 - 00:23:16.880, Speaker A: So you wouldn't want to actually put any private data on chain? That's not what we want to do at all. We want to prevent people from doing that. No private information.
00:23:16.880 - 00:23:44.956, Speaker A: Yes. So we actually do have a tool on the Explorer. So you can verify off chain Attestations using our SDK, or you can drop any Attestation file directly into our UI, and it'll verify using the SDK in the UI.
00:23:44.956 - 00:24:23.090, Speaker A: Yeah. So if we download well, so this raw data that you can see here, you can just have that and then drop it into the verify off chain Attestation, then it'll see if it verified or not, or just use the SDK. Any other questions? On off chain or on chain? In the back? Can you say that a little bit louder? You said how do we compare to Verifiable credentials? Okay, so Verifiable credentials typically follow the W three C standard.
00:24:23.090 - 00:24:33.700, Speaker A: The W three C standard was built not related to blockchain technology. So it has a lot of data. Right.
00:24:33.700 - 00:24:52.008, Speaker A: So a lot of off chain protocols today, like Disco and others, will use Verifiable credentials. And I think that has a lot of value towards web two interactions and stuff. But W three C standards, you can also create dispute records and things with Attestations in different ways.
00:24:52.008 - 00:25:16.988, Speaker A: Yeah, so the difference is that Verifiable credentials were made before blockchain, and they have like a ton of data that you wouldn't want to actually put on chain. And also, there's no such thing as a schema registry for Verifiable credentials. So when people are using Verifiable credentials to Attest about things, they've never really thought of any kind of schema registry where any entity can register a topic, and then that topic gets its own unique identifier.
00:25:16.988 - 00:25:45.150, Speaker A: And so we think that this is much better for being able to decentralize all these kind of interactions. Another advantage to think about is also the composability. So if you were to make an Attestation, not exactly as a W three C, Verifiable credential, but if one Attestation is made and you want to be composable with things outside of identity, maybe it's like authenticity of content signatures and things like that, then it allows you to do that in a much easier and faster way.
00:25:45.150 - 00:25:59.904, Speaker A: Thumbs up from the front. So, he's a testing time is up, but if you have questions related to this, would love to show you kind of how the Merkel tree approach works. But there's a lot of cool things that you can build.
00:25:59.904 - 00:26:14.630, Speaker A: Really excited to see just the progress from the previous hackathons. A lot of cool things can be built using AAS as an alternative to NFTs and things like that. So if you're thinking about NFTs for verification, think maybe an Attestation could be used instead.
00:26:14.630 - 00:26:48.792, Speaker A: We get 25 minutes. How does that work? Oh, five minutes after, I guess we still had five minutes. He told me five minutes.
00:26:48.792 - 00:26:54.130, Speaker A: He came up with a five minute, like, a minute ago. How you doing? That does make sense. It's okay.
00:26:54.130 - 00:28:05.692, Speaker A: Where you can oh, you cannot it has to be the are these the only microphones? There's no holding microphone. Yeah, that's fine. Yeah, that's we'll be there.
00:28:05.692 - 00:28:55.980, Speaker A: She'll be there. Testing, testing, testing, testing. Can everyone hear this? Okay, thumbs up.
00:28:55.980 - 00:29:15.292, Speaker A: Yes. Is there a kicker or not? Mexico. I need to have space to be a soul.
00:29:15.292 - 00:29:28.284, Speaker A: Could you give me yes, because I have no idea. Wait. Yes.
00:29:28.284 - 00:30:24.140, Speaker A: Wait a minute, because I'd like to close some before bring up the slides to start. Okay. It but I feel that there'll be a monster if it is visiting my face.
00:30:24.140 - 00:30:36.990, Speaker A: You you yeah. Okay. Yes.
00:30:36.990 - 00:30:54.010, Speaker A: You can share now. Sure. All right, I think we're ready to get started once we have visuals working.
00:30:54.010 - 00:31:03.304, Speaker A: All right, let's go. Hi, everyone. Welcome to our presentation.
00:31:03.304 - 00:31:18.108, Speaker A: So today we are going to talk about building secure cross chain applications with Chainlink CCRP. So we're very excited to be here today. My name is Harry Papacrusiu.
00:31:18.108 - 00:31:35.104, Speaker A: I manage the developer advocates at Chainlink Labs. Today I'm joined by my colleague Sol or solange and also with Chainlink co founder and CTO, Steve Ellis. So we're very excited today because we launched a new product on Monday called Chainlink CCRP.
00:31:35.104 - 00:31:50.392, Speaker A: It's been in two years in the making, and we're very excited to talk to you about it today. But first, we're going to talk about the bounties, because that's why everyone's here for so we have two tracks. In terms of our bounties, we have a track specific to CCRP.
00:31:50.392 - 00:32:07.244, Speaker A: So $2,000 for the best three projects that use CCIP in their submission. And we're going to talk about CCIP in just a couple of minutes. However, we have $1,000 for the four best projects that use another chaining service in their submission.
00:32:07.244 - 00:32:15.100, Speaker A: Right? So if you're building a DFI app, you can use data feeds. If you need randomness, you should look at VRF. If you want to do API calls, you should look at functions.
00:32:15.100 - 00:32:29.080, Speaker A: And if you need to automate your smart contract calls, et cetera, you should look at automation. So we're not going to talk about those services today because we only have 25 minutes. However, I urge you to go to the chainlink docs at Docs Chain Link and check them out.
00:32:29.080 - 00:32:37.908, Speaker A: So let's go. So, introducing CCRP. So before we introduce CCRP yeah, that is a bit bright.
00:32:37.908 - 00:33:08.004, Speaker A: I want to talk about the cross chain smart contract, because when everyone talks about smart contracts, it's usually in the context of a specific chain. But what a cross chain smart contract is, when you have smart contracts deployed on multiple blockchains, two or more, and they all talk to each other across each of the networks at the protocol level to create a single unified application that is the cross chain smart contract. And that is what a cross chain protocol such as CCRP enables you to do.
00:33:08.004 - 00:33:41.864, Speaker A: So what can you do in CCRP? So the chainlink cross chain interoperability protocol launched on Monday, it's now live on testnets for you to use in your submission right now. So Sepolia, Arbitrum, optimism, avalanche, polygon, and you can use it for any kind of cross chain need from sending tokens or so you can use CCIP to send messages from one smart contract on one blockchain to another smart contract on another blockchain. You can use it to send tokens.
00:33:41.864 - 00:34:02.644, Speaker A: You can send tokens from a wallet on chain A to wallet on chain B, wallet on chain A to smart contract on chain B or smart contract on chain A to wallet on chain B. And you can do what are called programmable token transfers, which is basically combining a message and a token in one. Let's move on.
00:34:02.644 - 00:34:35.452, Speaker A: So what are some cool things that you can do with CCRP? You can send tokens, like we said, if you're building DeFi apps, you can use collateral on one chain and send it another chain and make it available on a DFI protocol or a DFI smart contract on that chain. And what CCRP does is it enables what I call true Web Three DFI composability, right? So when we build DFI apps and we talk about money, Legos, it's always in the context of one chain. So you have composability on ethereum, avalanche, optimism.
00:34:35.452 - 00:35:08.970, Speaker A: But with CCRP you can take all the DFI protocols and have composability across the entire Web Three landscape where a DFI Dex on polygon, you can combine that with a lending and borrowing protocol on Arbitrum, right? So DeFi composability across the board, you can do cross chain NFTs, can mint an NFT on one chain, make it available on that address on multiple other chains. You can combine the cool features of account abstraction and you can add a blockchain abstraction layer to that as well. Have a think about that.
00:35:08.970 - 00:35:20.460, Speaker A: Gaming is really cool. You can have game assets available on multiple chains. And when I play games at home on Xbox, a lot of the games I can play against people on PC, web Three games should not be any different.
00:35:20.460 - 00:35:31.760, Speaker A: Like, let's say you're building a turn based game that's not real time. There's no reason why me on Arbitrum shouldn't be able to play a game against Steve on polygon. This is what CCIP enables.
00:35:31.760 - 00:35:55.192, Speaker A: So now you know what the cross chain smart contract is, you know what CCIP kind of is, and you think, Well, I've never built something that's crosschain before, why should I try now? Right? So I'll give you a couple of reasons. The first is we have bounties and that's why everyone's here, we've lost the slide. That 1 second reason.
00:35:55.192 - 00:36:15.148, Speaker A: And this is the most important to me, in my opinion. Right, so we've all had a great week at EthCC and it's now culated to the ETH Global hackathon here. But guess what? Everyone here is in competition with each other and everyone would love to have their project declared as one of the finalists, right? So there's going to be a lot of great projects.
00:36:15.148 - 00:36:22.080, Speaker A: I'm sure yours will be too. But you need an edge. You need something to stand out above everyone else.
00:36:22.080 - 00:36:42.810, Speaker A: And having your application as a cross chain application that you deployed on multiple chains that talks to each other across multiple chains, that's a big deal. That's going to impress the judges, not just us. And if they're looking at two projects that they love and they're not sure which one to progress, and one of them is a cross chain application and one of them is not guess which one they're going to choose.
00:36:42.810 - 00:36:59.496, Speaker A: They're going to choose the cross chain one. Sorry, go back one more time. And one more point I'll make is when you use chainlink in your project, it shows you're serious about security and decentralization and trust minimization because that's kind of synonymous with the name chainlink, right? DeFi protocols have issues.
00:36:59.496 - 00:37:14.992, Speaker A: They care about security and that you're now powered by chainlink. And again so CCRP, we think it's the easiest cross chain protocol to use as a developer. You can go forward.
00:37:14.992 - 00:37:29.576, Speaker A: Again, we've taken a lot of time to design it so that you can easily just use it with just a few lines of solidity. The billing is really easy and seamless. And in terms of developer experience and friction, we've tried to make it as good as possible so that you can use it.
00:37:29.576 - 00:37:37.492, Speaker A: And this is important because you guys are on a limited time. So we're going to talk about a bit more about that in the demo. Let's move on.
00:37:37.492 - 00:37:46.652, Speaker A: So now I'm going to introduce our friend Steve Ellis here and he's going to talk a bit more about CCIP. Thanks, Harry. Yeah.
00:37:46.652 - 00:38:11.652, Speaker A: So not only we think you should use CCIP, not only because it has the simplest developer experience and the easiest billing model to integrate with quickly, but longer term it is the most secure. And so if something comes of this hackathon project, you want to turn it into something else, you will easily be able to scale up. Use this on a production level application.
00:38:11.652 - 00:38:26.856, Speaker A: So just to walk you through some of the security that we have baked into this, so there's essentially three different steps that this goes through. You first send your message to the onramp. At this point, you kind of stop worrying about it.
00:38:26.856 - 00:38:41.936, Speaker A: You just send a message actually to the router, and the router then routes that it will get picked up by one of our decentralized Oracle networks. These are what power all chainlink products. This is the base level of security for everything that we offer.
00:38:41.936 - 00:38:55.364, Speaker A: After that, once the chain has finalized that the message gets written on the other side, the Arm network will then confirm that. Message. We'll talk a little bit more about the arm network later.
00:38:55.364 - 00:39:25.132, Speaker A: But the arm network checks that message and then essentially unlocks what the next blesses the message so it can be passed over on the next chain. So that's then unlocked on the destination chain and the executing Don picks it up and delivers the message for you on the other side. So pretty much once you there's, lots of security baked in behind the scenes, you just have to send one message to the router, gives you easy pricing quote and just to describe the arm network a little bit, the arm network is our security.
00:39:25.132 - 00:39:49.780, Speaker A: It is a complementary second don, it is a second client implementation written in rust different language, written by a different team, completely separate. So you are sure that none of the same bugs will like no bugs are going to show up on one side and they'll be caught by the other. So this watches, monitors the network, brings an extra level of security, but hidden behind the scenes from you, you won't have to worry about it.
00:39:49.780 - 00:40:01.640, Speaker A: Your applications can scale up to however much TVL you want. And so I'd recommend both easy use and long term usage. I think this is a great way to start getting involved with CCIP.
00:40:01.640 - 00:40:13.004, Speaker A: Thank you, Steve. We're pressed for time, so I'm going to move on next slide. So if you want to use token transfers in CCIP, we've got two deployed ERC, 20 tokens on all the chains that are kind of generic tokens that you can use.
00:40:13.004 - 00:40:27.436, Speaker A: One of them is a lock and mint, one is a burn and mint. So the lock and mint token, you can go to the deployed contract and mint as many as you want and it locks up tokens on chain A and then mints them on chain B. And then when you go back, it kind of does the opposite.
00:40:27.436 - 00:40:45.888, Speaker A: It burns them and then unlocks. If you want to use the other deployed generic EASC token for whatever purpose you want, the burn and mint one, it'll burn it on chain A, mint it on chain B and then backwards going back the other way. So messaging I already talked about, I'm just going to once again say you can send any kind of message you want.
00:40:45.888 - 00:41:04.780, Speaker A: It could be instructions, it could be logic or whatever for the receiving block contract to do anything for essentially and programmable token transfers. Once again, you can send tokens as well as a message to say, hey, here are some tokens and by the way, here's what I want you to do with them. Now in the other smart contract on the other chain.
00:41:04.780 - 00:41:20.252, Speaker A: So just last point for myself, the fees is gas cost plus premium. You pay in link on the source chain and you pay once you can pay in link or in native tokens for that chain or the wrapped version. So you pay on that initial transaction.
00:41:20.252 - 00:41:29.910, Speaker A: CCRP will handle the rest. It'll make sure that the other smart contract gets the transaction. Now we're going to see a demo from Sol.
00:41:29.910 - 00:41:50.908, Speaker A: Hello. Well, I love to do a hands on workshop so I love to do you doing me, but I know that I cannot do this in 15 minutes. So I will copy and paste a lot of comments for you.
00:41:50.908 - 00:42:05.170, Speaker A: I will copy and paste a lot of links and then you can do this later and our first will be around to help you. Okay, let me move on from this. And here we are.
00:42:05.170 - 00:42:29.370, Speaker A: If you'd like to get all that I'm doing, I will be here in this collaborative bed. So take a picture of this, go to this link if you'd like to follow me now or later. Okay.
00:42:29.370 - 00:42:50.540, Speaker A: And if you'd like to add your name and country here could be good as well. And first of all, I read, copy and paste some requirements for you. So to add the Fuji on MetaMask because I'm doing out today from Fuji to Sepolia.
00:42:50.540 - 00:42:55.468, Speaker A: Okay, this was my choice. We have other possibilities. I choose this.
00:42:55.468 - 00:43:18.312, Speaker A: And if you don't have Fuji here, you can add Fuji to MetaMask. You can get tokens on Fuji. You don't need to have the Link token but because we can pay fees using Link or using the Fuji but are you paying Link? So if you'd like to have Link tokens as well is this.
00:43:18.312 - 00:43:42.832, Speaker A: And my goal is to show you two different ways to do this. First using our had the Hat starter kit and then using Remix. The easiest way the had starter kit is this here and from the oh, I forgot one thing.
00:43:42.832 - 00:43:51.510, Speaker A: Yes. Let's be sure that this is working. Yes, this is the Hadhat starter kit, it's good enough.
00:43:51.510 - 00:44:04.760, Speaker A: And then from here I'm going exactly to the example three. It's not three, I am not transferring tokens. I'd like to go to example five.
00:44:04.760 - 00:44:25.824, Speaker A: No, well, but it must be open because I am in a computer that is not in the network of chainlink. Yes, but he'll be sure with this. So I'm doing the example six.
00:44:25.824 - 00:44:37.084, Speaker A: Here we are. Okay, let's edit this for you as well. Okay.
00:44:37.084 - 00:45:07.860, Speaker A: And what's the idea of example six is only to send some text, some messages and if you'd like to see another a bit complex example doing the same thing but not a message, but I did two days ago in ECC and it's transferred. I minted a token on Fuji and the token appear on Sepolia. So in the same way that I can send a message, I can send a comment to another chain.
00:45:07.860 - 00:45:46.336, Speaker A: So this is another good idea for you. So to do this now again, I will only copy and paste the instructions for you because it's this you get clone compile and we have some so important parts to show you related to encrypted environment because chainlink created developed a new way to have your environment variables in an encrypted file and how you can do this. First of all, you need to set up a password.
00:45:46.336 - 00:45:57.912, Speaker A: And every time that you are open your repo, you need to set up this. And I think this will be Swiss mo better for you. Okay.
00:45:57.912 - 00:46:18.624, Speaker A: So I'm here, I need to set up my password again. And because I did this before, I need to use the same password every time that I came here. Yes, I think I'm right.
00:46:18.624 - 00:46:25.612, Speaker A: And after this, you need to set up these variables. Okay. These three variables.
00:46:25.612 - 00:46:34.776, Speaker A: And like get your private key. I'm going from Avalish Fuji to Sepolia it. And you run this comment and set up each of it.
00:46:34.776 - 00:46:51.630, Speaker A: Okay. And following my copy and paste, if you'd like to get the URL directly from chainlist.org. It's good, it's easy.
00:46:51.630 - 00:47:00.812, Speaker A: Okay, this is another trick for you. And I have mine done. I can show you here because it's encrypted.
00:47:00.812 - 00:47:08.610, Speaker A: You can do nothing with this. And this is the example. What we need to do is this part.
00:47:08.610 - 00:47:32.240, Speaker A: So if you can follow me, we are here. So I deploy the basic message sender on Fuji and I already set up this. Okay.
00:47:32.240 - 00:47:43.458, Speaker A: You can see that this is not my contract yet. We need to wait a bit. Yes, this is my contact.
00:47:43.458 - 00:47:52.600, Speaker A: Okay. And I can share with you because maybe we'd like to see my content later. Where? Here, let's put it this near.
00:47:52.600 - 00:48:03.510, Speaker A: Okay. No, not this. I can see my keyboard.
00:48:03.510 - 00:48:11.994, Speaker A: It's so dark. Okay, this is done. Let's go to the next step that I have here.
00:48:11.994 - 00:48:24.220, Speaker A: My step is here. You need to send to fund because I'm using link, I need to fund with link my comfort. Let's fund it.
00:48:24.220 - 00:48:34.814, Speaker A: You don't need to send one link can be less. But to be sure, now I'm sending one link. We are using less than 0.1.
00:48:34.814 - 00:48:57.130, Speaker A: So I'm in the right account and I'm sending to this address, not a vax, but the link token and one link in our starter kit. You can do this in a comment as well. I'd like to use MetaMask in this point.
00:48:57.130 - 00:49:06.780, Speaker A: Okay, now I have the sender. I will go to the other chain and deploy the receiver. Here we are.
00:49:06.780 - 00:49:50.900, Speaker A: I have the comment done and in some seconds I will have the address of my receiver and I can copy the next comment for you as well, because after this, we are sending the message. Okay. And I would like to get my transaction.
00:49:50.900 - 00:49:58.730, Speaker A: Let's prepare this for you. Is the same. And let's see what happened here.
00:49:58.730 - 00:50:12.270, Speaker A: Yes, almost done. Wait a bit more. I don't know if it's my Internet.
00:50:12.270 - 00:50:38.594, Speaker A: I have another receiver that I did before. Maybe I can use it to be fast. I used this receiver before and after I have in my after I send and after I receive, I have the sender and the receiver.
00:50:38.594 - 00:50:57.070, Speaker A: I can send the message to send the messages, I need to fill the sender. This is the sender and I need to fill the receiver. Let's see if my new receiver is here.
00:50:57.070 - 00:51:09.088, Speaker A: Not yet. Let's use the receiver because I will not wait now this is the receiver and this will be my message. I change my message.
00:51:09.088 - 00:51:21.750, Speaker A: My message will be hello, Et Global Paris. And I'm paying fees in Link. Let's do this.
00:51:21.750 - 00:51:30.504, Speaker A: Oh, I need to wait. Okay, so I'm awaiting this. Let's do another point as well.
00:51:30.504 - 00:51:48.748, Speaker A: Because I told you that I'd like to do another contract using Remix. So the remix part ubgs. We have this tutorial on Remix, the cross chain tokens.
00:51:48.748 - 00:52:05.972, Speaker A: And we have, like Harry said before, we have a special token that you can use to test and to transfer to all places. I have this as well. And this is some parts that we need to have.
00:52:05.972 - 00:52:20.440, Speaker A: I create a special contract to use this that I did some part faster for you. I add my contract here because it is not on the documentation. And you can use this content.
00:52:20.440 - 00:52:35.084, Speaker A: You can copy and paste this contract because I put all the information that we need. The outers, everything is here as well. And I have the right interface and discontent that it is.
00:52:35.084 - 00:52:52.164, Speaker A: Here what I'm doing here. I'm using the howuter to do the transfer. I'm using the chainlink client, the link token interface and another interface for the token that I told you before.
00:52:52.164 - 00:53:06.344, Speaker A: Okay? And everything is set up here. This is the outer, this is the link token. This is the address of the CCAP test token and the destination chain selector where I got this.
00:53:06.344 - 00:53:27.224, Speaker A: It's important to you to understand where is this? Like this is the supported networks. And here you can see that for example, if you'd like to go to understand Sepolia, this is the chain selector to go to Sepolia. This is how we go to Sepolia to other links, I mean, on Fuji.
00:53:27.224 - 00:53:40.210, Speaker A: So this is the idea, like to go from Fuji to Sepolia. And I have these tokens that I can use in this time. Okay, and what's happened here? Oh, finally.
00:53:40.210 - 00:54:00.616, Speaker A: Okay, two minutes. I know I will send my message, but we cannot wait my message to be in the other chain because it used to have four minutes to move from one chain to another. Unfortunately, next time this guy will not talk before me.
00:54:00.616 - 00:54:06.872, Speaker A: I start myself and then you talk later. Yes. And this is my receiver.
00:54:06.872 - 00:54:23.120, Speaker A: Now can I add my receiver here? This is my new receiver and I assigned this comment. And then we can check the translator in some place. This is the messaging.
00:54:23.120 - 00:54:36.752, Speaker A: And when I got the transaction, I can check this in our CCIP Explorer. Yes, this transaction will save my life. But this is only a part of the transaction.
00:54:36.752 - 00:54:58.012, Speaker A: This is one part and we need to get the other part that is here. Okay, this is my transaction. What are you finality on the source chain and then once that source finalizes, then the Arm network will sort of bless it to pass through and it'll get picked up.
00:54:58.012 - 00:55:10.400, Speaker A: So yeah, right now we're still waiting for chain finality. This is a security mechanism just to make sure token transfers don't roll back as happens before sometimes, yes. And we have three status here.
00:55:10.400 - 00:55:29.728, Speaker A: It's certified, finalized, blessed. What is blessed? Blessed is when the Arm network the second implementation, the second client has said, has also verified that this is a separate dawn network that essentially or decentralized Oracle network that checks the one. They don't have access to move any funds.
00:55:29.728 - 00:55:47.564, Speaker A: They're purely a security mechanism. Okay, great. And the last stage will be the finalized when you really can check the other chain and see whatever you'd like to see over there can be the message for now, remember that I added this for you.
00:55:47.564 - 00:56:13.196, Speaker A: So in two minutes you can check here and see that the message is over there and why we need to wait so long time. And why is this timing? This timing comes from the blockchain's finality. So yeah, in this case it is just how many blocks deep avalanche has to be before it is guaranteed finality.
00:56:13.196 - 00:56:27.880, Speaker A: Okay, yeah. So is this I know that you have here all the contents that we need to check it now, but I know that I couldn't finish if I have you one more minute. I have 1 minute.
00:56:27.880 - 00:56:31.816, Speaker A: Yes. Okay, I have one more minute. I'm so happy.
00:56:31.816 - 00:56:47.870, Speaker A: I can go here and using the content that I share with you and I read set up it I you deployed the content just now. Here we are. I have others deployed, but let's deploy a new one.
00:56:47.870 - 00:56:58.064, Speaker A: Okay, this is my contact. You can check my contact later. No, this is not my contact.
00:56:58.064 - 00:57:06.404, Speaker A: My contact is here. So this is my contact. I need to fund my contact as well with link.
00:57:06.404 - 00:57:31.706, Speaker A: So let's go here send from not from, send it to this address and send the link again. Remember that I can pay with AVAX as well. And once it's funded, I can see, I can send the message.
00:57:31.706 - 00:57:48.180, Speaker A: Let's use the order that I did before. This is my example transfer and let's wait this transaction be confirmed. Contact interaction, confirm it.
00:57:48.180 - 00:58:05.600, Speaker A: This is the block explorer. So if I go to our Explorer and see this is the other transaction that I did now. And we are waiting for this transaction as well.
00:58:05.600 - 00:58:22.824, Speaker A: And this irre minted tokens in one chain and this will be minted in one chain, burned in one chain and appearing another chain. This is how the process let's see, the first is done. Oh, I'm so happy because now we can see.
00:58:22.824 - 00:58:41.550, Speaker A: Let's go. Let's come back here to finish our workshop here I send the message and I can go to the receive address and can see this. Okay, let's edit this for you to be sure that you can see with me.
00:58:41.550 - 00:59:15.580, Speaker A: And this is my receiving address that I changed. What my new receiver address because I changed the messaging receiver address. Where are you now? Here is the receive address and let's see our messaging and hello, it's Global Paris.
00:59:15.580 - 01:02:30.310, Speaker A: Thank you everyone. What a great thank you. What network? There's another one I want to listen.
01:02:30.310 - 01:11:54.722, Speaker A: Delightful. It it no USB needs to be yeah, it I think the most important thing is hello. Hello.
01:11:54.722 - 01:11:59.390, Speaker A: Perfect. Thank you. With normal lending platforms, you have variable rates.
01:11:59.390 - 01:12:14.070, Speaker A: They change based on how they get utilized in the market, how many people are supplying or borrowing that asset. In the case of Maker, the utilization doesn't affect the rate. The rate is actually defined by governance.
01:12:14.070 - 01:12:29.290, Speaker A: So you have kind of a nice smooth experience with rates. So you know how much as a borrower, how much you're going to be paying. We do change our rate, so it's not a fixed rate or fixed term rate as it's more commonly known.
01:12:29.290 - 01:12:50.962, Speaker A: But when it does change, first of all, you know when it's going to change and you also know what value it's going to have at the end. So this actually leads to a better experience from both the depositor and also the borrower side. So before at Maker, you could only be borrowing through the CDPs, you had a single collateralized position, you borrowed eye and that was pretty much it.
01:12:50.962 - 01:13:07.238, Speaker A: Now we're morphing into this new model where you actually have a lot more ways of interacting with predictable rates through Maker. So on the borrower side, now you have spar protocol. It's our new lending platform where you're able to have multiple collateral positions.
01:13:07.238 - 01:13:18.874, Speaker A: So you can deposit ETH and any staked ETH derivative and borrow Dai. At this predictable rate you can also be a depositor. You can deposit dai in the DSR.
01:13:18.874 - 01:13:34.958, Speaker A: This is the Dai savings rate module. Essentially we provide yield to Dai holders based on the protocol revenues allowing to, again as a depositor get this predictable rate on you. And what we are going to be showcasing today, which is the most exciting thing, is conduits.
01:13:34.958 - 01:14:03.734, Speaker A: So this is more if you're a builder, you are able to create basically a connection or interface between Maker and external protocols to actually have this rate provided to you. So you essentially get to tap in into Maker liquidity in a fully standardized and secure way. So now when we get that going on, I'm going to be showing well, Lucas is actually going to be showing how you're able to build this conduit and get that connection.
01:14:03.734 - 01:14:14.494, Speaker A: So this can be on any sort of like external protocol. It could be any lending market, it could also be on your DAP as well. You can actually have this conduct connected to it.
01:14:14.494 - 01:14:33.890, Speaker A: Let's say you want to build a use case for wheel assets. So you're moving funds off chain. This is also possible with conduits essentially because what you define in the interface is the communication between maker or what we like to call the subdou and the arranger.
01:14:33.890 - 01:14:48.998, Speaker A: The arranger being the external protocol on chain or off chain. This is a new way that we'll be able to expand similar to how uniswap is having hooks. So you can have full customization within a certain level parameters.
01:14:48.998 - 01:15:13.730, Speaker A: You can do the same thing when you look at maker and liquidity provision. And I think with that I can hand it over to Lucas. Yeah, we're still trying to sort out some technical difficulties here sharing the screen, but what I can talk about without sharing is that I'm currently working on the arranger conduit.
01:15:13.730 - 01:15:54.222, Speaker A: The arranger conduit, the goal of it is to provide like a standard contract that multiple RWA arrangers that are currently working with MakerDAO can move to in the future. As well know, future arrangement structures that are deploying in the Treasuries or different real world assets, can use the same smart contracts that will be standardized throughout Maker and that'll provide a lot of benefits. First, it'll provide an easier user experience for the arrangers because they'll know exactly how to deal with these contracts, but it will also provide a lot easier reporting for the entire MakerDAO system.
01:15:54.222 - 01:16:34.380, Speaker A: So for all of the risk teams, all the different teams that are working on displaying information in Dashboards, dune, analytics, whatever it is, there will be a common source of information for these conduits. So what I wanted to show you guys today was the general structure of the arranger conduit, how funds are flowing through it, as well as how to build initial integration testing with the new allocation system. So I guess what I will say is I'll talk about the flow of funds since I can talk about that at a bit of a higher level.
01:16:34.380 - 01:17:12.226, Speaker A: So how the flow of funds will work at a high level within the new allocation system is that each allocator will be able to pull funds from the Maker system and then allocate it to different conduits. So what a conduit's purpose is, is to be able to take in deposits and hold custody of funds and track positions across multiple allocators. So multiple allocators will be able to mint dai from maker and allocate funds into these conduits.
01:17:12.226 - 01:17:59.110, Speaker A: The funds will sit in the conduit until an arranger is able to deploy that capital into real world assets or any sort of yield generating strategy. So those arrangers who are permissioned actors can come into these contracts and take the funds out and deploy them into Treasuries or whatever it is. And over time, as the allocators find a new strategy to allocate dye to generate more preferable yield, or the maker course system wants to reduce the total supply of dye or whatever it might be the the allocators can request funds from the arrangers through the contracts.
01:17:59.110 - 01:18:28.942, Speaker A: So instead of this being an on chain or an off chain procedure, the allocators can come in, request the funds, there will be an on chain event as well as storage that gets persisted on chain that persists. The state of this fund request and also orders all these fund requests that all the different allocators have made. And so the arranger can come into this single conduit and now see the overall state of the system.
01:18:28.942 - 01:19:05.770, Speaker A: They can see how much funds they're able to deploy from multiple actors, as well as all of the different fund requests that are outstanding that they need to fulfill on behalf of each of these actors so they can come to a single source and just handle all of their real world asset integrations with Maker. Which is great. So once they return the funds, then they will again be sitting custody in the contract, except they'll be tracked in another way called like withdrawable funds so all the allocators can come in and see that, okay, now we have some cash available.
01:19:05.770 - 01:19:22.446, Speaker A: Sure, let's try that. They'll have some cash available so they can actually withdraw the funds out of the instrument and deploy to another conduit. And so this is like the first example of a conduit that we put into production.
01:19:22.446 - 01:19:57.580, Speaker A: But the idea behind this architecture is to allow for the community to come up with new ideas, creative ideas of how to deploy capital into real world assets, DeFi protocols, lending, whatever it is, any safe way to generate, yield and expand the supply of dai and get it further out into the DeFi ecosystem. The maker community will happily explore just as long as it is definitely maintaining conservative positioning and safety for the core maker system. See if this works.
01:19:57.580 - 01:20:17.460, Speaker A: Five minutes. I honestly wonder if it's even worth going into the code with five minutes. Does anyone have questions at this point? No? Okay.
01:20:17.460 - 01:20:33.630, Speaker A: Oh, sorry. So this is currently in development, so yeah, we're currently working on developing this right now. Soon TM.
01:20:33.630 - 01:21:06.330, Speaker A: What are the kind of hacks do you mean like here? Oh, definitely related to conduits. I'm very biased, obviously, but I think that I've been involved with the maker ecosystem since 2020, and as a hacker, I think this is genuinely the most exciting thing that's happened in a very long time. The maker system is very conservative and very thoughtful in their development, and they will always be.
01:21:06.330 - 01:21:34.478, Speaker A: But what's really cool about this is it allows for external developers to propose experimental strategies for deploying dai, and anyone could come in and have access to this massive pool of capital. That's the maker core system. And if their strategy is proved out and it's scalable and it's safe and it generates good yield, they could see their strategy be managing very large amounts of funds.
01:21:34.478 - 01:22:02.100, Speaker A: So if I was a hacker, I would be 100% working on conduits this weekend. That's right. So after the talk, todayo will provide you guys with resources, links to repos.
01:22:02.100 - 01:22:14.840, Speaker A: Everyone in this room is welcome to Fork. My repo that I'm currently working on, it's open source and just poke around and see how it works and modify it. There's full integration testing with the existing system and everything.
01:22:14.840 - 01:22:27.980, Speaker A: So that's a great place to start. There is a standardized interface that you'll see me import in my repo. And as long as you adhere to the core interface, which I'm inheriting, I'm inheriting a core interface.
01:22:27.980 - 01:22:38.160, Speaker A: Then you're on track to be considered for a conduit. Exactly. That's right.
01:22:38.160 - 01:22:59.000, Speaker A: So another example of a conduit is a conduit that would deploy dai into an allocator would be able to just take dai from the core system and allocate it into. Really, any lending protocol can be Aave compound, spark, whatever it is. The first one that we're building is for Spark.
01:22:59.000 - 01:23:21.930, Speaker A: Anyone else? Good. Yeah, so we'll have everything in the dashboard. It's global, but again, I encourage you to ask questions because we'll probably miss a thing or 20.
01:23:21.930 - 01:23:31.660, Speaker A: So, yeah, thanks a lot. And yeah, if you guys have any technical questions about conduit implementations, just find me and I'm happy to help out. Or Sam.
01:23:31.660 - 01:30:58.694, Speaker A: Okay. We're live. Yeah.
01:30:58.694 - 01:31:05.526, Speaker A: Thank you all for coming to my talk. It's about building the Safe core SDK or building with the Safe core SDK. My name is Manu.
01:31:05.526 - 01:31:14.650, Speaker A: I'm from Safe Wallet, and I'm working in frontend at Safewallet. And now this stopped working. Now we're back.
01:31:14.650 - 01:31:27.898, Speaker A: Okay, so let's talk about Safe. I guess most of you know us already. The project was formerly known as Nosisafe, and it's a multi SIG wallet, but it's also more than just a multi SIG wallet.
01:31:27.898 - 01:31:46.786, Speaker A: We also want to move the narrative of account abstraction forward. So we built a lot of tools around account abstraction, and Safe for us was account abstraction from day one because account abstraction mostly means that you use smart contracts as accounts, and that's what Safe basically is. But we also have an ecosystem.
01:31:46.786 - 01:31:58.490, Speaker A: We have multiple interfaces building on us. And yeah, I will go into more detail when we talk about the packages. And what we talk about mainly in this talk, is about the Safe Core SDK.
01:31:58.490 - 01:32:08.074, Speaker A: It's a TypeScript library. It's a set of kits which help you to integrate with the Safe Core contracts itself. So deploying, safes, et cetera.
01:32:08.074 - 01:32:21.134, Speaker A: We'll hear more later. So Safe was recently split into two teams. The first team is Safe Core, and the second team is Safe Wallet.
01:32:21.134 - 01:32:40.418, Speaker A: So what are the difference between these teams? It's quite self explanatory. Safe Wallet basically builds and maintains the Safe interfaces. That means it's the Safe Web interface and also the Safe mobile wallets on Android and iOS and the services which these interfaces require.
01:32:40.418 - 01:32:53.798, Speaker A: And I work on this team for the front end. So if you have questions about that, come to the booth. The SafeCore team has multiple fields where it's active, basically three, or you can split it into three fields.
01:32:53.798 - 01:32:58.814, Speaker A: It's first. The SafeCore protocol. Yeah.
01:32:58.814 - 01:33:10.050, Speaker A: The SafeCore protocol. So that's like the set of smart contracts around Safe. So the smart contracts are deployed on all networks which are the core also of Safe.
01:33:10.050 - 01:33:38.870, Speaker A: We will also hear a bit about that and the SafeCore API, which are the services around Safe. So it's a service which helps you load Safe data. So it runs an indexer, for instance, and multiple wallets use it to load data about Safes or to submit transactions because it's also like a strength of Safe that you can sign transactions off chain and then submit them once everybody signed or enough people signed a transaction.
01:33:38.870 - 01:33:46.678, Speaker A: And then it's the SafeCore account abstraction SDK. We will talk a lot about this in this talk. So let's go forward with the SafeCore protocol.
01:33:46.678 - 01:34:04.126, Speaker A: I will only touch it very slightly in this talk because it's a quite new topic. It's alpha, so it's only deployed on Gurley because you shouldn't use it in prod. Yet basically I present it here because we have like half of the bounties revolve around building with SafeCore protocol.
01:34:04.126 - 01:34:13.926, Speaker A: So I will quickly explain the architecture which you see in this diagram. So the idea is that you can integrate with multiple accounts. Like one option is of course the Safe smart account.
01:34:13.926 - 01:34:32.150, Speaker A: But it's also possible or we want also and we hope that other wallets or other smart account wallets will also use Safe and build on top of the new SafeCore protocol. And the idea is that the SafeCore protocol has multiple registries. These could be maintained by a Dao or by groups.
01:34:32.150 - 01:34:46.138, Speaker A: And the idea is that these registries contain like trusted or audited integrations with Safe. And the integrations can be plugins hooks or function handlers and signature verifiers. It's all things which already existed in Safe.
01:34:46.138 - 01:35:03.410, Speaker A: Like plugins is similar to what modules are right now. Hooks are similar to transaction guards, a bit like a plugin. Basically you can extend the smart contract or the smart contract wallet by any functionalities by providing new functions which then will be available for the Safe.
01:35:03.410 - 01:35:20.490, Speaker A: With hooks you can dive into the transaction lifecycle. So you could have preassigned checks or post execution checks, I mean pre execution and post execution checks and more. And the signature verifier and functional handler are basically what's right now called the compatibility fallback handler.
01:35:20.490 - 01:35:39.630, Speaker A: It for instance offers 1271 signatures. So you could extend the signature checks by new algorithms, for instance using Paskis or something. Yeah, this is the SafeCore protocol if you want to find more information, we updated our docs today.
01:35:39.630 - 01:35:50.962, Speaker A: So if you check the docs yesterday, check them again today, it's a whole new page. There's also a lot about the new SafeCore protocol and there's also a demo on this GitHub page. I will very, very quickly.
01:35:50.962 - 01:35:55.062, Speaker A: Only show it. So let's hope the screen share works. It works.
01:35:55.062 - 01:36:08.486, Speaker A: So basically the idea of the demo is and it only works on Gurley because it's only deployed there. There's a GitHub page deployed and this GitHub page is a Safe app. So you can add it as a custom Safe app on Gurley to any Safe.
01:36:08.486 - 01:36:18.750, Speaker A: Then you have the SafeCore protocol demo app. You open it and you see this page and you can look at the available plugins. Modules are now called plugins on this protocol.
01:36:18.750 - 01:36:30.586, Speaker A: And it loads some plugins which are registered on the deployed register. And you could enable them. And some of them also have a custom UI where you get with this error.
01:36:30.586 - 01:36:40.386, Speaker A: That's all I want to show. If you want to check it out, check the repos, or if you have more questions about it, please come to our booth. I'm just quickly demoing it because half our bounties will be about this.
01:36:40.386 - 01:36:46.950, Speaker A: So you should have seen it once at least. It's quite new. Yeah, let's go back to the presentation.
01:36:46.950 - 01:36:54.918, Speaker A: Okay, that's all about SafeCore protocol. Come to our booth. If you have more questions, please let's talk about the account abstraction SDK.
01:36:54.918 - 01:37:16.762, Speaker A: It's a TypeScript library, as I mentioned before, and it contains of several kits, like several kits around account abstraction or interacting with your Safe. The first is the OS kit. It basically gives you advanced authentication mechanisms, for instance, using your social media account to log in, or like APC, for instance.
01:37:16.762 - 01:37:27.406, Speaker A: So right now, we will see later which products are integrated with it so far. Then we have the Protocol kit. It's there to integrate and to interact with Safes.
01:37:27.406 - 01:37:35.826, Speaker A: So you can deploy Safes, you can create transactions, you can sign transactions. Everything around the Safe protocol is in this kit. Yeah.
01:37:35.826 - 01:37:48.326, Speaker A: Here, for an example, you could craft a batch transaction which deploys a Safe and also sends a transaction in the same transaction. Then we have the Onramp kit. It's quite trivial.
01:37:48.326 - 01:38:00.202, Speaker A: Like on ramping means you convert your crypto. You buy crypto with Fiat money and you fund your Safes basically with it. The Relay kit also quite self explanatory.
01:38:00.202 - 01:38:14.500, Speaker A: Like you can execute a transaction without paying for the gas yourself. So you could, for instance, pay directly from your Safe or you could pay using ESC 20 tokens even instead of using the native tokens. Yeah.
01:38:14.500 - 01:38:30.200, Speaker A: And currently these implementations exist for these kits, like the way it's structured. In the SDKs there's always kits and then there's packs, which kind of are implementations of the interface. So for authentication we have like Web Three out right now.
01:38:30.200 - 01:38:42.390, Speaker A: For protocol, it makes no sense because it's the Safe protocol. For Onramp, we have like Stripe, which only works in the States right now. But for people in Europe, we have Monarium launched quite recently.
01:38:42.390 - 01:38:55.280, Speaker A: So check it out. And for Relaying we are integrated with Gelato. Yeah, we're also planning to build more kits or there's more ideas and more kits coming soon.
01:38:55.280 - 01:39:06.002, Speaker A: For instance, we are looking into recovery. So offering a recovery kit and different ways of recovery inside this kit. So different packs again or like for better multi chain support.
01:39:06.002 - 01:39:18.914, Speaker A: A kit and others are also possible but these are the ideas currently revolving around. Yeah, if you want to check out the kits, they're all in the same repo. They're all in SafeCore.
01:39:18.914 - 01:39:31.274, Speaker A: SDK here's a link to it and a list of the packages. Here again, it's the same list of packages, a bit easier to read. The only one I didn't cover is the SafeCore SDK types but it's quite explanatory too.
01:39:31.274 - 01:39:42.990, Speaker A: It's like everything is built with TypeScript. So these contain the types which are used throughout these kits. Okay, I will also quickly demo these kits.
01:39:42.990 - 01:39:57.026, Speaker A: In the account Abstraction SDK, there's a small react app, it's also open source. You can also check it out to see also how these kits exactly work at least. And if you start it, it should show this page.
01:39:57.026 - 01:40:11.030, Speaker A: You can select a chain, I will use Mumbai and you can start the demo. And it contains three kits the outskit onram Kit and Relay kit. And here with the outskit as mentioned, you can connect with for instance your Google account.
01:40:11.030 - 01:40:16.846, Speaker A: So let's try it out. I hope the WiFi is strong enough. Yeah, so here you see this modal.
01:40:16.846 - 01:40:25.500, Speaker A: This is from web three. Out. So you could also connect with your UA as usual but you could also use for instance, your Google or Facebook or whatever account.
01:40:25.500 - 01:40:34.574, Speaker A: Let's do it quickly. Sign in with Google if you would use it for the first time. If you want to check it out, it will not deploy a safe yet.
01:40:34.574 - 01:40:44.594, Speaker A: It will use the predicted Safe address and only if you do the first transaction from that safe. It will deploy that safe first and then do the first transaction. So I already tried it out.
01:40:44.594 - 01:41:02.600, Speaker A: So this safe is already deployed, will take a bit to load the data. So here we see the owner wallet which was created and the address of it and the Safe account which was created and it's already funded because I did this demo already. Once down, like underneath, you can also always see code Snippets which explain how it works.
01:41:02.600 - 01:41:23.022, Speaker A: Here, for instance, we import the outkit as mentioned, we have some options which are like coming from Web Three out. So it contains which chains do we want to support or which login method or how should this modal look like? Do you want a dark theme or not? And important. The client ID.
01:41:23.022 - 01:41:48.790, Speaker A: That's something from web three. Also you need to become a client or a customer at Web 3 hours to use it and then in the end you can create this login adapter and this Web Three modal pack passing in all these options. And then this modal pack is wrapped in the save Auth kit which is again like kind of the interface for everything and it offers like a sign in, sign out and other methods.
01:41:48.790 - 01:41:59.066, Speaker A: Let's go to the next. This one I will not show because it's right here. We didn't integrate the Monero pack yet so Stripe only works in the United States and we're in Europe so it won't work.
01:41:59.066 - 01:42:26.414, Speaker A: But I can shortly click on it and you can see that after some loading this widget opens and you could now onboard if you were in the states but yeah, again the code, it mostly contains stuff about stripe like you have a stripe public key and other stripe data. You put that into the Stripe pack and then again you initialize the kit. So it's a similar pattern.
01:42:26.414 - 01:42:51.786, Speaker A: You always have the packs which are implementations for the kit and then again this kit offers functions like Open and it opens the model and subscriptions to some events which will happen from stripe next. In this one we can also try and show is a relay kit. It's using gelato to relay a transaction and a repay from the Safe itself.
01:42:51.786 - 01:43:04.110, Speaker A: So here we will send 0.1 matic to the safe itself. But you can see that we won't need to sign anything because the signer is using web three out and we already logged in with our Google account.
01:43:04.110 - 01:43:20.626, Speaker A: So we won't have a MetaMask pop up and have to sign. But instead it will just create the transaction, relay it and show when it executed. It could take a bit yeah, try it out if you want.
01:43:20.626 - 01:43:34.866, Speaker A: Now it's pending and at some point it will be executed. I will go forward because don't want to wait for this transaction. Yeah, we are also almost done so this is like all about the kit and a bit about the protocol.
01:43:34.866 - 01:44:07.502, Speaker A: If you have questions please come to our booth and probably we also have a bit of time for questions after this. Let's talk about the bounties because we're all in a hackathon so Safe has like $10,000 in bounties and these bounties are split as I already mentioned between these two projects. So if you want to build on Safe and you want to participate in the hackathon and be eligible for a bounty you have to either use or build on top of the new SafeCore protocol which means if you planned to build a module then build a plugin.
01:44:07.502 - 01:44:32.458, Speaker A: If you plan to build a transaction guard then probably look into hooks, use the new architecture and the new contracts. Again they are on our docs and the implementation and the examples too. Yeah so for Safe core protocol we have like for the first place $2,500, for the second $1,500 and for the third $1,000.
01:44:32.458 - 01:44:43.680, Speaker A: And the same tiers we also have if you build on top of the Safe core account abstraction SDK which we presented. So this TypeScript library. So if you want to be eligible use one of each or both.
01:44:43.680 - 01:44:57.730, Speaker A: Here are some useful links. Like I already mentioned the docs, you can also find everything if you just go to Safe Global. But we have a docs, we have our Discord, a forum and our Twitter.
01:44:57.730 - 01:45:19.174, Speaker A: Also important, you can also reach us on the discord of East Global. Like there's a partner Safe channel, so if you have questions right there or better come to our booth. And we also have a small guide which has some learning materials and some past winners of Hackathons and some past workshop videos and other resources.
01:45:19.174 - 01:45:42.020, Speaker A: If you want to use that, then scan this QR code. It's a notion page, contains some useful information too for participating in a Safe hackathon. This is the presentation, so thank you very much for your attention and if there's some questions, I'm not sure how much time you used, but probably there's a bit of time for a few questions.
01:45:42.020 - 01:46:24.960, Speaker A: Are there any questions? If not, then if you have some in the future, please come to our booth or post in the discord. Cool. Which chains are eligible? Yeah, I can go back to the Bounty slide.
01:46:24.960 - 01:46:41.680, Speaker A: If you want to build on top of the SafeCore protocol, that's only deployed on Gurley for security reasons, because it's still very alpha so we don't want to deploy it on mainnet because people could assume that it's fully audited and ready to use in prod. That's why it's only in Gurley. So that will only be Gurley.
01:46:41.680 - 01:47:15.556, Speaker A: But if you want to build on top of the account abstraction, SDK Safe is already deployed on a lot of chains, so you can just use multiple chains then you're not really restricted. Yes. Can we transfer any token with a construction with the smart wallet? If you can transfer tokens, yes.
01:47:15.556 - 01:47:28.440, Speaker A: ERC 20 tokens. Yeah, like the demo I showed there. For instance, we relayed a transaction which sent funds so you can relay any transactions, for instance using Gelato or other relay providers.
01:47:28.440 - 01:48:03.520, Speaker A: Or you could pay directly from your Safe to transfer tokens. Yeah, I mean in general, Safe supports all kinds of tokens for a Safe core protocol. Is that limited to specific networks or can we use it also on testnet? What functionality also is available and isn't available? If we deploy it on our own custom networks? Yeah, for SafeCore protocol, it's currently only deployed on Gurley, so only on Gurley testnet because it's still in alpha stage.
01:48:03.520 - 01:48:13.748, Speaker A: So if you want to build on Top, it will be on Gurley. It's not deployed on other test networks yet. I mean, if you really want to use it on Mumbai, I guess you could try to deploy it yourself or something and then build on top of it.
01:48:13.748 - 01:48:36.316, Speaker A: It shouldn't be a blocker, but if you want to use the already deployed contracts, then they are on Gurley. And there's also already like the demo I showed here, this demo app, there's a repo where you can see a small UI for one of these plugins and you can see a relayer plugin using Gelato. So you could also use that as a starting point and then build your own plugin on top of that or something.
01:48:36.316 - 01:48:53.120, Speaker A: So that's like an example with UI and Contract. Just a quick follow up. Are there instructions or guides how to deploy SafeCore on your own network? I'm not entirely sure, but the contracts are all open source.
01:48:53.120 - 01:49:02.470, Speaker A: They also linked in our docs. So there you can find the solidity code. So I guess in theory you could deploy them on a network then yourself.
01:49:02.470 - 01:49:40.640, Speaker A: Thank you. Does the SafeCore include safe modules? Does the SafeCore use Safe modules as well? I mean, if we build a Safe module, would it be eligible for Safe Core? I would suggest using the building on top of the plugins because they're similar to Modules previously, but in the new SafeCore protocol. But in general I think you can also send a module transaction from the SafeCore Protocol kit.
01:49:40.640 - 01:50:05.480, Speaker A: Okay, got it. But you can also come to the booth if you have safe plugins are not in the prices, right? I mean bounties Safe plugins, they are not in the Bounties. I mean plugins are part of this new Safe Core protocol.
01:50:05.480 - 01:50:20.444, Speaker A: Let me try if I find the slide very quickly here. So I'm not exactly sure what you mean with plugins, but here plugins are very similar to modules. So you could extend the Save Smart contract by new functionalities by building a plugin.
01:50:20.444 - 01:50:37.888, Speaker A: For instance, the example which is on our repos now demo app is a relay plugin. So it will pay the Gelato relayer for a transaction and then relay the transaction using a plugin. So it will be part of Safe Protocol.
01:50:37.888 - 01:51:18.044, Speaker A: Yeah. And what about sponsoring guest transactions? So you sponsor transactions on any chains or on the ongnosis you mean in our UI right now? In the wallet right now, yeah. Gas fees, it was in presentation, like gas fees in ERC 20 tokens, you could do that with the relay 1 second, there's a relay kit and with that you could for instance pay from your Safe or Gelato.
01:51:18.044 - 01:51:35.690, Speaker A: Like we use Gelato for the relay pack and Gelato supports that you for instance pay with USDC for a transaction instead of using the native token. So for the relay packs, it's currently Gelato and you can pay from your Safe or you can pay using one balance. It's a gelato product.
01:51:35.690 - 01:52:06.188, Speaker A: So it's the same like Paymaster? Yeah, in fact it's similar. It's like a solution which was pre four through C seven. Okay, one more question, I'm sorry, where can I link to the demo repo or the demo website? It's all on our docs.
01:52:06.188 - 01:52:29.130, Speaker A: So if you go to Save Global and then click on the docs there, the demo repos should be linked especially for Safe Core protocol, there's a demo repo linked and also for the Save account abstraction, you find the demo. If not, then come to our booth and I can give you the link. If you have trouble finding it, please pin the links in the discord if you can.
01:52:29.130 - 01:52:36.170, Speaker A: Okay. Yeah, I think we already pasted some links in the discord. Like, there is a Partner Save channel.
01:52:36.170 - 01:52:42.430, Speaker A: We are reachable there, and we are also reachable at our booth. The whole day is here. Thank you.
01:52:42.430 - 01:53:41.672, Speaker A: Thank you very much. What? It was like people need to be about that distance. Yeah.
01:53:41.672 - 01:54:18.750, Speaker A: If you guys talking like, this is right, okay. Or you don't have to do anything, and I do meet what you prefer. No? Okay.
01:54:18.750 - 02:05:53.590, Speaker A: Forget I can start. Yeah, you can start. Cool.
02:05:53.590 - 02:06:12.632, Speaker A: Hey, everyone. So I'm going to be talking about Zeta chain. What is Zeta chain? It's essentially an interoperability solution that lets developers build cross chain DApps, or, as we call them, Omnichain DApps.
02:06:12.632 - 02:06:53.640, Speaker A: So, Zeta Chain offers a solution for developers to just write a contract once, deploy it to Zeta Chain, and this contract essentially has powers to manage assets on all the connected chains. So, for example, if a user has an asset on Bitcoin, they can send BTC to a specific address. And this BTC becomes available to the contract on Zeta Chain, and your contract can perform logic, and, for example, swap the token for another token and withdraw it back to a native chain.
02:06:53.640 - 02:07:06.876, Speaker A: So that's called omnichain contracts. It's super easy to start building with Zetachain if the screen comes back alive. I will even show you that.
02:07:06.876 - 02:07:35.940, Speaker A: But Zetachain offers also an alternative way of building cross chain DApps, and it's through cross chain messaging. So, cross chain messaging is, instead of deploying a single contract to Zeta Chain, you deploy contracts to a bunch of different chains. And they're using Zeta Chain's API to send messages with arbitrary data between chains.
02:07:35.940 - 02:07:53.950, Speaker A: So both solutions have advantages. The main advantage of Omnichan Contracts is that it drastically reduces the complexity of the system that you're building. So you just have one contract to worry about.
02:07:53.950 - 02:08:12.850, Speaker A: Only state is only in one place. So that's very convenient from an architecture point of view. Okay, let's wait a bit for screen to come back.
02:08:12.850 - 02:08:20.500, Speaker A: I know that you're starting out. Everything there for everyone. This looks funny.
02:08:20.500 - 02:08:41.582, Speaker A: Looks very web. Three like, very hacky. Actually.
02:08:41.582 - 02:09:44.346, Speaker A: It doesn't change if I change? No, it that's like reading docs on hard mode. Awesome. Can I continue? Can I get a green light to go ahead? No, it might happen again.
02:09:44.346 - 02:10:41.270, Speaker A: Let me just get an adapter quick for you. Let me just get one more adapter. Should you deploy it to Single Chain or to all the chains or Zeta Chain deploys the contract.
02:10:41.270 - 02:10:52.646, Speaker A: So it depends on which path you're taking. For Omnichan contract, you would deploy it once to Zeta Chain, and that's it. You don't need to do anything to any other chains.
02:10:52.646 - 02:11:09.678, Speaker A: It just all works out of the box. If you're using cross chain messaging, you have to deploy it to all the chains you want to connect. So right now, four chains, zeta chain is in the testnet phase, four chains are connected.
02:11:09.678 - 02:11:31.734, Speaker A: More chains, of course, will follow. But if you're using cross chain messaging, you're deploying a contract on all four chains and you're also setting an interactor. So you're basically telling to each contract, you're telling the counterparty contract address so that it knows which contract to talk to.
02:11:31.734 - 02:12:06.370, Speaker A: So it's a bit more involved from the architecture point of view, but it's kind of a very well known solution, basically. Right, so if you have an existing application that needs to be augmented to become cross chain, you can use crosschain messaging for specific areas. If you were to build something from scratch, I would recommend looking into Omnichan contract first because it's just so much simpler and it's the killer feature of SATA chain.
02:12:06.370 - 02:12:54.668, Speaker A: If anyone has questions, let's just jump to questions, I guess, first, which is weird before yeah, go ahead, deploy to every chain. So, again, if Omnichan, you just deploy once cross chain messaging, you deploy it to all the chains. For cross chain messaging, you will be able to send messages between the chains you've deployed your messaging contract to, because, for example, Zeta chain at some point might support like 2050 blockchains.
02:12:54.668 - 02:13:20.884, Speaker A: You might be interested only in three of them or like ten of them. So with cross string messaging, you have to explicitly deploy it to the contracts you're interested in. So does that answer the question? Right now, in the testnet phase, only four chains, so that would be Bitcoin, Ethereum, Polygon, BSc.
02:13:20.884 - 02:13:33.768, Speaker A: Of course more chains will follow. And Zeta Chain is built on Cosmos tech, so possibly it will be IBC compatible. If you're familiar with Cosmos, then this will connect it to even more chains.
02:13:33.768 - 02:13:55.668, Speaker A: And we are planning on integrating more EVM blockchains and non EVM chains as well. One of the advantages so, besides Omnichain contracts, the advantages of Zeta chain include Bitcoin interoperability. So not many solutions, especially decentralized solutions, support Bitcoin out of the box.
02:13:55.668 - 02:14:15.540, Speaker A: So from Bitcoin, you can trigger smart contracts on Zetachain, which is pretty cool. There's very little overhead and there's nothing you need to do on Bitcoin. You just ask users to send tokens to a specific address and that triggers a contract call on Zeta chain.
02:14:15.540 - 02:14:44.468, Speaker A: And the other advantage is that there's no wrapped assets. So there are wrapped assets on Zeta chain when the process happens. Right? So when you send tokens to a TSS address on a chain, ZRC 20 wrapped version of the original asset gets minted, but only gets minted on Zeta chain for the purposes of swapping and working with it.
02:14:44.468 - 02:14:55.300, Speaker A: So it's like representations of the original asset on Zeta chain. Okay, cool. So let's continue with the slides.
02:14:55.300 - 02:15:06.490, Speaker A: So, I talked about cross chain messaging, Omnichan contracts. Now I want to show how well basically easy it is. So if you go to Zayshain.com
02:15:06.490 - 02:15:21.868, Speaker A: Docs, in the developer section you will see two sections omnichain contracts and crosschain messaging. So here is a complete example of an Omnichan contract. As you can see, it's super simple.
02:15:21.868 - 02:15:39.856, Speaker A: The only thing you need is Z contract. Here a couple of imports and you need to implement on crosschain call function. This function gets called whenever tokens are sent to a specific address on any of the connected chains.
02:15:39.856 - 02:16:08.556, Speaker A: So for example, if someone sends tokens to a TSS, to a specific address on Ethereum, there are two paths. These tokens might be just deposited into your contract on zeta chain. Or if a user sends tokens and supplies arguments in the data field of the transaction, these arguments get passed to your contract as the message.
02:16:08.556 - 02:16:20.156, Speaker A: Then you can decode the message, implement your logic. For example, this contract is super simple. It just withdraws the tokens to the same chain.
02:16:20.156 - 02:16:38.548, Speaker A: Doesn't do much, but it shows you an example of how to trigger an Omnichan contract and how to withdraw. But you can of course swap to a different token and withdraw to a different chain. Or you can mint tokens on zeta chain.
02:16:38.548 - 02:16:49.676, Speaker A: It's really up to your contract. But the logic is super simple. Token transfer on a connected chain triggers this function call and that's it.
02:16:49.676 - 02:17:06.528, Speaker A: And then you can use ERC 20, which is an extension of ERC to withdraw the tokens back. Right now Omnichan contracts support native gas tokens as well as ERC 20. Of course, more asset types will be added later.
02:17:06.528 - 02:17:36.864, Speaker A: ERC 20 need to be whitelisted by the chain and this is not a centralized decision. The blockchain is going to be very decentralized and people are going to the community is going to be voting on important decisions like which ERC 20 we want to whitelist. If it's whitelisted, a pool will be created internally on zeta chain so that tokens can be swapped and so forth.
02:17:36.864 - 02:17:44.670, Speaker A: So as you can see, there's not much to it. Your contract just need to implement one function. That's it.
02:17:44.670 - 02:18:01.568, Speaker A: With cross chain messaging it's also pretty straightforward. So here you have a few things you need to implement. First, a function that will use zeta chain's connector API to send data.
02:18:01.568 - 02:18:20.200, Speaker A: So you just provide some helpful information like where do you want to send the message to the destination chain. You need to provide things like gas, but most importantly you need to provide the message. Here is just a text hello world message.
02:18:20.200 - 02:18:40.132, Speaker A: But you can encode any kind of data you want and it will be processed once the function gets called. This will essentially trigger a process where an event is emitted on the source chain. Zeta chain's validators.
02:18:40.132 - 02:19:04.288, Speaker A: They run nodes of all the connected chains and when they see a transaction happening, they will vote on zeta chain whether they've observed this transaction or not. If enough votes are cast, the transaction will go through and will be processed by zeta chain. And on the recipient end you just implement on zeta message.
02:19:04.288 - 02:19:23.880, Speaker A: So if the transaction comes through, you just handle it. For example, if it's a NFT project, you might want to lock the NFT in the send message function right here. Before connector send, you will lock the NFT.
02:19:23.880 - 02:19:53.300, Speaker A: You will mint an NFT on zeta message on the receiving chain and maybe send an acknowledgement back to burn the original NFT. If you got a new NFT minted, right? That could be, but again, the architecture is up to you. This is just a kind of low level primitive for you to be able to transfer value and data between all the connected chains.
02:19:53.300 - 02:20:15.020, Speaker A: You don't need to worry about zeta chain here at all because zeta chain works as intermediary here. So we have a lot of tutorials for everything. You can see a very simple cross chain swap and just what is like 30 lines of code withdraw tutorial.
02:20:15.020 - 02:20:28.896, Speaker A: You can also check out the Bitcoin tutorial as well. Not many projects support Bitcoin, so that's pretty interesting. What I'm going to show, the last thing I'm going to show is basically how you would start.
02:20:28.896 - 02:20:37.552, Speaker A: So you would go to GitHub.com datachain. We have a bunch of reposts here, but I recommend just cloning the template.
02:20:37.552 - 02:20:59.284, Speaker A: So GitHub.com data chain template, when you clone the template, you have something like this and it doesn't have much, but it imports a bunch of helpful utilities. So if you run NPX hard hat, you will get a bunch of helpful tools.
02:20:59.284 - 02:21:12.488, Speaker A: So for example, if you need to connect create an account, you just Hearthat account and it will create an account for you. You can even save it. You can PX hardhead balances.
02:21:12.488 - 02:21:27.124, Speaker A: This is helpful because we're dealing with a bunch of chains, so you need to know what kind of tokens you have. So on all the connected chains you can see native zeta and zero C 20 equivalents. What is super helpful I think is how you get started building.
02:21:27.124 - 02:21:45.848, Speaker A: So you have a command, hardhat omnichain. And what this does is it accepts a name. So let's call this contract withdraw and a bunch of params like recipient data whatever from.
02:21:45.848 - 02:22:13.860, Speaker A: So what this will do is it will create a contract that you just need to fill in the blanks, right? So it's already there for you and you already have a deploy task, so you don't need to worry about that and also a task to interact with it. So you just executed one command to create a new contract. Then you can run hardhat compile.
02:22:13.860 - 02:22:49.580, Speaker A: Now you can just run deploy network. Since this is an omnichan contract, you always deploy it to zeta testnet and of course it doesn't do anything, right? You saw that there's a blank in the contract and boom, you got the contract deployed and you can interact with it as well. So all the boilerplate code is here, and there are more tasks.
02:22:49.580 - 02:23:16.292, Speaker A: One more useful thing is if you're building with crosschain messaging, we also have a task for this. So NPX, hard hat messaging, My contract, Foo, Bar, and this will create a crosschain messaging contract instead. And it has Foo and Bar here, so you can already compile it and deploy it to different chains.
02:23:16.292 - 02:23:27.160, Speaker A: Let's do that. It's slightly different because with cross chain messaging, you deploy it to several chains. So let's say Gurley testnet and Mumbai testnet.
02:23:27.160 - 02:23:50.956, Speaker A: Okay, we need to compile it first. And what this will do is it will deploy the contract to all the chains you specified, but also set interactors for all the contracts. So it will tell the contract on Mumbai, the address of the contract on Gurley.
02:23:50.956 - 02:24:06.544, Speaker A: So it kind of wires everything up together. So you don't need to worry about that. You just read the docs, understand how it works, and implement the logic of your contract, and send data you want to send through this connector.
02:24:06.544 - 02:24:18.996, Speaker A: Send Zeta Chains API. So I don't have much time for anything else. I will be available, as is the rest of the team downstairs at the booth.
02:24:18.996 - 02:24:41.676, Speaker A: So please do check out Zeta Chain if you have questions, more than happy to dig into any technical details. If you're going to be building on we have a price for the hackathon, more on the website. But please do make sure that you're using Zeta Chain's API and actually build something with cross chain messaging or Omnichan contracts.
02:24:41.676 - 02:24:46.230, Speaker A: That's very important. And yeah, good luck on the hackathon. Thank you.
02:24:46.230 - 02:25:04.200, Speaker A: Do we have time for questions while we get the next speaker set up? You could host like a Q and A. Okay. Over there, maybe? Okay, so I will be there if you have any questions.
02:25:04.200 - 02:30:14.548, Speaker A: Thank you. Maybe. Do you have power? Is the mic work? Yeah, mic works.
02:30:14.548 - 02:30:22.900, Speaker A: Okay, so hello, guys. My name is Simeon. I'm leading integrations with Neon EVM.
02:30:22.900 - 02:30:44.920, Speaker A: So today we'll speak about what the heck is Neon EVM and what are we doing, and we're going to be conducting a really short demo. So in a nutshell, neon EVM is EVM inside solana. It's not like layer two, it's not like a side chain.
02:30:44.920 - 02:31:17.668, Speaker A: But because Solana provides a very scalable architecture, we have the opportunity to build the entire EVM execution layer inside a Solana smart contract. And how this is possible? It's possible because in Solana, in one account, you can store up to ten megabytes of executable data. And actually, the EVM that's pretty interesting is around two megabytes.
02:31:17.668 - 02:31:46.028, Speaker A: So we built DVM inside Solana, and we provide an Ethereum like interface for users and developer to use it. And basically from developer perspective and user perspective, you can use the scalability and low transaction fees from Solana infrastructure. And at the same time, you don't really need to change your context.
02:31:46.028 - 02:31:59.664, Speaker A: And. From user perspective, change wallets. Or if you're a developer, I know it's really hard to change your tech stack or to learn new blockchain mechanics.
02:31:59.664 - 02:32:46.880, Speaker A: So we abstracted away all the solana complexity. And so what we are going to do today, I'm going to deploy one contract both on Sepolia and Neon EVM to show you what differences and what code changes we need to do. And also I'll show you one more thing and we're going to see so the best place to get more info is the developer documentation and here you can for example go to let's say Neon Faucet and get some testnet neons you can get from chainlist.
02:32:46.880 - 02:33:14.410, Speaker A: For example you can just write Neon, include testnets and add Neon DevNet in your MetaMask. I already have it and I already have Neons but let's just try it out. So yeah we can request 100 Neons and they should be here shortly.
02:33:14.410 - 02:33:46.840, Speaker A: Yeah so we have an Ethereum like blockchain Explorer so everything is EVM native and you don't really need to know about how Solana works and how transactions settle on Solana layer. So let's look at the project I have prepared. Basically it's a very simple hard hat project.
02:33:46.840 - 02:34:37.586, Speaker A: If we go and check you can see we have just two or three dependencies like we have hardhead toolbox, hardhead and hardhead Etter scan to verify our contracts and also we have open Sapling and Temp to store our environment variables in different file that will not be committed in our repository. So let's see the first contract that we are going to deploy. So we have a simple ERC, 20 token that we have supply limit, burnt amount, storage variable and just for the sake of the demo, I just added zero decimals so we don't have to add all those extra decimals.
02:34:37.586 - 02:35:14.942, Speaker A: For example, if you want to mint from the explorer so we don't need to count them. Yeah so let's try and deploy first this contract in Sepolia and verify it to see to verify that it works on just normal EVM before running. Yeah I'm going to just run it and show to you the hardhead configuration.
02:35:14.942 - 02:35:37.462, Speaker A: So as you can see we have configured two networks one of them is Sepolia and the other is Neon DevNet. Basically, as you can see, you don't need to do any extra configuration for this. And we also have another configuration.
02:35:37.462 - 02:35:52.190, Speaker A: This is for the verification of the smart contract. We have the API key for Sepolia and also for Neon Devnets. As of now, you can just put any key so you'll be able to verify the contract.
02:35:52.190 - 02:35:59.722, Speaker A: Yeah. It's strange. We are waiting so much for this contract to get deployed on Sepolia.
02:35:59.722 - 02:36:38.810, Speaker A: It usually takes 4 seconds. Just try again. It should be operational.
02:36:38.810 - 02:37:37.660, Speaker A: It it always happens like this when you need your contract to be deployed. It doesn't yeah, it's not okay, let's try to do one or two questions. Yeah, we can just try to deploy it to Neon DevNet.
02:37:37.660 - 02:37:57.648, Speaker A: Which one of you has deployed contract on Solana? Only one. Okay. Only one person.
02:37:57.648 - 02:38:23.892, Speaker A: Okay, so which one of you has deployed on EVM chain? Okay, we have more. So that's for you. Yeah, so you don't really need I've never deployed contracts on Solana for the simple reason that, you know, too lazy and just to learn any other and to change my tech stack, to change the code, learn new tools, learn new blockchain mechanics.
02:38:23.892 - 02:38:48.640, Speaker A: So I really find it very fascinating what Neon achieved. So basically, I don't know why for Sepolia, it doesn't really work, but let's try one more time. Maybe we can check some other maybe the public RPC.
02:38:48.640 - 02:39:07.720, Speaker A: Let's just get another I think that's right. Let's just get another RPC node. Maybe this one is down.
02:39:07.720 - 02:39:29.298, Speaker A: So we already deployed our contract on Neon DevNet. I just want to make sure that on Sepolia, everything's right. But if not, we're going to just proceed with Neon DevNet.
02:39:29.298 - 02:39:41.306, Speaker A: It's just a simple contract. So, as you can see, we just imported from open Seplin, and it should be no changes made, actually. Okay.
02:39:41.306 - 02:40:17.330, Speaker A: Sepoli is not that important. So the good thing is that we managed to deploy on Neon and let's just verify this contract. Just a second.
02:40:17.330 - 02:40:51.570, Speaker A: Let's try to deploy it again. And it says that it cannot find the built info, which is strange. Let's do it like this.
02:40:51.570 - 02:41:31.872, Speaker A: We're going to hack it sooner or later. Now we should have the correct build info. Okay.
02:41:31.872 - 02:41:37.948, Speaker A: Yeah. I forgot to clean the cache of Hardhead. It always happens if there is a problem.
02:41:37.948 - 02:41:42.420, Speaker A: The problem is in your cache. Always. Yeah.
02:41:42.420 - 02:42:01.000, Speaker A: So we verified the contract successfully and let's just go in Neon scan and see. Yeah, we can see we've deployed the contract. We have the contract here.
02:42:01.000 - 02:42:18.640, Speaker A: Maybe we can try and add it in our MetaMask. Yeah, let's import this token. Here it is.
02:42:18.640 - 02:42:44.694, Speaker A: Okay. And let's maybe try to mint yeah, we need to connect it and let's mint 100 tokens. Okay, let's see.
02:42:44.694 - 02:43:09.562, Speaker A: Did we no. Yeah, we need to provide a little bit more because I found a bug yesterday. Neo scan doesn't yeah, we need to have this value as gas because otherwise the transaction just requires a bit more gas.
02:43:09.562 - 02:43:41.794, Speaker A: But actually, a pretty interesting thing is that Neon doesn't use gas measurement from Ethereum. We use gas measurement based on Solana, and it's a bit different, but we support all the RPC calls. So most of the libraries, they use estimate gas and then put this as gas limit.
02:43:41.794 - 02:43:51.740, Speaker A: So we are fully compatible with this. And obviously, Neon scan don't use Estimate gas. Maybe hard coded some value.
02:43:51.740 - 02:44:11.460, Speaker A: Let's just check. Yeah, we coded two times. So we have 200 tokens and yeah, basically, as you can see, it works.
02:44:11.460 - 02:44:37.898, Speaker A: One more interesting thing is that maybe if we open the transaction, you can see that there is like five maybe more nine Solana transactions. And if we open even one of them, you can see those are all the underlying transactions that executed and that were wrapped in one Ethereum transaction. Basically.
02:44:37.898 - 02:44:55.790, Speaker A: Why is that? Is because in order to scale, solana has a completely different infrastructure from Ethereum and it's Stateless. Ethereum is stateful. It uses accounts.
02:44:55.790 - 02:45:16.418, Speaker A: In a nutshell, Solana is like a big file system. So it has two different kinds of accounts. It has data account and executable account and Neon EVM basically creates executable accounts for smart contracts and smart contract.
02:45:16.418 - 02:45:36.054, Speaker A: State is saved in data accounts in different files and read from them. So sometimes we need to create one or two transactions. When we are using for example SS store, we need to create a new data account in order to execute this opcode.
02:45:36.054 - 02:46:11.282, Speaker A: And this is one of the reasons we have more than one transactions and there are more limitations that we can discuss. For example, one Solana transaction actually has limited 256 transaction and all the EVM primitives like memory call stack is saved in this transaction. Memory, all the metadata that is related to the transaction and EVM.
02:46:11.282 - 02:46:33.866, Speaker A: And sometimes we need to make two or three different iterations in order to complete the Ethereum transaction. Okay, so the other contract that we are going to deploy is a bit more interesting. So it's called ERC, 24 SPL.
02:46:33.866 - 02:46:43.826, Speaker A: How many of you know what SPL token is? No one? Okay, one person. Okay, that's good. So I will explain to you.
02:46:43.826 - 02:47:07.606, Speaker A: So SPO token is the ERC, let's say the ERC equivalent in solana. So in EVM networks we have each ERC 20 as a separate contract, right? But in Solana we have a token program that is like a centralized smart contract, centralized program for all of the tokens. It's like a registry for tokens.
02:47:07.606 - 02:47:34.254, Speaker A: So in order to create to transfer to Mint tokens, you need to call this centralized program that is native on Solana and perform some token operations. So what we are going to do here, we have the SPL token contract here. As you can see, we wrapped it in the SPL token interface.
02:47:34.254 - 02:47:47.730, Speaker A: This is the interface for Solana. We also have metaplex. Metaplex is where the metadata for all the tokens resides in Solana.
02:47:47.730 - 02:48:07.558, Speaker A: So we also need this to get the token name, the token symbol and so on. So we also need this contract in Solana. As you can see, we are using some pre compiles and we wrapped the ERC 20 interface.
02:48:07.558 - 02:48:32.290, Speaker A: We wrapped it to call the underlying either Metaplex or SPO token. And what we are going to do now is we are going to deploy an ERC 20 on Neon EVM that under the hood will basically create a Solana SPO token and we can transfer it back and forth. So let's just see our script.
02:48:32.290 - 02:48:43.202, Speaker A: It's just a straightforward script. We get the contract factory for ERC 20 for SPO mintable. As you can see in this contract we have two tokens.
02:48:43.202 - 02:49:11.726, Speaker A: One is ERC 20 for SPL and the other is yeah, ERC 20 for mintable. The only difference is that we have exposed Mint functions here and the deployment script is actually pretty straightforward. We take the contract factory, deploy it and then we mint tokens.
02:49:11.726 - 02:49:46.090, Speaker A: So why we put nine decimals here is because Solana don't store variables in 256 bits but 64. And basically we don't want to have a big decimals because otherwise we will sacrifice to have really low really low cap of how much tokens we can have. So nine decimals is okay.
02:49:46.090 - 02:50:11.510, Speaker A: Let's just try and deploy it. Yeah, sure. It okay.
02:50:11.510 - 02:50:28.140, Speaker A: Now the most interesting part and again. Yeah. Okay, so we deployed, let's try to verify it.
02:50:28.140 - 02:50:50.180, Speaker A: We need to provide arguments. Okay, we don't have more time. So let's just see the transaction and I want to show you the interesting thing.
02:50:50.180 - 02:51:11.494, Speaker A: Okay, so you can see we have two transactions. One is the contract created and the other one is the Min transaction. So if we go to the contract create transaction, you can see we have 25 Solana and this is actually the deployment transaction.
02:51:11.494 - 02:51:41.250, Speaker A: Nothing that interesting. But for the other transaction you can see that here we transferred from zero address to our address 100 tokens. Right? And if we go and see and check the Solana transaction, you can see that on Solana again, we have Mint.
02:51:41.250 - 02:51:59.426, Speaker A: So it means that we have created native Solana SPL token. We deployed it and we can natively from Neon DevNet access Solana liquidity. And if we scroll down a bit, we can see that.
02:51:59.426 - 02:52:17.550, Speaker A: For example, here we have the token program. Basically that mints those tokens. So that was pretty much it.
02:52:17.550 - 02:53:08.340, Speaker A: And do you have any questions regarding Neon? And yeah, so Solana, because Neon EVM is inside Solana contracts can interact natively with Solana contracts. This was actually the demo I wanted to show you how we interact with SPL token program. And basically that's a good thing because you can create composable modules for Solana but writing solidity code and don't change your tech stack and that's pretty nice.
02:53:08.340 - 02:53:29.370, Speaker A: Only maybe I can just tell you about one problem that is not compatible. But I think most of the row ups and L two S have it. You cannot use block timestamp and block number as mapping index.
02:53:29.370 - 02:53:44.140, Speaker A: This is still not supported. But it's not I mean, I've never seen it protocols use block number and block timestamp as index. Most probably as mapping value, but not as key.
02:53:44.140 - 02:53:56.110, Speaker A: So I guess there is no more questions. Thank you very much, guys. Thank you.
02:53:56.110 - 02:56:45.810, Speaker A: It present amount that if you haven't go out of the speaker view. Nice test. Here's the trick.
02:56:45.810 - 02:56:53.960, Speaker A: Should I try? It works. Break this up. There should be two browser windows here.
02:56:53.960 - 03:01:09.700, Speaker A: Okay, great. Nice meeting you all. I'm Fabri from Xmdp and this is Nick and we are going to introduce you to the secure messaging network for Webfree.
03:01:09.700 - 03:01:28.748, Speaker A: So you might have seen in the news that Xmtp launched with Coinbase Wallet last week. If you haven't tried it yet, the only way to get access to the feature is by scanning one of these QR codes here. But it's pretty cool.
03:01:28.748 - 03:01:33.224, Speaker A: You get wall to Wallet messaging. Inside Coinbase wallet. There's no signatures.
03:01:33.224 - 03:01:38.720, Speaker A: There's no Web. Three UI. It really looks like a messaging app.
03:01:38.720 - 03:02:00.030, Speaker A: And so if you scan this QR code right now, we can show you what it looks like on the other end. All right, let me do something. So this is Xmdp Chat, another app on the Xmdp network.
03:02:00.030 - 03:02:55.170, Speaker A: If you scan that QR code in the last slide, you can send us message and say hi and it'll show up right here. Any takers? Show the QR code? Yeah, maybe it oh, look at this. So it all works in real time.
03:02:55.170 - 03:03:13.012, Speaker A: And this is interoperable across all 350 apps in the Xmtb network. You can also do it from Converse, which is a great mobile app built here in Paris. We just focus on building an interoperable messaging standard.
03:03:13.012 - 03:03:27.320, Speaker A: None of these apps are ours, other than this one you're looking at right now, which is a reference implementation. Yeah. So let's start with a problem, right? So we can think of communications today as being broken.
03:03:27.320 - 03:03:35.420, Speaker A: This is how web two works. Independent platforms that don't communicate with each other. They store the information.
03:03:35.420 - 03:03:48.416, Speaker A: We are not the owners of the information, so we think this should be better. There is also the thing that in each of these centralized servers, you don't own your identity, right? They own your identity. We only rent it.
03:03:48.416 - 03:04:06.000, Speaker A: So Web free is conversion into this unique identity, which is called the Wallet. And what the Wallet means is that we own our assets and we also own our communications. And that's on the side of Web Two and communications.
03:04:06.000 - 03:04:21.472, Speaker A: But we can also think about more practical challenges that today exist in Web Three, that is that we cannot message. There is no open channel between Wallet to Wallet communications. So if you're a developer and you're building a DAP or a protocol, you cannot communicate with your users.
03:04:21.472 - 03:04:37.650, Speaker A: If you are a creator, you cannot communicate with your audiences who purchase NFTs. And again, there is no way for users to communicate with each other. So for this, Xmdp has proposed a solution that Nick is going to introduce to you now.
03:04:37.650 - 03:04:48.112, Speaker A: Sure. So Xmdp is an open protocol for Web Three messaging. We already have 350 apps built on top of this protocol.
03:04:48.112 - 03:05:01.560, Speaker A: We have SDKs for every popular language. If you want to build an app this weekend, we have the tooling to support you. It is gasless very fast to set up, totally free to use.
03:05:01.560 - 03:05:20.888, Speaker A: And so when anyone builds an app on the Xmtp network, you can immediately reach any of the Wallets that are already on the network, which we have about a million wallets today. Let's look at some of the examples. This is converse, which is imessage of Xmtp.
03:05:20.888 - 03:05:34.480, Speaker A: It's really fast, really clean, and gets push notifications right to your phone. Just a great simple messaging interface. This is Orb, which is the biggest mobile app for the Lens ecosystem.
03:05:34.480 - 03:05:42.240, Speaker A: Lens is partnered with Xmtp. If you've used Lens, you probably have an Xmtp identity. You might not even know you're using our protocol.
03:05:42.240 - 03:05:54.532, Speaker A: But we power the DMs all across the Lens ecosystem and another 300 plus apps. Let's see if this video plays across all different categories. We have web three gaming.
03:05:54.532 - 03:06:29.156, Speaker A: We have NFTs messaging their holders, decentralized marketplaces, really a broad range of applications, all running on one protocol, all able to talk to each other. So why don't we dig in and look at some of the code and see what it's like to build an app on Xmtp. We have a replet here, so anyone with their laptop, you can follow this short link and follow along just in the replet.
03:06:29.156 - 03:07:00.240, Speaker A: You make changes on your own. Or you can scan that QR code and that'll also send you to the replet. Give you guys another second to take down the link before I hop over it.
03:07:00.240 - 03:07:17.204, Speaker A: All right, so this replet single file, really small app, just to test the basic functionality of Xmtp. For the purposes of this demo, we are not going to deal with wallet connections. We're just going to spin up a random wallet.
03:07:17.204 - 03:07:37.450, Speaker A: So in your app, you'd have to use something like Wallet Connect to get access to a wallet. But here we are just going to use the very helpful create random create a random wallet when this app starts up. Now, if you want to create an Xmtb client, you import the library.
03:07:37.450 - 03:07:45.430, Speaker A: Client Create pass in a wallet. This would be any ether signer or something compatible with that. And an environment.
03:07:45.430 - 03:08:10.470, Speaker A: We're going to use the dev environment since this is a demo and we don't want to send messages that people are going to see in their actual apps. And first thing we can do is just check and see if a user is on the network. So to message someone on Xmtp, they have to have used some Xmtp app at least once.
03:08:10.470 - 03:08:27.950, Speaker A: We have a handy function client can message that will tell you yes or no. Is this wallet address on the network. So why don't we try running this perfect hit run and it'll build this app and do the can message check.
03:08:27.950 - 03:08:42.234, Speaker A: Oh, maybe it's doing a few more things too. Let's see. Can message true.
03:08:42.234 - 03:09:04.820, Speaker A: So we were just looking at Fabri's wallet, which thankfully he is also using the network and working here. Maybe we could do a few more things here and send Fabri a message. So we're going to uncomment this function and this function and we're going to comment this one out.
03:09:04.820 - 03:09:25.738, Speaker A: So in Xmtp, everything runs over conversations, which is an abstraction we use to make it easy to manage your chats. To start a new conversation with a wallet address, this is all the code you need. New conversation, wallet two, which is Fabri's address.
03:09:25.738 - 03:09:35.100, Speaker A: So we can create that conversation. And then down here, we just use this conversation and we send a GM. Let's see if this all runs too.
03:09:35.100 - 03:09:46.524, Speaker A: All right. Message sent. Send a GM.
03:09:46.524 - 03:10:06.070, Speaker A: That is really all it takes if you wanted to get fancier. We do support custom content types and so you can add codecs to your Xmtp SDK for things like images or videos or file attachments. We have some new content types like reactions and replies that you can play with.
03:10:06.070 - 03:10:26.236, Speaker A: But the basics of Xmtp are just text messages, and that's the one thing that is universal across all the apps in our ecosystem. Now, let's see if we can do this in real time. I'm going to switch the environment to production so that people can actually send us a message.
03:10:26.236 - 03:10:46.556, Speaker A: And we are going to listen for messages on the network. This is obviously useful when you're building a client side app where you need to see things coming in in real time. And so we have this very helpful Stream All messages function and all it does is calls Xmtp conversations, stream all messages.
03:10:46.556 - 03:11:02.330, Speaker A: This is going to get the full list of conversations that this brand new wallet has. And it's going to get all the messages coming in in real time for each of those conversations. And so it's just going to print them to the console here.
03:11:02.330 - 03:11:23.576, Speaker A: I'm also taking the time to answer your DMs, so it's me. All right. Going to run this and it's going to print out a QR code for this random wallet.
03:11:23.576 - 03:11:36.796, Speaker A: Let's see if this is actually legible. All right, let's see. If you scan this, you should be able to send a message that'll actually get printed out in the terminal here in real time.
03:11:36.796 - 03:12:04.460, Speaker A: I'm going to try it myself. Maybe the QR code is a little mangled because of the display set up. Let's try this one more time with it, actually.
03:12:04.460 - 03:12:28.110, Speaker A: Yeah, I think let's try and print it again with I'm sorry, you're going to have to get a new QR code here. Oh, hey. All right, we got a first GM.
03:12:28.110 - 03:12:44.180, Speaker A: So that's all it takes to have a real time listener for Xmtv messages set up the terminal. This is maybe 50 lines of code and a lot of that's pretty lightweight. Awesome.
03:12:44.180 - 03:13:01.960, Speaker A: It someone's using this for some free advertising space. I appreciate the hustle. I respect that.
03:13:01.960 - 03:13:19.420, Speaker A: Did someone try and send us money? That second last one, I think that's a payment. Oh, that money's gone. This is an Ephemeral wallet that just went basically to the burn address.
03:13:19.420 - 03:13:32.570, Speaker A: I appreciate it. All right. The WiFi hand in here is pretty poor.
03:13:32.570 - 03:13:40.754, Speaker A: Takes some time. Yeah, there's also one other function here. If you just want to stream messages from one conversation, that's equally easy.
03:13:40.754 - 03:14:02.620, Speaker A: This just spits out an async. Iterator so you can just do away conversation, stream messages, and that'll give you just the messages for a single conversation, which can be helpful if you're building a chat app. So before we move on, any questions about this code? Anything that seems a little too mysterious, happy to field those in real time.
03:14:02.620 - 03:14:22.268, Speaker A: All right, back here. Real time message in every single conversation. Exactly.
03:14:22.268 - 03:14:45.190, Speaker A: Including newly created conversations. So there's kind of two streaming functions in Xmtv to stream the conversations, which will just let you know, hey, someone start a new conversation, but not give you the messages and stream messages from the conversation. And that API just ties the two of them together to make it really simple to build an app that has all the messages from all the conversations in one.
03:14:45.190 - 03:14:55.988, Speaker A: Yeah, so this is the basic concepts around Xmtp. So it's basically creating conversation and sending messages. And we are now working on group chats.
03:14:55.988 - 03:15:09.068, Speaker A: Read receives reactions to messages. There is also a way to send media attachments like image and video, so that's on the SDK level and on the protocol level. Nick, you want to tell? Yeah.
03:15:09.068 - 03:15:30.592, Speaker A: So Xmdp has a roadmap that we've shared publicly in our GitHub discussions around decentralization. There's a bunch of milestones we have to hit to get this point where anyone can run their own nodes and then anyone can get paid to run their own nodes. Right now Xmdp is operating the nodes in the Xmdp network.
03:15:30.592 - 03:15:46.148, Speaker A: We'd really like to get out of that business. And so we are working hard on decentralizing our network so that we can be a small minority of all the node operators. Also working on the next version of the Xmtp encryption protocol.
03:15:46.148 - 03:16:12.992, Speaker A: That's something that a lot of developers have been asking for better ways of revoking keys, of having device specific identities, so that if an app gets compromised, if there's a bad actor on the Xmtp network, that maybe is phishing people, that we can really limit the damage from that. And that's going to be rolling out in the next few months, which should come in the form of disappearing messages. Yeah.
03:16:12.992 - 03:16:24.832, Speaker A: As far as our developer tools, we have an SDK for basically every language, not only on Web but on mobile. This was a demo of the JavaScript SDK, but we also have, for example, React native. We have swift and android.
03:16:24.832 - 03:16:36.356, Speaker A: So check out our docs. You will find more information about the whole experience of sending your first message and you will find a lot of tutorials. We are trying to push into multiple use cases.
03:16:36.356 - 03:16:56.800, Speaker A: For example, you see Coinbase using a finance use case about sending money through messaging. We think that there is room for a lot more. So I invite you to check out the docs and see how it's using marketing, how it's using commerce, decentralized social, as we see with lens automation and support like creating chatbots.
03:16:56.800 - 03:17:13.104, Speaker A: And if you are going to build on a hackathon, I recommend you to check out our playground. Where is the beta versions of group chat, replies, reactions and read receives. And there is also the way to do broadcasting.
03:17:13.104 - 03:17:20.756, Speaker A: So if you want to send like a message one too many, there is a way to do that. So that was our talk. I'm fabri.
03:17:20.756 - 03:17:26.090, Speaker A: I'm Nick. Thank you all. Yeah, happy to answer any questions you guys have.
03:17:26.090 - 03:17:53.216, Speaker A: Thank you. Could you describe properly the overall architecture of Xmtp? Should have let that slide in for me for the introduction. It could be really good to have it.
03:17:53.216 - 03:18:12.408, Speaker A: Yeah, absolutely. So the Xmtp nodes are built on top of Waku, which means they use Lib P to P under the hood to create this mesh. You connect to one node through our API and publish it and then it will get gossip to all the other nodes in the network, which is how our subscriptions can work in real time.
03:18:12.408 - 03:18:24.908, Speaker A: Even if two users are talking to different nodes, we have a pretty big storage layer underneath it. So we can store messages on the Xmdp network forever. I think that's something in future versions we might not need.
03:18:24.908 - 03:19:08.452, Speaker A: But today a message can just get persisted onto our network in perpetuity, which makes it really easy to sign in across different applications. Okay, and another question, would that scale like Telegram or WhatsApp? And why are we still using Telegram, for example? And what would be the next application you see that could replace this kind of messaging applications? Yeah, why are we still using Telegram? At least the people in this room when there's good web three native alternatives? I don't know. I basically stopped using Telegram and just got people to message me on Xftp and it works great.
03:19:08.452 - 03:19:33.548, Speaker A: And we're not some shady company flying around the world between Russia and Dubai. We're right here and pretty transparent about how we handle end encryption, which is more than I could say about Telegram. Yeah, I think building identity layer where people are really thinking about themselves through their web three identities first, that's going to be the blocker.
03:19:33.548 - 03:20:00.580, Speaker A: A Telegram is great because it uses the phone number as an identity layer and phone number is something that people widely understand. And getting my mom to use her ENS as her primary identity, I think that's going to be uphill battle that we as an industry have to solve to make this easy, cheap and just painless experience. And then once that happens, Xmtp is ready to take on the messaging traffic.
03:20:00.580 - 03:20:15.468, Speaker A: Yeah, we're pretty comfortable with our ability to scale to deal with large volumes of messages. Awesome. What is the name of the app on the App Store? So there's a few that are in the App Store if you're into the lens community, you can use Orb.
03:20:15.468 - 03:20:37.680, Speaker A: Converse is the imessage of Xmtp and Coinbase wallet. If you've scanned one of those QR codes on the screen, you have access to this new feature of Wallet to Wallet messaging inside Coinbase Wallet directly. Sure.
03:20:37.680 - 03:21:17.982, Speaker A: How does the encryption and decryption work for Group Chats? Because I guess in one on one conversation you encrypt with a private key the other way around. But with group chat, can I do it to be like token gated? Yeah. So in the first version of Group Chat that we've just released this alpha for, the way that all permissions in the group chat work is someone in the group has a key that is secret for the group and they can share it to anyone that they would like.
03:21:17.982 - 03:21:48.230, Speaker A: And they send an announcement that says, hey, I shared this with Bob, I shared this with Joe. And you just pass that key around and so it'll be up to the application layer to add additional checks. On top of do you have the so, you know, if you have an app that is only for holders of some particular NFT, you would in addition to checking, can they send a message on Xmtp, you'd also check, do they hold this NFT? And if not, you make their messages disappear at the application layer.
03:21:48.230 - 03:21:58.540, Speaker A: Exactly. Yeah. We've had a number of people do this with one to one chat, but because Group Chat is so new, if you were working on a project like that, I think you'd be the first.
03:21:58.540 - 03:22:16.210, Speaker A: Thank you. Any other questions? Oh, sure. Do you perform any censoring on the message transfer? Xmdb has never censored a message on the network.
03:22:16.210 - 03:22:43.260, Speaker A: Part of our privacy goals are that we should not have enough information to be able to censor a message. Every version of the SDK removes more and more metadata to make it harder and harder for us to censor a message. So why would we censor something when we don't even know who it's from, who it's to, what it's about? It would just be very difficult for us to censor even if we were compelled by law.
03:22:43.260 - 03:23:06.510, Speaker A: Right now, blocking is done at the application layer. It's something we're thinking a lot about and there's some public discussions around consent on the network and how we might do that in a protocol level way. But today applications have blocking built in and unfortunately that doesn't sync between different apps on the network.
03:23:06.510 - 03:23:35.662, Speaker A: But if you use Coinbase Wallet, for example, they have a nice block feature. You block someone and it won't show up. At least inside Coinbase Wallet for you for adding the image attachments, what's the way to do that? Is there a plugin or is it copy pasting the code from XMP Chat or what's the best way to do the image attachments that is in there? Yeah.
03:23:35.662 - 03:23:42.686, Speaker A: So image attachments, the images are stored off network. We have, I think, now a. Guide.
03:23:42.686 - 03:23:59.750, Speaker A: Is that right around images? Yeah, it's on our dogs. So you can copy paste if you like, but we have also this public content types repo. So you can just import the content type, and that'll give you the boilerplate code for rendering these images or at least downloading them.
03:23:59.750 - 03:24:12.762, Speaker A: And then images can be stored wherever you like. And so we include an encryption key and a hash of the image in the Xmtp message. That means you could store it in IPFS, which we recommend.
03:24:12.762 - 03:24:33.220, Speaker A: But if you wanted to store it on your own servers or on S three, that would also be totally fine because the images are encrypted and there is a hash. So if someone monkeyed with the image after it was initially sent and replaced it with something else, it would fail to decrypt. And so it gives you a lot of flexibility to do images however you like for your application.
03:24:33.220 - 03:24:48.528, Speaker A: Like, we can show the playground maybe? Yeah, sure. We have five more minutes. Yes.
03:24:48.528 - 03:24:56.168, Speaker A: No. Okay. Yeah, no worries.
03:24:56.168 - 03:25:00.116, Speaker A: Thank you. Okay. Thank you.
03:25:00.116 - 03:28:35.600, Speaker A: Everyone dropped a phone. Anybody left a phone? You? How's it going? Nice to meet you. Oh, no, you're good? Are you with you bobo? Yeah.
03:28:35.600 - 03:29:27.660, Speaker A: Nice. Awesome. Okay.
03:29:27.660 - 03:29:41.440, Speaker A: What did you say? How much time? Yeah, okay. Yeah, perfect. I think mine's 20 minutes.
03:29:41.440 - 03:30:18.336, Speaker A: Okay, thanks so much. Okay. All right.
03:30:18.336 - 03:30:21.028, Speaker A: Can you hear me? Okay. All right. Hey, everyone.
03:30:21.028 - 03:30:37.400, Speaker A: My name is Alex. I am an integrations engineer at Uma. For the past few years, I've had the privilege of working with a bunch of integrations prediction markets, insurance protocols, and recently with DAOs, helping them with optimistic governance.
03:30:37.400 - 03:30:59.548, Speaker A: Really the focus. Today, I'm going to talk about using OSNAP to decentralize your Dao, but I really just want to make sure that everyone understands kind of how Uma works and how you can use it in your projects this weekend. So what does Uma actually do? Uma is an optimistic oracle that records truths about the world onto blockchains.
03:30:59.548 - 03:31:27.876, Speaker A: So what does that mean? You can pretty much make any statement you can use which Team won out of Team A or Team B. You can say, Is this a valid snapshot proposal? And then essentially, you can propose a transaction and attach a bond to that transaction that essentially enters into a challenge window. And during that challenge window, if anyone disputes, it's escalated to the token holders to resolve.
03:31:27.876 - 03:31:56.080, Speaker A: And if nobody disputes at the end of that challenge period, it is deemed as valid and can be used in your smart contracts. So, like I said, if the statements are false while Uma's oracle assumes a statement is true but allows anyone to dispute if it's incorrect, during that challenge window, disputes are really rare. We've seen maybe one dispute out of every few hundred markets, and that's because disputes are financially incentivized.
03:31:56.080 - 03:32:06.032, Speaker A: So when you're making an assertion, you have to post a bond. And if you're wrong. When someone challenges that, you lose your bond.
03:32:06.032 - 03:32:21.852, Speaker A: So it's very costly to make inaccurate or bad data in your assertion. And that's because uma's, resolution process is essentially the token holders vote when there are disputes. It's a two phase process.
03:32:21.852 - 03:32:56.564, Speaker A: That first phase is the commit process and during that commit phase, no token holders can actually see other people's votes and they vote based on their belief. And then in the second phase each are 24 hours people reveal their votes and at the end the majority of the votes essentially are used to resolve and essentially resolve that market. So now I just kind of want to talk through briefly some of the current integrations that we have and it might help to kind of click on what kind of assertions we're seeing every day.
03:32:56.564 - 03:33:14.668, Speaker A: This is one that I just pulled from Polymarket. It's a prediction market and it's basically asking if Oppenheimer grossed over $50 million domestically on its opening weekend. And I think that this is a good example because Polymarket could have stopped there and that's all they asked and they probably would have gotten the right answer.
03:33:14.668 - 03:33:47.540, Speaker A: But when you're making statements to Uma, I think it's really important to include a data source and really think it through any edge cases. So if you go to this box office mojo and there are estimates and that could cause some confusion when people go to resolve this or make an assertion that this is resolved in doing that. So Polymarket predicts, they actually specify use the final not estimates, even though it seems obvious it can cause confusion and cause disputes.
03:33:47.540 - 03:34:28.380, Speaker A: And another example is we have Cozy and Sherlock, they're both prediction markets and this is just basically was there a hack bug, user error or malfeasance? And again, it's basically just asking if 50% of user funds in Curve was hacked before or after a specific block number on Ethereum. And again, I think these details that they're providing a specific block and a specific value of 50% or more. So there's not going to be any confusion in terms of like if there's a small bug in the UI or something like that that causes a couple of $1,000 that's not disputable or that's not something that you can actually claim as a hack.
03:34:28.380 - 03:34:41.780, Speaker A: It has to be 50% of those user funds. So I think that's an important distinction when you're kind of thinking about what you should be asserting to the Oracle. And here are some other examples of our integrations.
03:34:41.780 - 03:35:11.120, Speaker A: Across is our cross chain bridge and basically how it works is it would be really capital and efficient to make a proposal every single time someone went from one chain to the next. So all of the transactions are bundled in basically a few hour period and that's what's proposed to the chain. Another example is decentralist and essentially asks do all, I mean it's, it's essentially verifying addresses on a list.
03:35:11.120 - 03:35:31.364, Speaker A: So like it could verify blacklisted wallets or wallets involved in a hack. I think one of their first lists asking what Uma addresses voted correctly 80% of the time. So you can kind of think of how you can use this to use Uma to verify these address lists.
03:35:31.364 - 03:35:45.688, Speaker A: And then the last one is Polymarket is just asking TVL at a certain date. But I think it's kind of cool to see these three different use cases. I mean, one is a very bot driven cross chain bridge.
03:35:45.688 - 03:36:00.800, Speaker A: One is a manually proposing addresses to a list. And then this pull together one for TVL is just using DeFi llama's API. So it really shows just how flexible all this can be when you're using data with Uma.
03:36:00.800 - 03:36:29.610, Speaker A: And I guess how does all these apply to governance? Yeah, I mean, this is the typical governance flow and there's on chain there's forking compounds governance contract. But this is what we're kind of seeing on a typical governance flow. You first have a forum discussion, and that's basically a period where anyone can propose an idea.
03:36:29.610 - 03:36:50.944, Speaker A: And typically Dao stewards or the community come in and make comments and make sure that the proposal is aligned with the actual dow, like what the dow actually wants to do. And then when everyone kind of gives it the green light, it usually goes to a Snapshot vote. And Snapshot is actually really good in a lot of ways.
03:36:50.944 - 03:37:08.660, Speaker A: Even though it is off chain, it gives a lot of control, such as the quorum, the voting period. You have a lot of flexibility with your voting strategies. If there's LP tokens, giving them voting power on chain would be really difficult.
03:37:08.660 - 03:37:16.404, Speaker A: But with Snapshot, yeah, it's no problem. You can just add it as an ERC 20 balance strategy. So there are some advantages of using Snapshot.
03:37:16.404 - 03:37:33.180, Speaker A: The problem is the multisig implementation. You're essentially just signaling on Snapshot and the votes aren't really binding. So what we really wanted to create with OSNAP is a way to enforce the votes of Snapshot.
03:37:33.180 - 03:37:54.084, Speaker A: And yeah, that's what we're really pushing is reducing the reliance on the multi sigs because dow coordination efforts just don't mean anything if it's just signaling support and it has no actual execution on chain. I'm sure you've seen a lot of these multi SIG problems, I think. Yeah.
03:37:54.084 - 03:38:17.820, Speaker A: The first one multisig signers can act against the will of their community for the most part, the dow and the community and the multisig is usually aligned. However, if you're asking the multi SIG to remove themselves as a signer or pay themselves less, that could be delayed or not executed at all. The other issue is just the regulation.
03:38:17.820 - 03:38:44.784, Speaker A: Dows are not resilient at all. If you're essentially relying on a few individuals that you can go into a discord and find these people, they oftentimes have ENS names attached to their wallets or their KYC. How decentralized and resilient is a dow if all you have to do is go after the multisig signers as regulators.
03:38:44.784 - 03:39:15.192, Speaker A: So they really are a target. And the last thing is just the burden of signing multisig transactions is not fun. I always ask kind of what's the process of multistick signers, how they review transactions? And they kind of laugh at me because I don't think the review process there's a lot of trust involved and they typically just trust whoever is asking them to sign that transaction.
03:39:15.192 - 03:39:30.048, Speaker A: And the problem with that is the community depends on these signers to always be accurate. I mean, it only takes one transaction signed wrong with the multisig for essentially the Dao to go down. So that's really why we created OSNAP.
03:39:30.048 - 03:39:58.360, Speaker A: It allows the Dao to be the multi SIG. So now anybody can initiate a transaction and that can be proposed by the community, it can be proposed by the multisig multisig holders, or it can be proposed by anyone that's not even involved in the Dao. And that's powerful because you're essentially not only allowing anyone to initiate a transaction, you're also allowing anyone to dispute.
03:39:58.360 - 03:40:14.048, Speaker A: And this works the same way as Polymarket did with the prediction market or Cozy did with the insurance. And the truth is economically incentivized because you're posting a bond when you initiate these transactions. And the challenge windows can be two or three days.
03:40:14.048 - 03:40:33.476, Speaker A: And so if you have to post ten WETH and someone comes in and disputes you, you're essentially losing that ten WETH. So it's very costly and people are very careful when they're proposing these transactions. And I think the most underrated feature of this is transactions are transparent when voting.
03:40:33.476 - 03:40:46.024, Speaker A: So they're actually included in the snapshot proposal. And I think that's a huge step forward. You can actually look at the transactions when you're voting on snapshot and it's just so much more transparent.
03:40:46.024 - 03:41:04.160, Speaker A: So if something is wrong with the transaction payloads, you're noticing it while you're voting and you're not waiting essentially for that multi SIG signers to then execute those transactions. So this is just a quick overview of the flow. You have your safe deploy the OSNAP module.
03:41:04.160 - 03:41:26.388, Speaker A: You can then set some custom parameters or keep the default. And then the rest of the flow is pretty much the same all the way through creating a snapshot proposal, except you have a transaction builder at the last step where you're able to input transaction payloads. And if the snapshot proposal passes, you can then propose and execute those transactions.
03:41:26.388 - 03:41:46.620, Speaker A: And if someone does dispute, it goes to the token holders to vote on. I think an important distinction, though, is that the resolution value that the token holders are resolving is not actually executed by the safe. So they have no control of the transaction payloads that are being executed.
03:41:46.620 - 03:42:19.428, Speaker A: So if there's a dispute, that actual proposal is deleted and then it needs to be re reposed. So, uma, token holders actually have no control over what's being executed or so I kind of looked at the rules of or sorry, the assertion of prediction markets and insurance. And this is kind of what's proposed for OSNAP, where you're really validating if the proposal was approved on snapshot.
03:42:19.428 - 03:43:07.192, Speaker A: The snapshot space, you're looking at the quorum and the voting period, which are actually these are just example values, but these are what are usually set by the team in snapshot and to basically confirm that Snapshot voting system is not being exploited or otherwise unavailable. So it's a very straightforward validation process and you can kind of see what these transactions look like in Snapshot. And I created a proposal before this and it's basically asking, yeah, is this transaction proposed during the ETH global demo? So this voting period has already been completed, so I can just go in here and actually just request this.
03:43:07.192 - 03:43:24.770, Speaker A: And when I'm requesting, it alerts me. What is the required bond to post? I made it zero because this is on testnet and the challenge period is two minutes. And in production, this is two or three days with a bond of typically $5,000.
03:43:24.770 - 03:44:06.186, Speaker A: So, yeah, I signed that and you can kind of see it'll alert you when these transactions are able to be executed. We won't wait the two minutes, but after this period is over, you'll then be able to go through the same process to actually execute the transactions which will send this ETH to this address. So we have some bounties we'd love for everyone to build as much as they can on Uma, using pretty much any use case that makes sense to you.
03:44:06.186 - 03:44:16.480, Speaker A: Our first place is $5,000. Our second place is 2000. And then we have a pool price pool prize for anyone that uses Uma for $3,000.
03:44:16.480 - 03:44:34.870, Speaker A: And also we're always hiring, so if you are someone that's interested in working with us or know anyone that is interested, come to our booth or feel free to go to this link or just come find us. You're not going to remember this link. All right, thank you.
03:44:34.870 - 03:45:09.190, Speaker A: And any questions? Outcome e was that was the Snapshot space. So essentially you would deploy the safe sorry, you would deploy the OSNAP module with that safe, and then you could go into the Snapshot settings and add the OSNAP module into that space. And in the rules of the OSNAP space, you'd want to include that space that you're governing over.
03:45:09.190 - 03:45:38.640, Speaker A: So when you went into Gnosis in the Zodiac module, you would specify that Outcome finance space and then you would add it to the space in Snapshot. And who is usually a signer in this initial? It's typically the team. So, yes, you'd have most dows that we talk to, they have core members of the team that are the signers.
03:45:38.640 - 03:45:59.752, Speaker A: And so what this would allow anyone to actually propose the transactions and it can still be the core members. I think we've probably seen that several times, but what it still does is allows it to be a much more transparent process. And I think the big win is, like, those transactions are in that snapshot space.
03:45:59.752 - 03:46:26.260, Speaker A: They're transparent, what's actually being signed. And yeah, if they're signing something that is not actually valid, it can be disputed. Where can we find them? Yeah, you can build anything using the Uma's Oracle, or you could also use a cross chain bridge.
03:46:26.260 - 03:46:45.276, Speaker A: So if you have any type of cross chain use cases, you could absolutely use across for that. I think that it's really open ended. So if you have any type of data off chain calculations or anything like that that you want to use in your contracts, I think Uma is a great use case.
03:46:45.276 - 03:47:19.590, Speaker A: And, yeah, it's very open ended in terms of what you want to build. Do you have any questions? Let's say someone proposes a transaction on Snapchat. What are the conditions under some malicious transactions, for example? Yeah, that's a good question.
03:47:19.590 - 03:47:51.584, Speaker A: Really? It would only be malicious if it didn't follow these rules. So if there was a snapshot vote, but the quorum didn't actually, like, of the vote, didn't actually meet the minimum of the rules, or if the voting period set in that proposal wasn't long enough, that was specified on the OSNAP module. So the other would be like, yeah, if someone proposed transactions that didn't actually pass.
03:47:51.584 - 03:48:24.330, Speaker A: So if you go into I think it'll help to see kind of well, actually, this might be difficult. Like, if you go into the Ostap module, you'll see the rules specified in that module that essentially govern over that space, and you can change these rules and these parameters. But, yeah, this is what really is holding those snapshot proposals as valid or invalid.
03:48:24.330 - 03:49:12.720, Speaker A: Any other questions? All right, thanks for coming. Thank you. It's getting yeah, we'll check.
03:49:12.720 - 03:58:04.152, Speaker A: Where's that? All right, check. One, two, three. It's not on yet, is it? Okay.
03:58:04.152 - 03:58:08.488, Speaker A: All right. Okay. He's having a smoke.
03:58:08.488 - 03:58:12.830, Speaker A: Can't start till the he's back. Okay. Two minutes.
03:58:12.830 - 03:58:31.960, Speaker A: Sure. You stay next to me too. Sure.
03:58:31.960 - 04:00:05.110, Speaker A: They want to crowd the campaign. All right, let's get started. Good evening, everyone.
04:00:05.110 - 04:00:15.668, Speaker A: I'm Jason Goldberg, founder and CEO of airstack. And I'm here with Rishi Thakur, one of our senior developers. Today we're going to give you an overview of airstack.
04:00:15.668 - 04:00:39.020, Speaker A: Rishi is going to show you how to write some more complex queries. I'm going to first provide an overview of the APIs that we provide, and then I'll show you how you can use our AI engine to write your queries, give you a glimpse of our new Explorer that we launched yesterday. So it's a graphical interface on top of our APIs, and then I'll head over to Rishi to go into some of the queries.
04:00:39.020 - 04:01:14.300, Speaker A: First of all, we want to make it as easy as possible for you to integrate any Web three on chain and related off chain data into your apps. The whole mission of the company is just make it easier and easier for developers to integrate with the things outside of their apps, so you can focus on your app, use our APIs to get the data about everything else. And so everything we do on a roadmap is all about how do we make it easier and easier so that you don't even have to run any backend infrastructure if you don't want to, to be able to bring data in about your users, about their on chain activities and things that increase relevance.
04:01:14.300 - 04:01:34.572, Speaker A: So first I'll just show everyone really quick the APIs that we have. Let me go here. So, airstack offers a number of APIs today, and just from a company strategy standpoint, we decided to go really deep on Ethereum and Polygon.
04:01:34.572 - 04:02:00.680, Speaker A: So rather than doing like ten chains and doing a little bit on each, we decided to go really deep on these two chains. We also have Poops on Gnosis, but really deep on Ethereum and Polygon, and offering features and API access, especially around social and identity that you don't find anywhere else, and helping solve very specific use cases. And then we'll take all that in the coming months to other chains going on the left hand side.
04:02:00.680 - 04:02:19.272, Speaker A: We provide APIs for tokens, ERC, 27, 20, 111, 55, every transaction since the Genesis block and new transactions within seconds are coming through our nodes. Very strong, obviously. Also in NFTs, we also offer resized NFT images inside of our APIs.
04:02:19.272 - 04:02:34.612, Speaker A: You don't have to go out to IPFS and fetch images, it's all right there in our APIs, which we'll show you in a second. We also are the first and only indexer right now of, ERC, six, five, one token bound accounts. Rishi will show some examples of that.
04:02:34.612 - 04:02:43.556, Speaker A: And we're thrilled to work with the token bound working group. Very close with the team there. And a lot of developers building on 6551 see huge potential in that.
04:02:43.556 - 04:02:56.600, Speaker A: And we'd love to work with you. If you're thinking about building on 6551 here in Paris, you can also use Airstat to get all token balances, token transfers of users. And then, as I said, we're especially strong in identity.
04:02:56.600 - 04:03:16.428, Speaker A: So we have fully indexed ENS, subdomains and regular ENS domains, lens and Farcaster. When it comes to social Poops, all six and a half million Poops that have ever been handed to anyone we have inside of airstack and New within seconds. And also as of yesterday, we also index Xmtp.
04:03:16.428 - 04:03:27.744, Speaker A: And so Xmtp you might be familiar with is a messaging protocol enables you to send messages from 10. X address to another. airstack is the only way today you can find out who has Xmdp.
04:03:27.744 - 04:03:51.436, Speaker A: So you could query does this Farcaster address or this Lens or this ENS or who in this Poops has Xmdp. So we enable that as well as a benefit within side of airstack. And the other thing that we do also with related to Xmtp that's really interesting is we act as the universal resolver for Xmtp, right? So with Xmtp, you can message from a zero X address to another zero X address.
04:03:51.436 - 04:04:08.256, Speaker A: But I don't know Rishi's zero X address, but I do know his Farcaster name and he might know my lens handle. And with airstack, the messages get through because we help developers resolve those. So all you need to know is the name of the person that they have, whether it's their ENS or their forecast or their lens, and we help devs resolve that.
04:04:08.256 - 04:04:20.230, Speaker A: We'll show you in a second. And then we have a lot on NFT sales and marketplaces in our APIs as well. So let me go back here and where we go.
04:04:20.230 - 04:04:48.284, Speaker A: Okay, so 1 second, sorry, let me show you. All right, so when you go to airstack, the first thing you'll see is that once you run a query in airstack, if you want to, you can share it with the community. If you want to really start to jump in and learn about the APIs, one of the things you can do is just browse queries other people have done.
04:04:48.284 - 04:05:03.436, Speaker A: So you can see there's a query someone did that has 374 runs and four forks. They've got all, ERC, 27, 21 tokens and poops NFTs to someone or bulk check if a zero X address have Xmtp and primary ENS. And I think Rishi is going to actually show how to write this query today.
04:05:03.436 - 04:05:18.804, Speaker A: And you can just see also there's by different tags, you can see queries that people have done about socials. And you can just dive into any one of these and you can see the GraphQL query that the user did to get this right. And so I'm just giving you an overview.
04:05:18.804 - 04:05:31.208, Speaker A: We'll walk into some of these, walk through some of these in detail in a second. But the first thing I want to show you is the cheat codes. So the cheat codes is we want everyone, obviously, to learn our GraphQL schemas and our APIs.
04:05:31.208 - 04:05:39.324, Speaker A: But you can also get started using our AI engine. Our AI engine is built with GPD four. We've been working on it for seven months now.
04:05:39.324 - 04:05:44.364, Speaker A: It's fully trained on the airstack APIs. It's over 99.9% accurate.
04:05:44.364 - 04:05:54.976, Speaker A: So anything that is in our APIs, it can help you write the query. So I'm going to show you, for instance, I'm going to show you two queries here. First, I'm going to pick on my friend Shane Mack, who's the CEO of Xmtp.
04:05:54.976 - 04:06:11.444, Speaker A: I'm going to say show all NFTs tokens, socials ENS and Xmtp for Shanemac ETH. And I'm going to ask the AI to generate this for me. Pretty complex query.
04:06:11.444 - 04:06:33.244, Speaker A: I mean, this is basically saying NFTs across ethereum and polygon tokens across ethereum polygon socials is both Farcaster and lens ENS and not even providing his UX address, providing his ENS that it's going to resolve. And there he goes, there's the result. And here you can see his Farcaster name is Shane Mack.
04:06:33.244 - 04:06:38.140, Speaker A: His lens is Shane Mac lens. Here's other domains that he has. Here's his tokens.
04:06:38.140 - 04:06:54.344, Speaker A: Here you can see we also bring back the images of those tokens all here in a single query and response. So you can create all sorts of amazing user experiences with this, just from a single API call. Obviously you could also do this in multiple API calls, but the AI helps you learn this.
04:06:54.344 - 04:07:08.536, Speaker A: And just to show you an example, here I mentioned we built an Explorer that we launched yesterday. And this Explorer is a front end to the APIs. I'm going to do the exact same query.
04:07:08.536 - 04:07:25.840, Speaker A: So I'm just going to type in Shanemac ETH and there's the results. And the Explorer is designed in a way where this is entirely forkable. You can grab SDKs for this with react and JavaScript and python.
04:07:25.840 - 04:07:39.104, Speaker A: The code is available for the front end. Here you can get it from our GitHub. And then for any of these queries that you do, like the one I just did from the front end Explorer, you can also jump right back into the GraphQL and get the API.
04:07:39.104 - 04:07:50.552, Speaker A: So here I'm going to go right back in and get the API for that query right there. That made the front end so very easy to learn it either way. You can use the AI or you can use the Explorer front end.
04:07:50.552 - 04:08:01.420, Speaker A: Something else I'll show you from the Explorer real quick is we also not just wallet balances, but also token holders. Here's an example. This is very current.
04:08:01.420 - 04:08:10.764, Speaker A: This is ECC Six. We have aggregated counts of the token holders. You can see the Socials, how many have ENS farcast or Lens.
04:08:10.764 - 04:08:20.764, Speaker A: Pretty impressive actually, that 570 people from the 1136 have signed a transaction on polygon and got a Lens address. Just claim. And here you can see all the token holders.
04:08:20.764 - 04:08:30.752, Speaker A: And then same thing again. If I go to the GraphQL here, you can get that exact query right there. And as I said before, you can also see that the images are resized.
04:08:30.752 - 04:08:48.792, Speaker A: So you can literally just call our APIs and get whatever size you need and plug it right into your application. So you can build something like an Explorer, but you can also do all sorts of other things. And just to show you real quickly, in our docs, we have a number of different use cases.
04:08:48.792 - 04:08:57.720, Speaker A: We have specific around token. Bound 6551 has Xmtp resolving identities. We've also done a lot with contact recommendations.
04:08:57.720 - 04:09:20.704, Speaker A: So we've done work both with Farcaster and with Lens and with Xmtp to help recommend people that, you know, based on your on chain behaviors. So people that you've sent tokens to or sent to you who have NFTs in common, or PO ops that you've been to. Also there's a Lens playground we've built, happy to share if anyone's interested can show you some of that and then lots of other use cases as well that you can dive into in our docs.
04:09:20.704 - 04:09:30.520, Speaker A: Lots of tutorials here as well. All right, over to you Rishi, to get into more. That was the fast overview and Rishi is going to details.
04:09:30.520 - 04:09:37.980, Speaker A: Thanks Jason. Hi everyone. So let's get started with some pretty interesting queries.
04:09:37.980 - 04:10:03.030, Speaker A: So for the first one, let's try and get all the people that hold the Poop for each CC Paris and let's see what extra information we can get after we get those owners. So for that we can use our Poop API over here. We need to pass the event ID.
04:10:03.030 - 04:10:50.890, Speaker A: I have that here and we can see the owners and their addresses. We can see more things about the event such as which country city. This is like the pop event for ECC Paris.
04:10:50.890 - 04:12:05.854, Speaker A: We've got the metadata, we have some description associated with it and this is the owner for this particular token ID. So now supposing you met somebody here at ECC and you wanted to reach out to them and we can even get their primary domain as well as their different social voila. So for example, this user has Xmtp enabled here's, his ENS here's their profiles as well.
04:12:05.854 - 04:12:13.150, Speaker A: So this is one pretty cool query that we have. Moving on. Yeah.
04:12:13.150 - 04:12:41.798, Speaker A: So for the next one let's look more into ERC, six five one and let's try to form a pretty cool query. So we have the accounts here. So this account represents the account which the NFT is owning and let's say we want to get all the, let's start with getting all the ERC, six five for an account.
04:12:41.798 - 04:13:20.214, Speaker A: We can get the address, the token address, token ID, some information about the NFT as well. Right? Yeah, right. So here we have the so this is the address of the contract deployed.
04:13:20.214 - 04:13:48.450, Speaker A: This is the address of the like because this is a wallet so we can get other information about it as well, like whether it has any ENS or any lens accounts. And here we have the NFT and there's metadata related to it for ETH. So we can take a specific token address and token ID and we can add it into our filters.
04:13:48.450 - 04:14:31.992, Speaker A: So token address here and token ID. So yeah, so here we have for that particular NFT, we have the address of the deployed contract and we also have the token address of the NFT which is owning that account and say we want to get the owner of that NFT as well. So you basically have the account, then the NFT and then the owner of that NFT.
04:14:31.992 - 04:14:50.560, Speaker A: So you get the true owner of the entire sort of tree here. For that we just need to go into NFTs. We have token balances and here we get owner and after that we get the addresses.
04:14:50.560 - 04:14:56.644, Speaker A: Yeah. So now we get this particular address here. So this is.
04:14:56.644 - 04:15:30.076, Speaker A: The externally owned account which owns this particular token address and this token ID, he owns this NFT and this NFT is what is owning the account. So just putting that together, we have a pretty complex query here. And using this there can be ways to get like for a given account or a given set of NFDS, we can get all the ERC, six, five one accounts related to that and as well as the owners for it.
04:15:30.076 - 04:15:46.008, Speaker A: So it could be a way to kind of get the total balance of a particular NFT. Because if you have this NFT and each ERC, six five one can hold multiple NFTs and those NFDS again can have 6551. So you get like a complete tree.
04:15:46.008 - 04:16:08.360, Speaker A: So yeah we can get that all through airstack. And for the last query I can show you how to use variables. So rather than entering everything in the UI, we can just take a bunch of variables here.
04:16:08.360 - 04:16:29.340, Speaker A: These are a bunch of addresses that I have and I'm building a query now where we can get a given owner's. For each address we can get their ENS name as well as whether they have Xmtp enabled or not. So you can go through token balance.
04:16:29.340 - 04:17:32.040, Speaker A: How we add a variable in the UI is we select the owner and then we just and this dollar sign here add the variable and here we can just pass addresses and we get their owner. We have their social domains. Let's start by getting their ENS names, profile names and Xmtp is enabled.
04:17:32.040 - 04:18:01.680, Speaker A: Right so here you can just summarize like we have an array of addresses which we're going to pass as a variable and we're getting all this different information about these particular addresses. Let me add a few more. Yeah, so I think a tabular form might be a bit better here.
04:18:01.680 - 04:18:12.736, Speaker A: So we can see like for this particular address there's socials. So this particular user has two socials. One is Cr, which will be on Farcaster.
04:18:12.736 - 04:18:45.296, Speaker A: The other is his lens, the domains which he has, he has three couple of at least ten ENS names here and this particular address has Xmtp enabled. So yeah that's really powerful because in a single query you're able to get the owners and their socials Xmtp status as well as their domain information. And we can even add token addresses as well here.
04:18:45.296 - 04:19:04.228, Speaker A: So you can get for a particular NFT all the owners and their particular social handles and other identity fields. So we'll take questions in a second. Just if you're interested in 6551, definitely recommend reading through the docs that we have on 6551.
04:19:04.228 - 04:19:41.170, Speaker A: And also the 6551 founders are in our dev chat and they're on standby if anyone needs any help deploying your 6551, our team can help somewhat and they're staying by to help. And in particular in our dev docs we also have some queries you can just kind of like replicate on 6551 of the very interesting ones is you can just say show the last ten, or you need to show all 6551s either deployed on Ethereum or Polygon. And if you just add in at the end and all the assets in them, you'll see the whole tree of every asset, the images of the NFTs that those 6551 accounts own.
04:19:41.170 - 04:19:54.936, Speaker A: Obviously, we can go into a lot more. We also can answer any questions one on one or come to our booth. And if you're not in our Telegram chat yet, please join, because our whole team is standing by to answer questions, and we have six minutes to answer questions now.
04:19:54.936 - 04:20:14.968, Speaker A: Go ahead, please. Yeah, I would like to know necessary to pay any fee or yeah, so, airstack is completely free until September 1. Starting September 1, we will have a generous free tier, and then I'll be charged based on usage.
04:20:14.968 - 04:20:22.396, Speaker A: But for now, it's entirely free. There is a rate limit. If you need a rate limit increase, we have five additional free plans right now.
04:20:22.396 - 04:20:34.944, Speaker A: So just let us know what your needs are and we'll give you a rate limit increase. You can just request one from our team sorry. In which network is possible to do queries? Yeah.
04:20:34.944 - 04:20:49.770, Speaker A: So Ethereum mainnet polygon main net and so we do recommend hackathons like we don't index go early right now. We know a lot of folks would like us to, so if you need some matic to use on polygon, just let us know. We'll send you some.
04:20:49.770 - 04:21:12.780, Speaker A: Thank you. Other questions? Yes, please. What's gap between your data so, new transactions? I think you're asking how fast are things in airstack? A new transaction in Ethereum or Polygon should be in airstack within a couple of seconds.
04:21:12.780 - 04:21:19.360, Speaker A: We've tested over and over again for performance. It's the very low latency. It's not real time, but it should be just a couple of seconds.
04:21:19.360 - 04:21:37.382, Speaker A: Yes. On the metadata side, are you querying IPFS as well as RV right now? We run our own IPFS nodes right now. IPFS.
04:21:37.382 - 04:22:08.614, Speaker A: We have a couple of other off chain data sources we use for descriptions and metadata right now. Unfortunately, not Indexing airwave yet. So the token Uri, which is there in the contract, like if it's an Airwave URL or an IPFS URL, we're making the call to the nodes, getting the data, storing it, and you wouldn't have to add any extra effort from your side to fetch it.
04:22:08.614 - 04:22:24.120, Speaker A: It's all on airstack. Steve and I learned something new today, in a way. We have two minutes left.
04:22:24.120 - 04:22:30.518, Speaker A: Anyone? All right, thank you, everyone. Appreciate it. Thanks, John.
04:22:30.518 - 04:30:23.038, Speaker A: Thank you. Thank you. Should I help? Microphone perfect.
04:30:23.038 - 04:31:06.068, Speaker A: Thank you. Hello, everyone. Thank you so much for joining us for today's workshop.
04:31:06.068 - 04:31:24.716, Speaker A: My name is Gyan, and I have my colleague Omar. Together we'll be exploring the world of provable programming through Cairo. It's a bit of a long title, but I have bolded things that are basically important, that is provable programming and Cairo.
04:31:24.716 - 04:32:12.030, Speaker A: The agenda for today is why Cairo? Before learning any new programming language, especially in the Web Three space, I feel like everybody should ask this question to themselves why should you learn another new programming language and what does it bring to the table? We look at what are validity proofs and how are they solving the scalability problem, and then all about Cairo with Omar. Thank you. So why Cairo? I just have one slide for it, and I'm going to try and explain this in a scenario that's best understood by developers.
04:32:12.030 - 04:33:08.660, Speaker A: When you write a program in any programming language, you execute the program and you try to get a result for that program, right? Most of the times, this is how you have been seeing systems running so far. However, if you want to make sure that you want to prove that something was done correctly, then you want to create a proof out of that program, right? And most of the programming languages that exist as of today do not allow you to generate that proof. However, when you write a program in a programming language like Cairo, when you execute this program in any supercomputer, for example, in this context, or any computer for that matter in the world, it will not just execute that program, it will also generate a result and a proof for you.
04:33:08.660 - 04:34:00.562, Speaker A: Now, this slide actually has a little bit more context, but because of the shorter workshop today, imagine if this supercomputer exists in a rival country and you have given them a piece of code to execute, right? You want them to give you the result, and you want to make sure that the result is accurate. If the rival country tries to manipulate the result, whether it was intentional or unintentional, you will come to know, because along with the result, a proof is generated. So the idea of Web Three or the idea of blockchains is to be able to create trustless cooperations, right? You want to be able to trust any source or any machine that runs a piece of code.
04:34:00.562 - 04:34:25.820, Speaker A: And the best way to do that is for that machine to be able to prove that I have run the exact same algorithm that you have given me. This is exactly what proof systems do. Proof systems help not only generate a result for your algorithm from your algorithm, but they also generate a proof that I ran the same algorithm that you gave me.
04:34:25.820 - 04:34:35.790, Speaker A: And you might have heard of zero knowledge proofs. You might have heard of provers and verifiers, which is what is used in zero knowledge proofs. And this is what exactly the provers do.
04:34:35.790 - 04:34:59.254, Speaker A: They generate a proof that a certain computation was done authentically. So in case the computation was tampered, whether intentionally or intentionally, the proof generated for that computation will be invalid. And this is how in a zero knowledge proof or in a validity proof scenario, a regular computer is able to keep a supercomputer honest.
04:34:59.254 - 04:35:28.350, Speaker A: The crux of all of this is that in order to generate a proof, you need to learn a provable programming language, which is what Cairo is. Cairo is a powerful and a highly performant programming language which is not just used in Stucknet, but can also be used as a standalone provable programming language. That's why we chose to phrase the talk today as explore the world of provable programming through Cairo.
04:35:28.350 - 04:36:02.060, Speaker A: How are verity roll ups solving the scalability problem? And why should you build on StarkNet? That's the next question, right? When you think of the L one scaling problem you have Ethereum where say, for example, when you're producing a block, it just says that, hey, you remember the problem where we are saying like, okay, here is an algorithm, we are executing this algorithm. The new state of the system is 42, right? And a lot of books also say that the answer to all world's problems is 42. Well, we can only hope.
04:36:02.060 - 04:36:47.746, Speaker A: And what happens in the system is the validators actually validate whether this new state is correct and how do the validators validate? They are going to rerun the entire computation that this particular block producer actually ran in the first place. And I'm sure all of you already know that Ethereum has gotten congested more often than not in the past couple of years, especially when there's been huge launches, et cetera, et cetera, and that's a huge bottleneck in L ones. Whereas when you think of proof systems, if you remember in a programming language like Cairo, you can not just generate a result saying hey, the state of the new system is 42, but you can also generate a proof.
04:36:47.746 - 04:37:00.034, Speaker A: That how this rate of the system became 42. And what happens at Ethereum level, right? So you can see there are two distinctions here. One is the sequencer and one is the validator.
04:37:00.034 - 04:37:28.558, Speaker A: Now, sequencer is what is sitting at the layer two at StarkNet, which is producing this new block and it is also able to create a proof. Now the validators, instead of having to rerun the entire computation, we'll just have to verify the proof that is generated by the sequencer. And the time taken, as you can see, is pretty, pretty less than what it takes to actually rerun the entire computation.
04:37:28.558 - 04:37:47.126, Speaker A: Not just darknet, but almost all of the zero knowledge proof mechanisms that you're looking at, or validity roll up mechanisms that you're looking at use this exact mechanism to achieve scalability for Ethereum. And that's why you should learn about StarkNet. That is verity proofs.
04:37:47.126 - 04:38:00.666, Speaker A: Verity proofs are an implementation of zero knowledge proofs. To say that they are zero knowledge proofs is actually a misnomer. It's not correct because StarkNet is a decentralized layer two, which is a public network.
04:38:00.666 - 04:38:23.378, Speaker A: So it's not entirely a zero knowledge proof system, but it adapts from the mathematics of zero knowledge proof systems. It takes from the arithmetics of that and is built on top of that and because it validates in a way that is based on the proverb verifier system, that's why we call them validity proofs. They use ZK proofs to guarantee computational integrity.
04:38:23.378 - 04:39:03.646, Speaker A: That means you can always say that a particular computation was correct or not just by being able to validate or invalidate the proof. What this means is doing the right thing even when no one is looking, which is the ethos with which web Three was created, right? We placed our trust into code and not middlemen because we want everybody to be able to do the right thing even when no one is looking. There's a lot of misunderstanding when it comes to what you can build on things which are built on top of principles of zero knowledge proofs because zero knowledge proofs are generally considered to have more privacy use cases.
04:39:03.646 - 04:39:25.420, Speaker A: But that's not the truth in this case, StarkNet itself, it's all about scaling, right? So you can just about build anything on StarkNet. A lot of people came to our booth asking if we are leaning towards a particular domain and my answer is surprise us. If you're building on StarkNet, build anything cool and we are more than happy to see what you're building.
04:39:25.420 - 04:39:40.570, Speaker A: Like I said, ZK rollup is a misnomer and StarkNet is a validity rollup. It uses a particular algorithm called Starks, not Snarks. Two advantages of Starks I want to quickly run through before passing it over to Omar.
04:39:40.570 - 04:40:05.570, Speaker A: The first one is that Starks are post quantum secure because they don't rely on elliptic curve cryptography, they rely on collision resistant hashes and the second is Starks do not require a trusted setup, whereas Snarks do. So they are decentralized from the get go. Cairo is the programming language that we are using right now to be able to write contracts to deploy on StarkNet.
04:40:05.570 - 04:40:32.998, Speaker A: And the next session is all about Cairo. So thank you very much. Now we know the relevance of Cairo, what STARnet is for, and now let's look at some Cairo who is here considering building something on STARnet for this hackathon.
04:40:32.998 - 04:40:57.554, Speaker A: Okay, so most of you okay, so today, who of you have already written Cairo? Who has written Cairo before? Okay, what is your name, sir? Danilo. You know who Danilo is? He's building the serial node GVM called Kakarot, which is using Cairo for building a serial node GVM. So what Jiang was saying was very relevant.
04:40:57.554 - 04:41:12.974, Speaker A: You can build a serial node GBM on top of Cairo and Stargnet. So this is very interesting. You can do a lot of different stuff and to be honest, we won't be able to learn how to write Cairo right now in these 20 minutes we have left.
04:41:12.974 - 04:41:38.530, Speaker A: But there's our boots and feel free to come and we will see more details about it. We'll go with an overview right now, but feel free to come to our boots downstairs and we can guide you, we can help you and you can build some very cool projects. For example, some guys which I don't know, they are not here, but they came out and asked us if there's something like auto payments they can implement on STARnet with Cairo.
04:41:38.530 - 04:41:54.982, Speaker A: An auto payment is, for example, when you subscribe to Netflix, and Netflix makes you a charge every month without you even, you don't authorize it. You authorize it once, and then you don't have to keep signing the transaction each month. It's automatic.
04:41:54.982 - 04:42:07.162, Speaker A: And that's thanks to account abstraction. That is something that we have natively in STARnet. And it's something that we have been working on a lot of time with Openseeple and Bravos Argent members from Ethereum Foundation.
04:42:07.162 - 04:42:19.006, Speaker A: So we have been working hard on a kind of extraction. And that is something that I don't know if you can build it with that quality, another place that it is not STARnet. And you can do all that with Cairo.
04:42:19.006 - 04:42:27.170, Speaker A: So Cairo basically is a smart contract. It's a language that is very similar to Rost. Who knows Rost here? Roast.
04:42:27.170 - 04:42:33.794, Speaker A: Perfect for you. It's going to be very simple. But don't worry if you don't know Roast, it is very doable.
04:42:33.794 - 04:42:53.600, Speaker A: Who knows solidity here? Okay? If you know Solidity and you know how a smart contract works, it is very simple. So I will go and see a small smart contract here and also point you to a place where you can learn more. I love learning in a written way.
04:42:53.600 - 04:43:14.014, Speaker A: So if you want to install everything, you need your setup in order to build on top of Cairo and STARnet. If you scan this QR code, you will go to the STARnet book. As with the Rosbook, you will have everything you need to start coding the syntax of Cairo, the setup, the CLI, in order to interact with the network.
04:43:14.014 - 04:43:29.538, Speaker A: Some tooling you can write your contracts using started JS, which is an SDK that will be similar to whatever you use in JavaScript to interact with Ethereum. You can do it with Python, you can do it with Ros. So we have different SDKs.
04:43:29.538 - 04:43:39.718, Speaker A: Everything you can find in the Ethereum ecosystem, you can find it here. And this is the guide for you. This is the guide for you to install everything and then start writing Cairo contracts.
04:43:39.718 - 04:43:48.878, Speaker A: And you will be able to go for this hackathon again. You can ask anything you want downstairs. Actually, one of the creators of Cairo is down there with us.
04:43:48.878 - 04:44:09.046, Speaker A: So who better than him to answer your questions? And let's look how smart contracts in Cairo looks. If you go to the STARnet book, this is the STARnet book, the one you already scanned, the QR code. And you will go to chapter number two.
04:44:09.046 - 04:44:25.370, Speaker A: Inside here you will have the Fundamentals of Cairo. Cairo applied for STARnet because it's different, right? And here is a small smart contract that will allow you to vote. It's a boating contract, just an example, but this example will get you going.
04:44:25.370 - 04:44:34.282, Speaker A: So let's start. Okay, I will import with use STARnet. STARnet is the library that contains everything related to STARnet.
04:44:34.282 - 04:44:49.582, Speaker A: I'm going to import the contract address, okay? That's very similar to solidity. And then as in Roast, we're going to define a trait. This trait is going to contain all the functions that are going to be external functions.
04:44:49.582 - 04:45:05.538, Speaker A: What I mean with external functions, the external functions are those that interact with the memory or the state of the smart contract. Okay? Those that can read or write from the state. For example, this is the trade boat trait.
04:45:05.538 - 04:45:21.094, Speaker A: T here makes reference in this case to the state of the smart contract. Okay? So we are receiving here the state of the smart contract and then we're going to be interacting with T. So again, T in this case is the state of the smart contract.
04:45:21.094 - 04:45:34.318, Speaker A: Then we have this function called getboat status. I want a function that is a getter function. For those that already know, solidity is going to be reading from the storage and it's going to get me the status of a boat.
04:45:34.318 - 04:45:44.910, Speaker A: How many yes, how many no. It will make a reference pointing towards the storage. Okay, why? Because I don't need to write on storage.
04:45:44.910 - 04:45:58.810, Speaker A: For those of you who know Rost or memory management, this is very familiar to you. So here we're referencing the storage because we need to read from it, we don't need to write on it. So it is basically a read function or a getter.
04:45:58.810 - 04:46:25.426, Speaker A: And it will be returning four different U, eight unsigned integers, eight bits. Okay? This is also another getter function. It will be reading from the storage and it will tell me if a voter can vote, it will receive again the storage of the contract and will receive the contract address of the user that I'm asking for.
04:46:25.426 - 04:46:38.930, Speaker A: Can this user vote? I will give it the address and it will return a boolean. True or false? And we have the same with is a voter register yes or no. In this case, one or zero because it's a boolean.
04:46:38.930 - 04:46:57.082, Speaker A: It looks like that. And finally we have an external function, but it is a write function. Okay? This write function which is boat, it references the storage, but it is not only like a reference to read from the storage, but it can write it.
04:46:57.082 - 04:47:09.242, Speaker A: It can alterate the storage. That's what I'm telling with this. Notice the difference between this and this, okay, these are getter functions only reading from the storage.
04:47:09.242 - 04:47:22.830, Speaker A: This is right into the storage and it will also receive the boat, an onsite integer, eight bits, yes or no. In this case it would be zero or one. Then we'll be implementing destroyed.
04:47:22.830 - 04:47:33.110, Speaker A: So we're defining here the storage. The functions are going to be interacting with the storage either by writing or by reading. And then finally we go into the STARnet contract.
04:47:33.110 - 04:47:42.060, Speaker A: This is going to be a module mod called Both. That is the name of the smart contract. Then we will import a couple.
04:47:42.060 - 04:47:53.726, Speaker A: We will import the contract address from Start and we're going to import the function called Get caller address. I don't need to explain those. Those are very similar for you.
04:47:53.726 - 04:48:02.206, Speaker A: We have two constants. One that represents a yes and a no. Those are U eight and they are one U eight.
04:48:02.206 - 04:48:08.930, Speaker A: This looks a lot like roast for those of you that have already seen it. But it is very simple. If you don't know rust, no problem.
04:48:08.930 - 04:48:16.178, Speaker A: Then we're going to go to the storage. This storage is very simple. You can read for a moment and you will understand it.
04:48:16.178 - 04:48:25.090, Speaker A: We have yes votes, no votes, camboat, which is going to be a Boolean. It's going to be mapping. This is a mapping like in Solidity.
04:48:25.090 - 04:48:32.554, Speaker A: A contract address to a boolean register. Boater is going to map a contract address with a Boolean again. And yes and no.
04:48:32.554 - 04:48:49.610, Speaker A: Boats are simply unsigned integers until now. Is there a question? We have seen how to create the trade for the functions that are going to be interacting with the storage. We have started our own smart contract and we have defined the storage.
04:48:49.610 - 04:49:03.378, Speaker A: The next is going to be easier. So is there any question here? Yes. You won't even notice it behind it.
04:49:03.378 - 04:49:21.546, Speaker A: It's building everything you need in order to interact with Cairo. Computation expensive because of no, on the contrary, it's very cheap. So the goal here is that we are having a network that is going to be very cheap to use and also very fast.
04:49:21.546 - 04:49:34.298, Speaker A: We had a recent update to the network last week actually, which increased a lot. The TPS from the network I think right now is the fastest zero knowledge network there is. To be honest.
04:49:34.298 - 04:49:46.642, Speaker A: This is going to increase in a lot in the next month. So congratulations for being here because to be honest, we are in a very good spot right now with STARnet and this is going to be even better. Okay, so I will proceed again.
04:49:46.642 - 04:49:52.798, Speaker A: There might be more questions, but we can meet downstairs. No problem. Then I have the constructor.
04:49:52.798 - 04:50:06.198, Speaker A: This for you is very similar if you know Python Ros, I don't know JavaScript if they have something like a constructor. But simply what we're doing is initializing the smart contract. So the constructor, when we deploy it, we are asking for four things.
04:50:06.198 - 04:50:15.194, Speaker A: First, we're asking for the contract state. Again, this we can modify. So I can asking for the state and I'm going to be able to modify it.
04:50:15.194 - 04:50:27.166, Speaker A: And I'm going to ask for three contract addresses for the voter number one, voter number two and voter number three. We only have a smart contract for three different addresses to vote. This can be infinite, four, five, whatever.
04:50:27.166 - 04:50:48.280, Speaker A: In this case, in this example, we only have three. Then we are doing some stuff in the initialization, we are calling functions inside our smart contract using self and calling internal functions like register voters in here. I will show it in a minute, but to me, this is very important.
04:50:48.280 - 04:51:08.730, Speaker A: Here I am altering the state of the smart contract. I am writing to it, okay? So what I'm doing here is self on this smart contract that is self, go to the JS votes, which is on the storage here. This is the JS votes variable in the storage.
04:51:08.730 - 04:51:21.754, Speaker A: And then write the number zero but zero in a format of an unsigned integer of eight bits. Sorry, I'm making some zoom here. Do the same with no votes.
04:51:21.754 - 04:51:34.594, Speaker A: What I'm doing here is basically saying the voting contract is going to start with zero votes with no, zero with yes. Okay? So write to a storage that we don't have any votes with no and no votes with yes. That's basically it.
04:51:34.594 - 04:51:43.330, Speaker A: And we are also registering the voters, like voter one, voter two and voter three can vote. That's all we're saying. These guys can vote.
04:51:43.330 - 04:51:54.646, Speaker A: And we're initializing the vote count with zero and zero. Then we create an event. This is how events look like in STARnet and Cairo.
04:51:54.646 - 04:52:07.120, Speaker A: I won't go into details right now, but again, you can go to the boat or you can read this in the book STARnet IO. I will give you the URL in case you want to review it. But this is how an event looks like.
04:52:07.120 - 04:52:25.474, Speaker A: Okay? Then I want to show you how to implement the functions that we actually defined before in the trade. Okay? So we create an implementation of that is going to be called Boat implement. This name can be changed.
04:52:25.474 - 04:52:53.338, Speaker A: It can have any name, no problem. This is an implementation of super, which means it's an implementation of something that is in this file, which is called Boat Trades. And it's going to be receiving the contract state if you go to what is Boat trades? Boat trait is the trait that we define at the beginning that contains all the functions that are going to be external functions.
04:52:53.338 - 04:52:59.294, Speaker A: Okay, so we are now implementing all these functions. Here I am defining a gateboat status. Look, like this.
04:52:59.294 - 04:53:09.186, Speaker A: It received this and returns this. Why I'm not telling you how to implement it? Okay, so now we are going to implement it. And yes, that's all.
04:53:09.186 - 04:53:13.358, Speaker A: Here's a function. You can see it. Here it is getboat status.
04:53:13.358 - 04:53:19.714, Speaker A: We mentioned it before. It is not going to be writing to a storage. It's simply going to be reading from the storage.
04:53:19.714 - 04:53:27.914, Speaker A: And it will be returning me four unsigned integers of eight bits. And then I start writing the function. As you can see, it's nothing.
04:53:27.914 - 04:53:40.590, Speaker A: Sorry, it is nothing. Out of this world. Let's calling this function with self, the self because simply it is referencing to something that is inside this smart contract.
04:53:40.590 - 04:53:51.386, Speaker A: Then we're defining the yes storage and no percentage. It looks like, for those in Python, it looks like Tuple. It's actually a tuple.
04:53:51.386 - 04:53:58.834, Speaker A: And then we call a function and that's it. I think you can understand this. It's very simple.
04:53:58.834 - 04:54:08.286, Speaker A: Then we implement another read, another getter function which only reads from the storage. We do the same here. And this is very interesting to me.
04:54:08.286 - 04:54:16.918, Speaker A: This is the external function that actually writes, which is the boat. So it alters the storage. It says this number of boats were with yes and this with no.
04:54:16.918 - 04:54:27.786, Speaker A: And basically it receives a boat. Then it caps an assertion which is very useful in Cairo for finding errors in your code. So we assert that the vote should either be no or yes.
04:54:27.786 - 04:54:40.858, Speaker A: Otherwise it will return this error, boat zero or one. This is an error that will be returned if I boat with two or three or four, it won't understand it and it will return this error and it will stop. Then we start calling some functions.
04:54:40.858 - 04:54:51.822, Speaker A: But again, this looks to you very similar to Solidity or any other paramount language. It's very simple. And basically, then I do the same with another set of functions.
04:54:51.822 - 04:54:56.002, Speaker A: And that's it. That's basically it. This is the Cairo smart contract.
04:54:56.002 - 04:55:13.414, Speaker A: Right now is, to be honest, very simple. If you know Python or you know Rust or solitude, this to you is very simple. So sorry we couldn't go through a lot of details, but again, we will be downstairs tomorrow, today and the day after tomorrow.
04:55:13.414 - 04:55:21.260, Speaker A: We will be there answering any question that you can have. And please go to the bookstarnet. IO, let me give to you.
04:55:21.260 - 04:55:32.986, Speaker A: This is the QR code to the book, where we have most of the content you need. To do this. You will have the voting contract plus other examples, if you are willing to implement account structure.
04:55:32.986 - 04:55:41.346, Speaker A: We also have account structure examples. We have all the tooling you need. If you write Python, JavaScript, Rust, whatever, you will find it there.
04:55:41.346 - 04:55:51.830, Speaker A: If not, please let us know. All the tools are there. The future for us is going to be scalable and we really believe we are building stuff for the next 20 years.
04:55:51.830 - 04:56:01.962, Speaker A: And STARnet, we think, is a great solution. To me, it is the way to go. And yes, let us know what you think and yes.
04:56:01.962 - 04:56:20.222, Speaker A: Thank you very much. Thank you to Jan and thank you for coming. If there's any question I can see, we have a couple of minutes and if you get stuck with any questions later.
04:56:20.222 - 04:56:34.546, Speaker A: Also, we have a cool Swag telegram group. Do you have the link? I don't have the QR, but let me find that out. Yes.
04:56:34.546 - 04:56:44.040, Speaker A: So we have a telegram group which is of high quality, where we have a lot of builders in STARnet. So you can feel. Free to ask stuff.
04:56:44.040 - 04:56:56.522, Speaker A: Go write some cairo. Let us know that you're writing Cairo and we can help you in different ways, right? So go explore it, feel it. If you like it, let us know.
04:56:56.522 - 04:57:04.542, Speaker A: If you don't like it, also let us know and we can support you. We are here to help you. Our goal is to get as many developers as possible.
04:57:04.542 - 04:57:16.980, Speaker A: We're not interested right now in investors or in that many users, financial users, per se. We are more interested in building right now. So if you're a builder, let us know and we can help each other.
04:57:16.980 - 04:57:36.710, Speaker A: So, just very quick to deploy is very easy. She asked how to deploy and you will find everything you need here in the STARnet book. In this QR code, you will find in the introduction to STARnet, your first smart contract.
04:57:36.710 - 04:57:44.262, Speaker A: First STARnet contract. And then you will find everything you need here. To deploy, you have to create a signer, because we're using accounts fraction.
04:57:44.262 - 04:57:53.866, Speaker A: Somebody that signs for the transaction, you have to declare it, which is a different concept. But you will find it here, then deploy it. But yes, here you will find anything unique.
04:57:53.866 - 04:58:07.170, Speaker A: Sorry. Yeah. So I'm trying to figure out in practice what use case could run on StarkNet that I couldn't run, let's say, on a regular EVM chain.
04:58:07.170 - 04:58:33.898, Speaker A: If I understand correctly, this is one of the fastest of the zero knowledge chains. But does that mean there are some things I can do in this chain that I cannot do on the others? Or is it just faster than what imagine you have a bigger computer, so whatever you think requires more computational power. Computational power.
04:58:33.898 - 04:58:45.082, Speaker A: I think this is a use case. For example, right now we are building a lot of autonomous worlds for gaming on chain. Gaming, where all the regulation is made on chain.
04:58:45.082 - 04:58:54.894, Speaker A: All the operations are made on chain. Also, because it's cheap and it is fast, you can do AI on chain. This is something that I have not seen in done on chain.
04:58:54.894 - 04:59:07.406, Speaker A: It's something that is weird. I don't know if somebody knows about on chain AI build all the calculations on the chain. That's something hard to implement because of the cost of the velocity.
04:59:07.406 - 04:59:22.378, Speaker A: So I think that if you can think in something that requires a lot of computation, this could be a use case. Of course, I'm not saying that this is good for everything. You don't want to kill a fly with a Basuka, right? So you have to think about it.
04:59:22.378 - 04:59:36.960, Speaker A: But yes. So we actually want to use it for AI. But as far as we understand, if we use zero knowledge for AI, it increases computational cost by like 100, even 1000 sometimes.
04:59:36.960 - 05:00:03.060, Speaker A: So is that something that would happen in StarkNet as well? Actually, Danilo is working on that. Right, then one of the powerful things about Cairo is that you build the same program and you can run it off chain and then just verify on chain so similar to Circum. So for example, let's say you will a smart contract that runs your knowledge.
05:00:03.060 - 05:00:52.464, Speaker A: You can run it as smart contract but if the number of steps are too large you can just run it somewhere else, get approved with input and output and verify that on your smart contract with the exact same code. I think there's widgets now for don't have to use any CLI and any setup and just try out also you want to do some AI, I recommend you check out Orion from the GSET tech company. They're using STARnet and Cairo to build some AI.
05:00:52.464 - 05:01:14.808, Speaker A: So they are actually in this hackathon right now and you can meet these guys. These guys are genius and they are making on chain ML. And here we have a lot of different tutorials on how to use their models and this is something that I think is going to be the future in the next year we will be talking about this and I think this is a great opportunity to win a hack, right? It sounds very impressive.
05:01:14.808 - 05:01:22.670, Speaker A: AI on chain okay, thank you very much. We'll be downstairs again. Thank you.
05:01:22.670 - 05:01:26.250, Speaker A: We can.
