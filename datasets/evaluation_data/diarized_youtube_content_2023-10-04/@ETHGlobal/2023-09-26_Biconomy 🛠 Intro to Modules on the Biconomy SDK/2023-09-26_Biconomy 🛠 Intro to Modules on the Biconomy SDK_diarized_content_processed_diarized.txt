00:00:12.610 - 00:00:17.186, Speaker A: Founder, hip hop artist. I've retired. I no longer do freestyles.
00:00:17.186 - 00:00:23.830, Speaker A: I'm sorry. But you can follow me on a couple different places. Twitter at rahat codes rahat lens on lens.
00:00:23.830 - 00:00:39.710, Speaker A: If you need a primer on account abstraction, I did do an Intro to Account Abstraction at ETH Paris. You can see a replay of that on this link. So if you're new to account abstraction in general, you can check that out.
00:00:39.710 - 00:00:52.830, Speaker A: This is not an introduction course to count abstraction. This is going a little bit deeper into a newer feature that we just recently released. So I will give you just like, a small kind of overview.
00:00:52.830 - 00:01:11.670, Speaker A: But if you want to go deeper into what account distraction is, highly recommend checking out this video and some of the resources. Yes, this is okay. It's not showing my slides.
00:01:11.670 - 00:01:46.700, Speaker A: Go to your System Preferences displays. Mirror Duke. Cool.
00:01:46.700 - 00:02:05.590, Speaker A: All right, cool. So this is the QR code. If you want to go through that introduction to Account abstraction, highly recommend going through this.
00:02:05.590 - 00:02:21.892, Speaker A: It'll give you an overview, what account abstraction is, and just like a general introduction to our SDK. So really quickly, though, I will go over some of the details in that video. So the Biconomy SDK allows you to tap into the full stack of account abstraction.
00:02:21.892 - 00:02:45.520, Speaker A: So we give you Paymasters bundlers as well as packages to create your own smart accounts. So the Smart Account package helps you to deploy your own smart accounts as well as create user operations that eventually get executed as transactions. Our Paymaster package, you use one URL and you can switch between doing Gasless transactions as well as doing ERC 20 token payments for Gas.
00:02:45.520 - 00:02:53.472, Speaker A: So we're really focused on the developer experience. You just use one URL, switch the mode, and you're good to go. Bundler package.
00:02:53.472 - 00:03:13.704, Speaker A: You can use our bundlers. We have bundlers available on several different chains to actually send your user operations to the entry point contracts on every chain that we're deployed on. So now we're introducing the Smart Account platform, which is our focus for this hackathon, as well as some of the different prizes that we have available for you.
00:03:13.704 - 00:03:40.992, Speaker A: So the Smart Account platform is built around extending our smart accounts to allow you to create and use different modules. So some of the modules that we have available for you today that you can start using allows you to do a few things. We have a regular ECDSA module which just relies on an EOA to sign and verify your messages, similar to the experience that we've had with our previous offering, with our previous version.
00:03:40.992 - 00:04:03.000, Speaker A: But going a step further, we now also have a multi chain validation module which acts the same way as the ECDSA module. You use an EOA to sign for your transactions, but using that EOA and one signature, you can interact on multiple chains, all with one signer. So you don't have to have your user switch between different networks.
00:04:03.000 - 00:04:23.372, Speaker A: You can just interact seamlessly across chains and completely abstract away the need for your user to even think about what network they're even using. We have session key managers, which is going to be the focus for today's workshop. This enables the use of sessions and session validation modules for your DApps.
00:04:23.372 - 00:04:29.940, Speaker A: So think of it this way. You sign once and then you start doing transactions. And you don't have to keep signing over and over again.
00:04:29.940 - 00:04:50.010, Speaker A: You unlock actual fluid web two experiences where you can do things like working on web three, social sign once. You don't ever have to like, if you think about if you've ever used Lens protocol, you don't have to sign every single time that you like something or comment or post. It's a similar experience to this.
00:04:50.010 - 00:04:59.260, Speaker A: So like I said, today's focus is on session key modules. Let's dive into a quick demo and some code. So here's the demo.
00:04:59.260 - 00:05:07.550, Speaker A: First, hit this connect to web three button. MetaMask will pop up. I'm going to connect.
00:05:07.550 - 00:05:17.068, Speaker A: Cool. I've connected. And although my address ends in BDFD, you'll see that the smart account address is different.
00:05:17.068 - 00:05:30.300, Speaker A: This smart account was deployed using my EOA as the signer. So this is showcasing the ECDSA wallet. Here the ECDSA module.
00:05:30.300 - 00:05:36.548, Speaker A: I'm going to hit this create session button in the background. A session will be created. I just sign once.
00:05:36.548 - 00:05:48.600, Speaker A: So this is what I meant before. I sign once, right? Every single other transaction that I do in this demo, I will not have to sign again. So it's creating a session for me in the background, letting that kind of go, cool.
00:05:48.600 - 00:06:04.220, Speaker A: Success session was created. Now in this demo, I'm simply just going to hit this transfer one USDC button. What's going to happen is I've already preloaded my smart account with some testmatic as well as some test USDC.
00:06:04.220 - 00:06:20.764, Speaker A: And I'm going to send USDC two back to this account. So just to show you, right now, there is 29 USDC on this smart account. I hit transfer one USDC in the background.
00:06:20.764 - 00:06:28.852, Speaker A: It's happening. No MetaMask pop up, right? Nothing that I have to sign. It's just a nice little seamless experience.
00:06:28.852 - 00:06:37.060, Speaker A: I'm just waiting for it to kind of go through in the background. Cool. I get my actual transaction happening here.
00:06:37.060 - 00:06:55.244, Speaker A: But before we look at the transaction, you'll see that my USDC balance went up to 30. Didn't have to sign, didn't have to do anything. This is an actual, like, think about this as like an actual experience of how a web two user would use Venmo, right? You're sending some funds to another user, but you're not signing every single time.
00:06:55.244 - 00:07:10.000, Speaker A: You're not approving it every single time. Now you can actually unlock these experiences on chain. So this is the transaction that just went through about 12 seconds ago, sending one USDC from this account to the other one, all on the Polygon Mumbai chain.
00:07:10.000 - 00:07:36.920, Speaker A: We're on major pretty much all major, almost all major EVM chains. If you want to look at our bounties, as well as some of the chains that are available here, we're available on polygon, we're available on base, we're available on Linear as well as Arbitrum. So if you're hacking on any of those chains for the hackathon, you're able to use our SDK.
00:07:36.920 - 00:07:44.684, Speaker A: Cool. So that's very basic example, right? Just kind of like what's possible. Let's see how that actually works.
00:07:44.684 - 00:08:10.212, Speaker A: I'm going to go over to our documentation and show you an implementation of the session key validation module smart contract that actually allows this to happen. So you can actually use this as an example to build your own session key validation modules. But in this instance, this is an ERC 20 session validation module which takes a few different permissions for you to look at.
00:08:10.212 - 00:08:24.440, Speaker A: For the little demo that I just did. One, it's going to take some information for the session key itself. This session key is going to have four different arguments in it and I'll kind of go over those later.
00:08:24.440 - 00:08:31.784, Speaker A: It's going to take a token. In this case, I sent USDC. So the USDC token address, it's going to take a recipient.
00:08:31.784 - 00:08:51.788, Speaker A: In my case, I hard coded the recipient only to be my other EOA. You can obviously change this logic, but this makes it so that within the session, I can only transfer ERC 20 tokens to that specific account. So here we're looking at the different permissions of what's actually allowed in this session.
00:08:51.788 - 00:09:21.452, Speaker A: And then there's just a max amount that I cannot cross over during any of these sessions, right? So this is just doing all of the checks, making sure that the token that is supplied in the argument matches the token in the session key, which would be the USDC that I used. This is also requiring that the call value equals zero. If you want to do your own kind of like session key validation module, let's say you're minting an NFT that needs some value.
00:09:21.452 - 00:09:40.556, Speaker A: You would remove like a line like this and just make sure there's a certain value attached to it. So this is just like a base for what you can use to actually build your own modules. Next, it's just checking if the recipient is actually the same as the one that's specified in the session.
00:09:40.556 - 00:09:58.680, Speaker A: Again, I can only send to that one recipient and making sure that the max amount is not exceeded. This specific function here and this specific function here, they do more or less the same thing. This function is called from our session validation manager.
00:09:58.680 - 00:10:15.932, Speaker A: The manager, essentially you supply it a deployed smart contract. In this case, we deploy this contract for you so you can start doing the transfers yourself. But if you wanted to use your own contract, build it on top of this, deploy it, just switch the contract address.
00:10:15.932 - 00:10:33.568, Speaker A: You have a session validation module that you can use with our SDK. So this is called specifically by the session key manager. And if you're doing something like batching sessions together, we have another batch session router which allows you to batch multiple different types of sessions.
00:10:33.568 - 00:10:51.524, Speaker A: This is the function that's called. In that case, if you want the base, kind of like how to build, we have the actual contracts that are linked here. So you can use the interface and follow the example here to build your own modules, deploy it and use it on our SDK.
00:10:51.524 - 00:11:11.620, Speaker A: How do you actually use it? So to actually use it in the application, first thing you want to do is set up your Biconomy Smart account. In this case, I'm using the Biconomy Smart account v two. That's our latest version of the Smart account itself.
00:11:11.620 - 00:11:24.680, Speaker A: You create an instance of your bundler. You can grab your bundler straight from the dashboard for testnets. You can actually just use variations of this link and just change the chain ID.
00:11:24.680 - 00:11:40.862, Speaker A: Also from your Biconomy dashboard, you can grab a URL for your paymaster. And I recommend using your own URL because none of your transactions will work on this URL. But cool.
00:11:40.862 - 00:11:51.518, Speaker A: This is just like a connect button just to connect to the actual MetaMask wallet. Nothing fancy here. I'm just doing an Ethers request for request accounts.
00:11:51.518 - 00:12:10.082, Speaker A: And then I'm using our ECDSA ownership validation module to create the signer that's going to control the smart account. So that's this step here, essentially passing the signer that I get from MetaMask over to the ownership module here. The cool thing about this is we're signer Agnostic.
00:12:10.082 - 00:12:23.766, Speaker A: This is one way of me creating a signer, a simple way through Ethersjs. However, you can use any type of authentication system that you want. Another sponsor here is Privy.
00:12:23.766 - 00:12:35.886, Speaker A: If you wanted to use Privy to create a signer, you can actually use their SDK. Create a signer, pass it to us. Now you have a Biconomy Smart account created by the signer from a Privy account.
00:12:35.886 - 00:12:42.558, Speaker A: And this is the same. If you want to do something like Wallet Connect, you want to use Wallet Connect to Connect, get your signer. You can do that too.
00:12:42.558 - 00:12:48.370, Speaker A: This is just a basic example. This is not the only way to create the signer. You can create the signer in any way you want.
00:12:48.370 - 00:13:09.610, Speaker A: As long as you pass the signer to the address, you're good to go. Last thing here we create the account. These are just the different validation modules and everything you need on the creating the session side of things where you actually create your session.
00:13:09.610 - 00:13:36.222, Speaker A: One thing that I mentioned before is you're essentially using a deployed smart contract, right? That's the smart contract that we went through before. Replace this with any smart contract that you want that you've built on top of that for your specific use case, right? So if you want to add more permissions, more granular activity, onto your module you can do. So you want to replace it with like an ERC 721 module.
00:13:36.222 - 00:13:44.490, Speaker A: Go ahead, whatever you want. All you got to do is just replace this address. Cool.
00:13:44.490 - 00:13:59.884, Speaker A: In terms of the actual transfer itself, again, we're making sure that we're using that ERC 20 module. We're making sure that we use the session key manager module. This is all just copy and pastable things from our documentation.
00:13:59.884 - 00:14:12.150, Speaker A: This repo is available on GitHub. There is a step by step how to recreate this exact project on our documentation as well. Just for the interest of time, I can't go through every single detail.
00:14:12.150 - 00:14:43.980, Speaker A: But here I'm transferring the funds to a specific EOA, which is the EOA that I created before. If I were to change this, this specific transaction would fail because I only specified that I want to send to this address. And that is done when you actually create the session, which is over here, the session key data itself, which holds four arguments.
00:14:43.980 - 00:14:56.240, Speaker A: It's going to be the session key EOA. You're basically creating an EOA for your DAP that's going to sign on your behalf. You're passing it a token address, you're passing it a receiver address and a maximum amount.
00:14:56.240 - 00:15:14.300, Speaker A: So these are the permissions that you create on your front end and pass to your session key validation module for it to check against every time you do a transaction. And then there's just a few other pieces of data. How long is it valid for? It's here, which means it'll be valid forever.
00:15:14.300 - 00:15:22.490, Speaker A: You shouldn't do this in production. Make sure you actually have an end date. You just pass a Unix timestamp here and you're good to go.
00:15:22.490 - 00:15:44.204, Speaker A: And the last thing that I want to call out here in this demo, we're saving the session key, private key to local storage. This may or may not be something you want to do in production, but you have to look at the trade offs of doing it this way versus saving it on some server. If you save it on some server, you have direct access to the private key of this session.
00:15:44.204 - 00:16:06.970, Speaker A: So you want to look at the trade offs. Do you want to keep that on the client side and let the user kind of just work, worry about that and make sure they don't have any malicious code running or do you want to manage it for them? So look at the trade offs for your specific use case, depending on how you want to go on that end. But this is a quick run through of the code.
00:16:06.970 - 00:16:29.604, Speaker A: Now, really quickly, let's chat through stuff that you can build. So our top prizes revolve around awesome use cases with our modules. What are some things you can build? I've actually seen a couple of people come up to me asking about this already.
00:16:29.604 - 00:16:43.224, Speaker A: Payment subscriptions. You can build a module that allows a merchant to pull funds from a smart account. You can actually just use even the base ERC 20 contract that I have and add just additional bits of logic to it.
00:16:43.224 - 00:17:06.320, Speaker A: And you can probably create this this weekend pretty quickly. Automated Token Trading again, another thing that you can just build on top of the ERC 20 session module that we showed based on different market conditions, based on how much the gas prices token prices. Do specific token trades or add daily limits to your spending.
00:17:06.320 - 00:17:19.296, Speaker A: Replace the ERC 20 token entirely with NFTs ERC 721 NFT rentals. Create a module that allows p to p NFT rentals between users. Look at gaming modules.
00:17:19.296 - 00:17:27.188, Speaker A: We just looked at, like, signing transactions for onchain gaming. Kind of sucks. You don't want to keep signing every time you do an action on chain.
00:17:27.188 - 00:17:36.712, Speaker A: How can you use session keys to improve gaming? Use cases. Do something like creating a wallet burner factory. Allow users to create burner accounts for specific transactions.
00:17:36.712 - 00:17:45.940, Speaker A: Give an account the ability to do a specific transaction and then never use it again. And if you're excited to build, let us know. We're ad by economy.
00:17:45.940 - 00:17:57.040, Speaker A: I'm at Rahat codes on Twitter. You're not the only one who's excited today. We actually just passed 600,000 user operations that have gone through our system.
00:17:57.040 - 00:18:07.120, Speaker A: So we'd love to see you kind of like adding to that number and joining in the community who's building around Biconomy. So I'll be around all week. We have a couple of engineers who are here as well.
00:18:07.120 - 00:18:08.350, Speaker A: We'd love to see what you guys build.
