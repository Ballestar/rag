00:00:00.410 - 00:00:10.858, Speaker A: Thank you. Hello. So, a quick question into the audience.
00:00:10.858 - 00:00:31.798, Speaker A: So who of you knows what is the graph? Okay, we can do some introductory then. Who already wrote the subgraph? Okay. And who already wrote the smart contract? Okay, now better.
00:00:31.798 - 00:00:38.454, Speaker A: And who plans to write the smart contract? Cool. All right. Yeah, that's good.
00:00:38.454 - 00:00:42.170, Speaker A: Okay, that's good. All right. So my name is Simone.
00:00:42.170 - 00:00:56.350, Speaker A: I am a solutions engineer at Edge Node. That's one of the core dev teams that work on the graph protocol. Tonight I show you how to use the graph.
00:00:56.350 - 00:01:06.622, Speaker A: And this time I think I start this presentation with this is what you can get. Like if you use the graph, we have two tracks. The one is a best new subgraph.
00:01:06.622 - 00:01:16.078, Speaker A: That's the first thing we will look at. The best one will get $2,200, runner up 800. And then you can also use existing subgraphs.
00:01:16.078 - 00:01:22.182, Speaker A: There are tons. I will show you where you find them. And because this is much easier, the bounties a little bit lower.
00:01:22.182 - 00:01:35.158, Speaker A: So I would say the strategy here is if you are a good developer and you want to go for the higher bounty, then you would do that. But it takes more time. Whereas when you use an existing subgraph, it might be more competition.
00:01:35.158 - 00:02:05.230, Speaker A: But yeah, let's see, the thing is, a lot of hackers usually start with this one, remix. Who uses remix for the smart contract development? Yeah, and especially beginners first use remix before they start to use more sophisticated tools like foundry hardhat and that kind of stuff. That's why I show you quickly how you do it in remix.
00:02:05.230 - 00:02:13.862, Speaker A: So when you are in remix, what you usually do is like you create a new workspace. Then let's say we create an NFT. NFTs are cool.
00:02:13.862 - 00:02:26.780, Speaker A: Maybe it's almost a little bit over, but yeah, we can still do one. So it's cool. So you can just start with a template and then you can say, okay, I want a mintable burnable, possible, whatever.
00:02:26.780 - 00:02:38.494, Speaker A: And this we don't need upgradability. I believe in smart contracts should if possible, be atomic and nonchangeable cool. And that's it.
00:02:38.494 - 00:02:48.722, Speaker A: Then you just click OK. And then it generates you this token. You have this function, so you can pause it, you can mint it, and it's using the open Zeppelin standard.
00:02:48.722 - 00:03:01.398, Speaker A: So that's already good. So I can say like, yeah, this is now the Simon Token st. And when I save it compiles in the background, it creates all this stuff.
00:03:01.398 - 00:03:29.790, Speaker A: But actually at some point you are finished and then you want to deploy it. So let's go to Girly network and you will just say, okay, I want to use the injected provider and then we deploy. You sign the transaction and it deploys the contract.
00:03:29.790 - 00:03:46.774, Speaker A: So now you already have your contract deployed. Almost there, right? It's Sunday morning and you think like, okay, I want to build my front end on top of it. I don't know who tried to get data from a smart contract with the JSON RPC providers but in my opinion it's a bit a mess.
00:03:46.774 - 00:04:01.146, Speaker A: I can show you it looks like this. So you write code that you loop over. You do these callbacks back and forth and try to get it.
00:04:01.146 - 00:04:22.478, Speaker A: And when someone has ten NFTs with that code and that's code that I saw in the wild, actually, and all of these calls to the JSON RPC endpoints that take 200 to 300 milliseconds, you easily end up with three, four, 5 seconds load time of your website, right? I mean, that's not cool. So we have the contract now deployed. That's very cool.
00:04:22.478 - 00:04:30.350, Speaker A: So what you do next is you verify the contract. It's very important. I never interact with any contract that's not verified.
00:04:30.350 - 00:05:09.006, Speaker A: I mean, you never know, right? So how can we use this in remix? So there is a plugin called the flattener so if you're here and you don't find it, you just do the Flattener. You click on Activate and then you go here and then you just say like flatten my contract and now immediately the whole flattened source code that means all these imports are created in one file, are in your clipboard then I can just go here and it works actually more or less the same on any chain. So you can do this on Polygon, on Mainnet, on Mumbai you just say verify and publish then you have the contract address here.
00:05:09.006 - 00:05:51.026, Speaker A: Compiler type is solidity single file the compiler version is usually 8.0 you can check here which one it is, right? Open source license MIT and then we go forward paste just the codes that we have in the thing you prove that you're not a robot, own boats, verify and publish and then your smart contract will be verified. Nice, cool.
00:05:51.026 - 00:06:06.920, Speaker A: And now you are actually ready oh, cheat sheets. She has cheat sheets that help you with these steps to remember. So please raise your hand if you want one.
00:06:06.920 - 00:06:19.622, Speaker A: And now the next step is you actually now want to have a subgraph. So we have a smart contract, it's verified and we now want to have a subgraph that I can use. We want to have a cool and nice GraphQL API.
00:06:19.622 - 00:06:28.526, Speaker A: I want to have something like this I want to have a GraphQL API to get my data out. That's very beautiful. All the front end developers know that's the way to go.
00:06:28.526 - 00:06:34.926, Speaker A: All right, so what do I do? I go to thegraph.com oh, wait. Other browser.
00:06:34.926 - 00:06:44.094, Speaker A: Thegraph.com when you are on Gurley or in Ethereum, Mainet, you choose here. Subgraph Studio.
00:06:44.094 - 00:06:54.680, Speaker A: If you are any other chain polygon, Mumbai, Zalo, whatever optimism, you go to hosted service. But because we are on Gurley, we take Subcraft Studio. So I go here.
00:06:54.680 - 00:07:06.250, Speaker A: Usually you connect first. I want to show you all these steps. So you connect, you take MetaMask pop up comes, you sign in, you sign that's it.
00:07:06.250 - 00:07:12.030, Speaker A: You're here. And then you say, I want to actually make a subgraph. So you create a subgraph.
00:07:12.030 - 00:07:17.226, Speaker A: You say which chain you are indexing. It was girly. So, girly.
00:07:17.226 - 00:07:24.340, Speaker A: How do I name it? I name it NFT. Nothing special. All right, continue.
00:07:24.340 - 00:07:32.030, Speaker A: That's it. Now, when you are here, there are like instructions what you should do. It's the same on the cheat sheet.
00:07:32.030 - 00:07:43.814, Speaker A: So you should install the graph protocol CLI globally. And then yeah, and then you can actually say graphinit Studio Simon's NFT. That sounds interesting.
00:07:43.814 - 00:07:52.006, Speaker A: So let's do this. Now, here comes a trick. I wrote it also on the cheat sheet.
00:07:52.006 - 00:08:07.200, Speaker A: But the trick here to get started quickly is like index events. All right, this is the magic thing that helps you to get started quickly. All right, now let's do it.
00:08:07.200 - 00:08:21.246, Speaker A: Now we have a nice dialog that we can go through. And it says, which protocol do we use? The graph supports RV nier like ethereum. Think of EVM compatible and Cosmos.
00:08:21.246 - 00:08:27.082, Speaker A: But we are here with Ethereum. It's a global hackathon. So ethereum the subgraph slug.
00:08:27.082 - 00:08:31.010, Speaker A: It's already here. We can just take it. Then the directory.
00:08:31.010 - 00:08:35.586, Speaker A: That probably sounds good. Then I check the network. I take Gurley.
00:08:35.586 - 00:08:42.202, Speaker A: Right. And now I need the contract address. The contract address is here.
00:08:42.202 - 00:09:03.400, Speaker A: This one we can just copy and paste. I hope that this will work. Okay, let's just try again.
00:09:03.400 - 00:09:18.626, Speaker A: All right. Sometimes you just need to try again twice. So it takes some time until the API is available on Ether scan.
00:09:18.626 - 00:09:24.202, Speaker A: But yeah, if it doesn't work, there's this thing. Like if it doesn't work, turn it off and on again. Right.
00:09:24.202 - 00:09:29.382, Speaker A: Okay. So it's a simon's NFT. Give just a name and boom.
00:09:29.382 - 00:09:40.640, Speaker A: The subgraph is created for you in the background. Now, we actually don't need to do much. We don't need to understand how to write the subcraft, how this works, what is a schema, what is whatever.
00:09:40.640 - 00:09:51.810, Speaker A: When we want to get started, we can just follow the instructions here. So you go into the directory. Can do this in a new window while it's installing.
00:09:51.810 - 00:10:05.220, Speaker A: Then we actually do the authentication. So we need to load the API key that we can deploy. So I do this.
00:10:05.220 - 00:10:14.902, Speaker A: And now the deploy key is set. And here now in the background, everything is already installed. It asks me if I want to do another contract.
00:10:14.902 - 00:10:18.762, Speaker A: But we are good. Like, just go with this. That's it.
00:10:18.762 - 00:10:29.322, Speaker A: And now I can just say graph deploy. Actually, I need to change here. And I can just graph deploy to the studio.
00:10:29.322 - 00:10:37.054, Speaker A: I just followed these steps that are written there which are also on the cheat sheet. I return. I need to give a version label.
00:10:37.054 - 00:10:45.790, Speaker A: Let's say this one. And boom. It's deployed.
00:10:45.790 - 00:11:04.230, Speaker A: That's it. Now I can go here and go into this URL. And here I have a graphic Ul interface.
00:11:04.230 - 00:11:23.546, Speaker A: Now, unfortunately, currently we have this problem that if you just follow the steps that I did, there is one small missing piece that we can now do together. I mean, eventually this subgraph will start to index, but we can speed it up with this little trick that I show you right now. So we just look at the code and the subgraph.
00:11:23.546 - 00:11:32.386, Speaker A: Basically the main thing you're interested in is the manifest, like the subgraph. YAML. So here the trick is everything is already set up for us.
00:11:32.386 - 00:11:57.770, Speaker A: But what we need to do in source, like we need to add a start block so that the graph node in the studio knows where to start indexing. How do we find the start block? We look at the transaction where the contract was deployed and we check the block and we just copy paste. All right, boom.
00:11:57.770 - 00:12:18.620, Speaker A: Save and redeploy. Now it's version two. All right, let's see what the studio now thinks about this.
00:12:18.620 - 00:12:22.442, Speaker A: Woohoo. It's fully indexed. So that was better.
00:12:22.442 - 00:12:34.782, Speaker A: Right? Now we can also go into this again. There's also the playground. So what it's probably interesting if NFTs we see transfer events, right? So the playground is cool because it helps you.
00:12:34.782 - 00:12:45.118, Speaker A: It has here a graphic Ul explorer. So we don't really need to understand everything. So you can just click around here and say, actually I'm interested in the transfers.
00:12:45.118 - 00:12:51.906, Speaker A: Maybe I want to have the from, the ID. The to and the token ID. And then it just builds you the GraphQL query.
00:12:51.906 - 00:13:06.010, Speaker A: You don't even need to understand GraphQL in detail, but when you have a front ender in your team, they know, right? And then you can send it. And OOH, we do not have any transfers, but I mean, it's a fresh contract. If you're in Remix, it's very easy.
00:13:06.010 - 00:13:21.314, Speaker A: You can just go where is it? Here, this one. Thanks. I'm not using remix.
00:13:21.314 - 00:13:32.460, Speaker A: Usually I need some help. So what I can do here is save mint. So I can just say, okay, I mint myself an NFT, copy the address, take a token ID and then send it.
00:13:32.460 - 00:13:44.462, Speaker A: Boom. Check on ether scan if it comes true, probably takes a while. Cool.
00:13:44.462 - 00:13:50.814, Speaker A: So this is the easy thing. So you can quickly get started with a subgraph. You don't need to know much about it.
00:13:50.814 - 00:14:03.422, Speaker A: You can just follow these steps. I repeat, you go to Remix, you deploy a contract, you verify the contract, then you go to the graph studio or hosted service. Then you log in and create a subgraph.
00:14:03.422 - 00:14:12.882, Speaker A: And then you go into the terminal. And very important here is this. Where is it? This one graph init index events.
00:14:12.882 - 00:14:26.198, Speaker A: And that will scaffold you a subgraph that has for every event on your smart contract, an entity and auto generated mappings. And you can just get started. I think the transaction should be included.
00:14:26.198 - 00:14:37.022, Speaker A: So we go now back to the subgraph studio. We send the query again and we see our transfer event here, it's very easy. Now you already get started.
00:14:37.022 - 00:14:47.890, Speaker A: You have like a contract deployed, you have a subgraph, you have a GraphQL interface. Now you just need to code a little bit frontend and then you're actually done. You can go home and enjoy maybe Saturday night parties here in San Francisco.
00:14:47.890 - 00:15:14.550, Speaker A: But yeah, there's probably more and we can go into this. So for those that don't know what the graph is, I give you quickly the theory behind now that we saw the practice already. So when you think about the data on chain, we currently have a state in the thinking of NFTs.
00:15:14.550 - 00:15:33.854, Speaker A: You can think about this Google sheet where you have like a token ID and an owner. So the blockchain always knows who owns which NFT. But what about the provenance who owned the NFT before? So we know that the blockchain is this thing with the transactions on top of each other and so we should know.
00:15:33.854 - 00:16:06.570, Speaker A: But it's not easy to get to the old data. You need to kind of dig through it and it would be nice to have this time machine where you can just go back in time and then you see how this own has changed and that's actually what the graph helps you with. So initially the idea for DApps, like these decentralized applications was that you have a front end that's JavaScript, HTML and CSS deployed to IPFS or another decentralized storage and that directly communicates with the blockchain.
00:16:06.570 - 00:16:41.922, Speaker A: The problem here is the blockchain is optimized for writing. You pay the miners so they introduce your transaction. But like when you read from the blockchain, how does this actually work? I mean, in theory you can communicate with a node that you should run at home, but a question like who runs an Ethereum node at home? Yeah, you can communicate with that node, but the JSON RPC interface that you communicate with, it, it's not actually made for building a front end, it's made for you managing your node and maybe send a transaction and do some inspections.
00:16:41.922 - 00:17:05.054, Speaker A: And also there is no incentivization if you don't run the node by yourself, who gives you that data? I mean, sure there are some centralized providers that give you access to JSON RPC endpoints, but that was not the idea of a decentralized system. So you end up with stuff like this when you get the data out. So what a modern DAP architecture would look like is you have a front end that writes to the blockchain that works.
00:17:05.054 - 00:17:22.642, Speaker A: That's cool. And then when you want to read data, you go through an indexing protocol like the graph that gives you decentralized access to data. Now the graph network is already live since one year for Ethereum mainnet and you can have fully decentralized subgraphs there of the thing that we built before.
00:17:22.642 - 00:17:37.066, Speaker A: And the thing is you pay per query by paying for queries the incentivization structure for the data delivery is given. Yeah. So that's the Graph, the APIs for this decentralized future.
00:17:37.066 - 00:17:55.422, Speaker A: Oops, where are we on the host service? The graph currently serves 1 billion queries a day. It's quite a lot and big user like uniswap audience unlock protocol and others using it. Teller also, actually.
00:17:55.422 - 00:18:12.174, Speaker A: But those two already are on the decentralized network. And now since one year we launched a decentralized network, you have 224 indexers worldwide that are independent. They index your subgraph and they're participating in the network with incentives.
00:18:12.174 - 00:18:18.614, Speaker A: They receive query fees, they receive indexing rewards. And that makes it redundant. Right.
00:18:18.614 - 00:18:38.730, Speaker A: If one indexer goes down, another is around to serve your queries. And so that gives you fast, cheap, and reliable APIs in a decentralized way. And that brings us together through a global open API where all the data is available for you, so we can have truly decentralized apps.
00:18:38.730 - 00:18:54.410, Speaker A: We quickly touched the subgraph. Basically, all these transactions are a mess on touch of each other. And a subgraph creates these focused databases.
00:18:54.410 - 00:19:10.566, Speaker A: If you want that, you can save what you want in your database. So if you write the subgraph for your specific contract or your protocol that you write on this weekend, then you just say like, okay, I'm interested in this contract and interested in this event and that transaction. That's how I want to store my data.
00:19:10.566 - 00:19:19.094, Speaker A: And then it will be there. Otherwise it will be very hard to get that data. So you have full control over which data you want to store and how you want to store it.
00:19:19.094 - 00:19:27.894, Speaker A: And then later on you can just query it. So this is roughly how it works. So the DAP on the right side, we saw this, we write transactions to the blockchain.
00:19:27.894 - 00:19:42.522, Speaker A: The blockchains get in, they emit events in what for NFTs, these are transfer events. They are emitted and then the graph node is configured to index those events or to ingest. Then you run a mappings code that you also can enhance.
00:19:42.522 - 00:19:52.110, Speaker A: If you want to get the price for the best new subgraph, you should really enhance your mappings and not just do this what I did. But it's a good starting point. It will be stored in a database.
00:19:52.110 - 00:20:06.314, Speaker A: So on the other hand side, on the left side, you see, you send queries which go to this GraphQL API and will be served by the graph node. That's roughly the system architecture here. Yeah, that's actually then how it looks.
00:20:06.314 - 00:20:27.070, Speaker A: So you have this mess of subgraphs data, and in the end, magically, it gets ordered and you have a very good overview what's going on. Cool. So now if you want, you can scan the QR code and tweet that you just learned about the graph or not.
00:20:27.070 - 00:20:46.742, Speaker A: All right, now peer pressure starts. Cool. Yeah, we did this already.
00:20:46.742 - 00:20:58.294, Speaker A: That the subgraph stuff. But actually we can now go a little bit into the code. So we barely touched on the subgraph YAML.
00:20:58.294 - 00:21:13.922, Speaker A: This holds it together. In the subgraph YAML, you define which chain I'm interested in. What is the address that I want to index? What's the start block? What is the abi? You see the is copied here that was created magically for us.
00:21:13.922 - 00:21:32.782, Speaker A: And also which event handlers that you are interested in. So because we use the ownable Posable, whatever event handler openseplin templates, you have all these events here, but for NFTs you're mostly interested in a transfer. So that's the YAML.
00:21:32.782 - 00:21:58.506, Speaker A: The YAML also says where is the Schema? So the Schema, when you look at the Schema, it really just defines a database. You say okay, there is one table with approval and approvals have an ID and owners which is represented as a bytes and approved and token ID. And so this is all just auto generated according to your contract.
00:21:58.506 - 00:22:14.862, Speaker A: But you're free to change this, right? So you could say yeah, actually I'm also interested in the block number. So you write block number and say it's a big int and then you can extend your subgraph from here. Then the third part is the actual mapping.
00:22:14.862 - 00:22:30.246, Speaker A: So the mappings, they are written in a language called assembly script. It looks similar to TypeScript but it has small nuanced differences. So for example, you cannot just import JavaScript packages here, only the assembly script stuff.
00:22:30.246 - 00:22:47.710, Speaker A: But yeah, it's pretty cool. And because for example Vs code knows about, you can also start to explore. So we can see for example what is then in the event, what do we have here? And I do usually this command click and then you see you go into the event and then see okay, it's approval event.
00:22:47.710 - 00:22:56.186, Speaker A: These are the properties. I can also see what is actually here, what is in an ethereum event. Then I see oh, there is transaction or there is a block.
00:22:56.186 - 00:23:08.280, Speaker A: Let me see what's in the block and then we see. Okay, we have the block hash timestamp and so on and so forth. So then I could say I added this block number here.
00:23:08.280 - 00:23:29.962, Speaker A: What you would do as a next step is you just do yarn code gen. When you change the Schema, you need to run code gen again which generates this stuff. And then I go here to handle transfer and make entity block number.
00:23:29.962 - 00:23:44.226, Speaker A: And see now because I did code chain, it already knows that the entity has a block number equals event. That's also we explored before on the event we have block. So I type B and you see like you can explore it here, it's not so complex number that's it.
00:23:44.226 - 00:24:01.954, Speaker A: And I can save and I can redeploy version three. Cool. So that's roughly how a subgraph works and how you can extend it and really build your magic.
00:24:01.954 - 00:24:11.660, Speaker A: You can come up with new entities that make more sense, not just the events. For NFTs, for example, you want to have the holders, the actual NFTs, then maybe the sales or whatever. It's up to you.
00:24:11.660 - 00:24:28.220, Speaker A: We are already almost at the end. What I want to show you quickly is this QR code. This time it's not for a Tweet.
00:24:28.220 - 00:24:49.908, Speaker A: This will bring you actually to a repository that I created for this hackathon that has all the example code, a link to that presentation, a link to the cheat sheet. So if you rather want to have it digitally and more. So really a good starting point for a hackathon focused.
00:24:49.908 - 00:25:09.850, Speaker A: Also if you go there, you see you need it back. I also added some interesting stuff for you, especially the good subcrafts. Here is a trick.
00:25:09.850 - 00:25:38.498, Speaker A: When you are on a hackathon, you want to get as much bounties as possible for different sponsors, right? So that's why they sponsor. And an easy thing to do actually is you look for the subgraphs of the sponsors that you're interested to build upon and then you use that subgraph and you make a cool integration. If you do a cool usage with a special stuff, maybe you do some machine learning on top of it or whatever, then you come into a good position to get the best usage of existing subgraph.
00:25:38.498 - 00:25:57.546, Speaker A: So I have here so for once we have the subgraphs, the very high quality missari joined as a core dev for the graph ecosystem. And they are writing standardized subgraphs over these different verticals. So we have for exchanges, ERC, governance and they all have the same schema.
00:25:57.546 - 00:26:28.546, Speaker A: So you can aggregate and compare and do fancy stuff. So you can click on those and then you find the links and you can also inspect, you see events and they have some charts, so that's very good, the necessary stuff. But also other sponsors, for example, Lens Protocol, I know they have their own API, that they have their centralized API.
00:26:28.546 - 00:26:40.650, Speaker A: But there is also a subgraph. And so if you want to build something on Lens, you might want to check out that subgraph and see how far you can get. Because if you have a good application on top of the Lens subgraph, you might be eligible for both the lens and the graph.
00:26:40.650 - 00:26:54.720, Speaker A: And so it goes. Also unlock protocol, which we'll see later here, OpenSea that sponsor linear as an example how a subgraph on near works. Very interesting.
00:26:54.720 - 00:27:00.820, Speaker A: Ave Gorge, a cool subgraph that's on polygon. Yeah. So you can check this stuff here.
00:27:00.820 - 00:27:09.074, Speaker A: Yeah, I think I'll leave it here. We are at the booth. I try to be there as much as possible.
00:27:09.074 - 00:27:25.930, Speaker A: And so if you have any questions, just combine and we look at it together. And if you have any questions now, I think I have another two minutes to answer questions, so please shoot them. Thanks.
00:27:25.930 - 00:27:52.018, Speaker A: Yes, good question. All right, so the mapping code, it takes a while to run it. It depends on how efficient you write it.
00:27:52.018 - 00:28:20.140, Speaker A: So rule of thumb is do not do eave calls, do not call back if possible, but usually it's a matter of milliseconds, like if you do not do very complex stuff. So you saw before, I just created that transaction, the block gets mined and then more or less half a second later you have it in the subgraph. And if you want to know which block that your subgraph has indexed, there is this special thing here.
00:28:20.140 - 00:28:40.100, Speaker A: So we had transfers, it's the meta key. So with meta block timestamp and number that you can query for, I created a new version. All right, let's do it again.
00:28:40.100 - 00:28:58.920, Speaker A: Meta block timestamp, number. You see, this is the latest block that the graph nodes are or the subgraph, and this is the timestamp. So that helps you to build a front end that knows how fresh the data is.
00:28:58.920 - 00:29:21.606, Speaker A: One more question otherwise yeah. Yes. When you send a query, they respond to that query and they give you a query at the station and they have GRT staked.
00:29:21.606 - 00:29:38.738, Speaker A: So if they give you their response and it was wrong, you can prove them wrong. There are also fishermen that op serve this and then they get slashed and the fishermen get part of the slashing. But we are working on a thing called verifiable queries so that you will have a proof that everything is true.
00:29:38.738 - 00:29:46.850, Speaker A: But I mean, this is a little bit hard mathematical problem, but that's on the roadmap. Thank you so much for having me and yeah, happy hacking.
