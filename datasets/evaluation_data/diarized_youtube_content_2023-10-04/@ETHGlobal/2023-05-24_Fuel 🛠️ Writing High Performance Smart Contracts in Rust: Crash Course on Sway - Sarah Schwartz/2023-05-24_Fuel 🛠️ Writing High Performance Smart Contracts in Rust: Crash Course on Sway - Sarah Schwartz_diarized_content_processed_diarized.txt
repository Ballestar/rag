00:00:07.610 - 00:00:24.234, Speaker A: Hi, my name is Sarah Schwartz, and I'm a developer relations engineer at Fuel Labs. And today we're going to do a workshop to walk you through how to build a fuel stack DAP on Fuel. So really quickly, what is Fuel? Fuel is a modular execution layer.
00:00:24.234 - 00:00:43.770, Speaker A: So it means you can execute on Fuel and settle on any other L one like Ethereum, and it uses the Fuel VM set of the EVM and it has a UTXO model which allows for a parallel transaction execution. Some quick terminology about fuel. When I say Fuel, I'm referring to the fuel blockchain or network.
00:00:43.770 - 00:01:05.262, Speaker A: Sway is our Rust based domain specific language that we're going to be writing our smart contract with. Fork stands for Fuel Orchestrator and it's essentially like Cargo for Rest or NPM for Node. Fuel up is the tool chain manager that will install Fork and the Fuel node software on your machine.
00:01:05.262 - 00:01:18.674, Speaker A: And then Fuels is the SDKs. There's a Rest and TypeScript SDK that you can use to interact with Fuel. So really quickly comparing EVM to FVM or Fuelvm.
00:01:18.674 - 00:01:33.718, Speaker A: So EVM you're writing your contracts in Solidity. You're probably using some sort of development framework like Hard Hat or Foundry. You're probably using ethers JS or Web three JS for your SDKs to interact with your contract.
00:01:33.718 - 00:01:45.742, Speaker A: And for the indexer you might build your custom indexer. You might use something like the graph. And basically these are all sort of independently managed tools that you have to sort of plug and play, get them all working together.
00:01:45.742 - 00:01:56.350, Speaker A: Versus Fuel, everything is built in house, like all the aspects of your application. So sway is a language. Fuel up is sort of like tool chain manager.
00:01:56.350 - 00:02:12.050, Speaker A: We have our own Rest and TypeScript SDKs and our own indexer system. And Solidity is really like the OG language for the EVM. It's been there for us for a lot of cool stuff, but it can also be like a minefield for Vulnerabilities.
00:02:12.050 - 00:02:38.554, Speaker A: It can be really tricky to feel confident that your contract is not going to get hacked and there's just sort of a lot of environmental things that you just have to know about Solidity versus Sway. It's Rust based, so if you're familiar with Rust at all, you'll know that the compiler in Rust is really helpful because it will tell you exactly where all of your errors are. And we have the same sort of thing going on with Sway.
00:02:38.554 - 00:03:05.240, Speaker A: We have our own compiler that will give you really detailed error messages and also warn you if you possibly have a reentry vulnerability. So it's really built with lessons learned from Solidity in mind and designed for really good developer experience. So the dependencies you'll need to build with Fuel is first you'll need the Rust tool chain and you'll also need Fuel Up.
00:03:05.240 - 00:03:17.146, Speaker A: So I can show you how to install fuel up. So you can find this on our GitHub. Fuel labs is our GitHub name.
00:03:17.146 - 00:03:36.674, Speaker A: FuelUp. And we also have a book. If you go to install Fuel network latest you'll find these instructions and basically to install Fuel Up, it's this one really simple command here and it should modify your path for you.
00:03:36.674 - 00:03:59.654, Speaker A: So it's just one step and then once you have that installed you should be able to use this like Fuel Up show command to see all of your tool chains installed. So right now I have the beta three tool chain set as my default and these are essentially like different versions. So we have different testnets that associate to the different versions.
00:03:59.654 - 00:04:42.280, Speaker A: So right now beta three is our latest testnet and to develop and deploy on the beta three testnet, EVD is the beta three toolchain. So I'm going to make a new project and go to my desktop and make a new folder called Sway demo actually just called Sway Oops and go into that folder and we're going to use the fork command to create a new project. So it's fork new and then we can just call this contract, you can call it whatever you want.
00:04:42.280 - 00:05:00.742, Speaker A: So I'm going to open this up in Vs code and here is what the template contract looks like. So it's really simple. There's the getting nor file, there's this fork TOML file which is essentially like configuration or manifest file.
00:05:00.742 - 00:05:13.934, Speaker A: And then here's our contract. So main Sway and the first line of all contracts in Sway start with this contract keyword. And this is because there's different program types in Sway.
00:05:13.934 - 00:05:35.910, Speaker A: So there's something called Predicates which are essentially like functions that evaluate to true or false. There are scripts, there's libraries and then there's contracts which I'm guessing you're familiar with already. And one different thing that Sway has that Solidity doesn't is you have to define your own Avi here.
00:05:35.910 - 00:05:50.730, Speaker A: So this is the name of the contract, my contract and we can change this to whatever we want. So I can call this game. And then we have one function here, it's called Test function and it returns a boolean.
00:05:50.730 - 00:06:12.274, Speaker A: And then below is where we actually implement the logic for the functions that we have in the Abi. So essentially the Abi is like an outline for all the functions and their inputs and outputs and then we implement the logic here. So we're going to implement the game Abi as a contract and we're going to make a really simple game.
00:06:12.274 - 00:06:24.150, Speaker A: It's not going to be too crazy. We're going to create a game and this game is going to have players. So I'm going to create a struct called Player.
00:06:24.150 - 00:06:39.690, Speaker A: And if you're not familiar with Rust, a struct is sort of like an object in JavaScript. Essentially it's just something that has keys and values. So our player can have a level and we have to give it a type here.
00:06:39.690 - 00:06:53.290, Speaker A: So the standard number type in Sway is a U 64. So we can say the level is a U 64. And then we might also want to have something like a player type and we can use an enum for this.
00:06:53.290 - 00:07:18.822, Speaker A: So an enum is essentially it stands for enumeration. It's essentially just a list of options. So we could have, let's say, like our enum can be called player type and say there's one that's like a superhero and the syntax is a little different than Rest if you're familiar with that.
00:07:18.822 - 00:07:26.490, Speaker A: And then we can have like a supervillain or something. So these are just sort of unit types. They're just basically like a blank type.
00:07:26.490 - 00:07:53.810, Speaker A: So the player type is either going to be a superhero or a supervillain. All right, so now that we have our players, we want to be able to store them persistently in our contract, right? So we're going to have a function called New Player. So we're going to change the name here prior to New Player, and it can return the player struct.
00:07:53.810 - 00:08:23.002, Speaker A: And you can see that this is not very happy with me because the Abi here is not matching the functions in the actual implementation. So we need to update that New Player and True is not a player. Okay, so we have this new player here and we function and we know that we're going to want to store the player somewhere.
00:08:23.002 - 00:08:48.462, Speaker A: So we'll just add a comment like store player, store player. So in Solidity you're probably familiar with like, persistent you might be familiar with persistent variables in Solidity and know that they can sort of be anywhere in the contract as long as it's outside the function. But in Sway, we actually have a dedicated storage block.
00:08:48.462 - 00:09:14.714, Speaker A: So you know, as you're reading this, okay, everything inside the storage block is what's going to be the persistent storage. And I don't have to keep track of like, is this variable persistent? Is this one not? Anything outside the storage block is not persistently stored. So we're going to have all of our players store here and the type of this is going to be a mapping.
00:09:14.714 - 00:09:52.502, Speaker A: So we have a special type called storage map, and it takes like a generic key and value here and you can initialize it as an empty storage map just like this. And so thinking about the key and values we're going to use here, we're probably going to want to save their address to the actual player struct. So another thing that's different about Solidity and Sway is that Sway has two different types to distinguish EOAS or externally owned accounts and contracts.
00:09:52.502 - 00:10:05.998, Speaker A: So you can't just use like an address type for contracts. So we have another type that's an enum that's called identity. And an identity can represent either an address or a contract ID.
00:10:05.998 - 00:10:44.016, Speaker A: So here we're saying that we don't care if a contract wants to play this game. If we did care about that and we only wanted EOAS to play the game, we could store this as an address, but just to keep it simple, I'll keep it as identity and we're going to store that to the player. Okay, how do we get the identity in this function? So just like Solidity we're going to use a message sender and this is actually going to be a method that we import from our standard library.
00:10:44.016 - 00:10:58.684, Speaker A: So like Rust there's a standard library and it's sort of like if you're familiar with React at all, it's sort of like being able to import use state or use effect from React. Like it's already there. You just have to explicitly import it and call it.
00:10:58.684 - 00:11:44.874, Speaker A: So we can say use standard library and the message sender function is in this library called Auth can say message sender and before we store the player we can say let sender equals message sender unwrap. And why does it say unwrap is because message sender returns a result type, which means that there is a small potential that it's unable to detect the sender and that's like for really specific edge cases. So generally you're going to be able to reliably detect the sender but that's why it's there.
00:11:44.874 - 00:12:12.214, Speaker A: And then we're going to insert it into the storage map so we can say storage. And this is a really important part. So instead of like in Solidity you want to call or reference a persistent variable, you just use the name of that variable and you sort of have to keep track like, okay, this one's in use already, but with Sway you use the storage keyword and object to access all this.
00:12:12.214 - 00:12:37.920, Speaker A: So I can say like let player equals x and then storage players something else and they won't conflict. So storage players is how we're going to access the players mapping and then we can use this insert method to insert the identity and player. So it's going to be the sender and a player which we haven't made yet.
00:12:37.920 - 00:13:03.770, Speaker A: So there are a couple of ways to create a new player. One way we could do is just say let player equals and then use this player struct keyword and sort of create an object and recreate this right here. Another way is that we can implement associated functions for a struct.
00:13:03.770 - 00:13:38.040, Speaker A: So we can sort of use this object oriented programming method here, say implement player and add a function called New that's going to return itself which is sort of like this in JavaScript. And essentially we can just say self. The level will start at level one and then player type will be a parameter here.
00:13:38.490 - 00:14:05.490, Speaker B: So player types layer type our variable.
00:14:06.790 - 00:14:24.690, Speaker A: Okay, so now we want to decide whether or not to make our player a superhero or a supervillain. And one thing we can do is decide like, okay, if you're an EOA, you can be a superhero. If you're a contract, you're a supervillain.
00:14:24.690 - 00:15:05.730, Speaker A: So we can use a match expression to match the type of sender and see whether or not it's an address or an contract ID. So Suede has exhaustive pattern matching just like Rust, which means that it will detect basically all of the possible options for you and let you know if you haven't addressed some possibility. So the sender, let's see, let's say let the player type equals and it will use this match expression.
00:15:05.730 - 00:16:05.880, Speaker A: So if the sender is the type identity of an address or like this, sorry, address, the player type is going to be superhero and the contract ID who is supervillain see match text player. Okay, this is for the whole function. And then to initialize a new player, we can say player equals player new and then pass in that player type.
00:16:05.880 - 00:16:22.422, Speaker A: And at the end here, we can return the player object and should be happy with us. Okay, we spell this right. All right.
00:16:22.422 - 00:16:45.534, Speaker A: Nice. So there's a new player function. Let's see, what else can we add to this one really cool feature that Fuel has or Sway has is native tokens or native assets, which means that essentially you can mint tokens in your contract and then send them directly in a call so you don't have to approve and then transfer.
00:16:45.534 - 00:17:06.818, Speaker A: You can just directly send tokens. And we have something in our standard library to make this really easy. So we have a token library and you can import this like mint two function and then we can just call that here and mint a bunch of tokens to our player.
00:17:06.818 - 00:17:24.442, Speaker A: So we're going to mint one token which the app units and Sway are basically guay. So 1 billion is one token and we'll send that to the player. Nice.
00:17:24.442 - 00:17:44.160, Speaker A: All right, we're adding one more function here, which is level up. So the player starts at level one. But how do we increase that level? We can add a new function here called level up and we'll have it return a U 64, which can be the new level.
00:17:44.160 - 00:18:01.606, Speaker A: And this will take a parameter of ref mute self. And what that means is just a reference to the struct itself and it's mutable. So by default, all variables are constants in Sway.
00:18:01.606 - 00:18:20.622, Speaker A: So we have to declare this as mutable. We can say self dot level plus equals one and then just return the new self dot level. All right, so we need to add one more function here that can be called to actually level up.
00:18:20.622 - 00:18:49.206, Speaker A: So we'll have to add it to our abi so we can say function is level up. We'll try to use 64 and then we need to add it down here. And I like to just sort of copy and paste to make sure everything matches and the player oops, sorry, send it to the sender, not the player.
00:18:49.206 - 00:19:07.182, Speaker A: There we go. All right, so to level up, we're going to need to grab that player from our storage. So just like this, we're going to get the sender with the message sender function and then we're going to look into storage players to see if we can get this sender.
00:19:07.182 - 00:19:37.270, Speaker A: So you can use this get function. So let player equals storage players get sender and then we can say player level up and then we have this. So it's already upset at me right now just because this player should be mutable if we're going to update it and then we're going to reinsert it into the storage mapping to overwrite our previous value.
00:19:37.270 - 00:19:52.594, Speaker A: So we can just use the same line right here and then this level up function returns our level. So level was that and return it at the end here. All right.
00:19:52.594 - 00:20:47.950, Speaker A: So there's a lot more we could do with this contract. We could also make this function payable and say like, are they sending this token that I just minted them? And essentially how you can do that is in solidity you can just sort of look at the message amount, but in Sway you can see the message amount and the message or sorry, the asset ID being sent because you can send almost any asset. So essentially you could just add like a require statement, something like this, say require, the amount is greater than zero and require that the asset equals the contract ID the asset ID equals the contract ID and add like a payable annotation.
00:20:47.950 - 00:21:05.740, Speaker A: So that's actually one more thing I forgot here is in sway functions are pure by default and you have to specifically say when you're going to access storage. So right now if I try to compile this, it shouldn't work. Let's see.
00:21:05.740 - 00:21:27.050, Speaker A: Yeah, okay, it should say few things here. So it says storage attribute access mismatch. Oh, sorry, that's a different thing.
00:21:27.050 - 00:21:43.624, Speaker A: So basically, essentially storage attribute is this thing right here. I'm going to add it above each function. And so our new player function writes to storage.
00:21:43.624 - 00:22:03.850, Speaker A: Our level up function will read and write to storage. And we just have to add these here as well. Oh, excuse me.
00:22:03.850 - 00:22:25.080, Speaker A: We have to add them to our actual functions down here. So have the same lamb storage read, write and storage write. Okay, let's see if this compiles now.
00:22:25.080 - 00:22:53.900, Speaker A: Okay, so again I said insert, let's see, storage type clear. Okay, so I forgot one more thing, which is when you're getting something from storage, it returns an option type. And an option type is basically it can either have the value that you're looking for or it can return none, which is sort of like null.
00:22:53.900 - 00:23:09.820, Speaker A: So we also have to unwrap this as well. So awesome. The command I'm using is fork build and it created a build file.
00:23:09.820 - 00:23:45.290, Speaker A: So I don't have enough time to create a front end for this. But I do have an example I can show you, um, install. Basically this is what our TypeScript front end looks like.
00:23:45.290 - 00:23:47.290, Speaker A: Let me start this.
00:23:49.180 - 00:23:52.330, Speaker B: Thing left it to me.
00:23:55.180 - 00:24:13.676, Speaker A: So we have our contract ID and you can see the steps to deploy the contract if you go to our developer Quickstart. And we have this Fuel Wallet like window object. So we have our own wallet extension and we have this hook to check if it's connected.
00:24:13.676 - 00:24:41.332, Speaker A: And basically here's our new player function. So we can use the fuels or Fuel window object to get the user's account and then we can use these generated types that we got from our contract to instantiate a connection to our contract with the ID and the wallet as the provider. And then here's calling our new player contract.
00:24:41.332 - 00:25:09.532, Speaker A: So we say awaitcontract functions, new player transaction parameters and add variable outputs is one. So this is probably the trickiest thing about this is whenever tokens are sent from the contract to an address, that will affect the UTXOs of the transaction. So we have to specify that tokens will be sent out to an address here or else this call will fail.
00:25:09.532 - 00:25:20.372, Speaker A: And then we just say call and our level up function is basically the same. I actually added like a payable thing here. So we're sending 0.1
00:25:20.372 - 00:25:40.270, Speaker A: of our tokens in the call parameters and I'm basically just console logging this. So I'm going to say make a new Oops. Let's see, this works.
00:25:40.270 - 00:25:59.830, Speaker A: I'm on the wrong network. All right, so beta three testnet. I have funds on my wallet, make a new player and it will show inputs and outputs.
00:25:59.830 - 00:26:15.286, Speaker A: And I'm going to receive one of these unknown tokens because I don't have this asset in my wallet yet. Approve that and we should see our player. All right, so here's our new player.
00:26:15.286 - 00:26:34.390, Speaker A: It's a superhero level one and we're going to level up real quick and this is sending 0.1 of our tokens and we should see the new level in the console. All right, well now we're level two.
00:26:34.390 - 00:26:46.056, Speaker A: Okay, so yeah, that's basically it for how to build a fuel stack. DAP. If you're looking for resources, fuel Network is our website.
00:26:46.056 - 00:27:08.172, Speaker A: You can find links to our developer Quickstart and all of our documentation here. And then I also have a copy of this contract and front end we just built on my GitHub Sarah Schwartz Swagamedemo and I'll put up the QR code for that if you want to check out that code. Yeah.
00:27:08.172 - 00:27:17.090, Speaker A: Any questions? Yeah.
00:27:17.460 - 00:27:22.880, Speaker B: Owned by Mike Frost, there are some space for the nick rolls. What incompetence?
00:27:25.220 - 00:27:32.168, Speaker A: It's just like Ethereum, sort of like so whoever deploys the contract basically are like, I guess you have to write.
00:27:32.214 - 00:27:41.416, Speaker B: Didn'T an owner, but Paul trying to fly track, create a new data iPad for it.
00:27:41.518 - 00:27:53.924, Speaker A: Correct. So yeah, sorry, the question was if you're calling a contract and storing it using storage, then who's paying for that? It's whoever's calling the contract. Just like ethereum.
00:27:53.924 - 00:28:06.946, Speaker A: Yeah, true. All right, well if you haven't already, we have a booth downstairs with a ton of t shirts. Please get a free t shirt.
00:28:06.946 - 00:28:12.840, Speaker A: You don't have to fill out a survey or anything. And yeah, come let us know if you have any questions. Thanks.
