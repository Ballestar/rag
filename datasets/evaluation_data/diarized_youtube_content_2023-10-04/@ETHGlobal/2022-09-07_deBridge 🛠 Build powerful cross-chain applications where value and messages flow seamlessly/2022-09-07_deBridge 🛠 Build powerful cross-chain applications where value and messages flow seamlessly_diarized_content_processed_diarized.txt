00:00:00.410 - 00:00:01.200, Speaker A: Thank you.
00:00:06.370 - 00:00:18.720, Speaker B: Hello everyone. My name is Alex Smirnoff and I am CEO and cofounder at Dbridge. We provide a secure and decentralized interoperability infrastructure for Web Three.
00:00:18.720 - 00:00:42.650, Speaker B: And yeah, I would just like to greet everyone who is participating in this hackathon. And during this workshop I'll provide some insights on how cross chain messaging is working. And at the same time I'll probably give some ideas of what can be built using Debris infrastructure.
00:00:42.650 - 00:01:10.706, Speaker B: And at the end of this workshop, my colleague, our Solidity team lead Alexei will guide you through the process of the technical integration, like how debris infrastructure can be leveraged from your smart contract or from your applications. So yeah, let's get started. And first of all, I would like to highlight also that Debris project itself has started as the hackathon project.
00:01:10.706 - 00:01:48.000, Speaker B: So last year, back in April, we won the global chain hackathon and the hackathon itself helped us to bootstrap the protocol and kind of attract a lot of attention and interest from VCs partners and industry in general. And today we are excited to partner up with East Online to help other fellow builders to build really cool D Five primitives and Web Three projects as well. So let's get started.
00:01:48.000 - 00:02:09.490, Speaker B: So yeah, Debriach is a secure interoperability layer for Web Three. The point is that we provide infrastructure that allows to interconnect any smart contract in any blockchain. So Debris Protocol enables seamless cross chain transfers of value and messages across different chains.
00:02:09.490 - 00:02:36.378, Speaker B: So in order to pass messages between different smart contracts, you just need to interact with the Debriach Protocol smart contract which is deployed in every blockchain, supported by our infrastructure. And what is needed for crosschain interoperability because Bridging of assets is not enough. Like many of the existing Bridging protocols are purely focused on the crosschain swaps or value transfers.
00:02:36.378 - 00:03:11.878, Speaker B: But in fact, in order to build really capital efficient crosschain solutions, we need to be able to transfer value and messages simultaneously. And we should be able to do that not only between users and smart contracts, but also between smart contract themselves. So that smart contract in one blockchain, let's say Ethereum, can open up positions or send a commands to smart contract in another chain and that blockchain can be not even compatible, it can be like non evamp chain theoretically.
00:03:11.878 - 00:03:41.954, Speaker B: So in addition to that, we should be know like the receiver of the message should be able to know who was the sender because when we are sending the message through some messenger, like a telegram, we can identify the sender using the ID. Same with the crosschain messages. Like receiving smart contract should be able to know the address and the chain ID of the sender of the message itself.
00:03:41.954 - 00:04:01.558, Speaker B: And the last point here, which is also important that somebody needs to trigger the transaction on the destination chain. The transaction should be executed because any cross chain interaction consists of two transactions. The one that initiates the interaction and the one that finalizes or executes the message on the destination chain.
00:04:01.558 - 00:05:05.162, Speaker B: And yeah, Debriach infrastructure provides all these features so you can know who are the sender and you can also specify the small incentive which we also call execution fee to incentivize bots or keepers to execute your transaction on the destination chain. And yeah, I will not go deep into the technical details here, but the idea is that in order to send a message, your smart contract or externally owned account like regular user's address, just need to call the send. Method of Debris Gate smart contract and as soon as transaction is finalized as soon as it became reversible debris infrastructure will validate your transaction and it will be claimed in the destination chain where Debris Gate smart contract is called like the claim method and the same transaction debris gate calls debris call proxy to execute the message that was passed.
00:05:05.162 - 00:05:32.290, Speaker B: And basically this external call or the message itself will be passed to the receiver. That can be SmarTrack or that can be the EOA wallet as well in case there is like liquidity transfer. And yeah, so Debriach is a secure and composable and powerful infrastructure that allows you interconnecting any smart contract in any chain.
00:05:32.290 - 00:06:10.654, Speaker B: So basically in order to do some kind of crosschain interaction you need to develop the sending smart contract in one chain and receiving smart contract that will receive the message and process the result of this crosschain interaction. And one of the powerful concepts that we enable is the transaction bonding. So basically Debriach is an infrastructure that allow to perform any complex cross chain interaction in a single transaction and that became possible due to our integration with the multi send library from Gnosis.
00:06:10.654 - 00:07:03.010, Speaker B: So basically the message which has been transferred across different chains can encode the arbitrary set of transaction calls and when the message is executed in the destination chain, the call proxy will call the multisent library. So together with the message you can actually fine tune the execution flow of the transaction and specify the special multisend flag. If there is a multisend flag, the debriach call proxy will understand that this message encodes the set of transaction calls and will execute them sequentially through multisend method where first call can be executed to the first smart contract like another one will interact with the second smart contract, et cetera, until all the transaction calls are sequentially executed.
00:07:03.010 - 00:07:32.714, Speaker B: And this kind of framework allows building very powerful crosschain applications as well as crosschain primitives. You can actually have crosschain swaps to perform conversion from any liquid asset in one chain to any liquid in another. And one of the solution that we already have is called Dswap and we have an API that allows you to perform arbitrary cross chain swaps.
00:07:32.714 - 00:08:29.514, Speaker B: If the asset is liquid then it can be swapped through Dswap and you can use actually Dswap in order to pass value and message simultaneously and you can do that to achieve various cross chainings. Let's say you can build cross chain lending protocol where you deposit liquidity in one blockchain, let's say ethereum, and in the same transaction your users can draw a credit from smart contract in another blockchain, for example polygon. Other use cases can be cross chain yield farming where your liquidity is automatically balanced and kind of managed across strategies deployed in different chains and the liquidity in each strategy can be automatically rebalanced based on the instant or like current APY of each strategy.
00:08:29.514 - 00:09:07.350, Speaker B: So yeah, there are many interesting primitives that can be done. Another one is like MultiChain governance where the voting, like governance voting can be conducted on chain simultaneously in different layer twos and then at some point the result of voting can be passed as a message to layer one, let's say Ethereum, and can be settled. So we can collect results of governance voting, let's say from Polygon, Avalanche, Arbitrum and some other chains and then at sorting timestamp we can subtle this result in Ethereum.
00:09:07.350 - 00:09:54.950, Speaker B: And that's also interesting as well because that makes the governance voting to be very cheap and subtles transaction in layer one which makes the overall process to be very efficient. And yeah, so in addition to that, you can use crosschain infrastructure to combine different protocols to create money Legos because normally we saw these protocols to be combined within one blockchain, let's say Ethereum where Ave is integrated with Maker or Curve is integrated with convex. But we have not seen many examples of cross chain solutions or cross chain protocols that combine different DeFi primitives across different blockchains.
00:09:54.950 - 00:10:57.070, Speaker B: And let's say one of the ideas would be to create the stablecoin protocol like FRAX which can open up delta neutral positions in perpetual markets in different chains simultaneously and the protocol where the position will be opened is picked based on the funding rate. So the better is funding rate, the more positions are open, right? And that allows to have this stablecoin protocol to be way more capital efficient since it's not tied or locked by one single perpetual protocol but it can diversify the positions that are opened across different perpetual markets. The overall idea that with having decentralized cross chain interoperability layer you can combine protocols and smart contracts deployed in different blockchains in order to enable more capital efficient solutions.
00:10:57.070 - 00:11:43.338, Speaker B: Another direction that you can pursue here is the interoperability for NFTs and for Metaverses. Since we can pass arbitrary message, we can also pass arbitrary asset, right? And in debriach we have the bridge for NFTs which we call Dnft and it's open source, you can find it in our GitHub repo and this bridge allows to bridge any arbitrary NFTs so you can leverage that in order to build interesting mechanics or applications with NFTs or NFT projects. So let's say you can bridge NFT from one chain to another and in the same transaction listed in some marketplace.
00:11:43.338 - 00:12:15.810, Speaker B: Or you can buy or sell game assets directly from the game interfaces without being locked to one specific chain, right? And that also allows to make assets to be interoperable between metaverses. Let's say you may have NFT from uniswap V three, which represents certain position or liquidity provided to the protocol. And you can use that NFT as a collateral in DeFi protocol deployed in different blockchains.
00:12:15.810 - 00:12:51.582, Speaker B: So it's really up to your imagination to come up with the idea of all these interesting crosschain scenarios. And if you have any questions about NFTs or any ideas of the projects that can be built, feel free to reach out to us on our discord. And yeah, the last thing that I would like to mention, the new crosschain paradigm, because basically we saw many projects that fork themselves and deploy in different blockchains simultaneously.
00:12:51.582 - 00:13:11.178, Speaker B: But with a decentralized interoperability layer, you can make your protocol or application to be globally accessible. You just need to pick one blockchain that suits your needs in the best way. And then through interoperability layer, you let users and protocols from other chains to interact with your project.
00:13:11.178 - 00:13:46.046, Speaker B: Let's say users from Polygon can interact with your protocol in Arbitrum without the need to switch wallets, switch networks. And you can leverage that in order to enable global accessibility for other protocols or for existing smart contracts deployed in certain blockchains. Let's say as a part of this hackathon, you can also combine Debriach with protocols that are partnering up with ETH Online to participate in several sections simultaneously.
00:13:46.046 - 00:14:14.186, Speaker B: You can build cross chain application and at the same time you can leverage the technology or protocol, which is also part of the list of partners or part of the technological stack. Yeah, so let's move on. The last thing that through global interoperability layer, you can kind of let users and protocols to interact with your protocol.
00:14:14.186 - 00:14:43.458, Speaker B: So you deploy your smart contract in one blockchain, where you need to have synchronous compatibility with other protocols, but then you just let protocols and users from other chains to interact with your smart contracts. And in Debriach, our goal is to maximally facilitate this process. That's why we also provide the whole set of development tools that you can find on our website that includes Dswap, API and Dswap feedrit.
00:14:43.458 - 00:15:08.030, Speaker B: So basically, API allows users to construct cross chain transactions to build cross chain transactions to interact with your protocol. So let's say if we have Ave deployed in Ethereum, we can do a cross chain swap from avalanche and provision of resulting liquidity into Ave in the same transaction. And you can also have utilized Dswap Widget.
00:15:08.030 - 00:15:40.278, Speaker B: That's the solution that allows you to build these crosschain interactions in your UI very quickly. So you just integrate the widget, it takes like 30 minutes or so. And then users can leverage global accessibility of your protocol from any chain where a user has this like any liquid asset so, yeah, that's a bit of the overview of what can be built using Debris infrastructure.
00:15:40.278 - 00:16:15.282, Speaker B: And again, there are so many things that can be created and I encourage everyone to check out our documentation to see what opportunities the Protocol enables. And now I would like to pass the word to our solidity Tim lead Alexei, who will guide you through more technical process of integrating with Debris infrastructure. And of course, I wish you good luck with the hackathon and feel free to reach out to us whenever you have any questions.
00:16:15.282 - 00:16:16.340, Speaker B: Thank you.
00:16:17.510 - 00:16:25.174, Speaker A: Hello everyone. My name is Alexey and I'm the solidity lead at Debris. First off, thank you all to coming to my workshop in this video.
00:16:25.174 - 00:16:42.058, Speaker A: My plan is the following. First, I will give you a brief introduction to the Dabridge architecture which is really important to understand, to start, to build, and to run your cross chain application successfully. For instance, I will let you know how our technical stack works.
00:16:42.058 - 00:17:11.234, Speaker A: I will show you how to construct a message to be broadcasted to another chain, how to monitor such message and how to handle it. Second, I will show you a set of smart contracts that communicate with each other the variations that Debris Protocol. In the wild, this means that we together will make a call to one smart contract with intention to finish this call on another smart contract on another chain.
00:17:11.234 - 00:17:25.420, Speaker A: And finally, I will introduce our new development toolkit which we developed to simplify the development of cross chain applications leveraging the Debris Protocol. That's it. Let's go.
00:17:25.420 - 00:18:11.690, Speaker A: First, what is debris? From the technical point of view, Debris is a generic messaging and cross chain interoperability protocol. But simply speaking, this means that your smart contract on one chain can craft a message containing instructions and assets and send them to the Debris contract with intention to broadcast this message to another chain, where the Debris infrastructure will unpack this message and execute the instructions inside that such message along with the Bridget asset. So how is this possible? Debris consists of two layers the Protocol Layer and the Infrastructure layer.
00:18:11.690 - 00:18:37.170, Speaker A: The Protocol Layer is represented by a smart contract with the name Debris Gate, which has been deployed to every supported blockchain. Currently there are ethereum, BNB, HECO, Arbitrum, polygon, avalanche and phantom. The same smart contract is responsible for sending messages, receiving messages, verifying them, and executing on the destination chain.
00:18:37.170 - 00:18:56.450, Speaker A: Then the infrastructure layer comes into play when the message is being submitted. So when you submit a message, a special event is emitted by the smart contract. Each Validator is responsible for monitoring and capturing such events from every supported blockchain.
00:18:56.450 - 00:19:27.198, Speaker A: And each time the new event is captured, the validator must again verify the message. And if the message is correct, it signs it with their own private key. Then, when all the signatures are collected, they alone with the message can be submitted to the Debris Gate contract on the destination chain where the contract verifies each signature against the public key which is known and trusted.
00:19:27.198 - 00:19:55.734, Speaker A: And if the signatures are correct and the message is consistent, it unpacks the message and executes the instructions inside this. That's how it looks from the high level perspective and from our point of view. This architecture, along with the delegated staking and slashing mechanism makes our protocol truly permissionless and transparent.
00:19:55.734 - 00:20:13.646, Speaker A: Let's dig deeper. So now let's dig deeper into the lifecycle of a crosschain call. So let's say there is a target contract which has been deployed on the destination chain and it exposes a target method which accepts a bunch of arguments.
00:20:13.646 - 00:20:37.830, Speaker A: And we want to make a call to this method from another chain, from the origin chain. How shall we do this? To construct a cross chain call, we must make a call to the Debris Gate contract which resides on the origin chain. The Debris Gate contract exposes a method with the name Send.
00:20:37.830 - 00:21:12.290, Speaker A: You can find the abi of our contract either on our website or even at other scan because the source code of the contract has been verified. You call this method either from externally owned account or from your smart contract, providing the values for each argument specifying flags that affect the behavior of the message. And last but not least, you provide enough native blockchain currency to cover the protocol fee.
00:21:12.290 - 00:21:56.206, Speaker A: The Debris Gate contract accepts all these arguments and verifies them one by one, checking if the values are correct. And if they are, the Wgate contract stores all these arguments as a message in its own storage after in its own storage. And if they are, the contract emits the Send event which just replicates the contents of the submission shortly after the validators catch this event and the submission enters the confirmation phase.
00:21:56.206 - 00:22:23.590, Speaker A: So the validators need to wait a specific number, a specific number of block confirmations for this particular transaction where the sent event has been emitted to ensure that the transaction got accepted by the blockchain. Though they need to avoid network divergence. They wait at least twelve blocks for most blockchains, but they wait 256 blocks for polygon blockchain.
00:22:23.590 - 00:22:56.014, Speaker A: So after the transaction where the submission has been submitted got confirmed, they start validating the message additionally to what the contract already did. So they again validate the state, they validate the values and if the message is correct, they sign them off by signing the message with their own private key. The resulting signatures got pulled to the debriach storage of signatures.
00:22:56.014 - 00:23:25.390, Speaker A: Currently you can cure them using the Debriach API, so it's a centralized solution, but later we will introduce that centralized solution like IPFS. So that's it how the cross chain message got submitted on the origin chain. After the submission got verified, it should be somehow relayed to the destination chain directly into the Debris Gate contract along with the signatures that verified this submission.
00:23:25.390 - 00:23:58.730, Speaker A: For this purpose, the debris Gate contract exposes another interesting method called Claim. This method accepts the message itself along with the signatures that verify this particular message. So you can see this dark blue balloon which consists of signatures which are coming from the signature storage which can be retrieved using the Debris API and the message itself, which is the same message that was submitted on the origin chain.
00:23:58.730 - 00:24:24.350, Speaker A: So the contents of this dark blue balloon got submitted to the Debris Gate contact by calling its Claim method the Claim method. So this process is called Claiming. When called, the Claim method again verifies the message and verifies its consistency by using the provided signatures.
00:24:24.350 - 00:25:12.042, Speaker A: So the Debris Gate contract knows the public key of every trusted validator and it can verify if each signature is authentic, if it comes from the known and trusted validator, and if the contents of the message hasn't been changed during submission. So if the signatures are correct, if they are verifiable, the message is marked as consistent and it got executed by the Debris Gate. How the execution is Performed debris Gate contract unpacks this message and takes all necessary Arcs like receiver and call data and passes all them to the periphery contract called Call proxy.
00:25:12.042 - 00:25:30.386, Speaker A: The call proxy executes the instructions that it finds in the call data field. And in our case, the call data field contains the call to the target method. So the call proxy makes a call to the receiver contract.
00:25:30.386 - 00:25:57.626, Speaker A: It's a target contract in our case and executes the call to the target method. After the call has been executed, the execution flow goes back to the Debris Gate and the Debris Gate emits another event called Claim claimed. This event indicates that the crosschain message or submission in our case has been successfully finished.
00:25:57.626 - 00:26:16.200, Speaker A: That's how the lifecycle of a crosschain call occurs across our infrastructure. I believe that the only way to learn new technologies is to practice them. So now I propose to move to the real world example, actually a conceptual example.
00:26:16.200 - 00:27:07.910, Speaker A: Imagine that we want to build a smart contract with the counter inside that can be incremented by a call from another blockchain. So for this purpose, we develop a counter smart contract here it is which holds the counter property and exposes the receive increment command which may be called by a trusted smart contract from a known blockchain. And we also build an incremental smart contract which, when called must craft a crosschain message which will be passed through the debris infrastructure with their segment to make a call to the counter contract.
00:27:07.910 - 00:27:39.440, Speaker A: For simplicity, the incremental contract will expose a public method with the name Increment which can be called by anyone. So in other words, there is an incremental contract which can be called by anyone and the incremental command creates a cross chain call to the counter contract which can be called only by the incremental contract on that specific chain. So let's move to the code.
00:27:39.440 - 00:27:56.340, Speaker A: This conceptual example I will talk about is already been built by our team and has been published in our GitHub. You can find it in our corporate GitHub account. I will show you.
00:27:56.340 - 00:27:59.800, Speaker A: Yeah. The bridge cross chain. DAP example.
00:27:59.800 - 00:28:31.322, Speaker A: This example is developed as a complete production ready project so it contains a lot of documentation, a lot of helper scripts. It discovered these tests extensively and of course, it contains the contracts we are talking about right now. So let's move to the source code of each of these contracts.
00:28:31.322 - 00:29:00.970, Speaker A: First of all, let's move to the counter contract. So the counter contract, as we already decided, will store the counter internally and here it is. It is defined as integer and the same contract exposes a function with the name Receive increment comment which is intended to increment the internal counter property.
00:29:00.970 - 00:29:35.750, Speaker A: So it accepts the amount we are willing to increment the counter by and the initiator the address of the wallet who actually initiated this increment. The contents of this method is very simple and straightforward. We see that the internal property is just added by the amount that has been passed as an argument.
00:29:35.750 - 00:29:58.380, Speaker A: Actually, that's the whole code for this method. But for simplicity and for more clarity, I decided to add the additional event with the name counter incremented. So we can always check the logs and see who incremented the counter and when.
00:29:58.380 - 00:30:24.930, Speaker A: What's more important here to mention is how the authentication is implemented. Of course, we don't want anyone to call this method, we don't want anyone to call this method either on the chain where this contract is being deployed and we don't want anyone to call this method from any other chain. So we want some kind of authorization layer.
00:30:24.930 - 00:30:38.890, Speaker A: This can be implemented using the modifier. So I give the name only cross chain incrementor. Let's go to the implementation of this modifier.
00:30:38.890 - 00:31:11.534, Speaker A: Yes, here it is the modifier only cross chain incremental. So we created this modifier to prevent unauthorized calls to this particular method. This modi wire is expected to prevent from any unauthorized call and give the ability to call this method only from the chains that are supported by this contract.
00:31:11.534 - 00:31:53.066, Speaker A: And by a trusted contracts, I mean the contracts that are allowed to call it the whitelists are stored internally in the counter contract. You can inspect the properties by yourself so how the modifier is implemented. So when the call to this method is performed, we need to read the data from the debris gate contract to understand the details of this cross chain call.
00:31:53.066 - 00:32:35.438, Speaker A: For the purpose of this, you need to define the interfaces of the debris Git contract. You can take it either from our GitHub account, you can go to the debris finance account, find the Debris Contracts version one repository and take the interfaces of our contracts here. Or you can use an NPM package which contains those interfaces which is very useful to plug in these contracts to your project.
00:32:35.438 - 00:32:44.702, Speaker A: You can find it at Npmgs. I'll show you. Here is the Debris protocol.
00:32:44.702 - 00:33:08.890, Speaker A: EVM interfaces. You can just install it to your package JSON file and import all available interfaces of the debris gate set of smart contracts. You see the imports of these interfaces coming right straight from the package.
00:33:08.890 - 00:33:27.418, Speaker A: So the contents of the modifier is quite complex, not as easy as the receive increment comment function itself. So I will describe it line by line. So first we need to obtain the address of the call proxy.
00:33:27.418 - 00:33:55.074, Speaker A: For this purpose we cure the debris gate contract obtaining the address of the call proxy here is and wrap it with the Icall proxy interface. That's how we obtained the call proxy instance. The call proxy instance is a periphery smart contract which contains the metadata of the crosschain call during this call execution.
00:33:55.074 - 00:34:26.574, Speaker A: So when the debris gate initiates the call on the destination chain, it injects the metadata of the call right into the call proxy. So during the execution of the call, you can get this information by curing the call proxy. The first check that we must do here is to be sure that the contract has been called by the call proxy.
00:34:26.574 - 00:35:04.090, Speaker A: Again, we cure the call proxy contract by calling the submission chain ID from Gadget and check if the ID exists in our internal mapping called supported chain. And the second and the final check we must perform is to ensure that the call has been initiated by a trusted contract on the origin chain. For this reason we again call the call proxy contract, calling the submission native sender.
00:35:04.090 - 00:35:32.870, Speaker A: Getter mind that the native sender is represented in bytes but not the address. This is because the bridge gate is going to support more chains, not only EVM chains and the addresses between incompatible chains are incomparable. That's why for compatibility reasons, every cross chain address is represented in bytes.
00:35:32.870 - 00:35:58.430, Speaker A: However, in EVM we cannot compare bytes directly. That's why we compare the hash of these bytes. So we take the hash of the native sender that we obtained from the call proxy and we compare the resulting hash with the hash of the trusted contract that we already register it to this contract.
00:35:58.430 - 00:36:18.150, Speaker A: In case they are not equal, we revert the transaction. Otherwise all checks have passed and the execution can enter the contents of the receive increment comment function. So, sounds quite simple and really straightforward.
00:36:18.150 - 00:37:04.690, Speaker A: Just one more thing to mention is it's up to you to decide how the counter contract should be configured? In this particular example, we've added some administrative methods like set the bridge gate, which is important for counter and to make some checks. And we also added add chain support which adds the trusted chains and trusted contracts on these supported chains. But you can move this configuration anywhere.
00:37:04.690 - 00:37:19.130, Speaker A: You can move it to constructor or it's up to you to decide how to design this. So that's how the counter contract is implemented. Let's move on to the incremental contract.
00:37:19.130 - 00:37:45.742, Speaker A: So again, the incremental contract is responsible for crafting the cross chain call. So most of its code is related to crafting a call to the Dabrish Gate send method. So for simplicity, we implemented two methods.
00:37:45.742 - 00:38:00.386, Speaker A: The increment method, which can be called by anyone. So we don't design any restricting modifiers. There is also a pair method with the name increment with included gas.
00:38:00.386 - 00:38:32.926, Speaker A: The included gas or the execution fee is a portion of the asset you are going to breach. You are willing to pay to the executor on the destination chain. So say you breach, say, one Ether to Arbitrum and the cost of the execution of the transaction on Arbitrum will cost, say, 0.1
00:38:32.926 - 00:38:46.018, Speaker A: Ether. You can specify the included gas as 0.1 and the Protocol is the design of our Debris Protocol.
00:38:46.018 - 00:39:13.360, Speaker A: It will pay this amount, this exclusive amount to the claiming service who will broadcast and execute the transaction. Treat it like a prepayment for gas for the destination chain. So again, what does these methods do? It accepts the amount you are willing to increment your counter by.
00:39:13.360 - 00:39:32.562, Speaker A: Then, it encodes the call to the counter by calling this internal method. Let's inspect it. Here it is encode receive comment the method is quite simple.
00:39:32.562 - 00:40:05.390, Speaker A: You see that it takes the interface of the counter and encodes the call to receive increment command by taking its selector and by passing the amount that you specify when calling the increment method. So in other words, when you want to increment the counter, you specify the amount in the origin chain. And this amount is being broadcasted along with the call to the destination chain where the call is performed.
00:40:05.390 - 00:40:25.560, Speaker A: So when you abi encode the call, you should wrap it with the message and pass to the Debris Gate. So here is the call to the internal send method is performed. Let's impact it as well.
00:40:25.560 - 00:40:52.510, Speaker A: The send method is more complex than the receiving method. First, we must check that this contract, the incremental contract, has received enough asset to cover the Protocol fees. So the Debris Gate takes two kind of fees.
00:40:52.510 - 00:41:15.146, Speaker A: The fixed protocol fee. It is measured in the native blockchain currency of the origin chain. It costs typically about one USD one dollars, but in the currency of native blockchain.
00:41:15.146 - 00:41:40.414, Speaker A: So for example, for Matic, it's about 0.5 matics. And for Ethereum by the way, I don't know the exact number, but you can always obtain the exact numbers by curing the Debris Gates global Fixit native Figure so I suggest you to do this right now.
00:41:40.414 - 00:41:46.350, Speaker A: So let's go to error scan. Let's find the debris. Gate contract.
00:41:46.350 - 00:42:02.558, Speaker A: Bridge Gate. Yeah. Bridge Gate contract the source code of the debris.
00:42:02.558 - 00:42:09.538, Speaker A: Gate contract is verified. So we go to this tab. We select the writer's proxy tab.
00:42:09.538 - 00:42:19.180, Speaker A: Readers Proxy and here we find the Getter with. The name global Pixit native theme, global excit native fee. Here it is.
00:42:19.180 - 00:42:40.814, Speaker A: And we see that the fee to send the message from Ethereum is this one. Let's take it, let's copy it and open the calculator. Yeah.
00:42:40.814 - 00:42:55.822, Speaker A: So that's the amount you need to supply to Debris Gate. So that Debris Gate accepts your message. So you need to supply 0.1
00:42:55.822 - 00:43:12.630, Speaker A: address. Mind that in other EVM chains the fees differ. So you need to query the actual fixed native fee amount on every supported chain explicitly.
00:43:12.630 - 00:43:42.398, Speaker A: Please don't hard code these values. So let's go back to the incremental command. So here we ensure that during the call to increment or increment with included gas, enough value has been provided to cover the protocol fee and the optional execution fee that you are willing to pay for the executor on the destination chain.
00:43:42.398 - 00:44:07.158, Speaker A: After that, we need to calculate the exact execution fee amount. So again, the execution fee is the optional fee you are willing to pay to the executor of the transaction on the destination chain. And the execution fee is a portion of the asset you are going to bridge.
00:44:07.158 - 00:44:39.750, Speaker A: So in our example, we are bridging the native blockchain currency of the origin chain. So say if we make a bridget call from Ethereum, we breach Ethereum and we must supply at least the protocol fee and the optional execution fee. But the bridge gate takes additional cuts off the additional fee of the bridget asset.
00:44:39.750 - 00:44:56.570, Speaker A: It's around ten bps. Again, don't hard code these values but rather curate from the debris gate. So here we curate the percentage that the bridge gate will cut off the bridged asset.
00:44:56.570 - 00:45:16.450, Speaker A: So expect to see ten bps. Here we see that we breach amount to breach will be equal to the execution fee. The amount that we will receive after the breach on the destination chain is the amount to breach.
00:45:16.450 - 00:45:28.438, Speaker A: Reduce it by the ten bps. That's all about the preparations. Then we are going to construct the crosschain call.
00:45:28.438 - 00:45:50.170, Speaker A: First we need to construct the submission autoparms structure, which contains a lot of flags and operational fields. At least the submission autoparms contains the execution fee. So we set it to the amount that we are going to receive after the breach.
00:45:50.170 - 00:46:01.706, Speaker A: We also set flags. There are a lot of flags that you can look up in our source code. But in this particular example, we need to set two flags.
00:46:01.706 - 00:46:52.358, Speaker A: The first flag is the proxy with sender which tells that the bridge gate to expose the address of the caller in the original chain. In case you don't set this flag, the check on the counter contract won't succeed because the call proxy won't expose the address of the incremental contract and the reward is external. Fail is the behavioral flag that tells the Debris Gate to revert the whole transaction in case the call to the counter fails.
00:46:52.358 - 00:47:08.646, Speaker A: So there are two ways we can handle it. Say the call proxy makes a call to the counter and the counter fails for some reason. If you set this flag then the call proxy will fail too.
00:47:08.646 - 00:47:44.094, Speaker A: But if you don't set this flag, then the call proxy will gracefully handle the failure of the counter and mark the submission as successful so you can operate how to the submission should be finished either gracefully or with failure. Then we set then the submission outer params contains the data fields. That's the call data that we are containing.
00:47:44.094 - 00:47:59.766, Speaker A: The instructions that need to be executed on the destination chain. We already prepared them by calling the API encode. And the very important flag is the fallback field is the fallback address.
00:47:59.766 - 00:48:27.594, Speaker A: Here you must provide the address on the destination chain where the bridget money bridget asset will be transferred to in case of the failure. The bridge gate requires you to specify this address even if you are not going to breach any asset. And lastly, the call to the bridge gate send method is performed.
00:48:27.594 - 00:48:59.370, Speaker A: You see that we provide the value with the amount that we provided during the call to the incremental method. Again, just reminder that the value must contain must cover at least the protocol fee which is equal to the global fixed native fee on the origin chain. And here are the arguments for this method.
00:48:59.370 - 00:49:34.450, Speaker A: In the first argument, the token address, you specify the address of the token on the origin chain you are going to bridge to the destination chain. It can be either a zero address and this means that you are breaching the native blockchain currency of the origin chain or it can be the address of ERC 20 token on the origin chain. Next, you should specify the amount you are going to breach.
00:49:34.450 - 00:49:54.890, Speaker A: The amount of the token specified in the first argument it can be zero. So don't include the protocol fee to this amount. Just include the execution fee and any asset and any amount you are willing to receive on the destination chain.
00:49:54.890 - 00:50:10.350, Speaker A: The third important argument is the ID of the chain you are willing to breach this message to. The list of supported chains can be found at the chainle.org or anywhere in the internet.
00:50:10.350 - 00:50:30.200, Speaker A: Then you need to specify the receiver. This is the packet address that the asset should be sent to and the instructions the call data should be executed against. So we specify the address of the counter here.
00:50:30.200 - 00:50:51.680, Speaker A: Other arguments like permit user, set fee and referral code right now are not important. You can find what they mean in the documentation. And lastly, you need to encode the structure that we've prepared right there.
00:50:51.680 - 00:51:28.310, Speaker A: So in case you made this call, the debris gate will validate all these arguments. And in case they are valid, in case the value contains enough either to cover the fixed native protocol fee and in case the amount you are going to breach is more than the value you have provided. Then the message will be submitted and the sent event will be emitted.
00:51:28.310 - 00:51:51.466, Speaker A: So right now, I would like to show you how these two contracts are operating in the wild in the main net chains. So for the purpose of this, I already deployed both of these contracts to the chains and configured them. I mean, I deployed the incrementer.
00:51:51.466 - 00:52:12.758, Speaker A: I called set Deverage gate and add counter so that these contracts already know about each other. And the same I did for the counter contract. I deployed this contract and called that Set debris gate and add chain support so they can operate with each other.
00:52:12.758 - 00:52:23.500, Speaker A: All right. Now I will show you how this can be performed. Let's go to address count.
00:52:23.500 - 00:52:37.806, Speaker A: I deployed and verified the source code of this contract. So I deployed incremental contract to the BNB chain. You can see the verified service code here.
00:52:37.806 - 00:52:51.890, Speaker A: And I deployed the counter contract to the avalanche. Let's try to perform the call. So I go to the incremental contract.
00:52:51.890 - 00:53:15.194, Speaker A: But before we start, I will show you the current state of the counter contract. For the purpose of these, let's go to the Read contract section. And you can see that the state variable of the counter contract already has the value five.
00:53:15.194 - 00:53:31.790, Speaker A: This means that I already performed several cross chain calls to this contract to test if everything works correctly. Yeah, let's go. So just remember that the current value is five.
00:53:31.790 - 00:53:44.100, Speaker A: So let's go to the incrementer. Let's go to the write contract subsection and find the increment method. Here it is.
00:53:44.100 - 00:53:54.200, Speaker A: I will check if the MetaMask is connected now. It's not connected. I will connect it right now.
00:53:54.200 - 00:54:02.554, Speaker A: Yes. Switch the next network. Yeah.
00:54:02.554 - 00:54:27.486, Speaker A: Right now my wallet is being connected to other scan at BNB chain. Right now, we are going to call the increment method of the incremental comment. For those of you who didn't do this before on other scan interface, the first field is not the argument of the increment method.
00:54:27.486 - 00:54:39.160, Speaker A: It's the amount of native currency you are providing to this method. This is because the increment method is marked as payable. I will show you.
00:54:39.160 - 00:54:53.690, Speaker A: So here is the incremental contract source code. And you see that the increment method and the increment with included gas method are marked as payable. That's why they are ready to receive value.
00:54:53.690 - 00:55:06.720, Speaker A: That's why the interface of elder scan shows this field. So I don't remember the protocol fee on BNB. So let's cure it first.
00:55:06.720 - 00:55:26.178, Speaker A: For this purpose, I will go to find a debit. Go to the contract tab read as proxy. Global fixate native fee has this value.
00:55:26.178 - 00:55:41.814, Speaker A: It means that it is yeah. So 0.5 BNB should be supplied to the Abbreviate contract when calling the send method.
00:55:41.814 - 00:56:03.262, Speaker A: So I copy this value and put it to this field. So that's the amount of BNB I need to supply to increment. So that increment will pass this value to the debris gate contract to cover the protocol fee.
00:56:03.262 - 00:56:20.950, Speaker A: Okay? And the first and the only argument of the increment method is the amount. So that's the amount I'm willing to increment the counter property by. Let's say I want to increment by ten, so the current value is five.
00:56:20.950 - 00:56:35.354, Speaker A: I will increment it by ten, and the resulting value I expect to receive is 50. So let's call the increment method. I see the MetaMask pop up.
00:56:35.354 - 00:56:45.790, Speaker A: I confirm the transaction. Yeah, let's view it. Let's wait a few seconds until it got caught.
00:56:45.790 - 00:57:02.706, Speaker A: It's currently in the pending state. Yeah, the transaction has succeeded. This means that the submission has been accepted on the origin chain by the Debris Gate contact.
00:57:02.706 - 00:57:24.410, Speaker A: But that's not enough. Let's take the transaction hash and go to the Debris Gate to the Debris Explorer where we can view the status of submissions. So we go to the Debris Finance, open the D Explorer and enter our transaction hash.
00:57:24.410 - 00:57:35.002, Speaker A: Inside this transaction, there was only one submission. Here we can see it. It's this submission that was made using the call to the increment method.
00:57:35.002 - 00:57:51.090, Speaker A: Let's open it. Yeah, we see that. While I was talking, twelve blocks have passed and the Debris Validators started confirming this.
00:57:51.090 - 00:58:22.830, Speaker A: You can see in the bottom of the page the list of the validators that have already confirmed and signed this submission. So we see that twelve signatures have been published to the Devreach server. It's time for the submission to be broadcasted to the destination chain.
00:58:22.830 - 00:58:41.410, Speaker A: As you remember, we didn't cover the execution fee, the payment for execution on the destination chain. So we need to execute this transaction manually. For the purpose of this, the Dexplorer provides an easy interface for making such transactions.
00:58:41.410 - 00:59:14.698, Speaker A: So you see the claim button, I click on it, something happens, I need to change the network. Yeah, I change the network to avalanche, the target chain and I will relay the transaction. Yeah, so the Explorer construct a transaction where the call to the Debris Gate on the avalanche will occur to the claim method.
00:59:14.698 - 00:59:36.674, Speaker A: So I confirm. Let's check the status of this transaction. Yeah, the transaction has been accepted by the avalanche chain and I suppose that the status of the state of the counter has been changed.
00:59:36.674 - 01:00:09.870, Speaker A: So let's go to check it. By the way, you see that the transaction initiates a call to the Debris Gate contract not to the counter contract, but to the Debris Gate contract which should verify the message, check the signatures and only if everything is valid, it will unpack the message and execute the call to our counter contract. So let's go to the counter contract and let's read it.
01:00:09.870 - 01:00:28.550, Speaker A: I will reload the page. You see that the counter variable has been incremented up to the expected value 15. Worth mentioning the events let's check the events of this counter contract.
01:00:28.550 - 01:00:52.430, Speaker A: We can see that 1 minute ago, the event with the name Counter Incremented has been emitted, which means that the counter has been successfully incremented. Let's check these values. So the new counter value is 15.
01:00:52.430 - 01:00:57.534, Speaker A: That's correct. The amount the value has been incremented by is ten. That's the same.
01:00:57.534 - 01:01:05.250, Speaker A: Correct. The chain ID from so the call has been originating from BNB. Its ID is 56.
01:01:05.250 - 01:01:19.510, Speaker A: That's also correct. And the initiator it's the address who actually performed the call to the leverage gate is my wallet. You see? Zero x four four one.
01:01:19.510 - 01:01:26.200, Speaker A: I will confirm it using MetaMask. Yeah, that's my address. Zero x four four one.
01:01:26.200 - 01:01:50.202, Speaker A: So that's how the crosschain call is handed, by debris in manual mode. But in most cases, we want these transactions to be executed automatically. So we want to create a cross chain call on one chain, expect it to be executed automatically on the destination chain.
01:01:50.202 - 01:02:20.422, Speaker A: So we don't need to go to the Dexplorer and construct this transaction for the destination chain. For the purpose of this, we need to supply some money that the protocol will pay to the executor on the destination chain. To show you how it may work, there is an increment with included gas method which accepts the second argument, the execution fee.
01:02:20.422 - 01:02:39.194, Speaker A: So the execution fee is a technical definition of the amount that the protocol will pay. So again, let's try to call it. Now, before we call, let me tell you how to calculate the execution fee.
01:02:39.194 - 01:03:00.914, Speaker A: So again, the execution fee is the part of the bridged asset. And if you breach the native currency of the origin chain, then you will receive the rapid version of asset on the destination chain. But the currency on the origin chain and the currency on destination chain are incomparable.
01:03:00.914 - 01:03:30.122, Speaker A: And also, it's important to understand that the gas price, which is the mixture of execution of the transaction, the gas prices are different across chains. So we can take the gas price of the origin chain and estimate the cost of the transaction on the destination chain. What is more important, we need to understand the amount of gas we need to execute the transaction on the destination chain.
01:03:30.122 - 01:04:01.100, Speaker A: So it's a quite complex topic, but for simplicity, let's take the transaction that we already submitted manually. That's it. So I go to the claim transaction on the avalanche, open the details and I see that it consumed almost 340, almost half a million of gas here.
01:04:01.100 - 01:04:37.986, Speaker A: And the gas price was 26. So we need to multiply the gas for this transaction to the current gas price which we currently see and convert it to the dollar equivalent according to the current price of the avalanche. And then we must convert the amount back to the BNB native currency.
01:04:37.986 - 01:04:53.980, Speaker A: So we can understand how much BNB should be provided to cover the gas costs on avalanche. For that purpose, let's go to our calculator. So the gas price is 26.
01:04:53.980 - 01:05:11.710, Speaker A: Let's take 30. Then we multiply it by half million of gas. I take an extra amount of gas to avoid accidental spikes.
01:05:11.710 - 01:05:29.714, Speaker A: So that's the amount of AVAX that you need to have to pay for gas. But we need to convert it to BNB. So we use the dollar equivalent.
01:05:29.714 - 01:05:41.900, Speaker A: It's around $20. So we subtract it. Yeah, that's the amount of dollars we need to have.
01:05:41.900 - 01:06:15.402, Speaker A: And then we multiply it by the price of the BNB. Yeah, that's the amount of BNB that you need to supply as an execution fee that will be passed to the bridge gate and then to the executor. So right now, after we know the amount of execution fee, we can craft another transaction.
01:06:15.402 - 01:06:41.118, Speaker A: So, again, how much BNB should be provided? Previously, we provided only the amount of the protocol fee, which is 0.5. But right now we want to but right now we want to add the execution fee. So we specify more, which at 0.5
01:06:41.118 - 01:07:07.800, Speaker A: plus let's take and this amount will be provided to the bridge game. The amount we are willing to increment by is ten and the execution fee we are willing to pay is 0.3. That's it.
01:07:07.800 - 01:07:56.714, Speaker A: Let's send the transaction yeah the execution fee should contain decimals so we multiply the execution fee by the decimals that's the inconsistency of the interface of Azer scan in this field we can specify the human readable amount and in this field, we must specify the amount with decimals included. So let's write oh yeah, I need to switch back to BNB. That's it.
01:07:56.714 - 01:08:06.890, Speaker A: And right now I will write the transaction finally. Yeah, that works. Confirm view my transaction.
01:08:06.890 - 01:08:30.070, Speaker A: Wait until it until it included in the blockchain. It was included. Let's take the transaction hash and go to the declar again.
01:08:30.070 - 01:09:02.050, Speaker A: Here is the submission. Yeah, already enough blocks, enough block confirmations have been passed and we are now waiting for signatures from the debris validator services. So you see that it's pretty fast.
01:09:02.050 - 01:09:15.136, Speaker A: Enough signatures had been already published. So ten is more than enough to relay the transaction. But you see that I'm not going to send the transaction to Avalanche.
01:09:15.136 - 01:09:48.668, Speaker A: I'm waiting for the automatic execution server to relay this transaction to Avalanche. So you see that we are waiting for it may take some time because the claiming service must be ensured that transaction has been included to the blockchain. But it usually takes a couple of minutes.
01:09:48.668 - 01:09:56.096, Speaker A: Yeah, you see that I didn't sign the transaction on the Avalanche. It has been signed automatically. Let's check it.
01:09:56.096 - 01:10:12.308, Speaker A: So I go to the claim transaction, I click on it. Yeah, you see that the transaction has been submitted from another address, not from mine. Mine is zero x four one.
01:10:12.308 - 01:10:40.190, Speaker A: And this one is the address of the smart contract, which is related to the transaction claimer. And the claimer with this address has been paid for the amount we have Bridget to pay to it. And now let's go to the counter contract again where it is and check the current state.
01:10:40.190 - 01:10:54.660, Speaker A: So I reload the page, read the contract. Yeah, we see that the counter again has been incremented by ten and the current value is 25. Let's check the events.
01:10:54.660 - 01:11:17.684, Speaker A: Yeah, we see yet another event has been emitted a minute ago and the new counter value is 25 is correct. The amount it was recently incremented by is ten, and the originating chain ID is 56. And the initiator is again my address zero x four four one.
01:11:17.684 - 01:11:58.404, Speaker A: So, two events that were met during this demo show how the calls can be crafted and broadcasted across different chains, either manually or automatically. That's probably all for today that I wanted to show you during the demo. But I would also welcome you to our website, Debris Finance, where you can find a lot of useful information and tools for developers.
01:11:58.404 - 01:12:30.700, Speaker A: So go straight to the developer section where you can find links to the documentation to the API of our solutions that are built on top of their breach infrastructure. For example, TSWAP, the cross chain swapping solution, uses Debriach contracts, but it is implemented as a separate product. You'll also find the Dswap Widget, which is useful for webmasters to integrate the cross chain swaps right into websites.
01:12:30.700 - 01:12:54.708, Speaker A: And for developers, there are two important tools that we open sourced. The first tool is hard hat debriach. Hardhat Debriach is a plugin for Hard Hat framework to simplify testing and validating your cross chain messages.
01:12:54.708 - 01:13:44.212, Speaker A: So you saw that the debris infrastructure is quite complex stack and it's almost impossible to replicate it locally. But this plugin simplifies it by providing an emulated environment which replicates the debris infrastructure on your local machine. So just install this other package to your product where you use the Hard Heart framework and then you will be able to run the debris emulator locally, which deploys the vanilla source code of the Debris Gate smart contract so you can test the calls to it using your local blockchain.
01:13:44.212 - 01:14:15.020, Speaker A: And it also provides some extension to the test framework of Hard Hub so you can write tests. Again, the contracts you are developing that should communicate with Debris Gate contract. By the way, the cross chain DAP that I was talking about is built solely on Hardhat and Hardhat the bridge.
01:14:15.020 - 01:14:40.536, Speaker A: So if you go to the Debriach Crosschain DAP example, you will find that tests are using the Hardhat Debris plugin to test the communication between these between each other. Also, we developed a software development kit. D is the game which is also open sourced.
01:14:40.536 - 01:15:12.000, Speaker A: It's a production ready product for complex installations, complex products, complex protocols who need a graceful way to manage and handle cross chain submissions. So, simply speaking, I show you how. I submitted message on one chain user using other scan and checked the status of this message using the Day Explorer.
01:15:12.000 - 01:15:37.256, Speaker A: But probably you want to do this programmatically without going to our interface, without relying on our infrastructure. And here's where DZK will help you. It provides a lot of handy methods that are useful for creating submissions, programmatically checking, the status of submissions again programmatically.
01:15:37.256 - 01:16:01.316, Speaker A: And if you don't want to pay the claimer and you would like to, for example, create gas less submissions or submit them on behalf of users. Claim and relay submissions on behalf of users. You can use again Dsdk to programmatically make this happen on your product.
01:16:01.316 - 01:16:30.430, Speaker A: So Dsdk again a production ready product for complex protocols, so feel free. But it's quite easy to use, so you can use it in your pet projects and I encourage you to use it in your protocols and products that you are going to build during this hackathon. So that's all for today.
01:16:30.430 - 01:16:47.796, Speaker A: Thank you for watching. I hope to see you all in our Discord channel in the Discord Channel of iteha online. So feel free to ask me some questions and see you soon.
01:16:47.796 - 01:16:50.080, Speaker A: Bye. Good luck. Bye.
