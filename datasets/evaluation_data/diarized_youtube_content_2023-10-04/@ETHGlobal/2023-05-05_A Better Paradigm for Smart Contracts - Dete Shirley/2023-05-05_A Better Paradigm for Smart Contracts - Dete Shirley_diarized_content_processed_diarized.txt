00:00:07.450 - 00:00:20.618, Speaker A: Hello everyone. I'm Deeter Shirley and I'm going to talk about smart contract development, which I know a little bit about. So I'm the chief architect of the flow blockchain.
00:00:20.618 - 00:00:40.570, Speaker A: I was also the creator of CryptoKitties, which you might have just heard us talking about a second ago. I also was the original author of ERC 721 that introduced the term NFT to everyone and defined how NFTs work on Ethereum. I was a co founder of Dapper Labs and I helped design a language called Cadence.
00:00:40.570 - 00:01:02.190, Speaker A: And Cadence uses a new programming paradigm that makes ownership a language primitive. And that's what I want to talk about today. So I want to start by making the argument that whenever we have a new domain for software development that it makes sense for us to come up with new programming language paradigms.
00:01:02.190 - 00:01:21.298, Speaker A: So I'll give some concrete examples here. So in the early days of computers, computers cost millions of dollars. And whenever a new computer was purchased at that time, they would write all the software up from scratch because the cost of researchers rewriting the software was cheaper than the cost of the hardware.
00:01:21.298 - 00:01:34.170, Speaker A: And so it seemed like a rounding error next to that. But as computers got more common, as they got cheaper, suddenly rewriting. And as the software got more complex, suddenly rewriting the software every time you got a new computer started to seem very wasteful.
00:01:34.170 - 00:02:01.780, Speaker A: And so the whole notion of portable code came around. The most popular version of that and maybe the most long lived version of that is the C language itself which was created so that the portable operating system Unix, which is probably the most successful software architecture of all time. I think there's probably in this room, I guarantee you there's more Unix computers in this room than there are people in this room.
00:02:01.780 - 00:02:24.730, Speaker A: Then when we introduced relational databases, we had a new concept of atomic transactions. And so we had this new paradigm, this new tool that developers needed to leverage in order to use this new software domain. And when we had graphical user experience, we started to use object oriented programming.
00:02:24.730 - 00:02:55.566, Speaker A: And when we started to create web applications pervasive web applications, we needed some sort of client side execution environment for scripts. And whenever we have these new paradigms, what we see is people developing new languages to express these paradigms natively in the language. And so portable code led to Fortran and C atomic transactions led to the language SQL, which we all still use today with object oriented programming.
00:02:55.566 - 00:03:22.510, Speaker A: We had small talk and then later Java. And for client side scripting we had a whole new language, JavaScript, which is probably one of the most used computer languages in the world right now. And so you got to ask yourself, is there anything in the blockchain world that we use all the time, concepts that we use all the time that aren't well represented in programming languages? And I would argue that there are two things.
00:03:22.510 - 00:03:41.934, Speaker A: One is managing ownership of scarce resources, whether that's fungible tokens or non fungible tokens, whether that's your USDC or your CryptoKitties. The fundamental aspect of those is who owns them. And we need to keep track of that in our smart contracts.
00:03:41.934 - 00:03:59.882, Speaker A: The other most important thing we need to do is control access who is allowed to do what on the blockchain. It's a shared computing environment, and if we don't have solid control over who can do what, then the ownership doesn't matter. If you can breed my CryptoKitties together, then it doesn't matter that I own them.
00:03:59.882 - 00:04:31.118, Speaker A: If that ownership doesn't impart control, then the ownership is perhaps somewhat meaningless. So what tool do we have to represent scarce assets? Well, the hammer for every software programmer is a data structure, a basic data structure where you bundle a bunch of data together and move it around together. And almost every programming language prior to blockchain has worked hard to make data structures more convenient.
00:04:31.118 - 00:04:48.920, Speaker A: They make them very easy to create, it makes it very easy to copy them. You want them to be easy to delete and destroy when you're done with them. The whole notion of garbage collection, which is the entire research topic in computer science, is about what do you do with data structures when you're done with them.
00:04:48.920 - 00:05:04.638, Speaker A: But think about your tokens, whether they're fungible or non fungible, you don't want those to be easy to create. The whole point of these things is that they have value and the creation of them is carefully controlled. They shouldn't be easy to copy in the context of money.
00:05:04.638 - 00:05:27.590, Speaker A: When we copy things, that's called fortuary, and we don't want that, and we also don't want it to be easily destroyable. You don't want a simple programming error to allow some sort of asset to just be deleted and destroyed. So data structures aren't actually really good fit for managing the ownership of scarce assets.
00:05:27.590 - 00:05:41.962, Speaker A: But in solidity and even in WASM, the only tool we have are basic data structures. It is a pain. The good news is that there are lots of smart people thinking about this problem.
00:05:41.962 - 00:06:13.726, Speaker A: And here you see three papers. There are more, but there are three papers where they introduce the notion of resources in smart contracts. So what are resources? They're like objects, if you're familiar with Java, with the whole notion of encapsulation, and the programmer having the ability to hide implementation details and to have capabilities that they don't necessarily expose to the users of those objects.
00:06:13.726 - 00:06:32.522, Speaker A: And they combine that with the notion of linear types, which is a concept that was popularized by Rust, which is that an object can only live in one place at one time. Now, the reason Rust did this was for memory management purposes, if you've ever used so most languages use garbage collection. That works very well.
00:06:32.522 - 00:06:52.778, Speaker A: Something like JavaScript, it uses garbage collection, go uses garbage collection. But the Rust developer said, hey, for certain kinds of programming problems, garbage collection is very expensive, its cost is very unpredictable. And I've seen estimates as high as three or four times the memory footprint of garbage collected languages rather than languages that do directly manage memory.
00:06:52.778 - 00:07:08.274, Speaker A: But directly managing memory is a pain in the butt. That's why most languages don't bother making you do it. And so what Rust did is it said, look, we're going to make sure that each object that has been allocated on the heap, that it only has one reference to it any given time.
00:07:08.274 - 00:07:33.142, Speaker A: And so when that reference goes out of scope, we know that they're done with that object and we can free it up and we can save a ton of complexity. Now it's funny because when they talk about memory management, they talk about who owns the object, right? In smart contracts, when we talk about who owns it, we mean something of value and the beneficial owner of that thing. And when most programming languages, when you talk about ownership, it's who has the responsibility of freeing up the memory.
00:07:33.142 - 00:08:03.014, Speaker A: But it turns out that learning your types that solve that ownership problem of who's supposed to free up the memory can actually also solve the problem of who is the beneficial owner of a scarce asset. And so if you take these concepts of object oriented programming and linear types and you combine them into resource oriented programming, you get something that has carefully controlled creation in cadence. The only way to create a resource object is actually in the smart contract that defines that type.
00:08:03.014 - 00:08:15.366, Speaker A: That smart contract can, of course, have other functions to allow the creation of instances of that new type. But you can't just go along and say new CryptoKitty. It's not a data structure.
00:08:15.366 - 00:08:25.150, Speaker A: In that sense, resource objects are uncopyable. That's the fundamental essence of linear types. And destruction is very significantly deliberate.
00:08:25.150 - 00:08:40.078, Speaker A: If you have a resource on the stack, if you're passing it as an argument to a function and that reference to that just goes out of scope, that's a static error. And that code won't even compile. You can't even upload that code to the blockchain.
00:08:40.078 - 00:08:56.194, Speaker A: It makes you either explicitly destroy that object or put that object into storage somewhere or pass it to a function that consumes it. So we've solved the problem of how you track ownership of scarce resources. We make scarce assets.
00:08:56.194 - 00:09:15.600, Speaker A: You make these resource types, they have direct ownership tracking built in the language itself. And now we have this notion of ownership as a language primitive in our smart contracts. But what about controlling access to those assets? Well, that's where you get this idea called capability based security.
00:09:15.600 - 00:09:31.074, Speaker A: Anyone who's looked at Agoric and the work of Mark Miller may have heard this term. It's also called the object capability model. The basic idea is that your access is based on what capability you have.
00:09:31.074 - 00:09:59.094, Speaker A: And capabilities are kind of like secure channels, right? So if you connect to a website, you might go through an authentication process, and from then on, that connection allows you to do things as you you don't have to keep reauthenticating, it doesn't keep checking who you are, you just keep reusing that same connection. It's often talked about security by what you have rather than who you are. And it is an alternative to access controlless.
00:09:59.094 - 00:10:19.330, Speaker A: But when people think of security by what you have, they often think of like a key card, right? Like I go up to a door and I slide the key card in and that's what gives me access. Capabilities, when properly implemented, actually are more like a remote control. It is the very thing that you hold that lets you do the thing, and by not holding it, you can't do the thing.
00:10:19.330 - 00:10:38.682, Speaker A: And so that's a really powerful way of doing security, because if you don't have it, you can't even call the function. It's not like you call the function and it rejects your call because you're not the right person or you're not on the right access control list. You literally can't call the function because you don't have a reference to the object that implements it.
00:10:38.682 - 00:11:03.200, Speaker A: And this allows for really powerful separation of concerns. It means that you can have multiple objects, each which are within the same scope, right, but which have different abilities, different capabilities on them. So I'll give a concrete example of that.
00:11:03.200 - 00:11:32.726, Speaker A: I my account might have the ability to mint an NFT, and it might also have the ability to draw money out of the smart contract that sells those NFTs. But those two capabilities, if you were to do it in access control this way, you'd put my account on a list and you'd, you know, Dieter has the ability to mint and Dieter has the ability to pull the money out. You know what I'm talking about? Sorry, by the this is can you stand up? This is Fabiano.
00:11:32.726 - 00:11:46.510, Speaker A: Fabiano was one of the other developers on CryptoKitties. There were three of us, and yeah, he's royalty. He wrote the code before I even started working on CryptoKitties.
00:11:46.510 - 00:12:21.050, Speaker A: Anyway, if you do that through an access control list, I now can't delegate the ability to do one of those things without delegating the ability to do both of those things. Because as far as the smart contract is concerned, there is one address which is allowed to mint, and also that same address is allowed to take the money out. But if I have a capability based system, I can actually take the object that lets me mint, and I can hand it to another person, I can hand it to another account, I can hand it to another object.
00:12:21.050 - 00:12:40.046, Speaker A: And I know with certainty that it won't be able to withdraw the money, because I'm only giving it that capability. To mint it further allows greater flexibility. Giving examples of like what I just said, and it's much, much easier to audit because you know that no one can call this function unless they have the object.
00:12:40.046 - 00:12:53.138, Speaker A: And if you don't give them the object, they couldn't possibly call that function. By the way, that's not just an assertion. I actually should ask the Quantstamp people to come to these things.
00:12:53.138 - 00:13:13.718, Speaker A: We've talked to people who do audits and we've had them talk to them about capability based security in particular. And they really find it makes their jobs much easier. So this one construct, these resource types, they seem to solve these two problems that are introduced in the blockchain domain very neatly.
00:13:13.718 - 00:13:32.854, Speaker A: And so that's one of the reasons why in our flow blockchain we implemented a new language called Cadence that is resource oriented. And so we have this new domain smart contracts. We think the new paradigm for implementing these things is resource oriented programming.
00:13:32.854 - 00:14:03.850, Speaker A: And we've introduced a language called Cadence that has thousands of users that implements all of this natively into the language. It's got beautiful syntax inspired by Swift and it's intended to allow much more powerful and complex smart contracts with fewer bugs, fewer complexity and fewer security problems. But wait, there's more because resources are data structures that have all of these limitations on them.
00:14:03.850 - 00:14:24.850, Speaker A: And objects, you can attach objects to objects. And so resources can own other resources and in particular NFTs can own other NFTs. Now this is close to my own heart as the developer of CryptoKitties because there was a project called Kitty Hats that came out soon after CryptoKitties launched where you could dress up your cats.
00:14:24.850 - 00:14:52.042, Speaker A: And it did that by assigning using ledger based ownership where it would say, hey, this hat belongs to this cat. And so if someone sold that cat, the hat ownership would stay associated with the cat. But we can do one better in this resource oriented model, we can actually have it so that the NFT that represents the CryptoKitty can have a list of other objects associated with it.
00:14:52.042 - 00:15:14.500, Speaker A: And as those elements move, then the ownership moves through transfers. The data that's attached to it moves with it. And if I can add more, if I can add a resource to your resource, let me put it this way.
00:15:14.500 - 00:15:36.694, Speaker A: The control of adding new attachments, we call them attachments, the control of adding attachments to existing resources is in the hands of the owner of the resource, not the author of the smart contract that defined the resource. So as the creator of CryptoKitties, we don't get to tell you whether or not you can put a hat on it. As the owner of the CryptoKitty, you can decide whether you want to put a hat on it.
00:15:36.694 - 00:15:54.242, Speaker A: And so the author that creates the hat smart contract says this thing is a hat it can attach to a cat and then the owner of the cat can decide whether or not they want to attach the hat. But once it's attached, those things move together as a unit. And it doesn't have to be a hat.
00:15:54.242 - 00:16:13.250, Speaker A: It could be State, it could be here are your cat stats in this RBG. Here is a list of win loss records of your cat in this battle game. And it allows for a level of composability and extensibility that is very hard to do in other contexts.
00:16:13.250 - 00:16:39.660, Speaker A: So you can see this happening today on the Flow blockchain at developers Flow. There's a link there to let you try Cadence. We have a playground that runs in the browser so you can play with the Cadence language and see what resource oriented programming looks like and see how it makes smart contract code much more intuitive and easy to implement and understand.
00:16:39.660 - 00:17:09.310, Speaker A: So I have time for questions. Does anyone want to ask questions? Yes. So we have a construct built into the language called capabilities.
00:17:09.310 - 00:17:29.314, Speaker A: And the way that we originally implemented capabilities was it's going to get a little in the weeds, but let me try this. Okay? So when I give you a capability, the simplest version of that is just to give you a pointer, a reference to the object. The problem is that that's very dangerous.
00:17:29.314 - 00:17:44.474, Speaker A: So imagine I decide that I'm going to sell you my CryptoKitty. So what do I do? I take a reference to it, I take a pointer to that object, then I transfer that object to you. So what we can't have is that the reference follows the object as it moves around.
00:17:44.474 - 00:18:02.382, Speaker A: The other problem is that what we didn't want to do was have the references be non revocable by default, right? So you can always wrap it in another object to make know have a forwarder. And you could disable the forwarder. And if you read Mark Miller's work, that's what he suggests, right? You create this intermediate object.
00:18:02.382 - 00:18:26.562, Speaker A: And instead of me giving you a reference to, let's say I want you to have the ability to withdraw some money from my account, I don't give you a reference to the vault in my account. I give you a reference to an object that has an access to the vault in my account, and then I can disable that interim object. But if I forget to do that, then I'm really screwed, right? And so what we wanted to do was sort of force people to have this interim object.
00:18:26.562 - 00:18:34.202, Speaker A: And so we would have them create this thing called a link. And it was very confusing. They're trying to understand capabilities, they're trying to understand what they are.
00:18:34.202 - 00:18:47.114, Speaker A: And then the first thing you have to do is create something called a link. And you don't even know why you need a link, right? Because we want to be able to unlink it. And so we're actually rolling out a new feature now called Capability Controllers, where when you get a capability under the hood.
00:18:47.114 - 00:19:07.222, Speaker A: It creates this thing called a controller and that controller lets you disable the capability after the fact and so you don't have to explicitly create the link. But that was a huge area of confusion and it was because we had to introduce these two concepts together. And when you're first learning it, you don't necessarily think, oh, it's critical, this thing can be disabled at some point in time.
00:19:07.222 - 00:19:31.830, Speaker A: And how do you even get a reference to it to disable it if you've handed it off to somebody else? Great question. Anybody else? Go ahead. As a developer, as a multi developer, yeah.
00:19:31.830 - 00:20:13.090, Speaker A: The costs on Flow are very low right now because like any network that's underutilized the rational fee is very low and at some point in time those costs are going to go up. We've done our best to make sure that we're providing a fair cost right, where the cost of executing code is the same as the computation cost of executing the code in terms of the transaction fees. And so then the onus falls on us as developers to make sure that the execution effort is low for the kinds of constructs that we want to see.
00:20:13.090 - 00:20:52.670, Speaker A: And so I think that in terms of load on the execution node that's actually executing the transactions, I think that there's a lot of stuff in Flow that would be cheaper comparably than things that are happening on other blockchains, especially things that are computation based. Certainly querying the contents of an account like on Ethereum, if you want to know what you own, you have to go look in every single smart contract and see if your name's in it or your account address is in there. On Flow, what you own is literally in your account.
00:20:52.670 - 00:21:35.724, Speaker A: I guess it's more of an off chain query anyway, but it certainly means that you can write code that does things like iterate over your transactions that actually iterate over the contents of your account, which would be kind of infeasible on Ethereum. But the one thing that has a little bit of an extra cost is that if your resources are large, like in terms of their byte size, actually transferring ownership can start to get expensive because you're literally copying data from one account to another account. Now that does have the advantage that the cost of storage is borne by the person who owns the object, which is very nice.
00:21:35.724 - 00:22:01.904, Speaker A: But I think that being thoughtful about how big those data structures are, are really important. And doing things like in TOPSHOT, what we do is for every what we call addition, which is a particular play in a particular game that data is all stored once and then referenced from the individual NFT. So the NFTs have some of that data, the serial number and the mint data and all that stuff is in the NFT.
00:22:01.904 - 00:22:58.462, Speaker A: But the shared data, like what's the player's name and what was the game and the score of the game, et cetera, that can be shared in a central smart contract. Anybody else? We have time for one more security practices? Yeah, that's a tough one, because what we did was we learned from another project that I worked on, fabiano with is a project called Cheese Wizards. Cheese Wizards was a game.
00:22:58.462 - 00:23:13.000, Speaker A: It was literally a game that ran entirely on chain. It was the simplest possible game because it was literally rock, paper, scissors. And it just about killed us because Solidity is a very arduous language to do that kind of logic in.
00:23:13.000 - 00:23:55.646, Speaker A: And so, unfortunately, my answer is mostly we learned a bunch of stuff about solidity that had us improve both the language cadence that I was talking about here, but also flow, like the whole account model and this notion. Of capability based security where I think one of the biggest problems that comes up in the ethereum context is people sort of granting access to people or smart contracts and not knowing what that smart contract is going to do and not understanding the limits of what that smart contract can do with that access. And that's something that we've really explicitly tried to make easier in cadence.
00:23:55.646 - 00:24:19.096, Speaker A: Unfortunately, I don't really know how to make those lessons go the other way, because at the end of the day, we decided to build a whole new language because of them. Yes, absolutely. Of course, one of the things we'd like to see is other projects take on cadence.
00:24:19.096 - 00:24:37.572, Speaker A: So cadence is yes, it is written as part of the flow blockchain, but it is as a language can be executed in other environments. In fact, the team was very careful to build the cadence execution layer as an independent entity and can be run independently of flow. So it's quite possible we'd see someone.
00:24:37.572 - 00:24:49.650, Speaker A: Maybe the lesson should be that there should be a roll up on ethereum that runs cadence. All right, well, thank you, everyone. I appreciate you coming and listening to my talk.
