00:00:07.530 - 00:00:25.906, Speaker A: My name is Gyan, and I have my colleague Omar. Together we'll be exploring the world of provable programming through Cairo. It's a bit of a long title, but I have bolded things that are basically important, that is provable programming and Cairo.
00:00:25.906 - 00:01:13.210, Speaker A: The agenda for today is why Cairo? Before learning any new programming language, especially in the Web Three space, I feel like everybody should ask this question to themselves why should you learn another new programming language and what does it bring to the table? We look at what are validity proofs and how are they solving the scalability problem, and then all about Cairo with Omar. Thank you. So why Cairo? I just have one slide for it and try and explain this in a scenario that's best understood by developers.
00:01:13.210 - 00:02:04.906, Speaker A: When you write a program in any programming language, you execute the program and you try to get a result for that program, right? Most of the times, this is how you have been seeing systems running so far. However, if you want to make sure that you want to prove that something was done correctly, then you want to create a proof out of that program, right? And most of the programming languages that exist as of today do not allow you to generate that proof. However, when you write a program in a programming language like Cairo, when you execute this program in any supercomputer, for example, in this context, or any computer for that matter in the world, it will not just execute that program.
00:02:04.906 - 00:02:46.038, Speaker A: It will also generate a result and a proof for you. Now, this slide actually has a little bit more context, but because of the shorter workshop today, imagine if this supercomputer exists in a rival country and you have given them a piece of code to execute, right? You want them to give you the result, and you want to make sure that the result is accurate. If the rival country tries to manipulate the result, whether it was intentional or unintentional, you will come to know, because along with the result, a proof is generated.
00:02:46.038 - 00:03:14.210, Speaker A: So the idea of Web Three or the idea of blockchains is to be able to create trustless cooperations, right? You want to be able to trust any source or any machine that runs a piece of code. And the best way to do that is for that machine to be able to prove that I have run the exact same algorithm that you have given me. This is exactly what proof systems do.
00:03:14.210 - 00:03:34.450, Speaker A: Proof systems help not only generate a result for your algorithm from your algorithm, but they also generate a proof that I ran the same algorithm that you gave me. And you might have heard of zero knowledge proofs. You might have heard of provers and verifiers, which is what is used in zero knowledge proofs.
00:03:34.450 - 00:03:51.786, Speaker A: And this is what exactly the provers do. They generate a proof that a certain computation was done authentically. So in case the computation was tampered, whether intentionally or intentionally, the proof generated for that computation will be invalid.
00:03:51.786 - 00:04:22.562, Speaker A: And this is how in a zero knowledge proof or in a validity proof scenario, a regular computer is able to keep a supercomputer honest. The crux of all of this is that in order to generate a proof you need to learn a provable programming language, which is what Cairo is. Cairo is a powerful and a highly performant programming language which is not just used in Stucknet, but can also be used as a standalone provable programming language.
00:04:22.562 - 00:05:03.220, Speaker A: That's why we chose to freeze the talk today as explore the world of provable programming through Cairo. How are validity roll ups solving the scalability problem and why should you build on StarkNet? That's the next question, right? When you think of the L one scaling problem you have Ethereum where say, for example, when you're producing a block, it just says that, hey, you remember the problem where we are saying like, okay, here is an algorithm, we are executing this algorithm, the new state of the system is 42, right? And a lot of books also say that the answer to all world's problems is 42. Well, we can only hope.
00:05:03.220 - 00:05:48.926, Speaker A: And what happens in the system is the validators actually validate whether this new state is correct and how do the validators validate they are going to rerun the entire computation that this particular block producer actually ran in the first place. And I'm sure all of you already know that Ethereum has gotten congested more often than not in the past couple of years, especially when there's been huge launches, et cetera, et cetera, and that's a huge bottleneck in L ones. Whereas when you think of proof systems, if you remember in a programming language like Cairo, you can not just generate a result saying hey, the state of the new system is 42, but you can also generate a proof.
00:05:48.926 - 00:06:11.366, Speaker A: That how the state of the system became 42 and what happens at Ethereum level, right? So you can see there are two distinctions here. One is the sequencer and one is a validator. Now, sequencer is what is sitting at the layer, two at StarkNet, which is producing this new block and it is also able to create a proof.
00:06:11.366 - 00:06:42.610, Speaker A: Now the validators, instead of having to rerun the entire computation, we'll just have to verify the proof that is generated by the sequencer. And the time taken, as you can see, is pretty pretty less than what it takes to actually rerun the entire computation. Not just darknet, but almost all of the zero knowledge proof mechanisms that you're looking at or validity roll up mechanisms that you're looking at use this exact mechanism to achieve scalability for Ethereum.
00:06:42.610 - 00:06:51.730, Speaker A: And that's why you should learn about StarkNet. That is validity proofs. Verity proofs are an implementation of zero knowledge proofs.
00:06:51.730 - 00:07:13.310, Speaker A: To say that they are zero knowledge proofs is actually a misnomer it's not correct because StarkNet is a decentralized layer two, which is a public network. So it's not entirely a zero knowledge proof system, but it adapts from the mathematics of zero knowledge proof systems. It takes from the arithmetics of that and is built on top of that.
00:07:13.310 - 00:07:32.770, Speaker A: And because it validates in a way that is based on the proverifier system, that's why we call them validity proofs. They use ZK proofs to guarantee computational integrity. That means you can always say that a particular computation was correct or not just by being able to validate or invalidate the proof.
00:07:32.770 - 00:08:13.518, Speaker A: What this means is doing the right thing even when no one is looking, which is the ethos with which web three was created, right? We placed our trust into code and not middlemen because we want everybody to be able to do the right thing even when no one is looking. There's a lot of misunderstanding when it comes to what you can build on things which are built on top of principles of zero knowledge proofs, because zero knowledge proofs are generally considered to have more privacy use cases. But that's not the truth in this case, StarkNet itself, it's all about scaling, right? So you can just about build anything on StarkNet.
00:08:13.518 - 00:08:31.798, Speaker A: A lot of people came to our booth asking if we are leaning towards a particular domain, and my answer is surprise us. If you're building on StarkNet, build anything cool and we are more than happy to see what you're building. Like I said, ZK rollup is a misnomer and StarkNet is a validity roll up.
00:08:31.798 - 00:08:50.666, Speaker A: It uses a particular algorithm called Starks, not Snarks. Two advantages of Starks I want to quickly run through before passing it over to Omar. The first one is that Starks are post quantum secure because they don't rely on elliptic curve cryptography, they rely on collision resistant hashes.
00:08:50.666 - 00:09:06.702, Speaker A: And the second is Starks do not require a trusted setup, whereas Snarks do. So they are decentralized from the get go. Cairo is the programming language that we are using right now to be able to write contracts to deploy on StarkNet.
00:09:06.702 - 00:09:09.890, Speaker A: And the next session is all about Cairo.
00:09:20.660 - 00:09:46.932, Speaker B: So thank you very much. Now we know the relevance of Cairo, what STARnet is for, and now let's look at some Cairo. Who is here considering building something on STARnet for this hackathon? Okay, so most of you okay, so today, who of you have already written Cairo? Who has written Cairo before? Okay, what is your name, sir? Danilo.
00:09:46.932 - 00:09:58.664, Speaker B: You know who Danilo is. He's building the serial node GVM called Kakarot, which is using Cairo for building a serial node GVM. So what Guiang was saying was very relevant.
00:09:58.664 - 00:10:15.596, Speaker B: You can build a serial node GBM on top of Cairo and Stargate. So this is very interesting. You can do a lot of different stuff and to be honest, we won't be able to learn how to write Cairo right now in this 20 minutes we have left, but there's our boots.
00:10:15.596 - 00:10:38.948, Speaker B: And feel free to come and we will see more details about it. We'll go, like with an overview right now, but feel free to come to our booths downstairs and we can guide you, we can help you and you can build some very cool projects. For example, some guys which I don't know, they are not here, but they came out and asked us if there's something like auto payments they can implement on STARnet.
00:10:38.948 - 00:10:56.104, Speaker B: With Caio, an auto payment is, for example, when you subscribe to Netflix, and Netflix makes you a charge every month without you even you don't authorize it. You authorize it once, and then you don't have to keep signing the transaction each month. It's automatic.
00:10:56.104 - 00:11:08.332, Speaker B: And that's thanks to account abstraction. That is something that we have natively in STARnet. And it's something that we have been working on a lot of time with Openseepelium, Bravos, Argent members from the Team Foundation.
00:11:08.332 - 00:11:20.176, Speaker B: So we have been working hard on account abstraction. And that is something that I don't know if you can build it with that quality, another place that it is not STARnet. And you can do all that with Cairo.
00:11:20.176 - 00:11:31.544, Speaker B: So Cairo basically is a smart contract. It's a language that is very similar to Rost. Who knows Roast here? Roast perfect portfolio is going to be very simple.
00:11:31.544 - 00:11:51.090, Speaker B: But don't worry if you don't know Roast, it is very doable. Who knows Solidity here? Okay? If you know solidity and you know how a smart contract works, it is very simple. So I will go and see a small smart contract here and also point you to a place where you can learn more.
00:11:51.090 - 00:12:04.820, Speaker B: I love learning in a written way. So if you want to install everything, you need your setup in order to build on top of and STARnet. If you scan this QR code, you will go to the Starnetbook.
00:12:04.820 - 00:12:29.272, Speaker B: As with the Rosbook, you will have everything you need to start coding the syntax of Cairo. The setup, the CLI, in order to interact with the network, some tooling you can write your contracts using started JS, which is an SDK that will be similar to whatever you use in JavaScript to interact with Ethereum. You can do it with Python, you can do it with Rost.
00:12:29.272 - 00:12:36.140, Speaker B: So we have different SDKs. Everything you can find in the Ethereum ecosystem, you can find it here. And this is the guide for you.
00:12:36.140 - 00:12:47.004, Speaker B: This is the guide for you to install everything and then start writing Cairo contracts. And you will be able to go for this hackathon again. You can ask anything you want downstairs.
00:12:47.004 - 00:13:10.216, Speaker B: Actually, one of the creators of Cairo is down there with us. So who better than him to answer your questions? And let's look how a smart contract in Cairo looks if you go to the Star netbook. This is the STARnet book, the one you already scanned the QR code and you will go to chapter number two.
00:13:10.216 - 00:13:26.560, Speaker B: Inside here you will have the fundamentals of Cairo. Cairo applied for STARnet because it's different, right? And here is a small smart contract that will allow you to vote. It's a voting contract, just an example, but this example will get you going.
00:13:26.560 - 00:13:35.452, Speaker B: So let's start. Okay, I will import with use STARnet. STARnet is the library that contains everything related to STARnet.
00:13:35.452 - 00:13:45.060, Speaker B: I'm going to import the contract address. Okay? That's very similar to solidity. And then as in Roast, we're going to define a trait.
00:13:45.060 - 00:14:02.744, Speaker B: This trait is going to contain all the functions that are going to be external functions. What I mean with external functions, the external functions are those that interact with the memory or the state of the smart contract. Okay? Those that can read or write from the state.
00:14:02.744 - 00:14:18.576, Speaker B: For example, this is the trait Bolt trait. T here makes reference in this case to the state of the smart contract. Okay? So we are receiving here the state of the smart contract and then we're going to be interacting with T.
00:14:18.576 - 00:14:28.480, Speaker B: So again, T in this case is the state of the smart contract. Then we have this function called getboat status. I want a function that is a getter function.
00:14:28.480 - 00:14:42.460, Speaker B: For those that already know, Solidity is going to be reading from the storage and it's going to get me the status of a boat. How many yes, how many no. It will make a reference pointing towards the storage.
00:14:42.460 - 00:14:56.924, Speaker B: Okay, why? Because I don't need to write on storage. For those of you who knows Rost or memory management, this is very familiar to you. So here we are referencing the storage because we need to read from it, we don't need to write on it.
00:14:56.924 - 00:15:07.410, Speaker B: So it is basically a read function or a getter. And it will be returning four different U, eight unsigned integers, eight bits. Okay.
00:15:07.410 - 00:15:26.596, Speaker B: This is also another getter function. It will be reading from the storage and it will tell me if a voter can vote. It will receive again the storage of the contract and will receive the contract address of the user that I'm asking for.
00:15:26.596 - 00:15:40.100, Speaker B: Can this user vote? I will give it the address and it will return a boolean. True or false? And we have the same with is a voter register yes or no. In this case, one or zero because it's a boolean.
00:15:40.100 - 00:15:58.224, Speaker B: It looks like that. And finally we have an external function, but it is a write function. Okay? This write function, which is boat, it references the storage, but it is not only like a reference to read from the storage, but it can write it.
00:15:58.224 - 00:16:10.364, Speaker B: It can alterate the storage. That's what I'm telling with this. Notice the difference between this and this, okay, these are getter functions only reading from the storage.
00:16:10.364 - 00:16:19.590, Speaker B: This is writing to the storage and it will also receive the boat, an onsite integer. Eight bits, yes or no. In this case it would be zero or one.
00:16:19.590 - 00:16:30.900, Speaker B: Then we'll be implementing destroyed. So we're defining here the storage. The functions are going to be interacting with the storage either by writing or by reading.
00:16:30.900 - 00:16:40.860, Speaker B: And then finally we go into the STARnet contract. This is going to be a module mod called Boat. That is the name of the smart contract.
00:16:40.860 - 00:16:53.392, Speaker B: Then we will import a couple. We will import the contract address from STARnet and we're going to import the function called get caller address. I don't need to explain those.
00:16:53.392 - 00:16:58.530, Speaker B: Those are very similar for you. We have two constants. One that represents a yes and a no.
00:16:58.530 - 00:17:08.356, Speaker B: Those are U eight and they are one U eight. This looks a lot like roast for those of you that already seen it. But it is very simple.
00:17:08.356 - 00:17:14.760, Speaker B: If you don't know rust, no problem. Then we're going to go to the storage. This storage is very simple.
00:17:14.760 - 00:17:24.180, Speaker B: You can read for a moment and you will understand it. We have yes votes, no votes can vote, which is going to be a Boolean. It's going to be mapping.
00:17:24.180 - 00:17:33.676, Speaker B: This is a mapping like in solidity a contract address to a boolean register. Boater is going to map a contract address with a boolean again. And yes and no.
00:17:33.676 - 00:17:50.752, Speaker B: Boats are simply unsigned integers until now. Is there a question? We have seen how to create the trade for the functions that are going to be interacting with the storage. We have started our own smart contract and we have defined the storage.
00:17:50.752 - 00:18:17.018, Speaker B: The next is going to be easier. So is there any question here? Yes, you won't even notice it. Behind it is building everything you need in order to interact with Cairo? No, on the contrary, it's very cheap.
00:18:17.018 - 00:18:33.320, Speaker B: So the goal here is that we are having a network that is going to be very cheap to use and also very fast. We had a recent update to the network last week, actually, which increased a lot. The TPS from the network I think right now is the fastest zero knowledge network there is.
00:18:33.320 - 00:18:47.802, Speaker B: To be honest, this is going to increase in a lot in the next month. So congratulations for being here because to be honest, we are in a very good spot right now with STARnet and this is going to be even better. Okay, so I will proceed again.
00:18:47.802 - 00:18:51.866, Speaker B: There might be more questions. What? We can meet downstairs. No problem.
00:18:51.866 - 00:19:03.594, Speaker B: Then I have the constructor. This for you is very similar if you know Python Ros, I don't know JavaScript, if they have something like a constructor. But simply what we're doing is initializing the smart contract.
00:19:03.594 - 00:19:11.822, Speaker B: So the constructor, when we deploy it, we are asking for four things. First, we're asking for the contract state. Again, this we can modify.
00:19:11.822 - 00:19:25.810, Speaker B: So I asking for the state and I'm going to be able to modify it. And I'm going to ask for three contract addresses for the voter number one, voter number two, and voter number three. We only have a smart contract for three different addresses to vote.
00:19:25.810 - 00:19:30.760, Speaker B: This can be infinite. Four, five, whatever. In this case, in this example, we only have three.
00:19:30.760 - 00:19:49.440, Speaker B: Then we are doing some stuff in the initialization, we are calling functions inside our smart contract using self and calling internal functions like register voters in here. I will show it in a minute. But to me, this is very important.
00:19:49.440 - 00:20:06.818, Speaker B: Here I am altering the state of the smart contract. I am writing to it, okay? So what I'm doing here is self on this smart contract that is self. Go to the JS votes, which is on the storage here.
00:20:06.818 - 00:20:20.360, Speaker B: This is the JS votes variable in the storage. And then write the number zero but zero in a format of an unsigned integer of eight bits. Sorry, I'm making some zoom here.
00:20:20.360 - 00:20:34.494, Speaker B: Do the same with no votes. What I'm doing here is basically saying the voting contract is going to start with zero votes with no, zero with yes. Okay? So write to the storage that we don't have any votes with no and no votes with yes.
00:20:34.494 - 00:20:42.942, Speaker B: That's basically it. And we are also registering the voters, like voter one, voter two and voter three can vote. That's all we're saying.
00:20:42.942 - 00:20:51.970, Speaker B: These guys can vote. And we're initializing the vote count with zero and zero. Then we create an event.
00:20:51.970 - 00:21:02.914, Speaker B: This is how events look like in STARnet and Cairo. I won't go into details right now. Both again, you can go to the boot, or you can read this in the book STARnet IO.
00:21:02.914 - 00:21:24.986, Speaker B: I will give you the URL in case you want to review it. But this is how an event looks like, okay? Then I want to show you how to implement the functions that we actually defined before in the trades. Okay? So we create an implementation of that is going to be called Boat Implement.
00:21:24.986 - 00:21:28.140, Speaker B: This name can be changed. They can have any name, no problem.
