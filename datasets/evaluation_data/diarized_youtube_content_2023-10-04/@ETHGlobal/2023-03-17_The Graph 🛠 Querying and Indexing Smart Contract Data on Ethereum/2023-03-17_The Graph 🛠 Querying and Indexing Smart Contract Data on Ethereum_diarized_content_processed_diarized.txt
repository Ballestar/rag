00:00:06.810 - 00:00:36.054, Speaker A: The presentation that I gave like usually it's half an hour or 20 minutes, but I have prepared a special one for you that is the less technical thing like how to actually query data and how to find the data and how to work with this. Depending on time, we can also go into the subgraph development. But yeah, I think it's cool to have this also that was never recorded.
00:00:36.054 - 00:00:48.490, Speaker A: Subgraph development stuff is recorded from target. Anyways, let's get it started. So querying and indexing smart contract data on Ethereum with the graph.
00:00:48.490 - 00:01:07.220, Speaker A: I start here really with the basics. That is what is actually then a smart contract anyways. And I have an interesting example you can think about of a smart contract that it has two things.
00:01:07.220 - 00:01:44.638, Speaker A: Basically it has storage like data and you can think about the storage in smart contract as a simple Google Sheets or Excel sheet where you have just rows and columns with data in it. When we look at the NFT contract, that's my main example because it's such simple in terms of technology, you would have like in a very simple way, you have an ID, the token ID of the NFT. And then you have an owner which is an Ethereum address.
00:01:44.638 - 00:02:11.718, Speaker A: And then you might or might not have a metadata Uri and other stuff. But in a nutshell, the NFT, the ESSN 21 contract defines Token ID and an owner. So that's the data view on it, right? The problem is with the data is that the smart contract and the blockchain, it usually holds the state.
00:02:11.718 - 00:02:28.794, Speaker A: As of now, it is a good tool to see who has which NFT, who owns which NFT. But it is not very good in knowing who owns the NFT before. And that's exactly what's going on here.
00:02:28.794 - 00:02:59.314, Speaker A: That's a problem that we don't see who owned it before. In the smart contract state by itself, this is where the graph jumps in that it actually helps to also find a way into the history of smart contract and on top of that making the current state actually also easier to access. So you can think about without the graph it is just this and with the graph we have a history, but we'll go a little bit deeper.
00:02:59.314 - 00:03:24.186, Speaker A: The second thing that a smart contract does besides holding state or data is it also has rules how to change that data. And that's very important because you don't want everybody just changing who owns which NFT. It follows certain rules which can be encoded in a smart contract.
00:03:24.186 - 00:03:47.990, Speaker A: And that's also why it's called smart contract because the data can only be changed according to the rules. So let's define quickly the concept of a blockchain. Again, so basically a blockchain is a distributed data storage secured by cryptography.
00:03:47.990 - 00:04:07.558, Speaker A: That means that all the transactions, they are in blocks and then the hash is coded on all over those transactions. That makes a block and then the block is always linked to its previous block. That makes the whole thing temper proof.
00:04:07.558 - 00:04:23.122, Speaker A: So you can never change one thing. Distributed means that the blockchain runs not on one server. It is basically copied over 10,000 times all across the world.
00:04:23.122 - 00:04:50.300, Speaker A: That makes it so censorship resistant that you would basically need to shut down every single node that runs the Ethereum blockchain on it or whatever blockchain in order to stop it. And that's basically impossible because we have not global jurisdiction where you couldn't enforce such a thing. That makes it very interesting.
00:04:50.300 - 00:05:06.670, Speaker A: But going forward we think of the blockchain as one thing we do not care about, that it is distributed across all these machines. So we think of it as a logical one unit. So that's just the blockchain.
00:05:06.670 - 00:05:41.900, Speaker A: And then the smart contract, as I said before, is the data and the logic how to change the data that is stored on the blockchain and how does it work. If you want to change the data, you send a transaction to the blockchain which is then distributed across all these copies and you sign it cryptographically with your secret key or your wallet so that everybody knows that this is a legit transaction and then the transaction is included on the blockchain. We will look at that later on.
00:05:41.900 - 00:06:18.520, Speaker A: But there is a problem with the data on the blockchain, as I said before, but the user interfaces, as we initially saw, they want to read, they want to write to the blockchain. And as we saw before, it is incentivized. So if you send a transaction to the blockchain you pay some gas or you have to put some gas on top of it and the gas is consumed by the miners or now it's the proof stake by the validators and then that's why you pay and by paying for it the whole thing works.
00:06:18.520 - 00:06:45.274, Speaker A: But when you want to read from blockchain there's no incentivization for anybody to provide you that data per se, not in the protocol. So that's why when you go on Ether scan you see a lot of advertisements which sometimes are also a little bit shady in order so that Etherscan can fund its own business. Or the same is also with alchemy.
00:06:45.274 - 00:06:55.250, Speaker A: If you do a lot of requests to Alchemy or infura you need to pay for them. So they're jumping into it. But the protocol by itself does not incentivize the reading.
00:06:55.250 - 00:07:18.986, Speaker A: That's a big problem. Going back to the analogy from before, each of these things here is one transaction. And also a bigger problem with the serum blockchain especially is that we have all these smart contracts or DApps that have stuff on the blockchain and every time someone sends a transaction it just laid on top of each other.
00:07:18.986 - 00:07:49.826, Speaker A: So in the end, if you want to see, okay, what was actually going on, let's say in foundation, then you would need to go through all these transactions and pick the ones out that are according to foundation. And that's quite tedious work and takes a lot of time without something that you want to have in the front end. And this is also what we see currently or before the graph that front ends do.
00:07:49.826 - 00:08:33.454, Speaker A: This is really code from a project that I was advising, how they were trying to get the data out. So for those that understand JavaScript or TypeScript that reads as follows you try to get a contract, but all these await methods, especially those that we see here. And these here, they all take 200 to 300 milliseconds to resolve because you always call back to some node, which you usually need to pay somehow, that they give you that data and then you wait and you go through.
00:08:33.454 - 00:08:59.610, Speaker A: So this code, if you own, let's say, ten or 20 NFTs, easily gets five to ten or 20 seconds to load, just to show you a list of the tokens that you hold. And this is super inefficient. And users just move away after a while because they say like whatever, I don't have time to wait 20 seconds for my stuff to resolve.
00:08:59.610 - 00:09:20.970, Speaker A: Yes, that's actually now we had already two reasons why the graph exists. So for one, to get the historical data, but for two, also to have a very good access to the data on the website. You probably know it's indexing protocol for green networks like your IPFS.
00:09:20.970 - 00:09:48.838, Speaker A: There's also support for RV, near Cosmos and others. So in the end, the graph will index all blockchains more consume TM on those 30, 60 currently one point or 1 billion queries per day or even a little bit more depends. So it is really powering a lot of the debts that we see currently.
00:09:48.838 - 00:09:58.060, Speaker A: Uniswap is the most famous example that uses this. But we have also kind of others like Enzyme or Odious or Mstable. Yeah, there are a bunch of them.
00:09:58.060 - 00:10:28.566, Speaker A: It's not only the host service, it's also decentralized indexing network protocol. So there are more than 180 indexes I think currently worldwide, owned by individuals Oops. And that means these are independent indexes that run the thing.
00:10:28.566 - 00:10:45.740, Speaker A: So it is similar to what we talked about before, but Ethereum or a blockchain general is that we have a distributed network. There is this redundancy. So if a subgroup is indexed by one indexer across the world, if one goes down, another is still around.
00:10:45.740 - 00:11:00.846, Speaker A: It also gives you fast and cheap reliable access to that data. And the whole mission is that we go towards a global open API of the data that we need. Yeah, that's very cool.
00:11:00.846 - 00:11:12.238, Speaker A: Then in the end we can now build truly decentralized apps. That's what we try to do here. So quick into the subgraphs.
00:11:12.238 - 00:11:26.886, Speaker A: So I've told you before about subgraphs. subgraphs in general are just a database. A database is the same as you saw before in these Google slides, just multiple of them.
00:11:26.886 - 00:11:57.266, Speaker A: So a database consists of multiple tables and you can define the tables as you wish. Then you have the mappings, which is this gear here, that's a logic of how to get data out of the blockchain into that database and in the end you make it available. And the subgraph by itself, subgraph by itself is only the code that defines how this is done, but it doesn't do it necessarily by itself.
00:11:57.266 - 00:12:26.774, Speaker A: The indexes then need to index the subgraphs which by indexing that means they create the database and they run the code how to fill that database. So yeah, that's the quick concept of the subgraph. So what happens is that we saw this mess of transactions that are just there on top of each other that they are created like very nice neat buckets for each of the protocol in the database, for each protocol.
00:12:26.774 - 00:12:50.766, Speaker A: So we can easily query that data and make much more sense about what's going on. In the end we end up with to go back to the screenshot from before that we have a very nice and neat GraphQL query. So we send one query that has a round trip of 100 to 300 milliseconds.
00:12:50.766 - 00:13:12.038, Speaker A: Usually it's much quicker, that's what we expect to get that data out. All right, I was just reading the chat, so I will also share with you that presentation afterwards. All my presentations are open, you can use them even if you want to give the presentation to someone.
00:13:12.038 - 00:13:43.090, Speaker A: Maybe you want to remove the edge and node logo then, but it's public goods. So end up with this modern DAP architecture where we have the user interface on top and then the blockchain on the bottom that we knew already. In between is this indexing protocol that is incentivized and built for data reading and that sits in between and reads data from the blockchain and stores it in this indexing layer.
00:13:43.090 - 00:14:08.518, Speaker A: All right, so how does it look like then? How can you think about it? This is the illustration, that's the official one, how the graph node works. So again on top is the depth adapt, can be like in its purest sense adapt. It's just HTML, CSS and JavaScript that defines the depth.
00:14:08.518 - 00:14:27.540, Speaker A: It could be also other programming language, but that's what we currently see. And as we talked before, when they send transactions to the smart contracts, you can change state. So that is buying an NFT on an NFT marketplace or swapping something on Uniswap or open LP position.
00:14:27.540 - 00:14:49.494, Speaker A: Whatever cool thing you can do in the transactions transactions, they emit events. And with events, the smart contract basically tells the outside world what happened. We can look into this later what an event is, but that's basically what Smart contracts emit.
00:14:49.494 - 00:15:16.130, Speaker A: So you can watch the blockchain or watch Smart contracts for those events. These events are then ingested into the graph node which will then according to those events run mapping which is in WebAssembly module and put then the stuff into the store. So here's the listed database where the data is stored for later retrieval.
00:15:16.130 - 00:15:38.178, Speaker A: Then the other way that we had also in this image from above, is that the depth also needs queries. So if you go to uniswap at the analytics page, it needs to load data somewhere. So it sends queries to the GraphQL API, which sits on top of the graph node.
00:15:38.178 - 00:16:10.702, Speaker A: And that graphical API will get data from the store and then send it back to the so it's very neat, right? Also a very funny GIF that we used to displace this one, like how subcrops work. So you have this mass of transactions again, and then magically, somehow, they are sorted into this pocket so that they know what's going on. Have an overview.
00:16:10.702 - 00:16:56.560, Speaker A: All right, so now when you think, okay, it's very cool, but now how can I actually find data? Tool query? The best thing in my opinion is these subgraphs that XYZ from Sri they are writing very sophisticated subgraphs okay, I also send you this here in the chat that's currently for me the best entry point. I mean, you can also go to the Graph.com and go here to the Graph Explorer and then you see also subgraphs here.
00:16:56.560 - 00:17:24.860, Speaker A: But the ones from these are the ones that write for themselves or also some of them sorry, see, they're also in the tops here. But subgraphs here are very good. So we can, for example, say, cool, let's have a look at so they have some on the decentralized network and some on the hosted service.
00:17:24.860 - 00:18:25.230, Speaker A: So you can look through them and find out they have like hundreds of crowds. What is it? Okay, 27 production avenue, 47, 74, 4700 development and 106 deployment cost why is that? Because they deploy to different chains that's curve they are usually the same on all cool. So when you want to look into one of those another good example actually is let's switch to this one is the CryptoPunk subgraph subgraph here you need to be careful to take the one with the highest correlation because somehow all the people just deployed subgraphs that's downside of a decentralized network.
00:18:25.230 - 00:19:21.614, Speaker A: Now if you want to query that subgroup then you can just go here and go into the playground and start to play around with that subgroup. But what I like to do and that's where I think it makes sense to see this workshop is to actually open up a little bit more sophisticated playground although a revamp of this one is in the works but I can show you how this work works. So what we do if you want to query a subgraph on decentralized network what you need is kind of this query URL you can copy this query go here then you can go to explore like this and paste it.
00:19:21.614 - 00:20:03.580, Speaker A: Now the problem with subgraphs on the decentralized network is that you need to have an API key and that's inside of that URL is this placeholder for the API key. But we first need to find one, right? So let's do this together. What you do is you go to the subcraft studio actually you connect the wallet and I will just create a new account and then sign in.
00:20:03.580 - 00:20:21.930, Speaker A: Yeah, I use tips already to deploy some desktop craft. But what's important for you is that you go to API keys and not subcraft and then create a new API key. You can click here, like demo.
00:20:21.930 - 00:20:28.650, Speaker A: Cool. And then I can receive free queries. That by giving an email.
00:20:28.650 - 00:20:46.304, Speaker A: I think these are optional fields so I can claim the queries. Nice. And now I have 2000 free queries on this API key.
00:20:46.304 - 00:20:54.230, Speaker A: That's very good. And I already have the API key here, so I can just copy here, go back, go here. I can paste it.
00:20:54.230 - 00:21:04.550, Speaker A: Feel free to just abuse that one. Everybody can have thousands free queries. Cool.
00:21:04.550 - 00:21:37.660, Speaker A: Now what we have here is on the top we have the subgraph and on the bottom we have the explorer and the documentation. So the cool thing about GraphQL is because it is very strongly typed query language that we see, we can have this Explorer on the right you can also have the docs. A GraphQL query has so called root types.
00:21:37.660 - 00:21:44.476, Speaker A: And here we have the root type query and root type subscription. Although subscriptions do not work currently. So we go with query.
00:21:44.476 - 00:22:04.532, Speaker A: If we go on query then you see a detailed documentation about what you can query. So in this example, when you look at the CryptoPunk subgraph it has accounts which are holders of punks. Then we have the actual punks and we have metadata of the punk.
00:22:04.532 - 00:22:28.444, Speaker A: And all of these you see there is this repeating pattern of account and then account with S. So the first one is to get just one and then you need to provide an ID or you can have many and then you can have a filter. We will look into this and then the result is an account or just one account or a list of accounts.
00:22:28.444 - 00:22:54.308, Speaker A: Same with punks and CP account punks, metadata trades, asks bid and contract and so on and so forth. There's a lot going on. So now what do we want to do? A funny thing to do with the crypto pumps actually is to say I want to know which was actually the most expensive sale ever happened on a punk.
00:22:54.308 - 00:23:27.452, Speaker A: And you could go to crypto punks, normal apps here. Cool. I think you can try a large sale.
00:23:27.452 - 00:23:45.412, Speaker A: So cool. They say the largest sale ever happened is this 15822 for 8000 e. Always funny for me to see that people actually pay that much money for a pixel.
00:23:45.412 - 00:24:07.950, Speaker A: But that's how it is. Now we could try to reproduce this one and that will be cool. We go here to the sales and I like this explorer we will have soon something like this also on the graph.com
00:24:07.950 - 00:24:31.030, Speaker A: it always looks the same. We can say okay, what we want to do, we can actually order by the amount of the sale and the order direction we make it descending. So that says it will sort the list of results by amount and the highest amount will be on the top.
00:24:31.030 - 00:25:01.916, Speaker A: Then we can say okay, in which hash it happened, we can say which ID it is and we want to see also the amount actually want to see the transaction hash. And then we maybe want to have the from and to let's see and see. This is for me a very explorative that's why it's also called Explorer.
00:25:01.916 - 00:25:32.970, Speaker A: I can just click around here and read stuff and trying to figure out what data is here and then I can send it. Cool, now we see. So the highest according to that chakra is actually this one and funny enough, when we go back here we see this is eight k but that's the second one.
00:25:32.970 - 00:25:50.160, Speaker A: Maybe I should also get here. Let's set this again. We can remove this one actually have a little bit better view.
00:25:50.160 - 00:26:46.434, Speaker A: So 5822 yes, that's what we saw here for eight k. But a funny thing is that actually the highest sale ever this one and let's try again and why instead what happened here? So when we go to eat to way by the way, usually it's so what happened here? This is interesting beast eight k is the highest sale. That's what they say here.
00:26:46.434 - 00:27:29.946, Speaker A: But actually we also see when we look on the blockchain that it is one hundred and twenty four k e for one punk. And now you wonder like why is it displayed here? We can start to do investigations and that's what I think is the graph perfect for and say there is this transaction hash we go to etherscan such a new compute so autocomplete not there yet and can actually start to look into this thing. And what you see here is that someone made a flash loan.
00:27:29.946 - 00:28:16.206, Speaker A: I think here we see someone got what is this? 500 million die in a flash loan I think from Compound exchange in robbed ETH. That's why we end up with this weird number and then buys a punk and then gives it all back and sells a punk. This person tried to fake this transaction and interestingly, on the official side they censor this but they talk about it in an interesting way.
00:28:16.206 - 00:28:45.970, Speaker A: So we can try to see the punk with the number and go here and yeah, see, they say I gay this blah blah blah they are flash loan and they send it on their website. Cool. Yeah, I think this explains how to query the graph.
