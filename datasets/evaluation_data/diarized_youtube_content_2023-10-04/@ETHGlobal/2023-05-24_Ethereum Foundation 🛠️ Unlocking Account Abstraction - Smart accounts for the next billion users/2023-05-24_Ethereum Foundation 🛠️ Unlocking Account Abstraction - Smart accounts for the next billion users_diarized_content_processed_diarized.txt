00:00:07.450 - 00:00:58.750, Speaker A: So hello, I'm draw, I walk with the Ethereum Foundation on ERC four, three, seven account abstraction. And this lecture is how what is account abstraction? What we are abstracting? What is it good for? So it's going to be an overview and then some deep dive or an example of how to use trampoline, which is a sample project for building an account abstraction. So, first of all, before we talk what we abstract, let's think what is an account? So we have an account. Account has an address. This is the address you hold, tokens and NFTs and whatever. It has an authentication mechanism. You have your private key, these twelve words that you copy all over to the different wallet, applications that you need to protect, et cetera.
00:00:58.750 - 00:01:44.320, Speaker A: Once you create a transaction, you execute a transaction, that is, send the transaction to some specific destination. And of course you have to pay some gas to the network, which is basically the security mechanism that makes sure that nobody sends too many transactions and try to perform a denial service on the network. And all of this is defined by the Ethereum protocol. This is the Ethereum protocol for accounts. So we come to abstract all of this. So what we abstract and how the account becomes a contract. So the address is the contract address, the smart account address it keep still the same address, hold the token and everything you need.
00:01:44.320 - 00:02:18.140, Speaker A: The authentication mechanism is we abstracted by. It is a method. On this contract, there is a method, we'll see it later. We called it validate user op. User operation is our term for a transaction. So the account is asked do you accept this transaction? Do you accept these signatures? Do you accept what you like? This specific method you call it can decide what it accepted, what not usually, basically it's the signature. But it can be more than that.
00:02:18.140 - 00:02:48.580, Speaker A: Execution. Again, it's a method. It's a method called on the account. But it is fully abstracted in that it can decide not only what the method is named, but also what it does. Yes, it can execute on a target with the data, but it can do other things. It can do validation of the target and the data if it likes. It can do executive for batch, like a single user operation that can you please be quiet to move outside? Thank you.
00:02:48.580 - 00:03:34.122, Speaker A: So it can be a batch of multiple transaction, if you like, or a combination of both. And then we abstract the gas payment. Each transaction or user operation has to pay for its execution, but we abstract it to a contract. It could be that the account itself pays for the user operation, but it is possible to delegate it to an external contract. We call this contract a paymaster. It pays for all the transactions and it can decide what logic it performs to pay. Basic examples for that it can be a sponsoring paymaster something that a contract that would like you to use this system without paying for gas.
00:03:34.122 - 00:04:16.682, Speaker A: Someone else pays for it. Of course, it could be a token paymaster that doesn't pay for itself, but it takes your token and makes you pay the system with token. And there are other options. Now all of these with ERC four, three, seven, we've done without modifying the existing protocol. So it is live on Mainet and many, many other networks and test networks, what use cases we have for account obstruction. This is a very short list and there are very many other examples for authentication. It can be as simple as gaming.
00:04:16.682 - 00:04:46.918, Speaker A: With gaming, you don't want to accept each transaction you make it's annoying. You won't maybe do it once. So for gaming, you could create with account obstruction we don't have it. But you can create with account obstruction an account that supports session keys. You approve once, and then a transaction that are targeted at specific contracts at a specific time frame will be accepted automatically. So you wouldn't care to have this key in your browser. For example, on the other extreme, think of a corporate account.
00:04:46.918 - 00:05:15.954, Speaker A: A corporate account has the people who can send out salaries, the people who can send amounts over larger values, or the legal department, which is not allowed to make any transfer, but allowed to vote on some Dow. I don't know. The contract can decide what it likes to do. And again, the system doesn't. The account abstraction framework doesn't define what your account do. You, the developer, decide what features you want in your account. This is what we abstract regarding payment.
00:05:15.954 - 00:05:46.314, Speaker A: I already described this to a scenario sponsoring for onboarding and pay with tokens. Other possibilities exist. And recovery. Since the account is verifying itself, it means that it is no longer bound to a specific private key or something. So you could have some sophisticated recovery mechanism. The first recovery mechanism, the simplest one is change key. Something you can't do.
00:05:46.314 - 00:06:14.014, Speaker A: You can't change a private key with account abstraction. You could start you can start with a browser, use your browser MetaMask like key to protect it. And later on, after you gain some money, you don't want to lose your address. So, okay, you will change the key and now your signer will be, I don't know, ledger. It is the same account. You didn't change the account. If you take out your MetaMask on a MetaMask, a normal MetaMask, you take out the private key and put it into a ledger.
00:06:14.014 - 00:06:27.222, Speaker A: You didn't increase your security. It was exposed. It was written on some paper. It is not secured anymore. So you have to move assets to a different address. With account abstraction, you don't have to. You can even change the implementation of your account.
00:06:27.222 - 00:07:05.322, Speaker A: You start with a simple account. Later on you want to switch to a gnossisafe based account abstraction, go ahead, just fine. There are many other examples. We had a very long lecture back in Bogota and there are others there was also several hackathon projects, some of which won prizes in previous hackathons. So you can look at them too. Okay, let's dive a bit deeper. What is account abstraction? What the components we have? The first layer are contracts.
00:07:05.322 - 00:07:41.710, Speaker A: The first component is our account is our account contract. A smart account contract. It's the contract that represents the account. The next entity is the entry point. Since we didn't change the framework, they didn't change the protocol. We added a singleton contract we call Entry point. All the traffic goes through it and it runs the protocol, runs the validation, makes sure that your account can't be griefed and nobody can perform any operation on your account without your permission.
00:07:41.710 - 00:08:13.930, Speaker A: We'll see it in a moment. And the last user operation may contain a paymaster. Paymaster the contract that is willing to pay for this specific transaction. User operation is the name we have for transaction. We could have named it AA transaction account abstraction transaction. It is named user operation, but basically it's a transaction. Different fields, but it is a transaction, a bundler.
00:08:13.930 - 00:09:06.902, Speaker A: A bundler is the component that put the transaction on chain. If you think of a normal transaction, you have the nodes or the block builders or the miners, depending which take transaction and put them on chain with account obstruction. We name this component a bundler because it bundles multiple user operation. There is some confusion about this component, but basically it is a node. It's just like a block builder that supports account obstruction. Lastly, we can see the mempool account obstruction or ERC four, three, seven try to use the exact same model security model of ethereum and that is transaction. Go into a public mempool and then nodes pick them up to put them on chain in order to boot censorship resistant.
00:09:06.902 - 00:09:28.494, Speaker A: So we copied the same mechanism. So we have a mempool. Obviously it's a mempool of user operation and not of transactions. Let's see the lifecycle of user operation, how it goes and compare it with a normal transaction. The green one. This is a wallet, a software wallet. IMS user want to create a transaction.
00:09:28.494 - 00:09:52.454, Speaker A: It could be an Android device, it can be a browser extension. I don't care using wallet connect or whatever. So it creates a user operation. These are just few of the fields of it. There are ten of them. A little bit more than a normal transaction. It creates a user operation just like a normal wallet.
00:09:52.454 - 00:10:25.614, Speaker A: Create a transaction and then after filling the user operation it sends them into the mempool through an RPC node. Again, just like normal transaction. Except that this is the user operation mempool. A bundler picks up user operations from this mempool that he decides that are worthy enough for him. They pay enough that it wants to put them on chain. If you think of a block builder. A block builder takes a transaction and performs a very simple validation.
00:10:25.614 - 00:11:10.462, Speaker A: He checks the signature, he checks that the non sees the next nons to include and the balance is enough. Very, very simple check. A bundler performs a view call into our entry point in order to validate the user operation before putting it on chain, it performs a simulation of the transaction. It calls the entry point a simulation function which in turn calls two methods in the account itself. It calls the validate user op which would revert if it's wrong, the signature fake or some other fields are wrong. And then it asks the paymaster again validate paymaster, user op, do you agree to pay if there is a paymaster? Otherwise it is the account to pay. This is the validation.
00:11:10.462 - 00:11:44.778, Speaker A: The transaction is okay, now it's ready to put it on chain. So it creates the execution phase. It create a transaction and put it on chain, usually within a bundle of multiple user operation, but it can be a bundle of one operation. It calls a method called handle ups. Handle ups first performs the validation. It's not enough to do it off chain, of course it repeats the validation. It validates indeed on chain that the account agreed that this is a valid transaction and paymaster agreed to paid and after validation it performed execution.
00:11:44.778 - 00:12:49.010, Speaker A: It executes the user operation and gives the paymaster some time to do cleanup. Very useful if you are a token paymaster because during validation you charge the user for the max token needed and in the post op you refund it with the excess of the tokens he didn't use. This way the user will have to pay and it can't get away without paying. This is a flow transaction. Again, this is basically repeating what I said about comparing an account with an EOA account and account abstraction account secured instead of by protocol, it's secured by code validate. We can do whatever validation we like. It's not only accept or reject a single transaction memory pool, quite similar for different entities and the block builder, instead of performing this protocol specific code, it runs the validation code.
00:12:49.010 - 00:13:16.584, Speaker A: Now I'm going one level deeper. I want to create an account. I have to implement a method. This is the only method I actually need to implement for an account which defined by the protocol validate user operation I get SN input the user operation itself. I get the hash of the user operation. It's a hash of all the fields. But since it used in the protocol, there is no need for the account if it needs this hash to calculate it again.
00:13:16.584 - 00:13:43.676, Speaker A: So we pass it in and how much this user operation, the max possible cost of this user operation, how much the account needs to pay, what the account has to do with it, it has to validate that is called from the entry point. This is very important. It is about to send money to this address. So you don't want to pay anyone. It has to validate this user operation. Someone told me it's a misnomer. It's not validate signature, it's validate user operation.
00:13:43.676 - 00:14:33.500, Speaker A: You validate the entire user operation and finally it pays the amount it needs. This is the code of the base account. Accounts usually will inherit because usually the validate is the only function they need to override. If you looked at previous talks I gave, there was also another check of the nons. Because we did let the past abstracted nons and let each account do its own nons management. But we found out that it does cause problems to some actually nothing on chain it will cause problem to block explorers and some other tools that might want to look at the blockchain. So we decided to less abstract the nonsense.
00:14:33.500 - 00:15:15.308, Speaker A: Nonsense are handled and managed by the entry point itself. Still the account has to manage to validate its own signature. This is the validation of the sample simple account. Simple account is an account that attempts to mimic an EOA. It performs the same signature check. So it uses open zeppelin to add the ethereum signed message prefix to the hash and validate that the signature is valid over that one thing. You notice that it returns an error.
00:15:15.308 - 00:16:08.076, Speaker A: In case of a signature failed, it could revert. But there are many reasons for a validation to fail. Like signature could be of a wrong length, wrong type, some other validations you would like to check here. But for signature validation check we add a return value. The reason we add it here again is a UX, because UX issue because you want to be able and I can't want to be able to estimate gas or to do the equivalent of if call with a user operation and you don't want to be able to do it before signing. So if you would revert, then some of the checks will not be able to be checked. So what we did is that the account returns zero if everything is okay and return an error saying okay, this signature has failed.
00:16:08.076 - 00:16:48.364, Speaker A: And during gas estimation, for example, we ignore this signature check. And of course on chain we check that the return value is valid zero. And the execution, this is again the execution of a simple account. Again, it can only be called from an entry point. Obviously you want to make sure that execution is done only to validate it. And the entry point assures the account that only after calling validation it would call execution. This way the account, this is the only check it needs that the sender is the entry point.
00:16:48.364 - 00:17:09.872, Speaker A: And there's also the basic implementation of a batch. And someone will say that execute batch doesn't pass value. They could go ahead, create your own execute batch. This is not part of the protocol. An account needs to have some execution methods. We don't mandate what they are. The validation is the only thing that the protocol with the entryfront define.
00:17:09.872 - 00:17:49.436, Speaker A: You can put whatever method to call and you can call other method like method in the account itself. You don't have to go through execute and call your account if you can support other methods. Sorry, this is the logic of the account. I'm now going into a Paymaster. What a paymaster has to do again the paymaster has his validation function. The base paymaster again wraps it just to make sure that it is called only from the entry point. If there is a paymaster, the paymaster will pay for the transaction.
00:17:49.436 - 00:18:47.888, Speaker A: The user will be told you are paying zero, you don't need to pay anything and the paymaster will pay. As I said, it will be called first to validate and after the operation is completed, the paymaster is called again with the actual gas cost that was used. The actual name is the actual gas cost except the post op we are unable to calculate how much if you want to create a token paymaster and you want to pay for this post operation, we are unable to estimate how much gas it will take. A Paymaster has to have its own constant how much to charge for this post op. Now I will go over Trampoline. Trampoline is a browser extension. We created it's inspired by tallyho or by MetaMask.
00:18:47.888 - 00:19:17.692, Speaker A: It is not based on their code and it is used to create an account. There are several projects were already created using this in previous hackathon. And yes, we would like to see projects that go with account obstruction. And I'm sure that the first thing people want to say yes, I will create an account. But yes, there are many of them. Try to think, or even approach me with it. Try to think somewhere innovate something new.
00:19:17.692 - 00:19:50.984, Speaker A: Not only create yet another account, but add something on top of that. There are many examples we can show, as I said, of what account can do. We want to see something new. But this is a template of how you can create an account. So the trampoline is built. First you have the account API. It's a wrapper contract that it's, a wrapper JavaScript code you will see around the API you need to implement for your contract account.
00:19:50.984 - 00:20:29.812, Speaker A: And then there are three UI components react component that you can use. One of them is the onboarding component that is called once when you create an account. The other is a react component that is executed every time you create a transaction. And the third is a react component when the account attempt to do a sign. So, first of all, okay, I have an account API. What is an account API? This is a wrapper you have to implement if you create a contract. We created a simple account.
00:20:29.812 - 00:21:08.288, Speaker A: We created a simple account API which gives JavaScript functions for each of the JavaScript functions in order for the account to be able to work with it. The first function is get init code. Getinit code is the constructor code if you like. That is called to create this account. It's a call to a contract and what data to pass to it. Usually this data contains the signer information to create this account. The factory contract is on chain and this is data to create it.
00:21:08.288 - 00:21:30.804, Speaker A: The second method is how to call the nons. Usually accounts have get nons function. The simple account has a get nons function. This is the JavaScript function to call it. We need it of course to fill the fields in the next transaction. The third one is encode Execute. As I said, the execution method we call by default.
00:21:30.804 - 00:22:01.360, Speaker A: We use the name execute, but again, it's a default. It's not defined by the protocol. You can have a different method. And when we work with Gnosis, if they have a different signature message, everything is okay. It doesn't have to be anything specific. It should contain the target, the call data and gas if you like, doing batching kind of, if you like. And lastly, of course, sign it's the method that is called in order to sign the transaction which should pop up something to the user to sign.
00:22:01.360 - 00:22:38.952, Speaker A: Or if you do it silently, it can also be done. The onboarding component is a react component with a single method that react callback onboarding complete. It returns some context. I didn't show it before. When you create this simple account, it gets this onboarding context. So onboarding can ask the user for some information and use it to create the account. When you send a transaction, when the user calls send transaction, then we call the transaction component.
00:22:38.952 - 00:23:30.830, Speaker A: It display the transaction and then call the it should call the onComplete transaction which in turn call the simple account API to use that information to create the user operation out of it. Now I want to show how it looks. So, okay, first, I have this extension. Here one. This is the trampoline contract on GitHub. I cloned it here. Now I will start it.
00:23:30.830 - 00:23:55.080, Speaker A: Actually, it's already compiled. I think I can load it from a previously compiled. So I go into extension. I need to disable MetaMask. It doesn't work in parallel with MetaMask. This one I loaded earlier, so I reload it. I will go into this project, the project compiles.
00:23:55.080 - 00:24:20.224, Speaker A: This is the trampoline projects. I go into the build. I will load it as a component. And now it will ask me to create an account. This is a sample page we started and I created an account. If you like to encrypt the local data, it's possible MetaMask does it and ask you for a password. Yes, you can use it.
00:24:20.224 - 00:24:50.180, Speaker A: But if you create an account that saves all the private key elsewhere, then you don't need to. I wanted to demonstrate I don't have it right here. The web authentication that use web authentication. That is the authentication API inside Chrome or Android devices. But I'm unable to demonstrate it right now. Sorry. So here we pop up a customizer component.
00:24:50.180 - 00:25:19.680, Speaker A: Whatever you want to put in front of it. It created the simple account. Created the account by creating an account, I mean it created a private key. It's everything in memory. It created the constructor code how to call it and I have an address but it's not deployed and it doesn't have any ease. So I will send from my own account some ease to it. I save years to join.
00:25:19.680 - 00:26:24.500, Speaker A: And why does it say fail? That's new. So you know designate. Okay, I'm sending some ETH to this account now you can click on deploy and then it will ask for transfer fund. Soon it will notice that I transfer fund and then I can deploy contract. But okay, I don't want to deploy it. I want to create a transaction directly with this account even before it is deployed. So here I open ether scan.
00:26:24.500 - 00:27:05.152, Speaker A: This is a nice contract sample from Open Zeppelin. Actually it's the old sample. They have the greater sample and I will use it as an application. I will connect my browser extension to it. It says MetaMask. It means whatever account you have deployed, it will pop up connecting UX of our account. Okay, now I'm connected and can call this set greeting function and I send a transaction again it pop ups a dummy component.
00:27:05.152 - 00:27:40.960, Speaker A: The basic sample doesn't do anything in it. So now it estimates the gas that it will take and we see the transaction that will be sent to the account. This page again it's fully customizable in the code. You can put whatever you like. Like custom logic for paymaster if you add one I'm sending this transaction. We wait a while a moment until Sepolio will agree to accept. Sepolia is faster than girly.
00:27:40.960 - 00:28:04.900, Speaker A: Yes. Okay, it completed. This our transaction. If we look at it, we see it's a transaction form and address. It is some bundler and it is sent to our entry point. If we go to our greeter and look at this transaction of course we will not see anything. We didn't call it directly.
00:28:04.900 - 00:28:46.930, Speaker A: It is called SN internal function. And our account if we now go to our account if I look at my account now, it is deployed. It paid for its transaction. And if I go to Ether scan I can see it in the contract itself. This is the contract code. It was deployed but it paid for its deployment. Deployed and executed on chain.
00:28:46.930 - 00:30:04.060, Speaker A: One thing I found some if you want to look at the transaction itself tenderly log is very nice and detailed to understand how transaction goes on chain so they belong with all you access. Why this transaction doesn't open? I need to think. No, this is not it. It's the wrong transaction. So once no, this is the deployment transaction. It's not the great for samples. This is our transaction, the latest transaction that was submitted to the entry point.
00:30:04.060 - 00:30:52.090, Speaker A: Here we can see the flow of the transaction. We called bundle of handle up. We can see the method that called validations here it creates the sender. This is the code that runs the factory that creates the sender and it calls the account validation. This is the account calls the entry point to pay for itself. And the account called this the greeter function and changed the greeting message, even the log inside it. And finally, the bundler that paid for this transaction get refunded.
00:30:52.090 - 00:31:22.694, Speaker A: Okay, this is the account now. Yes. Building all this is not a sole project of us. There are many where are they? There are many projects that did a lot of work to help several bundlers out there. Right now I think this one is using candidate bundler or stack app. I'm not sure. Alchemy also created bundler.
00:31:22.694 - 00:32:23.536, Speaker A: Several companies created wallets or toolkits like the zero dev toolkit that can allow an application to deploy accounts on chain to create initial account to let an onboarding deployment so that you can deploy an account even before you install a wallet. Okay, so that's it. If you have any questions, I'll be happy to answer. If you have question here if you want any help and you can contact me later. Yes, the validation is the validate user. Let's say you want to create an account with a different signature scheme. So instead of multi sync, you want to check two signatures.
00:32:23.536 - 00:33:12.162, Speaker A: So the place to check is the validate user op. The validate user op takes the signature field and decides that it's not a single signature, it's two signatures to verify one verification. This is what you do in a contract. Now in the UX, you need to pop up the user whatever it needs to collect those two signatures and put them into the signature field. When the UX asks you to sign, you perform a different logic what it has to be done in order to sign a transaction. So you change the contract and you change the UX to match it. Okay, I repeat the question.
00:33:12.162 - 00:33:46.906, Speaker A: You want to add the rule. I don't want to be able to send more than 500 if from a USDC. So what you need to do is probably create a different execution method. Because in the execution method you can limit that. You don't want to call the USDC account with a value more than something. Usually this is not what you want. You want to be able to let the user decide.
00:33:46.906 - 00:35:45.014, Speaker A: I want to transfer this from to limit this specific token for this specific value. Okay, you have a logic on chain to do it. So I'd create a method like transfer transfer with limits or something and it performs this limit check and during execution validation will make first check. What is the method that is called? Right now validation accept any method because there is single one execute a validation can check that the method SIG you are now calling is called limited if it's called limited validation to enforce this limit you're right. This is a sample that is better to be added to the demo to write it? Yeah, we can talk after and it's something that nice to be added into the presentation. Any more questions? Yes how the gas compared with a normal wallet and execution? Okay, it's more expensive of course we are calling an account we're doing a gas calculation on chain so roughly it's 30 or added overhead on main net. Yes, you might say it is expensive and on side chains on L two S there are ways to get the gas lower okay, we're creating a bundle.
00:35:45.014 - 00:37:21.996, Speaker A: Some of the overhead of accounts is split between different user operation within the same bundle for example, there's a 21,000 dependent that you have to pay. This is for the entire bundle, not for each user operation yes, there is an overhead for each user operation if you compare it to AI, if you compare it to EOA, if you compare it to other smart contracts you might call okay, let's say I'm calling Safe it will be slightly cheaper. Yes, we have an extra overhead. It is not only a smart account, it also has some overloads of gas. And the goal with ERC Four Three Seven is not staying as a contract, but at some point to be able to add it into the framework, to add it into the network, to enshrine it into the protocol, to be part of the protocol. One of the benefits then will be reduced gas costs, reduced overheads because one of the use case again theoretical one, it's not implemented yet, is that on L two s it's possible to there is a gap between how much you pay for CPU and how much you pay for call data. Most of the cost on L two S is for call data for putting the data on chain so idea if you could compress a bundle to put less data on chain even if it costs you more gas to process it, it'd still be beneficial.
00:37:21.996 - 00:38:23.376, Speaker A: So the most not cost effective, most expensive component in a transaction that you can't compress is a signature because all the rest of the data you can compress but signature you can't we have 32 bytes that you can't compress. If you are doing what is called signature aggregation you can have a single signature for an entire batch. And we did some calculation there is the BLS wallet who has done it not on top of account obstruction ERC four three seven but they are planning to add its support see Zach here so it will be able for while you use bundles larger than I don't know 510 you will. Actually reduce the gas cost when running on l two, the gas cost for the clients. So this is something that will be able to be done on the l Two s. Okay, enough. Okay, thank you.
00:38:23.376 - 00:38:24.770, Speaker A: Thank you very much.
