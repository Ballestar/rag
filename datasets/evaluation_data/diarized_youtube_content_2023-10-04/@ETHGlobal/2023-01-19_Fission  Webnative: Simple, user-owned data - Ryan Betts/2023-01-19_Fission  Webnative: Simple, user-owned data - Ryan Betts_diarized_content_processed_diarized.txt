00:00:16.400 - 00:00:26.916, Speaker A: Hello, everyone. Good morning, good afternoon, good evening. Depending on where you're calling from, welcome to day two of workshops for FBM Space War Pack.
00:00:26.916 - 00:00:41.820, Speaker A: We have Ryan and Andy here from Sissyon, who's doing a workshop on web native, simple, user owned data. If you have any questions, you can ask them right in the zoom chat and they'll be more than happy to answer them. And with that being said, I'll hand off the mic to our two speakers.
00:00:44.770 - 00:00:54.540, Speaker B: Thank you very much. Let me just get screen sharing here. Yeah.
00:00:54.540 - 00:01:03.790, Speaker B: Welcome everybody. Today, and I will reiterate yeah. Good morning, good afternoon, good evening, good night.
00:01:03.790 - 00:01:37.332, Speaker B: So we're going to talk today about Web native, a project that we're working on at Fission, and specifically a new feature, an experimental new feature we call Walletaut. And so what this is going to set you and your teams up with and your end users is simple user owned data backed by a filecoin wallet. So just before we dive into the demonstration, a little bit about Fission.
00:01:37.332 - 00:01:58.544, Speaker B: So we build identity data and compute solutions for the future of the Internet. We refer to ourselves as an applied research lab, and we're really committed to humane software, and we want to set people up with better ways of building it. And we're fairly ecosystem obsessed, we say, about how we go about that.
00:01:58.544 - 00:02:18.948, Speaker B: So we're focusing on doing that from the protocol up. We want to make sure that we've done all the heavy lifting so that you guys can focus on bringing your ideas to life. And we do this by working on some today stuff and also a lot of tomorrow stuff.
00:02:18.948 - 00:02:53.228, Speaker B: So we've started referring to some of the protocols, the aforementioned protocols that we work on as our edge computing stack. So I'll go through a couple of these protocols right now. The two today ones that we're going to be diving into that are a part of Web native at this very moment are you can, which you may have seen our UCAN toucan kick it around in worlds, but UCAN stands for User Controlled Authorization Networks.
00:02:53.228 - 00:03:15.716, Speaker B: It's a decentralized authorization protocol, and it's actually soon to be supported by our friends over at Web Three Storage. So presently, most of the time, if you're going to do authorization in an app, you're going to use Access Control list. That model doesn't really apply so well when you get into this world of decentralized applications.
00:03:15.716 - 00:03:31.724, Speaker B: And so you want something that's object capability space, where the person and the thing that they're able to do with the resource that's in question is actually just kind of all contained together. And so that's a concern that you can help take care of. For you.
00:03:31.724 - 00:03:42.960, Speaker B: There is a working group that you're invited to join. WinFS is the other thing. So this is user owned end to end file system that's built on top of IPFS.
00:03:42.960 - 00:03:57.140, Speaker B: You'll find this probably popping up in a lot of places throughout the protocol Labs ecosystem and beyond. And if you're interested in these, you can go to Fission codes and find links to them. You can also hop on our discord.
00:03:57.140 - 00:04:24.104, Speaker B: We have regular working group meetings that a bunch of organizations, not just vision, help to steward and then some of the tomorrow things. So IPVM, you may have heard the term compute over data. You may have heard about how IPFS wants to bring computing to the data layer.
00:04:24.104 - 00:04:47.524, Speaker B: So IPVM is one of the efforts that we're helping to lead in that regard. And then lastly Rhizomedb, which will be database structured data on top of IPFS, and that's being incubated in a group within Fission called Fission Reactor. By the way, I should also mention who I am.
00:04:47.524 - 00:05:12.396, Speaker B: I just realized I skipped over that I'm the head of design at Fission, so I'm just a designer, so please forgive me if I bungle some of the technical status of these things. And then Andy, who will be running the demo, is one of the developers on the web native team. So you can and winifast those two protocols that are ready today.
00:05:12.396 - 00:05:31.136, Speaker B: Web native is our SDK that wraps those things up. So even though you're invited and encouraged to dig deeply into those protocols, you don't necessarily have to understand them in detail or how they work in order to take advantage of web native. We refer to webnative as a true local first edge computing stack.
00:05:31.136 - 00:05:48.728, Speaker B: Why true? Because it honestly does just run at the edge on your user's machines. There's no cloud needed. So if you want to dig into this after during webnative dev is where you can find the full site dedicated to that and what's it going to give you.
00:05:48.728 - 00:06:25.110, Speaker B: It is going to provide you with passwordless authentication via one of three strategies. So the initial and most stable one that we implemented uses the WebCrypto browser standard to provision non exportable keys that live in the browser and uses youcan and some magic to let those things be syndicated across the different devices that you possess as the user. The second one, which is what we'll be diving into today, is Wallet Auth.
00:06:25.110 - 00:06:41.316, Speaker B: So this is an auth strategy that works with EVM compatible wallets. Presently the only wallet client that supports it is MetaMask. So this is experimental, but we're excited to see it stabilize as new standards emerge.
00:06:41.316 - 00:07:17.140, Speaker B: And then finally Paskey's, which is under construction right now, and we can talk about another session in the future. The other thing it's going to give you, as I mentioned, private and secure data encrypted at rest, user owned and IPFS based, which means it integrates seamlessly with filecoin. And this is going to give every user their own public and private file systems and then really importantly, a local first UX, right? So everything works offline by default.
00:07:17.140 - 00:07:40.428, Speaker B: This means you can easily as a user, collaborate across your multiple devices and in the future with other users and even in a more synchronous workflow. And critically, no cloud is needed to make this work. So you may have noticed in our earlier slide, or if you're familiar with all of Fission, we really love having mascots for stuff.
00:07:40.514 - 00:07:41.150, Speaker C: We.
00:07:43.280 - 00:07:57.796, Speaker B: Give out a lot of stickers. And so for Wallet Hot, our lead visual designer, Bruno, made this great mascot named Wally. And so if you track us down in real life, we'll hook you up with one of these.
00:07:57.796 - 00:08:23.610, Speaker B: But before we dig into the demo itself, just wanted to clarify some terms. So I noticed that the term wallet often gets used a little bit loosely within our industry. And while this doesn't necessarily matter for end users themselves, if they get a little bit of terminologically confused, I think for us it's really helpful to be a bit more precise about what we're referring to.
00:08:23.610 - 00:09:18.812, Speaker B: And so during the course of this presentation, when we say wallet client, we're talking about the MetaMask, rainbow, et cetera, the app that you're going to use or the browser extension that you're going to use that brings a UI to you, where you will interact to sign a message, review your balances and assets that's going to provide UI for the wallet structure, which is also maybe called best referred as the recovery method. This would be like your recovery phrase, or maybe your social recovery factors, and also the many accounts they represent if you're in fact using an HD wallet, and you have many accounts derived from that same recovery phrase. And then finally, and this is the thing that we're going to be calling the wallet today, there is the account, aka wallet, and its public address.
00:09:18.812 - 00:09:36.800, Speaker B: So this is the public private key pair that your assets are actually attached to and that you use to sign the message. Without any further ado, I'm going to hand screen Sharon over to Andy.
00:09:41.430 - 00:09:43.540, Speaker C: All right, let me just open up my screen share.
00:09:45.430 - 00:09:46.180, Speaker B: Okay.
00:09:46.630 - 00:09:52.690, Speaker C: Hey, everyone, thanks for all that. Ryan. I'm going to quickly walk through a demo of our Wallet Auth template.
00:09:52.690 - 00:09:59.750, Speaker C: So if you guys can see my screen here, this is all available. It's all open source on GitHub in our web native examples. Github.org.
00:09:59.750 - 00:10:18.620, Speaker C: So this is basically an app template built on Sveltekit based on our web native app template, which just uses the traditional webnative flow that Ryan could have described. This one has been configured to work with our web native Wallet auth package, which is also open source on our vision codes, github.org built by Steven Vandevelves, who's on our team.
00:10:18.620 - 00:10:30.686, Speaker C: And yeah, we have Svelte and React versions of both these. We made them basically so developers could really hit the ground running if they're at a hackathon, for instance, or if they just want to get a project up and out the door really quickly. Yeah.
00:10:30.686 - 00:10:41.614, Speaker C: So without further ado, I will check out Walletauth vision app. Anyone can go see this if they want to. And right upon landing, we set it up so you'll be prompted to connect your wallet.
00:10:41.614 - 00:10:57.366, Speaker C: In this instance, I haven't connected yet, so I'll just connect account two. Yeah, so all that good stuff. And so, yeah, right off the bat here, we basically ask you to sign a message and the message you're signing is specifically the message you're seeing here.
00:10:57.366 - 00:11:13.230, Speaker C: So hi there. Would you like to sign this so we can generate a did for you? So this is how we actually create the did or the decentralized Identifier that we'll be using throughout the web native program. So click sign and here is that same message, just hashed in basics, deploy, encoded.
00:11:13.230 - 00:11:41.730, Speaker C: So we'll sign that. And so there's some things happening in the background here that I'll kind of talk through, but essentially we're registering the user within web native itself and the next thing that's going to happen is bear with me, I think my screen share is slowing things down here. Of course, it wouldn't be a demo if everything went smoothly.
00:11:41.730 - 00:11:55.116, Speaker C: Let me just give this a quick refresh. Interesting. There we go.
00:11:55.116 - 00:12:05.664, Speaker C: Okay, it took a while. Yeah. So essentially after your web native file system is mounted to your user, or for your user actually before in this case, we need to decrypt this message.
00:12:05.664 - 00:12:30.376, Speaker C: So this is using the decrypt JSON RPC method that I believe Ryan mentioned, currently only supported by MetaMask the browser extension, not even the mobile version. So what we're decrypting here is essentially the user's read key stored in their web native file system, which gives them access to all the child nodes within the crypt tree. So let's decrypt that and that will give me access to the rest of the application.
00:12:30.376 - 00:12:41.790, Speaker C: Here we go. So here, this user does exist already, but the wallet wasn't connected to the SAP before, which is why I went through those steps. If you're already connected and you refresh, you just have to decrypt the message.
00:12:41.790 - 00:12:48.568, Speaker C: So here, let me just click on my photo gallery. Yeah. So these are all my public photos that I've already uploaded to web native.
00:12:48.568 - 00:12:55.116, Speaker C: This is just a drag and drop interface. You can pop these open and check them out. This could easily be configured to work with any type of files.
00:12:55.116 - 00:13:02.900, Speaker C: We just have it constrained to various image mime types right now. And then if we wanted to go to my private files.
00:13:04.760 - 00:13:05.476, Speaker B: Bear with me.
00:13:05.498 - 00:13:25.622, Speaker C: My Internet is having a bit of a hard time. Okay, we will give that a minute. Anyway, so let's pop open a public image here.
00:13:25.622 - 00:13:39.046, Speaker C: So here when you pop this open, you'll see you have this view on IPFS option. So as you can see, you have your actual IPFS URL here. This specifically is using the fission gateway, but you can do this on any IPFS gateway.
00:13:39.046 - 00:13:53.710, Speaker C: And what we've done here is basically taken the user's wallet address, hashed it, and that's now the actual pointer to their file system here for their public files. If we go back to the app and pop open the private photos.
00:13:57.730 - 00:13:58.434, Speaker B: Bear with me.
00:13:58.472 - 00:14:21.336, Speaker C: I don't know why things are so slow right now. Okay, well, regardless, anyway, so if we were to open up a private folder here, it would basically have a disclaimer saying it would still have the link to view it on IPFS. But we'd have a disclaimer saying that due to IPFS not being able to actually decrypt this file, you won't be able to view it.
00:14:21.336 - 00:14:33.372, Speaker C: So you'll basically just see a broken string, which is as expected. If you're going to use this for an actual application, you could obviously remove that. Yeah, so there are a few things kind of happening under the hood here.
00:14:33.372 - 00:14:52.210, Speaker C: So we're using two JSON RPC methods. One is get encryption public key and one is e decrypt. As I mentioned already, e decrypt is basically used before loading the user's file system before loading the existing file system to decrypt the user's read key to access their whole file system, which is stored in their web native file system.
00:14:52.210 - 00:15:11.050, Speaker C: And then ETH get encryption public key is actually called before loading a new file system. So if I were to log in with a new user, we would get the encryption key from MetaMask and we would use that to encrypt the user's read key and then store it in the file system. And then the before load existing decrypt method would be used to read that key.
00:15:11.050 - 00:15:49.168, Speaker C: And I believe Ryan might have also mentioned that these methods are being deprecated. So currently there's a bit of a security concern because those two methods basically use the same key for both signing and encryption, which presents a few potential security attack vectors that people aren't particularly happy about in the ecosystem. So that's why we're actually part of an alliance called the Chain Agnostic Standard Alliance or Casa, where we're trying to work forward to get some alignment on encryption and decryption methods that work both cross chain so for any chain, really, and that actually use separate keys for both signing and encryption.
00:15:49.168 - 00:16:06.248, Speaker C: So we're working with people from Brave signing with Ethereum, Wallet Connect, Palo, and a bunch of different people to basically try to push a standard for it that really works for everyone. So we're hoping to get to that point pretty soon. And yeah, it looks like my demo just froze.
00:16:06.248 - 00:16:10.776, Speaker C: Of course, with that being said, I will pass it back to Ryan.
00:16:10.888 - 00:16:24.730, Speaker B: Thanks. Thanks, Andy. Let me just get my screen sharing going again.
00:16:24.730 - 00:16:51.930, Speaker B: Okie doke. So, yeah, some caveats to know, Andy stated this clearly, but this wallet auth flow only works in the MetaMask browser extension for now. We wouldn't recommend it for production apps yet.
00:16:51.930 - 00:17:46.830, Speaker B: That said, as I mentioned, the WebCrypto API auth strategy, the one that's very stable right now, you can, of course, also use that to integrate into filecoin. Our belief is just that when Wallet Auth is ready, it'll provide a much better account recovery and account connection flow across various devices because your backup and recovery will basically be delegated to whatever best practice you use for yourself with your EVM compatible key pair. So on filecoin Ethereum and someone was asking in the comments, do we intend to support layer twos and any other AVM compatible chain? And the answer is wholly yes.
00:17:46.830 - 00:18:16.672, Speaker B: Really, the only thing preventing us from doing so right now is the adoption of an encryption decryption standard by specific Wallet clients. So a couple more things to just go over. If you are indeed really interested in helping to push Wallet UX forward either within Wallet clients or on the DAP side of things, I would love to talk to you first and foremost.
00:18:16.672 - 00:18:43.624, Speaker B: But then, as Andy mentioned, there's some really bright minds involved in Casa, the chain of Gastric Standards Alliance. So you have people participating there from Wallet Connect and MetaMask and Brave and many other organizations, spruce, et cetera, and more voices are always highly welcome there. There's active discord and multiple meetings per week to dig into this stuff deeper.
00:18:43.624 - 00:19:12.120, Speaker B: Spruce ID has a couple of standards that they've put forward in the Ethereum ecosystem CWAY, which stands for Sign In with Ethereum and Recap. Both of these are looking to improve the informed consent practices for authorization and sign in requests. So these are standard message formats for signing into an app and then also for granting that app authorization to do certain things with certain resources.
00:19:12.120 - 00:19:32.376, Speaker B: And this would help us work towards more of like an iOS and Android style. Very accessible and legible set of flows for making sure people are only letting DApps do what they think they should do and they understand it clearly. Wallet.
00:19:32.376 - 00:19:47.570, Speaker B: Connect and filecoin. It'd be great to get these things working together, open a PR, take a look at what's going on in that ecosystem. And if you're going to be at ETH Denver, sign up for Walletcon because I think it'd be great to see some filecoin representation there.
00:19:47.570 - 00:20:10.760, Speaker B: The encryption decryption standard is forming under 56 30 right now if you want to dig into that. Unrelated to anything we've mentioned yet today. But two other things that I think are very fascinating to follow are account abstraction, which is happening under EEP 4337 and I think within the filecoin Fit 55.
00:20:10.760 - 00:20:59.844, Speaker B: And then finally EEP 5003 Auth Usurp, which is a provocative standard for how we might take existing EOAS and convert them into contract accounts without having anybody need to pay exorbitant gas fees to transfer all their assets and then move to a different public key. So what could you build, given what we've shown you today? Some real quick ideas, far from an exhaustive list, but persistent place to stage files for a user before they commit it to the filecoin network easily syncing private state across devices with no back end. I don't know if anybody's ever been collecting some favorites of ENS domains.
00:20:59.844 - 00:21:32.432, Speaker B: They might register on one device and then end up switching to a new device and realizing, oh shoot, these are trapped on one device. So with web native you should be able to sync that state privately across both. If you're on a Wallet client team, I really would encourage you to look into these encryption decryption standards and what they could unlock and voice your opinion on what you think and special presentation of the CWE and recap message formats.
00:21:32.432 - 00:22:00.536, Speaker B: I think it'll be great at some point when Wallet client teams adopt a dedicated UX for messages that follow these conventions. And then one little plug from Fission if you're really interested in this far future stuff, which I know a lot of people within the Protocol Labs network and Filecoin have a real explorer mindset. We're gathering some bright minds in Toronto for an event we're hosting at the end of April called Causal Islands.
00:22:00.536 - 00:22:09.852, Speaker B: Causalis.com is where you can find more about that. And with that, thank you very much and good luck.
00:22:09.852 - 00:22:15.250, Speaker B: And I think we've got some time for questions if anybody would like to ask them.
00:22:20.770 - 00:22:24.000, Speaker A: Feel free to come off mute if you want to ask your question live.
00:22:27.180 - 00:22:35.070, Speaker D: Ryan, regarding the web authentication that you mentioned, can you expand a little bit on that?
00:22:37.300 - 00:23:04.250, Speaker B: Sure, yeah. So one of the things that I think is an Achilles heel in the Web three space right now is account recovery, specifically like management of your private key. And so I think that there's tons of discussion about this, what to do.
00:23:04.250 - 00:23:39.292, Speaker B: No matter how much you attempt to educate people on how to do the right thing with a passphrase, they'll struggle. Even people who are well aware of the risks will still struggle to do the right thing and there's so many opportunities to really critically make a mistake along the way. Right? And so key management is something that Pass key itself is quite focused on.
00:23:39.292 - 00:24:31.252, Speaker B: And so Pass Key, in case nobody's familiar with it, is a because I'm a designer, I'm going to struggle to explain this with the most precise language. It's intended to replace passwords and it's being adopted at the operating system level and the browser level by Microsoft iOS, Android and one password, I think, unless password are also adopting it. And so what it is is it is a portable non exportable signing key that you can use to authenticate into an app.
00:24:31.252 - 00:25:20.420, Speaker B: And what this might mean for Wallets and for web native itself is that because these things are going to be very conveniently baked into people's workflows and normal folks should eventually be signing into all of their favorite websites using Passkeys. You should be able to then provision someone with a wallet via a Pass key or provision them with their private encrypted at rest web native file system using a pass key. And then now, however they're managing that, whether they're using like the built in iOS keychain or whether they're using one password, this is going to be available on all their devices.
00:25:20.420 - 00:25:49.672, Speaker B: So it's not really easily exportable to outside of their digital personhood, but it's very easily portable across all the different devices they use without putting them at risk of divulging this secret accidentally. So that should provide for a certain threat model, should provide a really interesting and very usable approach to a highly secure account mechanism.
00:25:49.816 - 00:26:11.248, Speaker D: I hope that explains yeah, I dabbled into that a year ago. It works pretty well. But the only stuff is that the current set of mobile devices and hierarchies only have three to five six keys or signatures.
00:26:11.248 - 00:26:29.610, Speaker D: So the idea will be to find out to somehow see if there's possibility to migrate or interior with the SEC P two K 56 keys because otherwise it should be like some different signatures than the common ones.
00:26:30.860 - 00:27:08.048, Speaker B: Yeah, and I think this is where actually account abstraction can play a really interesting role, at least when you're talking about doing this in an environment where authentication is kind of mediated via a blockchain, I think it is on Argent or one of the layer twos that has adopted EEP 43 37. There's a site called Cartridge GG.
00:27:08.224 - 00:27:09.156, Speaker C: And I think if you go to.
00:27:09.178 - 00:27:38.944, Speaker B: Cartridge GG, create or register, you'll see a flow where behind the scenes you're using a pass key, but it's provisioning you contract based account. And this is because I guess you can just have novel encryption key curves supported by contract accounts. So maybe there's something in there where we can make that work.
00:27:38.944 - 00:27:57.030, Speaker B: But yeah, as you mentioned, for now, with some of the browsers, there is limited support for things that for supporting pass keys integrated with the WebCrypto API. But we're hoping to crack that nut soon.
00:27:57.800 - 00:27:59.350, Speaker D: All right, thank you.
00:28:08.250 - 00:28:39.300, Speaker A: Does anyone have any other questions? All right, I guess if that's all the questions for now, we can end this workshop here. Ryan and Andy, thank you so much again for taking the time to do this workshop for this hackathon. For the rest of you, this workshop is also available on YouTube, so feel free to go back to it and use it as a resource for your hack and in the future.
00:28:39.300 - 00:28:47.258, Speaker A: And with that being said, I hope everyone has a great rest of your day. We have another workshop today in half an hour, so I hope to see.
00:28:47.264 - 00:28:49.030, Speaker B: You all there as well. Bye.
