00:00:06.090 - 00:00:13.040, Speaker A: Without further ado, I'd like to welcome our last speaker of the day, and that is Richard Moore talking about Ethers V six.
00:00:13.410 - 00:00:15.520, Speaker B: Hi, how goes?
00:00:15.970 - 00:00:17.886, Speaker A: Things are going great, how are you?
00:00:17.988 - 00:00:24.800, Speaker B: Excellent, excellent. Kind of just woke up, so ah.
00:00:25.370 - 00:00:29.634, Speaker A: That'S a very familiar exactly four clock.
00:00:29.682 - 00:00:31.000, Speaker B: So it makes sense.
00:00:32.090 - 00:00:43.850, Speaker A: All right, well, great having you, Rick. Let's talk about V six and see what things you can tell us without also committing to excellent.
00:00:45.150 - 00:00:47.130, Speaker B: Yes. Let me find the keynote.
00:00:48.270 - 00:00:50.570, Speaker A: Can you see that everything is great?
00:00:50.720 - 00:00:57.710, Speaker B: Okie dokie. And the little bar for zoom is covering the button. There we go.
00:00:57.710 - 00:01:05.620, Speaker B: Okie dokie. So I was kind of expecting more Q A at the end, so it might not be enough. So we'll figure that it would go along.
00:01:05.620 - 00:01:32.860, Speaker B: But for those that don't know, Ethers is like I don't know what the target audience is in terms of familiarity with Ethers, but it's just a library for interacting with Ethereum blockchain and that sort of thing. So V six is up and coming. I was hoping to have it out a while ago, but the beta is coming along and I've got a big release I was hoping to make by this talk, but it didn't quite get finished last night, hence waking up at four.
00:01:32.860 - 00:02:02.686, Speaker B: There we go. So yes, one of the biggest features of V four is I'm moving to modern ECMAScript or JavaScript features prior to like v five and before I only targeted features that were available in Es three. So it does mean that Ether's V five will probably work in Internet Explorer and browsers circa 2010, but that's becoming less and less important, especially for Ethereum.
00:02:02.686 - 00:02:23.530, Speaker B: And so moving to modern Es features gives us a lot of really cool abilities that JavaScript has added in the last five years. So one of the big ones that people seem to always want, and I am kind of looking forward to getting this out there is big INTs. Big INTs are now built into JavaScript.
00:02:23.530 - 00:02:44.894, Speaker B: I think it was like September 2000, that kind of the last holdout, which was Safari out of them. So everything should basically have access to Big INTs these days. There was a lot of issues, like before using big number, there was a lot of extra command, like extra code you needed because it was like mall this, add that.
00:02:44.894 - 00:03:05.286, Speaker B: You did instantiate big numbers from their static constructor before you do anything with them. So nice thing with Big INTs is they're built into JavaScript, they just work. You just add this little N to the end of your number and now you can have numbers that exceed the value that IEEE 75 four can support.
00:03:05.286 - 00:03:12.042, Speaker B: And it also means you can do other cool things. Like you can just multiply them together. There's no complicated things you need to worry about that way.
00:03:12.042 - 00:03:39.938, Speaker B: And you can just check them if they're equal to each other, use greater than, less than I mean that was a point of difficulty for a lot of people, especially when they're using test frameworks and they just want to see if this one value is greater than another and the existing frameworks just use inequality operators internally. So lots of cool things that way. One kind of downfall of big INTs I'm still trying to figure out the best way around is you can't JSON stringify them.
00:03:39.938 - 00:04:15.578, Speaker B: And so I do expect some people have issues where they have a value, they want a complicated structure, they want to jsonify and so there'll be a special function to help handle that sort of thing that's begint another really cool feature. Back in the day when I was using Python, this was just built into language es six proxies are freaking awesome. Basically it is an object that if you're familiar with JavaScript, if you have an object and you call a method on it and that method doesn't exist, it just fails.
00:04:15.578 - 00:04:52.540, Speaker B: The cool thing with the proxy is before that failure, it gives code a chance to determine do I want to do something or do I just want to fail? And so if you have object foo and you do foo bar, if bar doesn't have a value, it'll just fail. But a proxy will give the code a chance to say do you want to do anything with bar? And so in V Six, one of the big things we do with this is contracts. Because now contracts can take a property you're trying to access and kind of make it better educated guesses at what you're actually trying to do and find, for example, the method you want to call.
00:04:52.540 - 00:05:13.450, Speaker B: If you're familiar with V Five and you've got really complicated big APIs from third parties you probably also see, like 1000 warnings in your console log saying, like, duplicate API definitions. You have too many balance of you have too many owner OFS because each one of these had a different signature. Because solidity allows you to overload signatures.
00:05:13.450 - 00:05:44.220, Speaker B: So the cool thing is you only get those type of warnings now if you actually try using something that's ambiguous and that kind of leads into maybe it's a few slides ahead, I'll get to that in a second. But yes, basically it gets rid of all those errors that people have been receiving that were kind of required for Ethers to throw up at the beginning because it wouldn't know whether you would try using them or not package exports. That's actually why the latest version is a little bit behind.
00:05:44.220 - 00:06:12.290, Speaker B: I'm trying this out basically in prior versions of Ether V Five, it was a massive mono repo with 20 some OD subpackages and each subpackage is managed and has its own TS config and package JSON and all this crazy stuff. And it also meant that when you installed Ethers, some things would start getting out of sync and if you blew away a bunch of stuff but not everything. And then did an NPM install.
00:06:12.290 - 00:06:40.490, Speaker B: You start getting issues where versions of the library within Ethers, for example, Ethers project provider might not be compatible with the version of Ethers project contracts you have. And so then you get all these really crazy warnings and errors that make no sense because it's basically just the build system is completely lost. And so you had to delete the package JSON or the package, lock your yarn locks, all those crazy things, delete the node modules, then do a fresh NPM install.
00:06:40.490 - 00:06:48.746, Speaker B: And things just worked. But it was a lot of hassle. So now using the package exports, it's just everything is in one package, Ethers.
00:06:48.746 - 00:07:03.570, Speaker B: And if you do providers, it knows to pull in a specific set of files. And so the big advantage that this really helps is it makes tooling much simpler. Tools are just much happier now with a normal build process.
00:07:03.570 - 00:07:32.206, Speaker B: The original Ethers B five has a convoluted crazy build process to handle how TypeScript deals with composite packages plus how the bundler munges all these things together. Bundler and tool support is much better. The other cool thing with this Ethers provider thing is you still get all the great benefits of tree shaking because the exports kind of steers the bundlers and steers the toolings as to what file to look at.
00:07:32.206 - 00:07:55.734, Speaker B: And so because tree shaking really only works effectively on a per file level, these exports kind of guide the file processing part well. And basically publishing is much easier for me. Maintaining one package that I have to modify and not worry about having like 1000 SIM links for.
00:07:55.734 - 00:08:17.420, Speaker B: And then the SIM links sort of get unsynchronized over time for one reason or another or setting up a new machine anyways, it's just much easier. So I'm kind of belonging to my slides very quickly and I'm a little bit worried I'm going to be too fast. Hopefully Kartik is thinking up some good questions for me or keeping track of things.
00:08:17.420 - 00:08:31.310, Speaker B: Another big advantage of V five is the dependencies. I think V five had dependencies around nine or ten dependencies. With this we're down to five dependencies.
00:08:31.310 - 00:08:47.090, Speaker B: The WebSocket library is only necessary in node. I can't quite see all my slide, I think it was 60 million. But anyways, basically it's a very popular library that has a ton of downloads, so it's maintained.
00:08:47.090 - 00:09:12.490, Speaker B: I feel like an important thing people don't look at when they look about dependencies. It's not just how many absolute dependencies you have, it's kind of how many different authors and contributors you're depending on because of those dependencies and also the quality of the author. When you see these packages have very few downloads, I feel uncomfortable because it means that they're probably not worrying too much about the security.
00:09:12.490 - 00:09:38.006, Speaker B: And all it takes is one of your dependencies, dependencies, dependencies, dependencies to fail and all of a sudden the world is just lost and we've seen things like the Es Lint hack. I mean, there's always the possibility of supply chain hacks. So if we can reduce the number of people we have to rely on but also increase the quality of the people we rely on, we help protect ourselves from all these supply chain problems.
00:09:38.006 - 00:09:59.590, Speaker B: So TS Lib, for example, I mean, it's only included in V Six because it drastically reduces the size of the library to include all those little helper methods that TypeScript injects for you once. But again, Microsoft is a fairly big company. If they got compromised, they would suffer some sort of fallout and PR nightmare.
00:09:59.590 - 00:10:10.522, Speaker B: So they're heavily incentivized to keep all their security up and running. WS has a crazy number of downloads. It's only used in node.
00:10:10.522 - 00:10:17.026, Speaker B: I don't personally know the person. So that's my one kind of concern. Paul, though.
00:10:17.026 - 00:10:40.822, Speaker B: Paul Miller, the author of the Noble Classes? He's awesome. They're all audited and he's a big security guy as kind of I trust him more than I trust random other projects I've used in the past that maybe take a long time to get back to their non serious issues, that sort of thing. And then there's ethers.
00:10:40.822 - 00:10:58.590, Speaker B: If you're depending on Ethers, you're already depending on me being secure. And so my other library, Aesjs, which Ethers uses, is kind of in the same security threat model. So anyways, the goal is to kind of bring down dependencies, but also bring down the number of people that responsible for those dependencies.
00:10:58.590 - 00:11:14.974, Speaker B: That's kind of my take on that. Okay, now back onto more cool V Six things. So this goes back to the proxy thing I mentioned earlier, because the proxy can kind of decide at runtime we get all these cool abilities.
00:11:14.974 - 00:11:25.910, Speaker B: The next two slides will cover those. So, first of all, we have a typed contract interaction. Historically, if you saw this abi, as you can see there's two methods called foo.
00:11:25.910 - 00:11:51.680, Speaker B: Sorry, yes, as you can see, we have two methods called foo. So first of all, in V five, if you load this ABIF, you'll get warnings in your console saying duplicate definitions of foo, which makes sense, there are two of them. And so if you just did contract foo, as you can see in this first case, it doesn't know which one you actually meant to call because an address can also look like a number.
00:11:51.680 - 00:12:03.566, Speaker B: So in the first case, it would still fail, as it does in V five. But in V six we added the typed object. And so typed lets you kind of hint to the contract.
00:12:03.566 - 00:12:23.254, Speaker B: By the way, this sum adder parameter is actually an address. And now it's no longer ambiguous. It knows that if you're calling foo and the first value is something, but the second value has to be an address, then it can find the right foo to call and keyword contract interaction.
00:12:23.254 - 00:12:37.674, Speaker B: So this is something that I've just started adding so it's still very bleeding edge. But this is a feature that I've seen a few people ask for. They want to be able to basically call a contract method using the keyed arguments.
00:12:37.674 - 00:12:55.822, Speaker B: This is something you're probably familiar with, the Kw ARGs. If you're using Python, it can make code a little more readable in many situations. And so if you pass in one of these type keywords objects, it realizes that all the parameters are not being passed in positionally.
00:12:55.822 - 00:13:16.762, Speaker B: They're not being passed in based on the order of the parameters as they show up in the abi, but actually by their name. And so for example, in this example, you see I'm using from to and value, but the order doesn't really matter. If you wanted to, you could specify the two and the from and then the value.
00:13:16.762 - 00:13:42.690, Speaker B: You could imagine constructing these objects somewhere else. If this is available, throw that in and kind of like codifying or procedurally generating this stuff. And so this will also be useful for a lot of frameworks that need to kind of call functions in a constructive way based on other information they may be pulling from other places.
00:13:42.690 - 00:14:11.114, Speaker B: Is there anything else to say on that? So I think that's good for now, right? So another big thing that's changed in V six is how providers work. So not how they work from users points of view, but how they work internally. When V five came out, it was very heavily influenced by V four, which was heavily influenced by V three, and so on and so on.
00:14:11.114 - 00:14:22.560, Speaker B: So back in 2017, it was a very different landscape. Basically everyone only used HTP providers, socket providers were still kind of like a niche thing. WebSockets were expensive to run.
00:14:22.560 - 00:14:48.962, Speaker B: Now there's a much more it's much more common to use WebSockets, and even IPC, I don't think IPC is still that popular. But the thing is, once you support one, you might as well support both because they're both basically the same. So there's been a lot of work just to abstract and change the model so that internally they work better from a long lived socket connection.
00:14:48.962 - 00:15:19.394, Speaker B: So, for example, WebSockets as a result, one thing people always want with WebSockets is they want it that when there's a hiccup, when the connection drops, they want the WebSocket to reconnect and just continue on. Trucking it's actually quite difficult to do, especially in how V Five was structured, because you could imagine if you were streaming, if you were listening for some event and there was a hang up and you reconnect, you may have missed events during that time. You need to kind of know which was the last event you saw.
00:15:19.394 - 00:15:47.114, Speaker B: So you can kind of resubscribe to old events or pull for the old events and replay those, but you can't start emitting the new events till the old events are processed because you still want to keep things in order basically it's a consistency nightmare. So in V six there's been a change in how the overall model works so that these are all abstracted away. So each provider kind of gets to decide how it's going to process these.
00:15:47.114 - 00:16:13.326, Speaker B: And so the WebSocket provider has its own custom mojo thing going on so that it knows how to reconnect, restart and kind of keep all the events consistent. On that note crap, I've lost track of where I was going with that. Oh yes, pausing.
00:16:13.326 - 00:16:17.486, Speaker B: That was the other cool thing. I think that might actually be on another slide though. Maybe I'll save that for the next slide.
00:16:17.486 - 00:16:50.080, Speaker B: I think it's there great. Basically, by using Filter IDs we also gain a lot of abilities because now we can actually get orphaned events from even a polling connection. Some backends do not support Filter ID, but things like inferior do and so we can use those, which also helps some of the problems with talking to a large backend cluster of nodes, making sure that everything comes in consistently and in order.
00:16:50.080 - 00:17:13.142, Speaker B: Also, there's new plugins available so that for example, it's much easier if you're trying to build something on top of AWS which might want bare authentication tokens and generalized contract Runner type. This is a little bit of a I'll try giving a quick overview. Basically, a Contract Runner is something you pass into a contract to run it.
00:17:13.142 - 00:17:27.494, Speaker B: Historically in V five that's been either a provider, a signer or null. And depending what you pass in, kind of dictates what type of things you can use the contract for. By generalizing the Contract Runner, there's now a higher level interface that anything can implement.
00:17:27.494 - 00:17:51.666, Speaker B: It happens at provider implements this interface, it happens at signer, implants this interface. The cool thing is you can now build your own random weird things that also implement this interface, which gives you, for example, some really cool things you could do for mocking purposes if you wanted to build some sort. Of test contract runner that's going to feed fake data, but that's meaningful to the contract if it asks for it.
00:17:51.666 - 00:18:02.594, Speaker B: And it'll think it's just talking to something, speaking its language. Right, here's the pausing thing I was mentioning. So basically providers can now be paused.
00:18:02.594 - 00:18:35.662, Speaker B: You can pause, resume, restart them. And so this was kind of almost free because we needed this functionality for the purposes of being able to restart a WebSocket provider like the events on it and make sure everything comes back consistently. So this is an example where if your application goes in the background, if they click a different tab in the browser, you might as well turn off all of the providers that are running events and triggering things and updating the UI, because you're a using bandwidth.
00:18:35.662 - 00:18:46.930, Speaker B: You're paying for those inferior requests or Alchemy, or Anchor or even like just contacting your own server to do things. You're paying for that infrastructure. You might as well pause it when you're not being used.
00:18:46.930 - 00:19:04.426, Speaker B: Maybe they close the tab later and then anything you were updating wouldn't have mattered anyways. Or when they come back later. You can then decide, do I want to continue replaying all the events that happened while my tablet is gone? Do I want to just replay the last ten minutes to catch up my UI so it looks nice, or just elliptic state.
00:19:04.426 - 00:19:23.406, Speaker B: So I think this will help a lot of people as well. It makes it nice and easy to pause a provider network plugins. So another big issue with Ethers is some people want to use Ethers on networks, chains that are kind of insane.
00:19:23.406 - 00:19:45.814, Speaker B: They just break the rules in ways that made either no sense for them to break or in ways that, from my perspective as a Ethereum semi maximalist didn't really think was a great idea. But I also don't want to preclude those people from having access to Ethers. I don't want them building their whole own other library that maybe has other problems in general.
00:19:45.814 - 00:19:59.420, Speaker B: It's just nice if we all work together. And that way anything they build on top of Ethers, other Ethereum people can use as well. And so network plugins kind of allow weird networks to be weird and just treat it as that's an okay thing to be.
00:19:59.420 - 00:20:12.158, Speaker B: So for example, so some examples I will give of this are cross chain ENS support. ENS actually supports any chain, any chain in the universe you want. ENS supports it.
00:20:12.158 - 00:20:33.298, Speaker B: The problem is you need an Ethereum connection for that, for a lot of networks. So for example, if you are on finance smart chain and you want to get a binance smart chain address, you need some way to talk to l One Ethereum to ask for that. So this just kind of provides a way for networks to figure out how to connect to and talk to l One chains.
00:20:33.298 - 00:20:42.970, Speaker B: Different chains have their own way of computing intrinsic gas costs. That's not really that interesting for most people. That's just something kind of used internally by contracts when they're trying to estimate gas.
00:20:42.970 - 00:21:13.326, Speaker B: So, for example, in terms of VIP 1559 priority fees, the Mumbai what's that one? Polygon. The polygon peeps kind of chose weird values for those. And it causes a lot of confusion when people use Ethers because the way they use the AP 1559 is not really the way that 1559 was intended to be used and it's certainly not the way it works on Ethereum.
00:21:13.326 - 00:21:36.406, Speaker B: And so this allows people to build and just kind of attach a little plug into their network saying by the way, when doing gas estimation, use this other criteria to kind of like munge the values. It also lets you add or add extra fields or missing fields to the transaction. There are some chains that actually compute transaction hashes completely differently.
00:21:36.406 - 00:22:01.906, Speaker B: This makes it nice and easy for them to kind of shim that in there without having to have their own complete instance of every provider under the sun. And it also allows you having custom URLs, because in general, I try keeping Ethers quite lean, which means focusing on kind of the main chains people use. But for example, Etherscan does have a Binance smart chain API, and so this means that the Network object can now encode that.
00:22:01.906 - 00:22:18.810, Speaker B: So that if anybody wants to use binance smart chain with Ethers, they just need that one network object, and once they pass it into a provider, the provider knows all those weird exceptions. Excellent. And I think I made it through, and I guess I took longer than I thought I might.
00:22:18.810 - 00:22:25.980, Speaker B: But yes, that's V six in a nutshell, from what I could throw slides together in the last few days for.
00:22:28.190 - 00:22:51.380, Speaker A: That was still great. All right, so I have a few questions, but they're largely meta questions because you were very concise and articulate on what you're trying to do, and it's very easy to understand what this does and why you're doing it. I think maybe kind of just let's start with the more obvious one.
00:22:51.380 - 00:22:59.638, Speaker A: Obviously didn't get deployed today, but what's the timeline on? Yeah, when should we see V six coming out?
00:22:59.724 - 00:23:08.950, Speaker B: So there is already V six beta. It's been up for a few months now. So if anybody wants to use it, just NPM install Ethers at V six beta.
00:23:08.950 - 00:23:21.120, Speaker B: The exports stuff is kind of new. I just found out kind of that it was widely supported by most of the tools I need this week, so I started porting everything over to use that.
00:23:23.890 - 00:23:29.422, Speaker A: Sorry. I ended up disabling the screen share in case anyone else you're more than welcome to.
00:23:29.556 - 00:23:35.440, Speaker B: Oh, there we are. Okay. I thought maybe my device had hung up on you.
00:23:35.440 - 00:23:42.114, Speaker B: Great. So I only discovered like, this week that it's widely supported. So I've been kind of, like, adding that.
00:23:42.114 - 00:23:52.502, Speaker B: So that was what I was hoping it out today. It didn't quite happen, but hopefully this weekend people will be able to start using the new version that has the package exports. But yes, it's already available.
00:23:52.502 - 00:24:03.770, Speaker B: It's on GitHub. If you go to GitHub and look at the branches, there's a branch called V six beta. And the new one that will be coming will be v six beta exports.
00:24:03.770 - 00:24:16.080, Speaker B: That's the one that will include the exports instead of the crazy monorepo. The monorepo still isn't completely off the table. I'm just hoping it is because the export is so much more useful and so much easier to develop against.
00:24:16.690 - 00:24:41.346, Speaker A: Tree shaking is way nicer. Okay, so other set of questions, broadly kind of speaking, and these are kind of mostly matter questions, but I like that the inference piece. I like how you're trying to conform Es six to Python or just Plug, actually, maybe one.
00:24:41.346 - 00:24:55.900, Speaker A: Yeah, so I like the network plugin architecture sounds really, actually extensible and it's how you get it to apply to other EVM chains. Is it just specifically for network plugins or is it overall just a hook system that you were talking about but you just referred to the network plugins as the example.
00:24:56.270 - 00:25:04.926, Speaker B: So there's two places I kind of put plugins. One was in the provider, one was in the network. It is mostly just to handle kind of exceptional cases for now.
00:25:04.926 - 00:25:35.350, Speaker B: They are hooks things and I mean, once people have hooks, they'll use them in weird and crazy ways and it'll be awesome and I'm looking forward to that. But the main purpose that I'm putting them in for is just kind of like for headache reduction when people have some weird network and they're like, this thing's not working for me and I have to give them this big workaround or they have to re implement this whole thing. It'll be easier if I can just say just hijack this hook on the network or add this hook on this network and then the provider will kind of know what you will need to do.
00:25:35.350 - 00:26:11.186, Speaker B: The other thing is it's also extensible that if one of these weird networks comes along and has something that I don't support, it doesn't need to change the API for the provider because I can basically add the special logic into the provider necessary. They can add the plugin onto the network and then when the provider is running, it can ask the network for this new plugin that didn't exist before and kind of go from there. So it just means that I can stop changing interfaces like the signatures for methods because someone has some new thing.
00:26:11.186 - 00:26:23.574, Speaker B: Like historically I haven't been able to I don't backwards breaking changes. So they say I want to do this thing and I'm just like, I'm sorry, but there's nothing I can do about it because it'll break. There's almost a million downloads a week now of this thing.
00:26:23.574 - 00:26:33.418, Speaker B: It's going to break a ton of people if I just make this weird change for you. So it gives me the ability to still make weird changes for people who need weird changes without hurting everyone else.
00:26:33.584 - 00:26:50.560, Speaker A: That's amazing. Onto the meta questions. How do you decide when something is ready for release and which features should be part of a major version upgrade versus like a minor or testing? What's kind of been the design or philosophy behind this thing? Because V Six has been in the works for quite some time.
00:26:50.560 - 00:26:54.080, Speaker A: How do you get to a new version exactly?
00:26:55.810 - 00:27:09.602, Speaker B: It's very much an art. I think it was eight months into V Five when I first told some people like, oh, I've got some really cool ideas I want to do for V Six, here's what I'm going to do. And everyone was like, eight months? It's too soon.
00:27:09.602 - 00:27:23.420, Speaker B: And so I just kind of started wrapping more and more ideas in until eventually it got away from me. And then it was like it was no longer something I could complete in a short period of time. And so that's why it's what, like two years later since V Five has come out.
00:27:23.420 - 00:27:36.666, Speaker B: So I think in the future I'm going to be a little more aggressive trying to release more frequently in terms of major versions. In terms of minor versions. Minor versions are required anytime that you're breaking kind of forwards.
00:27:36.666 - 00:27:57.918, Speaker B: Compatibility and patches are just nothing bad is changing, but it's not an easy thing to do, even trying to figure out what features to include. So, for example, if I was willing to wait another six months because right now there's still a bunch of craziness involved for fetch. Fetch is in the browser.
00:27:57.918 - 00:28:18.438, Speaker B: Fetch happens to now be in Node 18. If I decided to cut Node 14 and node 16 out, all of a sudden my life become much easier. Or if I waited six months for Node 18 to kind of but the thing is, it's like buying a new computer, right? Like, my dad's been trying to buy this new computer and he keeps every time he has enough money to buy a new one, he's like, but if I wait another three months, it's going to be so much better.
00:28:18.438 - 00:28:23.630, Speaker B: But you have to kind of find that happy balance between the Pragmatic side.
00:28:23.700 - 00:28:32.558, Speaker A: And the well, your core principle is like preserving backwards compatibility. Then I feel like you have to kind of deal with the polyfills for quite some time.
00:28:32.724 - 00:28:38.514, Speaker B: Exactly. And for me, backwards compatibility is an important feature. And this is something that a lot of people do not really get.
00:28:38.514 - 00:28:57.270, Speaker B: And they're like, well, why don't you just do this? Why don't you just drop support for that? I'm the maintainer of so many legacy iPhone apps and these sorts of things. When these things drop compatibility, it breaks. It's just a week of my life that disappears now because somebody dropped support for one little thing.
00:28:57.270 - 00:29:05.398, Speaker B: And that little thing was used by some other little thing I used. And like I said, it's turtles all the way down. The dependency tree goes right down to the floor.
00:29:05.398 - 00:29:09.610, Speaker B: That bottomist dependency is borked. And now you're borked.
00:29:11.330 - 00:29:22.922, Speaker A: I hope that the WebSocket library is not using left pad. All right, so two more questions. One is granted.
00:29:22.922 - 00:29:53.114, Speaker A: Obviously so much of I would say Web Three infra right now relies on Ethers. How do you kind of look at how people are using the library or how people are using other abstractions that use the library? Just kind of we just talked about log me just before this and kind of see how it's being implemented versus what you think you can help simplify and abstract for others. Do you kind of care about that? How often do you actually do these things and how often those decisions end up influencing future features and sort of what's the process like there.
00:29:53.114 - 00:29:55.660, Speaker A: And then I'll close off with a simpler question.
00:29:56.510 - 00:30:01.130, Speaker B: Cool. I absolutely love other things using it. It's really cool.
00:30:01.130 - 00:30:25.954, Speaker B: I just saw the last few minutes of the Wog Me thing and I was really impressed by the way it was able to detect errors. And I was just like, man, I feel like it's really cool to see all these things built on top of Ethers that extend it, because it means that it's something I don't have to write. Because the reason I made Ethers in the first place is Ethers is I made Ethers for me.
00:30:25.954 - 00:30:42.742, Speaker B: Even today Ethers is largely for me. It just happens that I make it available for other people as well. And so all these other things I see out there for it are awesome because it now means that I have this extra ability using my own library that going back, you can even imagine, like syntax highlighters.
00:30:42.742 - 00:30:55.406, Speaker B: Writing a syntax highlighter is boring and annoying. If somebody else out there wants to write them for me and let me use them, it's awesome. That's one of the big things as well.
00:30:55.406 - 00:31:01.662, Speaker B: I'm seeing. That's one of the reasons why I want things like the keyword. Exactly.
00:31:01.662 - 00:31:23.782, Speaker B: I basically want keywords to be available so people who are building frameworks can continue building frameworks that kind of expand and enhance the capabilities of Ethers. Because that way someday I can use those frameworks and save myself time and effort. And if it makes things more secure and better for them, why not? This is one of the things I find in common.
00:31:23.782 - 00:31:47.678, Speaker B: When you build nice abstract libraries, you'll often find a feature you add that increases abstraction. It makes it easier for frameworks to interact with your stuff. Makes it easier for you when you need to interact with your stuff sometime, because you often do have these very abstract, high level ways you end up needing to interact with things and having already abstracted them for the frameworks to make it easy for code to operate with.
00:31:47.678 - 00:31:52.078, Speaker B: It makes it easier for you to write your own code that operates with it. If that makes sense.
00:31:52.244 - 00:32:11.880, Speaker A: Yeah, I think abstraction is also an art and you end up learning about kind of how in a way these things are codependent. So as long as that helps you anywhere from improve it to make your life easier in the future, it's a pretty good way to look at it. Final question.
00:32:11.880 - 00:32:21.450, Speaker A: How do you usually collaborate with open source contributions on the project? And if somebody wants to get involved, how can they contribute to Ethers?
00:32:22.990 - 00:32:28.006, Speaker B: I wasn't sure if you first heard the question is that with external partners or external contributions?
00:32:28.038 - 00:32:36.622, Speaker A: So just on the GitHub, when you are complaining or suggesting or submitting pull requests, what's kind of the process and how can they get more involved if they would like to?
00:32:36.756 - 00:32:50.978, Speaker B: Absolutely. So generally I prefer I mean, some of the things I'm trying to change with the V six. I'm trying to be less megalomanial but I've historically been very tight with my code and I don't like other people just modifying it.
00:32:50.978 - 00:33:04.070, Speaker B: So there's definitely PRS. I appreciate the PR concisely shows the problem, but I still usually make those changes myself. There are weird attack vectors from just merging PRS so I merge them manually.
00:33:04.070 - 00:33:08.554, Speaker B: There's actually. Git poop. I should give them a shout out as well.
00:33:08.554 - 00:33:30.446, Speaker B: I'll be announcing they've integrated with Ethers because Ethers has its own process, because Ethers doesn't really merge PRS. The PRS I examine and I merge manually. But now I've got a script that runs and anyone who has been tagged in one of my commits for either a PR or an issue, I really love issues as well.
00:33:30.446 - 00:33:46.434, Speaker B: If someone wants to open an issue and say, rather than building a PR, because a PR is actually quite a bit of effort. But if you've identified the problem, it's like, oh, in line 37 of this thing, it's a plus or it's a less than or equal to, which should be just less than. Just a quick example of that sort of thing.
00:33:46.434 - 00:34:01.506, Speaker B: It's something that I can change very quickly and easily and then push the fix out for. And I tag all my commits with issue numbers and that sort of thing. So the cool thing is the script now just picks up the fact that you reported a bug.
00:34:01.506 - 00:34:22.800, Speaker B: You don't have to fix the bug, you just have to report the bug if you reported it and it gets tagged. So don't just report bugs because if you just open up and report a bunch of scam, it's not going to count. It's only for ones that actually get tagged as solving something, but they get added to the contributors file and the contributors file has a JSON equivalent which is then fed to Git Poop and they can use that to issue.
00:34:22.800 - 00:34:30.530, Speaker B: I also call it pop. I don't know how to pronounce the thing. The POAP.
00:34:30.950 - 00:34:32.594, Speaker A: I say POAP too.
00:34:32.792 - 00:34:37.874, Speaker B: Yeah, exactly. So there we go. So, yeah, it'll issue you a POAP basically, yeah.
00:34:37.874 - 00:34:42.918, Speaker B: I mean I'm always open for. If you have a question, please use discussions. If you have an idea.
00:34:42.918 - 00:34:53.830, Speaker B: Discussions also has an ideas thing. If there's an enhancement you can jump right to that. But usually I'd recommend starting a discussion on GitHub about a new idea before jumping to the enhancement.
00:34:53.830 - 00:35:05.630, Speaker B: But basically I do everything through GitHub. Everything is an issue, everything is a discussion or PR. I also listen to Twitter if people want to tweet out to me it's at Rick Moo.
00:35:05.630 - 00:35:41.080, Speaker B: I do keep in mind there's definitely climate issue things we have to worry about. So I do keep a complete synced copy of all of my GitHub discussions, issues, et cetera, et cetera, locally, so that if there ever is like a tornado cache like event against Ethers for whatever reason, then I have some way to at least mirror a lot of that data. But for now, basically, everything goes through GitHub, and any aspect of decentralization happens on my side on a private clone of all that data.
00:35:41.080 - 00:35:42.486, Speaker B: Awesome.
00:35:42.668 - 00:35:49.240, Speaker A: That was great. Well, thank you so much and can't wait for V Six to come out very soon.
00:35:49.610 - 00:35:51.050, Speaker B: Excellent, excellent. Thanks, Alex.
