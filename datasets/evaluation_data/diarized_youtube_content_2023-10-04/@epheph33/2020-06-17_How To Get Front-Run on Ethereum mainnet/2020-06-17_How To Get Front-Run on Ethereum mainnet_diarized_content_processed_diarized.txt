00:00:00.410 - 00:00:54.800, Speaker A: Hello, my name is Scott Bigelow and I'd like to talk to you today about front running in Ethereum. And specifically, I'd like to show you what it's like to be a victim of being frontrun. I've been working in the Ethereum ecosystem since about 2017 and in the last year I've started working fulltime as a solidity auditor and I'm currently working with the Ethereum Foundation providing free quick checks for well known security issues to projects that are deploying on Ethereum. Now this offering of free security checks is called Spot Check. And if you have an Ethereum project that is nearing mainnet released, my information is listed on the slide. You can reach out to me via email or I'll have some more contact information in the video description. And while providing this feedback to projects, there's been a couple of front running based issues that I found and reported and the project developers ended up fixing these issues.
00:00:54.800 - 00:02:01.822, Speaker A: But in the conversations around them, I always got the sense that there was a hint of disbelief that what we were talking about was a bit theoretical in nature and that it wasn't until the project had many, many users and thousands of ETH stored in it that front running would ever become a serious issue. And what I would like to demonstrate today is that front running is an issue that impacts all projects of all sizes and nobody is safe because of a lot of the software out there being very intelligent about the way that it operates. It doesn't even need to understand that much about the way that your system works to exploit it. So in this talk, I'd like to talk a bit about what front running is and then we're going to just jump into writing and deploying a simple contract from Remix. We're going to seed this contract with a small amount of ETH and we're going to actually get front run. We are going to waste a little bit of ETH for what I hope is a valuable or at least entertaining learning experience. So what is front running? One of the answers I have for this revolves around CryptoKitties.
00:02:01.822 - 00:02:37.818, Speaker A: This is a project started back in, I think, right around 2017. And it's a project that allows you to have these non fungible tokens that represent these CryptoKitties and they have these genetics in them. And that's not really an important part for this. But what is important is the birthing process. The process by which somebody takes two CryptoKitties that they own or have access to and submits a transaction to the blockchain that says, hey, I would like to take these two kitties and I want to make a new one out of their attributes. And this is an onchain process that takes these attributes and merges them into a new one. But this process isn't instantaneous.
00:02:37.818 - 00:03:32.622, Speaker A: This process has a cooldown and actually requires two different transactions, one transaction here to signal the intent of the owner to create a new kitty from these two, some period of time has to elapse. This could be minutes, this could be hours or even days. And then finally, on the other side, a kitty pops out. But there needs to be a transaction right here, right? Nothing happens on Ethereum without a transaction. And this is actually a time sensitive one where after the kitty is eligible to be born and it needs about an hour after that to be born or else the process kind of falls apart. There's an element of randomness in its creation and that randomness is only available for about an hour. And so if you were interested in birthing CryptoKitties because there is a small amount of ETH to be gained in doing so, let's walk through that process.
00:03:32.622 - 00:04:18.414, Speaker A: Let's say that you decide that you want to be the person who sends this transaction. That actually takes somebody else's intent to create a CryptoKitty and actually makes one. So this is the CryptoKitties contract and this is you. And you're having a great day and you're looking for a new Ethereum project and you thought you'd make a little bit of ETH on the side. So you fire up your development environment and you figure out how to comb through the CryptoKitties event logs to figure out when CryptoKitties are ready to be born. And your software sits there and waits for the right moment and finally fires transactions when the time is just right. And so let's say that some time has elapsed, the software works and it decides that kitty number 72 is ready to be born now.
00:04:18.414 - 00:05:02.880, Speaker A: And it goes ahead and fords along some fairly significant amount of gas to accomplish this birthing process. And the CryptoKitty contract verifies that this is indeed like when this kitty was born. And this is an active kitty and nobody's tried to birth it before and it sends the reward back to the user. Currently, this reward is zero point 16 ETH and it utilizes the gas provided in this transaction to birth this new CryptoKitty. And the user is pretty happy about this because depending on the gas prices that are active at that moment, they could end up with a decent little profit here. The problem, however, is that this isn't the only person on Ethereum. There's somebody else.
00:05:02.880 - 00:05:27.902, Speaker A: And this person has wrote a different bit of software. And this software doesn't really know anything about CryptoKitties. It doesn't know anything about cat genetics. It knows nothing. But what it does know about is the Ethereum pending queue. Because when this person calls this birthing function on the CryptoKitties contract, this isn't an instantaneous process. This is a transaction that is submitted to a pending queue.
00:05:27.902 - 00:06:19.270, Speaker A: And it could be sitting in this pending queue for a few seconds. It could be there for a minute or two. Even if you pick a fairly competitive gas price, it could still take some non trivial amount of time before this pending transaction becomes confirmed by the Ethereum network. And during that time, this transaction is available to everyone. And some software trolls through these transactions, looking at each one of them to see that if they instead run this transaction instead of the sender, if they would personally benefit from it. And so what it would do is come through and say, hey, you know what, if I were to do this birth kitty number 72 transaction instead of this person, I would be the one that receives this zero point 16th. It's able to emulate what would happen if they did this before it actually submits the transaction to the chain.
00:06:19.270 - 00:06:54.542, Speaker A: So they decide that it would be beneficial for them to do so. So they copy the entirety of this birth kitty 72 transaction with the destination, with the call data, everything. It doesn't even know what it's doing. All it knows is that if it does so, it is rewarded. So it sends this copied transaction with a slightly higher gas price. Here they selected eleven, here they selected ten. And in doing so, they're likely to end up in a block that is earlier in the blockchain, or if it even lands on the same block, higher in the transaction order.
00:06:54.542 - 00:07:50.434, Speaker A: And so by the time cryptokitty's contract processes this transaction, it will say, yeah, thank you, thank you for birthing this kitty number 72, here's your zero point 16th reward. And since that cat was already born by the time this transaction over here comes along, the one that actually did all the work to figure out when this kitty was ready to be born and submitting that first transaction, that becomes a fail, because only one kitty is going to be rewarded. You can't have two births of the same kitty. And so that makes this person really angry, of course, because not only have they missed out on this zero point 16 ETH, they did all of the work to figure out when this crypto kitty was ready to be born. And the reward for this is a negative 0.3 ETH if they were paying ten guay because even transactions that fail cost some amount of gas, it's not going to be that full 200. But it's also not nothing.
00:07:50.434 - 00:08:42.002, Speaker A: And also ten really isn't even the current gas price. We're currently looking at gas prices closer to 30, 40 or even 50 right now. So these losses can really accumulate. In the meantime, this person is benefiting significantly from somebody else's work. So let's go ahead and create a contract that is susceptible to the same style of front running and see if we can actually catch it happening in the wild. We're going to be using Remix, which is a solidity and I think they actually support Viper now. But it is an online Ethereum development environment that allows you to write Ethereum contract code in a fairly simple web interface deploy it to various either test or mainnet Ethereum blockchains and actually deploy it, interact with it, read values off of it.
00:08:42.002 - 00:09:23.070, Speaker A: It's a really useful tool. And so we're going to be creating a vulnerable contract inside of this inside of this environment. So let's go ahead and create a contract. And this contract is going to be called Frontrunme Sol. We're going to specify which version of Solidity we want to use and we're going to call this contract, of course, Front run Me. Now, the way this contract is going to work is that during construction we are going to pass in a Keshek 256 hash that only we know the answer to. We're going to have a value that when hashed spits out this value.
00:09:23.070 - 00:10:12.990, Speaker A: And so we're going to verify later that if you know this secret value will forward you all ETH that is stored in this contract. So we're going to have to store permanently this bytes 32 value. And we're going to call this secret hash. We're going to have a constructor which is going to take an argument of a secret hash and we're going to just go ahead and set it to storage value so we can specify this at deployment time and it'll just end up in this variable here. Also, I mentioned we want it to be seedingless with some small amount of ETH to incentivize front running. So we're going to make this constructor payable as we create the contract, we can actually forward value to it. The other function we want to create is just a take function.
00:10:12.990 - 00:11:15.330, Speaker A: So this is one where somebody can submit a I made a mistake here. This should be bytes 32. So anybody can submit a string of bytes. Actually, we'll make this a string just for ease of interaction and anybody can interact with it in this function. If the hash of the secret you pass in matches this hash, then we'll go ahead and send you all of the ETH that is available on this contract. So we'll say if the hash this is just a way to kind of convert a string into these bytes, if the hash of what you pass in equals the hash that we stored during construction, we'll go ahead and send you all the ETH message sender. So whoever called this, we'll go ahead and transfer you the balance.
00:11:15.330 - 00:11:33.354, Speaker A: Good. Let's go ahead and see if this thing compiles. Obviously, we have just a licensing warning here. Newer, solidities complain about this. It's not fatal, but it's nice to not have any warnings. Just in case the warnings do pop up, you don't ignore them. Great.
00:11:33.354 - 00:12:20.358, Speaker A: So here we have a contract that looks like it compiles. There's one more function I'd like to add and that is just I'd like to emit some logs on Success and Failure. So we have a success event and we have a Fail event. And if you are on the success path, we'll go ahead and emit the Success Event log and if you did not match this correctly, we'll go ahead and emit a fail. Great. So before we ship this to Ethereum Mainnet, let's go ahead and run this on a test Ethereum network and Remix provides one of these just built in right away in this JavaScript VM. Gives you a bunch of accounts that have like 100 ETH on them.
00:12:20.358 - 00:12:49.870, Speaker A: It all runs right in the browser. It's super convenient. But in order to do this, we're going to need to come up with this secret hash and this secret. So we kind of have this private public value. So here's an online hash generator and let's just start slapping some keys here, right? We're just typing in a bunch of random values. It doesn't really matter. All we need to make sure is that nobody else is likely to be able to guess that this is the value that hashes to this hash.
00:12:49.870 - 00:13:24.522, Speaker A: Someone's like to just grab stuff here just to make it look super random. So this is a pretty randomized string. And this value here actually, I'll just say value here just so it's really obvious what we're doing. So that becomes part of the actual string itself. We have this string here hashes to this value. So we're going to go ahead and copy the hash and we'll go ahead and say, Remember we made the constructor payable. We're going to go ahead and include one Ether and paste.
00:13:24.522 - 00:14:11.660, Speaker A: So this is the hash from that tab and we'll say, get rid of anything we had before deploy. So here we have a deployment of this front run me contract. If you look at the secret hash, it matches what we pasted in here. You'll also notice that we've been deducted one Ether from the value we typed in here. So we're sitting at about 99 Ether. If we just put in the wrong value here and say take, you'll see that we hit the fail event and we were not credited any ETH. Whereas if we go over here, copy the value that went into the creation of this hash and pass this value in instead, we get success.
00:14:11.660 - 00:14:47.046, Speaker A: And not only that, where we had about 99 ETH before, we have almost 100 ETH now back in the JavaScript VM. So this contract did actually send us back the ETH that we initially seeded it with. Okay, so let's go ahead and do the rest of this. Let's actually ship this thing to Ethereum Mainnet and let's watch ourselves get front run. Okay, so I have a real mainnet Ethereum account here and it's been seeded with a small amount of ETH. Yes. We have one ether on ethereum main net here.
00:14:47.046 - 00:15:07.760, Speaker A: And we have, what do we say? Zero point 35. That should be enough to incentivize front running. So again, we don't need to recompile. We can just go ahead and deploy the contract that we had before. We're going to use the exact same values we had before. This is that zero x 8710 x eight seven one. Great.
00:15:07.760 - 00:15:46.100, Speaker A: Let's go ahead and deploy this. Gas prices fairly high today, so let's do this. Should be good. Let me check real quick. That's a good value. So we're going to be confirming this transaction paying a decent amount in the deployment fee. All right, so it looks like that transaction was able to mine successfully.
00:15:46.100 - 00:16:41.176, Speaker A: We can see that transaction here. So there's that zero point 35 Ether that we seeded this transaction with. And now let's go ahead and try to using our secret that only we know pass in the value to actually withdraw Ether from this contract. Again, we can verify that that secret hash truly did get set in that storage location. And here is this take again, passed with the value that when hashed corresponds to the hash that was stored in the storage of that contract. Let's go ahead and we don't need to make this fast, right? Because we'll make sure that these other people have plenty of time to see this. But I very much doubt that's going to be a problem.
00:16:41.176 - 00:17:26.328, Speaker A: Let's go ahead and make this I don't know how about 33 33 guay. But in doing so, we're going to be publishing this contract to the pending queue and divulging this answer that at this moment, only we know, but everyone is about to know it. All right, we can see this data. This is the encoding of of that string. Let's go for it. All right, so now that we've sent this pending transaction into the wild, we can go ahead and take a look at it and we'll see that this transaction is indeed still pending. This is our source account.
00:17:26.328 - 00:18:05.076, Speaker A: This is the contract. And this is where we have specified the input that enables us to withdraw that zero point 35. We'll see that's still pending. However, if you go to the contract itself, you can see this contract has already been drained. Even though our attempt to drain it is still waiting to process. If we go ahead and look at our events that we added, which made it a little bit easier to spot when these withdrawals were happening, we can see that there was already, even without our transaction having landed three attempts to take this zero point 35 Ether from this contract. So let's go ahead and pop these ones open.
00:18:05.076 - 00:18:31.832, Speaker A: We have one, two, three. Let's see what happened here. So here we have the winner. Because there actually was a transfer here of zero point 35 Ether. We can see that this is not the contract address that we deployed, but they ended up calling their own contract, which called the one that we deployed via an internal transaction. We can also see the gas price they paid for. This was pretty hefty.
00:18:31.832 - 00:19:02.264, Speaker A: It was 122 guay. They ended up paying 0.1 in transaction fees in order to grab this zero point 35. Let's see the other transactions here. Okay, well, now we see why this person paid this 122 Guay. It's because they were outbidding someone else who was trying to front run our transaction as well. So we see this 44303.
00:19:02.264 - 00:19:28.208, Speaker A: Let's see if we can see it over here. 44305, right. So this person was outbid by two guay. They landed higher. So here we have these are all front runners, but even amongst themselves, they themselves are front running each other. So this person paid 122 guay, but they did not land properly. Even though they had the right answer, there was no Ether left to send.
00:19:28.208 - 00:19:47.856, Speaker A: And they ended up paying $0.60, even though they ended up with nothing in the end. And the last one is somebody who did call the contract directly. This is that contract's actual address. And again, they just failed. They submitted 43. And these all landed in the same block.
00:19:47.856 - 00:20:34.960, Speaker A: You see this? They landed in 128-12-8128. So they all landed, like, very shortly after that transaction hit the pending pool. But again, because of this gas price and the transaction ordering within that block, this one over here that paid just very slightly more than the other one was the one who ended up walking with this 00:35. And remember, this is the contract here, right? This is not a verified contract. This is not a contract that anybody has ever seen before. Nobody probably even understands well what it's actually doing. All they knew was that when they copied this transaction that I sent here that is still pending, they knew that when they copied what I was trying to do, they would end up receiving 00:35 ETH.
00:20:34.960 - 00:21:06.092, Speaker A: And so they took that opportunity. And this ETH has been effectively stolen from us. Yeah. So that's it. That's what I wanted to show you here today, is that front running on main net is a real thing that happens at fairly small values and with projects that these front runners don't even understand how they work. They look at these, like, black boxes that they can't extract value from. So, yeah, don't ever think that front running won't impact you because your project isn't well known yet.
00:21:06.092 - 00:21:40.050, Speaker A: It can happen when a project is as well known as these bytes that have that nobody's ever seen before with a hash that nobody has ever seen before. Um, so thanks. Let me know what you think of the video. Maybe the next video we can talk about ways that you can combat front running. Or I was considering talking a bit about how quickly divulging a private key on GitHub or accidentally, in various ways, end up with transactions that steal that Ether from you. So, yeah, let me know what you think. Let me know what you'd like to see next, and I'll talk to you later.
