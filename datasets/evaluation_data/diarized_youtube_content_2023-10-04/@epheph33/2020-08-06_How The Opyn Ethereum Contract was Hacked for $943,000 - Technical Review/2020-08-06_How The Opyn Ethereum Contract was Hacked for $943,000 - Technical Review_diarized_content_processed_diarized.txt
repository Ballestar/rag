00:00:00.330 - 00:00:13.150, Speaker A: Hello. My name is Scott Bigelow, and today I'd like to talk about an Ethereum attack that happened a couple days ago. On August 4, 2020, an application called Open was compromised for nearly $400,000 worth of USDC.
00:00:13.150 - 00:00:33.394, Speaker A: A million dollars worth of USDC was actually at risk, but a white hat hacker named Sam Sun got involved and helped steal the funds first in order to return them to their rightful owners. This video will be a quick but technical look into what happened under the hood. We're going to be exploring Ethereum transactions on the blockchain using Ether scan.
00:00:33.394 - 00:00:59.790, Speaker A: We're going to be reading solidity code and browsing GitHub history to see how an application which was audited by a reputable firm such as OpenZeppelin in this case, was able to ship code that had a bug in it. And for those of you who turn off a video after 30 seconds, the spoiler alert here is going to be that Open Zeppelin was not actually at fault. They reviewed a version of this code that was not what was actually deployed to the blockchain.
00:00:59.790 - 00:01:18.326, Speaker A: But first, let's quickly go over what Open is so we can talk more concretely about how this heist was pulled off. Open describes themselves as a decentralized insurance platform. And this is a pretty decent explanation if you come over here to their website, open.
00:01:18.326 - 00:01:53.166, Speaker A: Co this is the front end UI with a corresponding smart contracts on the ethereum mainnet blockchain that provide the actual DeFi logic that allows users to effectively buy and sell price movement protection to each other. And we're not going to be going through a tutorial of how to use the system, but very basically, the system allows you to deposit USDC into a vault. And when we talk about this vault, this is really the Open portion of the smart contracts is a system that holds onto your USDC.
00:01:53.166 - 00:02:07.698, Speaker A: But by depositing this USDC, it generates something called an O token. This oToken represents an option to exchange assets for this underlying USDC. So as a insurance provider, you deposit it, mint the O token.
00:02:07.698 - 00:02:27.210, Speaker A: You can sell the O token today, which gives someone else the future option to come along and exchange that asset for a predetermined price. There's many vaults that have different parameters. One of the exploited ones was an ETH put option for 330 USDC per ETH.
00:02:27.210 - 00:02:50.786, Speaker A: These vaults also have an expiration. So this O token only gives you the right to that exchange up until this point in time, at which point, if the oToken is not exercised, this insurance provider can just withdraw their USDC. Now, if the O token is exercised, this insurance provider simply withdraws the ETH instead, because somebody ended up providing the ETH in order to exercise that option.
00:02:50.786 - 00:03:02.722, Speaker A: So let's go through that workflow real quick. If you are somebody who ended up buying one of these O tokens, let's say that you wanted that price movement protection. You bought one on uniswap, you would come along with one O token and one ETH.
00:03:02.722 - 00:03:14.854, Speaker A: These numbers need to match. You would send them both to the vault. The vault would look up what its predetermined parameters are for how it should be storing this data, and it says, okay, well, thank you for these two assets.
00:03:14.854 - 00:03:25.210, Speaker A: I will go ahead and send you 330 USDC. There's no oracles involved. There's no check to make sure that this is a reasonable time to do it, so long as it is before expiration.
00:03:25.210 - 00:03:43.086, Speaker A: You show up with one side of the assets, you get the other one at a fixed price. Now, normally, people would not actually execute those options because this is a bad price. Based on today's prices for one ETH to turn into USDC on the open market, you could probably get closer to about 390 USDC per ETH.
00:03:43.086 - 00:04:16.830, Speaker A: But the open system doesn't actually check to make sure that the person who is performing this action isn't making a bad decision. So this system had been working for some months, and many people were buying and selling these assets and using the system pretty functionally until we started hearing some rumblings about an exploit that had occurred. And anybody who went and looked at the open contracts noticed that they had been very quickly drained of significant quantities of, in this case, USDC.
00:04:16.830 - 00:04:35.586, Speaker A: So there was a nice article here by Pexhield that came out maybe about a day after the attack occurred. This is a pretty good overview of what happened. It's very short, but very concise and drives at the heart of the issue.
00:04:35.586 - 00:04:52.854, Speaker A: What this article talks about is what we're going to be talking about in this video. So I'll leave a link here if you want to read a little bit more. But let's say that this article hadn't come out yet, and you're curious about how and why the open system was drained of this USDC.
00:04:52.854 - 00:05:09.246, Speaker A: How might you figure that out? Well, one thing you can do is just go look at the contract itself. This here is the open vault. No, the thing we had to circle around in that previous diagram, and one of the things we can do is look at the analytics here.
00:05:09.246 - 00:05:32.760, Speaker A: So if we look at the USDC holdings of this contract and then look at the analytics, we can see that this thing was getting USDC and getting more of it, more of it, more of it. We're talking about at this point, it has over $200,000 worth of USDC. And then you can't see that right there, but basically crashes down to nothing.
00:05:32.760 - 00:05:55.950, Speaker A: So I might come here and look and see, okay, well, how did that happen? How did we go from having so much USDC stored on this contract to having almost none? This token holder right here is the OETH vault contract. One of the things I like to do is look for patterns in token movement. Let's go back a little bit farther.
00:05:55.950 - 00:06:16.920, Speaker A: Okay, so here we see a bunch of transactions where USDC is moving in, right? We have like one transaction, USDC moves in. One transaction, you know, USDC moves in. Then we see over here, you know, USDC is moving in, moving in.
00:06:16.920 - 00:06:36.314, Speaker A: Let's now we're looking at a whole bunch of USDC moving out. And remember, this is a 330 USDC per ETH contract. So the fact that lots of USDC is moving out, meaning people are exercising these options, is very strange because this is not the proper price.
00:06:36.314 - 00:06:47.440, Speaker A: The price that these exercised options are getting per ETH is not appropriate. So let's look at one of these transactions where ETH is moving out. This one here.
00:06:47.440 - 00:07:01.362, Speaker A: And what we can see is that there is a whole lot going on in this contract. Lots of tokens are moving around, lots of Ether is moving around. The contract that's being interacted with is not the open contract itself, but it's being called.
00:07:01.362 - 00:07:07.482, Speaker A: Like another contract is being called, which is making an internal call to it. If you open this. So just open this up a new tab.
00:07:07.482 - 00:07:18.738, Speaker A: This is an unverified contract. So somebody deployed some special logic to the blockchain to interact with this system. And yeah, you can see it's got some call data that seems pretty opaque.
00:07:18.738 - 00:07:33.354, Speaker A: So something is pretty messed up right here. Somebody is executing on these options, even though the price doesn't really make sense. Now, it can be a little difficult to see what's going on just with some flat list of token movements.
00:07:33.354 - 00:07:47.554, Speaker A: So one of the tools that I like to employ when I am looking into these transactions, there's a site called Ethx info. And here's the transaction in question. I went ahead and copied it.
00:07:47.554 - 00:08:05.874, Speaker A: Come over here to this, paste it in the transaction hash. Give it a second, because it's looking at not just what happened, but it's creating a hierarchical list of what has actually happened inside of this transaction. So one things we note is here's the emitted events.
00:08:05.874 - 00:08:14.758, Speaker A: This is something you can also get on Etherscan. Here is each individual coin transfer, which is fairly interesting. But probably one of the most interesting parts here is account balances.
00:08:14.758 - 00:08:37.214, Speaker A: Instead of just looking at all the various transfers, this gives you the net effect of this transaction. Where we can see that 24,000 USDC has been credited to this is that receiving contract, the unverified source one. And the USDC has been deducted from this system, but it does not have a corresponding increase in Ether.
00:08:37.214 - 00:08:48.950, Speaker A: As you would expect when you execute an option, you give Ether for the USDC. This has not received that Ether. So something really unusual happened in this transaction.
00:08:48.950 - 00:09:10.582, Speaker A: In order to see what happened, we see that this is the caller, right? This is the user, the EOA. This is the contract the contract ended up creating oTokens. This is the transaction that deposits this person's own USDC to create o tokens.
00:09:10.582 - 00:09:32.866, Speaker A: Then we see that the system went ahead and transferred the O tokens to the vault. What we see here is that they then called in and said, okay, I would like to exercise. And they exercised against two different vaults, right? A vault is a place where basically USDC is stored and somebody owes some O tokens so they are eligible to have an option executed against them.
00:09:32.866 - 00:09:48.370, Speaker A: So they called it against two of these vaults and we can see that it transferred the USDC. The receiver was that E 78 contract. This is the attacker's unsourced verified contract.
00:09:48.370 - 00:10:09.454, Speaker A: We see that it transferred to it twice, but it only accepted the 75 ETH to facilitate that transaction once. And then at the very end, they went ahead and took the ETH that they gave themselves originally here. It's a little strange because they are creating O tokens here.
00:10:09.454 - 00:10:45.020, Speaker A: They are executing against themselves and somebody else. Then at the end, they are claiming the ETH that became their vault's property because of the first transfer against their vault. So why is it that the system only required one submission of 75 ETH to claim 75 ETH worth of USDC two times? That question is really the crux of the bug here.
00:10:45.020 - 00:11:09.358, Speaker A: And to answer that, let's look at the source code for the oToken contract itself. This is the vault that ends up storing the USDC on behalf of oToken holders so that they could come along with ETH later to exercise that option. I'm going to go ahead and open this up a little bit more so we can scroll through it a little bit easier.
00:11:09.358 - 00:11:17.938, Speaker A: So this is this zero x nine five one. This is the one that was drained of USDC. If you come along and look through here, it's a fairly long contract.
00:11:17.938 - 00:11:24.966, Speaker A: It's not terribly complicated. A lot of this is flattened ERC 20 code. But there are a few interesting functions in here.
00:11:24.966 - 00:11:47.840, Speaker A: So the bug, as it was called, was related to the exercise function. So this exercise function allows, again, remember, it said like, hey, I want to exercise this much and I would like to exercise from these vaults, right. These users who had previously deposited USDC in order to create these O tokens to sell, I would now like to execute on those options.
00:11:47.840 - 00:12:07.266, Speaker A: So effectively, it jumps into a loop here to iterate through the arguments that you passed it right here. See, we're iterating through these vaults to exercise from. And depending on what's going on here, it's going to effectively call this exercise internal function.
00:12:07.266 - 00:12:18.360, Speaker A: So this is the public exercise. The internal one has an underscore here. So we're going to go down to this internal underscore exercise, right? This is the only one that can be called from that public function.
00:12:18.360 - 00:12:28.010, Speaker A: And there's a lot of things going on here. But the real important part here is right here. I'm going to blow this up a little bit.
00:12:28.010 - 00:12:46.494, Speaker A: You can see it's better, the video, because they're using ETH directly as value attached to a transaction and not using ETH as a token such as WETH. There's different logic for handling how you receive ETH as value. So, again, ETH is attached to the transaction itself.
00:12:46.494 - 00:13:00.354, Speaker A: And so what you need to do is check that the value that was attached to the transaction equals the amount that you were expecting to receive. So if it's ETH, it makes sure the value was attached. If it's not ETH, it goes ahead and transfers the asset.
00:13:00.354 - 00:13:40.878, Speaker A: So, for example, if this was switched, if the people were depositing ETH and you were coming in with USDC when you called this internal underscore exercise function, every time you entered this function, you would transfer some batch of USDC from yourself to the contract. The problem, however, is that this underscore exercise internal function is called multiple times in that loop that we saw above. And every time it enters this loop, the message value hasn't changed, right? The amount of value that was provided to this transaction remains the same every time you enter this loop.
00:13:40.878 - 00:14:13.530, Speaker A: And so you basically get to accomplish all this other logic on this transaction without providing any more ETH, because the amount of ETH that you submitted in that original transaction is the same. And so you can call this unlimited times, and it just makes sure that the amount of value that you are submitting is the same. So you get credit for your ETH every time you call this transaction, even though you aren't sending more ETH in, it keeps checking the exact same value versus if you were using tokens every time you entered this transaction.
00:14:13.530 - 00:14:27.150, Speaker A: This function you would call this transfer from. And each iteration it would take more and more USDC from you, which is appropriate. So basically there was a bug here where it's not properly checking.
00:14:27.150 - 00:15:00.398, Speaker A: When you are exercising multiple options and providing ETH, it's not ensuring that every time you enter this function, you are receiving more and more ETH. So all the person needs to do is call an exercise with multiple vaults to exercise so that it could get credit for the ETH that it is receiving, that it is sent the first time over and over again, and just keep cashing out those USDC deposits from other users. And when they come to reclaim their ETH, there isn't enough to pay everybody.
00:15:00.398 - 00:15:24.782, Speaker A: This system ends up becoming under collateralized versus the assets that it owes everybody that comes in and tries to claim their corresponding assets. So, yeah, that's kind of the gist of this issue. And the other question that I've received a few times is how this has happened, despite the fact that this was audited by the very reputable OpenZeppelin.
00:15:24.782 - 00:15:42.074, Speaker A: If you come here and check out develop, go to security, they're talking about this open Zeppelin audit here. So open Zeppelin, they took a look at this thing the bug actually occurs in Options Contract. That is the source code file that had this problem.
00:15:42.074 - 00:15:52.910, Speaker A: And yeah, they don't mention this issue. They don't mention this. And I'd be kind of surprised if OpenZeppelin missed an issue as critical as just not checking that message.
00:15:52.910 - 00:16:07.794, Speaker A: Value was received twice now. They mentioned that the audited commit is this, right? This is a reference to a specific point in time in the Git repository for this code. So if we go here, I just followed that link here.
00:16:07.794 - 00:16:16.786, Speaker A: So we're following that exact commit hash that it mentioned. Come over here to Contracts, come over here to Options Contract. This code should look pretty familiar.
00:16:16.786 - 00:16:25.590, Speaker A: Let's go ahead and find our functions here. Here's exercise, exercise. Looking for that function call that we were browsing.
00:16:25.590 - 00:16:51.470, Speaker A: What we find here is that the exercise function itself, when we looked over here on GitHub, we saw that it took an argument of members exercise, O tokens and then an array of vaults to exercise from. In this case, the function signature is just completely different. The function signature only has O tokens and the system actually performs completely different.
00:16:51.470 - 00:17:37.642, Speaker A: If you read some of these comments here, they talk about how the collateral is paid out from all repository holders as opposed to naming specific ones, and then the repository holders end up withdrawing proportional as opposed to executing entirely against single vaults. So there was a very structural change that happened between the time that the project handed off their source code to OpenZeppelin to audit and the code that actually got deployed on Chain, right? This is a completely different function that doesn't really behave the same and the economics around it are completely different. And the bug was implemented much later, almost a month later in a different commit.
00:17:37.642 - 00:18:07.106, Speaker A: So the problem with the system really is that they requested an audit from a reputable auditing company. They received an audit that looks like it's very thoughtful, is very in depth, but they kept developing during the time frame that the audit was undergoing. And OpenZeppelin isn't going to sit there and keep refreshing to make sure that new bugs aren't getting added.
00:18:07.106 - 00:18:29.902, Speaker A: They end up getting a snapshot in time. They use that snapshot in time to review the code and see if there's any bugs there. And so when we talk about projects that are audited, a lot of times we aren't that concrete about the fact that they were audited and the fact that no changes have gone into the code since a company like OpenZeppelin signed off on it as not having any bugs that they found after looking at it for however long.
00:18:29.902 - 00:18:44.226, Speaker A: So I think that the real lesson to learn here is that projects aren't audited, but solidity code is audited. And very specifically, solidity code at a very specific point in time is audited. And a lot of times we kind of confuse it too.
00:18:44.226 - 00:18:58.994, Speaker A: We say, oh, this project is audited. I think the question really comes down to when. And we need to do a better job of creating a system that allows people to know what code actually is and if this code was actually audited or if this code was audited.
00:18:58.994 - 00:19:19.642, Speaker A: And then we made a bunch of changes that we don't think probably impacted anything. So anyway, yes, this is what I have for you today. So, again, my name is Scott Bigelow, and I'm currently working with the Ethereum Foundation on a project called Spot Check that is providing free quick gas and security consulting to projects that are nearing mainnet release.
00:19:19.642 - 00:19:32.220, Speaker A: So if you have or know of projects that could benefit from security or gas auditing, go ahead and hit me up here. Either on Twitter or my email is Scott Bigelow@ethereum.org. Thanks, see you next time.
