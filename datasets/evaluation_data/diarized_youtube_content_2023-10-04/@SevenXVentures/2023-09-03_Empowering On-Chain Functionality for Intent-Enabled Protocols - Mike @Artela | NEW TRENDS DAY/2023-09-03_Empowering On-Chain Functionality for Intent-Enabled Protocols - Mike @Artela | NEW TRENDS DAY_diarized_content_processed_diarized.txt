00:00:00.410 - 00:00:11.962, Speaker A: Yeah. So I'm going to talk what is Intent Centric Protocol and also how to implement it. And also if the current blockchain can enable the Intent Neighbor Protocol.
00:00:11.962 - 00:00:29.750, Speaker A: And also we provide a model to make it happen. And as Eric mentioned, we should need a universal framework for the Intent Centric protocol. So I will introduce what is aspect and what is our solution for the universal framework for Intent Neighbor protocols.
00:00:29.750 - 00:01:00.106, Speaker A: Yeah, so why we talk about Intent Centric protocol? Because now we want to achieve Intent whereby architecture like a ManPool. So by a ManPool centric architecture, just like paradigm mentioned in their research, the transaction need to be orchestrated and processed to achieve Intents. Which means we need a middleman to be the propagator of intent.
00:01:00.106 - 00:01:13.790, Speaker A: They need to propagate the intent and also another guy need to solve the intent. So there's always a middleman to be the propagator. So it need to be incentivized and need additional trust because we need middleman.
00:01:13.790 - 00:01:34.730, Speaker A: Right. So within this framework, the protocol itself cannot even though it do not need to be changed, but still unable to produce desired outcomes by themselves. So that's like the current protocols on a ManPool based architecture to achieve Intent.
00:01:34.730 - 00:01:58.846, Speaker A: So however, if we imagine protocols can produce the desired outcome, they can by themselves be the Internet enabled protocol. Do we still need kind of ManPool based architecture? To our understanding, maybe yes. But it definitely will be two kind of form.
00:01:58.846 - 00:02:15.480, Speaker A: First is still the manpole based architecture, especially for Ethereum. But definitely there are lots of talk among Ethereum because one that cannot support propagation is manpole. Also, there are concerns about DOI's attack.
00:02:15.480 - 00:02:26.806, Speaker A: So there should be another form. Intent centric or intent neighbor protocol. There are lots of research around the manpole based internet architecture.
00:02:26.806 - 00:02:53.726, Speaker A: So what we want to talk today is Intent Neighbor Protocol and how to achieve it. So I want to use again about the use case eric in Dodo just mentioned in his previous speech still the limit order. But honestly, limi order or other book AMM are two different design, right? So AMM is much easier and urly on chain.
00:02:53.726 - 00:03:03.566, Speaker A: But limit order. If I want to achieve this functionality, it's urly off chain. It's more complex but more commonly used in the web two exchange.
00:03:03.566 - 00:03:16.342, Speaker A: But we can say uniswap or one inc or call protocol. They actually use their AMM design to achieve on chain limit order. So it's a really amazing innovation.
00:03:16.342 - 00:03:25.742, Speaker A: Actually, this can be Zhou model for the Intent enabled protocol. So we want to start from here. Yeah.
00:03:25.742 - 00:03:37.198, Speaker A: So we dig into the code of uniswap reforms hook design. Maybe I can use an example to make it easier to understand. For example, I'm a user, I have an Intent.
00:03:37.198 - 00:03:45.906, Speaker A: I want to sell my ETH. It's 3000. Maybe it's not realistic for the current market condition, but just imagine it.
00:03:45.906 - 00:04:22.014, Speaker A: So actually the whole contract helped the Am design to solve this intent it's now the AMM pool directly. So how do this happen? Is that according to the hook throughout the post transaction lifecycle you can add additional logic throughout these call points to add this hook contract to solve this intent and also if I'm a user I regret I don't want to sell it anymore the whole contract can help me cancel and kill this order. Yeah.
00:04:22.014 - 00:04:31.730, Speaker A: So that's actually what you can okay. Yeah. With the hook design, AMM could solve the intent of limit order and fully on chain.
00:04:31.730 - 00:04:49.410, Speaker A: So what's? Uniswap V four show us we can achieve intent at a protocol level. Not need necessarily any third party architecture ManPool or anything. And second is that hook design actually makes this onchain intent server possible.
00:04:49.410 - 00:05:17.810, Speaker A: And third is that as we can see like hook contract, we need an onchain computing unit where we can see a coprocessor with smart contract for this intense server. Right? Move one step further is that hook makes on chain intense hour possible. Like smart contract during its execution, it has lots of stage, there are lots of call points.
00:05:17.810 - 00:05:37.650, Speaker A: So it will expose with its runtime context to these points. And there should be a hook contract act as intent solver for these protocols to solve the intent of users. It can insert the transaction with its outcome back to the smart contract to continue the execution.
00:05:37.650 - 00:05:51.870, Speaker A: Maybe it's hard to understand, but I can go a little bit further to get another level of abstraction. So a smart contract is a program. When run, it will emit event with runtime context.
00:05:51.870 - 00:06:05.166, Speaker A: And this event will trigger computing model to do the computation on chain. We call it on chain intern. So this is called EVAP.
00:06:05.166 - 00:06:45.710, Speaker A: Two is called Event Treasure programming you may heard of it but it's totally fine and also like this on chain server after it's finished the computation it will insert the result back and also create a new transaction it's a just in time transaction but just like just in time IOP it's in a deterministic order back to the smart contract and smart contract can continue to execute but the thing is that I want to say maybe use a human word. Intent software not necessarily need to be the original smart contract. It can be additional.
00:06:45.710 - 00:07:05.530, Speaker A: Something like a hook contract to achieve this intent. We all agree that it may be a good design for maybe the future so called intent focused or intent centric protocols. But the current hook is actually limited.
00:07:05.530 - 00:07:23.574, Speaker A: I want to say three limits here. First is still running ethereum with high gas fee limited computation capability. Second is that because it's in the smart contract level as a hook you can only for the hook transaction lifecycle.
00:07:23.574 - 00:07:42.400, Speaker A: But it's still limited runtime context for the computing unit. Because for smart contract execution, even like before smart contract execution or after smart contract execution, there are still multiple stage. So there are lots more runtime context than the smart contract itself.
00:07:42.400 - 00:07:57.090, Speaker A: So it's limited. What we need is actually a blockchain level runtime context. And also the third thing is lots of people don't have notice that because we all say unisoft before is good.
00:07:57.090 - 00:08:22.702, Speaker A: But I want to say one of this job, I don't know if you are uniswap before by Taiwan, it's a fee application. So for example, I'm a user, I want to achieve the intent of limit order, right? But there's another guy who do the trading in AMM. So Uniswap need to solve this intern for me, I am the limit order guy.
00:08:22.702 - 00:08:55.542, Speaker A: But who should pay the gas fee? Limit order guy or the AMM guy? It surely should be the limit order guy, right? Because I put forward this intent of lime order, why should I let the Am guy pay for me? But currently it's paid by Aim guy. Aim guy. So there is a fair allocation problem and in our opinion there need to be account abstraction here but in a blockchain level to solve this fair allocation problem.
00:08:55.542 - 00:09:16.346, Speaker A: I don't know if I explain this clearly, but if you have any other questions, you just feel free to ask anytime. Yeah, so with these three limits but the essential reason for this three limits design is the execution layer for the current hook design is weak. So in our opinion as a layer one Atala.
00:09:16.346 - 00:09:51.310, Speaker A: So we want to make it stronger to enable the higher on chain functionality execution layer level. So imagine there's a universal framework for the hook design results limit it should be much cheaper and has next level of computation power and easy to build and have a blockchain level runtime context and also definitely should be a fair phase allocation. That's why we are investigating.
00:09:51.310 - 00:10:03.498, Speaker A: I want to introduce Atala just in service sentence. So it's a layer one, it's an extensible blockchain enable developers to build feature rich D apps. It's general, it's abstract.
00:10:03.498 - 00:10:26.590, Speaker A: So what Atala offers is first is two enhanced execution layer actually EVM for smart contract just like Ethereum. So we keep the data structure of Ethereum but also we have another layer it's Wasom. So we are an EVM plus WASM design in one blockchain but two VM.
00:10:26.590 - 00:10:40.554, Speaker A: So this WASM is to run what's our aspect contract called aspect. So we have an enhanced execution layer. I will tell you why WASM is better in the next page.
00:10:40.554 - 00:11:00.110, Speaker A: And also we provide a new programming framework. It's not new actually because we are in the similar with uniswap who designed but we tell the same story because we all believe that it will be the new trend in crypto. This aspect we can make the app more modular and easy to build.
00:11:00.110 - 00:11:16.486, Speaker A: But it's not a modular blockchain, it's modular DApp actually because with smart contract and aspect it can combine to be a modular D app, not a modular blockchain. So it's technical side. Sorry about that.
00:11:16.486 - 00:11:32.218, Speaker A: So just like hook design, we can add additional logic throughout the transaction lifecycle. So we can make a transaction to enable intent. Even though the transaction the intent may not directly from the smart contract itself.
00:11:32.218 - 00:12:10.474, Speaker A: But as you can see, we can have more runtime context even before the execution of smart contract or after the execution of smart contract or in the block level like block init, they can all add additional code in this join point and this additional code point this additional code are written in WASM. So one thing here is that maybe you heard of lots of idea about pre compiled solutions. For example, Avalanche also use precompile and Emo's EVM extension or Stylus all pre compile.
00:12:10.474 - 00:12:41.466, Speaker A: So what's the difference? Because Stylus also EVM plus WASM right three days ago in the Bus speech. It's one wonderful speech but we support dynamic loading and execution at this joint point. A second is that ASPI code are running WASM runtime so with near native efficiency and secure web browser I think this page will be the most important page in my whole speech.
00:12:41.466 - 00:13:11.926, Speaker A: So let's bring aspect back to the Internet neighbor protocol. I want to say three points why it's better than why it can be a universal framework for the intent or for the hook design. The first is that we have more or four context as blockchain level of runtime cycle is run in Wasam runtime, it's a Wasam VM.
00:13:11.926 - 00:13:36.910, Speaker A: So according to our benchmark it's 2000 times faster and also secure web browser because all the common web browser use it. And also we allow account abstraction here to solve the problem of free allocation. So with this advantage, we make it a universal framework.
00:13:36.910 - 00:13:50.726, Speaker A: I want to add one thing here is that we are a universal framework. We are built on top of tendermint because we enable IBC. So in the future for now it's a layer one.
00:13:50.726 - 00:14:10.060, Speaker A: But in the future we will also support other execution layer if they are EVM to add this WASM execution layer to their EVM execution layer. So it can be a whole ecosystem. But future plan, we need to focus on our layer one first because we are still in development stage it's quite early.
00:14:10.060 - 00:14:37.166, Speaker A: So basically for user general page is that we can build the app by smart contract and aspect. So developer can write basic logic in smart contracts before EVM. It can enjoy the EVM equivalents and enjoy the rich tooling and ecosystem of ethereum and also low barrier to entry.
00:14:37.166 - 00:15:07.440, Speaker A: But also they can build their on chain Intent software in aspect to build this what I say intent centric protocol and enjoy the native speed and high efficiency for the additional module. And it's universal for all decks because it's a universal framework. So all the DAX even though it's not as good as uniswap or maybe a new one, they can use this kind of design.
00:15:07.440 - 00:15:26.870, Speaker A: They can just write their business logic. Don't need to worry about the similar hook design or something like that because we can achieve it for them. So it's universal for all decks or all the potential applications and in the future hopefully our execution layer of EVM.
00:15:26.870 - 00:16:09.406, Speaker A: Yeah so with our designs can enable more innovations like in DeFi side just as I mentioned as a Dex as AMM Dex you can enable fully on chain limit order or like more functional trading strategies just too complex. I will avoid this part and also a security I want to say one thing here is that several months ago it's unluckily curved protocol, it gets a reentry attack and lose 5 million, right? So it's a bad thing. It's made the crypto world worried about all DeFi world is maybe unsecure even though we are still in development stage.
00:16:09.406 - 00:16:33.226, Speaker A: But we try to reach out to them to build together because we think we write a code actually for this solution? Our solution can enable them to avoid runtime attack even at a bytecode level. Because like for Kerry Protocol, they didn't do anything wrong. Their code is perfect.
00:16:33.226 - 00:16:48.462, Speaker A: But after compiled wrong, thing happened. So after compiled, we can actually reverse the transaction if something go wrong. So this reentry attack can be avoid in a blockchain level.
00:16:48.462 - 00:17:08.838, Speaker A: So that's the difference. And also, even though we haven't launched our Dev night because several months ago we just launched this project and we are still in development stage. But in this playground we can show developers can use this playground to write some as by code and to say what happened, to have fun.
00:17:08.838 - 00:17:46.542, Speaker A: Yeah and also if you are interested you are looking forward, you are more than welcome to have a try and maybe give a PR or contribute together with us for the conclusion maybe just say something is fine. So with intern neighbor protocol we think we actually don't need to rely only on ManPool. For instance, if we can enable the protocol level or I should say internable protocols.
00:17:46.542 - 00:18:04.514, Speaker A: And also how can we achieve this method? Hook design makes on chain internet server possible and gave us a clue. And third is that uniswap v four is good, but it's kind of limited. Especially it's not a universal framework.
00:18:04.514 - 00:18:25.978, Speaker A: So what we are building is a universal framework to enable this intent. Enable protocols without limit slang is like smart contract plus as far is equal to reach the app. So that's our contact info and my contact info.
00:18:25.978 - 00:18:41.300, Speaker A: So if you have interest or want to have fun or just scan this code and let's talk more or if I have any other questions, feel free to ask me anytime or leave a comment. Totally welcome.
00:18:42.630 - 00:18:48.360, Speaker B: Thanks. Any questions here?
00:18:49.290 - 00:18:50.630, Speaker A: Okay, sure please.
00:18:50.780 - 00:19:04.310, Speaker C: My question is as a user, what is my point of interaction with call? Do I call a specific program on aspect? Or do I do a normal interaction with the EVM part on a smart contract?
00:19:04.470 - 00:19:17.102, Speaker A: Yeah, so, good question. So let me repeat his question. So, as a user, why I develop my program in WASM? Why not I directly build on top of Ethereum using EVM, right? Yeah.
00:19:17.102 - 00:19:37.506, Speaker A: So I think to my understanding is that we totally agree that I'm also a developer. Everybody wants to build on top of Ethereum directly. So everybody also know that not everybody can build on top of Ethereum because it's gas limit and high low computation power.
00:19:37.506 - 00:20:07.370, Speaker A: So there are also lots of layer two appeared and they choose to build on top of them. I think the general idea is that if we want to onboard the next million user for web three, we need first we need to onboard the next million developers. But even though most developers in web three, they choose to build solidity in EVM, but compared to the whole developer world, it's still a very small amount of developers.
00:20:07.370 - 00:20:22.062, Speaker A: Right? I think it's definitely less than 1 million, I think worldwide. I forgot. But compared with WASM, so WASM supports C support c support JavaScript assembly script, right? Or Rust.
00:20:22.062 - 00:20:32.162, Speaker A: So it's more universal, it's language agnostic. Most of the developers in web two they choose WASM. So that's why we don't want to change the habits of developers.
00:20:32.162 - 00:20:44.342, Speaker A: Yeah, definitely. They can build on top EVM, Ethereum or Arbitram or Polygon, totally fine. But if we want to have more people come in, we need to enhance this EVM.
00:20:44.342 - 00:20:53.946, Speaker A: So that's why we add WASM. We didn't replace it with WASM. We add it so more people can onboard and have fun in crypto.
00:20:54.138 - 00:20:58.270, Speaker C: So when I do a transaction, does it land on the WASM part by default?
00:21:00.050 - 00:21:06.834, Speaker A: It's not by default, actually. So optionally, you can choose to bind the aspect or not. It's totally fine.
00:21:06.834 - 00:21:19.430, Speaker A: Up to you. You can directly build your smart contract just as Ethereum and don't use this WASM code, it's totally fine. But you can also add this to aspect throughout the transaction lifecycle.
00:21:19.930 - 00:21:24.614, Speaker C: So if I have an intent, then I would probably write a program on the WASM layer which would delegate to.
00:21:24.652 - 00:21:27.080, Speaker A: The at certain points of time based.
00:21:28.490 - 00:21:30.030, Speaker C: Is my understanding correctly?
00:21:30.130 - 00:21:45.446, Speaker A: Exactly. So the amazing thing here is that even beyond smart contract, ASPI can solve some additional logic. For example, like AMM smart contract it is.
00:21:45.446 - 00:21:59.250, Speaker A: AMM only can solve AMM problem. But their whole contract is for limi outer maybe or maybe other who contract. Right? So this can solve something beyond smart contract.
00:21:59.250 - 00:22:09.658, Speaker A: So that can be the same intent or different intent. Yeah, so that's why we call it modular DAP. Or maybe I should now use the word intent.
00:22:09.658 - 00:22:21.542, Speaker A: Actually it's an abstract word, it's just put forward by the power paradigm. But before that nobody said but you know, the idea is maybe you can use intern. Thanks a lot.
00:22:21.542 - 00:22:22.760, Speaker A: No worries.
00:22:24.810 - 00:22:29.998, Speaker B: Any other questions? If no, we will grab up here. Okay, thank you.
