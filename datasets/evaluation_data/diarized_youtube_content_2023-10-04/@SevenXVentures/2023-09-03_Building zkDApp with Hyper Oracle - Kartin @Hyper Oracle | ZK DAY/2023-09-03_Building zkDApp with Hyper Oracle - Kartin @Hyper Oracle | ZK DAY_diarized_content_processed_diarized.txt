00:00:00.650 - 00:00:28.790, Speaker A: How to build a Zkd app and what's Zkd app let's build with hyper Oracle to build a Zkd app. So before we go into Zkd app, we need to have the concept of what's ZK Oracle so ZK Oracle essentially is like for ethereum at least it's this structure that we have like the consensus proof and we have the proof for the event and proof of the state and proof of transaction. Also enable custom compute verifiable custom compute in the Zkvm.
00:00:28.790 - 00:00:54.270, Speaker A: So basically hyperoracle can unlock this following ability for the sewer power for the smart contract. For instance, you can have historical on chain data for your smart contract with hyperoracle and also you can have complex compute extension for hyperacle to use in your smart contract. Also you can have multiple data source in the future, we can support internet data source for your smart contract too.
00:00:54.270 - 00:01:12.066, Speaker A: So, hyperacle is the programmable ZK Oracle protocol. So what's Zkd app zkdf essentially is the instance of the intent compute. So if you have an intent D app, what you're talking about most likely is like the Zkd app.
00:01:12.066 - 00:01:30.680, Speaker A: So Zkd app is the app that utilize the ZK Oracle to perform the computation and the data fetching. So with Hyperacle we are empowering the nest way of the Zkd app which will be noble, secure and permissionless. And also it's really easy to build with hyperacle to build a Zkd app.
00:01:30.680 - 00:02:04.850, Speaker A: There's many usage for ZK Oracle in your smart contract. The first will be like the bunch like new DeFi usage like Zkarm and kind of like a fully on chain derivative and fully on chain ETF. And also we have enable Aigcnft for a ZK Oracle we can also perform some little bit like ML inference, we will talk about it later and also can have a ZK automation for recursive payment and some schedule on chain ability.
00:02:04.850 - 00:02:17.334, Speaker A: Here is the study case for what we can do with the ZK Oracle. So let's go back review the history for the development for the DFI. So in the D five 1.0
00:02:17.334 - 00:02:32.830, Speaker A: we have the centralized exchange that we have the ERC 20 that we can issue any tokenized everyone and organization entity on chain. But we only can do the swapping in a centralized exchange. So that's why we have a DeFi 2.0
00:02:32.830 - 00:02:50.958, Speaker A: am that will enable people to generate the token tokenize themselves organization on chain also swap the token and provide the liquidity on chain. But we still have another problem is that we cannot have the derivative. That the underlying asset is that certain token fully on chain.
00:02:50.958 - 00:03:14.410, Speaker A: What's the problem? The problem is because it would be really expensive on the gas fee if you put the whole derivative condition checking on chain an automation on chain in DeFi 2.0. So that's why we introduced the ZK Oracle to have the ZK automation for the D five 3.0 that will enable fully on chain derivative and fully on chain ETF.
00:03:14.410 - 00:03:45.586, Speaker A: For instance, before you have a ZK Oracle, the only way you can do a fully on chain derivative is that you have a Smart Contract on chain and then you do the triggering for the smart contract every block to check if fit the condition for the clearance. For instance, I want to shop the ETH to the half of the price we have today. And then what we need to do is that you need to call the Smart contract every block and then check if the ETH price is like the half of what you hit the strike price or not.
00:03:45.586 - 00:04:14.458, Speaker A: But with the ZK Oracle you no longer need to check every block, you can just basically have the automation and only call the Smart Contract when you need to call the Smart Contract. And why building with Ziki Oracle is better than the traditional Oracle is because it's safer, faster and more decentralized. The Oracle we use today most likely like Chunning type of Oracle is pretty centralized and pretty inefficient and manipulatable.
00:04:14.458 - 00:04:48.902, Speaker A: So the way the workflow for traditional Oracle we have today is basically you aggregate all the computation reserve and data fetching into some certain centralized cloud node and then report them into a Smart Contract through this trusted entity. And by this way, all the Oracle node need to stay the certain token into the Oracle node to ensure their computation integrity. And then with the ZK Oracle we no longer need to require the Oracle node to stay the token to ensure the integrity.
00:04:48.902 - 00:05:26.770, Speaker A: Instead we just use cryptography to ensure the computation security and data fetching integrity and then use the Smart Contract to verify instead of trust to do the data fetching and computation extension. So here is the comparison between the Staking Oracle that we use today and the ZK Oracle that we are going to use in the future. It's a paradigm shifting, so we can tell that transition Oracle can finalize the thing that require one to two minutes to finalize a data and computation result, when ZK Oracle can finalize that within 12 seconds, which is the ethereum block time.
00:05:26.770 - 00:05:58.682, Speaker A: And we already have the benchmark today. And the way we keep the Oracle network fully decentralized is the idea we call it proof of Oracle work. So what is the proof of Oracle work and how are you going to keep the Oracle network, become fully decentralized and should receive? So it's the whole procedure, the workflow for the proof of Oracle work is that the developer will put down the bounty for the computation test that they want the ZK Oracle to compute with for their Smart Contract.
00:05:58.682 - 00:06:15.330, Speaker A: In this case, this guy want to compute a Blackshop model for his Smart contract. There's a multiple reason why Smart Contract cannot do Blackshop model. For instance, the square rule, the lock admitted, and like the distribution computation, this mathematical statistic computation.
00:06:15.330 - 00:06:31.442, Speaker A: So smart contract. Cannot do that. So that's why we need ZK Oracle to do that, but we can send out a signal through the smart contract, say, hey, I want to do this computation and I think this job worth like five token or one E for this job for my smart contract.
00:06:31.442 - 00:06:56.674, Speaker A: Every block probably is too expensive, probably like 0.1 if per block to do the computation for my smart contract. And then the developer will put down the bounty in the ZK Graph bounty and then all the ZK Oracle node will compete with each other to finish the computation first and submit the proof first into the Verifier smart contract so that the smart contract can check if the result is correct or not.
00:06:56.674 - 00:07:26.378, Speaker A: After it pass the verification in the smart contract, it will TransPass the result into the target smart contract that developer want to be triggered and also transfer the computation itself into. So I'm going to introduce this ZK Graph Studio, which is a web IDE that can help developer to develop a Zkd app within the afternoon. That's the purpose for this hacker house, to make it more detail.
00:07:26.378 - 00:07:54.958, Speaker A: So if you guys have any questions for how to make a ZK graph for a ZK Oracle code that you want to program with, you can ask our expert. Suning is here to see to check about more the technical detail. So basically this is like ZK Graph Studio is essentially equal to remix for Solidity that will enable developer to program a ZK Oracle in a website that they don't need to spend time on, figure out the dependency and stuff.
00:07:54.958 - 00:08:15.546, Speaker A: Basically a senior Solidity developer can develop a Zkd within an afternoon without knowing anything about zero launch proof. So there's a many use case for ZK Oracle, many use case. The one I mentioned earlier is like the D five 3.0
00:08:15.546 - 00:08:45.694, Speaker A: use case that's like fully on chain ETF on chain derivative. And also you can have some use case like security use case like a zero s hack that basically utilize the ZK Oracle to do the security check for a smart contract. And if the hacker can hack a smart contract successfully, but he can propose a bounty into the protocol to say, hey, I had your protocol, if you pay me certain amount of money, I will review that and not execute this certain hacking behavior.
00:08:45.694 - 00:09:14.330, Speaker A: But if you're not, they're going to utilize the Z Oracle to do the hacking by themselves. Okay, so basically it's like a negotiable protocol for hacker and there's a new usage like ZK Stablecoin that's like fully on chain with 100% collateral and also have some dow management for their smart contract. Like Els used the ZK Oracle to basically manage their Dao for voting resell because they pretty often need the voting resell every block.
00:09:14.330 - 00:09:39.634, Speaker A: Also what's more than a Zika Oracle with Hyper Oracle is that we propose a new mechanism and the library is open source already and it's already enabled stable diffusion, llama and tragedy on chain. And this is called OPML. And this OPML library you can check out in hyperorco repo and can utilize that to build something cool with this if supported model.
00:09:39.634 - 00:10:09.390, Speaker A: So you can have the model itself on chain compared with Ckml. The good thing for OPML is that essentially you can do any kind of model as long as you can run in a computer for the inference, you can have that for your smart contract. But I will say the problem for OPML today is in the most ideal situation that we have ZK fraud proof for the OPML we will still need two block time to finalize the ML inference result into a smart contract.
00:10:09.390 - 00:10:22.020, Speaker A: And also the gas fee is a little bit too high right now without ZK fraud proof. But we are working on it. If you want to try out how to put a on chain machine learning this will be the best library you can chat right now in the market I think.
00:10:22.020 - 00:10:30.390, Speaker A: Thank you. Here is like this call please join our community through the link. You can also check our progress in GitHub and follow us in Twitter.
00:10:30.390 - 00:10:55.738, Speaker A: Yeah, basically that's it the most interesting use case you've seen people developing hypercom fully on chain. Delivery guy, he basically built a repo that called Decentralized ETF right now. So what they do is they want to put the SP 500 fully on chain.
00:10:55.738 - 00:11:08.100, Speaker A: Basically it's like have like top 50 most traded ERC 20 token in the DAX. And then this smart contract only do one thing and one thing only. That is like act like SP 500.
00:11:08.100 - 00:11:37.734, Speaker A: So SP 500, essentially what it does is he purchased the most representative 500 stock in the US stock market. They will change their holding every three months. So what this Decentralized ETF does is basically they will use like algorithm that hosts inside Zika oracle and then they monitor all the on chain behavior they want to monitor and then pick out the most representative top 50 ERC 20 token and then that's my contract.
00:11:37.734 - 00:11:56.278, Speaker A: Do only one thing and one thing only. It's just like holding them and then change that in every 1000 block and every 1000 block they will repeat the most representative top 50 token. And this smart contract, the most amazing thing is doesn't have an owner at the main which means nobody can change it and it's really neutral once they put it on chain.
00:11:56.278 - 00:12:15.686, Speaker A: Nobody can change that and the way he utilized so before you cannot do that because you need some monitor to keep checking out what's the most traded token pair on chain. But it's like trusted entity to do it which means the smart contract need a super user. But right now we don't need a super user for the smart contract to do that.
00:12:15.686 - 00:12:54.546, Speaker A: You just have verifier that asking the data from a ZK Oracle and then refresh the smart contract every 1000 block and then that will have like fully on chain and neutral asset management smart contract. And I think in the future people if they don't want to be hustled on DeFi they can just buy this decentralized ETF and put down their ETH in it and then it will management for them automatically. Because in long run and in a big size for the capital normally the passive ETF is always outrun majority pro ATIC fund in the traditional finance market.
00:12:54.546 - 00:13:03.480, Speaker A: So I think it's pretty common in this phenomena. So I think it's going to be pretty useful for everyone here who actually use DeFi, right? Yeah.
00:13:04.490 - 00:13:07.880, Speaker B: You mentioned you have some use case like there is some security.
00:13:08.330 - 00:13:09.080, Speaker A: Yeah.
00:13:09.930 - 00:13:13.622, Speaker B: So what do they use of the check?
00:13:13.676 - 00:13:42.958, Speaker A: Smart contract? Yeah, what they do is that so they have like a state checking thing inside ZK Oracle. So basically what they do is that so we run a smart contract inside a ZK Oracle and run to basically essential idea is that they try to prove that I'm able to hack your protocol by running the EVM logic inside the ZK Oracle and then I can prove that in the next block. If I implement this logic, you will lose all your fund in your smart contract.
00:13:42.958 - 00:13:54.818, Speaker A: At least majority of the fund. The state slot will be changed to a really low amount of the money inside this smart contract. Which means I already had your smart contract and transferred the fund out to my smart.
00:13:54.818 - 00:14:33.886, Speaker A: Contract but I didn't actually implement it because this running in the simulation inside Zkoracle but you generate a proof without reviewing what's the problem? What's the bucky point for your smart contract? And then I will submit the proof, and with the state of the basically, the public input is like the state of how much money you left in your smart contract. And then with the proof and then submit into the smart contract that can verify that that show the guy hacked your protocol, but you don't know how he hack it. So this protocol will enable the protocol side to provide them a window for negotiate with the hacker.
00:14:33.886 - 00:14:52.234, Speaker A: If they pay certain amount of money for property, it's like 1% of the governance token into the deposit into the hacker's wallet and they will not execute this thing and reveal what's the problem to the protocol like alternative of the.
00:14:52.272 - 00:14:56.426, Speaker B: White hat bug bounty, but in a not very present way.
00:14:56.608 - 00:15:32.566, Speaker A: Yeah, it's more like a hostile version for the white hat bounty thing, but it's a real world, right? Like hackers normally do not care this white hat bounty thing because they're hacker, what they want to do is maximum their profit. But in the real world even though you try to wash the money that you hack from certain protocol but you still have risk that you got caught, right, but if you submit this thing as the trade for certain governance token and cash them out that will be considered as clean money. Nobody will after you.
00:15:32.566 - 00:15:41.426, Speaker A: So it's like expectation value here that I need the people to negotiate and have a game series behind them. But it's like pretty early stage project, but it's really innovative.
00:15:41.538 - 00:15:43.126, Speaker B: This is your own project or there's.
00:15:43.158 - 00:15:48.986, Speaker A: Somebody no, it's somebody else actually. It's like a team in Hong Kong doing that. We don't even know them before.
00:15:49.008 - 00:15:50.810, Speaker B: They haven't been applied yet.
00:15:50.960 - 00:16:03.198, Speaker A: Yeah, it's not it's like they have a CTF hosting in September 1 that try to use this thing to find out who is the hacker, can hack, what kind of protocol. Okay, yeah, they're doing it and it's progressing really well.
00:16:03.284 - 00:16:04.718, Speaker B: That could be very interesting.
00:16:04.884 - 00:16:33.510, Speaker A: Yeah, it's a security usage and yeah, we have like AIGs usage, DeFi usage, security usage and dow management. And I think that's like most common usage for now. And what's most important that is you can already build this thing out today because I know another similar project that they are still in under development, but with hyperacle you can already build it today within the afternoon.
00:16:33.510 - 00:16:38.380, Speaker A: That's like what's our advantage and why to choose us to build with?
00:16:39.070 - 00:16:55.774, Speaker B: In your Oracle architecture, there was one page showing how the Oracle works. It's like you have this bounty to have someone to maintain that work. But right now is that also related with OPML? Is that same thing?
00:16:55.892 - 00:17:09.310, Speaker A: No, that is basically how we keep the Oracle network alive. So it's like, you know, proof of work, right? Proof of work is like bring two things to bitcoin. One is the consensus that random number can summarize all the transaction in that certain block.
00:17:09.310 - 00:17:30.438, Speaker A: And the second thing it brings to the bitcoin is like the liveness for the network because there's a reward for every block. Right now it's like 25 bitcoin, right? Yeah, something like that. Per block, which means it's not 25, it's like zero point 25 bitcoin per block.
00:17:30.438 - 00:17:37.278, Speaker A: And it's like a reward there. People will spend the resources to do the computation for this certain network. So it's the same thing.
00:17:37.278 - 00:17:52.414, Speaker A: Basically this GK Oracle network. No, operator. They can download image for free, it's open source and then they can run it and then compete, use their computation to compete for the computation job that hosting inside the smart contract.
00:17:52.414 - 00:18:18.794, Speaker A: If they are, for instance, this job I want to do a normal distribution for uniswap trading pair between ETH and USDC. I want to do the normal distribution for all the transaction and I do the computation, and then I want people to do the computation for it. And I put down how much it costs, how much I think this job value is, for instance, uniswap, like this project put down like 0.1
00:18:18.794 - 00:18:28.366, Speaker A: ETH for every block who compute this thing for me. And then all the ZK Oracle is competing to finish this job. And the proof first for that 0.1
00:18:28.366 - 00:18:33.386, Speaker A: ETH and whoever yeah, the one before Oracle.
00:18:33.418 - 00:18:34.558, Speaker B: How does the oracle work?
00:18:34.644 - 00:18:45.614, Speaker A: This one proof of Oracle work? Yeah. So basically all the Zigoracle are competing for this certain bounty. For instance, in this case, this guy developer they put how many node do you have? It's dynamic.
00:18:45.614 - 00:18:49.970, Speaker A: It's dynamic? Yeah, it's dynamic. It's basically in the beginning maybe mostly.
00:18:50.050 - 00:18:51.174, Speaker B: Like the one, you know.
00:18:51.292 - 00:18:57.506, Speaker A: Yeah. I think right now we don't run our own no. It's just like all another people partners are running the nodes.
00:18:57.506 - 00:19:11.194, Speaker A: It's permissionless, everybody can run the no and when we have it in mainnet, everybody can run the node and whoever run the node, we will get the token reward for this. Where the job we put down how.
00:19:11.232 - 00:19:12.798, Speaker B: Your token have been?
00:19:12.884 - 00:19:28.119, Speaker A: Yeah, have the utilization it's a utility for the token. So whoever passed the verification first, who will get the reward. And we don't need to worry about the front running here because how can.
00:19:28.119 - 00:19:30.798, Speaker B: You prove that they give the right results?
00:19:30.974 - 00:19:41.022, Speaker A: It's a smart contract for Verifier. So if you are having uncomfortable too, you already have yeah, it's a customized automation that you can write anything in it and then get verified in a smart contract.
00:19:41.086 - 00:19:44.982, Speaker B: But I have a little concern on that because the scope might be quite diverse from each other.
00:19:45.036 - 00:20:13.822, Speaker A: It does not matter as long as it's because it's a tooling complete system. So no matter where we write, you can prove that in a smart contract. Anyway, the core thing is in here is that how to prevent a front running because I have five guy here and then I finish the proof first and I submit the proof with the result into the main proof and how I ensure my transaction got taken and you are not paying extra gas to form run my transaction into the verifier, right? That will be the problem.
00:20:13.822 - 00:20:39.334, Speaker A: So that's why we have creatively invented a new type of circuit for signature for the public address. So which means in your proof you're also including your wallet information even there's another guy paying extra gas try to front run your proof with the result you still receive the money in that certain address instead of this front runner's address. So this is some little bit like innovation we have here to make this.
00:20:39.372 - 00:20:44.740, Speaker B: Whole system work out circle, if that's going to be general.
00:20:45.190 - 00:20:48.626, Speaker A: Yeah, the circle, yeah, I mean the.
00:20:48.648 - 00:20:50.466, Speaker B: Circle itself is still going to be.
00:20:50.488 - 00:21:02.950, Speaker A: A general trade with all the circuit or the circuit. Yeah, we utilize Ckbm so you have different circuit every time. But for instance, today we have five different computation job.
00:21:02.950 - 00:21:29.482, Speaker A: One guy want to do a square root, one guy want to do a floating point, another guy want to do a normal distribution, another guy want to do a python distribution. So we have got five different verifier in here. So different computation job have their own Verifier in the first version, but in the future version like probably in one year from now we have a unified Verifier that can support all the verification in one certain verifier.
00:21:29.482 - 00:21:41.170, Speaker A: That will be another type of thing in the future. But right now all computation tests have their own verifier in the smart contract with their own scope, with their own scope only.
00:21:41.240 - 00:21:58.474, Speaker B: Yeah, because that's also quite limited towards the development of the Zkem because they are maybe not super for general, they're still pretty certain circles to work, so it's not dealing with all the new things, you know what I mean? If they have something out of this five scope, they have something totally new.
00:21:58.512 - 00:22:11.194, Speaker A: As long as your computation scheme are the same, it will be the same verifier. If you have different input, for instance, this normal distribution have like one to ten, another one have like two to 20. It won't affect it doesn't matter.
00:22:11.194 - 00:22:16.734, Speaker A: It's just different input for the same circuit. So it's the same thing. So we don't need to worry about that.
00:22:16.734 - 00:22:37.346, Speaker A: As long as this DeFi protocol have certain what they want in the Verifier so they can use the decay Oracle to do that. And the reason why it's like permissionless and censorship received or decentralized is just simply because the proof of Oracle work is like decentralized. Everybody can run a Zika Oracle so nobody can stop any job to be executed on chain.
00:22:37.346 - 00:22:53.814, Speaker A: Because as long as we decentralize enough, there's a job that US government or any authority tried to ban it. And there's another guy in another place on the earth will do it in that Zika Oracle. It's like it still work out because have the bounty.
00:22:53.814 - 00:22:57.402, Speaker A: It's just the same logic. That why bitcoin is decentralized, how efficient it will be.
00:22:57.456 - 00:23:01.738, Speaker B: You say something after 1000 blocks something no.
00:23:01.824 - 00:23:09.322, Speaker A: So that's the use case. The Use case, they choose 1000 bot to update it. But normally you can do every bot, it's just up to your demand.
00:23:09.322 - 00:23:23.302, Speaker A: What kind of usage? If you can make money with every bot and still do verification every bot, you can make money from it, which you're using right now. We just support Ethereum just for now. Yeah, it's fast enough.
00:23:23.302 - 00:23:41.860, Speaker A: Right now our benchmark is like 7 seconds, seven to 8 seconds for all the competition tasks that happening inside the any other questions? Beautiful. Thank you, cardi. Thank you.
