00:00:00.330 - 00:00:42.854, Speaker A: The reorganization of the slides is completed and the blockchain holding the slides has been finalized. Let's resume. So this is our stack that we provide at the very base. We have our own modular smart contract implementation. This is our own implementation that is very minimal by design. And we have implementations for modules like session keys, batch transactions, pass keys, and obviously the normal ECDSA validation module. So whenever a user deploys a wallet, they have the ability to choose how transactions are validated by default.
00:00:42.854 - 00:01:33.894, Speaker A: The implementation of the modular smart contract wallet by itself doesn't really make any assumptions about how the wallet is controlled. And then on top of this, it's not pictured in the slide, but we have a client facing TypeScript SDK, which DApps are able to integrate into their front end, and that is responsible for setting up the smart contract. Wallet on behalf of the user, handling deployments, talking to various services, negotiating with the bundler, negotiating with the paymaster services and stuff like that. And then on the infra level, we provide two major services. One is the paymaster service. So we have our own implementations of a token paymaster through which users are able to pay in any token that they choose, like an Arc 20 token. And we have a verifying paymaster which allows DAP developers to customize the conditions under which they might want to sponsor a transaction.
00:01:33.894 - 00:02:47.054, Speaker A: Like for example, Adapt might want to sponsor a transaction when it lands on their specified DAP or contract. So we run services for that and then we run our own bundler. Our bundler is a TypeScript implementation that essentially captures the stack that we provide. And yeah, I mentioned that one of the primary focus for Biconomy these days is to take multi step interactions from the user and figure out a way to compress them to take it down to as low of the steps as possible. And these days I would say a major path that we are trying to take to achieve that is through modules. So as you saw in the ERC 6900 standard, there can be multiple types of modules. There can be modules that change the way transactions are validated, like through a normal EO using the SEC P curve or through a passy, which is stored on your hardware on your phone in a secure hardware enclave or even something like a multisig.
00:02:47.054 - 00:03:46.718, Speaker A: And then there are other modules which I'm going to talk about. And then there are execution modules which change the way or modify the way in which a smart contract wallet can do execution, like a custom execution function to fan out tokens or something like that. So the way we do this is we combine these modules and our modules are composable in the sense that multiple modules can be used with each other. And that is how we kind of reduce the number of steps by looking at a use case and then figuring out okay, what are the interactions? And then figuring out what module can act as a UX improvement layer for that. So before talking about some of our modules, I would like to give a brief overview about how our smart contract wallets are implemented. And that is the modular account architecture. So this is the second version of our smart contract implementation.
00:03:46.718 - 00:04:47.990, Speaker A: In the first version, we always had an implicit assumption that a smart contract wallet would be always controlled by an EOA. But we found out that this is not necessarily the case, because in future it could be the case that there's a smart contract wallet, but there is no notion of EOA. It could be the case that it's just controlled by a hardware wallet private key using the R one curve. Or it could just be the case that there isn't a single EOA that's controlling the wallet, it's just that it's controlled in a multi SIG fashion or something like that. So by default, our smart contract implementation doesn't really make any assumption about how the transactions are validated. This also means that the smart contract wallet does not store any state at all, except the fact that which modules are currently enabled on that particular smart contract wallet. So the way you create a smart contract wallet is that when you ask the SDK to deploy it, the user is allowed to specify the way in which they want validation to be done.
00:04:47.990 - 00:06:00.782, Speaker A: So for the very basic use case, the user is just able to specify that, okay, this is an EOA which I own, and please use the default ECDSA k one validation module so that my EOA can sign the user operations that I create. And then all of the validation for those user operations would be done through this module. It could also be the case that the user just specifies a different module, and then this k one curve verification never happens inside the smart contract wallet. And then this is not a strict requirement for us, but what we've kind of found through practice is that it's better to keep our module single tenant multitenant. What I mean by this is that let's say that I create a module to do path verification using the R one curve, right? I won't really deploy multiple this module multiple times for every user. All of the users would essentially be pointing to the same instance of the smart contract which contains this module implementation. And then during the smart contract initialization, this particular module would just store the details for every user using something like a mapping or any storage pattern that it wants to use by itself.
00:06:00.782 - 00:07:03.490, Speaker A: But essentially there's going to be one contract and all of the smart contract wallets which want to use that particular module are just going to reference to it instead of deploying another copy. The benefit of this is mostly that it saves on deployment costs and we haven't really found a need to have multiple deployments. I don't really think that enables another use case, but obviously would be interested in knowing if you have something in mind that would benefit from that kind of pattern. And yeah, this is just a diagram that shows how the Smart Contract initialization works during deployment. So there is a Smart Contract Factory which can be called independently, but is normally called using the entry point during when the user operation contains the init code. That init code is essentially a call to the Smart Contract factory which is going to deploy the Smart Contract Wallet. And that init code is going to contain a reference to this singleton multitenant module.
00:07:03.490 - 00:07:34.240, Speaker A: And once the Smart Contract has stored in its storage, that okay. This is the module that I want to use as a default validation module. It's just going to do a call to the module. In this case, just called Setup for SA. And then this module is going to store whatever information it wants. And in the case of, let's say, a basic ECDSA K One EOA based verification module, it's just going to store okay, for this particular Smart account at this address, this is the owner. So it's just a mapping from the Smart account address to the owner address.
00:07:34.240 - 00:08:20.108, Speaker A: So for this particular presentation, I would like to focus on validation modules. Our current Smart Contract architecture supports validation and execution modules by default. And we are in the process of adding support for ERC 6900 so we would be able to support hooks. And I guess, yeah, I believe there are two more classes of modules. One of them is Hooks and there's one more type of module. We'll have support for that. So essentially a validation module is a module that modifies the rules for validating a user operation by the SCW.
00:08:20.108 - 00:09:30.520, Speaker A: And examples are session keys, pass keys and on chain automation. I believe the automation use case is interesting because you can essentially create a validation module which delegates the access of an account to certain parties, like an off chain service which manages automations for users. For example, let's say there is a user which wants to do DCA through the Smart Contract Wallet, right? So what they could do is they could just install a module which verifies that a user operation has been signed by a particular, let's say EOA. And this EOA is owned by an off chain service. And that off chain service is then essentially allowed to sign user operations on behalf of the user. But then this module is also doing some validations in the validation phase of the user operation, which could be that this particular user operation must be executed at a certain point of time. And the call data of the user operation should exactly be something like dex call with a certain amount of tokens and a particular address of token or an array of tokens.
00:09:30.520 - 00:10:31.816, Speaker A: And there could be as many validations as required inside the automation validation module, obviously subject to the rules of the public mempool imposed by the bundlers. And how do you create a validation module for our smart contract wallet? So it's pretty simple. This is the interface which is very similar to the interface of the smart contract wallet itself as defined by ERC, four three seven. And what you do is you just define a function called validate user op which takes the user operation struct and the user operation hash. This is generally calculated by the entry point itself and it just returns the validation data in case of 43 seven. This validation data is essentially a concatenation of three fields. A boolean representing whether the user operation is valid or not, and then a time frame essentially valid until and valid after the two boundaries for the time in which the user operation is valid.
00:10:31.816 - 00:12:04.436, Speaker A: So you can build a module which controls like within what time duration is user operation actually valid, right? And if you want to store some data for the user when the module is being initialized, like some module specific configuration for the smart contract wallet, you can also implement a function like setup or set up an setup module or you can essentially name it anything. There is no restriction on that because you are able to essentially pass arbitrary call data during initialization which would be called on this module and then that call data would essentially get executed on this module during initialization. So it's pretty simple for anybody to create a validation module on our smart contract wallet. And this is how the validation flow looks like when the actual execution is being done for a user operation. So the entry point is going to call the smart, this is the validation phase of the execution of the transaction in which a user operation is executed. So the entry point is going to call validate user operation on the smart contract on the smart account and the smart account is going to then look at the user operation and it will figure out which module is essentially responsible for validating this authorization module. Now how is this done? The way it's done is that we essentially use the signature field of the user operation.
00:12:04.436 - 00:13:09.870, Speaker A: This signature field is something which we define as the place where you can put custom validation data for your module. So in the very simple case where your user operations are being validated by an EOA, the signature is going to be an actual ecdss signature of the user operation hash with that particular private key. But if you want to design a custom module, what you can do is you can put some arbitrary data inside that signature and that signature is just going to be, that signature is going to correspond to a particular the format of that signature is going to correspond to a particular validation module. And also the signature in itself contains the address of the module that should be used to validate this user operation. So what happens is that the smart account internally is going to look at the signature field. It's going to extract the address of the validation module. It's going to verify whether the validation module is actually something which has been enabled before or not.
00:13:09.870 - 00:13:44.388, Speaker A: Once it has verified that, it's going to pass in the rest of the data, in that signature, whatever that arbitrary data is to the module at the address which it extracted before and call this function called validate user off. And then the authorization module is free to do whatever validation it wants and then it will return the validation data which is a concatenation of the three fields, a boolean representing whether the op is valid or not and the time frame in which it should be considered as valid.
00:13:44.484 - 00:13:50.540, Speaker B: Does the auth model call the execution model? Where would the execution model call in this flow?
00:13:51.040 - 00:14:42.960, Speaker A: No, this is only for the validation flow. The execution flow is completely different. Yeah. Okay, so now this is like the highlight in my opinion, of this particular presentation. We've been working on a module which is able to provide single signature and multi execution module. We call this module a MultiChain validator module. And what it essentially allows you to do is once this module has been enabled, let's say you essentially have three smart contract wallets on three chains, right? Once this MultiChain validator module has been enabled on three different chains, what this allows you to do is to execute three different user operations arbitrarily on the smart contract wallets of these three different chains with just one signature.
00:14:42.960 - 00:16:14.604, Speaker A: Without this module, what you'd have to do is you have to create three different user operations individually sign each of them with whatever validation module you're using. If you're using a normal EOA based validation module, you have to do a MetaMask sign for each of those user operations thrice and then you'd have to submit all of them separately, right? But what this module allows you to do is that you create three user operations, but then the user has to sign only once and that same signature can be used to validate the user operation on all three chains without any loss of security or replay protection. So how do we do that? So this is the internal working of the MultiChain validator module, but I'll show you a diagram instead and I think that's going to make it much more understandable. So what we do is let's say that the user has a wallet on four chains, on ethereum, polygon, on avalanche and base. Now, for whatever reason, they want to execute four independent operations on these wallets, right? They create a partial user op. A partial user op is essentially a user op with all of the fields like call, data and whatever is required to figure out what's being executed without the signature. And stuff like gas and also a partial user op essentially just tells you that what is actually being executed and where it should go.
00:16:14.604 - 00:17:26.740, Speaker A: Right, you create those user operations, you calculate their hash, the user operation hash, and then you also specify the validity for this user operation, the valid until and valid after this is again something which can be the same for all of the four chains or it could also be different. And then you arrive at the actual leaf hashes of these corresponding operations. Now what we do is we just grow a merkel tree on top of these four hashes and then we end up with a merkel root on the top. Now this merkel root is the actual data that the user is going to sign with the private key. Now what happens during execution is okay, do I have a slide for that? Okay, no worries. Yeah. So what happens during execution is that let's say now that I have this signature, the multi chain validator module is just going to accept as a part of its custom signature format the merkel root, the signature and then for whichever user operation needs to be executed, the merkel proof for that particular user operation.
00:17:26.740 - 00:18:28.532, Speaker A: So what it's going to do is that the first thing that it's going sorry, okay, no worries. The first thing it's going to check is whether the multi chain validator module has been enabled or not. That's the base case. Assuming that has been done, it's then going to verify whether this merkel root has been signed with a known private key or a known address or not. Once it has established the authenticity of this merkel root, then it will verify whether the user operation is actually a part of this merkel tree or not by verifying the provided merkel proof. And once all of this is verified, now the smart contract wallet knows that the user actually did sign over n number of user operations and it is safe to actually execute this user operation on behalf of the user. And this can happen on all four chains in any possible order and there is no restriction or assumption on the contents of these user operations.
00:18:28.532 - 00:19:20.520, Speaker A: All of them can be completely independent in terms of their data. I would say the only constraint here is that you need to know the next nons for the user operations on all of the chains for all of the wallets. So if let's say your ethereum wallet has already executed four user operations, you need to keep a nonce of five here and similarly you'd have to know the next nonsense for each of the user operations. But this is something that we have been thinking about and the semi abstracted nons functionality of the entry point is something that we are thinking about. Like we could probably leverage it to create to solve this. It's still something we are actively thinking about. But yeah, this is how the MultiChain validator module works in practice.
00:19:20.520 - 00:20:46.916, Speaker A: Now, you might have realized that the validation algorithm for this module doesn't actually place a constraint on the user operations being actually from different chains. So in theory, yes, it is actually possible to sign multiple user operations for the same chain with this module. But we feel that it actually doesn't make sense to do this in a lot of scenarios because every smart contract wallet has an intrinsic batching functionality, right? Like you have a function called execute batch on most smart contract wallet implementations. So it's just better to if you want to create multiple user operations for the same chain to do that, I think it's just better to use the intrinsic batching functionality and do multiple operations within a single user operation. Sorry, do multiple executions within a single user operation itself. Now, what are the security considerations around this module? Right, so notice that from the user's perspective, they're actually signing a merkel route, right, which is an arbitrary bytes 32 for a user. There's no way to actually look at this bytes 32 hash and figure out, okay, what is actually happening inside this merkel tree, what are the contents of this merkel tree, unless the DAP actually specifically shows it to them, it's difficult.
00:20:46.916 - 00:21:51.050, Speaker A: Right, but this is actually a concern for normal user ops right now as well, because when the user signs a user operation, a single user operation for the normal case, even then they're actually just signing on the hash of the user operation, which is a similar interest assumption. Right. Although this is also something that we've been thinking around how to solve and would really love to hear your thoughts around if you have anything on how this can be improved. And yeah, lastly, I would just like to explain a potential use case that we found for the MultiChain validator module. And this involves composability or essentially using multiple modules for a single use case. Now, what was the problem? Right, so just to give some context, rage Trade is essentially a perpetual protocol. And this is not the problem.
00:21:51.050 - 00:22:41.370, Speaker A: That's a really good thing. The actual problem is that so what these guys wanted was they are creating a multi chain perpetuals protocol and they wanted to allow a way to provide fund delegation on all of the chains that they support. So essentially a user comes to their platform, they have assets on five different chains. Now, when you're actually staking on a perpetual platform, latency is the key. Like you want to click a button and you want your funds to go inside the protocol immediately. Right? Now, if they wait for the user to sign, it might actually be too late. So they wanted to have a way where users actually give them permission to use a certain amount of tokens in whatever way that they want.
00:22:41.370 - 00:23:33.556, Speaker A: And then this should also be possible for all of the chains that they support. Right. So what are our options? Option one is that let's say there are five chains, right? Let's say that the user deploys the smart contract wallet on five chains. And now what Racetrade does is they just ask the users to give them approval on five different chains and that technically works, right? But what's the problem with is the problem is that you give an approval, but then you never know how long that approval is going to last. You have to manually revoke the approval later if you want it to be revoked, right? Unless you actually use whatever tokens you have approved, this approval is going to stay. So it's not a very clean solution. A slightly more cleaner solution is using SCWS plus session keys.
00:23:33.556 - 00:24:43.436, Speaker A: So session keys are essentially another type of validation module that we created and they're very widely known in the community. Session keys allow you to essentially program any functionality which once enabled, the delegated entity is able to perform on your smart contract wallet on behalf of the user, but only for a very limited time. So by principle, session keys are supposed to be formal and very short lived. Like it's like you gave an approval, but only for five minutes. And the way we implement it is that we just create a module which allows you to which does some validations, but then it essentially returns a very strict time in which it is supposed to used. But while this also works, the issue here is still that the user would have to enable these session key modules on all five chains separately, right? So even though this works, it's still going to be five different interactions from the user's perspective. So what's the final solution? We use FTW plus session keys, plus multi chain validator modules.
00:24:43.436 - 00:25:35.116, Speaker A: The flow looks like this. A user who has never used Racetrade comes to the platform. They essentially deploy five different smart contract wallets through biconomy's SDK integrated into racetrade. But during deployment, they enable the multi chain validator module as the default validation module. Right? Now once this has been done, what Racetrade can do is they can use the multi chain validator module, create five user operations for each of the chains, and these user operations are what are going to enable the session keys. So on step two, ragetrade is able to ask the user for one single signature and then execute five different user operations on all five chains. The session keys are now enabled.
00:25:35.116 - 00:26:31.752, Speaker A: And now ragetrade has access to a certain amount of tokens on the user's wallet for a limited amount of time. And now whenever the user wants to use their protocol, they just click a button and then internally Rage trades servers are able to use the session keys to do the transaction without a signature. Yes, that's how this particular use case works. Finally taking a step back, what's in the pipeline for us? So, ERC 6900 compatibility is something that we've been focusing heavily on and it's something that we'll have something on soon. This obviously includes the features that come with 6900 like hooks and we are looking at different modules. Like on the security side, we are looking to leverage stuff like two FA. There are multiple ways that we have thought about for implementing two FA.
00:26:31.752 - 00:27:44.084, Speaker A: There is stuff around ZK like we could essentially generate some OTPs and then later create a proof that proves the ownership of this particular OTP. But there are other patterns that we'll be looking into for implementing it. And intents. Yes, I had to include it, but yeah, I believe on a more serious note, ERC, four, three seven is something I feel is going to be a part of the wider intents picture. And the reason for that is when I think about intents, right, it could be a very generic thing. I say that I have five tokens and I want them to be converted to, let's say, an NFT right? Now, in my opinion, this could be a collaboration. The way of solving this could be a collaboration between a solver who knows how to convert a particular token to an NFT, like whatever pathways or algorithms that they want to use, and a collaboration between a solver that knows how to deal with ERC, four three seven wallets specifically.
00:27:44.084 - 00:28:33.252, Speaker A: So there are two solvers. One is providing the information around how to actually efficiently do an NFD transfer and another is providing the knowledge on how to do this in a single interaction. Right? So four three seven, I feel, is going to be one of the components to make sure that the Intent execution happens in as little user interactions as possible. And then lastly on the Registry end. So with all of our modules, we've been looking into how to make sure that there is visibility on them. So we've been looking at Rhinestones Registry standard and yeah, we'll be looking forward to integrate our modules into that. And this is our forum.
00:28:33.252 - 00:28:47.310, Speaker A: Feel free to post your thoughts, any discussions, any way you feel our contracts can be improved, or any criticism or any discussions. Happy to discuss on anything on that. Yeah.
00:28:54.340 - 00:29:06.084, Speaker B: Do we have just one question? Thanks for the presentation. Curious to hear about how many user operations have been powered by Economy. Do you have any?
00:29:06.202 - 00:29:09.670, Speaker A: I believe we just crossed 100K, right? We just crossed 100K.
00:29:13.240 - 00:29:19.930, Speaker B: Can you talk more about the execution module? How flexible is it? Like, can I change the execution path later? What are my choices there?
00:29:20.380 - 00:30:15.400, Speaker A: So with regards to our execution modules, it's essentially a way where we so we enable the module and then it's just that the execution pathway is such that the smart Contract is going to call a module and the module is just going to do a callback to the Smart Contract, and the Smart Contract is just going to listen to whatever the module has to say. So say for example, there is a swap module. There's a swap execution module, right. What's going to happen is that the user is going to request that the smart contract wallet use this particular swap execution data for whatever it wants to do in whatever fashion it wants to. And then the swap execution model is going to do a callback to the smart contract wallet so that this particular call data is executed from the context of the smart contract wallet. And this can happen any number of times inside a single user operation.
00:30:15.900 - 00:30:18.612, Speaker B: So it's a module for swap call for callback functions.
00:30:18.676 - 00:30:19.192, Speaker A: Yeah.
00:30:19.326 - 00:30:25.070, Speaker B: Okay. I can add new callbacks to that array that listed for callbacks later.
00:30:28.720 - 00:30:30.530, Speaker A: I'm going to have to think about that.
00:30:34.330 - 00:30:34.694, Speaker B: Yeah.
00:30:34.732 - 00:30:35.320, Speaker A: Okay.
00:30:36.410 - 00:30:56.650, Speaker B: It makes sense. It seems important to tile these different smart contracts together. Have we tried to measure from installative perspective what's there going to be like downtime under big demand under how many requests per second, per second, those type of metrics.
00:30:57.470 - 00:31:17.290, Speaker A: So this is something that we have been looking at. The concrete numbers is something that I haven't looked at at a while, but I should be able to provide it to you offline. I believe we are going to publish the numbers sooner or documentation as well.
00:31:17.820 - 00:31:38.270, Speaker B: Yeah. I'm wondering how scalable is this? If I want to get like million users, can I get and just one more question. How and is the system can it just be like, for instance, if I want to use both products, you and Al, can I do this together?
00:31:38.340 - 00:31:57.910, Speaker A: You can. So across all of our products, there is no assumption being made around which bundler should be used with the smart contract wallet or whether the paymaster should be used with a particular bundle implementation or not. All of our services are independent in the sense that you can just use the paymaster or just use the wallet implementation or just use the bundle.
00:31:59.050 - 00:32:08.358, Speaker B: How you get paid for that? Percentage of gas? You cut into the gassy market. That's if that's your model.
00:32:08.444 - 00:32:08.742, Speaker A: Sorry.
00:32:08.796 - 00:32:19.156, Speaker B: You cut into the gas market. Yeah. X percentage of the gas. Got it. That makes sense. Cool.
00:32:19.258 - 00:32:22.800, Speaker A: Thank you so much. Thank you. Bye.
