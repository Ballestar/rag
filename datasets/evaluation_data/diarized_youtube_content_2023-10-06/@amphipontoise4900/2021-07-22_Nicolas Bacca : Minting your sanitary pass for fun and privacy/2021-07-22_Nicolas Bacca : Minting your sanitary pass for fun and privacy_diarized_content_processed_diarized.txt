00:00:25.890 - 00:01:01.030, Speaker A: Okay, so sorry, I'm just turning on the clock. Please tell me if the sound is correct or not. If it's correct, I can start. So thanks everybody for joining me today for this completely improvised talk. So I will be talking about what you can do with a sanitary pass when you're a blockchain guy, how you can use it even if you are not a blockchain guy. And one immediate application, if you're a developer, would be to design your own application to validate your sanitary pass if you like. So if you don't like to santikovid, if you want a web app to validate your sanitary path, you will be able to code that either right after or during the hackathon.
00:01:01.030 - 00:01:37.438, Speaker A: Who am I? What is this? So I'm a co founder, Nicola Beckett, I'm a co founder at Ledger. I'm currently CTO at Ledger Origin, which is the IoT division of Ledger, which is not that well known. I am interested in open trusted computing. So trusted computing is basically the art of running code of computers that you can trust somehow with cryptography or other means. So when you run something on a trusted computing platform, you can provide a proof to someone else that your code is correct and that the platform is correct. That's more or less the idea. And I like to use trusted computing to add more privacy to different protocols.
00:01:37.438 - 00:02:07.066, Speaker A: So this talk is basically a weekend hack that was not supposed to be a talk at all. So it turned into an emergency talk according to the discussion you see right there last night, because apparently someone consoled. And so here I am. So if you wanted to see another talk, you are in the right room. So that's the talk for today. If you don't like this talk, sorry, that's it. So what's a sanitary pass? So, sanitary pass is a QR code format which is defined by a European standard.
00:02:07.066 - 00:02:40.310, Speaker A: So I will be calling it Digital Green Certificate as well because that's the official name. So you have a link to the first specification as it's a European standard. You have a lot of other specifications not necessarily linked to that one. So this talk is about summarizing the specification, if you're a developer, how to use them, how to read them. So the pass can be useful to get into Ethereum conferences, as you know, or cafe in France. You can have it into the Tusantikovid app and you can verify your pass with a Tusantikovid VERIF. And you are not supposed to run it.
00:02:40.310 - 00:03:34.274, Speaker A: So it might be a good way to understand what the format is because if you read the license of Tucson Tikovid VERIF, if you are not a health professional, you are not supposed to use it to scan QR codes for whatever reason. So that's it. So the problem with that, with a sanitary pass designed as a QR code is that you have several problems. So the first one is of course a security issue. So you have a signed QR code for authentication that doesn't look too great because you have no mutual authentication so everybody can copy it. And I have seen people, I won't give names of ethereum conferences doing that for example, but sometimes they are verified with the naked eyes which means that well, you are basically back to the old KCD with PGP. Just here you replace PGP by QR and well signature by vaccinated because of course if my phone displays a QR saying I'm vaccinated, I am vaccinated without any doubt.
00:03:34.274 - 00:04:00.490, Speaker A: So that's not great. The bigger problem I would say are the privacy issues. So first you have to trust the validation application not to keep your data when reading it. Of course you have absolutely no way of checking that because usually the application is run by a terminal that you don't control. So well you can't really do anything about that. But which data are we talking about? So the most obvious one is your name. So there is your name in the certificate.
00:04:00.490 - 00:04:43.518, Speaker A: Less obvious things there is your age, type of vaccine, vaccination country, issuance and expiration date because so yeah, your certificate is going to expire in about two years. So that's good to know. That's what's in the certificate. But what can be extrapolated from the certificate? Of course you can get your listed venues because if we suppose that the application is keeping lists well it's going to be able to see that time of visit. Then you can see who is attending together, you can see who is eating what and so on. And you can well, it can turn into a privacy nightmare basically if people keep the QR codes and start doing big data or even small data on it. So it's not really great.
00:04:43.518 - 00:05:26.586, Speaker A: So what if we could provide a proof of owning the DGC so either locally, remotely or remotely, which would solve the security issue. Then what if we could optionally link it to a name but on demand and not by default. So that would solve the privacy issue. And we would like to do that without involving at any point sending the digital green certificate to a centralized third party. Because if you do that you basically completely well, you drop your privacy because then everybody can see your certificate and you don't know what the remote party will be doing. So we want to do that locally with trusted computing. So what is going to happen with this? This is what we want to achieve and we will see how to achieve it.
00:05:26.586 - 00:06:13.500, Speaker A: You get the QR code, you give it to a magic trusted computing box which is going to verify it. Then this box will issue a proof of unique validation so that you can't have multiple people scanning the same certificate. You will have the issuance and expiration date because that's still useful to know if you are fully vaccinated and if your certificate is valid, you will replace the name by a hash of your name. So a hash that you can reveal or not if you want a proof of trusted computing processing, of course. Because this data would only be valid if it's run on a secure platform. Since you can then have a route of trust from the secure platform to the DGC and the smart contract will be able to verify this received and mint something out of it. So I took an example of an NFT because I think it's a good example but it could be pretty much anything.
00:06:13.500 - 00:06:59.842, Speaker A: So challenges if we want to do that. So first one which is what we will tackle in the presentation, can we verify the DGC on a trusted computing platform? So is it complex? Can we do it offline so spoilers yes, we can do it offline and no, it's not complex. So is the trusted computing platform open enough to let us check what it is doing? I will demonstrate how to do it on ledger because that trusted computing platform I know the best for some reasons and can we verify the trusted computing proof in a smart contract? Spoilers also yes and people already did it for ledger so my job was really easier. Another spoilers, there is absolutely no code. So I will show you how it works so you can implement it if you want. The code will be coming later. Let's start.
00:06:59.842 - 00:07:26.642, Speaker A: So we are going to read the QR code. So first we scan it. So you get a big blob of text. You can decode with this blob of text with an encoding format called base 45. It's not very common but I think it was basically done for this specification. Then it's compressed to save space so you can decompress it with deadlib which is pretty standard and the result is binary JSON called Cbore. So if you are not familiar with Cbore, I won't dig into it here.
00:07:26.642 - 00:08:03.600, Speaker A: You can do that yourself but it's basically JSON and everything will read like JSON. So if you want to read it in a human readable format, you can do that with the tool called SIBO dump for example from tiny SIBO from intel. But there are probably a lot of other tools to do that. So let's dig into what is over query code. You'll see that you have a kind of an array over there which is well with a lot of other SIBO encoded things. So we start with the first number which is a SIBO tag. So which is going to tell okay, this message is signed that way and this format is defined by yet another specification called Cause.
00:08:03.600 - 00:08:41.398, Speaker A: I don't exactly remember what Cause means but that's in this RFC. So in this message you have the name. So the format of the message protected header, extended header which is empty a payload and a signature. So we see here that the DGC is actually a cryptographically verified item. So that's good because it means that we can make a loop, we can make a link with the trusted computing platforms, we can link certificates together, we can have a cryptographic proof that everything is correct from the beginning. We start digging into the header. So the first part thing is we have only two fields.
00:08:41.398 - 00:09:10.270, Speaker A: One called Algorithm and one called kid. So Kid means we will be able to link back to our key. So first to verify, that's a standard PKI thing. So to verify what is this key, we can fetch a list. So those lists are not really public, but apparently some people are fetching them and putting them on GitHub. So that's good. So here you can get the public trust list for France on this URL, which will list the list of all trusted authorities from the other countries.
00:09:10.270 - 00:09:31.770, Speaker A: So that works well. And the key of this entry is a base 64 encoded key ID that you are reading here. So matching one to the other is pretty simple. Just short break. Let's say you are reading this file. You have absolutely no idea what are the PKcs standard. You see something called Public Key PEM PM.
00:09:31.770 - 00:10:08.614, Speaker A: You don't want to convert it to Dare, pass it and so on. You can just base 64, decode it and take the last 65 bytes and you will get the key. So if you just need to get the key and you are in a hurry, you don't want to spend time reading PEM specifications and so on, you can just do that and you get the key. So once you get the key, you can verify the signature. So to verify so the signature is the signature one that I described before. That's just a shortcut. I mean, you can probably do that with a library if you want, but let's assume that you don't have a library to do that.
00:10:08.614 - 00:10:35.454, Speaker A: You are going to compose the SIBO message yourself. So the SIBO message is an array of four fields. The first one is a string called signature one. Literally signature one. Then by string producted header, by string empty, by string payload, you take that, you hash it, you can verify it against the signature. So the signature in the DGC is Air and S. If you want to convert it to a Dear signature, you have some work to do.
00:10:35.454 - 00:10:57.666, Speaker A: But well, I will leave that to the reader. It's not very complicated. And then well, so when we do that, we verify the signature. We know that the DGC is valid, so we can proceed. If it's not valid, of course we will discard everything because it means that the certificate has been tampered by someone. For example, either to fake the name, fake the Vaccination status or whatever. Interesting part, the payload.
00:10:57.666 - 00:11:31.166, Speaker A: So when we read the payload with CBO dump as well, we see all the data that we need here. So we have the expiration date, which is standard Unix timestamp, issuance date, vaccine information with tagv we have the current number of doses. So well, the doses needed, which is SD here, two current number of doses, DN one. So sorry for his loss. For example, certificate will not be valid to enter, etc. But that's okay. We have TG which specifies which disease this vaccine is used against.
00:11:31.166 - 00:12:08.634, Speaker A: So here it's our beloved COVID. And then you get so that's very nice. You get a standardized last name and a standardized first name. So it's kind of international format that's written in your ID card, I guess, which is great because if you have exotic characters in your language, they are not going to be exotic here. So it means they are going to be nicely displayed by whatever platform you have. So once we have that what the trusted computing platform can do, it can verify that the vaccine is vaccination is okay. So you have the right number of doses and then proceed from there because you have all necessary information.
00:12:08.634 - 00:12:35.030, Speaker A: You could do the same with PCR tests. So PCR tests are also encoded using this format. I'm not describing this. So here I'm just focusing on vaccination. You could do that with PCR test and say, okay, I can have a proof of a valid PCR test. Now, moving to ledger as a trusted computing platform, so it's an open development environment. You can get a link here and see how you are going to write applications from ledger.
00:12:35.030 - 00:13:13.826, Speaker A: The Attestation mechanism that we are going to use here is something that has been implemented from the beginning but not really used today. So the idea is that you can provide a proof of what is running into your ledger. So you will do that by signing whatever application data you want with a code hash of the application that's running. So here you have a proof that you are running the correct version of the application because you can compile it yourself, verify the hash. This is going to be signed by the device Attestation key, which is generated when you run the Attestation mechanism. And optionally you can sign that by ledger issuance key. So you can do your own Attestation scheme yourself.
00:13:13.826 - 00:13:56.462, Speaker A: Meaning if you want to do that with your own certificate, your own set of ledger, or your own set of friends owning a ledger, you can do it. But here we are moving one step further and we are saying that ledger is going to be generating that key because then we can verify everything from an external point of view. We can verify the device is genuine. That's the first part. And we can verify that ledger has been providing the key. So we have a complete link from the issuance, from the issuer ledger, to the platform, to the digital green certificate. So what is the application going to do? It's going to read the digital green certificate, an Ethereum address that it's going to send the certificate to.
00:13:56.462 - 00:14:44.558, Speaker A: So that's nice to provide it because then we can display it on the ledger or we can have the user verify it and we have approved that the certificate has been sent or not to someone else. So I'm not in this model, I'm completely debatable but I'm not preventing people from sending the digital green certificate proof to someone else, which doesn't make much sense, but then we can verify that it still belongs to the original owner which makes sense because you can't transfer your vaccine. So you're still able to transfer the NFT but vaccine is harder. You are going to provide a privacy password. So privacy password, I'm going to explain what it is. The application will verify the DGC, pass it and issue the following data which is described on the other side. So you will have an NFT token ID which is standard for 721.
00:14:44.558 - 00:15:50.034, Speaker A: The token ID is going to be here, a Sha 256 hash of the payload of the digital green certificate which makes it super easy then to avoid duplicates because since you can't create NFT with the same token ID by design here you have an automated way to prevent duplicated certificates from being passed into the system. You are going to have the Ethereum address that you provided, sha 256 hash of your first name, so standardized, last name standardized and the privacy password. So if you want to reveal it to someone, you would have to reveal the free elements and then someone could verify your name, issuance date, expiration date. We sign that so that's part of the so this makes the attested data, we create the Attestation signature and we provide then all the other elements to verify the Attestation. So the code hash Attestation public key and signature of the Attestation public key by ledger. When we have this, we have the link I was talking about and we have the complete loop from ledger to the DGC. Now what is the smart contract going to do? So just high level code here.
00:15:50.034 - 00:16:25.450, Speaker A: No code, just description. Smart contract is going to verify that the receipt format is correct. So that just verifying that it looks like what it should be. Then it will verify cryptographically that the device attestation public key is signed by ledger. Then third step, it will verify that the receipt data is signed by the device attestation public key. Once we verify that we know that everything is genuine and we can trust what we received, then we can mint, we can mint to the address that we have in the received, we can use the token ID and we will store the original address. So this looks, I mean the only hard part in that is the verification of the Attestation.
00:16:25.450 - 00:17:20.398, Speaker A: And luckily for us and for shitty solidity coders like me, the hard part of the job has already been done by Provable. So provable formerly known as Oracle. I'm not supposed to say that name so please don't sue me but you have a link here to the API and it's well done and you can just copy and paste and that's what I am going to do to verify it in my smart contract. So when I said I have no code, I lied a bit. I mean I have code working in hard hat but well I want to clean it up before publishing it. So then what can we do with that? I think the first thing which is, well, definitely the most useful we can provide a single tap proof that the NFT has been issued for the correct address, for the correct key. So we can provide a proof of the Vaccination certificate which is much better than what we have today because we can prove it cryptographically and we won't reveal our name by doing so.
00:17:20.398 - 00:18:16.718, Speaker A: For example we can just sign the current timestamp, display that as a QR code. Then you just have to look back on the blockchain that on this address you have the NFT. You can verify that you own this address because you can verify the signing of the timestamp and you have a solution which is much better than the current one and not more complicated to use because from user experience point of view you just have to scan a single cure. Another nice ID? No, sorry it was just completely stupid ID but it was fun to write if you have a slowkit powered door because who haven't for example installed at Pfizer lab you can only open it if you are vaccinated with the right vaccine. So it would be a good use case for slowkit I guess. And well if you have another ID, please feel free to come to me with the ID because I'm sure it will be better than the last one. Next things to do so we can support more trusted computing platforms.
00:18:16.718 - 00:18:59.200, Speaker A: If you are a fan of SGX, please do that, please use it to support that kind of logic. It would be nice to see, especially since I think with a new ECDSA Attestation you can verify an SGX proof on a smart contract. I never did it, but there are a lot of people on that field playing with SGX for good or bad reasons so well please try it and I would really like to see the same thing with the zero knowledge proof and pure math. Problem is I am very bad at that. So if someone has a better idea and a very big brain well please feel free to contribute. Contact me, show me what you can do, that would be really great. So workout soon? I said likely next week.
00:18:59.200 - 00:19:10.740, Speaker A: I will be pointing to it on Twitter so if you want more information about that you can just follow me on Twitter and well I will have some time for questions. Thank you.
00:19:20.890 - 00:19:36.362, Speaker B: Just to be clear, I'm not really sure to fully understand what's the benefit on the privacy side because the door still needs to look on the blockchain so it still could collect what you have done before.
00:19:36.416 - 00:19:51.700, Speaker A: It can collect your address, it can collect your ethereum address, it can't collect your name. So if your ethereum address is linked to your ENS then yes, you have an issue but if you mint it to something that's not connected to your name then you're in a better state than before.
00:19:59.350 - 00:20:01.060, Speaker B: It. Any question.
00:20:13.040 - 00:20:51.800, Speaker A: Is it possible to fake the certificate, the vaccine certificate so it's not possible to fake it? If you trust in cryptography, if you don't trust in who is owning the keys then it's completely possible to fake it. And we have seen that for example, the easiest way to fake it is just to give money to someone that will issue you real fake certificate. So certificate with fake name but signed by the right key and of course there is nothing we can do about that so well, we can't solve that but at least we can know that we can map cryptographically proven certificate to something else which is more private.
00:20:57.900 - 00:21:27.180, Speaker B: Question in order to solve that trusted vaccine problem could we not combine a biometric at the time of taking being given the vaccine and combine the biometric with the vaccine certificate?
00:21:28.320 - 00:21:58.216, Speaker A: We could imagine doing that then that would solve mostly I mean verification because it would mean that we guarantee that when we verify the certificate in that case we are not sending the key used to verify the certificate to someone else. So that's an additional step that prevents people from sharing the key that was used to generate the DCG. So that's an additional step I would say, but client side because then we wouldn't use that on the blockchain but on the client side definitely that could be an improvement to avoid sharing the key.
00:21:58.398 - 00:22:02.532, Speaker B: Yes. So you then have to avoid sharing.
00:22:02.596 - 00:22:39.110, Speaker A: The biometrics on and the difference is that one thing you can do to improve that you can have different level of proofs. For example in the receipt that was in the receipt that is generated by the trusted computing platform here you could have an additional flag that says the quality of the key, for example, that this key is bound to a biometric parameter and so that this key is not supposed to be traveling. And according to the level of proof that you want, you could say okay, I'm only trusting keys that are generated using that scheme or I am trusting all kind of keys. So that's something additional you could add.
00:22:47.100 - 00:23:30.240, Speaker B: Thank you. So far we're talking in an hypothesis where whoever is doing the test is genuine. So essentially, your approach is to validate that the data initially is correct and then find ways that people can review. I mean, it's early, but it seems, at least in France, that there is a significant market, let's say for healthcare professionals who produce real fakes in the sense that they will follow all the verification procedure, but they don't inject you with the vaccine or whatsoever. Do you see any solution to validate the data even against the operator?
00:23:30.400 - 00:24:34.680, Speaker A: So I don't think there is a solution to validate the data in that case, but there would be a solution to revoke the certificate in that case, which is, in my opinion, better. Because today we don't really have ways to revoke on a fine grained basis, I think, because we can neither revoke the whole certificate with the whole group of trust, which wouldn't be a good idea, but if we could revoke by individual certificate ID. And we do have individual certificate ID, by the way, either in the format here I didn't talk about it, but ty in that is supposed to be a unique identifier. So we could think that at some point on the board, I mean, on whoever is testing, we would have a list of blacklisted certificates that would be rejected and then this list can be cryptographically signed by anybody else and we can incorporate this into the trusted computing platform. So of course, you have the problem of knowing if you provided the right version of the blacklist or a previous version of the blacklist and so on. But that's an additional problem to tackle. But well, at least we could do something.
00:24:34.830 - 00:24:39.630, Speaker B: I see. Yeah. Thank you. We have time for our last question.
00:24:40.480 - 00:24:41.036, Speaker A: Yeah.
00:24:41.138 - 00:24:52.300, Speaker B: If we have the time, could you clarify how the smart contract knows that it's the right code that perfectly checked the certificate?
00:24:52.380 - 00:25:31.544, Speaker A: Also? That's quite easy because the device itself is computing the code hash of the code which is running on the platform. So the code is open source. You can compile it yourself. You can verify that the code hash is correct, so you know, so you can do the link between what is verified and what is running inside the device. And then the smart contract will just verify the code hash here because it will be present in the receipt that is sent by the device. So you can do it, I mean, either hard code it or put it in a way that is going to be modifiable only by the owner or well, you can do pretty much anything, but it's just a comparison in the end. Thank you.
00:25:31.742 - 00:25:33.130, Speaker B: Thanks for the question.
00:25:33.500 - 00:25:33.990, Speaker A: Thank you.
