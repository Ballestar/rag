00:00:00.730 - 00:00:30.774, Speaker A: Try. No, it does not work. Okay. Hi, everyone. Thank you for joining me today. I'm Gila Castell novo. I'm a director of Engineering at Sertora, and I'm going to show you today how you can use the Certora tools to protect your code.
00:00:30.774 - 00:01:19.558, Speaker A: And we are going to go over some examples from some basic property checking on ERC 20 protocols to detection of common vulnerabilities, such as read only re entrance. Before I start, I'm not sure if you are familiar with Sertora. Certora is a security company. We implemented the Sertora Approver, which is actually a tool which is based on a formal verification. And the goal of the tool is to prove properties and detect bugs. So before I even start, I want to ask here who heard about formal verification before this talk? Okay, cool. That's cool.
00:01:19.558 - 00:02:26.170, Speaker A: And how many of you know what formal verification actually is? Okay, cool. So for those who do not know, formal verification actually is a technique to prove properties on code. A property in the area of DeFi can be. For instance, then for every transaction, I want to make sure that no user is spending more money than his balance. And the way that it works with our Approver is that you define the property in the specification language, which is for the Certura Approver is the CVL, which is a Certura verification language. And then you take your code written in the solidity and you then let the formular verification engine try to prove the property or find a violation. The way that it works behind the hood is that the specifications and the code are translated into a mathematical formula and then math and formal methods are used in order to prove the property or find a violation.
00:02:26.170 - 00:03:42.530, Speaker A: So now that I said that, I have another question. How many of you sorry are actually using formal verification as a tool for security? So nobody? That's my point, actually. And I want to ask you why? And maybe this is because you think that you need a PhD in order to use formal verification, or maybe because you think that formal verification is nice, but it can only prove trivial properties. And another option is that maybe you think that formal verification is good for some property checking, but you do not think that it can prove or find sophisticated vulnerabilities in your code. So in my talk today, I want to break this myth with the Sertora Approver. I want to show you some examples of Sertora specifications and usage of the Sertora Approver. And we will go from immediate properties on protocols to some detection of vulnerabilities, such as Readonly reentrancy.
00:03:42.530 - 00:04:30.098, Speaker A: So I will start with the first myth. As I said before, some people think that you need a PhD to use formal verification. This is actually a joke, but there is some truth behind it because people think that since it's based on math and it's based on theorem checking. So you actually need a special background which includes mathematics and logic. And I want to show you how actually it looks with the Certora Approver and with our language. So let me start with a simple example, which is an implementation of the ERC 20 protocol. And I implement my own version of the transfer form function.
00:04:30.098 - 00:05:17.246, Speaker A: And I want now to check some properties on it. One property, for instance, can be the integrity of the transfer. I want to make sure that every time that I'm sending money between the sender and the receiver, the sum of the balances is not affected. This is actually something quite basic, but I want to start with this property just to exemplify how it works. So let me show you how I wrote my rule with the CVL language. As I told you before, the CVL is the Certora verification language and you just need to write rules and run the Certura Approver to check the rules on your code. So this is how my spec looks like, okay? This is my rule.
00:05:17.246 - 00:05:59.802, Speaker A: This is the integrity of transfer. I have some parameters in it and I have the sender, the recipient and the amount. And then what I do, I just sample the balance before calling the function. Okay? So I said before, we are sampling the balance of the sender and the receiver in the beginning of my rule and afterwards I'm just calling the transfer from function, asserting that the sum of the balances stayed before stayed the same. So, as you see here, this actually looks like unit testing. It's very similar to the solidity code. It's quite straightforward.
00:05:59.802 - 00:06:50.606, Speaker A: But this is not unit testing, this is formal verification, which means that I'm checking any options, any arguments that can be sent to the transfer form function will be checked and also any amount will be checked. This is because formal verification is exhaustive. It takes into account all the possible valid inputs and just proves mathematically that the rule holds. So once the rule is proven, you can be certain that this specific rule will be true for all the specific paths and inputs that can be given to the transfer for function. So, okay, maybe this was not enough. Maybe now we are thinking, okay, so this was a trivial property, ERC 20 and you are not convinced yet. I want to tell you a story.
00:06:50.606 - 00:07:58.374, Speaker A: Okay? So maker is one of our customers and one of the things that maker did, they implemented the maker die stablecoin. And one of the most important properties of the maker die stablecoin is the fundamental equation of Dai. This equation actually makes sure that the balance of the Dai are always backed by debt. Okay? This equation actually says that the sum of the balances of the user is equal to the sum of the collateral plus some fixed amount, which is in the responsibility of the token itself to cover it. So the maker dice tablecoin was actually deployed in 2019. And what happened when Maker started working with us? They wanted to use the Tertora approver in order to check this environment with our language. And what happened is that surprisingly they found out that this environment did not hold on their own protocol which was actually deployed for three years.
00:07:58.374 - 00:08:44.930, Speaker A: Okay, so fortunately I want to say that this specific invariant and this specific bug was not exploitable. So no funds were at risk and of course Maker fixed it pretty immediately. But ECDs actually exemplifies and emphasizes why formal verification is so important because sometimes even this 0.1% of inputs that you are not checking can hide behind them like a very important bag can lead to a steal of million of dollars. Okay, so this is actually how the rule looks like in CVL. This was actually implemented by Maker themselves. There is a public repo that you can go and find it yourself.
00:08:44.930 - 00:09:47.358, Speaker A: The way that it works here they implement an invariant which is actually a rule which is checked for all the status in the contract, which means that we are like proving the invariant by induction. Every time that the function is called, we will check that the invariant still holds. And you can see here that they just implement the same equation as they wrote before. This is the fundamental equation of Die. There are some technical details here that you can find in our public repo. But very briefly they are using here what it's called the Ghost, which is like a function which is not implemented in the protocol itself, but actually you can implement yourself into your specifications and you just need to write the code which updates the function to model the behavior of the contract. So this was actually a very important example, but it's still about property of a specific protocol.
00:09:47.358 - 00:10:54.254, Speaker A: We did not get into common vulnerability that you might be interested in checking. And for instance, one vulnerability which was very hair during the last year is the read only reentrancy one which was actually presented last year by the chain security. And actually what happens when you have a read only re entrance, there is a bug here in the presentation. So what happens here is that a bad intermediate state is exploited through an external call to another contract. This actually happens when a contract is calling an external call while having a dirty state and a malicious attacker can actually use it to mislead another contract regarding the state of the vulnerable contract. And this will happen using a view function. So this vulnerability actually put in risk more than $100 million.
00:10:54.254 - 00:12:06.706, Speaker A: So it's a very important vulnerabilities. It was also reported in Wrecked several times. But I want to think together with you how you can actually define this protection in specifications. What should I want here? I want to make sure that every time that I'm calling an external call, my intermediate state is valid okay, but what does valid mean? Because it can also be to lead to false positive because I can also update my internal state but it does not affect anyone okay? So once I want to make sure that every time that an external function is called sorry? Every time that an external function is called all the view functions are returning a valid state. And what I mean by valid I mean that this is equal to the beginning of the transaction or to the end of the transaction. This is something how I implement my properties in words. But when it comes to CVL, this is also quite simple.
00:12:06.706 - 00:12:57.186, Speaker A: Okay? This is my rule. This is the no read only reentrancy rule. And what I do here, I just sample all my view functions, external view functions that I have in my contract. Afterwards I will call any function external function that I have in the contract and in the end I will sample the same view function again. And what I want to make sure is that in the end, the value or the intermediate state that might be returned by the view function is either equal to the beginning of the transaction or to the end of the transaction. Of course, I'm omitting here some technical details, but of course you can find it in our repo and there is all the explanation regarding that. We actually implemented it in our own version of the Corve protocol.
00:12:57.186 - 00:14:02.266, Speaker A: And of course, this rule found the vulnerability and the most interesting thing that first of all, as you can see here, we are testing all the external functions that we have in the contract and all the view functions. But more than that, once we find a violation, we can say exactly which view function is the problematic one. And once we have it, we can also explain to the user how to fix it because we know that gas is kind of expensive, but you can put actually a reentrancy guard only in the vulnerable view functions and not in all the view functions that you have in your contract. So this is actually the end for the read only reentrancy. And this is actually I'm getting to the end of my talk, but I wanted to give you some takeaways. Okay. First of all, I hope that I kind of convinced you that writing CVL specification is not as difficult as you may think.
00:14:02.266 - 00:15:39.500, Speaker A: And secondly, we also saw here a real example when formal verification is applicable on complex protocols. And lastly, we saw here also an example on how formal verification can find sophisticated vulnerabilities such as the read only reentrancy one. So you can find a bunch of more examples in our Pagvreques that we are updating all the time in these very dates. And you can also start using our tool. There is a barcode here which does not work and I'm not sure why because I see it here, but actually we just released the pay as you go option, which is actually you can start using a trial version and just pay for the usage of the prover. So this should make the proverb much more accessible to whoever wants to try it. And I hope that you enjoyed I'm very sorry about the technical issues that we had here, and if you have questions, I am not sure that we have time, but it.
