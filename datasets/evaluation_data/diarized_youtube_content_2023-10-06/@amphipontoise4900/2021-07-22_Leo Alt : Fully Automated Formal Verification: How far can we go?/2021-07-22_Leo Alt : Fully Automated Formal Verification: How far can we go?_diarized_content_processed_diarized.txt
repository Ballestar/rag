00:00:00.650 - 00:00:06.400, Speaker A: Is being live streamed. I'm not sure about the live stream or.
00:00:27.540 - 00:00:40.804, Speaker B: Good morning. Congratulations on being here that early. Yeah, it's early. I'm kind of slow. Maybe Martin is too, but we'll make it. My name is Leo. This is Martin.
00:00:40.804 - 00:01:38.248, Speaker B: We work with form verification at the foundation. Yeah. And we wanted to go through the idea of fully automated form verification and see how far we can go in terms of verifying actual real world contracts as opposed to toy contracts, which we do play a lot when developing new features and fixing bugs, these kind of things. So I'm going to start talking about some experiments and then Martin will take over to talk about some hevm internals, which is one of the tools we're going to talk about. And a heads up right after this talk, martin will lead a formal verification workshop right across the hallway at Room biev, or however it's pronounced. So we're going to be moving right away after this talk over there and run a few live demos and also chat more about everything. There's a lot of overlap between these two talks.
00:01:38.248 - 00:02:34.012, Speaker B: Do you want to say anything at first? So the goal of this experiment was to run over a few examples and see what we can get from fully automated formal verification tools. So how many people here understand this overall? Okay, cool. So this is the first contract we're trying to verify. It's a solidity token contract, a very simplified version of the usual, ERC, 20 contracts we have. Of course, I removed a lot of stuff here because I wanted it to fit on the screen. So here we have the basic constructor that basically sets whatever amount to the owner of the contract, which is the sender. And here we want to verify functional correctness of the transfer function, which just transfers certain amount from the message sender to someone else.
00:02:34.012 - 00:03:04.488, Speaker B: And then I verify that the sum of the two balances does not change after this transfer. So we want to verify that this assert is true. It must always be true. Otherwise we have a bug in our program. The second one is an AMM so an automated market maker, which this is also a very simplified version of. And this contract, you can find this kind of contract in uniswap and other exchanges where you can swap one token to the other. So in these contracts, usually.
00:03:04.488 - 00:03:50.512, Speaker B: So this is an example that I took from David Terry, also from the Fort verification team. So here we have the contract that has two tokens that we want to be able to swap, say, for example, Dai and USDT. And some actions you can do in this contract are you can join the contract giving a certain amount of each of the tokens. You can exit the market or you can swap one token. Where is this? You can swap one token to the other. And the price for this swap is calculated over this constant formula that we have heard so much about, x equals x times y. And we want this constant to never decrease.
00:03:50.512 - 00:04:33.620, Speaker B: So this is the property we want to prove statically. The next example is going to be the deposit contract. I'm not sure how much you can read from this, it's quite a lot of code, but this is not a simplified version. So this is the actual deposit function from the deposit contract that was deployed last year. So the deposit contract is the ETH two deposit contract where validators must deposit at least 32 ETH to be able to be a validator on the beacon chain. So this deposit contract has a merkle tree of all the validators and it was formally verified by runtime verification. We have Ricard here, I'm not sure if he worked in it, but he works for RV.
00:04:33.620 - 00:05:26.404, Speaker B: And they first verified the Viper version and then the team that coded the country decided to swap to solidity because of gas costs. And yeah, this is the final version and we want to prove that this assertion here, the end of this function is never reached. So we want to prove that this loop always terminates inside this branch here. The next one is a snippet from the open Zeppelin implementation of the ERC seven seven token. What this token does is it's basically a normal ERC 20 token. Plus it has the feature that it calls back both the receiver and the toker whenever a transfer is made. So there's this interface for the sender for the recipient and both of these functions in each contract, if there are contracts, they are called whenever there's a transfer.
00:05:26.404 - 00:06:22.420, Speaker B: And the property we want to verify is that whenever these callbacks are called. So here tokens to send tokens received. We don't want them to mess up with the total supply of the token. So these two properties are what we want to prove. Okay, so the experiment is basically to try to run some tools that are fully automated or almost fully automated, basically relying on a small and simple specification where so far it only shows specification in terms of the assertion that we want to prove is always correct. But some of these tools will require a little bit of a spec. And if a tool is not here, it's because it either requires a more complex type of specification like K for example, or they are not fully publicly available, which I wanted to for this experiment because I just had a script that ran everything.
00:06:22.420 - 00:07:09.830, Speaker B: So I wanted to just have a binary and run stuff. Okay, so the tools that I ran here were Mithril, which is a symbolic execution tool for AVM bytecode. It's very fast but also very simple. It does simple things, HVM, which Martin will also talk about later. It does symbolic execution similarly for EVM bytecode, but also invariant testing, which Echidna, which I never know how to pronounce it echidna also does invariant testing and then finally the SMP checkers also verify and very smart try to do unbounded model checking. So fully complete and bounded model checking, but on top of solidity code, it doesn't handle EVM bytecode, only high level solidity code. And we want to run these tools and see which ones can prove or break the properties I wrote before automatically or with a little bit of spec.
00:07:09.830 - 00:07:18.280, Speaker B: So hope you can guess which tool could either prove correctness or find bugs in all the examples that I showed.
00:07:19.660 - 00:07:20.970, Speaker A: SSC second.
00:07:23.340 - 00:08:30.716, Speaker B: Any other guesses? What about false positives? Now I spoiled, sorry, without false positives? Well, my question was related to without false positives. So here's the answer none of them did it. One possible reason is not only automated, but form verification in general is undecided, which means that there's no possible algorithm or anything that will solve every single instance of a form verification problem. So that's it okay, so it's undecided we can't really solve for general case. So there are several different approaches that have different pros and cons that a lot of people develop in the wild. And one very common approach is to either target VM bytecode or target solidity high level code. Some things against the approach of targeting solidity is first of all, you have to rely on compiler correctness, so everything you're proving, you're proving a high level, not exactly on the bytecode you're deploying.
00:08:30.716 - 00:09:21.360, Speaker B: So you still have to rely on the compiler being bug free. And there's lots to encode high level features, there's various data types, pointers, inheritance, there's just all sorts of really complicated stuff that's hard to encode when generating the formal model of the contract. Some pros of this approach are you have a lot more structure and information in the program, so you know what loops look like, you know what external calls look like, you know what state variables look like, so it's easier to simplify the problem. Sometimes the structure of the theorem you try to prove afterwards is just look simply in general and this enables you to try harder problems that have loops, contract invariants and all sorts of complicated stuff. And out of the tools that I mentioned before, descent pitcher is also verifying. Very smart adopt this approach. The other tools, they target EVM bytecode.
00:09:21.360 - 00:10:06.456, Speaker B: Of course, the first and foremost pro of this approach is that the results are basically what you deploy, right? You don't have to trust the compiler, you don't have to trust, of course you still have to trust the tool that verified it, but you just reduce a lot level of trust that you need regarding a property. And it's generally easier to encode because you just have, you have stack memory storage and you don't have all sorts of complicated stuff from the high level language. Some of the problems here are basically the opposite of the other approach. There's not a lot of structure. So a state variable that just looks like X in the other one, it's a number. Here it's going to be a slot in the entire storage. So it's much harder to track storage, external calls, functions and all this kind of stuff.
00:10:06.456 - 00:10:57.070, Speaker B: Another thing that gets a lot more complicated here is that the abi encoding and decoding oh, sorry, abi encoding and decoding code is all in the bytecode as well, whereas in the solidity code you don't have that code. So when you start a function, you assume that the call data is going to be translated correctly into the types in the signature of the function. You don't have to deal with that at all, so it's a lot easier. So the experiment is use each tool in each example first automatically, just tool example, see what you get, and then try to power use the tool. So learn a bit more about the tool. And I think on average I gave myself basically like an hour per tool, for example, to run it automatically. Then learn the parameters, learn how the tool works more or less and try to get something stronger out of the, out of the tool.
00:10:57.070 - 00:11:23.380, Speaker B: By the way, all the examples that I'm showing here are in this repo as well. Maybe not exactly a bit changed, but you can find it. There also the presentation itself. Okay, so first trying to prove functional correctness of the transfer function. As I said, we want to prove that. So we have the person who wants to send funds and the person wants to receive funds or a contract. They cannot be the same.
00:11:23.380 - 00:11:53.392, Speaker B: And the master standard must have the amount they want to send. So we compute what the sum of their balances is before we perform the transfer. We compute the balance of their sums, the sums of their balances after, and then it say must be the same. Is that correct? Depends on your certain. But which one could overflow balance? Two. But if we overflow, if it overflows, it just stops execution here. Oh, yeah, sorry.
00:11:53.392 - 00:12:24.936, Speaker B: Yeah. So this is what is your eight? Yeah. So overflow doesn't exist at this point at least. Okay, so overflow and underflow, reverts early said that, is that correct? Yeah, that's correct. Right. So if we just run tool token, sol, these are the results we get. So all the tools can either prove that it's correct or eCNA doesn't issue proofs.
00:12:24.936 - 00:13:10.484, Speaker B: But it didn't find any bugs, meaning didn't give any false positives, at least in the 50,000 instances it tries by default. So what if we make the transfer function buggy? Like what is the bug here? Go ahead. Right, so this one is wrong, right? We're basically giving more to the sender himself, themselves and this one's correct. But yeah, there's too many tokens here and this should fail. Right. So just running the tool on the example, this is what we get. So these four tools okay, meaning they found the bug and they give you a counterexample.
00:13:10.484 - 00:13:52.250, Speaker B: Meaning they tell you how to break the assertion and what the state is when you break it. Saucer if I did break the assertion but it could not give a counterexample and Verizmite did not break the assertion, I suspect it is because I suspect very smart doesn't really check assertions by default, even though it does claim to do so in the documentation. That's why I tried it, but I don't know, because in the log it even says there were no assertions to be verified. So maybe this is solidity eight thing, I don't know. Okay, sounds good. So the next one mm swap functional correctness. We want to prove that this assertion is always true.
00:13:52.250 - 00:14:27.034, Speaker B: Is it correct? Okay, we can go through a little bit. This might be a bit complicated. So the goal here is so someone calls a swap function. They want to swap this token for this token, right? These two tokens must be these two here. Just the order doesn't matter, but they must be the same as these two and that's what these requires here to do. That's it. Then the way you compute the price for the swap is basically always trusting this formula here.
00:14:27.034 - 00:16:04.220, Speaker B: You want this k equals x times y where x is the balance of the market itself in token zero and y is the balance of the market itself in token one. So this cannot decrease because if it decreases with time, it means that the market itself is losing money, right? So we first compute what the current ratio is, what the current multiplication is, then we transfer to the market from the sender the source token they want to swap to the contract, give to the contract, which means that now the contract has more source than before, right? Then now we want to compute how many destination tokens we want to give to the user or to whoever called the swap function. So we take k, which is the previous multiplication with both old balances divided by the new source, the new amount of source tokens that the contract has, which is going to give us this is just the same multiplication. So this is going to give us the new amount of destination tokens that the market has which must be less than before, right? Because one increase or the other one must decrease. Then we just subtract there's a minus here, it's a bit right? We just subtract it from the previous amount of tokens the contract had in destination token and this difference should be the amount we give then to the user. Then we compute the same multiplication again. This must not have decreased, otherwise the market lost money.
00:16:04.220 - 00:16:29.620, Speaker B: Is this assertion correct? Any other guesses? I mean, only other guesses? No. Okay, so we're not going to solve it yet. So that's why the trigger mark. So first one is while execution and model checking tools. They could not tell us anything. They did not prove the property, but they also did not disprove the property. Meaning they just say, I don't know.
00:16:29.620 - 00:17:02.534, Speaker B: So the next thing we can try is fuzzers. So here's HVM and here's Echidna. And actually both of them did break the assertion. And here's how. So HVM, actually, if I would have used a verbose mode, it would also have given the full list of functions. But here it just gives you a simplified look at the call data needed to break the assertion. And here eCNA tells us that you can very easily break the assertion by first calling join, then calling swap.
00:17:02.534 - 00:17:46.362, Speaker B: And this looks very simple. Okay, so the assertion is actually not true, but what did I have to do to actually get this? So this required a little bit more work than just the contract itself. So HVM works with DS test, which you can see here. And instead of verifying things in the contract itself, we want to write a test that uses the other contract and then tries to verify something on top of it. So here we have the same contract before, but I changed the k prev and post to be state variables instead of local variables. And you can see that for the first iteration both are zero, right? And for the second iteration this one is going to have ground. So it should be true.
00:17:46.362 - 00:18:15.406, Speaker B: Also, of course, it's more expensive because now there are state variables, but for the sake of proving the property, it should be equivalent. And here we have a function called invariant k, which is a view function that basically asserts the same property. So this is just the same as before and here just gathers for the two variables. So to use Hevm fuzzing in this case. So we have a setup function that deploys the two tokens. We create an AMM. With the two tokens, we create three users, which you will find in this repo.
00:18:15.406 - 00:18:53.262, Speaker B: Just didn't have space here. But what the users do, they're basically just interfaces to call the join, exit and swap functions in the other contract, they just relay the calls and then this contract was the owner of the two tokens. They just mint a bunch of tokens to the users and then just let them do whatever. And Htpm fuzzing also requires, well, you can use this feature of the target contracts here. It's a function that returns a list of addresses, which are the addresses that are going to be used as the interface at the front end for the fuzzing calls to be generated. That's it. And then we have this.
00:18:53.262 - 00:19:17.842, Speaker B: So invariant fuzzing in Hevm, it runs functions that start with the word invariant. And basically this just calls the invariant from the contract itself. And then if this assert fails, it is going to fail. And then you get the result that I showed before to run this with the kidna. It was very, very similar. I used pretty much the same users, the same Tas AMM. I only didn't use the target contracts.
00:19:17.842 - 00:19:37.614, Speaker B: And Echidna invariant fuzzing needs the function to start with Echidna. And the difference is that it doesn't check for assertion failures. In this case, you need to return a bool. So basically, instead of asserting, you just return whether the invariant is true or not. And that's it. And that was the result that I got before. Okay, so the contract was wrong.
00:19:37.614 - 00:20:12.610, Speaker B: I think my next slide actually tells how to fix it. Does anyone have any idea how to fix it? I'm going to go back for a second. You know the answer. Okay, so the fix requires two characters. I'll show you the hint. So the property that you actually want is sorry. The property you actually want is that k post equals k.
00:20:12.610 - 00:20:34.068, Speaker B: But for some reason this cannot really be true all the time. That's why we say it's fine if it's greater, we just don't want to lose money. But ideally, in an ideal world, this should be equals and not greater or equal. Yeah, getting there.
00:20:34.154 - 00:20:45.220, Speaker A: What's the joint function in the kidney? Sorry, what's the joint function? Joint and swap.
00:20:45.380 - 00:21:10.736, Speaker B: Right. So the joint function, basically you give both tokens to the market. Yeah. Then you get like a share of the of the market. Then when you exit, you get tokens back based on your share of the whole pool. So it's going direct direction. So the thing is, you have integer division here.
00:21:10.736 - 00:22:06.992, Speaker B: So sometimes this division is not going to be an integer result, which means you have to round the output and this is a solution with this plus one. So this is how it is actually implemented, at least in this version of the contract. Yeah, because of rounding, basically. So basically what this does is if the division is integer, then the property is equals, so no one gains or loses more money. But if the division is not integer, then the rounding goes to the contract, to the market. And that's why k can grow, but it can never decrease. So now both fuzzers say, okay, everything's fine, and yeah, so that's how as far as we got with this example.
00:22:06.992 - 00:23:09.972, Speaker B: So the model tracker still could not prove anything, but the fuzzers can now give us good confidence that it is correct. Let me just see how much time I've spent. Did I spend 20 minutes already? Okay, I'm going to try to speed up a little bit. So trying to prove functional correctness of the deposit contract, we want to prove that this assertion is false. So running all the tools just like this, just with the contract as is also no tool could prove anything. You get false positives, you get I don't know what's happening, all kind of results, but we can try different things. So when running, actually, when running HVM on this function, the main problem is that in the original contract, you can see that here there's three parameters that are dynamic bytes and hevm doesn't support symbolic dynamic types in the input of functions it wants to reason about.
00:23:09.972 - 00:23:55.830, Speaker B: But here you can see that these dynamic bytes, they actually must have a fixed length, all three of them. So pub key must have 48 bytes, with Rock credentials, 32, signature must have 96. They could be fixed types. The reason why they're not is historical when converting the contract from Viper to solidity and yeah, I'm not going to go into too much details we can talk after, but yeah, there's a historical reason for that. But effectively they could be fixed fixed byte types. So that's what we change here for Huvm. So instead of having a byte that must be 48 in the require, we can make the pub key three bytes 16 variables, which is 48.
00:23:55.830 - 00:24:59.396, Speaker B: Withdrawal credentials was already 32 and signature was 96. So we make three bytes, 32 variables and we can remove all the other requirements because now the length is guaranteed by the Abi decoder just with this change. The rest is all the same here. So HVM can now prove that the assertion cannot be violated. And it proves that after exploring 295 branches of assertion violations and you may ask, well, what about the for loop? How does hevm know that the loop? Like, does this include all the loop iterations? And it actually does, because if you take a look at the contract, you'll see that the loop is actually bounded by constant number and it can only run 32 iterations, not more than that. And hevm by default sets to 50 the number of times that an EVM CFG node can be rerun. So we know that here all the loop bounds, all the loop durations are covered.
00:24:59.396 - 00:25:55.372, Speaker B: But of course this includes internal knowledge about the tool, right? I know that it's 50 because Martin works in the tool and he told me it's 50. So if you don't know that it's 50, then you could also use a parameter called max iterations for Hevm, which I did try, but then it failed. It took too long, I don't remember why, but there were reasons it proves like this. So we're good running the model checkers, they also couldn't do much, so various all couldn't do anything. And with false verify, which has a very similar approach to Smt checker, it didn't support a lot of the solidity features in this contract. It has a lot of weird stuff, has encode packed, has hashing, has a bunch of things and it just couldn't handle the language part of it, which means you couldn't prove anything. The Smt checker, I got it to prove in the end, but it took quite a bit of work.
00:25:55.372 - 00:26:37.444, Speaker B: So the first thing is you see here, this line in the original contract, it basically tests that size is whether size an OD number or not by doing a bitwise operation with one. And if it's one, this means that it is an OD number. So the semantics of this line is just that. So I can replace that line by this line. So just doing mod two instead of bitwise one. So the semantics gas might change a little bit, but math is also cheap, so the behavior should be the same. Here the reason why I changed this descent checker or the solvers that it uses in the underlying logic layer, they have more problems with this type of operations than with this type of operations.
00:26:37.444 - 00:27:34.664, Speaker B: So with this change, we make the problem much easier for the underlying solver. With the default solver that Smt checker uses, which is called spacer, it still couldn't prove it. So recently, this other solver we use something called horn based solving. And this other solver actually added some support we needed to run in the theorems that the tool generates called Etherica. And using this solver via Saucy JS Smt callback, which something that actually exists, plus setting a different abstraction option in the tool allowed us to prove it quite quickly, actually less than 2 seconds. But you need to know that a second horn solver exists and the tool actually can use that solver via Solc JS, the JavaScript wrapper for this whole C compiler. And you need to know that this tool has this abstraction option that when turned off, actually proves the deposit contract.
00:27:34.664 - 00:28:23.080, Speaker B: So took a little bit of work, but it worked. And here is part of the proof from the SNP checker from the tool actually. So this whole thing here is an induction variant for the loop before the assertion, which should prove that the loop always terminates inside that branch. But this is maybe 5% of the whole proof. So this last contract, I think I'm going to go very quickly through it because I took 25 minutes already, or even more. So this is in your C seven seven token contract, which I mentioned before. When you make a transfer, it calls this function tokens to send in the sender and it calls this function tokens received in the receiver.
00:28:23.080 - 00:29:37.370, Speaker B: And what we want here, and this is from the OpenZeppelin official implementation from their repo, minus all the Registry authenticator operator stuff, which is I don't think is part of the actual standard and there's a lot of stuff around it. And if you try to verify that, of course it's going to take much longer and I wanted this to be quicker, so I removed all that. And this still has the core of the EC seven seven seven token and I want those callbacks to not mess up with my total supply. So, yeah, this must be true. And I'm going to go quickly over this contract because running out of time and we're actually going to demo this contract live in the workshop so we can talk more about this contract there, if anyone is interested. But just very quickly, do you think this assertion is true with the contract, as is the rest of this contract is the same as, ERC, 20, you can mint, you can burn, you can do whatever. So if I call this callback here in the sending contract, do you think this assertion is true necessarily?
00:29:37.710 - 00:29:40.870, Speaker A: The receiver could reentrancy and do anything?
00:29:40.960 - 00:30:13.686, Speaker B: Yeah, you could do anything, right, based on reentrancy. So we think the property is actually not true, right? In this case. So Salty verified does say it's not true, but it doesn't give a counterexample. Various salt doesn't say anything. So this is just running the model checkers for now and the S and T checker does say the property is wrong. And this is actually one of the in my opinion, one of the coolest features is that it's going to sometimes, not always, it's going to synthesize the reentry call. So what it's basically doing is it's saying transaction trace is you can deploy the contract just to seven seven seven.
00:30:13.686 - 00:30:37.246, Speaker B: This is the current state. Then someone calls burn then, which calls internal function underscore burn, which then calls the call token to send callback thing that's going to call the sending contract. And this is that call. This is the untrusted external call. It's untrusted because we don't know who that contract is, right? It could be anything. It could have any code and you have no idea what it's doing. So what a tool.
00:30:37.246 - 00:31:25.502, Speaker B: Now, does it synthesizes calls that that contract could make back to your contract? So it synthesizes a reentrant call over here calling burn, which then calls internal burn, which then is going to change the total supply of the contract, then breaking the assertion finally. And I also had to change some stuff in the contract. So counterexamples are actually strings are pretty hard for counter examples in the Smt checker. So I removed like the string, the name of the contract, symbol of the contract, this kind of stuff. I just removed the state variables and this already made it possible to get a counterexample because otherwise it would have to come up with values for those strings as well. And that's what it's hard here and it doesn't really matter for the property. So we can test that.
00:31:25.502 - 00:32:10.780, Speaker B: So this is a quick GS test and here I'm just running a test, not really any symbolic check or any fuzzing. So basically we just have a new recipient contract that when it receives tokens, it then burns those tokens. Basically what the count example told us to do when we run this, this is running with Daptools. You get a full transaction trace here. So I'm transferring and here, this is the external call tokens received. This is the callback in the receiving contract, which then calls burn and then the assertion breaks afterwards. So we can forbid reentrancy by adding mutax to every public function.
00:32:10.780 - 00:32:53.366, Speaker B: This is just one way, obviously, if you want to do forbid reentrancy in this case, so we add a lock and then every public function must use the modifier Mutax, which means that basically we're forbidding reentrancy, right? So if you're trying to transfer, we're going to call the callbacks. But if they try to reenter and call Mint or Burn, which should also have this mutex modifier, then it's going to fail, right? That point, right? It's going to fail the reentrancy guard and the assertion should not fail if it's ever reached. So now running the test again, it still reverts, but now it's reverting because of the reentrancy check. So you see that it reverts much earlier. So you try to do a transfer. This is a callback. It calls burn.
00:32:53.366 - 00:33:34.226, Speaker B: It fails right away because of mutax. So now if you rerun this and t checker on the same thing. So now we finally get approved and one of the new features coming up, this is of course a feature branch. It actually exports and tells you contract invariance and external call properties for reentrancy in the contract. And this still looks quite verbose and quite long, but basically if we simplify this formula with just very basic operations, we get this property. So dissolver inferred for us that this property is true for any external call that this contract might make. So if lock is true, this thing's maybe running out of battery.
00:33:34.226 - 00:33:51.070, Speaker B: So if lock is true, it means that the total supply after the external call that it makes an untrusted code is not going to change, which is basically what we wanted to prove. Yeah. So I'm going to pass over to Martin to talk a little bit about HVM internals.
00:33:52.050 - 00:34:39.206, Speaker A: Okay, thanks. Just a little quick theory on how HVM does symbolic execution. HVM does a lot of different things. Like we saw it in the previous examples, both doing invariant fuzzing and symbolic execution. And I won't really be talking about any of the fuzzing features or anything like that. I'll just go over a little bit of the symbolic execution stuff and the equivalence checking that it has, which also uses the symbolic execution engine. So it's basically just well, it starts as a normal EVM interpreter and then it was generalized in March last year to also be able to deal with abstract arguments.
00:34:39.206 - 00:35:47.170, Speaker A: So in the call data or in the call value or who the sender is and all these things not fully abstract in that you can't have abstract code. For example, it doesn't deal with abstract gas, but it has. Sufficiently many abstract argument that it becomes interesting for the types of things that you normally want to prove and as a trade off, is also quite fast at doing those things. So the way that it works is that it's executing the EVM. And some of the arguments that are in the stack or in memory are going to be symbolic terms, which means that we don't really evaluate the results. Immediately, but rather we build up this Abstract Syntax tree that we can then send to the Smt Checker or the Smt Solver to consult whether this term actually is possible to fill with some real arguments. And as we're doing this, there may be branching points, and on the EVM level, these are all the branching points are when you see the jump I instruction.
00:35:47.170 - 00:37:10.090, Speaker A: And actually, we're doing an eager algorithm here where we don't actually consult the Smt solver for which path is reachable. We just explore both of them. And then at the end, we look at all of the final states that we get and we look at the final states where our assertion might be violated, because often this is like a structural property that you can see without consulting Smt to prune a lot of states early on. So if we know that we're looking for an assertion violation with the assert, and we have a bunch of cases where we have ordinary reverts, then we can just prune those from the state, and we don't need to consult the solar at all. But for the ones that do look like they might be problematic, we take all of the constraints that we got from getting to this particular branching point. So all of the conditions under which we would have jumped to this particular branch, and we see whether it's possible to get to this branch and to make sure that we're not getting stuck in an infinite loop. Somewhere in the code, we have this max iterations, which eternally keeps track of every time you encounter a particular jump by instruction.
00:37:11.150 - 00:37:11.900, Speaker B: Okay?
00:37:13.390 - 00:37:19.040, Speaker A: So that's how it works as an eager algorithm. And also this max iteration stuff.
00:37:21.030 - 00:37:21.394, Speaker B: This.
00:37:21.432 - 00:38:23.058, Speaker A: Can also explain what Leah was talking about when we were looking at the deposit contract. And we get different behavior when we change max iterations, because here, max iteration sort of stops this eager algorithm in its tracks, because we need to make sure that we're not getting into this infinite loop. And so then once we reach max iterations, we want to make sure, okay, what's this path actually reachable. And then we do a consultation with the Smt solver. And often this can be the bottleneck for the entire execution. So sometimes we run into a timeout here, and then the whole thing will not be as easy to verify. Okay? And since we are interested in performing this symbolic execution in a variety of different contexts, like, we want to do it in DS tests, where we have a very specific setup.
00:38:23.058 - 00:39:30.460, Speaker A: We deploy all of the contracts that we're interested in, or maybe we're using Mainet states, or we're just like performing the symbolic execution on an arbitrary run of the contract. We want to assume that it's in any arbitrary state. We have a couple of different options when it comes to how we deal with storage. When we're doing symbolic execution and we have three options. So the first one is concrete. So this one actually fails if you try to do something symbolic with storage, if you try to read from a symbolic location, or if you try to write to a symbolic location, because this one wants to be compatible with RPC. If you want to run symbolic execution against a Mainet contract, for example, then obviously you can't be asking for the main net value of an abstract location because no client will be able to tell you what is that storage location X, where X is an unknown number.
00:39:30.460 - 00:40:43.774, Speaker A: But if you say, I want the value at four, they can give you that. So when you're using concrete, you can use symbolic execution against Mainet state. And the other two are both symbolic versions, but they make a different assumption on which particular state you're in. In that in the first one, which I call initial S, we're assuming that everything that we haven't spoken about in storage is zero, the way it would be by default. We can still read and write from abstract locations and we keep track of where we have read from and written to in this abstract storage mapping. But yeah, if we try to read from a location that we haven't written to before, we always get zero. So this is like yeah, it's basically performing what you would get if there was no previous state besides what you have done in the setup function and your whole sort of dance that you do before you actually run the execution.
00:40:43.774 - 00:41:25.374, Speaker A: Whereas the third one and the most general one, you're not putting any additional constraints on the state of the contract. You're saying this contract can be in an arbitrary state. And whenever I read from any storage location, I can get any possible value back. And this is actually a bit of an over approximation because you may have certain constraints enforced by the code of your contract. Like you can't, for example, write to the storage location 13 ever. So if we were to have analyzed the contact completely, then we will know that this is zero. But if we're just looking at one particular invocation of a function, then we won't know that.
00:41:25.374 - 00:42:42.722, Speaker A: So if we're reading from storage location 13 or X or whatever, we're just getting an abstract value back and we're not putting any additional constraints on that. So when we're doing BS test, we're actually doing initial S, because you're assumed to do all of the things that you want to do in your setup function. But when we're doing some other things, like the equivalence thing, that I'll be explaining to you what it is in the next slide, we're using this symbolic so the fully unconstrained storage. Okay, so quickly about the equivalence checking that we can do with hevm. So as I mentioned when I described the general algorithm of the symbolic execution that hevm performs it's going down the entire execution tree and looking at all of the leaves, right? So we can do that in two VMs at the same time. So we copy the entire VM state and we change only the contract code. So now we can explore two VMs that differ only in the code of the current contract that we're executing.
00:42:42.722 - 00:43:45.686, Speaker A: And we explore both paths of both contracts or all of the paths in both contracts. And we look at all of the pairs of end states that we have and then we compare every possible combination of these pairs and see if the constraint sets of each path are simultaneously satisfiable. And if so, if their results differ. Because this means that there is an input such that if you run it with a one piece of code, you'll get one result and if you run it with the other piece of code, you get another result. That means that the contracts are actually different. And in fact, this is the only way something can be different is you run it with the same input and you get different output. And so if there is no such pair, then these contracts must be equivalent.
00:43:45.686 - 00:43:57.498, Speaker A: So that's how the equivalence trigger works. And I think that's all I'm going to be saying about the theory of symbolic execution in HVM right now. And now I got to run to the other room and prep the workshop.
00:43:57.674 - 00:44:15.890, Speaker B: All right. Thanks, biev. Just like across the hallway, same floor here. Yeah. So we're obviously overtime. I'm just going to skip to the very last one. I was not that optimistic.
00:44:15.890 - 00:45:11.442, Speaker B: So just a few quick conclusions on actually the experimental part that I should maybe have put the slide before. So some of the automatic Fe tools can be really powerful even given which approach you're taking, verifying solidity or EVM bytecode or doing small execution or model checking or this kind of stuff. But there is no tool that's going to do the job at every single time. So I would encourage everyone to actually use all of them and each one of them is going to do something differently and you might actually get a complete result if you use each one of them separately. Also conclusion of this experiment is that FV is still very much, very much an expert domain and some very specific tool knowledge was required to verify, to extract the full potential of the tools and even verify the simplified versions of the contract. So you can only imagine what you need to do to verify the full version of the contract. So for example, we needed to note that hevm does 50 iterations.
00:45:11.442 - 00:45:39.560, Speaker B: Max needed to use a different horn, solver different abstraction options, so it was still quite in depth knowledge required to verify these contracts. And of course playing of the tool, knowing the specifics of the tool, knowing the parameters and what things do differently is essential to get any good results out of the tools. So I don't think we have time for questions, but we're running over to the workshop. Thank you very much. Thank.
