00:00:00.570 - 00:00:42.970, Speaker A: Hi everyone and welcome to this video that accompanies section 22.4 of the book Algorithms Illuminated part Four. This section will be the first of our major NP hardness reductions, a reduction from three sat to the independent set problem. Let me quickly jog your memory about what the independent set problem is. In the independent set problem, the input is an undirected graph and the goal is to compute an independent set that is a subset of vertices that are all mutually nonajacent. An independent set of the maximum possible size. For example, if the input graph is a five cycle, the maximum size of an independent set would be two vertices.
00:00:42.970 - 00:01:27.398, Speaker A: There's various pairs of vertices that form independent sets. Not all of them do, some of them are adjacent, but any nonajacent pair of vertices is an independent set. And if you tried to pick three vertices, two of them would wind up adjacent, which is not allowed. So two as big as it gets if the input graph is a five cycle. We've talked about the independent set problem a couple of times in the past, so it's very common for the vertices to be representing people or tasks and the edges to be representing conflicts. So for example, peoples that people that don't get along or tasks that require the same resource. In fact, what we've discussed has been a generalization of this called the weighted independent set problem, where also part of the input is a non negative weight w sub v with each vertex v.
00:01:27.398 - 00:02:18.578, Speaker A: And the goal in that version of the problem is to compute the independent set with the maximum possible total weight. So that's, for example, the version of the problem where we gave a linear time algorithm using dynamic programming for graphs that were path graphs, we did that back in part three. Back in the previous playlist, or more generally for tree graphs, you can solve the weighted independent set problem in linear time. What we're going to see here is that even this special case of the independent set problem, which basically corresponds to all of the vertex weights being equal to one, if you have general graphs, then even this special case is going to be NP hard. So how are we going to prove that? We're going to prove that using our two step recipe. So we're going to choose an NP hard problem A and reduce that problem A to the independent set problem. Now, at the moment we kind of only have one NP hard problem truly to work with, which is the three set problem offered by the Cook Levin theorem.
00:02:18.578 - 00:03:04.262, Speaker A: Then as we generate more and more NP hard problems that'll give us more candidates that we can use in the first step of the recipe. But to get started, our hand is sort of forced. We really need to reduce the three set problem to the independent set problem. So that's going to be what we're going to do. As long as we're willing to take the Cook Levin theorem on faith, as long as we're willing to assume that the three side problem is indeed NP hard, then by our two step recipe, this reduction will show that independent set is an NP hard problem as well. As we saw in the previous video, once we know that the independent set problem is NP hard, the dominoes start falling and we find that lots of other problems that we care about are NP hard as well. Right? So the clique problem, the vertex cover problem, the generalization of that into the set cover problem, then the maximum coverage problem, and finally the influence maximization problem.
00:03:04.262 - 00:03:40.882, Speaker A: All of those are NPH hard via very easy reductions from the independent set problem. So how is this going to work? How are we going to be reducing three set to independent set? Remember what this means. That means if we're given a subroutine for independent set, so independent set will correspond to the magenta box. We need to show how from such a subroutine, we can build an efficient algorithm for the three set problem. So we need to figure out how to build the blue box. We have seen one NP hardness reduction in the past that was way back in the opening sequence of videos corresponding to chapter 19. Not sure if you remember it.
00:03:40.882 - 00:04:21.370, Speaker A: So there we reduced the directed Hamiltonian path problem to the cycle free shortest path problem. So in that first example, our magenta box was a subroutine for computing cycle free shortest paths. And the light blue box that we were building was an efficient algorithm for the directed Hamiltonian path problem. And that reduction really was pretty conceptually straightforward, right? Because these are both problems that involve directed graphs. So the blue box for solving Dirk and Hamiltonian path, it's given a directed graph. And the question is, is there or is there not a directed Hamiltonian path? And then the subroutine also expected a directed graph, and you just ask it for the cycle free shortest paths. There was the one twist where the cycle free shortest path subroutine expected the edges to have lengths.
00:04:21.370 - 00:04:54.074, Speaker A: So we gave them all a length of minus one to trick the subroutine into computing long paths for us, even though it was a shortest path subroutine. But it was very straightforward, right? We're given a directed graph. We just added minus one to every edge. We fed it into the cycle free shortest path subroutine, the magenta box, and then we could pretty much immediately output what we needed to to complete the description of the light blue box. Now, here, things do not seem as straightforward. We are not dealing with two graph problems. We're dealing with one problem from logic, the three set problem, and then a graph problem, the independent set problem.
00:04:54.074 - 00:05:51.702, Speaker A: So somehow this reduction, okay, so now we're given a subroutine, a magenta box that expects a graph, but we weren't ourselves given a graph, we were given this three set instance, just a bunch of sort of disjunctions of literals. So somehow we have to fabricate some kind of graph from the three set instance that we can then feed into our magenta box, our independent set subroutine. So that somehow the answer to that independent set problem gives us information about whether the given three set instance was satisfiable or not. That is what we are tasked with doing. So let's start brainstorming about how we might do that. Your first thought might be to transmogrify the given threesat instance with N decision variables into an undirected graph that has N vertices. So with a one to one correspondence between the boolean variables in the given three set instance and the vertices in the graph that we construct, there's two to the N truth assignments corresponding to true false, and there's two to the N subsets of N vertices.
00:05:51.702 - 00:06:37.194, Speaker A: So maybe somehow we could do that in a way that independent sets of the graph correspond to satisfying truth assignments. Well, actually that's a natural nice place to start, but it's not actually going to pan out. So we're going to need a more clever way of setting up a correspondence between variables in the three set instance and vertices in the graph that we construct. So think about one of the constraints in the three set instance that we were given. Each constraint is a disjunction of at most three literals. So for example, one of the constraints might be not x one or x two or x three. Back when we were talking about sat solvers and we first introduced the satisfiability problem, we discussed how disjunctions of literals are pretty easy going creatures, pretty easy to satisfy really.
00:06:37.194 - 00:07:18.950, Speaker A: They're just a list of variable assignment requests. And to make a clause happy, you just need to satisfy one of their requests. So for example, this disjunction of three letterals is sort of pleading with us please set x one to false, then I'll be happy. Or failing that, please try to set x two to true, I'll still be happy. Failing also that the constraint is saying you have one more shot at making me happy, please set x three equal to true. So we can think about a disjunction of k literals as really being k different requests for how the constraint wants the variables to be assigned. And the only way to fail to satisfy a clause is if you reject every single one of its k variable assignment requests.
00:07:18.950 - 00:08:08.266, Speaker A: The key idea in the reduction is that in the graph that we're going to construct from the given three set instance, we're going to have one vertex for each of the variable requests. So for example, a clause like this one in the upper right that would give rise to three vertices, one requesting that x one is false, and then two that are requesting x two and x three are true. Every other clause with K literals would give rise to its own K vertices. So for example, imagine we had three constraints, each disjunction of three literals. Let's say we had the same constraint as before, not x one or x two or x three. And let's throw in one constraint asking for something to be set to true. So x one or x two or x three, and another constraint which is asking for some variable to be set to false.
00:08:08.266 - 00:08:55.760, Speaker A: So not x one or not x two or not x three. So this is three constraints each with three literals. So that's going to give rise to nine vertices, one for each of the nine assignment requests made collectively by these three constraints. For example, the first three vertices correspond to the three assignment requests made by the first clause. So we have one vertex about C one asking that x one is set to true, c one asking x two to be true, and then the third one, C three, asking x three to be true. Then we have separate vertices when the constraint C two makes the same request for variables x two and x three. So the separate vertices corresponding to the second clause, again with the three variable requests x one to false or x two to true, or x three to true.
00:08:55.760 - 00:10:13.400, Speaker A: Do subsets of these vertices encode truth assignments? Well, it depends, not always. The issue is that some of the requests are inconsistent with each other in that they ask for opposite assignments to the same variable, like the first vertex and the fourth vertex are making opposite requests to what the variable x one should be assigned to. And obviously x one is only to get one of those two values, not both. On the other hand, remember the whole point of the independent set problem is to represent conflicts. So that says, okay, we should just introduce an edge between any two vertices that conflict that ask for opposite assignments to a common variable. So for example, we will have an edge between the first and fourth vertices, similarly between all three of the first three vertices and the corresponding last three vertices, and then also the second and third vertices from the second group conflict with the second and third vertices from the third group. So now what's cool is that a satisfying truth assignment can be easily extracted from any independent set in this graph, any subset of nonconflicting vertices, if that subset contains at least one vertex in each group.
00:10:13.400 - 00:10:57.326, Speaker A: For example, consider the second, fourth and 7th vertices. Those three vertices correspond to three variable assignment requests. Actually, two of those three requests are redundant. So we have two different requests to set x one to false from the fourth and the 7th vertices, plus the request by the second vertex to set x two to be equal to true. Now, the claim is that any truth assignment consistent with all of those requests that any truth assignment that sets x one to false and x two to true will in fact satisfy all of the clauses. And that's because this independent set has at least one vertex from each of the three groups. So by virtue of x two being set to true, that first group is represented.
00:10:57.326 - 00:11:24.990, Speaker A: So the first constraint will be satisfied. And then similarly, because x one is equal to false, that's going to give us a representative from the second and third group's satisfied assignment request. So the second and third clauses will be satisfied as well. So this independent set gives rise to two different satisfying truth assignments. We don't really care which one, both of them. X one is equal to false and x two is equal to true and then x three can be equal to whatever. Either way it's going to be a satisfying assignment.
00:11:24.990 - 00:12:19.570, Speaker A: So far so good. We see how any independent set of a particular form, any independent set with at least one representative in each group, we can easily extract from such an independent set a satisfying truth assignment to the three side instance that we started with, which is exactly what we wanted. That can't be the whole story, however, because for all we know we're going to be handed a three set instance that doesn't have any satisfying truth assignments at all. That's actually unsatisfiable and that's also something we're responsible for recognizing. So we need to make sure that in the graph that we construct we can know immediately when we look at the maximum size independent set. We can know immediately whether or not there was some satisfying assignment in the three side instance we were originally given. But there's a very easy way to do that which is just we're going to add in all of the edges that occur within a group.
00:12:19.570 - 00:13:00.300, Speaker A: So in effect we're going to impose a triangle on each of these triples of vertices. Now what should be clear is that any independent set can only pick one vertex at most from each group. Any pair of vertices within the same group are adjacent, so they can't both be in an independent set. So every independent set picks at most one representative per group. We already know that if we get exactly one representative per group we can extract a satisfying assignment. And as we'll see in the correctness proof, the converse is fine as well. So if in fact the maximum independent set does not have one vertex from every group, then we'll be able to immediately conclude that we were initially given an unsatisfiable threesat instance.
00:13:00.300 - 00:13:40.296, Speaker A: So the general reduction, the main result in this video, the general reduction from threesat to independent set, it's literally just exactly what happened on this slide, just scaled up to arbitrary threesat instances. So let me go ahead and spell out the reduction on the next slide. It'll literally be just what we just did. But I'll spell out that reduction on the next slide and then we'll discuss the correctness of the reduction. So we'll argue that you can deduce whether or not the original three set instance was satisfiable based on what a maximum size independent set looks like in the corresponding graph that you construct. All right, so let's describe the reduction in general. So don't forget what a reduction is responsible for doing.
00:13:40.296 - 00:14:15.670, Speaker A: You're given a magenta box a subroutine for some problem B. B in our case is independent set. And then from that you're building up the light blue box, the algorithm for the problem A. And for us here, A is three sat. So our blue box is given an instance of threesat, right? So we're given n decision variables m constraints, each one a disjunction of at most three literals. And then we have to somehow prepare that into a graph that we can feed into our independent set subroutine. It'll spit back out a maximum size independent set from which we can hopefully deduce what was going on with the original threesat instance that we're responsible for.
00:14:15.670 - 00:14:51.040, Speaker A: So given an instance of threesat n variables m constraints, we need to construct a graph. So what are the vertices? Well, just like in the example, the vertices are going to correspond to assignment requests made by the constraints. So we have m constraints. Let's say the ith constraint has k sub I literals in it case of I here is going to be one, two or three. So for each constraint i, we're going to have a collection of case of I vertices. So one, two or three vertices, depending on the number of assignment requests. And then the overall vertex set is just going to be the union of these subsets of vertices over all of the m constraints.
00:14:51.040 - 00:15:25.560, Speaker A: The edge set then contains two types of edges, just like in the example. So first of all, any pair of vertices in the same group, any pair of vertices that are assignment requests from the same constraint, those get connected. That was the second batch of edges that we added in the example, those triangles and then the other edges are the ones between conflicting assignment requests. So if two different vertices are making opposite requests to the same decision variable, those also get connected by an edge. That was the first group of edges that we added in the example. And that is it. That is a graph defined from an arbitrary threesat instance.
00:15:25.560 - 00:16:02.084, Speaker A: Having defined the graph, we now have in our hands an input that we can, if we want, feed into our magenta box, our assumed subroutine for the independent set problem. And that's all we do. We have our graph, we just say, hey, subroutine magenta box, give us back a maximum size independent set of this graph. So it'll do that by assumption. Now we'll have this independent set, and the question is, what do we do with it? How do we figure out what was up with the three set instance we were given from this independent set that was handed to us by the magenta box. Well, we're not going to have to work too hard. We're just going to look at how many vertices are in this independent set that we're given.
00:16:02.084 - 00:17:01.720, Speaker A: So if there's m vertices in the independent set where m is the number of constraints we started with, or equivalently the number of vertex groups. So if we're handed an independent set that has m vertices in it, then we're just going to return an arbitrary truth assignment consistent with all of the variable requests made by that independent set. And remember, because of that second batch of edges, because of the edges in e two, any independent set corresponds to one or more consistent truth assignments. So we just pick an arbitrary truth assignment consistent with the independent set, capital S, and we return it, as we'll see on the next slide, that will necessarily be a satisfying assignment. On the other hand, if the independent set that we get back does not have m vertices in it, if you think about it, that means it has to have less than m vertices in it. Then we declare victory in that we say, well, that three set instance you gave us in the first place, we're off the hook because it's unsatisfiable, there are no satisfying truth assignments. And again, on the next slide we'll see that that is indeed a correct declaration of unsatisfiability.
00:17:01.720 - 00:17:55.332, Speaker A: If you look over the amount of work done by this reduction, it's not very much, right? So it invokes the assumed subroutine for the independent set exactly once for the graph capital G that it constructs. And with an appropriate implementation of the reduction, you can also make it run in a linear amount of work outside of its one subroutine call. By linear I mean big O of m plus n, where m is the number of constraints and n is the number of variables in the given threesat instance. Let's proceed to the argument that this reduction is correct, that it always correctly solves the three sat instance it was given. So that is, whenever there is a satisfying truth assignment, the reduction will return one. Whenever there is no satisfying truth assignment, the reduction will in fact, correctly deduce that fact. So the picture you want to have in mind as we go through this proof of correctness is the cartoon I've drawn here on the right part of the slide.
00:17:55.332 - 00:19:03.552, Speaker A: So it's a reduction from threesat to independent set. So that's why the green arrows go from left to right, independent set, that's what we're assuming we have an efficient subroutine for. So that's like the magenta box that we have access to, and we're trying to build that light blue box for the three sat problem and what we're hoping we just did with this reduction, right? So we just showed how to translate any instance of threesat into a graph. And we're hoping that the satisfiability status of the three side instance we started with will be immediately apparent from the result of the independent set subroutine. Specifically, we're hoping that whenever we started with a satisfiable threesite instance, we wind up with a graph with an independent set of size M, and whenever we started with an unsatisfiable three side instance, we wind up with a graph that has an independent set of size less than M. Now, mind you, the reduction, right? When you're constructing capital G, you have no idea whether this formula, whether the three side instance is satisfiable or not, and yet you're hoping that property gets preserved encoded by the independent set of that graph, capital G. So let's now see that that is in fact the case.
00:19:03.552 - 00:19:48.350, Speaker A: And let's begin just with some basic properties of the reduction, really just things that we deliberately enforced in the way that we constructed our graph Capital G. First of all, we have these edges in e one. So these are the edges that go between any pair of vertices that belong to the same group, or equivalently, any two assignment requests made by the same constraints. These were the triangles that we had in the example. So because of the edges in e one, any independent set can only pick at most one vertex from each of the M groups, where m here is the number of constraints. If you think about it, I mean, that means the biggest an independent set could be is if it picked exactly one vertex from each of the M groups. So the maximum size, no matter what, is going to be m at most.
00:19:48.350 - 00:20:47.356, Speaker A: Don't forget about the edges of e two. So these were the first ones that we added in our example. These are the ones that were between vertices corresponding to conflicting variable assignment requests, so requests to the same decision variable, but for opposite values. So we added these edges so that in any independent set, right, which means there's no conflicts. So if there's no conflicts, that means we can define a truth assignment that is consistent with all of the variable assignment requests in that independent set. There may be more than one, as we saw in the example, but there always be at least one consistent truth assignment for any independent set, and that's enforced by that second subset of edges. Therefore, we can extract a satisfying truth assignment whenever we're given an independent set that happens to have M vertices in it, right? Because the only way that an independent set, capital S, can have M vertices if it has one vertex per group, having a vertex from a group corresponds to making a variable assignment which satisfies that clause.
00:20:47.356 - 00:21:38.144, Speaker A: So if your vertices represent all of the groups, then you're making assignments that satisfy all of the clauses, all of the constraints. So those are all properties of the reduction that hold, no matter whether the given three set instance was satisfiable or not. So now, to do the correctness proof, we're going to need two cases one for the case where the given three set instance is satisfiable, and one where it's unsatisfiable. So let's assume first that there is some satisfying truth assignment to the three side instance we were given fix some satisfying truth assignment arbitrarily. Now, what we're going to do is construct an independent set of the graph G that has M vertices in it. So how are we going to do that? Well, it's a satisfying truth assignment, which means that each of the m constraints is satisfied. So for each of the m constraints, at least one, if not more of the variable assignment requests that the constraint was making is in fact met.
00:21:38.144 - 00:22:34.244, Speaker A: So what we're going to do is we're going to walk through the constraints one at a time. When we get to a constraint, we pick one of the variable assignment requests it was making, which was in fact satisfied by the truth assignment. So that gives us one satisfied variable assignment request for each of the m constraints, which then translates to m vertices in the graph g with exactly one vertex for each of the groups. So that's a subset of m vertices. Moreover, because we picked only one vertex per group and because we started from a consistent truth assignment that is going to be an independent set of capital G with size M summarizing whenever we're given a three side instance which is, in fact, satisfiable. We're going to wind up constructing a graph where, in fact, the maximum size of an independent set is m is equal to the number of constraints. So when we invoke our subroutine, it'll compute for us a maximum size independent set.
00:22:34.244 - 00:23:20.764, Speaker A: It'll give it back to us, we'll check it, it'll have M vertices in it, it'll have to be exactly one vertex per group. And as we've seen, we'll be able to extract from that independent set a satisfying assignment for the original instance. So the reduction really will do the right thing when it starts with a satisfiable instance. Now, suppose on the other hand, that we actually start out with an unsatisfiable three set instance. What's going to happen? What's going to be up with the graph capital G that we construct? Well, the thing to realize is there is no way that the graph G that we construct will have an independent set of size m. Why not? If it did have an independent set of size m, it would have to be with one vertex per group, and then we'd be able to extract from that independent set a satisfying truth assignment. But by assumption there are no satisfying truth assignments.
00:23:20.764 - 00:24:06.912, Speaker A: Ergo, if you start with an unsatisfiable three side instance, you're going to wind up with a graph where every independent set has at most m minus one vertices. So therefore, when our reduction invokes the magenta box and computes a maximum size independent set of g. It's going to get back an independent set that has M minus one vertices or less and it's going to do the right thing. It's going to report that the given three side instance was unsatisfiable. So with both cases covered, that wraps up the correctness of the reduction. So I'm wondering if this is one of those proofs where some of you out there are thinking I'm being a little too pedantic, so maybe slide before last when we describe the reduction, how you build the graph g from the given three side instance. Maybe once that reduction was written down, you looked at it and you're like, yeah, it's obvious that this works.
00:24:06.912 - 00:25:14.384, Speaker A: And so you're wondering what was the point of that sort of slightly painful proof of correctness we did in the previous slide. And as we saw, that reduction is correct, but actually it is not that hard to screw up reductions. And to think that you've proved that a problem is empty hard using a reduction, but then actually the reduction isn't quite right. So to drive that point home on this quiz, I want to show you an example of how a reduction might go awry. Specifically, I want you to think about the reduction we just saw from the three set problem to the independent set problem. And imagine we just sort of forgot about those edges that went inside a group. So imagine we did not include an edge between vertices that are different variable assignment requests from the constraint where would the proof break down? So the correct answer is the third one, answer C.
00:25:14.384 - 00:26:24.136, Speaker A: So first of all for answer A, because we still have the edges e two, those were the ones that ruled out any conflicts between assignment requests. So even without the edges in e one, it's still the case that any independent set translates to a well defined truth assignment. And more generally, any independent set with at least one vertex per group is going to translate to a satisfying truth assignment. For B, it's also still the case that the case one of the proof of correctness a satisfiable three set instance, you can again just choose one satisfied assignment request from each of the M constraints and that'll continue to give you an independent set of size M in the graph capital G. So that part still works. What about C? Why is C correct? Why does this part of the proof break down? The issue is that if we omit the edges e one, all of a sudden it becomes possible for an independent set to include more than one vertex from a group. So while it's still the case that if you start from an unsatisfiable three side instance, it's still the case you will not have any independent sets with at least one vertex in every group, you can't have independent sets of that form because from any such independent set.
00:26:24.136 - 00:27:00.112, Speaker A: You could extract a satisfying truth assignment which doesn't exist. However, if you forget those edges e one, you might have an independent set which sneakily smuggles in m vertices into it, even though it skips some of the vertex groups because it made up for it by including more than one vertex and some of the other vertex groups. Other vertex groups. So the second case of the correctness proof breaks down without those edges. E sub one. So one takeaway from this quiz is that with empty hardness reductions, the devil is often in the details. And if you get the details wrong, the reduction can actually be wrong.
00:27:00.112 - 00:27:14.390, Speaker A: And so that's why, as we proceed to our next three reductions in the next three videos, we will always pause and take care to make sure that our reductions are correct. So that's it for independence? Set. Let's move on to directed Hamiltonian path. See you in the next video.
