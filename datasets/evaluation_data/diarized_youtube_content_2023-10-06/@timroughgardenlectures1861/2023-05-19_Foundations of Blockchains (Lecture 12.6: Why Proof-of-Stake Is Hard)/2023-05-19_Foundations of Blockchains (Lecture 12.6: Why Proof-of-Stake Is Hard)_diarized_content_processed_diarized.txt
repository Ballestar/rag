00:00:00.170 - 00:00:40.824, Speaker A: So the goal of proof of stake random sampling should seem pretty simple. So let me just briefly remind you what it is. You can think of the input as a list of the active validators. So validators that are currently participating in consensus. A validator is identified by its public key and is associated with some amount of stake. So that list is available in some designated staking contract. And all we want to do is sample one of the public keys in this list with probability proportional to stake.
00:00:40.824 - 00:01:29.736, Speaker A: Probability proportional to the Q sub eyes. So, for example, if you're one of the validators and amongst all of the locked up state, 1% of it is owned by you, then you would like to be selected with 1% probability. Now, remember, why is it that we want this property? Why do we want to sample with probability proportional to stake? Well, that gives us civil resistance because this means the probability that a node is selected is independent of how many IDs it uses. It doesn't matter if it's using one public key or many public keys. Its selection probability depends just on the overall amount of stake that it's committing. Also, with sampling proportional to stake, it becomes quite clear what kind of assumptions we're going to need to make bounding the power of the adversary. It's going to be just on the fraction of the stake that's controlled by Byzantine nodes.
00:01:29.736 - 00:02:10.520, Speaker A: So for a BFT type consensus protocol, you'd expect us to assume that less than a third of the overall stake is controlled by Byzantine nodes. For a longest chain protocol, you'd expect the assumption to be less than half of the stake controlled by Byzantine nodes. So speaking of consensus protocols, how are you actually going to use such a random sampling procedure in a consensus protocol? Well, one obvious thing to do with it is to sample a leader. So a block proposer for a given round. So remember, both longest chain consensus and most BFT type protocols, like tendermint, there's a notion of a round and there's a notion of a single designated node that acts as the leader that kicks off the round with a block proposal.
00:02:11.180 - 00:02:13.084, Speaker B: So, in effect, you can interpret such.
00:02:13.122 - 00:03:15.900, Speaker A: A random sampling procedure as reducing the problem of designing a permissionless consensus protocol to a problem we've already solved, namely designing a permissioned consensus protocol. Right? Permissionless longest chain is just permissioned longest chain, plus this civil resistant random sampling to choose a leader in each round. Similarly, for BFT type consensus, you just sort of stand on the shoulders of the permissioned version, but again, using this random sampling procedure to choose a leader in each round. Now, for a BFT type protocol, you also have to figure out which active validators are allowed to vote on a block proposal. And we'll talk more about the details of how to do that in a separate video about coupling proof of stake civil resistance with BFT type consensus. For now, for simplicity, if you want, just imagine that all of the validators so all of PK one through PKN are allowed to vote on block proposals with their vote weighted by the amount of stake. So a supermajority in a BFT type protocol would mean that more than two thirds of the overall stake is voting to proceed with a particular block.
00:03:15.900 - 00:04:17.520, Speaker A: So that's, again, what's the key defining property of proof of stake? Those are the reasons why we want it and that's how we obviously make use of it in a consensus protocol. And you look at this, you're like, how hard could it be, right? There's just some explicitly defined distribution that the protocol is well aware of and all it has to do is randomly pick a sample from that distribution. Well, here's a fact, and this should not necessarily be intuitive. It is actually surprisingly tricky to do this in the context of a blockchain protocol. So indeed, every proof of stake blockchain protocol sort of handles this, implements this a bit differently. And actually, with each new generation of proof of stake blockchain protocols, we're seeing sort of increasingly sophisticated but also increasingly sound solutions to pulling off proof of stake random sampling. One example would be if you just look at the iterations of the proposed proof of stake version of Ethereum over the years, you will see sort of it getting increasingly complex but also increasingly robust to wider and wider sets of possible manipulations.
00:04:17.520 - 00:04:29.220, Speaker A: And the state of the art is very much still evolving. So, speaking here at the beginning of 2023, I don't think we've reached the end game of how to implement proof of stake random sampling.
00:04:30.120 - 00:04:31.636, Speaker B: So my goal here then is going.
00:04:31.658 - 00:05:03.680, Speaker A: To be sort of to highlight the state of the art, such as it is for this problem, and in particular to make sure you understand what are the key challenges and the currently available palette of solutions. So again, you might find this fact surprising, like why is it so hard? So I owe you an answer to that. There's actually a couple of answers, but the answer I want to focus on now and for the next many number of videos is the challenge of generating randomness from the hermetically sealed blockchain environment.
00:05:05.060 - 00:05:06.224, Speaker B: So what do I mean by that?
00:05:06.262 - 00:05:36.940, Speaker A: Well, imagine a blockchain protocol wanted some randomness like it wanted the outcomes of some fair coin flips. Let's think through where that randomness might come from and let's think about it separately for the proof of work and proof of stake cases. Now, in proof of work, the protocol basically gets randomness for free by an external process, namely the mining process of would be block producers sort of repeatedly trying nonsense and trying to find a solution to one of these hard crypto puzzles.
00:05:37.360 - 00:05:39.084, Speaker B: So a proof of work protocol really.
00:05:39.122 - 00:06:24.796, Speaker A: Just is given a random sample from the outside, namely whichever public key is the first one to report a solution to a crypto puzzle. That's the public key that in effect gets selected in a given round. And under our usual random oracle assumption that a cryptographic hash function like Sha 256 is for all practical purposes equivalent to a gnome in a box just flipping fair coins, that means that miners can't, they really don't have any other strategy than just repeatedly guessing distinct nonces hoping to get lucky. And given that given that that's the only thing that miners are capable of doing they also are incapable of manipulating the probability with which they get selected, it's just a sort of undeniable fact that you're going to be selected with probability proportional to the fraction of guesses the fraction of hashes that you are.
00:06:24.818 - 00:06:32.810, Speaker B: Generating with the proof of stake blockchain protocol.
00:06:32.890 - 00:07:05.378, Speaker A: Meanwhile, there's no clear analog to this external mining process which for proof of work is in effect providing the protocol with fair coin flips. In the proof of stake world, it would seem you're kind of stuck. The protocol is stuck trying to generate randomness knowing the only stuff that it knows about, stuff from within its hermetically sealed environment. In other words, from the current state of the protocol. So, a couple of comments. So first comment is the key challenge we're talking about here. It's actually not specific to the fact we're trying to sample from the stake distribution.
00:07:05.378 - 00:07:43.586, Speaker A: The exact same issues would come up if you were trying to sample from any sort of known distribution known to the protocol, namely, where are you going to get your randomness from? So the issue is more general, but we're obviously interested specifically in the case of sampling from a staking distribution. The second comment is you could in principle try to import randomness somehow from outside the blockchain protocol. But the question then is like, who is allowed to inject that randomness into the proof of stake protocol and how do you know that that person actually generated that randomness appropriately and didn't manipulate.
00:07:43.618 - 00:07:44.934, Speaker B: It in any way?
00:07:45.132 - 00:08:44.746, Speaker A: So if you have some party that you're willing to trust to reliably submit actual true randomness to a blockchain protocol, then a lot of the issues we're going to talk about in this video, not all of them, but a lot of the issues in this video are going to go away. So one can imagine a proof of stake blockchain protocol that does make this trust assumption to sort of avoid all these issues with generating its own randomness. In practice, however, if you look at all of the major deployed proof of stake protocols, they do not in fact trust an external source for randomness. They do in fact generate it internally. So the issues we're going to discuss in the next several lectures are very, very relevant to the current state of the art. So this new key challenge, which we did not have in the proof of work world, in the proof of work world we just had under the random oracle assumption, this non manipulable source of external randomness in the proof of stake world, that randomness is going to be derived from the blockchain state. And that opens up a new attack vector that we really just did not have to worry about before.
00:08:44.746 - 00:09:28.070, Speaker A: So if randomness is being derived from the blockchain state, that means you could manipulate the randomness potentially by manipulating the blockchain state. Who is it that's in charge of maintaining the blockchain state? Well, that is exactly the validators themselves. They're the ones producing and finalizing blocks. So it is now possible we have to worry about validators potentially manipulating the blockchain state, for example, by choosing the contents or metadata of a block proposal appropriately. So manipulating the blockchain state in order to, for example, make it so that it or its friends are going to be selected as leaders more frequently in the future than they would have been otherwise. All right, so I hope the intuition behind this challenge is clear.
00:09:28.140 - 00:09:28.326, Speaker B: Right?
00:09:28.348 - 00:10:04.554, Speaker A: So, proof of stake, no obvious external random process. We're not willing to sort of trust some third party to supply randomness. We really want just the protocol to be able to generate the randomness itself. Where can it get that randomness? Well, it has to be from something it knows about. And basically all it knows about is its own blockchain state. But if randomness is derived from blockchain states, then you worry about manipulation of that randomness through the manipulation of the blockchain state by block producers. So this is the natural place to conclude part one because all of the next bunch of videos, all of the part two videos, they're exactly about understanding and addressing this challenge.
00:10:04.554 - 00:10:14.774, Speaker A: How do you have randomness so that the manipulation probabilities are few to none run for the block producers participating in the protocol. So that's where we're going to start next.
00:10:14.892 - 00:10:16.610, Speaker B: I'll see you there. Bye.
