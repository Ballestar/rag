00:00:00.650 - 00:00:46.186, Speaker A: Hi, everyone, and welcome to this video that accompanies Section 19.6 of the book algorithms Illuminated, part Four, a section about rookie mistakes. Now, NP hardness, on the one hand, it's it's a pretty technical topic. On the other, it's highly relevant for practicing programmers and computer scientists. And when computer scientists speak about NP hardness outside of a sort of academic setting, like a classroom or a textbook, we generally take some liberties with the exact mathematical definitions just in the interest of sort of easier communication. However, some inaccuracies around NP hardness will mark you as a clueless newbie, others more culturally acceptable. How would you ever know which is which? Because I'm going to tell you right now.
00:00:46.186 - 00:01:46.590, Speaker A: So let's begin with a list of five common rookie mistakes. The first rookie mistake concerns the acronym NP, meaning what does it stand for? And it's actually not that important that you remember what it stands for as long as you remember what it doesn't stand for. It does not stand for, quote unquote, not polynomial. Now, while it's true that most people believe that NP hard problems cannot be solved in polynomial time, nevertheless, that is not polynomial is not what NP stands for. You could ask, what does it stand for? You might regret if you ask the question, but if you're really curious, the answer is non deterministic polynomial time. And if you want more details about that, we'll cover it in the optional lectures toward the end of this playlist when we discuss PNP and all that. Moving on to rookie mistake number two, which is something I hear quite commonly is when someone means to say that a problem is NP hard, they instead say that it's either an NP problem or is in NP.
00:01:46.590 - 00:02:26.326, Speaker A: For those of you that go on and watch the optional videos about the formal definition of the complexity class NP, you'll learn that when you say a problem is NP or is an NP problem, you're actually saying something positive about the problem, something about tractability rather than about Intractability. Specifically, a problem is an NP. If you can quickly verify solutions to that problem, the way that if I give you a filled out Sudoku puzzle, it's easy for you to check that indeed it is a valid solution. It follows all the rules of Sudoku. So you really want to say with NP hardness, you want to say, a problem is Intractable, not tractable. So don't forget the hard after. The NP.
00:02:26.326 - 00:03:25.690, Speaker A: Rookie mistake number three is another one that I encounter all too often, which is assuming that NP hardness is a merely academic concept and is not relevant for practice. That, again, is a big mistake. Now, it's true that NP hardness is not a death sentence, and there are numerous success stories of taming NP hard problems in practical applications, provided you use enough human and computational effort. Indeed, we'll see several examples of this later on in this video playlist, but there's plenty of other real world applications where computational problems have had to be modified or even just completely abandoned because of the challenges posed by NP hardness. And don't forget, people are much more likely to brag to you about the one time that they did successfully solve an NP hard problem, as opposed to the dozens of times where they failed to solve an NP hard problem. So you hear about the successes much more than the failures. But believe me, the failures are out there, and they are abundant.
00:03:25.690 - 00:04:14.330, Speaker A: Indeed, if NP hardness didn't matter in practice, why would fast heuristic algorithms be so prevalent in practice, right? If you could always solve NP hard problems, there'd be no reason to resort to a heuristic. But people do all the time. In fact, you could even argue, how does modern commerce even exist if NP hardness is sort of irrelevant in their practically easy problems? Modern e commerce relies on the assumed security of crypto systems like RSA. And that security rests on the assumption that it's computationally difficult to factor large numbers. But if you had some magic box that could reliably solve empty hard problems super quickly, that would give you an efficient factoring algorithm, therefore breaking the RSA crypto system. But obviously, that hasn't happened yet as far as we know. So let's move on to the last two rookie mistakes.
00:04:14.330 - 00:05:02.774, Speaker A: The fourth rookie mistake is something I'm hoping that all of you, having now worked with asymptotic analysis for some time, would not make. So rookie mistake number four is assuming that, well, computers keep getting faster and faster. So problems that are hard today are going to be easy tomorrow. So, as we've discussed in the past, advances in computing technology, and, for example, Moore's Law stating that computers will keep getting faster and faster, that all actually only makes the theory of NP hardness even more relevant. Remember, as our computing power scales, so do the sizes of problems that we're interested in solving. And the bigger the problems, the bigger the gulf between a polynomial running time and an exponential running time. So as technology gets better and better, empty hardness becomes more relevant than ever.
00:05:02.774 - 00:05:49.414, Speaker A: Rookie mistake number five is a very difficult one to avoid. In fact, people who do theoretical computer science for a living, you still see them making this mistake once in a while. So this rookie mistake concerns designing a reduction in the wrong direction. So remember that when we're doing, when we're proving that a problem is NP hard, the intractability spreads in the same direction as the reduction. So if you're deucing a problem A to A, problem B, intractability spreads from A to B. Now, when you're coming up with an empty hardness proof in the reduction that it involves, there's usually an overwhelming temptation to do it in the wrong direction just because that's the direction that we're used to. So you have to remember, if you're trying to prove that A, problem B is intractable.
00:05:49.414 - 00:06:27.314, Speaker A: The intractability has to spread from some other problem in the direction of that reduction. So you have to reduce a hard problem A to your target problem B rather than vice versa. And again, this is a very easy mistake to make. All of us make this mistake sometimes. So really, the only cure is to every time you think you've proved a problem as NP hard, go back and triple check that the reduction is going in the right direction, that the intractability is flowing from a known hard problem to the problem of interest. So that wraps up the five rookie mistakes I wanted to tell you about. Let me conclude with three sort of acceptable inaccuracies.
00:06:27.314 - 00:07:22.442, Speaker A: So these are going to be three statements which, strictly speaking mathematically, aren't quite correct, but everyone will know what you mean. If you make these inaccuracies, it won't shake anybody's confidence that you're a master of NP hardness. So the first acceptable inaccuracy is to just assume that the P not equal to NP conjecture is true, that it really is fundamentally more difficult to verify solutions to problems than to come up with your own solutions from scratch. Now, as we've discussed, we actually do not know to this day whether or not the P zero equal to NP conjecture is true or false. Our intuition is strong that it should be true. And so really, while it feels like we're waiting for our mathematical techniques to catch up to our intuition, most computer scientists sort of think of P zero equal to NP as a law of nature, and they just proceed as if it was true. So the second socially acceptable inaccuracy is to treat two terms as synonyms, when really they're not.
00:07:22.442 - 00:08:12.282, Speaker A: Those two terms being, first of all, NP hard, as we've been using it so far and will continue to use in most of these video lectures, and then a second term, which you may have heard of called NP complete. Basically, NP complete is a specific form of being NP hard. The details are kind of technical, so I'll discuss them only in those optional videos where I discuss formally what the complexity class NP is and what NP hardness actually means to first order. If you're focused on the algorithmic side, it really doesn't matter whether a problem is NP complete or NP hard. The takeaway is the same either way. These are problems that, assuming the P not equal to NP conjecture, there is no polynomial time algorithm that solves it. So whether you're NP complete or you're NP hard, you're going to have to make the types of compromises that we're going to discuss in the videos to come.
00:08:12.282 - 00:08:42.706, Speaker A: So the final acceptable inaccuracy is to equate NP hardness with requiring exponential time to solve. In the worst case. That's basically the oversimplified summary of NP hardness I gave to you when I first introduced the term. As we've seen since then, there's some subtleties that that overlooks. So, for example, there are problems that you can't even solve in exponential time. Like the halting problem. There are a few problems that seem to be sort of intermediate, too hard to be polynomial time solvable, but too easy to be NP hard.
00:08:42.706 - 00:09:45.586, Speaker A: Like factoring large integers is a major one. But generally speaking, day to day computer scientists do more or less equate NP hardness with worst case exponential time solvability. So no one will ever bat an eyelash if you find yourself implicitly sort of making this equating these two things in casual conversation. So that wraps up the sequence of videos for the first chapter of the book, chapter 19 just sort of explaining what is NP hardness intuitively? What are the consequences for an algorithm designer? What might you do about it when you encounter an NP hard problem? How do you prove problems are NP hard on your own? And so where we're going to go next is we're going to enrich your algorithmic toolbox with some new tools to make progress on NP hard problems when you do encounter them. And so coming up next, we're going to be focusing on fast heuristic algorithms. So this is going to be compromise we make for NP hard problems when we're willing to give up a little bit on correctness. We're willing to be a little bit wrong some of the time, but we really want a fast algorithm.
00:09:45.586 - 00:09:50.290, Speaker A: So that's where we're going to be going in the next sequence of videos. See you then. Bye.
