00:00:00.570 - 00:00:19.306, Speaker A: Hi everyone and welcome to this video that accompanies section 22.7 of the book Algorithms Illuminated part Four. My guess is you're probably getting pretty sick of these empty hardness proofs at this point. Totally understandable. So, good news. This is the fourth and final one that we will look at. It will again be a reduction from three Sat.
00:00:19.306 - 00:00:39.270, Speaker A: This time it will not be to a graph problem. It will be to a problem that involves only numbers known as the subset sum problem. And the subset sum problem is actually a special case of two familiar friends problems we've looked at in the past, both nafsac and makespan minimization. So in one fell swoop we will be proving both of those problems in Be hard as well.
00:00:39.340 - 00:00:40.380, Speaker B: Let's get started.
00:00:42.190 - 00:00:50.266, Speaker A: So the subset sum problem, a problem we haven't actually talked about at any previous point in these video playlists or in this book series. Let me tell you about it.
00:00:50.288 - 00:00:51.580, Speaker B: It's very, very simple.
00:00:52.270 - 00:01:44.592, Speaker A: The input is nothing more than a bunch of numbers. So we're going to have N numbers that we're going to call a one up to an and then we're also going to have a final number, capital T, which will serve as a target. All of these n plus one numbers are assumed to be positive integers. The goal then is just to identify a subset of the AIS whose sum is exactly capital T. So believe it or not, this super simple problem where the input is just a bunch of numbers, this is actually an NP hard problem. The way we're going to show that is we're going to reduce the independent set problem, which we proved NP hard a few videos ago, reduce the independent set problem to the subset sum problem, thereby showing that subset sum is also NP hard. What is the plan? Notice we're back to needing a plan.
00:01:44.592 - 00:02:33.184, Speaker A: This is a reduction between two problems that seem to have nothing to do with each other the independent set problem, a problem about graphs and the subset sum problem, which is a problem just about numbers. In other words, if someone handed you an efficient subroutine solving the subset sum problem on a silver platter, that would be like the magenta box. How do you build the light blue box? How would you efficiently solve the independent set problem? So just for this slide, rather than worrying about the optimization version of the independent set problem where you have to find a maximum size independent set for this slide only, let's just worry about the feasibility version of the independent set problem where I give you a graph and I give you a target independent set size K like 173. And your job is just to figure out whether or not there's an independent set that has size at least 173. That's all I'm going to ask from.
00:02:33.222 - 00:02:34.960, Speaker B: You on this slide.
00:02:35.540 - 00:02:54.296, Speaker A: So now the question is, given a graph and given a target k like 173, how can we metamorphose that into a bunch of integers so that there's a subset sum of a given target? In the instance that we construct, if and only if we started with the graph that does have an independent set.
00:02:54.318 - 00:02:55.690, Speaker B: Of size at least k?
00:02:56.220 - 00:03:08.936, Speaker A: One thing to be on the lookout for is that whatever encoding we use of a graph of an independent set instance in terms of numbers, we better be using really big numbers like magnitude exponential in the size of the graph.
00:03:08.968 - 00:03:10.190, Speaker B: That we started with.
00:03:10.560 - 00:03:59.928, Speaker A: The reason for that is that if the numbers aren't big, then not just subset sum, but even the more general knapsack problem is not a hard problem, it's a polynomial time solvable problem. We saw that when we discussed the dynamic programming algorithm for the Napsack problem. We saw an algorithm that runs in time big O of little n times capital C, where little n is the number of items in the input and capital C is the magnitude of the Napsack capacity. That algorithm shows that the Napsack problem, and therefore subset sum, is easy when the numbers are small. So the only hope of generating a hard instance of Napsack, or even more strongly a subset sum is to use numbers that are exponentially big. Those are going to be instances where our dynamic programming algorithms are no better than exhaustive search. Let me draw the usual kind of summary cartoon on the right part of the slide.
00:03:59.928 - 00:04:37.972, Speaker A: So our known NP hard problem here is the independent set problem. So that's the light blue box that we're trying to build and then the target problem, the one we're trying to show NP hard is subset sum. So that would correspond to the magenta box. A reduction goes from the known NP hard problem independent set to subset sum. And what we're hoping is that instances so graphs that have an independent set of at least a given size K, they're going to map to subset. Some instances that do have a subset who's summing to a target capital t, whereas if we started with a graph that does not have that big an independent set, we'll get a subset sum instance that does not have a subset sum with the appropriate target.
00:04:38.036 - 00:04:40.756, Speaker B: That's what we're shooting for our initial.
00:04:40.788 - 00:05:00.080, Speaker A: Attempt at the reduction, we're just going to use one number and a subset sum instance to encode each of the vertices of the graph. And the key idea is to use the lower order digits of the numbers that we construct to encode which edges are incident to the vertex. So to see how this might work, let's look at a simple example.
00:05:00.150 - 00:05:01.760, Speaker B: Let's look at a four cycle.
00:05:04.100 - 00:05:34.684, Speaker A: There are four vertices. So in this initial attempt we're going to be using four numbers, one for each vertex. Let's use a one, a two, a three, a four for the vertices, v one, v two, V three, V four. The leading digit of each AI is always going to be equal to one. And then there'll be four trailing digits which encode which of the four edges is incident to that vertex. So let's give everybody their leading digit of one. Now a one.
00:05:34.684 - 00:06:13.752, Speaker A: So we look at vertex v one and we see that it's incident to the first and fourth edges, e one and e four. So we're going to tack on four digits 1001. So the first one indicates that e one is incident to v one. The next two zeros indicate that edges e two and e three are not incident to v one. And then the final one encodes that e four is in fact incident to v one. So as a result we map vertex v one to the number 11,001. We can repeat the exercise with a two.
00:06:13.752 - 00:06:43.360, Speaker A: So the second vertex, the first and the second edges are incident to it, the third and the fourth ones are not. So here the four trailing digits are going to be 1100 and as a result vertex v two gets mapped to the number 11,100. Similarly the vertex v three gets mapped to the number 10,110 and the fourth vertex gets mapped to the number 10,011. Now here's what's cool.
00:06:43.430 - 00:06:44.448, Speaker B: Check this out.
00:06:44.614 - 00:06:47.156, Speaker A: So consider independent sets of size two.
00:06:47.258 - 00:06:49.812, Speaker B: In this graph there's only two of them.
00:06:49.866 - 00:07:47.044, Speaker A: There's one that picks the northwest and southeast corners, the first and third vertices and there's another one picks the northeast and southwest corners, v two and v four. Consider the first one v one and v three. Let's look at the sum of the two corresponding numbers, a one plus a three. Well if we sum up 11,001 and 10,110, what do we get? We get 21 111. What about the other independent set of size two, the v two along with the v four? Well, if we sum up the corresponding numbers, the a two and the a four, look at that, exactly the same sum, 21,111. Moreover, and I'll this for you to check that any other pair of vertices or any other subset of vertices is not going to give you this sum, it's going to give you a different sum. So for example, if you took v one and v two, which of course is not an independent set, you're going to get 22 101.
00:07:47.082 - 00:07:48.612, Speaker B: So it's a different sum.
00:07:48.756 - 00:08:02.236, Speaker A: So that seems pretty promising, right? The independent sets of size two are exactly correspond to the subsets of numbers with this target sum 2100 and eleven. But let's change the example just a little bit. Instead of a four cycle, let's think.
00:08:02.258 - 00:08:03.500, Speaker B: About a five cycle.
00:08:04.880 - 00:08:57.176, Speaker A: So we can use exactly the same idea. So now we have five vertices. So we're going to have five numbers and each of those numbers it's again going to have this sort of leading digit of one and then it's going to have five trailing digits, one digit for each of the five edges in the graph. And again that digit will be zero one according to whether the edge is not incident or incident to that vertex. So for example, the first vertex will be mapped to a number a 110,001, reflecting the fact that the first vertex is incident to the first and fifth edges but is not incident to the second, third and fourth edges. Similarly for the other four numbers. And what's annoying is the different size two independent sets now actually map to pairs of integers with different sums.
00:08:57.176 - 00:08:59.176, Speaker A: So for example, look at the independent.
00:08:59.208 - 00:09:00.750, Speaker B: Set v one and v three.
00:09:03.870 - 00:09:49.184, Speaker A: If you add together 110,001 and 101,100 what do you get? You get 211,101. Now let's try it again with the vertices v two and v four. Now unfortunately you don't get quite the same thing. Instead of 211,101, you get 211,000 and 110. So what's going on in general? So in general, a lower order digit of the sum, we're seeing a zero whenever it corresponds to an edge with neither endpoint in the independent set. So for example, when we take v one and v three, e four is not incident to either e one or e three. And that's why we're seeing a zero in the fourth of the trailing digits of the Blue sum.
00:09:49.184 - 00:10:07.836, Speaker A: Similarly, if we look at v two and v four, now it's the fifth edge, e. Five that is incident to neither v two nor v four and that's why we're seeing the zero in the last leading digit of the Brown sum. On the other hand, for any edge where one of its endpoints is in fact in the independent set, that's where.
00:10:07.858 - 00:10:08.956, Speaker B: You'Re seeing a one.
00:10:09.058 - 00:10:46.596, Speaker A: So for example in the Blue sum you see ones in the first, 2nd, third and fifth digits to reflect the fact that those are the four edges that are incident to the two vertices v one and v three. The final idea in the reduction is to introduce one additional number per edge. We already had one number per vertex. Now we're going to also add one number per edge. And the sole purpose of these new numbers are just to correct any digits that would otherwise be zero in the sum. So for the five cycle, in addition to a one through a five that we already had, we're going to have a b one through b five corresponding.
00:10:46.628 - 00:10:48.760, Speaker B: To the five edges in the graph.
00:10:49.260 - 00:11:13.296, Speaker A: So b one corresponds to the first edge and its job is to correct a zero if it shows up in the digit corresponding to edge e one. So that would be the first of the trailing digits or the second digit overall. So to correct for a zero in that first trailing digit, b one should be equal to 10,000. Similarly, on down the road b two that's supposed to correct the second trailing digit. So that should be 1000 and then the rest are going to be 110.
00:11:13.318 - 00:11:16.128, Speaker B: And one now we can set the.
00:11:16.134 - 00:11:22.576, Speaker A: Target just like we did for the fourth cycle. The leading digit should be two, all the other digits should be one. So in other words, the target sum.
00:11:22.608 - 00:11:26.388, Speaker B: Is going to be 211,111 and we.
00:11:26.394 - 00:11:54.044, Speaker A: Can now see how to make use of these new numbers, the BIS, to supplement our old blue and brown sums so that we get the desired target. So for example, in addition to a one and a three, we can supplement that with B four, reflecting the fact that edge e four is not covered by either v one or v three. Similarly for the independent set corresponding to v two and v four. So there it's edge e five that is left out in the cold. And so to correct that we use.
00:11:54.082 - 00:11:57.776, Speaker B: The fifth of the BIS and in.
00:11:57.798 - 00:12:51.152, Speaker A: General to achieve a target sum of 211,111, what do you need to do? You need to pick two vertices because you need a two in the leading digit and then you need the rest to be equal to ones. So you need it to be an independent set because if you didn't have an independent set, you'd be picking two endpoints of the same edge and you would see a two in the corresponding column. On the other hand, if you do have an independent set of two vertices, you can always complete that with corresponding bi values to get this target sum just by adding in a bi value for any digit where you would otherwise have a zero. So that's the idea of the reduction and that's what's going to work in general, one number per vertex, one number per edge. Leading digit is always one for the vertices. The rest of the digits encode the incident edges and then the numbers corresponding to the edges are just meant to correct for any digits that otherwise would be zero. So just to spell it all out.
00:12:51.152 - 00:13:22.804, Speaker A: So again, this is the reduction. We're responsible for building that light blue box. That light blue box should solve the independent set problem given an efficient subroutine for the subset sum. Problem given a magenta box for subset sum. So consider some instance we might see it's just going to be some undirected graph capital G. Let's label the vertices v one up to VN and the edges e one up to em. Also a little notation, let a sub I denote the edges or really the indices of the edges that are incident.
00:13:22.852 - 00:13:24.540, Speaker B: To the vertex of VI.
00:13:25.040 - 00:14:17.016, Speaker A: So the first thing the reduction does is it constructs numbers just like we did before. So there's going to be AIS one per vertex and there's going to be BIS one per edge. So the formal definition of a sub i, the number that corresponds to vertex v sub i, well we're going to have a ten raised to the m. This corresponds to that leading digit of one that we always had, plus we're going to have a one in any digit corresponding to an incident edge. So we're going to sum over the edges incident to vertex VI, and if EJ is incident to VI, then in the jth of the trailing digits we want to see a one. So that's going to correspond to ten raised to the m minus j power. But again, this is just saying in math exactly what we were doing on the last slide.
00:14:17.016 - 00:15:02.860, Speaker A: Leading digit of one plus, then zeros and ones according to which edges are incident to that vertex. Then for each edge EJ, as mentioned, we're going to have a number that corrects for a zero that would otherwise appear in the jth trailing digit. So BJ is just going to be equal to ten to the m minus j. So those are the numbers we're going to be using corresponding to the vertices and corresponding to the edges. So all we need now is our target sum capital T. At that point we have all the ingredients to feed into our subset sum subroutine and see what it says. So we're actually not just going to use one target sum capital T, we're going to search through a bunch of them, starting from very big target sums and then looking at smaller and smaller ones.
00:15:02.860 - 00:15:10.652, Speaker A: And the first point at which we succeed, that's going to tell us exactly how big the maximum size of the independent set is of the graph capital.
00:15:10.716 - 00:15:11.330, Speaker B: G.
00:15:14.690 - 00:16:02.638, Speaker A: So we're going to have a loop indexed by k and you should think of k as the size of an independent set that we're looking for right now. So if we have a graph with 10,000 vertices, we'll start very ambitious and we'll set k to be 10,000. Is there an independent set that includes every single vertex? And then if we find out the answer is no, we're going to decrease our ambition, say, well, what about one that's 9999? Is there an independent set of that size? The answer is no, we'll move on to the next iteration and so on. And if at some point, all of a sudden for the first time, for an iteration where k is equal to 3723, we do find an independent set of that size, we know that's got to be maximum. If you wanted to, I'm using linear search over k here for simplicity. If you wanted to be fancy, you could use binary search as well. But let's stick with linear search just.
00:16:02.724 - 00:16:03.920, Speaker B: To keep it simple.
00:16:04.690 - 00:17:01.926, Speaker A: So for a given size of independent set k that we're looking for, at that point we know exactly how we want to set the target sum. So basically in the trailing digits we want to see ones everywhere, just like in the example, and then in the leading digits we just want to see the size of the independent set that we're looking for. So in our examples we were looking at independent sets of size two, and so that's why we had a two always in the leading digit of our target sums. Having specified the target, we can now invoke our assumed subroutine for the subset sum problem. We just ask it, hey, could you return to us a subset of the AIS and the BJS that has total sum equal to this capital T and the subroutine will either will hand us such a subset or it'll correctly tell us that no such subset exists. The subroutine reports that no subset with that sum exists. Then we just sort of move on to the next iteration, to the for loop.
00:17:01.926 - 00:17:34.434, Speaker A: We try again with decreased ambitions, lower target size for an independent set. If it does return a subset of the AIS and the BJS, well then we're just going to return the vertices that correspond to the AIS in the sum. So if the sum has like a one, a three and a five, along with some B's like B seven and B nine, whatever, we're going to return the vertices v one, V three and V five. And that will be our final answer, which, as we'll see in the proof of correctness in the next slide, will in fact be a maximum weight, maximum independent set of the input graph capital.
00:17:34.482 - 00:17:37.922, Speaker B: G. This definitely qualifies as a reduction.
00:17:37.986 - 00:17:55.822, Speaker A: In the sense we've been using the term. It does invoke the assumed subroutine for subset sum multiple times n times. So it's a polynomial number of indications that's allowed and outside of the subroutine calls it does a polynomial amount of work. So if this is correct, this would indeed be a reduction from independent set.
00:17:55.876 - 00:17:57.774, Speaker B: To the subset sum problem.
00:17:57.892 - 00:18:36.198, Speaker A: Let's now see why it is in fact correct. Let's start with a few basic properties of the reduction. Think about any subset of the numbers that we just constructed, any number of the AIS, any number of the BJS. Let's say there's S AIS, and then I don't care how many BJS there are. So maybe 17 AIS and 23 BJS in a subset. What is that sum going to look like? Well, it's definitely going to have as its leading digits, it's going to have S, the number of AIS, because those are the only ones that have a one in the leading digit. So in our example, the sum is going to start with a one and a seven because there's 17 of the AIS.
00:18:36.198 - 00:18:58.286, Speaker A: Then we're going to have these M trailing digits, one for each of the edges, and each of those trailing digits is going to be either zero, one, two or three. And the reason is that there's only three different numbers that we've constructed that could possibly contribute to one of the trailing digits. So for example, consider the 40th trailing digit.
00:18:58.398 - 00:19:00.706, Speaker B: Which numbers could possibly contribute to it?
00:19:00.808 - 00:19:17.286, Speaker A: Well, it's B sub 40, right? That's the number that's basically a one only in the 40th trailing digit and then zeros. Otherwise that can contribute one and then the two endpoints of edge e 40, they also have a one in the 40th trailing digit. But that is it. Those are the only three numbers that.
00:19:17.308 - 00:19:19.682, Speaker B: Can contribute to the 40th trailing digit.
00:19:19.826 - 00:20:22.432, Speaker A: So you sum up all these numbers, you're going to get however many AIS you have in the leading digits, and then you're going to get a bunch of zeros ones and twos and threes in the m trailing digits. So what this tells us is that there's only a very limited number of ways that a subset of these numbers could possibly have the target sum capital T. Remember what capital T is. The leading digits should be equal to k, where k is the size of the independent set that we're wondering about. And then all of the m trailing digits should be equal to one. So how is it that the leading digits could possibly be equal to k? Well, from the first observation we see, the only way that could happen is if the subset included k of the AIS, which would then correspond to k vertices of the original graph g. Moreover, if all of the trailing digits are at most one, it must be that those k vertices form an independent set of the graph g that we were given.
00:20:22.432 - 00:21:17.184, Speaker A: Because if two of those vertices had the same endpoint so like if the set included both endpoints of the 40th edge, then the 40th trailing digit would not be one, it would be two or more. So now for each iteration of the reduction so for each target independent set size k and corresponding target capital T, we're again going to have two cases saying the reduction does the right thing in either case. So, first of all, if the graph did not have an independent set that was that big of size K, there should not be a subset sum of the target sum. Capital T. On the other hand, the first time k reaches a number where there is an independent set in g of that size, then in fact we should extract that from a corresponding subset sum. So for the first case, consider an iteration where actually k is really big. So there is no independent set of size k in the input graph, capital G.
00:21:17.184 - 00:21:52.908, Speaker A: The claim is then in the subset sum instance that we construct, there will be no subset with the target sum. And of course, the subroutine will then correctly tell us that fact and we'll move on to the next iteration as we have to. So why is that the case? Well, if there was a subset with the target sum capital T from these couple observations, we know we could extract from it k vertices that form an independent set of g. But that doesn't exist in this first case. So that subset can't exist. So we're never going to be tricked into thinking that there's an independent set when there isn't. If there isn't an independent set, there won't be a subset sum and the.
00:21:52.914 - 00:21:55.070, Speaker B: Subroutine will clue us into that fact.
00:21:55.680 - 00:22:35.800, Speaker A: Now, at some point k will get small enough that the input graph g really will have a size k independent set. So what happens then? Well, the reduction will construct this instance of subset sum and the claim is that instance will indeed have a subset with the target sum capital T. And in fact, you can read off such a subset from any size. K independent set of the graph g. Namely, given the K vertices of g that are an independent set, you just include in the subset the corresponding AIS that makes sure the leading digits are equal to K. And because it's an independent set. All of the trailing digits will be equal to either zero or one, depending on how many endpoints of an edge are included in that independent set.
00:22:35.800 - 00:23:23.576, Speaker A: And then just whatever digits have the zero, you throw in the corresponding BJS to correct it and bump it up to one. So if there's a size k independent set, then there will in fact be a subset that has the target sum capital T. With our subset sum subroutine, it will return to us some subset of that form. And as we saw from our basic observations, once we're given a subset with a target sum, we can extract from it a size k independent set. So in the very first iteration where a size k independent set exists in G, this reduction will indeed find it and return it. So that completes the correctness of this reduction. Given an efficient subroutine from subset sum, you really can solve the independent set problem because independent set problem is NP hard.
00:23:23.576 - 00:23:32.412, Speaker A: Subset sum is NP hard as well. And as we've seen subset sum, it's a special case of both Napsack and makespan minimization. So now we know those two problems.
00:23:32.546 - 00:23:34.190, Speaker B: Are NP hard as well.
00:23:35.120 - 00:24:05.236, Speaker A: That's the last of the NP hardness reductions that I wanted to torture you with. So you can breathe a sigh of relief about that. Having seen this parade of NP hardness reductions, I hope a few things have happened. So one I hope it's sort of closed some loose ends that we had earlier on. In this video playlist, I was throwing you all these different problems, just sort of promising you that they were NP hard. Promising you that we needed to resort to something like a heuristic algorithm or something like an exponential time algorithm. Better than exhaustive search.
00:24:05.236 - 00:24:10.324, Speaker A: Now we know that that is in fact true. Now we know that all those problems are indeed NP hard and do require.
00:24:10.372 - 00:24:13.240, Speaker B: The kinds of compromises that we were looking at.
00:24:13.390 - 00:25:08.140, Speaker A: Secondly, now you know a whole bunch of NP hard problems. So if you want to prove a new problem is NP hard in your own work using that two step recipe, you have a lot of options for what you can pick for the known NP hard problem, which we were calling capital A. And again, you can look in a book like Gary and Johnson to find many more examples of NP hard problems. And finally, while these reductions may have been kind of messy and pretty problem specific, and you probably won't remember any of the details even a week from now, you watch this video, right? It wasn't that bad. I mean, we did sort of slog through it. And so if you really were sort of locked in a room and no one was willing to let you out until you proved that some problem is NP hard, having seen all these, I hope you feel like, you know what? If I really had to do it, I could. I hope you now feel like you have those skills, that your level of expertise with NP hardness is up to level three.
00:25:08.140 - 00:25:46.936, Speaker A: You now can recognize NP hard problems in the wild. So from here, there's sort of a fork in the road. There's two different directions you can go. So in the next chapter, chapter 23, that's an optional chapter. It's more mathematical than the rest of the playlist. And that's for those of you that want to bring your level of expertise with NP hardness all the way up to level four, where you could really just sort of go to a whiteboard and explain what the P versus NP question is to one of your colleagues. So for those of you that are interested in that, the mathematical underpinnings of NP hardness and the P versus NP conjecture, definitely check out the next set of videos corresponding to chapter 23.
00:25:46.936 - 00:26:16.044, Speaker A: If that sounds like too much or just sort of not how you're interested in spending your time, I really encourage you to jump to Chapter 24, which is going to have a detailed case study of how almost all of this algorithmic toolbox that we've been studying was put to use in a super high stakes application major auction called the FCC incentive auction that was run just a few years ago and that involved tens of billions of dollars. So even if you don't want if you want to skip the math, I hope you don't skip chapter four and.
00:26:16.082 - 00:26:17.630, Speaker B: That final case study.
00:26:18.160 - 00:26:21.524, Speaker A: In any case, whichever route you choose to go, I look forward to seeing.
00:26:21.562 - 00:26:23.760, Speaker B: You in the next video. Bye.
