00:00:00.490 - 00:00:39.218, Speaker A: Hi everyone. My name is Tim Roughgarden and I'd like to welcome you to this video playlist that accompanies the book Algorithms Illuminated. Part Four algorithms for NP hard Problems So in this opening video, I just wanted to say a little bit about the background that I'm going to be expecting you to have throughout this video playlist and also give you a brief overview of the contents. So as far as prerequisites, I mean, you know, this is part four before part series. So I will be assuming you have basic familiarity with some of the most important concepts from the first few parts. So for example, Asymptotic notation I will assume you've seen before, especially big O notation for analyzing the running time of algorithms.
00:00:39.394 - 00:00:40.566, Speaker B: I hope you've seen a couple of.
00:00:40.588 - 00:01:21.062, Speaker A: Basic data structures, things like heaps or search trees. I hope you have at least some familiarity with graphs. So for example, the fact that you can search a graph efficiently using an algorithm like breadth or depth for search and that you can compute shortest paths efficiently using an algorithm like Dijkstra's algorithm. And finally, I hope you've seen a couple of the most important algorithm design paradigms. So for example, a few examples of greedy algorithms and dynamic programming algorithms. Now, you don't have to be a math whiz to make it through this video playlist, but I hope math isn't completely foreign to you. So for example, if I write down a summation sign on a slide to sum up over a bunch of numbers, I hope that's something that you've seen before.
00:01:21.062 - 00:01:25.138, Speaker A: Hopefully you've seen examples of proofs by induction and proofs by contradiction.
00:01:25.314 - 00:01:26.502, Speaker B: And if I write down a function.
00:01:26.556 - 00:01:48.862, Speaker A: Like the logarithm function or the exponential function, I very much hope that doesn't frighten you too much. I hope you've seen that in the recent past. So maybe you have this background because you've watched the previous three playlists. Maybe you even got it because you read the previous books of the series. That would be awesome. Maybe you took a class from a different textbook a long time ago. That's fine.
00:01:48.862 - 00:02:29.290, Speaker A: However, you have the background. That's great. That's what I'm expecting you to know as we go forward. So what is the book about? The book is about NP hard problems and what to do about them. So it's a sad fact that a lot of the computational problems that show up in the real world are what are called NP hard. And these are problems that we believe are fundamentally unsolvable by the types of always correct and always fast algorithms that have starred in the first few playlists in the first three books of this book series. So what that means is if you're confronted with tackling an NP hard problem in one of your own projects, you must compromise either on correctness or on speed.
00:02:29.290 - 00:03:32.810, Speaker A: If you compromise on correctness, that puts you in the realm of fast heuristic algorithms, algorithms that are always going to run quickly, but at least in some cases will not output a correct solution. So the goal then for the algorithm designer is you'd like a fast heuristic algorithm which is at least approximately correct in some sense. So we'll revisit an old algorithm design paradigm, the greedy paradigm, and we'll see its application to the design of fast heuristic algorithms. And we'll also look at a technique that maybe you haven't seen before, namely local search, which is very effective for lots of different empty hard problems in practice. Our case studies in this part of the playlist will include the famous traveling salesman problem problems in scheduling, in team hiring, and even influence maximization in social networks. The alternative is to compromise on speed. So here you're going to be designing an algorithm which is always guaranteed to be correct, but will not on all inputs, run quickly and even, you'd expect will run in exponential time, at least in some cases.
00:03:32.810 - 00:03:59.674, Speaker A: So here the goal is to design an algorithm which at least is an improvement over some naive algorithm like exhaustive search. So we'll again revisit an old algorithm design paradigm, namely dynamic programming, and we'll see its application to beating exhaustive search for different NP hard problems. And again we'll look at some tools that maybe you haven't seen before, specifically state of the art solvers for mixed integer programming and satisfiability problems.
00:03:59.872 - 00:04:01.546, Speaker B: So our case studies in this part.
00:04:01.568 - 00:04:57.020, Speaker A: Of the playlist will include the traveling salesman problem, yet again finding signaling pathways and protein protein interaction networks, and even a high stakes auction which was run in the US. For wireless spectrum a few years ago. This book will also give you the skill to recognize NP hard problems when they show up in the wild, when they show up in your own work. And this is actually a super important skill, right? Because you don't want to inadvertently waste time trying to design an always correct, always fast algorithm for a problem if that algorithm doesn't even exist. So you'll acquire familiarity with several famous MP hard problems ranging from, say, satisfiability to graph coloring to the Hamiltonian Path problem. And through examples, you'll also learn the tricks of the trade in NP hardness reductions. And this will give you the skills to be able to prove that new problems are NP hard as well when they show up in your own work.
00:04:57.020 - 00:05:05.818, Speaker A: Finally, if you've ever heard of the P versus NP conjecture and wondered what it was all about, that is also something you will learn in this video playlist.
00:05:05.994 - 00:05:53.840, Speaker B: So let's look at a more detailed overview of the book's contents. So, first, chapter 19 is all about what is NP hardness. So this chapter explains at a high level what the NP hardness is, what it means for the algorithm designer, what are the tools you have available to tackle problems that are NP hard? And what's a simple recipe for recognizing NP hard problems when they come up in your own work. And so the goal of this first chapter is really twofold. So first of all, after this sequence of videos, you'll already have an accurate but pretty superficial understanding of what MP hardness is that already, I think, is useful in its own right. But also this first series of videos will get you oriented. And I'll give you the context when we do a deeper dive into the later chapters, into the later videos.
00:05:53.840 - 00:06:47.466, Speaker B: So in the second chapter, Chapter 20, we're going to be looking at compromising on correctness. So we're going to look at algorithms which are guaranteed to run quickly, but are only in some sense approximately correct. The first half of the chapter will focus on heuristic algorithms with provable guarantees that are guaranteed to be close to optimal, primarily using greedy algorithms. And the second part of the chapter will discuss local search and its variance, which often does not have provable guarantees, but is nonetheless unreasonably effective at tackling many NP hard problems in practice. Chapter 21, we'll talk about the other type of compromise you can make with NP hard problems, which is compromising on speed. So you want to be guaranteed to always be correct, however you're willing to run in more than polynomial time, at least some of the time. So here again, we'll talk about half of the chapter on provable guarantees.
00:06:47.466 - 00:07:33.674, Speaker B: We'll show how dynamic programming algorithms can beat exhaustive search for some interesting problems, including the traveling salesman problem. And then we'll also look at some methods that don't really have provable guarantees, but again, are unreasonably effective in practice, specifically, state of the art solvers for mixed integer programming and satisfiability. So those two chapters, chapter 20 and Chapter 21, that's really about enriching your algorithmic toolbox. So if someone hands you a problem and tells you that it's NP hard, then you kind of know what to do. You have some things you can throw at it. But there's still the question, like, what if there's a problem? And you don't know if it's NP hard or not? How do you know whether you should apply this toolbox you've just learned or go back to the old toolbox for designing fast and exact algorithms? Well, that's the point of Chapter 22. So we want to give you the skills to allow you to quickly recognize NP hard problems.
00:07:33.674 - 00:08:05.042, Speaker B: So no one needs to tell you it's NP hard. You can figure it out for yourself, and then it is MP hard. Then you can default to the skills that you already gained in the previous two chapters. So in these first four, chapters 19 through 22, a quite superficial understanding of NP hardness will be sufficient for everything we want to discuss. So as an algorithm designer, if you just want theory of MP hardness to guide you about how you should tackle various problems, you can get away with a pretty superficial understanding. And that's all we'll be using in these first four chapters. That said, I'm sympathetic and very excited.
00:08:05.042 - 00:08:15.642, Speaker B: If you want to know more, if you want to say no, what really, what is the mathematical definition of NP and NP hardness? Maybe you've heard of the P versus NP conjecture. Maybe you want to know what is that really?
00:08:15.696 - 00:08:16.410, Speaker A: What is P?
00:08:16.480 - 00:08:34.986, Speaker B: What is NP? Why should they be the same or different? What's the state of the art in mathematics and understanding the conjecture? So we'll talk about all that in chapter 23. That's an optional set of videos for those of you that want to dig deeper into the mathematics. And in particular, we'll highlight the P versus MP conjecture and some stronger variants, like the exponential time hypothesis.
00:08:35.178 - 00:08:36.946, Speaker A: So to conclude, as a sort of.
00:08:36.968 - 00:09:27.726, Speaker B: Dessert, in the last chapter, chapter 24, we're going to talk about this algorithmic toolbox in action in a real high stakes application involving tens of billions of dollars. So the application concerns an auction that was run by the FCC in the United States back in 2016, extending into 2017. The point of this auction was to sell licenses for wireless spectrum. So one of these licenses gives you the right to use a portion of certain frequencies in a certain geographic area. So the government wanted to sell a whole bunch of these licenses all at once, in effect, to the highest bidder. Now, it turns out the auction that they wanted to use for this application fundamentally involved computationally difficult problems, NP hard problems. And so for the actual deployment of the auction that was rolled out in 2016, that implementation used a surprisingly wide swath of the toolbox that you will learn in this playlist.
00:09:27.726 - 00:09:43.606, Speaker B: In that case study, we'll see everything from graph coloring problems to fast heuristic algorithms based on greedy algorithms to the use of satisfiability solvers. So all of that is meant to sort of tie all of the themes of the book and of this video playlist together in one place.
00:09:43.708 - 00:09:44.838, Speaker A: But also, I hope, it just kind.
00:09:44.844 - 00:10:03.050, Speaker B: Of shows you that this is a pretty sophisticated toolbox you will have mastered by the end of this playlist. And it's actually something that can be a make or break skill in important applications. So that's an overview of what you'll learn if you go ahead and go through this whole playlist or go through the book. Let's proceed to what is NP hardness?
