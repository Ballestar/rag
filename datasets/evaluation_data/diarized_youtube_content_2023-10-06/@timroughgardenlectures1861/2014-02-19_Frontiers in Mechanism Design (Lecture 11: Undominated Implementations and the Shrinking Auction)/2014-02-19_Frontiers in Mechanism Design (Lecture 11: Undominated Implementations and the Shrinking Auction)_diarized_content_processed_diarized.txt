00:00:00.650 - 00:00:44.230, Speaker A: All right, so let me go ahead and get started. I just want to make a few final comments about sort of the part two of the class, and then we're going to move on to part three. So where are we? So we've been striving for these three things. We've been looking for strong incentive guarantees so far, DSIC or Epic back in part one, welfare optimal or almost optimal, and polytime mechanisms. And up to this point in the class, we constrained ourselves to these super strong incentive guarantees. We could get away with it in part one because I sort of shepherded you through tractable special cases where he'd get everything we want. We just finished a couple of weeks, though, of NP hard special cases of welfare maximization.
00:00:44.230 - 00:01:17.410, Speaker A: And what we discovered is that just already two and three jointly is nontrivial. It's NP hard. So you're looking for approximation algorithms, but at least there's a lot of tools, there a lot of positive results known. But then if you add in DSIC on top of it, things get actually quite difficult indeed in two senses. So first of all, the positive results that are known, you have to work quite hard to get those positive results, and complex mechanisms seem required to get them. And then secondly, and this is what I'll comment on at the moment, is there's lots of cases where it's just simply impossible.
00:01:17.490 - 00:01:17.686, Speaker B: Okay?
00:01:17.708 - 00:01:54.266, Speaker A: So no matter how hard you work, no matter how complex your mechanism, you can't get all three of these properties simultaneously. Let me just comment on some negative results. So, scenario number eight, this was what motivated us throughout part two. This was bidders with sub modular valuations. So this was just a little bit beyond gross substitutes, but already welfare maximization was NP hard. And part two culminated with a positive result. Last week, we showed that for a special case of submodular valuations, namely these coverage valuations, we gave a DSIC mechanism that was very good, that was 63% of the optimal welfare.
00:01:54.266 - 00:02:42.910, Speaker A: And that's actually best possible, even ignoring incentives, unless P is different than NP. But what about sort of the general version of scenario eight? So what about full blown sub modular valuations without this coverage restriction? And let's say I give you black box access just through value oracles. And that's all we needed. All we were using was value oracles with the coverage valuations. So with just two and three jointly, the news is good. Okay, so there's a beautiful algorithm by Vondrak, which those of you who just sort of like commentrail optimization, I recommend reading this sometime, it's really a very nice algorithm. And so this says ignoring incentives can get one minus one over E for sub modular valuations only using a polynomial number of value queries.
00:02:44.050 - 00:02:44.800, Speaker B: Okay?
00:02:45.490 - 00:03:56.150, Speaker A: So this says there's at least no obstruction to a complete solution for scenario eight, just from parts two and three. So the question is, what happens when you add in DSIC also, and it turns out we now understand that the problem is just fundamentally much, much harder. I insist that you solve the problem using a DSIC mechanism. So basically, a pair of papers by Doug Zinsme and Doug Me and Vondrak basically show that nontrivial I'm not going to state the formal version, but nontrivial approximation here, nontrivial means anything better than a polynomial approximation factor. So we're talking just beating something really terrible like root M, where M is the number of items. So forget about 63%. I mean, just anything, certainly any constant, no matter how small, requires an exponential number of value queries, okay? So this is DSIC, and this is even if it's just what's called a truthful and expectation mechanism, so it's not just for deterministic.
00:03:56.150 - 00:04:09.430, Speaker A: The first results for deterministic and some bells and whistles on them, and then the second paper shows that even with the full blown MIDR mechanisms, you can't do better. You can't get nonchrivic approximation with less than exponentially many value queries.
00:04:09.510 - 00:04:09.994, Speaker B: Okay?
00:04:10.112 - 00:04:28.182, Speaker A: And this despite being sort of bad news, just intellectually, this is a real kind of triumph of this algorithm game theory field, actually. So a lot of these results have only been the last five years or so. We now understand in a rigorous sense how incentives make NP hard problems much, much harder than if you just care about approximation algorithms.
00:04:28.266 - 00:04:28.994, Speaker B: Okay?
00:04:29.192 - 00:05:02.566, Speaker A: So I'm not going to talk about this now. I think especially this first paper would be a good topic for a bonus lecture. So maybe in a couple of weeks, if there's interest, we can talk about it. It's a doable argument. So instead what I want to do now is plunge on to step three where we say, let's relax this. So let me just write something weaker here and with the hopes of getting sort of two benefits. First of all, just that these negative results, we want them to go away and they will go away, so we'll get much more sweeping positive results.
00:05:02.566 - 00:05:47.114, Speaker A: Also, the mechanisms will get simpler, generally speaking, okay? So the incentive guarantees won't be as strong, but there'll be lots of other benefits. Other thing I want to mention here, so sort of a really kind of nice open question is if you have demand queries. So let me just jog your memory. What are all these queries? So in general, if you have evaluation, value query just says you ask it for a set and it tells you back what the value of that set is. Kind of any reasonable model evaluations, you can implement value queries in polynomial time. Demand queries, while they're useful and natural in an auction context, it sort of depends. We've actually seen some examples where demand queries are NP hard, including coverage valuations that we talked about last week.
00:05:47.114 - 00:06:31.078, Speaker A: But sometimes you can implement these in polynomial time, and when you can, you can do useful things with them. And the main application you saw of demand queries was when we solved the LP relaxation of the welfare maximization problem. How did we solve it? We passed to the dual, the separation oracle for Ellipsoid in the dual was a demand query. So that's what we needed to solve that linear programming relaxation. And we've used that in a couple different contexts. So it's known that you actually with demand queries and in a DSIC mechanism can get a non trivial approximation, although it's basically logarithmic in the number of goods and we don't know whether a constant factor is possible or not. So that's sort of a major open question, sort of in this part of the world, can you get a constant factor DSig mechanism with demand queries? You cannot with just value queries.
00:06:31.174 - 00:06:31.820, Speaker B: Okay.
00:06:32.910 - 00:07:14.760, Speaker A: All right. So on the part three, so we're going to compromise on the incentive guarantee. And the question now is what compromises could we make? What would be a sensible weakening of dominant strategy incentive compatibility? So the main answer to that is something called Bayesian incentive compatibility. And so that's where I'm not going to talk about that in this first lecture, but we'll talk about it a bit toward the end of the day and quite a bit for the rest of the class. And that's where we're going to have a common prior. And basically we're going to ask that all the bidders are optimizing an expectation over this prior. And that's sort of a very traditional approach to mechanism design.
00:07:14.760 - 00:07:51.314, Speaker A: Before we get to these Bayesium incentive patentable mechanisms, I want to take a detour. I want to show you one result, which at this point is sort of a curiosity in the literature. So the incentive guarantee will be weaker than DSIC. Bidders will not have dominant strategies in the auctions, I will show you, but it will still very much have the spirit of DSIC. We have to make very minimal behavioral assumptions to argue that we get what we want from this mechanism. And I'll be precise about that. But this sort of notion of a little bit weaker than DSIC, basically players not playing stupid strategies, there's not a lot known either on the positive side or the negative side.
00:07:51.314 - 00:08:22.080, Speaker A: I'm going to show you kind of the main positive result known. We don't really know anything negative. So again, this seems like a very interesting direction for more research. So this will be all of the first lecture today and I might spill over after the break a little bit also. So DSIC, the only behavioral assumption was that if a player has a dominant strategy, they play it. So a foolproof strategy players will play. Now we're just going to assume that if there are stupid strategies, bidders don't play the stupid strategies stupid, meaning it's dominated, sort of obviously dominated by something else.
00:08:22.080 - 00:08:31.630, Speaker A: So assume bidders don't play stupid strategies.
00:08:34.450 - 00:08:34.814, Speaker B: Okay?
00:08:34.852 - 00:08:50.950, Speaker A: And I'm not, you know, in the context of the concrete mechanism. It'll be very clear what I mean by this. It'll be very clear what I'm assuming. All right, so any questions before I start sort of talking to you about the setting and the mechanism where we look at this relaxation of Dsick?
00:08:52.250 - 00:08:53.000, Speaker B: Okay?
00:08:54.490 - 00:09:37.622, Speaker A: All right, so this is going to be another scenario, but not very different than some of the other ones we've seen. So this is going to be called single value, multi minded bidders. So let me say what I mean. So we again have our set of nonidentical goods in each bidder I. We don't know what it wants, but we know there's some bundles of goods that it wants. So the simplest case would be sort of unit demand. We know it wants a singleton good, and it doesn't care which singleton it gets.
00:09:37.622 - 00:10:06.650, Speaker A: Or maybe it wants a pair and we don't know which pair. Okay, so there are these things that these bundles that it wants could be one, could be many. We don't know. And then a strong assumption, but one that's important for the results, I'll say, is valuation VI. And VI is the same for all of the bundles.
00:10:06.810 - 00:10:07.614, Speaker B: Okay?
00:10:07.812 - 00:10:24.082, Speaker A: So it's in the spirit of unit demand and that the bidder doesn't want many of these. It only wants one. And as soon as it gets one of these bundles, it gets a value of VI. So, again, a very simple case would be the bundles are just the singletons of U that just says, I want one. Good. To me, they're all the same. I don't care which I get.
00:10:24.082 - 00:10:25.418, Speaker A: It's worth $5.
00:10:25.534 - 00:10:26.200, Speaker B: Okay?
00:10:27.450 - 00:11:13.134, Speaker A: Okay, so formally, given this information, the valuation for bidder I is just defined as VI. If S includes one of these desired bundles, some AIL, and zero otherwise. Okay, so it's single value because there's the same value for every bundle, and it's multi minded because these are the multi, the bundles it might want. All right, so what are some other examples? So one example, imagine you could imagine that you have a network, and as a bidder, you have some source and some sync in this network, and those are private. The seller doesn't know what they are. And then what you want is just a path from your source to your destination.
00:11:13.262 - 00:11:13.602, Speaker B: Okay?
00:11:13.656 - 00:11:37.174, Speaker A: And so then here, goods correspond to edges, and the bundles correspond to the path from your source to your destination. If the seller doesn't know your source and destination, it doesn't know your bundles. And then this assumes you don't care which path you get. You just want some path. Another example you can imagine you're a firm, and you just want some task to get done. VI is sort of the value for getting this task done. And you need some workers that have enough skills that are needed for the task.
00:11:37.174 - 00:12:05.814, Speaker A: And so maybe sometimes three workers are good enough to accomplish this task. Maybe if you get some really good workers two of the workers are good enough for this task. And you don't care which ones you get, just as long as the task can be achieved. So those would be some examples where you might see this questions about that. So let me develop your intuition by mentioning two special cases that can be solved by DSIC mechanisms. And you may have even done these on homework last quarter. I don't actually remember.
00:12:05.814 - 00:12:45.902, Speaker A: So special case number one is when, if I also tell you what these bundles are. So special case number one, ails all publicly. So in other words, you know what bittereye wants, you just don't know how much they're willing to pay for it. You don't know VI. That's the only thing which is still private. So these are the kind of problems that we talked about some last quarter. This is a single parameter problem.
00:12:45.902 - 00:13:19.606, Speaker A: Now, from a bidder's perspective, either they get a bundle they want or they don't get a bundle they want. And they have this private value and that's sort of like winning. And they have this private value in VI for winning. So this is where we have Myerson's Lemma that says allocation rules can be turned into DSIC mechanisms if and only if the allocation rule is monotone, meaning the more you bid holding everyone else fixed, the more likely you are to win. Or you only switch from losing to winning, never the reverse if you raise your bid. So this is a single parameter problem. And one of the things we talked about last quarter is how greedy algorithms often give monotone allocation rules and therefore lead to DSIC mechanisms.
00:13:19.606 - 00:13:42.900, Speaker A: And that's equally true here. So greedy gives a D sick. There's one parameter I forgot to tell you about. So we're going to assume that all desired bundles have cardinality at most D.
00:13:44.790 - 00:13:45.540, Speaker B: Okay?
00:13:46.790 - 00:14:25.470, Speaker A: And D is known to the seller. So you might want to think of like D as maybe six. And then the bundles have sizes one, two, three, or four, something like this, okay? So greedy gives a DSIC one over D approximation. So let me tell you what I mean by greedy. So what I mean by greedy is you just sort the bidders from so you get people's reported valuations. You sort them from high to low. You start with the highest bidder.
00:14:25.470 - 00:14:58.618, Speaker A: You give them one of their bundles. You go to the next highest bidder, you look at the bundles they want. If any of them don't conflict with goods you've already allocated, you give them one of them and so on, and you just go through the bundles in this way. Allocating people a bundle if you can. So that's going to be monotone because as you raise your bid, you go only earlier in this ordering, okay? So if you get allocated later, you're going to get allocated earlier as well by greedy. Now, this is not an optimal algorithm. It doesn't maximize welfare, but it loses a factor D.
00:14:58.618 - 00:15:07.114, Speaker A: Okay? And I'll leave the proof as an optional exercise. But the intuition, I hope, is very clear. So you give someone a bundle, and it hasn't most D items.
00:15:07.242 - 00:15:07.966, Speaker B: Okay?
00:15:08.148 - 00:15:44.938, Speaker A: So how could you have screwed up by giving these D items to this bidder? Well, maybe by giving this bidder those D items, you blocked these D other bidders in the optimum that you really wish you had allocated instead. Okay, but you're running a greedy algorithm. So those D bidders values is at most as much as the one you're just getting credit for now. So you get once times a value instead of D times a value. So that's the one over D. Okay, so this is an empty hard problem. So even in this public bundle case, and it's not trivial to approximately maximize welfare, in fact, you can't do much better than D.
00:15:44.938 - 00:15:53.146, Speaker A: So there's a reduction from independent set and bounded degree graphs that shows basically one over D is what you're stuck with, and greedy already gives it to you.
00:15:53.248 - 00:15:53.900, Speaker B: Okay?
00:15:54.270 - 00:16:03.730, Speaker A: So this special case, we kind of subject to P versus NP, worst case approximation, we know what to do with it. You just run greedy and this will be relevant for the mechanism that I show you.
00:16:03.800 - 00:16:04.420, Speaker B: Okay?
00:16:05.910 - 00:16:37.818, Speaker A: All right, so special case number two and can't do much better. So special case number two is when each bidder has only one bundle. So when each bidder has only one AI. So that's called single minded bidders. But in this case so it's incomparable to special case number one in the sense that over here, you don't know what the bundle is.
00:16:37.904 - 00:16:38.540, Speaker B: Okay?
00:16:40.050 - 00:16:48.590, Speaker A: So only one unknown bundle per bidder.
00:16:51.090 - 00:16:51.840, Speaker B: Okay?
00:17:04.530 - 00:17:17.394, Speaker A: So this now is not a single parameter problem, right? Because there's two things you don't know about a bidder. You don't know its value VI, and you don't know the bundle that wants AI. So like Meyerson's Lemma, for example, doesn't apply automatically.
00:17:17.522 - 00:17:18.200, Speaker B: Okay?
00:17:19.130 - 00:17:55.662, Speaker A: But it turns out greedy still gives a DSIC one over D approximation. Okay, so what do I mean by greed D? Well, so now you have to ask people for two things, not just one thing. Before we asked them just for their value. Now we say, what's your value and what's your set? And now you run the same algorithm you did before. You just sort them from high to low by reported values and you just greedily give them a set if you can. Okay, so it's definitely a one over D approximation if it's Dsick, because it's sort of a special case of the previous algorithm. And you can sort of prove just from scratch that it's DSIC.
00:17:55.662 - 00:18:23.790, Speaker A: Basically, it's sort of close enough to a single parameter problem. You can just prove that it works intuitively from a bidder's perspective. Given that it only wants this one set, it's never going to report a set that excludes any of the items that it wants. Because then it's guaranteed zero utility. And by enlarging the set, you only make it more likely that you're not going to be feasible when the greedy algorithm gets to you. So there's not really any reason to lie about the set. And then once you're not lying about the set, it basically defaults back to the single parameter analysis.
00:18:23.790 - 00:19:14.826, Speaker A: So again, I'll leave the details as an optional exercise, but that's kind of the idea of why this is also DSIC here. All right, so in this sense, scenario number nine is kind of just a little bit beyond what we know how to do with DSig mechanisms. And we'll show how basically taking this greedy out, basically an indirect implementation of this greedy algorithm with a couple of twists is good enough to get okay, it won't be one over D, but it'll be one over D plus some other factors, and it won't quite be DSIC, but it'll be close to DSIC. And again, I'm going to present this to you not as something like that's from the Book of Magical Proofs, although it's not that complicated. It's pretty nice, but more just sort of as an intriguing point that it feels like there should be some broader theory around.
00:19:14.928 - 00:19:15.580, Speaker B: Okay.
00:19:18.190 - 00:20:12.640, Speaker A: So any questions? Everyone clear on the scenario? So now we're going to go back to the full blown scenario. Again, there's only one private value. All your bundles are worth this, but you have an unlimited, in effect, number of bundles, all cardinals, D, that you might want, and you're happy to get any of them. All right, so let me tell you about what I'm going to call the shrinking mechanism. And so this is due to Babe, Levi and Pavlov from Six. So it's been around, decent number of people know about it. No one's really known how to build around this.
00:20:12.640 - 00:20:43.130, Speaker A: All right, so it's going to be an indirect mechanism. I thought we were done with indirect mechanisms, but we are going to see at least one more, this one. So we're never even going to really ask bidders what bundles they want explicitly. We're going to sort of force them to choose as the auction proceeds. So we're not going to actually ask them for their value either. It's going to have sort of an ascending auction flavor on the values. So I should say let's assume.
00:20:45.470 - 00:20:45.786, Speaker B: So.
00:20:45.808 - 00:21:28.470, Speaker A: We'Re also going to assume that all values are at least, let's say, one. Really, the assumption is, you know, some lower bound on people's values, call it one. So you initialize the bids to be the lowest the values could be. These will only go up over the course of the auction. Okay, so just like an ascending auction, we're going to systematically ask bidders, are they happy with us increasing their bid on their behalf or do they want to drop out? Then there's going to be the goods that a bidder is after. So we're going to force a bidder to kind of narrow its focus as the auction proceeds. So initially, there's no restrictions.
00:21:28.470 - 00:22:09.160, Speaker A: So si is the items which are still permitted to be allocated to bidder I anything outside of s sub I I cannot get no matter what. Okay, so this will only be decreasing as the auction proceeds, and then I'll need a couple sets of bidders just to keep track of stuff. So let me just put these here. Okay, so losers is going to be the bidders that have dropped out irrevocably from the auction forevermore. So let me show you the main loop, and then we'll do an example.
00:22:14.890 - 00:22:15.350, Speaker B: It.
00:22:15.420 - 00:23:29.242, Speaker A: So, while there are bidders which sort of have neither dropped out nor won in the previous iteration of the auction, we're going to compute a new candidate allocation. So new is going to be what we're computing in this iteration of the while loop. And the way I want you to think about what we're about to do next is I want you to remember what we said about the greedy algorithm, okay? In some sense, what we're doing is reducing the known case to the unknown case, meaning the known bundles case to the unknown bundles case, relaxing the incentive guarantee a little bit. So if we knew all of the bundles and we were happy getting a D approximation, we would sort bidders by value high to low, and we just allocate them a bundle as long as we can. Okay, so the problem, of course, being is that we don't know the bundles, right? So we can't do this. So we're going to ask the bidders to kind of help us simulate this greedy algorithm, okay? Because they know what bundles they want. Notice that in the greedy algorithm, the order in which we go through the bidders is independent of the bundles.
00:23:29.242 - 00:24:56.118, Speaker A: So in the greedy algorithm, we go through the bidders from highest value to lowest value. We don't even need to know the bundles to know the ordering, okay? But we do need to know the bundles to know who to allocate into what. Now, we go through all the bidders that haven't dropped out yet, so go through all bidders I and remember, losers are the ones that have dropped out forever. We don't know the values, but we have these lower bounds, these presumably lower bounds, these proxies, these BIS from high to low bid break ties canonically, for example, lexigraphically okay, so we want to run the greedy algorithm, okay? And right so, basically, new is what we're computing. So you should think of this as being the greedy, the output of the greedy algorithm that we're computing one at a time right now. So, intuitively, what we want to say is that when we get to a bidder, I if it doesn't conflict with people we've already allocated, then we should go ahead and add this bidder to new into the allocation we're computing. Was there a question? Yeah, there's one annoying twist, though, actually, which is in this greedy algorithm.
00:24:56.118 - 00:25:52.102, Speaker A: So there's this one thing that's kind of weird, all right, which just adds a little wrinkles to the analysis, which is, at the end of the day, think of U as being like 100 goods. So there's lots of items, and think of D as being maybe six or ten. Remember, that's sort of an upper bound on the cardinality of goods that anyone wants, all right? And D is pretty important, right, because in the greedy algorithm, d is what shows up in the approximation ratio. So we're thinking of D as being small right now, when we initialize this mechanism, on the other hand, we basically say a bidder is essentially going for everything, going for all 100 items, right? So this is way, way bigger than D in the case we're thinking about. And there's going to be this annoyance where from a bidder's perspective, there'll be this kind of initial phase where it hasn't given you any information about what items it's targeting as far as you know it wants any of the 100 goods. And then there'll be this first phase where we force it to target at most D items.
00:25:52.166 - 00:25:52.778, Speaker B: Okay?
00:25:52.944 - 00:26:33.980, Speaker A: So the relevant twist right now is that we don't want to run the greedy algorithm with any bidders that have sets of 100 items. We want them to be at most D. So here's the twist. We say, if so, again, remember, si are the items that I might conceivably get. Anything outside si I is definitely never going to get. And this is what's shrinking over the course of the auction. So if I has narrowed its focus to at most D goods, this sort of makes it eligible for the greedy algorithm and si feasible for new.
00:26:33.980 - 00:26:45.760, Speaker A: Meaning whatever other bidders that have been added to new, their SIS are disjoint from this one. Then we add I to new.
00:26:47.170 - 00:26:47.920, Speaker B: Okay.
00:26:50.930 - 00:27:18.794, Speaker A: So that's an iteration of the greedy algorithm that's successful, where we can add this person. There's no conflict. Now, here's what's sort of cute. So if it's the case that the greedy algorithm normally in this iteration would take a pass because we're at this bidder I and it has these set items si it might get, and it conflicts with people we've already taken and knew, we give the bidder the opportunity to shrink the items that it wants at this point.
00:27:18.992 - 00:27:19.740, Speaker B: Okay.
00:27:22.270 - 00:28:13.880, Speaker A: So if bitterize bundle s subi its items, s subi conflicts with new, we say, well, if you want, you have the option to shrink si to ti. So, in other words, we ask the bidder to volunteer some of the items in S sub I and agree to, you know, that it will be excluded from getting allocated those at any point for the rest of the auction. Okay, so ti is what's left where okay, so ti should be at most D, and ti feasible for new.
00:28:15.770 - 00:28:16.520, Speaker B: Okay?
00:28:19.450 - 00:28:51.894, Speaker A: So think of this as like, we go up to bidder I and we're like, look, based on the commitments we've already made in this iteration, we're going to take a pass on you, okay? But here are the items that are sold. Here are the items that have been sold. Here are the ones that are left. Some of the ones that have been sold are in your si. If you want, you can suggest a strict subset of your si ti, which consists only of items we haven't sold yet. And if you do that and there's the most D items, then all of a sudden you're eligible for the greedy algorithm and we'll go ahead and pick you and add you to new okay, but it's up to you. You don't have to do that, but you can if you want.
00:28:51.894 - 00:29:26.690, Speaker A: So in particular, this is the first time just from a bidder's perspective. So even like, the highest bidder at the beginning of the algorithm is going to be asked this question, right? Because, again, think of this as like 100 items and D is like ten. If you're the highest initially, all the bids are one, so it's the highest bidder. So let's just say the bidder with the alphabetically, first name, first iteration of the while loop, first iteration of this loop. Basically, that first bidder is going to say, look, your S sub I is bigger than D, so we're going to skip you. Or, but if you want, suggest a subset of size at most D and then we'll pick you. Okay, so that's the first shrinking by a given bidder.
00:29:26.690 - 00:29:45.880, Speaker A: Okay? So if the bidder agrees, then we reset the items. It might conceivably get to this shrinked set ti, and then again, simulating the greedy algorithm. We add I to the allocation new.
00:29:46.410 - 00:29:47.160, Speaker B: Okay?
00:29:49.950 - 00:30:39.958, Speaker A: Option two is you just pass. You can say no. I think I'll just stick with sibi, thank you very much. Okay, so we're not done, but that's one of the two questions that we ask bidders in a given iteration. All right, it so let me skip a step, which is less important. Let me tell you about the other thing that let me try to motivate the incentives that face a bidder when they're trying to decide which of these two options to take.
00:30:40.044 - 00:30:40.294, Speaker B: Okay?
00:30:40.332 - 00:31:21.878, Speaker A: So the point is, if you don't shrink your I mean, the way I've written it kind of like, why would you ever shrink your set? What's the benefit? So let me explain that. So basically the next thing happens for a bidder. Um, so basically for anybody not chosen so for anyone not chosen by the greedy algorithm, they're going to be asked, again, one of two things. They say if you weren't chosen by the greedy algorithm, then you would have to drop out or double your bid. You wanted these items, you didn't get them. We need to make progress. Either your values, right? So remember, we don't.
00:31:21.878 - 00:32:05.330, Speaker A: Know, people's values. We just have these sort of doubling estimates, these lower bounds on people's values. So if we didn't allocate to this person, we need some information, right? Either our estimate of their value is too low, they have this really high value and they should be allocated. And so we say, okay, then double your bid, put your money where your mouth is, double your bid, and you'll have a better chance next time being chosen in the greedy algorithm or drop out. Okay, sorry, there's just too much competition, you're not going to win. So option one is losers double their bid. Option two is I can drop out, in which case we add I to the losers.
00:32:05.330 - 00:33:01.362, Speaker A: Okay, so again, there's an interplay between these two options, right? Okay, so to first order, as you'll see, this isn't going to be quite true, but the way you should think about it is basically what a bidder is deciding between. Okay, so the happy case is when greedy just picks you and you don't have to do anything. Okay, that's awesome because you're not competing with other bidders or your bid is just so high, then you're happy. So the problem is, what if you're not going to get chosen by the greedy algorithm? This auction gives the bidder two ways of succeeding in the next iteration. And they're really pretty different ways actually. The first way is you bid higher and then you go earlier in the greedy ordering so you have a better chance of getting your items s sub I or you're allowed to just go after fewer items, shrink your set and you'll have fewer conflicts with other bidders. Okay, so either your bid stays the same and your set shrinks, or your set stays the same and your bid doubles.
00:33:01.362 - 00:33:30.030, Speaker A: Okay, so that's the trade off you're facing as a bidder and there's not going to be a dominant strategy. That's kind of what's really interesting about this auction. Like as a bidder, it's not really obvious what you should do. It's going to be obvious things that you shouldn't do. And the guarantee for the auction will hold as long as bidders don't do obviously stupid things. But it's not like we're going to have some prediction about what happens in the auction, like with truthful mechanisms where we just expect people to just do direct revelation. So that's sort of what's quite different about this auction.
00:33:30.030 - 00:34:12.960, Speaker A: Okay, let me fill in the details though. So there's this other piece which is a little annoying, which is because we're using an approximation algorithm, because greedy is just an approximation algorithm. It's possible that in one iteration, even though, sort of, the bids have only gotten higher, it's possible we wind up computing an allocation which was worse than the previous one, and we don't want that. Okay, so the approximation guarantee sort of depends on the amount of so the reason I have this old and new is every iteration we're going to be like, okay, let's look at what we just computed with our greedy algorithm. Let's look at what we computed last iteration. And if last iteration is better, okay, let's just use that instead. So that's a simple optimization, which is you remember last iteration's allocation and you just keep it if it's better than the one you just did.
00:34:12.960 - 00:35:19.438, Speaker A: So I'll write that here. If the sum of the bids last time around is higher than some of the bids this time around, then actually let me do this the other way. So what you're sort of hoping is that you've made some progress. And so if that's true, then basically your new tenant of allocation is so old is what you're saving the tenant of allocation in. Okay, so you compute this new one new, and if that's better than the one you were saving, well, then now this better one is the one that you start saving. Okay, so what does it mean to lose in this sort of greedy algorithm step? It means that you're neither in old nor have you dropped out. Okay, so at this point in the auction, if you're in the set old, you're happy, you're like a tentative winner.
00:35:19.438 - 00:35:31.430, Speaker A: In this auction, you're tentatively going to get all of the goods S sub I, and the current price for that is going to be bi. If you're not in old at this point, you are not a tentative winner. And those are the ones that are asked to either double their bid or get lost.
00:35:32.570 - 00:35:33.320, Speaker B: Okay?
00:35:33.850 - 00:36:18.726, Speaker A: And that's it. So that's the auction and then the final allocation is just the S sub I S, where I is an old. And then the final payments were just the last bid that you ever made. Okay, so let me do a quick example. So let's look at four bidders and four items. And D equals two. And let's even just do it for a single minded example.
00:36:18.726 - 00:36:57.348, Speaker A: Okay, so these dots are the four items and the four bidders I'm going to represent with these circles. So each bidder is single minded. It wants a pair of goods. So let's say bidder one is going to pay six for this bundle, going to pay five. There going to pay 15, going to pay twelve. Is it clear what the example is? So there's four bidders. Each has exactly one bundle, and the bundle consists of two goods.
00:36:57.348 - 00:37:22.352, Speaker A: And again, remember the seller, we don't know what these pairs are. We have no idea. Okay, so it's unknown. All right, so what's this auction going to do? Well, initially, all the bids are one. So let's just say we go through the bidders in order of name 1234. Okay, so we get to bidder one. Its current bid is one.
00:37:22.352 - 00:37:35.632, Speaker A: Its current set S one is all four items. Okay, so what the auction does, it says, hey, bidder number one, because your set si is so big, bigger than d, we're going to take a pass unless you want to shrink.
00:37:35.776 - 00:37:36.470, Speaker B: Okay.
00:37:41.160 - 00:37:58.440, Speaker A: Let me just point out, okay, so from a bidder's perspective, maybe the single minded case is a little weird to talk about, right? Because as a bidder, maybe you want to think about the following case, right? So maybe you want to think about the case where D is like ten and you're a bidder and unbeknownst to the seller, your unit demand.
00:37:59.020 - 00:37:59.624, Speaker B: Okay?
00:37:59.742 - 00:38:07.388, Speaker A: So all you want is one item. You don't care which one, they're identical to you, and you're willing to pay, like, five for just one item, but D is like ten.
00:38:07.554 - 00:38:08.270, Speaker B: Okay?
00:38:09.360 - 00:38:55.708, Speaker A: Now, as this auction proceeds, it seems like, okay, at some point I need to stop going for 100 items. I need to focus on ten because I have no hope of being chosen by the greedy algorithm until my si is down to ten items, right? But then there's this really kind of nontrivial decision you have to make, which is like, there's 100 items, I just want one, I don't care which. And now I got to tell the seller ten of them and the other 90 I become ineligible for. So intuitively, if you're bidding this auction, what you'd want to do is try to look at the biding that people are doing and try to see what's the least competitive parts of the items and then kind of say, okay, but you're also like, hedging right. You're like, okay, here are ten items. I think I got a good chance at getting one of these ten for a low price. So from a bidder, this is the kind of reasoning you have to do, and there's no obvious optimal way to do that.
00:38:55.794 - 00:38:56.430, Speaker B: Okay?
00:38:56.880 - 00:39:23.236, Speaker A: Now, in the single minded case, it's maybe kind of too simple an example because there's really no reason to hedge. Like, what are you hedging exactly right. So you may as well just kind of say, oh, yeah, sure, I'll shrink to the only bundle I want. Okay, but still, let's go through it in this example just to keep it simple. So I'm bidder number one at the very first iteration. I'm saying either I'm going to get either I'm going to get passed over, or I can shrink to these two items. And even here it's not I mean, you can make a case either way.
00:39:23.236 - 00:39:40.968, Speaker A: I could kind of say, like, well, my value is six. I'm going to be asked to double my bid to two. That's fine. I could just sort of stick with all four goods for now. But let's say bidder one just says, sure, I'll shrink my F sub one set to just the two that I want. And then this auction is going to say, oh, great. Well, in that case, I'll pick you in the greedy algorithm.
00:39:40.968 - 00:40:08.964, Speaker A: Okay, good. So this is a winner in the first iteration. Let's do this. So now we go to bidder two. Okay, so we go to bidder two. Currently, bidder two s sub two is all four items, just like everybody else, and these two goods have already been allocated this iteration. And so the auction asks, bidder two.
00:40:08.964 - 00:40:39.292, Speaker A: Hey, I'm going to take a pass on you unless you shrink to a set of size at most two, which is disjoint than these ones you've already allocated. Now, bidder two is going to say, hey, yeah, I'm not going to do that because bidder two is only happy if it gets that good and that item has already been allocated. Okay, so bidder two, it actually is clear what they should do. There's no shrinking that makes sense for bidder number two. So it's going to say, I'll take a pass. Okay, skip me. Bidder number three.
00:40:39.292 - 00:41:16.970, Speaker A: They ask the same question, do you want to shrink or not? And bidder three says, well, it doesn't have to do this, but one sensible thing would be to say, oh, sure, I'll just shrink to the two items I want. That's feasible with respect to the ones you've already allocated. And the auction says, great, will pick you with greedy and then four will take a pass. Okay, yeah. Why wouldn't bidder two just drop out altogether? Well, because its bid is only one and its value is five. Okay, so the one thing to think about I mean, you're right, that sort of like at the end of the day, bidder two is going to be hosed, probably. But bidder two doesn't know everyone else's value, so we want to be as close to DSIC as possible.
