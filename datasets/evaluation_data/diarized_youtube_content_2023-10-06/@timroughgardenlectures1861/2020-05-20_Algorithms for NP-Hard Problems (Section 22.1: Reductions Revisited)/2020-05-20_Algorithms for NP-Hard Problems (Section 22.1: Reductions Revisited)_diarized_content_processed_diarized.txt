00:00:00.650 - 00:00:46.122, Speaker A: Hi, everyone, and welcome to this part of the video playlist that corresponds to chapter 22 of Algorithms Illuminated, part four. This is a chapter about proving problems NP hard. So in the last couple chapters, chapters 20 and 21, we were focusing on raising your level of expertise around NP hard problems up to level two. So we had in mind, you know, your boss hands you a problem, tells you it's an NP hard problem. So, you know, immediately you have to comp relies on either running time or correctness. And the goal of those two chapters was to give you a number of tools to make progress on an NP hard problem. So whether it was using the greedy paradigm to design fast heuristic algorithms, whether it was using local search or dynamic programming to beat exhaustive search, or maybe those semi reliable magic boxes, the Sat and MIP solvers that we talked about.
00:00:46.122 - 00:01:25.974, Speaker A: In any case, given an NP hard problem, there's a number of different tools you now have to throw at it. So the goal of this chapter is to raise your level of expertise one further up to level three. So now imagine that you're the boss and a problem has come up in one of your projects. And, of course, problems that arise in the wild, they don't come with a label on their forehead telling you whether they're NP hard or not. Recognizing that takes a trained eye, and you will get that training, that practice. In this chapter, we'll begin with just one famous NP hard problem, the three Sat problem. So, Satisfiability, where every constraint is a disjunction of at most three literals, we'll take it on faith for this chapter that three Sat is NP hard.
00:01:25.974 - 00:02:17.698, Speaker A: That's a famous result known as the Cook Levin Theorem. And then, through a web of 18 reductions, we will establish 18 other problems are also NP hard, giving us an inventory of 19 NP hard problems. I encourage you to use this list of 19 NP hard problems as a starting point for your own NP hardness proofs going forward. And the many examples of reductions that we'll see, those can serve as templates for your own. So let's get started. Let me begin just by jogging your memory about some of the stuff we talked about in the opening sequence of videos corresponding to chapter 19, when we were just getting a level one understanding of NP hardness means. So what does it mean that a problem is NP hard? It means that a polynomial time algorithm that solves that problem would refute this famous mathematical conjecture, the P, not equal to NP conjecture.
00:02:17.698 - 00:03:03.826, Speaker A: And in particular, a polynomial time algorithm for an NP hard problem would automatically lead to polynomial time algorithms for thousands of well studied problems that have resisted the efforts of tens of thousands of brilliant minds. We haven't defined the P zero equal to NP conjecture formally. We'll do that in the next chapter. But we did describe it informally as the conjecture that checking someone's work, like checking out a filled out Sudoku puzzle, can be fundamentally easier than the problem of coming up with your own solution from scratch. This conjecture is widely believed to be true. It hasn't improved, but it's widely believed to be true. So that means if a problem is NP hard, so a polynomial time algorithm solving it would refute this P not equal to NP conjecture.
00:03:03.826 - 00:04:03.734, Speaker A: That is strong evidence, if not an airtight proof, but strong evidence that there's no exact polynomial time algorithm for the problem. And the kinds of compromises we've been talking about in the past couple of chapters are indeed required. One thing that's really cool is that to apply the theory of NP hardness, you actually don't need to understand any complicated fancy mathematical definitions. In particular, you don't need to actually know what the definition of the P not equal to NP conjecture is. That's probably one of the reasons why NP hardness has been arguably the most successful export ever, from theoretical computer science to the rest of the world. So to see what I mean, I encourage going to your favorite academic search engine and just searching for the term NP hard or the related term NP complete, and you will get an unbelievable number of hits, including many papers broadly in engineering, in the life sciences, and even in the social sciences. So you don't need to know any fancy math to apply the theory of NP hardness.
00:04:03.734 - 00:04:37.554, Speaker A: All you need is an understanding that you already have an understanding of reductions between problems. We've talked about reductions many times, but super important concept. So let me just sort of say it once again in terms of this cartoon. Reduction is just a way of building the light blue box given the magenta box. In other words, it's an argument that the only thing you really need to solve A efficiently is an efficient subroutine for B. So a little more formally, a reduction is an algorithm. It takes as input something from the problem you're trying to solve.
00:04:37.554 - 00:05:23.890, Speaker A: Problem A, it's allowed to use enough subroutine for this problem B, the problem, it reduces to a polynomial number of times and the reduction. So inside the light blue box, it's also allowed to do a polynomial amount of additional work outside of the subroutine calls to the magenta box. But at the end of the day, after you've called the magenta box a polynomial number of times and you've done your polynomial amount of extra work, that light blue box should be in a position to correctly report the solution to the instance of problem A that it was handed to in the first place. And as algorithm designers, we're usually thinking about reductions in their honorable form of spreading the frontier of tractability. So given a problem, you already know how to solve, problem B. A reduction spreads that tractability to a target problem. Problem a.
00:05:23.890 - 00:06:24.018, Speaker A: So, for example, the all pairs shortest path problem reduces to the single source shortest path problem. So, given that we know how to solve the single source shortest path problem, we then automatically also know how to solve the all pairs shortest path problem. In general, whenever you have a reduction and whenever there's a polynomial time algorithm for that problem B, the reduction automatically gives you a polynomial time algorithm for the problem A. In other words, a reduction from a problem A to B spreads tractability in the opposite direction tractability from B to A. But as we mentioned in the opening sequence of this video playlist, the point of reductions in theory of NP hardness is different. It's a more nefarious use of reductions not to spread computational tractability, but to spread computational intractability to spread NP hardness in the opposite direction. When we were using reductions in their honorable form for spreading tractability, the tractability spread in the opposite direction of the reduction.
00:06:24.018 - 00:07:11.880, Speaker A: So if a problem A reduces to A, problem B, tractability of B implies tractability of A because you get an algorithm from A just by running the reduction and using the assumed efficient algorithm for B. So computational intractability spreads in the opposite direction of tractability, which means it spreads in the same direction of the reduction. So if A reduces to B and A is intractable, say it's NP hard, then B is also intractable in the same sense. To remind you why that's true, imagine that problem A is NP hard. So what does that mean? That means a polynomial time algorithm for the problem A would refutes the P not equal to NP conjecture. Suppose then, problem A reduces to problem B. Suppose hypothetically, we actually came up with a polynomial time algorithm for B.
00:07:11.880 - 00:07:51.906, Speaker A: Well, then, by the reduction, that would automatically translate to a polynomial time algorithm for A. But we said that would refute the P not equal to NP conjecture. So, in other words, even a polynomial time algorithm for B would refute the P not equal to NP conjecture. And that's exactly our provisional definition of what it means for a problem to be NP hard. So if A is NP hard and A reduces to B, then B has to be NP hard as well. What that means for us is that there's an unbelievably simple recipe for proving that a problem is NP hard. So if there's some problem B that shows up in one of your own projects and you suspect B might be NP hard, here's how you'd go about doing it.
00:07:51.906 - 00:08:21.734, Speaker A: Step one, choose a known NP hard problem A. Step two, design a reduction from the problem A to the problem you care about B. If you carry out both of these steps, you are done. You know that problem B is NP hard. A was NP hard by assumption, you reduced it to B, and the intractability, the NP hardness, flows in the same direction of the reduction. So from a to b, that is it. To carry out these two steps, you do need a couple skills.
00:08:21.734 - 00:09:02.226, Speaker A: So for step one, you need some awareness of known NP hard problems. So you need to know what are some options for what you could choose for that problem a. Now, as we said in this chapter, you'll already learn about 19 NP hard problems, any of which is a totally legitimate choice for the problem a in step one. If 19 problems aren't enough for you, there's hundreds more out there that are well documented in books. The second step requires a skill that really you already have, which is skill in designing reductions between different problems. It's true our training to this point has been in honorable uses of reductions to spread tractability. But those exact same reductions spread intractability in the opposite direction.
00:09:02.226 - 00:09:21.260, Speaker A: And to the extent that there are special tricks of the trade of reductions and empty hardness proofs, we'll get a lot of practice with those as we go along through the rest of these videos. Coming up in the next video, we're going to discuss what in some sense is the mother of all NP hard problems, the three sat problem, and the famous cook levin theorem. I'll see you there.
