00:00:01.050 - 00:00:44.646, Speaker A: Okay, so I said that the devil is in the details with these consensus protocols. So let's actually go into the details of the Tendermint protocol. Let me start with a few preliminaries. So first of all, we're going to go ahead and make the PKI assumption assume a public key infrastructure. So this is the same assumption that we used in the Dole of strong protocol and we're going to use it in the same way. We're just going to assume that literally every message ever sent in the protocol should be signed by the sender. So remember, with PKI you're assuming that the protocol is born with not just all the nodes knowing about each other like their IP addresses, but also knowing everybody's public keys.
00:00:44.646 - 00:01:33.560, Speaker A: So public keys are somehow distributed before the protocol ever gets started. Now I should say that while our impossibility result in lecture three with the hexagon argument that actually shows that the PKI assumption is actually fundamentally necessary to get the guarantees of the Dolof strong protocol to tolerate any number of Byzantine nodes, that's actually not the case in the partially synchronous model. So I'm going to show you a protocol that does make a PKI assumption and achieves optimal fault tolerance, meaning the number of Byzantine nodes can be anything less than a third. There's actually other protocols also which do not make the PKI assumption, but nonetheless under weaker assumptions achieve the same level of fault. Know in practice PKI, it's a reasonably common assumption. Tendermint makes that assumption. So we're going to go with that.
00:01:33.560 - 00:02:11.050, Speaker A: Secondly, remember that in the partially synchronous model one of the things we have going for us is a shared global clock. And again, you can relax this to having sort of a bounded difference between different nodes clocks. But for simplicity, let's just think about a shared global clock. So there's a notion of time and in any given moment all of the nodes know exactly which time step they're in. What that means is we can chop time into what we're going to call round. You should think of a round as an attempt to come to an agreement on a particular block. So in the previous video when we talked about the high level ideas, idea number two was sort of keep trying until you reach agreement.
00:02:11.050 - 00:02:45.754, Speaker A: So one of those tries is going to be what we mean by a round. So a couple of things to note. So first of all, because all nodes agree on exactly what time it is, that means all nodes will automatically, without communication, know what round they're all in. So from time zero to four delta, they know they'll be in round zero from four delta to eight delta. Everybody knows they're in the middle of round one and so on. That's because of the shared global clock assumption. Secondly, notice that the interval length is defined in terms of the parameter capital delta.
00:02:45.754 - 00:03:43.540, Speaker A: Remember, capital delta is the guaranteed bound on message delay under normal operations after you've passed Global Stabilization time and you're in the synchronous phase. And remember, in the partially synchronous model, on the one hand GST, the Global Stabilization time is assumed unknown to the protocol. It needs to work no matter what GST is and it can't refer to GST in the protocol description. In contrast, delta, the delay bound under normal operations that is assumed known to the protocol in advance. And so the protocol's description can depend on delta and you are seeing that right here. And so for example, if you go poke into the tendermint documents, you'll see upon starting up the protocol, there's a parameter you can set determining the length of a round. If memory serves, I think the default is maybe 1 second per round.
00:03:43.540 - 00:04:26.160, Speaker A: So it's interesting to compare and contrast this rounds with what we talked about in the last video, what we were calling heights. So remember, tendermint is basically going to be iterated single shot consensus and each node is going to be working on one of those single shot consensus instances at a time. So if I'm a node, I might be trying to figure out what block number nine is. Now remember, especially in the Asynchronous phase, there's no guarantee that all of the nodes are maintaining exactly the same height. Maybe there's some nodes that have received many more messages than me. They've figured out block nine, they figured out block ten, they're working on block eleven. Maybe there's some nodes that are lagging behind even me, they've only made it to block number seven.
00:04:26.160 - 00:05:01.496, Speaker A: They're not working on block number nine yet. And we agree that the different consensus instances should basically be kept completely insulated from each other. So we're having all nodes ignore all messages that are about any block other than the one that they're currently working on. Okay, so the block number, the current block number will be different for different nodes, potentially at least in the Asynchronous phase. But notice that the round number is not different for different nodes, not even in the Asynchronous phase. And that's because the block that you're working on depends on what messages you have received to this point. You've been listening to the outcomes of voting rounds.
00:05:01.496 - 00:05:39.284, Speaker A: So depending on the message delivery, you may or may not have figured out block number nine. The round number, remember, is derived solely from the shared global clock. Everybody knows the current time step without doing any communication. So everybody knows the current round, again, without doing any communication. Okay, so summarizing rounds, there's automatic agreement amongst all the nodes at all times. Even in the Asynchronous phase heights, especially in the Asynchronous phase, there may be disagreement, different honest nodes working on different blocks at the same time. What happens in one round, it's going to sort of resemble like a Byzantine broadcast protocol.
00:05:39.284 - 00:06:14.012, Speaker A: Like if you remember way back in lecture number two, we reduced state machine replication to iterated Byzantine broadcast through the use of rotating leaders. And so here again, we're going to have rotating leaders. The leader of a given round is going to be responsible for proposing the initial block. It is trivial for all of the nodes to keep track of who the current leader is, who is the leader for each round. And that's because of two assumptions. Assumption one is the global shared clock assumption, so everybody knows what round it is. The second assumption is that we're in a permissioned environment, so everybody knows the names of all of the nodes.
00:06:14.012 - 00:06:36.920, Speaker A: So the names are SAG. Let's call it one, two, three, up to up to N. And then all the nodes can automatically know again without any communication. Oh, it's round one, I guess node number one is the leader. Oh, it's round two, I guess node number two is the leader, and so on. And now we come to an important definition. We're going to define what we're going to call a quorum certificate or a QC for shorts.
00:06:36.920 - 00:07:20.280, Speaker A: So what's a quorum certificate? Well, so remember, we already know that there's going to be leaders, they're going to be proposing blocks and then we know there's going to be voting. So we're going to have nodes voting on blocks. So a quorum certificate just sort of collects a supermajority worth of votes for one particular block in some particular round. So by supermajority I mean of the end nodes in the system. Strictly more than two thirds of those nodes should be represented in this collection of votes. So I mentioned last video how every message anyone sends, in addition to signing it, they're also going to include their own height. So if I send a message, I'm going to tell it to people, hey, I'm currently working on block number nine.
00:07:20.280 - 00:07:54.244, Speaker A: And actually now that we have this notion of rounds, let's just include the round also. So I'm going to send a message signed that says, I'm working on block number nine. This is a message belonging to round 117. Now, a quorum certificate involves a supermajority of messages of that type. All of the heights should match, so they should all be for given block number nine. They should all correspond to the same round, round number 117. And they should also all be votes, meaning signatures on the exact same block, the exact same list of transactions, capital B.
00:07:54.244 - 00:08:50.176, Speaker A: So that's what we're going to mean by a sort of successful outcome of a voting stage. If a supermajority of nodes sort of attest to some block B being their candidate for a given block number at a given round, that is what we call a quorum certificate or a QC. Okay, let's record a quick lemma about quorum certificates, about QCs, specifically about their, about their intersection. And so this will explain why we want a supermajority. And you'll also see for the first time how the less than 33% Byzantine assumption enters the picture in the simple lemma. So why is this true? Well, so take two QCs, right? So each one has 67% or more of the nodes represented amongst their signatures. Well, so I claim that this means that more than the overlap between the two has to be more than a third of all of the nodes.
00:08:50.176 - 00:09:37.840, Speaker A: Why? Well, all right, so think about the first QC. 67 people at least signed it. So the number of nodes that did not sign it is at most 33%. Okay? Similarly, the fraction of nodes that did not sign the second QC also at most 33%. So that means the fraction of nodes that signed neither the first QC nor the second QC is at most 33 plus 33, which is 66%, which means the rest of them, 34% signed both. Now, because we're assuming that F is less than N over three, because less than a third of the nodes are Byzantine, it cannot be that this entire 34% overlap can be Byzantine nodes. There must be at least one honest node in the overlap.
00:09:37.840 - 00:10:18.942, Speaker A: Okay, so if you prefer just the simple arithmetic, I'll put that on the slide. But what I told you in English is a totally correct proof of this lemma. So in fact, if we look at this counting argument, actually, it's still going to hold, even if we only insist on greater than or equal to two thirds n signed votes. So let's go ahead in convenience. Actually, tweak the definition of a QC. Let's tweak the definition of a supermajority so that it's greater than or equal to two over three N votes. All the changes in the proof is that the first inequality goes from being strict to going to not strict.
00:10:18.942 - 00:10:52.590, Speaker A: But again, since F is strictly less than N over three, we're still good. It's still the case that any QCs overlap in at least one honest node. The other tweak I want to do before we get to the pseudocode. So I've oversimplified slightly on this slide just by talking about block heights and rounds. Actually, as we'll see on the next slide, each round has two stages of voting. So a QC is going to be specific not just to a block number like block number nine, not just to a round like round 117, but also to a stage of that round, which again, will be either stage number one or stage number two. Those are the only two options.
00:10:52.590 - 00:11:37.562, Speaker A: So when we speak about a quorum certificate, when we speak about a QC, we're speaking about a supermajority of votes at least two thirds over N votes that match in everything other than the identity of the voter. They need to all be votes on the same block. They need to all be votes for the same block number, for the same round, and for the same stage. If all of the votes match in those four parameters and you have at least two thirds and distinct voters. That is, what is a QC, what is a quorum certificate. So one easy consequence of this overlap lemma which again really starts showcasing why N over three might be sort of a crucial threshold, is that actually if you have two QCs that match in the last three parameters. So two different QCs that are all about the same block number, all about the same round, and all from the same stage.
00:11:37.562 - 00:12:30.686, Speaker A: Then actually, those two QCs must also match in the fourth parameter in the block that the votes are for. So actually this statement in Magenta, that's going to be a consequence both of the overlap lemma and a property of the pseudocode that we'll see on the next slide, which is that an honest node is instructed to AdVote at most once in any referendum. By referendum here, I mean a three tuple specifying the block number, the round and the stage. So each honest node will vote at most once in each of those referendums. So given that, why does this Magenta statement hold? Well, consider two different QCs that do match in the block number and the round and the stage each of them has. So the overlap lemma tells us there must be an honest node present in both of those two QCs, but it's impossible that that honest node voted twice for two different blocks. It only voted for a single block capital B.
00:12:30.686 - 00:13:08.486, Speaker A: Because both of the QCs include that vote, both of the two QCs must be about that same block, capital B. All right, so that's actually a really nice property for a given referendum, meaning a block number, height, round stage combo, you only have one winner in the sense that any two QCs must be supporting the exact same block capital B. Those two QCs may differ in the identities of the at least two over three and voters that contributed votes to that QC. That's the only way in which the two QCs can differ. So they may as well be the same. Each of them maybe has a different set of identities of voters, but they're all for the same referendum, they're all for the same block, so they're pretty much interchangeable. All right.
00:13:08.486 - 00:14:16.714, Speaker A: So one other thing I want to tell you. In preparation for the pseudocode, the tendermint protocol on the next slide, so each of the nodes is going to be maintaining two local variables, one of which is keeping track of a block, the other of which is keeping track of a quorum certificate for that block. So when the protocol is just getting up and running and we need to initialize these local variables, each node independently just sets its QC variable to null. Because no quorum certificates exist yet, nobody's voted on anything yet, and sets its block variable B sub I to just all of the transactions it knows about that haven't already been executed, that haven't already been included in some previous block. Now, as the protocol starts humming along, nodes will be periodically updating their local variables to reflect newer quorum certificates that they may have seen or may have heard about. And so what do I mean by a newer quorum certificate? I think it's what you'd expect. So if you fix sort of a block number, like block number h, and you look at two different quorum certificates for that block number, well, if one of them is from a later round, like 119 instead of 117, that's going to be a newer quorum certificate.
00:14:16.714 - 00:15:02.426, Speaker A: And if they're both within a round and one is stage one and one is stage two, well, the stage two quorum certificate from whatever it is, round 117 is going to be the newer one. Now, notice, as we just saw, if you have a tie both in the round number and in the stage number for a given block number, actually the two QCs are basically the same. They support the same block, differ only possibly in the identities of the voters that contributed to that particular QC. So we're not really worried about ties. If there's a tie, they're basically, for all practical purposes, the same QC. If they're not from the same referendum, then we use the obvious notion of one QC being more recent or newer than another. All right, so what do we mean by periodic? Well, it'll be obvious once we talk through the pseudocode on the next slide, but basically there's sort of two main cases.
00:15:02.426 - 00:15:53.626, Speaker A: One is if you yourself witness sort of an immediate success of some referendum. So if there's just some referendum, you just had a voting stage and you yourself actually see the votes, not just somebody else reporting to you, a collection of votes, but you literally see firsthand two thirds end votes from that referendum that all agree, then you're going to update your local variables. The other key point in the pseudocode where you update your local variables is when you become a leader. So as we'll see, there will be rotating leaders and when it's your turn to be the leader, you're going to say, oh, am I out of date? Let me actually sort of update my local variables to reflect everything that I might have heard about up to this .1 other detail I said conceptually, the different single shot consensus instances are not going to be interfering with each other, right? Sort of a block working on block number nine never worries about messages on any other blocks. There is an exception to that. So if you're working on block number nine, you're definitely going to ignore messages from previous blocks.
00:15:53.626 - 00:16:30.374, Speaker A: Those are already decided. You don't care anymore for future blocks, you're going to ignore a lot of stuff. But if nodes are ever kind of circulating around quorum certificates for a future block, like say, block number eleven, you just sort of remember those. You just sort of keep those in your back pocket they're not going to be relevant to you until you yourself catch up and get to block number eleven. But you want those quorum certificates from the future block saved locally so that you can take advantage of them when you do eventually catch up and get to block number eleven. All right, so let's go ahead and walk through the pseudocode of the tendermint protocol. I should say at the outset there's sort of a bunch of different variants of the tendermint protocol.
00:16:30.374 - 00:17:36.414, Speaker A: Like if you look at the tendermint white paper, I'm not claiming it will like line by line match what I'm going to write down on this slide, but definitely the version I'm giving you captures all of the big ideas. And in particular, this is the most straightforward implementation I was able to come up with that faithfully implements the three big ideas that we talked about. The idea of iterated single shot consensus, the idea of using rounds to coordinate sort of multiple restarts to make sure you make progress, and the idea of within a round using two stages of voting so that you have this kind of intermediate stage allowing nodes to hedge. So in my opinion, if you make it through lecture seven and you really sort of understand everything in all of these videos, I think you can really honestly say that you understand the tendermint protocol, even if it's not line by line identical to what you see in their white paper. The description I'm going to give you on this slide, it'll be, as we'll see, pretty detailed. If you want sort of a super detailed version with literally nothing left out, then I encourage you to check out the lecture notes that accompany these videos. All right? So first, because the single shot consensus instances aren't going to interact much with each other, to describe the pseudocode, let's zoom in on a specific block number, like say block number nine.
00:17:36.414 - 00:18:16.638, Speaker A: Every round of the protocol is going to look exactly the same. So let's moreover zoom in on one specific round, like maybe round number 117. Let's use L to denote the node that is the leader of this round, R. So remember, we're just doing sort of round robin leader rotation, right? So if we have 100 nodes run around 117, maybe it's node number seventeen's turn to be the leader. In any case, all of the nodes know automatically who the leader of the current round is. Remember that we have this global shared clock rounds, as we'll see, just have a fixed length of four times capital delta. So everybody knows the current time, therefore they know the current round, therefore they know the current leader without any needing to communicate amongst them.
00:18:16.638 - 00:18:47.794, Speaker A: As mentioned, each round of the tendermint protocol is going to have length four delta time steps, where again, capital delta is the parameter in the partially synchronous model. The maximum message delay following Global Stabilization time. So the round will have length four delta. Accordingly, we're going to split it into four different phases of delta time units each. The first phase then will start at timestep four delta R. I'm assuming here that we start numbering rounds at zero. The first phase is relevant only for the leader.
00:18:47.794 - 00:19:53.350, Speaker A: So honest nodes who are not the leader are going to be doing nothing in this first phase. If you are the leader, then very much kind of like our SMR protocol way back in lecture two with rotating leaders, the leader of the round is going to be responsible for proposing a block and also proposing a quorum certificate ideally that supports that block. So what should the leader propose, assuming of course, that the leader is honest? Well, remember, each node, including l, has its locally stored variables b sub l and Q C sub l. So that's one option for what to propose. But actually I mentioned the periodic updates on the last slide and this is actually a key point where a node is going to do a periodic update of its local variables. So this leader l, it's going to ask itself what is the most recent quorum certificate I ever saw or heard about? And again, most recent meaning like most recent round breaking ties within a round for the most recent stage. And if actually the leader node l has perhaps quite recently heard about some quorum certificate newer than the value of its local variable, at this point, it updates the value of its local variables.
00:19:53.350 - 00:20:32.374, Speaker A: So it looks at the most recent QC that it ever heard about for the current block. For block number nine, it updates its local variables and that's the proposal it makes to all of the other nodes. So a little more detail here. So, along with this proposal of a block QC pair, the leader, again assuming it's honest, will sign that message so that everyone knows it indeed actually came from the leader l of this round R. And furthermore, it'll annotate it with sort of the block number so that other nodes may know to ignore it if they're not working on this block number. And also Annotated with the round. So you'll say hey for block number nine, for round 117, look, I'm the leader node number 17.
00:20:32.374 - 00:21:19.590, Speaker A: Here's my signature, here is my proposal for the block and a quorum certificate that supports it. The second phase then starts capital delta time steps later. The point of the second phase is basically for honest non leaders to sort of acknowledge and vote upon the proposal that was made by the leader in the first phase. So if everything goes sort of just right in this second phase, then the second phase will conclude with honest nodes casting votes for the block posed by the leader. So what has to go right? So first of all, an honest node, I, it has to receive something from the leader on time, right? By time for delta R plus delta. And it may not. It may not because the leader happens to be Byzantine and decided to say not send that note a message.
00:21:19.590 - 00:22:27.918, Speaker A: It also may happen if we're pre Global Stabilization Time and we're having message delays that are bigger than delta. So totally possible that an honest node I doesn't hear anything from the leader of that round by this time, in which case it's not going to cast a vote. So similarly, if there's something malformed about the vote that the node I receives from the leader, it's just going to ignore it, like if it's missing a signature or something like that. And actually, and this is sort of the crucial point is that an honest note is also going to ignore the leader's proposal if the proposal appears to be out of date. By which I mean the quorum certificate that the leader suggests is actually less recent, strictly less recent than the one that this node I already knows about that's locally stored in its local variable. If a node I sees that, if it kind of gets this old stale proposal from the leader, it's like, well, okay, either the leader is Byzantine and trying to mess with me, or maybe the leader is just kind of like really out of date because we're preGST in the partially synchronous model and messages are getting delayed. So I'm going to ignore it in that case, right? So I'm going to stick to my guns if I have more evidence, more recent evidence for some block than apparently the Leader does.
00:22:27.918 - 00:23:26.026, Speaker A: If none of those things happen, and a node I does actually receive from the Leader l by timestep four delta R plus delta a well formed vote for a block supported by a quorum certificate at least as recent as the one that node I knows about. In that event, Node I will in fact cast a first stage vote for the block proposed by the leader. So Node I is going to be broadcasting this vote to all of the other nodes and as usual, it will sign that vote with its signature so people know it's coming from node I. And as usual, it'll be annotated with the block number nine, the round number 117, and in this case, the stage number, which is number one. So here again, it makes sense for Node I to do one of its periodic updates. I mean, given that it just cast a vote for B sub l, presumably it should reset its local variable Bi to be B sub l if it wasn't already equal to B sub l. And similarly to update its QC to this at least as recent one that was just heard by the leader.
00:23:26.026 - 00:24:09.978, Speaker A: And Node I may also as well just sort of broadcast this newly adoptive Cordon certificate just to make sure that all of its colleagues are also aware of it. So, for example, there's the case where the quorum certificate received by the leader QCL is equally recent to the one stored locally at node I, QCI. So that means that they are both for the same block number, the same round number, and the same stage number. And remember we had that sort of observation on the previous slide that in that case they're basically interchangeable quorum certificates. In particular, they must be supporting the same block. So if there's a tie in recency between QCI and QCL, then also bi equals BL. And so basically node I is broadcasting a vote for the block that it sort of already thought was the right one anyways.
00:24:09.978 - 00:25:02.814, Speaker A: If, however, the quorum certificate QCL received by the leader is strictly more recent than the one stored locally at Node I than QCI, then in fact, Node I will broadcast its vote for the newly heard about Block B. Sub l. Now, it is possible that maybe b sub I equaled b sub l maybe node I already had that same block stored locally and it just had a sort of older QC. In that case, it's going to sort of update its QC and then broadcast a vote for the block that it anyways believed in, but when confronted with evidence. So if BL is different than bi, but QCL is strictly more recent than QCI, that's the case in which Nodei is going to be like, oh, wait a minute, I guess I'm out of date. I guess sort of other people have sort of figured out that b sub l is better than B sub I. Let me sort of not only update my own local variables, but also just kind of join the party and sort of also add my vote to those who are sort of favoring b sub l.
00:25:02.814 - 00:25:54.986, Speaker A: In fact, it's even okay actually if bi and BL match. In that case, it's okay for node I to cast a vote even if the leader is out of date. So if QCL is older than QCI, but it's for the block that nodei already believes in, turns out you can actually get away with casting a vote in that case as well. We're not going to look at that version of the protocol, but a good exercise for you is to go through the proofs of consistency and liveness in the next two videos and confirm that actually those proofs would still work even if we also allowed nodes in the second phase to vote for sort of confirmation bias. So blocks heard by the leader that agree with its block even if the leader looks to be out of date. The second aside is that the way I've described this, you're going to be seeing basically quadratic amount of communication, right? All of the nodes are broadcasting their first round vote potentially to all of the other nodes. So that's like n squared messages.
00:25:54.986 - 00:26:36.650, Speaker A: If you have N nodes, you could probably imagine ways of structuring the communication so that you only. Had linear communication rather than quadratic. So for example, you could have all of these sort of votes go through the leader node and indeed some of the more efficient implementations of sort of follow ups to tendermint do those kinds of tricks to avoid the all pairs communication that we're seeing here. But again, for us, efficiency considerations are too far out into the weeds. We want to keep things as simple as possible. So we're going to go ahead and just use this all pairs communication not just in this phase, but in the next phase as well. Speaking of the next phase, the third phase that's going to commence at timestep four delta r plus two delta.
00:26:36.650 - 00:27:23.978, Speaker A: In this third phase, nodes try to ascertain the outcome of the referendum that occurred in the previous phase. Everyone tries to figure out was there a conclusive winner in round number 117 in stage one of voting, where here a conclusive winner is going to mean a supermajority. So at least two thirds end nodes voting for exactly the same block. If in fact a node witnesses that supermajority for a block from the previous stage of voting, then it sort of proceeds kind of similarly to the second phase by casting a second stage vote for whatever block was the winner of the previous phase's referendum. So one minor detail, it's totally fine if one of these two thirds n votes from stage one actually comes from this node I itself. So it's allowed to count its own first stage vote. That's totally fine.
00:27:23.978 - 00:28:24.730, Speaker A: In fact, actually for convenience, you might just want to imagine in the second phase that in addition to a node I broadcasting a vote to all of the other nodes, it also kind of sends that vote to itself just for counting purposes. And that vote sent to itself will then arrive immediately. For that matter, even in the first phase when you're talking about the leader and it's proposing a block to everybody else, imagine that the leader proposes that to itself as well, which will then cause the leader l to kind of cast also a first stage vote for that exact same block in the second phase. Okay? All by way of saying these two thirds and votes can include a vote by I itself. Now notice that if a node I in fact witnesses a supermajority all supporting the same block, capital B from the previous stage, that actually constitutes a quorum certificate supporting this block B, right? So all of these votes correspond to round number to block number nine, round number 117, stage number one. So they match in all those parameters and then by assumption, we have at least two thirds end distinct voters as part of it. So that is a quorum certificate.
00:28:24.730 - 00:28:58.182, Speaker A: These votes received in this if statement are a quorum certificate. And if you think about it, actually that means that there can only be one winner of the referendum in the previous slide. So if there's multiple QCs floating around, all for the referendum that happened in the second phase, they must all support the same block. Remember that followed by the QC overlap property. So there's a most one conclusive winner if there's one, call a capital B. In that event, the supporting votes constitute a quorum certificate. It's the most recent imaginable quorum certificate, right? It's literally from the previous stage of this same round.
00:28:58.182 - 00:29:40.438, Speaker A: So this is a natural point for the node to update its local variables. So its new local QC is going to be this one it just witnessed. Firsthand, it's going to assemble all of these votes it received into a quorum certificate, store it locally, and then the local block variable will just be whatever block that QC supports, which in this case is capital B. Now we proceed just like we did in the second phase. So this is going to be the second stage of voting. Having witnessed a conclusive winner to the first stage's referendum, note, I will broadcast a second stage vote for this block, capital B. And like in the previous phase, it's going to go ahead and broadcast this new block QC pair that it discovered, making sure that all of its colleagues are up to date.
00:29:40.438 - 00:30:20.926, Speaker A: If this if statement is not triggered, if by time four delta R plus two delta, node I has not seen two thirds votes all supporting the same block from the previous stages referendum, then it does not vote at all. And again, this could happen for a couple of reasons. It could happen because you have a Byzantine leader. It could happen because you're preGST and you've had lots of message delays. So it's only if everything goes right that a node is going to bother to cast a stage two vote. And that's what it does here in the third phase, the final phase, the fourth phase, that begins at timestep four delta R plus three delta. And this is the phase where honest nodes might actually commit to a new block in their local appendonly data structures.
00:30:20.926 - 00:31:06.254, Speaker A: And what's going to trigger the commitment of a new block? It's exactly what we said it was going to be when we talked about the big idea of having two stages of voting. If nodes actually see two successive stages of voting, both succeed, that's going to be the sufficient condition under which it actually does commit a new block to its local appendonly data structure. So that's what's going to be happening in this fourth phase. Nodes will be looking to see a conclusive winner from the second stage of voting, just like in the third phase. If in the happy case where node I does actually witness this amount of agreement from the second stage of voting, if it actually sees a supermajority of second stage votes offer the same block, capital B, those votes then, by definition constitute a quorum certificate, right? They're all for the same block number. They're all for the same round, went around 117. They're all for the same stage.
00:31:06.254 - 00:31:57.300, Speaker A: Stage number two, they have two thirds n different nodes represented. That is a quorum certificate. And so, again, for the same reason we know there can't be two conclusive winners from that referendum because there can't be two quorum certificates from the same referendum that support different blocks. If in fact node I does witness this supermajority, then it just collects those votes into a quorum certificate that it just assembles from these first hand seen, firsthand, second stage votes. Naturally it updates its block to whichever block is supported by the supermajority, whether or not that happens to be the block that it had stored locally previously. And then here's the key thing. Having witnessed not just one but two stages of successful voting, now nodei actually takes the plunge and commits this block capital B to its local history.
00:31:57.300 - 00:32:49.774, Speaker A: Now this is the part of the pseudocode where you should feel maybe both sort of positive and negative emotions. Positive emotion is cool. Like to have any hope of having Liveness, the protocol better be at some point committing new blocks to sort of nodes, local histories. And so we're seeing that happen in this fourth phase, right? So if liveness is going to hold, it's going to be because nodes are regularly sort of carrying out this commit that we see in the fourth phase. The negative emotion should be you should be maybe worried about consistency. And our proof of consistency will certainly have to address the fact that if one honest node commits to some block B as block number nine, it better be the case that any other honest node who ever commits to anything as block number nine, it better be this exact same block capital B. So that's the responsibility of the consistency proof that we'll see in the next video if node I makes it through this fourth phase.
00:32:49.774 - 00:33:22.718, Speaker A: At that point it has decided upon the current block number on block number nine. So naturally it's going to start working in the next round on block number ten. So whatever the local sort of variable is, keeping track of the block number that's going to get incremented for node i. So I'm using h sub I here just to denote the block number that node I is working on. So we're almost done with the description of the pseudocode. There's just a couple of final details left which concern interaction between different block numbers. So remember, I encourage you to think of the single shot consensus instances as basically completely independent, not interacting at all.
00:33:22.718 - 00:33:56.134, Speaker A: It's not quite true. So let me tell you the sort of minor exceptions it is true. A node will completely ignore any messages from previous blocks. If you're working on block number nine, you hear something about block number seven, you're like, who cares? I already know what block number seven is. I'm just going to ignore you. Now, if you hear about messages concerning future blocks like block number eleven, you'll definitely ignore some of those messages. But if ever anyone sort of is passing around a quorum certificate for some block for some round in some stage for block number eleven, you're going to go ahead and sort of keep those in your back pocket.
00:33:56.134 - 00:34:32.520, Speaker A: You're going to remember those for when you yourself catch up to, in this case, block number eleven. All right, so honest nodes store quorum certificates they hear about for future blocks, for future use. What is that future use? When might they dip into their back pocket where there's going to be two places in the pseudocode. One's already on the slide, actually, the other one I still have to write down. The first reason why a node might dip into its back pocket is in the first phase of a round, if it's the leader. And in particular, imagine you're node number 18. Let's say there's 100 nodes total.
00:34:32.520 - 00:35:04.890, Speaker A: Imagine you're working on block number nine in round 117, and imagine you actually succeed in round 117. In the fourth phase, you actually commit to block number nine. You're like, cool, I'm going to start round 118 working on the next block, block number ten, okay. Now, you weren't paying attention to block number ten up until this point. You were sort of really focused on block number nine. So you're going to enter round 118 with your local variables reset, reinitialized. So your locally stored QC is going to be equal to null.
00:35:04.890 - 00:36:09.614, Speaker A: Your locally stored block is just going to be equal to all the transactions that you know about that haven't been included in one of the first nine blocks. But here's what's weird, right, if you're node number 18 and we're moving on to round 118, you're going to be the leader, right? So you're now the leader responsible for proposing something as block number ten when you weren't paying attention to block number ten at all in the first 117 rounds. Okay? But fortunately, you kind of have this cheat sheet, right? You weren't really paying attention to block number ten, but if any other nodes had sort of assembled corn certificates for block number ten and broadcast them out, you did remember all of those. So at the very least, you're sort of educated entering into round number 118. You're like, okay, I didn't actually personally assemble maybe any quorum certificates, but I did at least remember other ones that other people might have come up with. And so that way you can then sort of update your locally stored variables, in particular your QC, you can update it from null to the most recent QC you heard about from anyone else for block number ten. So that's the first reason why you might dip into these QCs for future blocks.
00:36:09.614 - 00:36:58.478, Speaker A: The second moment in time you might be making use of these QCs for future blocks is going to be at the end of each round. So at time of four delta, R plus four delta, this can be thought of as either the end of the current round R or the beginning of the next round R plus one. Let's think of it as the end of round R. So this code is going to be executed just before the first phase of round R plus one. So at the end of each round, each node just going to do a sanity check. It's going to say, basically, could it be possible that the problem is me and I'm behind the times and my colleagues have actually already figured out what the block is supposed to be? Right again, like, maybe you're in round 117, you're working on block number nine, and so maybe you sort of fail in this round. You didn't hear enough votes from the second stage of voting, you didn't wind up sort of committing anything as block number nine in the fourth phase.
00:36:58.478 - 00:37:59.430, Speaker A: As far as you know, you're still working on block number nine, but now at the end of this round, at the end around 117, you're like, let me just make sure there's not any irrefutable evidence that my colleagues have figured out block number nine. So what would irrefutable evidence mean? As we'll see in the proof of consistency in the next slide, a stage two quorum certificate for block number nine constitutes irrefutable evidence of what block number nine is supposed to be, doesn't have to be from the current round. Like, maybe because of message delays, you're like, only now hearing about that. Oh, wow, back in around 114, actually, there was a sort of successful second stage referendum. And finally, one of your colleagues echoes to you the quorum certificate that proves it around 114, stage two quorum certificate that block number nine is supposed to be some block capital B. It turns out, given a stage two quorum certificate, you can get away with just sort of skipping. Now, the rest of figuring out block number nine, you're like, I guess block number nine has to be this block supported by this stage two quorum certificate that someone told you about.
00:37:59.430 - 00:38:37.950, Speaker A: Okay, so if you just so happen to have a stage two quorum certificate for block number nine supporting some block B, you commit to that at the end of this round. Then of course, having doing that, you sort of do the sanity check again for block number ten. You're like, oh, well, maybe I have a stage two QC for block ten also. I may as well commit that as well and just sort of catch up to everybody else. So that's the tenement protocol, or at least the version that we're going to be talking about. And I hope the three high level ideas that I mentioned in the intro video all sort of come out pretty vividly in this description. The idea that you have iterated single shot consensus with the different instances parameterized by the block number, that you have sort of these kind of aggressive timeouts.
00:38:37.950 - 00:39:19.838, Speaker A: So to deal with Byzantine leaders and sort of long message delays. So you get sort of one new attempt at committing a block, each new round, each new four delta time steps. And then obviously we have the two stages of voting. The votes are cast in the second and third phases and then the results of those votes are processed in the third and fourth phases. Now, we've talked about kind of intuition, about why you might hope some protocol like this might work. But let me emphasize it is not at all obvious that the tendermint protocol satisfies consistency or eventual liveness when less than a third of the nodes are Byzantine. And you really should demand extremely careful proofs of both of those properties, which is exactly what we'll be supplying in the next couple of videos.
00:39:19.838 - 00:39:48.260, Speaker A: Frankly, it's actually hard to imagine even coming up with all of the details of this protocol unless you were simultaneous actually sort of with designing the protocol, also writing out the proofs of its key properties of consistency and eventual liveness. So, as we've said many times, intuition doesn't get you very far with distributed protocols. The devil is usually in the details and getting those details right requires careful mathematical analysis. And that will be the subject of the next couple of videos. I'll see you there.
