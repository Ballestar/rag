00:00:00.250 - 00:00:21.040, Speaker A: For, I don't know, slightly more than a decade now and been working on crypto for the last five years, I guess maybe the last three and a half of them on Ethereum. And we've been working on Biblier for slightly more than two years now.
00:00:23.650 - 00:01:02.400, Speaker B: All right, awesome. I think we've got the live streams going and we're going to check those really quick just to make sure and then we can kick it off. Do you want to start sharing your screen?
00:01:03.010 - 00:01:53.256, Speaker A: Yeah, sure. Okay. It all right.
00:01:53.358 - 00:02:06.510, Speaker B: I think we are good to go. Do you want to give a quick intro again? Because there are some people who have just joined and now the live stream has started, but it is yours to take away.
00:02:07.680 - 00:03:05.148, Speaker A: Okay, so let's start. Well, hi everyone, to the new people who just joined. I'm Patricio Palladino, CTO at Nomic Labs, where we work on improving the development experience of ethereum. Among other things, we do Bibler, our development tool that you are going to learn how to use today. So this workshop is mostly about how to set up and use a proper development environment for smart contracts. It's not going to be a solidity class like we are not going to go through different syntax options and data types and things like that. We'd rather set up an environment and start coding in a tiny smart contract.
00:03:05.148 - 00:04:26.756, Speaker A: So then you can continue your learning by just coding and playing with solidity rather than just hear me talking for an hour. So first of all, if you are not on Discord and you are not on the Biddler Channel, please join now because I'm probably going to share some links or comments that you have to run to follow this workshop. Also, it's important or you may want to know that what we are going to be doing is mostly following the tutorial that we have on our site. So let me show you the link to the tutorial. You don't have to worry about reading it now. Everything is going to be live. But if you want to go back to it after we finish this session or if you just got lost in a random part of it, you can ask on that discord.
00:04:26.756 - 00:04:56.560, Speaker A: You can raise your hand here on Zoom. Or you can go to a tutorial and check what's in there because this session is going to be pretty close. Pretty close to it. So let's start. So, to follow this tutorial, you need to have a Node JS installation. I hope everyone follow the instructions to do that. If not, you can find them in the tutorial.
00:04:56.560 - 00:05:56.390, Speaker A: But if you did, you just need to create an empty folder anywhere in your file system and initialize an NPM project. You can do that by running NPM init Y. I've already did that, so I won't repeat it, but please do it now. Let's a minute or so for people to do that as I mentioned, everything is here in the tutorial. So this is probably well, actually section three, you can follow these instructions and you are going to get the same result done by following the workshop. So as you see here, first we create a directory. Then we get inside the directory, run the NPM in it, and then we start some things.
00:05:56.390 - 00:06:35.330, Speaker A: The first thing that we are going to start is Vidler, our development tool. So let's start by talking a little bit about what Vidler is. So Vidler is a task runner for Ethereum. It automates the different things that you normally need to do while developing smart contracts and apps. Mostly they are compiling and running tests, but it also works for other kind of things. But we are going to be focusing on those. Apart from a test runner, Vidler has I think we have a question.
00:06:35.330 - 00:07:30.212, Speaker A: Okay, apart from a test runner, Vidler also has the testing Ethereum network. It's used to test your contracts. As Name says, the main reason for this is that you don't want to test your things on a live network, especially not on Mainet because things on Mainet cost money and also they go pretty slow. Instead of doing this, Biddler has its own simulated network or blockchain. We call it Biddler EVM and it has the advantage that first, it doesn't handle real money. So if things go badly, you don't lose anything. You can just restart your test and it's super fast.
00:07:30.212 - 00:08:38.280, Speaker A: And also it's heavily focused on development and debugging. So it can have special features that will make your life easier when developing smart contracts. Okay, so I guess everyone has already created their NPM project. So let's install Biddler by running this command. It's exactly the same one than if you were to follow this thing and install these plugins. Why do we have to install those main things? It's because Bibbler, one of the main focus of Bibbler is flexibility. Bibbler is based on a plugin architecture, so its core has minimal functionality and this testing network that we mentioned but then you are going to have to install plugins to connect to Ethereum to add some testing functionality and things like that.
00:08:38.280 - 00:09:44.330, Speaker A: I've already ran this command. If I rerun it, it's going to be super fast on my machine, but in yours it's going to take some time. Let's wait for a few minutes for everyone to install these things. In the meantime, if you have any question, please raise your hand or just write it on Discord. This is a lot of things, so it does take some time, maybe like two or three minutes. You can also use Fiddler to deploy your contacts to live networks. It's exactly the same process than deploying it to Biddler VM, the integrated network.
00:09:44.330 - 00:10:16.180, Speaker A: The only difference is that you have to instruct Biddler to connect to a different network than mainnet. Apart from that, it's exactly the same. You just write your deployment script. Or you could also run your test against Mainet, but that's going to take way longer and cost you money. So I don't recommend that. There's also other testing networks that are closer to mainnet. There's a bunch of them.
00:10:16.180 - 00:10:49.370, Speaker A: The closest to mainnet is called Robsten. It's pretty much the same than Mainet. It's also a proof of work blockchain. So it has the same peculiarities that Mainet has. The main difference is that Rockstain doesn't cost money. You can get it from Free through MetaMask or through many other places. But we are not going to see how to interact with those in this session.
00:10:49.370 - 00:11:33.600, Speaker A: We are mostly focusing on how to breed bright and bar contracts using Bidillary VM. So let's wait, I don't know one more minute because this does take time. But I think in the meantime I can show you how Builder project looks like. So now my folder is empty. Of course, I have the solution directory that you won't have. It's just a cheat sheet in case I forget something. But then you should have an empty folder with your node modules, package JSON and package log.
00:11:33.600 - 00:12:22.670, Speaker A: But there's a bunch of things that you are going to create here. First one, it's the contracts directory. You can just create it or wait until the installation finishes, but it's just an empty directory where we are going to place our Solidity files. Then there's also test where we are going to place our test files and that's pretty much it. So has everyone finished installing video? I don't know. Raise your hand if you haven't. I think someone okay, it's still starting for you.
00:12:22.670 - 00:13:08.940, Speaker A: Let's wait a few more minutes. Thanks for answering. So one important thing to know when developing smart contracts, especially with Bitlow, is that tests and contracts are written in different languages. You write your test in Solidity, but you write sorry, that's wrong. Actually, you write your contracts in Solidity because that's the language that Ethereum uses. There's also a few other languages, but those are smaller and more experimental for now. So most of the contracts out there are written in Solidity and it has better support from every measure tool.
00:13:08.940 - 00:13:43.570, Speaker A: There's another question. Yes. You can use Viper with Biddler. It's more of an experimental feature. We actually recommend using Solidity because it's a more mature language and everything in Ethereum is built around Solidity. So your development experience will be much better. So, getting back to what I was saying, while you write your contracts in Solidity, you normally write your test in JavaScript.
00:13:43.570 - 00:14:53.920, Speaker A: The main reason for this is that Solidity and especially the EVM, is a very specific environment for Ethereum. It's not like a general computing environment. So there's no things like or there are few things like test runners for Solidity. Especially there's non written insolidity itself because you can do things like accessing the file system or running other processes. Solidity is just designed to write smart context so it has its limitations and that's the reason why we use JavaScript to write our context. So we start connecting to the Ethereum network and execute our contracts using JavaScript. Okay, does anyone else need more time before we continue? Noel? Okay, so let's move on.
00:14:53.920 - 00:15:39.770, Speaker A: So now you should have Biddear installed all of its plugins needed for this tutorial. So let's do a first run of Vidler. Just write NPX vidler. NPX is not part of Vidler, it's just a node utility app to run your locally installed packages. So when you run NPX vidler, it means run our local vidler version that we've just installed. So you should see welcome screen and let's choose the second option. Create an empty vid config.
00:15:39.770 - 00:16:43.060, Speaker A: Because we are going to be creating our own project, we won't be using the sample project and that's it. This should have created this file Biddler config JS. This is the only file that you need to set up Bidler. So you do few things here or a bunch of things, but we are just going to load the plugin. So as I mentioned, Biddler is built around a plugin architecture and we are going to be using a plugin called Waffle here, builder Waffle that it's going to integrate with the Waffle testing environment. So to load this plugin, we just use plugin and the name of the plugin. That's it.
00:16:43.060 - 00:17:15.390, Speaker A: Remember that everything I'm writing here is also on the tutorial. So you just can go there and copy paste it. I am also going to paste it here in case you're not following that. And that's all we need to set up our plugins. So let's start to build our first contact. Okay, good. Thanks Franco.
00:17:15.390 - 00:18:08.300, Speaker A: So let's create a file in the contacts directory. We are going to be building a small token here. So let's call the file token sol and here's where we are going to place our content. So in every Solidity file, the first thing that you have to do is to tell the compiler which version of Solidity we are going to be using. And in this case this is going to be Solidity 0.5. And you do this by setting this Pragma. That's it.
00:18:08.300 - 00:18:52.830, Speaker A: Also you can copy this from the tutorial. You should probably go to step four here. You are going to see a longer contract. We are not going to be writing all this down, just a simpler version of this, but feel free to copy and paste parts of it as I go. Coding this contract. So the main construct to create a contract is just declaring it. So you can just write contract and the name of your contact and that's it.
00:18:52.830 - 00:19:36.170, Speaker A: You have a contract there. Of course, this is empty and doesn't do anything useful. So let's add a name to our contract. So that's it. What we are doing here is just declaring a variable and called name and assigning its initial value. And this public here means that this variable can be accessed from other contracts and from outside the network. For example, we can create a test to see that the name is actually my Token.
00:19:36.170 - 00:20:12.498, Speaker A: So let's do that as the first example on how to test your contract. So now go to your test directory and create a test JavaScript file. We are also going to call it Token just to reflect that it's testing the Token contract. But you can use whichever name you want. And this is just a normal JavaScript file. Nothing special, nothing ethereum specific. Here we are just going to use Vidler inside of it.
00:20:12.498 - 00:21:00.030, Speaker A: But you can treat Vidlear as any other JavaScript library. It's actually everything written in JavaScript or TypeScript. To write the test, we are going to be using Mocha and Chai. Mocha is a test runner that is super popular on the JavaScript ecosystem. It has nothing to do with Ethereum. It just runs your JavaScript test. And the way you does it, sorry, is by checking this test directory and loading every single JS file and seeing which tests are defined in those files and run them.
00:21:00.030 - 00:21:37.060, Speaker A: So how do you define your test? There are two functions that are useful for this. The first one is called Describe, which defines a set of related tests. So we say that we want to test things related to the Token contract. So we do describe Token contract. By the way, this is something super popular on JavaScript. Nothing related to ethereum. Here we are just defining the test.
00:21:37.060 - 00:22:06.940, Speaker A: And here you can define as many tests as you want. How do you define them? I don't know. What's that you just do it. Put the name of the test there. I don't know my first test. And here you are going to define a callback that is going to be the actual test. This callback in particular can be an ASIC function and Mocha knows how to handle that.
00:22:06.940 - 00:22:41.850, Speaker A: So that's it. That's how you define them. Let's, I don't know, write the console log here just to see that this is working and let's run them. So how do we run our test? It's very simple. NPX Biddler test. It's going to compile your contracts, especially the first time and every time you change them. And then it's just going to run Mocha.
00:22:41.850 - 00:23:25.520, Speaker A: That's it. So does anyone have a question? Let me check this code. Okay, so let's move on then. Okay, so for now, this is just a JavaScript test file. Maybe some of you already know this, it's pretty common. But let's actually do something with our contract. So the way we are going to do this is by accessing some global variables that Bitler defines.
00:23:25.520 - 00:24:03.630, Speaker A: You can also import them explicitly. But just for brevity, we are going to use the global version of them. Actually, I can right now. That would be a longer conversation, but I'm glad to explain parts of it. The notes of technical ones after this session is finished. But actually I can also explain the most technical ones depending on your background. There's one more question.
00:24:03.630 - 00:25:01.660, Speaker A: Okay, cool. So first thing that we need to test our contract is deploying it. So to do that, we are going to be using Ethers, which is a library to interact with the Ethereum network and your contract. There's a bunch of libraries to do this. Like Web Three suggest we are just going to be using Ethers as it's much more mature and it also integrates with Waffle, which is a great testing environment for smart contracts. And the way we can use Ethers here, it's just by using this Ethers global variable and we are going to use it to first load our contract and then deploy it. Loading the contract is actually an Async operation.
00:25:01.660 - 00:25:54.476, Speaker A: So we have to do it in an Async environment. And in Mocha, the way to do that is to create a before I say this before, sorry about that, a before block and pass. It an ASIC function. And again, Mocha knows how to handle this ASIC thing. And what it's going to do is run this function to completion before running any test. And here we can load our contract by just doing Ethers get Contract Factory. And the name of the contract, as I mentioned, this is in a sync operation.
00:25:54.476 - 00:26:42.220, Speaker A: So we need to add an await here, otherwise we are just going to get the promise. This is also written in the tutorial. So if you go to section five, you can pretty much copy paste the thing. It's actually here. The only difference is that I'm using that before block here. But it's exactly the same thing, it's just a different structure. Any questions so far? Yes, actually, sorry about that.
00:26:42.220 - 00:27:03.460, Speaker A: The name must match the contract name, not the file name. But it's a common practice to use the same name for contracts, their solidity files and their test files. So that way you don't have to be thinking about which name to use every time, you just always use the same one.
00:27:03.610 - 00:27:06.070, Speaker B: Patricio, could you just repeat the question.
00:27:06.520 - 00:27:52.180, Speaker A: And then oh yes, sorry. So I don't remember who asked that, but someone asked val asked about which name we have to use in this Get Contract factory function. Because here, token is the name of a bunch of different things and the answer is that it has to be the contract name. But my recommendation is to use the same name both for files and contracts. That's cleaner and it also saves you time. I mean, you don't have to figure out these kind of things, you just use the same name everywhere and it's easier. Okay, so let's move on.
00:27:52.180 - 00:28:29.980, Speaker A: So once we have our token here, we can actually deploy it. This token is not an actual instance of the contract, but let's say that the contract itself, it's more like a class and not an instance of our object. This is why it's called a contract factory. It's used just to deploy the contract but it's just a JavaScript extraction. It hasn't touched the Vidala VM network yet. So the first thing to do that is deploying it. And we just do it by calling Token Deploy.
00:28:29.980 - 00:29:32.084, Speaker A: This is also an Async operation so we also need an Await here. Otherwise we are just going to get the promise and this way we are going to get an actual instance of the Token. What this does under the hood is sending a deployment transaction and transactions in Ethereum take time and have to be confirmed or mined before they actually get into the blockchain. So we have to wait for the deployment transaction to be mined or confirmed. And we do this by calling Token deployed and also awaited. Once we got here, we have our Token already deployed and we can start testing different parts of it. How do we do that? Well, this object Token well it's a JavaScript object.
00:29:32.084 - 00:30:12.384, Speaker A: It's going to be mimicking or copying the I don't know how to move this thing. Sorry. I have a zoom thing covering my visual studio code. It's going to be copying our Solidity API. So here if we have a public function called Name while this is in Solidity, it's also going to be available in JavaScript on our Token object. The difference is that here this is a variable and here it's going to be an ASIC function or a Getter. So what we can do is call Token Name.
00:30:12.384 - 00:30:54.190, Speaker A: This is going to return a promise because it has to interact with the Ethereum network and that implies in a synchronous operation. So we have to await it and we are just going to get the Name. For now, let's just console log it and see if this is working. Okay. My token. So we are good. Any questions so far? Let's see here.
00:30:54.190 - 00:31:56.370, Speaker A: Okay, not for now. So now let's start actually testing this thing and increasing its functionality. We could just test these things like with console log and then checking manually if things were correct or things like that. But normally in JavaScript and especially when you are using Mocha, we use a testing library called Chi and Chi just offers a bunch of assertion functions that you can use to check different things. Basically, as in any unit test you just get some value and compare it against a well known value that you are expecting. Chi actually has different APIs. We are going to use one called Expect.
00:31:56.370 - 00:33:05.700, Speaker A: You can import it like this. Feel free to copy paste it from here. Again, this is just JavaScript, common JavaScript testing. You may already know this. Sorry if this is boring but the way you use child is using Expect to wrap a value like this and it's going to return assertion object or I don't know its exact name but it's an object that has lots of useful functions to test things. So what we are saying here is that once we got the token name we expect it to be equal to my token. And if we rerun our test, we are not going to see the output there of a console log, but just the test passing.
00:33:05.700 - 00:33:47.860, Speaker A: And if we don't get the expected result, we are going to see the test failing. So this is pretty handy. Like in any normal unit testing framework you just get an error and an explanation about it. So that's all we can do with the name. We can also add the symbol here, pretty much the same than the name. We are not going to test it. But let's say that this is the empty token.
00:33:47.860 - 00:34:27.330, Speaker A: But that's pretty boring so far. So let's start by adding some functionality. The main thing about the token is keeping track of how many units of token or balance every person has or every Ethereum account has. And to do this we are going to use a Solidity mapping. I never remember how to define a mapping in Solidity. So I'm just going to copy paste it from the tutorial. Let's see how this is done.
00:34:27.330 - 00:35:12.110, Speaker A: Okay, it's like this. This weird thing is the part that I always forget. So what this says is that we define a mapping from addresses. The address is normally used as an ID for Ethereum account to a number and the number is of course going to be the balance. So a mapping is just like a hash table in Solidity but it's stored in the contract storage. It's not discarded after the contract gets executed. I think we have one more question.
00:35:12.110 - 00:35:56.620, Speaker A: Okay, so now we have this variable to store the balances, but it's a private one. We can't actually access it. So we need to define gerry to access this variable. So let's do that. Let's define the function. I sometimes also forget how to define functions in Solidity. I mostly work with TypeScript so I'm pretty sure it's like this.
00:35:56.620 - 00:36:35.014, Speaker A: Just like in C or JavaScript, but with types. So let's say account. And here you have to define whether if this function is public or not. In this case it's going to be public and it's going to be a view function. Which means that it doesn't modify the state, it just access it. It's like a view of the contract state. The good thing is that if we make a view function, we don't need to send an Ethereum transaction to run it.
00:36:35.014 - 00:37:46.140, Speaker A: We just can run it without the transaction and get its return value and that's it. So we don't have to wait for it to confirm and we don't have to pay for its execution. The way this works is that the node you are connected to just runs it for you, gives you the return value and doesn't broadcast any kind of transaction to the network. And apart from that we just need to define the return value and it will be the same type than the balances, of course. And then just return the value balances and that's it. So how do we test it? Same time before. Let's change this to token name.
00:37:46.140 - 00:38:45.200, Speaker A: So now let's test the balance. You should probably use better names for this, but it doesn't matter now. So how can we test the thing same? We just call the balance of and we have to pass an address here. Let's try with address zero. An address has 40 characters, I think, so it's one I don't know how to do this. That's it. And in this case, as we haven't assigned any value to this balance mapping, we are always going to get a zero and that's the balance that we should have.
00:38:45.200 - 00:39:16.360, Speaker A: Let's check this. If it's working, it's going to recompile the contract because we changed it. There's a typo here. Let's try again. Okay, so it passed. Let's see if there's any question. Oh, thanks John.
00:39:16.360 - 00:39:50.980, Speaker A: Yeah, I'm going to copy paste it. There's probably a constant somewhere in Ethers to do this. I always forget its name. So I do this annoying thing of writing a lot of serials and pasting it here. How do I get into the chat here? Yes, you can deploy in the before instead. Let's change that. That's a good question.
00:39:50.980 - 00:40:54.018, Speaker A: You can deploy your contract here, but that means that you will be sharing the instance of the contract in every test. And I don't recommend sharing parts of your test state between tests because that way your test may pass or not, depending on the order on their order. And that's not ideal because maybe in the future you delete one of them or you reorder them or whatever and they stop failing. So to avoid that, mocha has this other function called before each. It's pretty much the same. The difference is that it's going to be run actually before each test, before every one of these or each one of these. So the state won't be shared.
00:40:54.018 - 00:41:53.510, Speaker A: The difference is that we won't be defining a new variable here, but just assigning to this token variable and that's it. Let's delete this and this should also work. Okay, cool. So the only other function that we want to implement to this token is a transfer function. So let's start by moking it somehow. So trans transfer. So it's going to transfer tokens from whoever it's calling it to receiver.
00:41:53.510 - 00:43:16.738, Speaker A: And it also needs an amount of tokens to transfer and it doesn't return anything because we don't care about that. It's not a view function because it's going to change the state of the function. But the problem is that we may implement this function now, but how do we get our first tokens? Who is the one that's gonna be able who is going to be able to transfer tokens to other people if no one has tokens so we somehow have to assign the initial supply of the tokens and we are going to do that in the constructor. Here there's a special function called constructor. I think it has to be external where you can initialize wherever you want. In particular, we are going to initialize the balance of the token to an initial supply message. Sender is the address of the account.
00:43:16.738 - 00:43:49.460, Speaker A: It's calling this function. And we are going to be assigning a million tokens to whoever deploys this token contract. Let's see if there's any other question. Okay, cool. Balances. Let's see. Okay, this must be public.
00:43:49.460 - 00:44:52.120, Speaker A: I don't know why, but let's also test this. The balance of whoever sent the transaction must be a million. So who is sending the transaction? Well, we actually have to get this sender account from Ethers. And we are going to do this by assigning by getting the accounts from Ethers and assigning the first account to that sender variable. Because normally in Bidler, the first account of Bidlar VM is used by default to deploy contacts and send transactions. And you do this by calling Ethers get Signus, I think. Let's check this here.
00:44:52.120 - 00:45:43.766, Speaker A: So yes, it's Ethers get signers. So remember that everything is here. If you get lost, or even if I get lost, I will just come here. So let's use the account zero or the first account to assign that sender variable. And now we can actually use it. How are we going to use it just to check if its balance is 1 million. We are just going to call the balance of function and check its return value so the sender has an address.
00:45:43.766 - 00:46:27.430, Speaker A: I think you get it like this. I'm probably going to check this in the tutorial because I always forget about this. And let's compare its return value with 1 million. We already know that it's going to be that and let's run it. It's get signers. Let's see another typo there. Hopefully this works.
00:46:27.430 - 00:46:53.772, Speaker A: Okay, cool. So now that we have a balance, we can transfer this. This is so annoying. We can transfer the tokens here. It's pretty easy. So let's do I don't know. Well, I guess everyone imagines how to do this.
00:46:53.772 - 00:47:35.470, Speaker A: We just subtract some tokens from the sender and we add them to their receiver. And let's just do that. So we subtract from the sender, add it to the receiver receive. Okay. Yeah, that's it. So now we can test this thing and see if it's broken. And probably we are going to need to debug it.
00:47:35.470 - 00:48:18.250, Speaker A: Let's see if there's another question first. Thanks, Franco. Okay, so we are going to add another test. How are we going to test this transfer function? Well, we should use the balance of getter to actually test it. We are going to just send a transaction and check the balances after the transfer was run. And it should be modified according to our logic. So let's do this.
00:48:18.250 - 00:49:04.360, Speaker A: Let. Me do this const zero because I'm going to be using this a lot. Token transfers. Okay. So the first thing that we are going to be calling is token transfer. First argument is the receiver. We are going to be sending it to the other zero and we are going to send one token.
00:49:04.360 - 00:49:58.026, Speaker A: This under the hood is going to be sending Ethereum transaction to the network, waiting for it to get mined. And just after it gets mined, we are going to be able to check the results. Ethers is going to do all of these things for us, so we can just concentrate on testing the thing. And what we should be seeing after this is run is that the sender has one less token and the zero Alice, has exactly one. Let me see if there's another question. Yes. Okay, so that's a good question.
00:49:58.026 - 00:50:51.528, Speaker A: You always need Ether to be able to send a transaction. But as I mentioned earlier, we are running against this simulated blockchain called Bidler VM. And in Biddler, when we initialize Biddler VM, we give some testing ETH to each of these accounts. Especially, we do that with the ones returned by Ethers get signers. They get a whole bunch of ETH so you can run your transactions without having to worry about fees. Let's see. Okay, so let's test this zero.
00:50:51.528 - 00:51:25.150, Speaker A: And we should have one token here. I'm pretty sure that oops, no, this is going to fail because we need 1345. That's right, I guess. Let's see. Transfer. The type was here. Transfer.
00:51:25.150 - 00:52:17.000, Speaker A: Wait, why? We are expecting it should be five nine. It no, it should be six, right? Yeah. So now it should pass. Okay, cool. So let's see what happens if we try to transfer 1,000,001 token. This is 1,000,001. Yeah.
00:52:17.000 - 00:53:21.180, Speaker A: What should happen here? It's probably I don't know, it should drain all the sender tokens and assign 1,000,001 to the other zero. Let's run it. And it failed. And we got this horrible, huge number that I guess no one knows how to pronounce. And I know what you normally have to do if you get an error like this on Solidity is, I don't know, break to somehow fix it. But with Biblayer, what you can do is use our console log feature. That is a Solid library that you can import by doing this bitler console sol.
00:53:21.180 - 00:54:19.760, Speaker A: And by running this line nomic labs. Is it correct now? Yeah. So by adding this line, you get access to console log in Solidity. You can copy paste this from Debugging with Builder VM right here. It's just an import. And what we should do is, like in any other language, like in JavaScript, just add console logs to help us divide. So trying to transfer from, let's say, to message sender receiver, let's see if this is working.
00:54:19.760 - 00:55:27.854, Speaker A: And what build ABM is going to do is just print the console log as you would expect. Okay, trying to transfer from the sender to the other zero. So let's add some more console logs. Sender balance is and is transferring. So this is how you get the balance and this is the amount. Okay, so let's check this console log works. Okay? No, so, console log doesn't emit an event.
00:55:27.854 - 00:56:25.758, Speaker A: What we do is just create very peculiar contact execution traces. I know this is super technical, I don't want to go very deep into the details, but the thing is that Vidrebm knows what's being executed. It's not just blindly executing bytecode but understand just parts of Solidity. And it does understand this call to console log. How it's super technical, but trust me, it does understand it. And when it detects it, it just prints using JavaScript console log. And what happens on mainnet if you deploy this? So if you deploy it on Mainet, it will just do nothing.
00:56:25.758 - 00:57:09.162, Speaker A: It will just spend a little bit of gas. But there are other tools that will be able to decode this on Mainnet. In particular, you can use Tenderly. Franco, can you paste the link to Tenderly? It's a great app to divide main transactions. So this is cool because we can figure out what's going on on our contract. So here the sender balance is actually lower than what we are trying to transfer. We can even check that instead of being guessing.
00:57:09.162 - 00:57:30.660, Speaker A: So let's do this. Has enough tokens. I do this on JavaScript all the time. So this is also wrong. It's like this. So this should print true or false. Let's see.
00:57:30.660 - 00:58:22.480, Speaker A: It takes a while to compile because every time we change the console log, we are actually changing the contract. Okay, so has enough tokens, it's false. So that's the problem. We are trying to transfer more tokens than we have and we should not allow that. And how do we do that on Solidity? Well, you have this function require that it's very useful to check this kind of preconditions. So what it's going to do is just make the transaction fail if its first argument is false. So if something needs to be true for your function to run, you just add a require.
00:58:22.480 - 00:59:17.544, Speaker A: And what it's very cool is that you can add a message to it. So let's do something like tell the user that they don't have enough tokens and let's see what happens if we run it. It should also fail with a clear error message. Okay, so yeah, we have the message here, not enough tokens. So we can know that this require is failing. But also what Biblibm does is computing Solidity stack braces and connecting them with JavaScript. So this is actually a JavaScript exception, but it has the Solidity stack trace.
00:59:17.544 - 01:00:38.480, Speaker A: Of course, now it's tiny because there's just a single function, but if you have multiple functions, they will all appear here and also across multiple contracts and multiple files. So using Vidre you can get access to console log to get to understand what's going on in your contract. But also if it fails, you are going to have a clear picture of where your contract is failing by taking a look at the stack traces. So finally, what we are going to see is how to actually test this required failing. Give a bit of context on Bilari VM, like how it's being used, where it is. Didn't I do that at the beginning? I can repeat it if I did, but Biblibm is a testing network that it's integrated into, like if you know Ganache, it's like Ganache but focus on debugging and testing. And what it does is, as I told some minutes ago, it does understand solidity.
01:00:38.480 - 01:01:40.170, Speaker A: It doesn't just blindly run your contract, but it knows where it's executing. So uses that information to do things like printing console logs or computing solid stackfaces. It's automatically initialized every time you run Biddler. When you run your test, you get a new instance of Biddler VM, like pristine builder EBM blockchain with the same state every time. So your tests are always deterministic and it automatically gets destroyed after your test run. And as someone asked, it does give you some if for the accounts that you use for testing. But that's not really it's just visual AVME that it will disappear when your tests run.
01:01:40.170 - 01:02:25.476, Speaker A: So you can get a bunch of it for free and you don't have to worry about having gas, I mean having it to pay for gas during your test. I don't know, if anyone has a question about Bdbm, you can ask it now. Let's wait a few seconds for that. Can you also paste the definition for zero in the chat? Sure, someone needs it. There it is. I think that's private, right? Yeah. Okay, I see.
01:02:25.476 - 01:03:22.216, Speaker A: Sorry. Yeah. Okay, so the last thing that I'm going to show is how to test that require failing. And this is going to be super easy thanks to Waffle, which is a library that adds a lot of functionality to Chi. Chi already has these things like to be equal, blah blah blah, that lets you test JavaScript things. But Waffle adds some ethereum specific functionality to chai. So what you can do is use expect to grab your transaction and you can use the same kind of assertions that I'm pretty sure I won't remember them now.
01:03:22.216 - 01:04:38.680, Speaker A: So let's copy paste them from the tutorial. So it should be somewhere here revert. Okay, so it has this expect to revert with that receives the error message so we can actually test for the error message. This is cool because if you just test that the transaction is failing, it may be failing for other reasons and your test would still be passing. But by doing this, you sure that your logic is actually doing what you think it's doing and let's run it. There's not a typo. Okay, so to end this, let's just break this test to see what happens.
01:04:38.680 - 01:05:34.690, Speaker A: Okay, so it tells me that the error message should have been not enough tokens and it's not enough token. No, it should have been not enough tokens ASD but the ASD is missing, so the test failed. If you follow the tutorial, there's more things about how to test your contact. Things like how to send transactions from other accounts, and not always from this first account that we call Sender. It's not complex, but we are running out of time. So please, if you want to know about that, come here and read this tutorial. It has much more tips that you can use during your hackathon project.
01:05:34.690 - 01:06:35.652, Speaker A: There's also a section about how to deploy your contract to Mainnet or other live networks. Like as I mentioned, there's Robstein Coba and other testing networks that are closer to Mainnet than Bitley VMEs. And finally, there's a boilerplate project hosted on GitHub which includes the final result of following the tutorial. And also a minimal front end application using Ether Sound React. It's not explained in the tutorial yet, but it has lots of comments on how it works. You can use it as an example to see how to connect to the Ethereum network on a front end application, or also as a boilerplate to build upon your hackathon project. So I think that's it for now.
01:06:35.652 - 01:06:41.300, Speaker A: If anyone has a question, you can ask it on the chat.
01:06:42.440 - 01:06:54.430, Speaker B: I think if you wanted to, we could probably go for another five minutes. If you had some other finer details you wanted to jump into, or another section of the tutorial, I think it's okay if we go a little bit longer.
01:06:55.360 - 01:07:28.196, Speaker A: Okay, briefly over deploying. Okay. Yeah, let's do that. So in binnara, apart from running tests, you can do a whole bunch of things. One of those is writing scripts that can access the Ethereum network. So let's write one to deploy our contract script. I don't know.
01:07:28.196 - 01:08:17.350, Speaker A: This folder can have any name. Let's call it script. Scripts are pretty much the same than tests, but they aren't using for testing. They are used to do actual things. They use the same syntax they use things like this await Ethers, get Contact, factory signers and things like that. The difference is that their intention is not testing your contract, but running things like deploying your contract to a network. So let's write a deploy script and let's add something like Console low High.
01:08:17.350 - 01:09:15.610, Speaker A: So the way you run this thing is by also using Biddler, of course. But instead of running Biddler test, you are going to do run script deploy JS. When you run it, Biddler will compile your contract, connect to the theorem network that it's using, depending on your settings. And after that's done, it's going to run this JavaScript file. So things like deploying a contract or getting the account that it's deploying it, it's exactly the same as if you were doing it in your test. The main difference is that you don't have Mocha no chai here. You just have a plain empty JavaScript file where you can do whatever you want.
01:09:15.610 - 01:10:05.320, Speaker A: As most of these things are async. We are going to be creating an Async function to make our life easier. I normally call oh, I hate this. I normally call this function Main just because. And what we are going to do is call the main function and if it fails, we are going to print its server. This is a common pattern in JavaScript to be able to do everything with a sync await. Otherwise if you call Async functions here, you have to do things like then catch all the time and those are pretty annoying.
01:10:05.320 - 01:10:58.360, Speaker A: So if you define a main Async function here, you can use a weight and everything is easier. So as I told, the way you work in the script is pretty similar than you would do on a test file. So let's just copy paste all of this. So that's the way we get our token. Let's get the deployer account in an initial way. Let's call it Deployer here instead of testing of Sender. And finally here we deploy our contract.
01:10:58.360 - 01:11:43.588, Speaker A: Initially, this is all you need to do to deploy your contract. The thing is that you are going to lose it. At the very least you want to console log the token address. Let's try running this. This is probably going to run okay, that's cool. We have a contact address, but there's a few issues here. As I mentioned, when you run Biddler by default you are just going to be running things against Biddler EVM.
01:11:43.588 - 01:12:53.348, Speaker A: And that's not what you probably want to do because Biddler VM gets initialized and destroyed automatically every time that you run Biddler. So yeah, you deploy your contract but after the deployment script run, that blockchain gets destroyed. So it's completely pointless unless maybe you just want to, I don't know, debug this deployment script. Another thing is that to deploy to an actual network you do need if to pay for the gas and nobody's going to give it to you automatically. So just to be sure that we actually have ETH on the deployer account, let's get the balance and print it. You can do this by accessing the ethers provider and calling a function that I think it's called get balance. I'm passing designer.
01:12:53.348 - 01:13:31.772, Speaker A: This may be completely wrong, but let's test it. Deployer balance. You can go get balance on the signer directly, I think. Oh really? Well that's cool. Let's do that's. Let's see, we are going to see a pretty large number. Okay, so it's a big number.
01:13:31.772 - 01:14:17.754, Speaker A: This is a little annoying. So you have to call two string to print it. Otherwise you are just printing the object that represents that number. Okay, so yeah, we have a lot of if. This is a huge number because this is actually weight which is the basic unit of if, one if is equal to, I don't know, a lot of weight. I don't know how to pronounce that number, but it's like 118 zeros. And yeah, we have a lot, but that's actually vital VM if.
01:14:17.754 - 01:15:16.626, Speaker A: So it's worth nothing. But it's useful to have that number there to check that we actually have gas to pay for the deployment. Another thing that we do need to do is well, what we actually need to do is to connect Vidler to another network, like to a real network to deploy it. And to do that, you have to set them up here on your villa config. It's not complex, but it's a little bit cumbersome because you need a node to connect to when we are running against Vidler VM Biddler it's its own node. But when you are running against Mainnet or Robsten, you need an actual node. And you probably don't want to set up your node just to deploy your contracts.
01:15:16.626 - 01:15:56.660, Speaker A: So you can use a service ethereum node provider, the most popular one. It's called infura. And Infura is just like a provider of ethereum infrastructure. It gives you some APIs to connect to their nodes. And that's all you need to do here. So if you were to deploy to Mainnet, you can define a network here called Mainnet. And you have to set the URL of this endpoint you are going to be connecting to.
01:15:56.660 - 01:16:31.530, Speaker A: And we are going to be doing that in a minute. But first I think there's some questions. Okay, cool. Thanks Frank. So let's not use Mainnet here because I'm going to have to paste the private key. So let's do Robstand instead. And there's probably a URL here.
01:16:31.530 - 01:17:54.086, Speaker A: Okay, yeah, it's here. So if URA URLs normally look like this, the name of the network infura IO slash some things and you need a project ID to get one. You have to sign up into Infura and follow some instructions there. Of course I have an account, but once you adhere, you can create different projects and each of them has API key. I think it's here in Settings and you can just copy this URL and paste it here and that's it. That's all you need to connect to Infura. It's pretty easy things like but apart from that, you are going to need a private key because what is going to happen if you don't set any account is that Bitlayer is going to try to use the account of the node that it is connected to.
01:17:54.086 - 01:18:42.710, Speaker A: And in this case you are connecting to an infura node and it doesn't have any account. Why doesn't it have accounts? Because it's public. It doesn't make sense for it to have accounts. They will be used or shared by lots of people who are going to be stealing their ETH from each other. So it just doesn't have any account. And to set up an account, you just have to set this account survey in your builder config with a private key. I actually don't know how to set up a new private key here without exposing my actual private keys.
01:18:42.710 - 01:19:04.202, Speaker A: So I'm not going to do this right now. But you just have to follow this tutorial. There's an easy way of doing this. That it's. Exporting your MetaMask private keys. I don't feel comfortable doing this live here. But you can just follow these instructions.
01:19:04.202 - 01:19:42.426, Speaker A: It's super easy. Or you can also create a new private key for this. I think there's a website called Keys Lol which generates private keys. Not the most secure way of doing this, but it's very easy to remember its URL, so I use it for things like debugging. You just get a private key and its address. Of course, all of this generated randomly have studio, so you won't be stealing anyone's money. I'm sorry, but apart from that, you just paste it here.
01:19:42.426 - 01:20:34.774, Speaker A: You can copy this config file, but there's one last thing that you need to do there is getting money into that account. Well, not actual money, because we are not using mainnet here, but Rostain. Yeah, fake money or test money. So there's these websites called Faucets that will give you money for free. In this case, this one is made by MetaMask. And the way you get money is by pressing this button, and it will send money to your MetaMask account. I have already used this thing a few times, so it's already connected to my MetaMask.
01:20:34.774 - 01:21:10.966, Speaker A: And here's one of my address. If I press this button. Okay, there it is. I have to do the whole thing of putting out my password and it's going to send me money there. But once you have that money, all you have to do is rerun your script with a parameter called network, and you use this name to indicate which network you want to connect to. And that's it. The same script is going to run.
01:21:10.966 - 01:21:33.040, Speaker A: Your contract is going to be deployed. You're going to see the balance of your address on Robsten or Mainet or wherever you're using. I'm sorry, but this number is going to be way lower. Finally, you are going to see the address of your contract, and that's all you need to do. Any question?
01:21:38.310 - 01:22:27.326, Speaker B: Awesome. I think that's probably a good place to wrap up. Okay, any final questions from anybody in the chat? Again, if you have any things that you couldn't follow along with or you missed, there's a dedicated nomic chat or a Biddler chat in the Hack Money discord, so just head there. If you run into any other problems, the team will be there to help you troubleshoot anything. Hopefully you're able to use it for whatever you're working on. Real quick, let's get everybody to turn on video. If you can just give a wave as a big thank you to Patricio and Franco.
01:22:27.326 - 01:22:28.740, Speaker B: You guys have been awesome.
01:22:29.110 - 01:22:30.770, Speaker A: Thumbs up. Two thumbs up.
01:22:30.840 - 01:23:01.698, Speaker B: Waves everything. Thank you so much for taking the time to run through what you guys are working on. It's really an awesome product. Like I said, hopefully people are able to use it for their project. So, a few last things. Let's see if you've applied and you haven't staked yet, the deadline is either tomorrow or Wednesday, so you need to do that ASAP. If you're not in the Hack money channels, please reach out to anybody on the team and we'll get you in the right channels.
01:23:01.698 - 01:23:36.038, Speaker B: If you haven't found a team yet or you have an idea and you'd like some feedback, please, again, reach out to any of the team members. Drop your ideas in the Hack ideas channel. We want to make sure that everybody's starting off on the same footing. So reach out if you have roadblocks earlier rather than later, and we'll make sure to fix any problems if you have them. I think that's it. We'll be having a team formation session on Wednesday. Again, if you haven't found a team yet, go to the Find a Team channel.
01:23:36.038 - 01:23:57.310, Speaker B: There's a form there that you can fill out, and we'll try to match you up with people who are interested in working on the same thing. So, yeah, fill out the form, and we'll be having a session for anybody who's still looking to join teams on Wednesday. I'll double check the time for that. Andrew, do you know the time? I don't know the time.
01:23:57.380 - 01:23:58.238, Speaker A: Sorry. Okay.
01:23:58.324 - 01:24:07.514, Speaker B: All right, well, it should be somewhere in the discord. I'll link the schedule. Awesome. All right, thanks again, guys. We'll see everybody in the discord.
01:24:07.642 - 01:24:12.970, Speaker A: Thanks, everyone. Thank you, everyone. Bye. See you in the discord.
