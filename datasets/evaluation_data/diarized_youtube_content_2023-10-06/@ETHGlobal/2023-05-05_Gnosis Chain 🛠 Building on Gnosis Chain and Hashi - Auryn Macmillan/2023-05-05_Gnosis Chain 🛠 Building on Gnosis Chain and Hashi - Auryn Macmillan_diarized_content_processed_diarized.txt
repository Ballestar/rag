00:00:07.530 - 00:00:41.130, Speaker A: Cool. Hey folks, I'm Oren work at Gnosis with Dao. I guess that is the steward of Gnosis Chain. The talk today is going to talk briefly just about building on Gnosis chain what Gnosis chain is. But then the bulk of it is going to be about hashi which is a new kind of bridge oracle aggregator. So we'll kind of talk about what that is and why it exists. For the bulk of the talk today, but just quickly talking about Gnosis Chain kind of why it exists.
00:00:41.130 - 00:01:38.380, Speaker A: Gnosis Chain is a kind of community run chain formerly known as XDI. We kind of aim to have this environment that very closely mirrors the mainnet Ethereum environment in terms of both the beacon chain and the execution layer. Big differences are essentially the price for participation. So running a validator on Gnosis chain requires a one GNO deposit which is a few hundred dollars as opposed to the kind of 32 e tens of thousands of dollars deposit to run a validator on main net Ethereum. So really it's intended to kind of open up at home staking to a much much larger audience of users on kind of really low end hardware with very low stakes. And as a result we've had a really incredible response from the community. More than 100,000 validators up and running.
00:01:38.380 - 00:03:01.654, Speaker A: It's tooling compatible with everything that you already use to write smart contracts for Ethereum main net and the price of transactions is super, super low. The native token on the network is Dai or kind of Dai breached over to Gnosis chain. So XDI and yeah, 100K gas is a fraction of a cent. This is really great for kind of testing things in production but also for kind of high throughput applications where you want to have your users be able to kind of participate in some interesting thing on chain that isn't necessarily financially dependent or isn't financially worthwhile necessarily to run on mainnet. So we've seen a lot of really interesting things like games deployed on chain, games deployed to nurses chain because they can kind of leverage on chain mechanics without costing users ridiculous amounts of money just to kind of participate. So just a couple of links here for kind of playing with Gnosischain you can find the docs Gnosischain.com faucets for both mainnet and for their chiato testnet@gnosisfosst.com
00:03:01.654 - 00:03:59.506, Speaker A: and then the RPC endpoints for interacting with mainnet with nurses chain's mainnet and for testnet. Yeah, so I guess what I'd like to do is just encourage folks if you're building something here at the hackathon, then explore nurses chains as an option for deployment target if you are doing something, particularly if you're doing something that would benefit from really low cost transactions and a really stable execution environment. We have a whole bunch of prizes for applications built on and deployed to nurses chain and we'll talk about them at the end. We can switch gears now, switch topics and jump into hashi which is this hash Oracle aggregator. So hashi is a protocol for cross chain communication based on this kind of additive security. So multiple inputs. Multiple oracles.
00:03:59.506 - 00:04:55.530, Speaker A: At its core, it's a hash Oracle aggregator. And what I mean by that is it allows you to start this kind of Ryho, which is this acronym that I'm trying on. I don't know if it'll stick, but it's akin to array if you've ever set up kind of big storage devices, redundant array of hash Oracles. The idea here is to distribute trust for bridges kind of on the mechanism level, not put all of your systems trust into one bridge Oracle. And the reason for that is that bridges have been responsible for this outrageous amount of loss over the last couple of years. More than $2 billion in 2022 was lost because of bridge exploits. The top four of five items on the Rec News leaderboard are bridge related hacks.
00:04:55.530 - 00:06:23.202, Speaker A: And I think what this really serves to illustrate is that no bridge implementation, no bridge mechanism is kind of 100% secure. There's always attack surface and there's always potential for bridge mechanisms to fall over, to kind of break, and to in doing so, break any systems that are dependent on them. And so hashi is the system that essentially allows you to not have to trust one bridge mechanism, but rather to distribute trust over a number of different bridges, require that they agree or require that the threshold of them agree in order to kind of propagate any state change. So the design principles here, we wanted to kind of have standardization at the kind of lowest possible level, the hash for any kind of data or state change that you're wanting to propagate, make it really modular and agnostic to the underlying mechanisms. And then, yeah, this idea of this Ryho redundant array of independent hash Oracles, analogous to array, it prioritizes security over latency. So it moves kind of as fast as whatever your slowest Oracle is in your kind of threshold of Oracles, and then prioritizes kind of robustness and security over execution costs. So it's slower and more expensive than every other bridge mechanism because it requires redundancy.
00:06:23.202 - 00:07:51.218, Speaker A: But in doing so, you gain a much better security model or much better security assumptions. Essentially what you're relying on is that an exploiter cannot break multiple mechanisms in parallel and convince them all to create the same kind of false output. So even if you are able to break multiple in parallel, it's going to be really difficult, kind of near impossible to have them report the same false outcome is the kind of assumption here with something like hashi, the goals diversification on the cross chain protocol implementations. So we want integrations with kind of multiple different header Oracles. What I mean by this is kind of like client like bridges, where you're bringing the header block header from one chain over to another chain so that you can then do things like storage proofs on them and then also integrations with multiple message passing mechanisms. And this is one reason that we're careful to call it a hash oracle rather than something like a header oracle because it's really agnostic to what type of information is being passed or what type of information is being aggregated. We're aggregating hashes and that can be a hash that is a block header, it can be a hash of some message, it could be a hash of some outcome out in the real world.
00:07:51.218 - 00:08:39.380, Speaker A: You kind of use this in any number of different ways. You're just basically creating this mechanism for multiple different oracles to agree or to require multiple different oracles to agree on a given hash for a given ID in some given context. And what we want to do is allow users to choose what combinations and what thresholds of these combinations their system requires in order to kind of build custom trust assumptions for their system. It's a bit of a messy architectural overview here. I think I have a mouse curse that I call. So this is kind of drawing a kind of hypothetical example of a token bridge. So we have this token bridge over here on the left side where you would kind of deposit tokens in.
00:08:39.380 - 00:10:35.800, Speaker A: This is a little bit out of date actually. We'd have a message dispatcher contract here that the token bridge would then call to dispatch a message and that would relay it out then to various different bridge mechanisms. All of these bridge mechanisms are effectively black boxes. They do whatever they do to kind of move information from one network to the other and then over on the destination network, you have adapters to each of these bridge mechanisms that are then going to kind of feed into hashi or hashi will actually query each of these bridge mechanisms to have them report their canonical hash for a given ID in a given context. And then there's a few extra layers here to enforce specific thresholds and specific sets of adapters and then eventually a message executor plugging into the other side of the token bridge where a token would be minted for kind of end users. This is a bunch of redundancy and so we probably see this being used more by more as a way to kind of create the canonical instance of your token and then probably leveraging networks like Connect Network, the kind of liquidity layers on top of this bridge for relatively lower value and relatively lower value transfers across chain and the hashi set up as your way to kind of secure the canonical mint and burn functions for your tokens on either side. So I think it definitely benefits from these kind of faster execution layers added on top of it.
00:10:35.800 - 00:11:34.746, Speaker A: So main components here or main things that we've built in them that we're looking for, for others to build. Very interested in applications like token bridges, governance bridges, NFT bridges kind of built on top of this. Very interested in Hash Oracles. So like mechanisms for passing messages or passing block headers from one chain to another chain. Very interested in Oracle adapters. So for any existing Oracles that are out there, adapters for plugging hashi into those and interested in things like message dispatching contracts, message executing contracts and any other novel use cases that you can come up with. I guess we kind of covered that.
00:11:34.746 - 00:12:01.730, Speaker A: So we can skip over and yeah, just link here to a couple of resources. The reposit. GitHub.com gnosis hashi. I can just drop the whole presentation into their discord server somewhere so you can track it down there. And if you want to find out more about Gnosis chain in general then we've got a bunch of links here as well. If we've got time.
00:12:01.730 - 00:12:54.722, Speaker A: I think we do have a bit of time. I can happily answer any questions now, but we can also just go and poke through the code and get a bit of a better feel for how the whole thing works if you guys like and I can kind of let you drive it a little bit from there. Oh, I should talk about prizes really quickly for Gnosis chain. So there's a handful of prizes here for just applications built on top of Gnosis chain. The kind of top three applications built on and kind of deployed on Gnosis chain will get prizes as well as best project built using hashi or kind of utilizing hashi in some way and best project utilizing Safe in some way. But yeah, let's go play with some code, I guess. Does anyone have any questions now? Yeah, I looked at Succinct, I looked.
00:12:54.776 - 00:13:38.818, Speaker B: At Succinct Telepathy ZK Bridge and there they can provide the state route like on Ethereum and you can't access that from a smart contract on L One. Right? You only have the block hash, but I don't know when hashi is being used. And aggregating these values is the assumption that if the ZK bridge isn't working or someone passed a false proof that the block hash then therefore would be different. Or what values in the block headers can you compare or is there a way that the Amb can also pass the state route from L One?
00:13:38.984 - 00:15:09.840, Speaker A: Yeah, that's a great question. So I think there's probably two questions bundled in there is like what are the other mechanisms that might pass that you might use for redundancy in this? And then the other kind of question that feels like it's bundled in there is like how do you get from blockheader to actually proving some data? And so the first question there, yes, you can use the Amb for passing block headers. We built this really crude little header reporter contract here which is essentially going to allow anyone to report a block header if it's within the range that you can actually get the block headers which is like 256 blocks. Into the past, and it's going to push that over the bridge via the Amb is going to require a pass message function so we can kind of coerce the amb into sending block headers over the bridge for us. And then once you have a header, we also have the ability to, thanks to laurent back here, the ability to kind of recursively prove historic block headers. So if you want to kind of go back in time further, you can prove the kind of previous block header because it's encoded into the current block header and you can kind of do that as far back as you like. It's pretty inefficient to go really far back in history, but it works.
00:15:09.840 - 00:16:20.790, Speaker A: If you want to go just a few hops back, then it's a probably easier route than kind of coercing the bridge to kind of pass another header. In terms of how you actually extract states from a block header, there's a handful of protocols for doing this. Axiom is one that has built a system for doing ZK proofs on a block header to be able to then validate that some state exists in the block that this block header was produced from. And so yeah, I think the assumption here with the header oracle aggregation is that it's going to work in tandem with some way of proving states something like axiom. We can also imagine a system here where you might have kind of multiple iterations through hashi to automatically kind of get to some states. So you might have hashi pass, say, the header oracles via various different mechanism. Sorry, hashi pass the block headers via various different mechanisms.
00:16:20.790 - 00:17:18.970, Speaker A: Have those mechanisms agree on what the block headers are, and then have another set of oracle mechanisms that are going to be queried for the state at a given block height with the state that is approvable from a given block header. And so you take this kind of second iteration through for each of those oracles based on the header that was reported in the kind of previous iteration. And so yeah, we're very interested in kind of any additional mechanisms for doing those kind of state proofs or event proofs based on blockheners. I think the two systems that I'm aware of for doing this, axiom, and I think there's another one called dendrith. And yeah, I'm sure there's many, many more out there, but those are the two that have kind of been flagged already as ones that we probably want to have integrations with.
00:17:19.120 - 00:17:24.246, Speaker B: Could you open up this okay if you go back to the header reporter?
00:17:24.358 - 00:17:25.020, Speaker A: Yeah.
00:17:25.870 - 00:17:28.330, Speaker B: And the utils header storage?
00:17:28.830 - 00:18:05.032, Speaker A: Yeah, I don't know why it's not letting me click into it that way, but I'm just going to add it here. So header storage would be on the destination chain. And this is just where we're going to pass in the headers that we've reported from the origin chain.
00:18:05.176 - 00:18:09.532, Speaker B: Right, okay. What contract is on the origin chain?
00:18:09.676 - 00:18:13.652, Speaker A: On the origin chain would be this header reporter here right.
00:18:13.786 - 00:18:20.928, Speaker B: Which uses the header storage and it calls store block header, which only stores the block hash.
00:18:21.104 - 00:18:21.492, Speaker A: Yes.
00:18:21.546 - 00:18:24.772, Speaker B: Okay, so only the block hash and then okay, yeah.
00:18:24.826 - 00:18:26.196, Speaker A: I mean, as long as I can.
00:18:26.218 - 00:18:28.592, Speaker B: Use Axiom to make a state proof using a block hash.
00:18:28.656 - 00:19:07.428, Speaker A: So the edge storage is used in the origin chain, right. Not in the destination. How am I mixing it up? Right, yeah, sorry, you're totally right. So on the origin chain here, we're calling header storage store Block Header, which is I've got this one up separately, which is yeah. Going to store the block header on the on the origin chain and then allow because it's in storage, allow mechanisms like this header reporter to query it from storage and then relay it.
00:19:07.594 - 00:19:08.068, Speaker C: Okay.
00:19:08.154 - 00:19:16.390, Speaker B: Yeah, I'll look more into Axiom, but if the block hash is enough because I just looked at Telepathy and they're just providing the state.
00:19:18.220 - 00:19:19.592, Speaker A: Yeah, cool.
00:19:19.646 - 00:19:20.730, Speaker B: Okay, thanks.
00:19:26.670 - 00:19:27.420, Speaker A: Yeah.
00:19:30.900 - 00:19:40.580, Speaker C: So are you guys just thinking about this as more like an infrastructure tool that we can just check the headers rather than like a messaging relayer?
00:19:41.160 - 00:20:31.700, Speaker A: I think we see it as both. So it should be able to aggregate really anything that can be represented as a hash. If it kind of maps to this essentially mapping of UN two five six to UN two five six to byte 32, then it should be able to kind of aggregate it. We have built adapters for execution layer header, oracles execution Layer Lite clients, and then also adapters for sending messages. So we have down here, this Yahoo contract is our message dispatcher. So this is the endpoint that you would use on the origin chain if you wanted to send kind of an arbitrary message across chains. And then on the other side, this Yarrow contract is our message executor.
00:20:31.700 - 00:20:40.280, Speaker A: That would be the thing that ultimately calls out to whatever your system is or your contract is if you wanted to execute arbitrary calls.
00:20:40.620 - 00:20:43.544, Speaker C: And what chain is it deployed on right now?
00:20:43.742 - 00:21:06.210, Speaker A: It's not deployed in production anywhere. It's very much still a moving target, very much still in development. And so you guys are kind of getting your hands on it really early, which is great. Hopefully folks here can help shape what it looks like. Cool. I think if there's no more questions, we can probably wrap it up here. I think we've had a pretty decent little dive in.
00:21:06.210 - 00:21:08.110, Speaker A: Yeah. All right, thanks everyone.
