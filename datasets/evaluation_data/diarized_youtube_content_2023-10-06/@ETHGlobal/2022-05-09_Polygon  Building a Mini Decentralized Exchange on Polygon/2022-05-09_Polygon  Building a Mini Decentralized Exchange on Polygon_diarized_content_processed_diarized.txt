00:00:00.490 - 00:00:26.144, Speaker A: Hey, everyone, thanks for joining. Just going to wait a couple seconds for the live stream to go up on YouTube before we get started. Awesome. Hi. Happy Monday. Or Tuesday, depending on where you are. We have Rahat here from Polygon doing a workshop on building a mini decentralized exchange on Polygon.
00:00:26.144 - 00:00:35.980, Speaker A: Questions go into the zoom chat and Rahat will answer at the end of the workshop, so stay tuned. And with that being said, I'll pass the mic off to Rahat.
00:00:36.480 - 00:01:02.048, Speaker B: Awesome. Thank you. Yeah, thank you for attending my talk on building a decentralized exchange on Polygon. We're going to be talking about a little bit about why building on Polygon is awesome, as well as dissecting some code that'll help you to build sort of like an MVP or minimal viable product for a decentralized exchange. First, a little bit about me. My name is Rahat. I'm a developer advocate over at Polygon.
00:01:02.048 - 00:01:21.870, Speaker B: I've previously been a front end engineer and solidity engineer and sort of like an indie hacker Web Three enthusiast. I tweet a lot about different product ideas I have that I never build. So if you ever want ideas for things to build that I never will, you can probably follow me on Twitter for that. Yeah, these are just some places that you can find me.
00:01:23.520 - 00:01:23.980, Speaker C: Cool.
00:01:24.050 - 00:02:20.700, Speaker B: So what is polygon? Polygon is the leading platform for Ethereum scaling and infrastructure development. We provide different solutions for helping you build on top of Ethereum that can be things like Lt solutions like ZK rollups, optimistic rollups, which are kind of in the works, as well as hybrid chains, side chains and things like that. What you might be familiar with and what we're going to be talking about deploying on today is the proof of stake blockchain. The Polygon blockchain is our most popular solution. Reason being it's EVM compatible. What does that mean? Anything that you build for Ethereum, any smart contracts, solidity code, all of the tooling that exists in the Ethereum ecosystem maps one to one right over to Polygon. So if you already know how to build on top of Ethereum, you already know how to build on top Polygon.
00:02:20.700 - 00:03:13.570, Speaker B: Our native token is Matic, so rather than ETH, you'll be doing transactions in Matic. It's much more accessible. One story that I like to share to folks is that the first time that I tried to deploy a smart contract, sometime last year, it was like during the height of a bunch of different NFT projects coming out. And then it was very poorly written smart contract code with a bunch of stuff that was unnecessary and unneeded and deploying that would have cost me like a $1,000 or something like that. And, yeah, I have now been deploying a bunch of toy contracts onto the Polygon main net for a fraction of a dollar, which is awesome. It's also sustainable. We've been doing a lot of work to make sure that the Polygon blockchain is eco friendly, so you can definitely check out more involved on that.
00:03:13.570 - 00:04:01.976, Speaker B: So I've covered a little bit about this, but why should you build on our proof of stake blockchain? The speed 65,000 transactions per second. You can still leverage ethereum. Like, you can take do transactions and then bridge your assets back to Ethereum, like if you were doing like an NFT project or something like that. And saving on cost 10,000 times lower cost per transaction than Ethereum, while still, again, leveraging the Ethereum ecosystem. First thing, before we go into the code and everything, I want to shout out Austin Griffith and Scaffold ETH. Today's code breakdowns and the code that I based this workshop on are from his Minimum Viable decks, which is an awesome challenge on Scaffold ETH. On scaffold ETH.
00:04:01.976 - 00:04:59.164, Speaker B: I don't know if it's ETH, but you can definitely check that out if you want to dive in, play around and build your own version of this. He's got different speed runs and things like that, where you can go in and play around. And again, just kind of like shouting out the fact that even though it says Scaffold ETH, everything's in solidity and all of that code can be easily deployed onto polygon as well. So what does an MVP for a Dex look like? First off, we need a liquidity pool, right? So this kind of is a ratio of how many tokens are available between two pairs. For example, if we had matic as well as rahatcoin, which doesn't exist but might one day, you never know. What you would need is like a certain amount of matic in your pool and a certain amount of the rahat coin. And let's say I wanted to get some rahat coin, I would have to put in some amount of matic into that matic pool.
00:04:59.164 - 00:06:31.230, Speaker B: And once I put that matic into that pool, I can then take some amount of rahat coin that is equal to or sort of equal to. I'll cover why it's sort of equal to in a bit when we dive into the code, but that'll determine how much rahatcoin I get back. And that's part of determining the price of the token swap, which is in the code in just a second. But we want people to actually swap matic and tokens so I can put in some matic, get some tokens, put in some tokens, get some matic. And the thing that I mentioned before of why you might not get something exactly equal is this concept called slippage. What is slippage? So a lower supply of a certain amount of liquidity for your tokens causes it to be more scarce and can raise the price of that token. So let's say I had ten Maddox and ten rahat coin inside of a pool, right? If I wanted to buy some rahatcoin using some matic, I would put some matic into the pool and I'd get some rahatcoin back, right? But the formula that we're going to be looking at in this code for how to determine the price is based on something that uniswap uses called constant product.
00:06:31.230 - 00:07:23.160, Speaker B: And what we need to do is actually to determine the price, we multiply the amount of each of our assets and the result of that multiplication is this constant sort of value that we always have to keep for our ratio. So in order to make sure that the two values multiply to that final product, you might not necessarily even if I put in one matic, I might not get one rahat coin back. I might get like 0.9 something rahat coin back. And we'll take a look at that in the code in just a second. But first off, you need to create a token, right? So this is very like bare bones ERC 20 token contract. This is all you need to create a token.
00:07:23.160 - 00:08:00.060, Speaker B: If you really wanted to. There's probably other things you would want to add on top of it. This was taken also from the Scaffold ETH challenge that I mentioned. But it's really just importing opens uplin's ERC 20 contract, initiating that and just taking 1000 coins and sending it to whoever created this contract. You can of course adjust that amount to whatever you need. You can send it to other people, add more functionality, et cetera, et cetera. And then this is like the starting code for our decks.
00:08:00.060 - 00:08:53.710, Speaker B: This is importing what's called the IERC 20. So you might be wondering what's the difference between ERC 20 and IERC 20? So the ERC 20 is like the actual coin itself. It uses all of the definitions and functionality that the IERC 20 holds. So the IERC 20 is like the interface. It contains all of the information for how to transfer, how to view ownership and things like that. And ERC 20 basically builds on top of that and gives you an actual coin. The reason we're using IERC 20 in our decks is because we don't necessarily need to mint or create new tokens, but we want the functionality of being able to transfer and send tokens to other people.
00:08:55.520 - 00:08:56.124, Speaker C: Cool.
00:08:56.242 - 00:10:09.104, Speaker B: So the first thing we need to do is add some liquidity to our contract. So we need some matic and we need the token that we're trading for. And that's going to happen inside of this function, which is an init function for initializing our liquidity. So going through this line by line, first thing I'm doing is essentially creating a total liquidity variable, just like keeping track of how much liquidity is in here, as well as a mapping that will associate the address of some person, probably whoever's, calling this initializing function and just keeping track of how much liquidity they have added. So this function here init is going to take an integer called tokens. Just be like the number of tokens that we want to put in this one function takes care of both adding matic as well as adding our tokens. How does it do that? First off is that public payable, that payable keyword is key for Solidity.
00:10:09.104 - 00:10:36.200, Speaker B: Solidity is awesome in the fact that payments and just like transferring money and all that stuff is baked in natively. And this payable function allows this function to be allows the payable keyword, sorry, allows this function to be able to say, okay, I can take some Matic or ETH if you're doing this on the ETH main net and add it to my contract.
00:10:36.280 - 00:10:36.910, Speaker C: Right.
00:10:37.520 - 00:11:33.170, Speaker B: And that ability is automatically there just with that payable keyword. So next up, I have this require statement that says total liquidity should equal zero because maybe I don't want to add any more liquidity if there's already some other stuff going on. And basically sorry, I lost my train of thought. Okay, so essentially we're just checking if since this is an initializing function, we're just making sure that there's no liquidity already in there and then we'll continue. Total liquidity is going to be updated to be the current balance. And essentially we're going to take the token. That the amount of tokens and the token sorry, I lost my train of thought again.
00:11:33.170 - 00:12:32.972, Speaker B: We're going to take the token, transfer it from the user and send it over to our contract. So again, this one function takes care of both receiving matic as well as receiving the token, which could be balloons for hotcoin, whatever dogecoin you want to put in here. Next up is Swapping, which is going to be done using that constant product formula that I mentioned, determining the price. So this is like the most important yeah, definitely the most important part of adex because you need to make sure the pricing of your assets are correct. Like I mentioned before, this is built using the way the fee structure that Uniswap uses. So Uniswap has a 0.3% fee attached to each of their transactions.
00:12:32.972 - 00:13:30.260, Speaker B: So that's why you see these numbers like 1009, seven. So nine nine seven over 1000 is about 0.3% because of how Solidity does not like decimal numbers. We have to do this in a weird way where you have nine nine seven out of 1000 to actually get that proper percentage. But essentially what we're doing is saying that there's going to be a 3% fee tacked on to this price that's going to be put into the reserves of the contract. What can you do with this contract? I mean, those fees can be for actually using the decentralized exchange. Maybe you want to use those fees to add some incentives later on for some of your users who are adding liquidity to your contract, et cetera.
00:13:30.260 - 00:13:41.050, Speaker B: But the main thing to kind of remember here is that the constant product side of things introduces the little.
00:13:43.420 - 00:13:44.730, Speaker C: What happened there?
00:13:45.100 - 00:13:46.250, Speaker B: Let's go back.
00:13:50.240 - 00:13:51.436, Speaker C: There we are. Okay.
00:13:51.538 - 00:14:02.272, Speaker B: The constant product formula essentially makes it so that in addition to these fees, I'm going to get a little bit.
00:14:02.326 - 00:14:02.930, Speaker C: Less.
00:14:05.700 - 00:14:52.590, Speaker B: Rahat coin than I would have gotten. So if I put in like 1000 Maddox, normally I would expect 997 tokens back. I might get something closer to 996 because of that slippage, because that concept product is making sure that ratio is always intact. So now that we kind of know how to determine that price, make sure that we're taking our fees, make sure that the concept product side of things are taken into account for our liquidity. Now we can actually add in the different ways of swapping. First thing is Matic to token swap. I have some Matic, I want some balloons, I want some rahatcoin, whatever back.
00:14:52.590 - 00:15:39.390, Speaker B: How do we do that? Once again, it's a payable function. We're going to be introducing some bit of Matic into this. And we have this thing called token reserve, which is going to get the token balance address. One thing that might be confusing that I may not have talked on this token variable, this token variable was determined if you see here on this, IERC. 20 token and then in the constructor, we're initializing the token by taking the token address of our deployed contract of the token, which was done here. So that allows us to actually get the balance of the token, make transfers of it, et cetera. Apologies for not explaining that before.
00:15:39.390 - 00:16:36.610, Speaker B: So matic to token swap. Again, we're just getting the balance of the tokens. We are looking at what the price is adding in like the message value, getting the and we're doing this thing here where we're subtracting the balance of the message value because you'll have some amount of matic in reserves. And then the payable modifier essentially gives you some more matic, which will update that. So we want to make sure that this is done on the initial amount that you had, which is why we're doing that subtraction. And then lastly, we're just essentially transferring the tokens once we have the correct price for them. And the token to matic swap works very similarly, just kind of the opposite way.
00:16:36.610 - 00:17:38.484, Speaker B: Rather than sending the tokens, this no longer needs to be payable, we're just transferring the token amount and then sending some amount of matic back to the person based on how the price is determined. So going back to slippage, because that's super confusing concept, it took me a while to wrap my head around it. I used this example a little bit before, but like diving into it a little bit once again. So if we add 1000 Maddox and then we base like that not 3% 0.3%, sorry, we should get back nine nine seven, but we actually get nine nine six due to slippage. So whatever amount of funds you might expect, you'll get a slightly less amount just to keep that ratio up. So the more of these assets that you try to buy.
00:17:38.484 - 00:18:31.190, Speaker B: So if I wanted to buy like 10,000, 20,000 whatever slippage is going to be higher the more of this token that I want because I'm making a huge dent in the reserves. And in order to make sure that the liquidity kind of stays balanced, that slippage is kind of like what goes in and happens. This contract is what's known as like an automated market maker. The constant product formula that determines the price will keep the ratio of the liquidity swaps intact. And again, this is the same sort of formula that popular exchanges like Uniswap will use to make sure that liquidity stays intact. How can we kind of take this example and build beyond it? I love this example because.
00:18:33.000 - 00:18:33.604, Speaker C: It takes.
00:18:33.642 - 00:19:24.150, Speaker B: A very complex bit of project. Creating a decentralized exchange seems pretty easy. Like, oh, you just swap some tokens and determine some price. But all these concepts of slippage and all that are pretty hard to wrap your head around. But you can take this example and start building more stuff on top of it. Add more decentralization by allowing more deposits. I think in the challenge actually for the Scaffold e, you can go into that and create a deposit function where rather than just doing that initial liquidity initialization, you add more matic, more other token, whatever it might be.
00:19:24.150 - 00:20:35.950, Speaker B: Next thing is incentivizing deposits, rewards. You'll see in a lot of decentralized exchanges that being someone who is a liquidity provider, you're giving some liquidity into this exchange will yield you some amount of rewards. You have the basis for doing that from even a basic contract like this. And then part of this contract is like we're mapping the different addresses to the amount of liquidity that they're providing. Maybe you can use that to build out some functionality where you're providing some rewards for those people who are giving you that liquidity. Because without liquidity, you're not going to be able to run your decks for too long. It's also, again, just like mentioning the slippage stuff again is just like the reason that a lot of people prefer that a contract has a large amount of liquidity is to minimize that slippage as much as possible.
00:20:35.950 - 00:21:34.370, Speaker B: More tokens, more amount of liquidity you have in there, less slippage, better user experience for everyone kind of involved. And going beyond this, like creating more robust solution with multiple token pairs. This code really kind of focuses on one single pair. It could be Matic versus Rahatcoin or whatever, ETH versus Rahatcoin or whatever. And you can take this and build much more pairs for having an actual almost like a uniswap type of exchange where you can add in a bunch of different tokens and swap it for whatever base token you would want. Rather than doing the base token being matic, maybe you have multiple types of ERC, 20 tokens that you want to create pairs for. That's another thing you can do to build on top of this as well.
00:21:35.460 - 00:21:36.064, Speaker C: Cool.
00:21:36.182 - 00:22:10.712, Speaker B: So again, thank you for tuning in once again. My name is Rahat, Developer Advocate over at Polygon. These are just some places you can reach out to me. Always available. I'll be available on the Discord as well. If you have questions just tag me to make sure that I see the message and would love to help you all kind of like dive in and see what you build during this hackathon and I will open it up now to questions I see that we have. One is payable modifier.
00:22:10.712 - 00:22:27.650, Speaker B: Yeah so thank you Omnipent for answering that. It is a modifier yeah, that Payable modifier gives you superpowers to be able to actually receive Matic or ETH depending on what network that you're building on top of.
00:22:29.940 - 00:22:30.448, Speaker C: Cool.
00:22:30.534 - 00:22:40.710, Speaker B: Any other questions? If not, then thank you all for joining in, really appreciate you tuning in.
00:22:42.280 - 00:23:15.976, Speaker A: Awesome, thank you Rahat, super useful, I'm sure everyone enjoyed it. As Rahat said, he can be available on Discord in the sponsor Polygon channel. Just make sure you tag him so he sees the message and yeah thank you so much Rahat for taking the time to do this workshop for our hack money hackers. And for the rest of you, we do have some more workshops happening for the rest of today so hope to see all your faces there as well. I think that you have a question in the chat asking if you can send the slides.
00:23:16.168 - 00:23:18.460, Speaker B: Yeah, I'll drop that into the discord.
00:23:19.040 - 00:23:24.530, Speaker A: Awesome. Well thank you so much everyone and have a great rest of your day. Evening, morning, wherever you are.
