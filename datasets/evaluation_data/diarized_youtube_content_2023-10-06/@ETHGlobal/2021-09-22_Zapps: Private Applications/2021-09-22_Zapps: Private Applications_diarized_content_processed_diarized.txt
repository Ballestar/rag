00:00:00.810 - 00:00:40.890, Speaker A: We're now streaming to the Ethgobo YouTube. My name is Andrew. I'd like to welcome everyone to the Zaps private applications workshop. We have here Blagoi Domovsky, who will be presenting and we can take questions at the end. So feel free to either unmute yourself after the presentation is over or you can put your messages in an ongoing basis in the zoom chat and then we can go from there. All right, take it away, Blagoi.
00:00:47.870 - 00:01:59.362, Speaker B: Okay, so let me know if you can looks good. Yeah, okay, sounds great. Okay, so my name is Blagoi and today I'm going to talk about private applications. I'm going to give you a high level overview of what are private applications, why do we need them, how can we build them, and at the end, we will go over some ideas which hopefully will give you some more inspiration. But first, let me tell you about the Scaling and Privacy Exploration Team at which I work at. So Privacy and Scaling Exploration Team is a team at the Ethereum Foundation, which works on bridging the gap between cutting edge research in zero knowledge proofs and application development on the Ethereum network. And we work on various different interesting projects which you can take a look at this link here.
00:01:59.362 - 00:03:17.318, Speaker B: There are few open projects and interesting opportunities for grants as well. And also you can read the official medium page of the team. So why privacy and anonymity? Why do we need private applications? So there are many reasons, but most importantly today in the information age are the data protection of the end users, such as user identity protection, personal account information and other personal data protection. And also anonymity is quite important from the standpoint of decoupling one's opinion from one's personal identity. And this can lead to more fluid conversations and fluid experiences. And there are many other reasons. I've linked Reddit link here, which goes over in more philosophical depth on privacy and anonymity.
00:03:17.318 - 00:04:38.146, Speaker B: But the main point is that you can actually interact with applications without giving too much of your information out. So how can we enable this? So, on a technological level, we can enable this by using zero knowledge cryptography and zero knowledge proofs. And some constructs based on zero knowledge proofs that enable this are Semaphore and RLN. And today I'm going to talk more about them and how we can use them. So, Semaphore is zero knowledge gadget, which allows the end users to prove a set membership while preserving their identity. And also it allows for the users to send signals. This might be very generic, but basically the point is that the users can obtain anonymity by just proving that they are part of a certain group without telling what is their identity, and the signal can be their opinions.
00:04:38.146 - 00:06:09.890, Speaker B: And it's very application based. So for example, if we have an anonymous voting application, then the group might be a group of users that can vote for a certain voting campaign and the signal can be the actual vote of the users. And also Semaphore is a generic privacy layer, meaning it's a building block that you can use to enable privacy and anonymity in your decentralized applications or just applications. And some of the use cases are anonymous voting, whistleblowing, mixers, anonymous authentications and many others. And there are actual proof of concept applications developed which you can find online and also we link some of them at the end of this presentation. So how it works the architecture consists of Smart contracts which is the on chain component and also zero knowledge components which are usually off chain. But this can also be a hybrid, meaning the smart contract part can be off chain as well.
00:06:09.890 - 00:07:49.620, Speaker B: So that can be just off chain registry and the registry is needed to store the state permission and to perform the proof verification while the zero knowledge components are used to generate proofs. And that is the client side of the architecture. And for Semaphore we use custom ZKS Narc and that is zero knowledge construct which basically enables all of this magic to happen. And we won't go into the depths of that in this tutorial, but there are great resources online if you're interested to learn more about the math behind it. So here is a simple flow of how Semaphore works. So firstly the users register, let's say via smart contract. So basically after they register they can now send signals and basically generate valid zero knowledge proofs which they can use for sending signals to the smart contract and the smart contract will verify their proof and if their proof is valid then their signal will be recorded.
00:07:49.620 - 00:09:25.940, Speaker B: So in terms of, let's say again, anonymous voting application first the users will register and they register by creating an anonymous identity which is basically just a hash, random hash, which they send to the smart contract. And the smart contract records that in a merkel tree structure. And then after a successful registration, the users can vote and basically they express their vote by the signal and they generate proof offline and they submit the proof together with the signal to the smart contract. And if everything is valid, then their vote is registered. So the ZKS Narc proves that the user has previously registered in the merkle tree and also that the signal was broadcasted by the user which generated the proof. So here is a little demo of how this looks like. Basically, the users need to register first with their identity commitment and this is their hash that I've mentioned.
00:09:25.940 - 00:10:22.654, Speaker B: And the smart contract stores the user registration in a merkle tree structure. And for this example, we have two users. One of the users, which is Alice, registered previously. And the smart contract recorded that registration as successful and now contains the identity commitment of Alice in the tree. And Bob tries to register with valid identity commitment. And then the smart contract records Bob's registration and adds Bob in the merkel tree as well. So now the tree contains two leaves which are the commitments of Alice and Bob.
00:10:22.654 - 00:12:13.160, Speaker B: And now Bob can vote assuming that he generated and provided a valid zero knowledge proof along with his vote. And in this case we assume everything is valid and his vote is recorded. And now in this example Bob tries to vote again but this is unaccepted because the smart contract can verify and stable double votes because of the cryptographic properties of the information that Bob sends along with his proof. So basically the smart contract is able to determine if this is a double vote or not. Then in this example we see that another user which is previously not registered tries to vote but this would be also unsuccessful because the smart contract can verify that this user is not in the tree but also the user cannot generate a valid proof if he is not a part of the seven four membership tree. Okay? And also the smart contract also prevents double registration. So if Bob tries to register twice with the same identity commitment then he won't be able to do so.
00:12:13.160 - 00:14:09.210, Speaker B: Okay, so that was a short overview of Semaphore and now let's continue with rate limiting nullifier. So this is a construct very similar to Semaphore but it also enables spam protection. And spam protection is especially important in anonymous environments because the strength of Anonymity can also be weakness. So for example let's say in anonymous instant chat application example, it's really important to be able to prevent spam and in anonymous environment it's hard to do that because we cannot find out who the spammers are because their identity is unknown and for that we can use RLM to help solve this issue. And also spam protection is crucial for many other applications because as I said, the users can abuse the anonymity property very easily. So how RLN works is that it provides a protection by two steps. So the first step is raising the barrier for entry in the group and that is achieved by providing a certain form of state by the end users which has a high subjective value and this also allows for hard replicability and preventing civil attacks.
00:14:09.210 - 00:15:43.082, Speaker B: And the second step is the slashing which is enabled on a protocol level by the proof system of the RLN. So also RLN can be implemented in a hybrid architecture the same as Semaphore. So we can use on chain or off chain registry plus off chain proof generation and also some forms of the stake needed for registration can be of a financial form such as tokens or ETH, or it can be of a social form because also the user's identity and public information can be of high value for them. And we can do a social profile linking with ethereum address easily using the interwap service. Arlen also features a custom Zksnarc which verifies that the user is part of the membership tree, but also that the user provides a valid share of their private key. So basically, with each signal they send, the users must provide part of their private key. Basically, they leak a share of their private key.
00:15:43.082 - 00:16:56.578, Speaker B: And if they send more signals than allowed per. Certain threshold then their private key can be reconstructed. So for example, let's say we have Eastern chat app and we have a threshold of one message per second. And if the users send two messages per second, then basically they will send two shares of their private keys and everyone in the group can basically reconstruct their private key and they can remove their stake from application and also remove them from the application entirely. So here is a quick demo on how this works. So in this case, we have chat application and we have an onchain smart contract registry. And here we have, like, two users, and the users stored a membership tree on their end.
00:16:56.578 - 00:18:07.080, Speaker B: This time. So each chat client stores membership tree for the users. And in this scenario, we have a new user, Charlie, trying to register, and he performs the registration by submitting a register message to the RLN. Smart contract with his identity. And here by public key we refer to the identity basically which is a hash generated from their private key. And once they are registered the smart contract emits an event that the Charlie is registered and other network clients listen for this event and register Charlie in their membership tree and also with registration. Charlie also provided stake, let's say financial stake in this situation.
00:18:07.080 - 00:19:07.974, Speaker B: So in this step, Charlie is registered and all of the users in the network have knowledge that Charlie is part of the membership tree. And now Charlie can broadcast messages to the other chat clients. So this is a peer to peer architecture. And he sends messages. And with each message he sends a zero knowledge proof the content of the message the epoch which is basically in this case it can be just a timestamp. And his X and Epsilon shares, which are the shares of this private key and that is needed actually for the other users to verify the zero knowledge proofs correctly. So he sends one message now and that's valid.
00:19:07.974 - 00:19:48.342, Speaker B: All the clients obtained the message and register it as valid. Basically, they send the message. To the upstream chat clients. And if Charlie tries to send another message in the same epoch, then he will leak another part of his private key, which the other chat clients will deem as a spam. And they can. Reconstruct the full private key of Charlie and remove him from the group and obtain his stake. So Alice does just that.
00:19:48.342 - 00:20:54.974, Speaker B: Basically, Alice sends withdrawal signal with Charlie's private key. And the smart contract basically broadcasts the signal to the other users to remove Charlie from their membership tree as well. So now Charlie is removed from the application and his date is stashed by Alice. Okay, so that was overview of the RLM construct. Now we can go over some of the ideas on what can be built with these two constructs which we find that are interesting. And here they are. So we can build anonymous voting for DAOs, we can build fair launch platforms, maybe launch platforms for NFTs and we can use Semaphore for this.
00:20:54.974 - 00:22:28.810, Speaker B: We can also build anonymous publishing platform, private and anonymous instant chat applications using Irln and Interact. We can build like rate limiting website services such as Cloudflare but instead of using CAPTCHAs, the clients would need to generate ZK proofs. And another interesting idea is private communication channel for ETH two validators which allows for spam protection and this is very much needed and RLM can be used for this. These are some of the ideas and we also at the end of this presentation provided specifications for the ideas which you can take a look at and if you're interested we can get in touch for working on that. And we've also provided tools that allow for easy integration with Semaphore and RLM. Basically they obstruct the mats and provide high level abstractions on how to integrate them easily in your application. And also we are working on a browser extension which makes life easier regarding Semaphore and RLM.
00:22:28.810 - 00:23:57.080, Speaker B: Also I've created a tutorial for how to implement an anonymous voting application using Semaphore and it's a bare bone proof of concept application using client server architectures which demonstrate how can you integrate Semaphore in your apps and provide anonymity. And you can find the link here. And we are also working on an RLN tutorial which should be available in the next few days and we'll share the link for that too. So some projects that are in production or to be in production using Seven, Four and RLN are these projects here, you can check them out and here are some resources which we have provided and also you can get in touch with us on Telegram or in the It Global Discord chat. We would love to help you out if you're planning to build some of these applications or have maybe an idea for other applications related to this construct. So that's it from my side. If there are any questions we can get to them.
00:24:04.200 - 00:24:29.980, Speaker A: Awesome, that was great. Like I said, ask questions now if you want to unmute. I noticed one question in the chat which is from Jason, the RLN demo four slide. Do I understand why the Charlie party loses anonymity once they are deemed to be a spammer?
00:24:32.000 - 00:24:52.530, Speaker B: Yeah, basically their identity is previewed. Basically the identity is their stake at this point and basically their private key can be reconstructed which in other terms they lose their identity here.
00:24:55.240 - 00:25:02.310, Speaker C: Got it. If it's just me then I'll ask a follow on question.
00:25:05.800 - 00:25:08.176, Speaker A: The key to that seems to be.
00:25:08.218 - 00:25:21.260, Speaker C: The definition of the epoch because you said if they send a message within the same epoch that this releases, the additional part of the private key. Is that configurable at the definition of the smart contract?
00:25:22.640 - 00:26:11.100, Speaker B: Yeah, so basically it's configurable at the whole app level and it's highly application dependent. But the idea is that you have some threshold which is based per epoch and in the example of a chat app, the epoch can be like 1 second, like every second can be a different epoch. And if you pass that spam threshold, then by the properties of the system, your share would be revealed and that's achieved by the shamir secret sharing part which basically in the background, you can use different polynomial depending on your use case and spam threshold.
00:26:13.520 - 00:26:22.400, Speaker C: That's interesting. I wonder what would happen if they made the spam threshold too long and people weren't conscious of respecting that somehow.
00:26:26.180 - 00:27:02.620, Speaker B: Yeah, that's a good question and that's why it needs to be pre configured. Well, but yeah, it should be generally set in constraints where it's not too low and not too big. And again, it's highly application dependent and also in terms of duplicate messages, the private key is not revealed. Thank you. Thanks a lot.
00:27:02.690 - 00:27:03.790, Speaker C: It's been great.
00:27:09.280 - 00:27:17.436, Speaker A: Okay, a couple of questions here in the chat. Will the slides be available publicly? Will you be able to share?
00:27:17.618 - 00:27:20.130, Speaker B: For sure. For sure, definitely.
00:27:22.100 - 00:28:01.976, Speaker A: And then another question from Barry in the chat. Are there any other constructions that can be built such as a member based on proof of assets with disclosing the full details I e. You need to have more than x tokens, but no member should reveal the exact amount of tokens they have. Yeah, I see with that right. Let me read that question again. Are there any other constructions that can be built such as member based on proofs of assets without disclosing the full details I e. You need to have more than x tokens, but no member should reveal the exact amount of tokens.
00:28:02.008 - 00:28:24.330, Speaker B: They yeah, yeah, definitely. I think UniRep is some similar example which deals with reputation, but definitely such constructs can be built. Great.
00:28:25.580 - 00:29:15.300, Speaker A: Any other questions? Feel free to unmute if you're feeling a question coming on. If not, this workshop was streamed and recorded so it'll be on the ETH online playlist in about 2 hours. And I want to thank Blog, our presenter for getting a lot of good information, I think at a good pace for a zoom call. It was like well constructed and well presented, so appreciate that. And again he said reachable in the discord. So let's keep this conversation going if you have any other further questions or want to explore any of this. So at that, I want to thank everybody for joining.
00:29:15.300 - 00:29:22.500, Speaker A: Good hacking everyone and we'll be in touch on discord.
00:29:23.080 - 00:29:23.468, Speaker C: Thank.
00:29:23.514 - 00:29:25.000, Speaker A: Thanks. Bye.
