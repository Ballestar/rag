00:00:06.090 - 00:00:50.954, Speaker A: Verified bridge. These bridges are like light clients IBC. They're great because they're verified by the chain's underlying validator set. So you're not adding any additional trust assumptions outside of the ones introduced by switching domains inherently. The other great thing is you can kind of pass any type of data between these two domains using this system. Unfortunately, these bridges are really difficult to create because they're heavily dependent on the underlying consensus mechanisms and the underlying chain dynamics. So I can't just take IBC and now use it for my ETH to Avalanche bridge because that's just not how ETH or Avalanche works.
00:00:50.954 - 00:01:25.480, Speaker A: So they have to be kind of developed in a bespoke way. The next kind of bridge is called an externally verified bridge. What's great about these bridges is they're portable between all domains, so they pretty much will work the same regardless of what chains they're connecting. You can pass general data between them. Unfortunately, the concession that you're making when you're using this type of system is that you have introduced a third validator set that isn't necessarily the same as your origin chain validator set or your destination chain validator set. And that can be problematic because.
00:01:29.050 - 00:01:29.366, Speaker B: The.
00:01:29.388 - 00:02:14.194, Speaker A: Security in all of these systems is only as strong as your weakest link. And so when you've added an additional validator set, that's really what's holding the security of all of your payments. Shout out harmony. The next one is locally verified. Bridges These are bridges like atomic swaps, where basically you take some transaction where you want to go from chain A to chain B, and instead of including everybody in the chain and including it as part of the state, you kind of match up to somebody else who's willing to go the opposite way, and you swap funds. This is great because you're not really adding any trust assumptions. Basically, your counterparty will always verify that you did something correctly.
00:02:14.194 - 00:02:34.320, Speaker A: They usually happen through some type of commit and unlock mechanism. The downside is it works the same between all domains. Like you really only need a hash function and a signature for the most part. The downside is you can't really pass complex data around because that doesn't translate easily to a two party system.
00:02:36.930 - 00:03:30.638, Speaker C: Yeah. So Lane covered, externally verified and locally verified. And so you can see that externally verified, it's quite extensible and portable, meaning you can sort of pass any type of data and move it to any type of chain, but it's insecure for reasons that you're trusting another external party with your funds or data. And then she also touched on Locally Verified, which is, I guess, very secure and minimally trustless, but not very extensible. And so we'll see that optimistically verified bridges are somewhere in a middle ground between these two things and can achieve both of these just kind of at a high level. The way that an optimistic bridge works specifically, I guess we'll talk about nomad, is that someone from the user perspective will send a message, and we'll have an off chain actor pretty much attest to that and say, okay, this user sent this message. Let me sign a piece of data which attests to this message.
00:03:30.638 - 00:04:26.290, Speaker C: And so we'll post that on the other chain. And the other chain, before accepting it, will start a fraud window and basically say, okay, within this amount of time, we'll let someone dispute it and submit a fraud proof which will basically tell the protocol, hey, if this attestation was invalid, don't listen to it and disconnect from the messaging channel. The reason why this is more secure, though, is that with something like a multisig, which is an externally verified example, you have basically a K of N honest actor assumption. If you have a three of ten multisig, you need at least eight honest actors. As soon as you have seven, there's now three malicious actors, which is enough to compromise your multisig in an optimistic, verified bridge, then you really only need one honest actor to maintain liveness. As long as there's one honest watcher which is inspecting these attestations from the updater, you can assume that your funds and data are safe.
00:04:28.390 - 00:04:38.900, Speaker A: So does anybody have any questions right now about the different types of bridges before we move on? Yes.
00:04:40.710 - 00:05:37.160, Speaker C: Yeah, sorry, maybe I wasn't too close. What part did I miss? I just have a question about yeah, that's a good point. So, I mean, like, at the moment nomad. For example, a watcher is a permissioned role where it's like a whitelisted role, and if they submit an attestation of fraud, that is enough for the protocol to disconnect. Eventually this will be something that's permissionless it just kind of, like, takes a lot of engineering work to get there. But the way we think about this specific trade off is that at the very worst, if you're a malicious watcher, you can grief the channel, but you can't actually steal funds. And so we think that this is a more desirable trade off than permitting some kind of scenario where you can actually steal user funds.
00:05:37.160 - 00:06:55.882, Speaker C: Are there any other questions? Sorry, could you speak up just a little bit? I know we're having this problem here. Sure, yeah. So it's a lot like sort of the way an optimistic roll up is modeled instead of with an externally verified bridge. Let's say you have a multi SIG. If the threshold number of signers sign off on something, that's kind of what serves as your proof that this event really did happen on the other chain. We kind of flip that model, and we'll have basically one signer attest to something, and we'll post it on the other chain and let a committee of watchers essentially inspect this attestation and say it's either valid or invalid it's. Basically, you give the watchers the power to veto something as opposed to giving someone the power to actually say that it's correct right now, they are whitelisted parties.
00:06:55.882 - 00:07:21.690, Speaker C: So a lot of l one teams want to run their own watchers. A lot of DFI apps, for example, want to run them as well. We want them to be such that the incentives are already aligned, but eventually this will be a permissionless role. So at the moment, it's a whitelisted thing, though. Go ahead. Yeah. So the dispute window for Nomad right now is 30 minutes.
00:07:21.690 - 00:08:07.910, Speaker C: A lot of people ask, why not seven days, I think for optimism or Arbitrum. The reason why it's this long is that the process of actually proving fraud is much longer. There's a lot of transactions you have to submit on Ethereum. And from what I kind of understand at this point, there's also some social coordination aspect for us because it's a whitelisted role and you're just submitting an attestation that fraud happened, we don't need nearly as much time. And so really, the way we parameterize the fraud window is just it's based on the economic cost that it would take to censor the chain. Essentially, if you're a watcher and you need to submit a fraud proof, how much would it cost? If you're trying to censor that fraud transaction.
00:08:11.150 - 00:08:11.706, Speaker B: Cool.
00:08:11.808 - 00:09:19.294, Speaker A: We'll leave more time for questions at the end, but I'm going to keep it moving for now, so hang on to them. Okay, so another important concept that exists in the cross chain world that doesn't exist in the single chain world, the regular DAP world is asynchronous solidity. And basically what I mean by this is the states of the two chains that you're connecting do not know about each other. So if you think of the example of an AMM, well, why does that work as well as it does on Ethereum? It's because when you have a transaction, you have solo read write access to the state of the blockchain, which means that the constant product formula can remain constant because the liquidity is always traded equally. If you're building like a cross chain AMM, that same assumption does not hold. So you can't say that like, oh, I have full access to trade USDC on matic for USDC on optimism. And it happens as soon as I submit my USDC on matic, because the optimism chain has no idea that you wanted to start this transaction in the first place.
00:09:19.294 - 00:10:23.150, Speaker A: So these are the types of things that you have to be aware of when you're developing cross chain applications that you may not have had to think about when you're developing regular DApps. Asynchronous patterns are very common in regular web development. So this is a direction that I think is useful to go in, but it is something that is different than most of the tooling that is available and most of the ideas and development patterns that are commonly used. So now we're going to dive in a little bit to building a zap and kind of what that looks like. So first, what is a Zap like? What does the anatomy look like and the architecture? You have basically a contract on the sending chain and the receiving chain. And then you'll submit your transaction to the source contract on the sending chain, which will then call your bridge. In this case it's Connect that happens to be the one I'm most familiar with and you call Xcall, which then will initiate a cross chain transaction.
00:10:23.150 - 00:11:35.660, Speaker A: This is where the asynchronicity comes in. As that transaction is propagated across to the destination chain by a network of relayers and then validated either by the nomad timeout or somebody else is willing to take on that risk for the timeout, then the action is propagated to the target contract. So, there's also another concept in this cross chain development platform with Connect about authenticated and unauthenticated data. And what that means depends heavily on the optimistic timeouts because we are built on top of nomad, there is latency built in as part of the security mechanism. Again, optimistic systems in general use time as a way to gain security. Like if nobody submits a transaction or disputes that something has happened within a certain window, then you know that that data has been authenticated. Because the assumption is there are enough actors in the system who are incentivized to have correct data that if it is incorrect, somebody will say something.
00:11:35.660 - 00:12:37.280, Speaker A: So in Connect we have this concept of authenticated data and what that really means is like permission calls. So when you're executing a cross chain transaction, you'll want to make sure there are some calls where the data that you're using is completely fungible, like a token transfer. You don't really need that data to be authenticated. However, in contracts that check like message sender, you need to make sure that that data has gone through the fraud proof window so that you know or can assume that then it is authenticated by the time you're acting on it. For example, if I am doing cross chain governance, I really need to make sure that I know that the data that is coming from some chain to the target chain has gone through that fraud proof window. Otherwise it is spoofable by the relayers. It doesn't matter if it's spoofable for transactions that are completely like fungible, again, token transfers, but for something that is more sensitive, you have to make sure you have that extra security.
00:12:37.280 - 00:12:57.990, Speaker A: So yeah, then unpermissioned calls are calls where you can go from the source to our relayers off chain, the target all pretty much immediately as immediate as blockchain gets in the time span of two on chain transactions. Whereas again, permissioned, you have to wait before you propagate the data for it to go through that fraud proof window.
00:12:59.130 - 00:12:59.880, Speaker B: Yes.
00:13:25.660 - 00:13:59.780, Speaker A: Right. So the actual authentication depends a lot on how the target contract is implemented. We'll walk through an example of this in the simplest way is the message sender. So we will pass through the original message sender from the origin source chain. But any relayer, if you don't wait for this data to go through the fraud proof window, could insert any message sender that they want because nobody's challenging on it. It hasn't been submitted as correct by the underlying system. So that's why you have to make sure that you're waiting.
00:14:04.600 - 00:14:44.420, Speaker C: Yeah, I think a good example here is think about a token bridge. So there's like two token bridge contracts and ultimately when you decide to send some assets to another chain that's you calling the token bridge contract, which calls our underlying message layer. And so the message sender ends up being the token bridge router on the sending chain. And so that gets wrapped up in the message. And so basically the token bridge router on the other chain will only accept a message if it's from the other token bridge router. Correct? Yeah.
00:14:55.710 - 00:14:56.460, Speaker B: Yes.
00:14:58.530 - 00:15:33.080, Speaker A: Oh, I'm deaf. You're going to need to yell no. The chains will not know about each other's state. Like they'll only know what data you've passed through.
00:15:35.210 - 00:15:35.766, Speaker B: Cool.
00:15:35.868 - 00:15:36.520, Speaker A: Okay.
00:15:38.410 - 00:15:38.834, Speaker B: Yeah.
00:15:38.892 - 00:16:21.086, Speaker A: So now we're going to walk through some example code. The example, I'm just going to lay it out for you. It's very simple. It's pretty much just like set value on destination chain contract from source chain contract using connect. So here we have some example solidity code for how you would integrate that. The source sol is basically what you would call that's your entry point for this user flow, where you call this with your intended updated value on the origin chain. This will then create the parameters to Xcall, which is the function that will initiate the cross chain transaction.
00:16:21.086 - 00:17:25.486, Speaker A: It's designed to mimic the lower level solidity call pattern, but cross chain X and then you call x call. Once you do that, the relayers in our system will automatically pick up that this transaction has been submitted and simulate it on the destination chain. If it fails, then they know, okay, well this is more likely a permissioned call or explicitly specified that it wants to use the authenticated data flow. And now I'll just wait for that to be fully propagated. Once it's fully propagated, meaning that the message has made it through to the destination chain via the Nomad system and has gone through the fraud proof window, then you can go ahead and call the updated value on the target contract. On the target contract. I'm not sure your name, but if you look closely at this modifier, this only executor modifier, you can see that the origin sender, which is the message sender on the origin chain, is asserted to some specific address.
00:17:25.486 - 00:17:51.090, Speaker A: And same with the again, like if you're doing cross chain governance, I only want the Ave Dao on mainnet to be able to influence parameters for the Ave contracts on polygon. Then I could assert that using something like this only executor modifier that exists on this update value contract. Does anybody have any questions before we dive?
00:17:51.170 - 00:17:51.800, Speaker B: Yeah.
00:17:56.490 - 00:18:33.630, Speaker A: Well, you can pass arbitrary data between chains, but you can't like, if you didn't pass it, the chain won't know about it. So you can read anything that you've passed through, but you're the one who has to initiate that's, right? Yeah, I mean, there's no, like, the chains that's the whole thing with Asynchronously is they are not composable. They don't know about each other. And so you are the one who has to pass that data through?
00:18:36.500 - 00:18:37.250, Speaker B: Yeah.
00:18:44.130 - 00:19:07.670, Speaker A: What do you mean? Can the parameters be changed? Yeah, well, I mean, it's your target, baby. You can do what you want. Yes. Sorry. So the question was, can the parameters be changed on the target contract? So if like, I want to change the admin. Yes, you can. That's completely up to the implementer of the target contract.
00:19:07.670 - 00:19:39.150, Speaker A: These origin sender and origin domain properties are just things that we expose when you make Xcall. So when you create that Xcall contract on the source chain, that information about which chain it's on and who called that function is passed through to the destination domain. So that changes based on who calls it and where it's called from. Whether or not that matches with who the admin is on the target contract is up to the implementer.
00:19:44.030 - 00:19:44.780, Speaker B: Cool.
00:19:45.470 - 00:20:40.458, Speaker A: So there's an example repo here. I'm going to kind of exit this presentation and look at some of the other cool things that you can do with connects. So one of the other things that we're really excited about with our new protocol is the ability to do JS style solidity callbacks. So what does that mean? This actually may be more relevant to your use case, but basically sorry. Okay, so the source contract implements this interface called Icallback. The Icallback interface is right here. And what this means is this is any contract on the source chain that can process return data from some call executed on the destination chain.
00:20:40.458 - 00:21:35.710, Speaker A: So when we execute arbitrary call data, we just use the dot call on your destination domain and then you get back whether or not that was a success and what the return data from that contract call was. If you have defined a callback when you initiate this call, an X call, then the protocol will automatically take the success result and the return data and propagate it back to the origin domain. So this could look like in this example, okay, I want to update some value, but I'm not going to specify a value. Instead, the target contract is going to randomly choose a value. So I call change value that will update the contract value from three to eleven or something. And then I've specified a callback that will emit an event with that new value. And so once that's changed, the information is sent back to the origin domain, where then I can say, oh, great, the random value is eleven.
00:21:35.710 - 00:21:43.700, Speaker A: And so that's kind of what I mean by solidity style callbacks. And you can see is there a question?
00:21:44.630 - 00:21:45.282, Speaker B: No.
00:21:45.416 - 00:22:02.326, Speaker A: Okay. And you can see that here in the source implements the callback interface, and this is the callback function where it decodes the new value that was set from the data and emits this event. Are there any other questions?
00:22:02.428 - 00:22:03.080, Speaker B: Yeah.
00:22:17.710 - 00:23:07.270, Speaker C: Exactly. The fraud window is let's just say that you wanted to build your own app. The fraud window that we have for our core contracts are 30 minutes, but you could technically deploy your own set of core contracts, change the latency and yeah, it's definitely configurable, depending on what level of security you want, like yeah. So we have our own Watcher implementation. This is what we provide to partners and other apps that want to run it. It's just running a docker image. Go ahead.
00:23:35.590 - 00:24:23.710, Speaker A: Right, so your first call would still have succeeded, but the sorry, repeat the question. Yeah, so the question was, if I have a revert on the target contract, what happens to the original transaction? Like, what happens to the flow? Where does it fail and where does it break down? If you have a revert on the target contract, there's a fallback function, so any funds would just get immediately sent to your recovery address. That's prespecified. But if you have also specified this callback interface, the fact that it failed will still get propagated back to the specified callback contract. Are there any other questions?
00:24:27.470 - 00:24:28.220, Speaker B: Cool.
00:24:29.230 - 00:25:10.790, Speaker A: Yeah, so I'll just give you some updates on timelines, then we're finishing up our audits for this protocol, and it should be live. Yes? Yeah, we'll fix it in the middle of a workshop getting called out by my CTO. So unreal. Any other questions?
00:25:14.360 - 00:25:14.772, Speaker B: Cool.
00:25:14.826 - 00:25:40.810, Speaker A: Awesome. Well, I hope you guys learned a little bit about what goes into building a cross chain applications and the things that you should be thinking about. If anybody at this workshop has been contacted by Duck, he's over here in the back, and you guys should probably reach out to him and find him somewhere where it's more okay to talk. Awesome. Well, thanks, guys.
00:25:43.860 - 00:25:44.610, Speaker B: It.
00:25:46.660 - 00:25:47.792, Speaker A: That he called me.
00:25:47.846 - 00:25:48.450, Speaker B: No.
00:25:53.260 - 00:25:58.710, Speaker A: I just like to point out I know.
