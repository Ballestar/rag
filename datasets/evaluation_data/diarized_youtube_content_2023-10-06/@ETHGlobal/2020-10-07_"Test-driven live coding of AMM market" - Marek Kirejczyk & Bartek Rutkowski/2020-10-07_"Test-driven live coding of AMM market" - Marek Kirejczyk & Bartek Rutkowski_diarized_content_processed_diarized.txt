00:00:00.090 - 00:00:25.990, Speaker A: And this is going to be something interesting because we are going to try live coding on our summit. And doing that will be Merrick and Bartek, who will be showing us how you can do better trust driven coding for AMMS using Waffle and Filler. So I'll have them kick it off from here and I'll let them share their talk and their demo. So please welcome Merrick and Bartek.
00:00:27.290 - 00:00:28.226, Speaker B: Hi, Eric.
00:00:28.338 - 00:00:35.302, Speaker C: Hey, thanks for having us. We're just about to share our screen. Off we go. Okay, good.
00:00:35.436 - 00:01:07.646, Speaker B: So, hello everyone. It's absolutely great to be with you here today. And what we're going to do today is we're going to do a live coding of Distributed Exchange in automated Market Maker model. And we're going to do it all in just 15 minutes. So how are we going to do it? Let me perhaps hide that first. So how are we going to do it? We're going to use test driven development. So we're going to write tests before we write our implementation.
00:01:07.646 - 00:01:50.954, Speaker B: And we're going to use ping pong per programming. So we're going to keep switching keyboards as we write the test and the smart contract code. The tooling that we're going to use is typical modern smart contract developer technological stack. So we're talking Waffle that was developed here at Itworks for testing smart contracts. We're talking Biddler for running the test and building the whole thing. We're talking about Etherege JS that was created by Richard Moore for connecting to the test nodes test node. We're talking about type chain created by Chris Kator that gonna give us strong types in our typeshift tests for the smart contracts within Solidity.
00:01:50.954 - 00:02:30.750, Speaker B: And finally we're gonna start with Solidity template that was created by Raul Satran. So what is automated market maker decks, you may ask? Well, the model is really pretty simple. Think about a single contract that represents a market per of ERC 20 token. We're going to call it Plume and Kibi for the purpose of this presentation. And you have really only two operations. One, you can modify liquidity, in our case, just add liquidity. And the way to do that is simply call a function that's going to send some of both of the ERC token and those ERC tokens going to be added to both pools.
00:02:30.750 - 00:02:58.342, Speaker B: For both pools? For both tokens. And of course, they need to be sent in the right proportion. And there is a second function used for trading. And again, it's very straightforward. What it does is it allows you to send a little bit of ERC 20 token and add it to one pool, while the subtracted amount from the second pool goes back to the sender pocket. So off we go.
00:02:58.476 - 00:03:08.034, Speaker C: Okay, so here we are with our 15 minutes. We're going to talk fast, write fast, so pay attention and stay tuned.
00:03:08.162 - 00:03:08.994, Speaker B: Wish us luck.
00:03:09.042 - 00:03:26.060, Speaker C: Wish us luck. So Marek right now is implementing our very first contract, which is going to be a market. It's going to be only the empty hollow of the contract and we're going to go straight to the test. We're going to write the first test just after initiating the.
00:03:26.690 - 00:04:36.562, Speaker B: So when it comes to tester and development, one of the hardest things is always writing the first test. Actually, as you're going to see, I think it's going to take us roughly half of the time to write the very first test. And many times when you're doing that it comes a question what is the simplest test? What is a simple reasonable test that you might write? So in our case and in general when it comes to working with smart contracts, the very first test is usually the one that deploys the smart contracts and checks if they were deployed any CLIs correctly. Now if we would like to write it all at once that would be quite a lot of work and that would be quite a big step. So we're going to start with just one very simple thing which is deploying the contract without even initialization in the very first iteration. Now what Bartek is doing is he's writing this very first test and he already comes time chain into play. So what we're going to do is what Bartic already did is he compiled the smart contract.
00:04:36.562 - 00:05:13.806, Speaker B: So the smart contract is compiled and the types and TypeScript for the smart contract are already generated. In addition to those types, the factories for every single smart contract are generated. In that case, in our case we have a market factory that can deploy the market. Now the market factory has its type and the market has its type. So when we're going to call functions on market we're going to see both suggestions and errors if we try to do something that should not be happening.
00:05:13.908 - 00:05:48.330, Speaker C: Okay, so we have our first already passing which is only deploying the contract and now we need to start implementing the actual functionality of the market. So we're going to pass two tokens to the market which are going to be exchanged on our market and we're already going to create of course we need to import an ERC 20 interface from well known and loved Open Zeppelin. Okay? And probably we're already going to also implement getters for the stored pointers.
00:05:51.090 - 00:05:54.558, Speaker B: A little bit long, a little bit tricky, but that's right.
00:05:54.644 - 00:06:03.802, Speaker C: And we're going to create two variables which are going to store pointers to these two assets that we're going to trade. We're going to make them public.
00:06:03.876 - 00:06:07.470, Speaker B: I guess a little bit copy paste feels a little bit like cheating.
00:06:07.550 - 00:06:08.334, Speaker C: Feels like cheating.
00:06:08.382 - 00:06:10.146, Speaker B: But I think you will forgive us.
00:06:10.248 - 00:06:15.966, Speaker C: Yeah. And let's make it public. All right.
00:06:16.088 - 00:06:43.922, Speaker B: Now let's try run tests. I think we need to reorganize the screen a little bit running tests and we expect them to fail because obviously we're not passing the tokens to the contract. Let's see if that's true. Well, we didn't even need to write a test. You can see when we compile the times, it already show us. Okay, deploy obviously doesn't have the arguments that it's supposed to. So now it's the time to implement token.
00:06:44.006 - 00:06:44.494, Speaker C: That's right.
00:06:44.532 - 00:06:45.918, Speaker B: Let's implement token then.
00:06:46.004 - 00:07:09.554, Speaker C: Yeah. So we're going to implement this one really simply and really in a very straightforward manner. We're going to strike all the necessary pragmas, of course. We're going to our contract, it's going to be a token we're going to import. It's going to be an ERC 20 token, of course. And we're going to import an ERC 20 contract this time. Implementation, not the interface from Open Zeppelin.
00:07:09.602 - 00:07:14.120, Speaker B: Again, good old Open Zeppelin, always there when you need it.
00:07:14.730 - 00:07:36.142, Speaker C: Our good old chump. Yeah, we're going to call them ERC 20 constructor and ERC 20 passing the names. That's right. And for the sake of the demo, we're going to mint all the tokens to the user, to the deployer of the smart contract is going to be Sender. And let's pass him 2000 tokens, for example.
00:07:36.276 - 00:07:39.934, Speaker B: All right, let's make him rich today. Is there anything?
00:07:40.052 - 00:07:42.522, Speaker C: Yes, tokens. You're missing slash tokens.
00:07:42.586 - 00:07:43.360, Speaker B: Oh, yeah.
00:07:44.930 - 00:07:46.640, Speaker C: So that should do.
00:07:51.190 - 00:07:52.578, Speaker B: It'S. A singular money.
00:07:52.664 - 00:07:53.154, Speaker C: That's right.
00:07:53.192 - 00:07:54.018, Speaker B: Good friends.
00:07:54.184 - 00:07:58.360, Speaker C: Okay, so let's build it and it's going to be a proper time to deploy it.
00:08:02.250 - 00:08:28.222, Speaker B: Almost there. Now that we have a token we need to deploy, we're going to deploy two instances of the same token. One that's going to represent Kibi, one that's going to represent Plume. And you probably already know how to do that. You need to use token factory again. Type chain comes very handy. So up we go.
00:08:28.222 - 00:09:13.686, Speaker B: Almost there. Token factory being created. And once we have that, we can create two tokens. Now, note in line 16, we are using Biddler getzigners method that allows us to get instance of the wallet that we're going to use to pay for deployment. And remember about good old Awaits, always there for you waiting. And yeah, we need to pass parameters. So I think we're going to have our very first test passing any second now.
00:09:13.686 - 00:09:44.840, Speaker B: Let's see. Okay, but we're not testing much yet. We kind of deploy the contract. Well, the test didn't fail, so it seems successful. So we're coming to the very first question, to the very basic question. What should the first test look like? And very simple answer is it just should check if the contract would initialize properly. So in our case, all it needs to do is to see if.
00:09:47.290 - 00:09:47.666, Speaker C: Both.
00:09:47.708 - 00:10:05.162, Speaker B: Contract variables were set up. So test is almost done and when we run the test, we expect the test to fail. That's fine, we expect it to fail, but when it does, we can actually jump to actual implementation.
00:10:05.226 - 00:10:28.930, Speaker C: Yeah. So that example might seem trivial, but actually this is a really important principle of the TDD method that you should, and you definitely should write your test for the implementation and that actually implicates many good characteristics in your development practices. And I think that the implementation is already done so we can jump to the test and see it.
00:10:29.080 - 00:10:46.730, Speaker B: And you can see Builder is doing great work for you because when you run tests, it knows if you change the contracts or not. So it's building contracts only when you need to. Boom, the very first test is passing. So off we go to implementing the contract. So let's write a first function. I think you remember from the presentation. We have a supply function.
00:10:46.730 - 00:10:48.794, Speaker B: And the supply function that's right, is.
00:10:48.832 - 00:11:06.370, Speaker C: Going to add liquidity to the contract. And as you can see, the flow is going to look like this for the whole demo and should look like this in the whole process. So you first implement the signature of the function, compile it, generate all the typings and then jump to the test and then continue with the implementations. Yeah.
00:11:06.440 - 00:12:03.618, Speaker B: So now the question is what's our supply function going to do? Well, it's going to add liquidity to our market. So it's going to basically just transfer two tokens to some amount of the two tokens, the Kibian plumes to the Smart contract. How are we going to test it? Very simply, we're just going to call the supply function, send a couple of tokens here and there, and then we're going to check if actually the balance of the Smart contract has changed and is proper. Now, when transferring ERC 20 tokens, always remember about calling the appro function, otherwise, well, it's going to fail and boom, off we go. Almost there. We're adding the first matcher, which checks if the balance is there. A quick trick, a little detail is we have expect to equal it's fine if on the left side.
00:12:03.618 - 00:12:25.980, Speaker B: On the expect side it's a big number and on the right side it's a number of a string because Waffle already does all the conversions on the fly for you. So I think the test is written, we run the test and see if it's going to fail. And if it does, it's good. It means we can start with the implementation. And it is failing. And it is failing for the good reason.
00:12:26.350 - 00:12:53.170, Speaker C: So we're starting with implantation and it's going to be really straightforward. It's going to be just calling the transfer from function two times. So one first time on the X token, we're going to transfer tokens from the message sender from the tokens donor to the address of the market and we're going to pass the X amount. And also we're going to do exactly the same for the Y token. For the Y token, I'm going to just pass Y amount. Okay, here we go.
00:12:53.240 - 00:13:08.866, Speaker B: Let's see if that's going to succeed. So I think we're coding now for almost ten minutes. And if the test is going to succeed, we actually have a working initialized contract with the very first function. I know there is still plenty of things missing, but let's now jump straight.
00:13:08.898 - 00:13:30.240, Speaker C: To the second function and it's going to be a trade function which is going to exchange our assets. So we start with the signature. We're going to pass one argument. You need to type it. Yeah, that's right. And we, for the sake of the simplicity, are just going to pass one argument, which is going to be the amount of tokens we intend to sell. And we will allow only trading one way.
00:13:30.610 - 00:13:59.002, Speaker B: In real solution, you would need to have functions that trade both ways. But again, it's just 15 minutes quick demo. So we're going to simplify a couple of things. I think we're almost there. So we're writing the test for the second, for the very second function out of two. So you see that Bardec has to build a contract because the environment didn't see the types. So that's little annoying thing here.
00:13:59.002 - 00:14:40.680, Speaker B: But it's worth investing this extra couple of seconds into compilation because it really helps writing the test layer. Well, the trick function is really similar to supply function. The only difference is it doesn't just receive the tokens of two types, it receives the tokens of one type and sends the tokens of the second type back. So you can see the test doesn't differ that much. And as you're going to see in a moment, the implementation is not that very different as well. What we do is defy all day long, we're just passing tokens around, right? So that's exactly what we're going to do this time.
00:14:47.770 - 00:15:01.190, Speaker C: So we expect that the exchange is going to gain 100 tokens, 1000 kiwis, so exactly the amount that we pass to the exchange and we expect the balance to drop below the 2000 of the second token.
00:15:01.270 - 00:15:04.810, Speaker B: So the test is failing for the good reason. So we implement.
00:15:04.970 - 00:15:50.780, Speaker C: Yeah, so the implementation goes as follows. First, we transfer the tokens that we intended to sell again to the market contract and then we transfer from the exchange. So the exchange is going to call the transfer function on the token and yeah, what amount is going to be? So we're going to go with something really straightforward and really simple, just because the time isn't our best friend today. And it's going to be a ratio of the token, y, token supply gathered, white token liquidity gathered on the address of this very contract, this market, and it's going to be divided, it's going to be a ratio. So we shall divide it. Yeah. And I know what you're going to say, that not using SafeMap is not how you do things.
00:15:51.470 - 00:16:13.890, Speaker B: That's fine. This is not production demo, this is demo. That shows you how you can code in the hackathon, but also if you have more time, it's a very good way to actually build a production code. Both ways you very quickly get into something that is working and that is something that is very stressful. So boom, guys, we did it. It's already working. It's ERC 20 market.
00:16:13.890 - 00:16:51.386, Speaker B: I think we still have a little extra time, so let's do something extra. There is plenty of details missing, so let's start with good old practice. That every single important method that you call on the blockchain, every single function supposed to emit an informative event so that you can gather the data outside of the blockchain, analyze them. So we're going to start again with a failing test. We're going to assume that supply going to emit an event. We want to see it failing before we actually implement it. I have a hunch that's going to fail and it failed.
00:16:51.386 - 00:16:53.102, Speaker B: And it failed for the right reason.
00:16:53.236 - 00:17:16.566, Speaker C: That's right. So right now we're adding the event to the contract. It's going to be against pretty simple. It's going to be just a supply event with two UN passed that's going to signalize and in the supply function we're going to emit them supply with X amount and Y amount. Okay, so that should the cool thing.
00:17:16.588 - 00:17:42.202, Speaker B: About per programming is if you make a stupid mistake instantly, the second person can see it. We're running the test now and let's see if it's going to be successful. I think it's going to be any second now. Three, two, one and boom. It's working and we still have time. So let's implement something extra. So we don't have any validation, so let's do validation.
00:17:42.202 - 00:18:13.740, Speaker B: In reality, validation code in smart contract oftentimes as much as half of the code or even more. So let's do that. Let's implement at least one require. We're going to do a very simple require for today. We're going to focus on reverting on trade function. If it gets your token, obviously if someone is sending zero tokens to the trade function, that sounds like an error. So we have a code.
00:18:13.740 - 00:18:44.606, Speaker B: Let us see if the test fails and if it fails for the right reason, it should. Let's see it fails and it fails for the right reason. So now we say we require X amount to be bigger than zero and if not, then this is the message we would like to it's a double quote. Double quote automatically fixed. Let's see if the test will pass. Right now I think it's going to pass. What do you think, Barrett?
00:18:44.638 - 00:18:56.870, Speaker C: Yeah, I think that we are doing really good, actually. We could have just now started all adding all these bells and whistles, some fancy formulas for prices, et cetera, but for the reasons I guess we're good.
00:18:56.940 - 00:19:08.842, Speaker B: I think we're good. I know what you think, guys. There's plenty of other things using SiteMark, all the validation and all the stuff. If we only have another 15 minutes, I'm pretty sure we could do at least majority of that.
00:19:08.976 - 00:19:15.930, Speaker C: Yeah, and actually if we did this in only 15 minutes, imagine what you can do in half a day or one day of hackathon.
00:19:16.010 - 00:19:17.598, Speaker B: I think it's a month actually.
00:19:17.764 - 00:19:18.334, Speaker C: Yeah.
00:19:18.452 - 00:20:03.594, Speaker B: So this way or the other, quick recap, what happens? We use waffle. Waffle has all these great markers, the two of them you've seen. So expect to emit with Arcs which allows to easily check if particular events were emitted by smart contract. Expect to revert Whip which allows you to see if the function reverted and reverted for the right reason and there's plenty of others. I'm going to just show you one more which is expect to be called on contract with which allows you to check if your original function that you called also did other calls to other smart contracts and if they were done with proper arguments. And Waffle also have plenty of other features. I would like to raise your attention just to one more which is Mocking.
00:20:03.594 - 00:20:40.138, Speaker B: Mocking allows you to deploy dynamic mock, a smart contract that is a mock smart contract on the chain and dynamically from the smart contract, sorry, dynamically from test allows you to define the behavior of the contract, define the behavior so that you can easily test in isolation. We also use Biddler for compiling and for testing. Additionally we use Biddler EVM which is the fastest test EVM that is available on the market. Biddler has plenty of great features. They have automatic verification on netterscan with single comment you can upload your code.
00:20:40.224 - 00:20:41.574, Speaker C: And get it verified.
00:20:41.702 - 00:21:04.722, Speaker B: And get it verified on netterscan. Very useful for hackathon. It has console log for solidity which allows you to quickly debug things. And I want to tease, there is a big announcement coming next week. So if you do anything related to DeFi or anything related to touching smart contracts that are already deployed on the blockchain, well stay tuned. It's coming.
00:21:04.776 - 00:21:06.290, Speaker C: It's really going to be bigger.
00:21:07.430 - 00:21:27.560, Speaker B: Yeah, the presentation is going to be available online. So we put all the links here and I think we still have a couple minutes for questions. Let us know if you have any.
00:21:29.690 - 00:22:05.330, Speaker A: There we go. I will just going to kickstart this. So thank you so much for this amazing live session. I'm glad that we were able to get something done live without Murphy's laws coming in place. We have a couple of questions coming in so anybody who's listening on the chat, feel free to ask the questions right on the chat itself. But our first question is to your knowledge, is there a good step by step visual debugger that can be used while running tests and if so, what do you recommend people do? And the question also points out that the one for Azure needs Ganache to their knowledge.
00:22:06.230 - 00:22:39.550, Speaker B: Here is the thing, there might be but we are so used to doing test run development that we never really use the bugger. We never actually even use console log. I think maybe occasionally because we write so many tasks that when they fail we almost instantly know what was the reason? What was the reason? So on one hand, we would like to advertise, like it's a really cool way of creating smart contracts. On the other hand, we encourage you to explore because I think some people are doing some interesting things, we just never kind of look into them. Awesome.
00:22:39.700 - 00:22:58.210, Speaker A: So we're waiting for a couple of more questions coming in. I just have to relay them with our live stream, sync and Lag. What other tools do you recommend that people try out if they are interested in just learning or being a better solidity developer?
00:22:58.550 - 00:23:10.710, Speaker B: Well, I think the stack that we presented is very good for actual coding, whether it's on hackathon, on production, if you just want to get into the thing. I think there is remix.
00:23:10.790 - 00:23:11.514, Speaker C: Remix, yeah.
00:23:11.552 - 00:23:35.230, Speaker B: And there is also what's the second one? I think there is now on Ethereum domain, there is some kind of what was it? I don't remember anymore. We can try to find it quickly. So there are great tools online that we encourage you to explore and maybe we will just leave it somewhere on the chat.
00:23:35.570 - 00:23:48.040, Speaker C: Yeah, but these are again like online tools. But when it comes to the tools that you can actually use in your local developer environment, I guess what we've shown is the state of the art for today in our opinion, I guess.
00:23:48.490 - 00:23:58.310, Speaker B: And we encourage to explore Biddler and we encourage to explore Waffle and all the other tools because there's plenty of features there that help in everyday work.
00:23:58.460 - 00:24:12.300, Speaker A: Yeah, great. The last question we have is what do you think is currently missing from the Ethereum Developer Suite right now and what will be your wish list of really great dev tools that would make everything easy for everybody?
00:24:14.750 - 00:24:47.494, Speaker B: Well, I think nothing comes to mind. I think there's a lot of polishing on features that we already have. So for example, tests are running pretty fast now, but I think they could be even faster. I remember originally tests were much, much slower. I think also we were just discussing internally, the watch mode would be interesting. We also thought about some deployment tool.
00:24:47.532 - 00:24:56.522, Speaker C: That will help you organize your deployment scripts, maybe in some declarative manner instead of the imperative one similar to the tools that you see in the DevOps world.
00:24:56.656 - 00:25:04.506, Speaker B: We think deployment got much more complex than it was a year or two years ago. So deployment is potentially a space.
00:25:04.688 - 00:25:05.514, Speaker C: Yeah.
00:25:05.712 - 00:25:06.470, Speaker B: Awesome.
00:25:06.640 - 00:25:18.130, Speaker A: We got one more question on our live chat, which is, to your knowledge, what is the best way to integrate your contract with existing DeFi protocol without directly testing on production?
00:25:19.670 - 00:25:26.926, Speaker B: The answer is you need to wait for big announcement from Vidler that is coming next week. So definitely follow those guys.
00:25:27.048 - 00:25:30.566, Speaker C: Yeah, and definitely this is going to be the answer, but we don't want.
00:25:30.588 - 00:25:45.430, Speaker B: To we don't want to spoil it from Nomic guy. So Nomiklab is the company behind Biddler that is doing a great job developing this whole Biddler solution and also the whole ecosystem around it.
00:25:45.580 - 00:26:03.820, Speaker A: No, that's wonderful. We can't wait for the Biddler Team to also announce this on our Discord. They've been a great helped to eat global over the last few months. So with that, I want to thank both of you for taking us through this Live Demo and giving us time to showcase how you can actually really do a Good.
