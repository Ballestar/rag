00:00:00.250 - 00:00:28.738, Speaker A: Hi everyone, sorry about the wait. My name is Derek Pierre and I'm head of business development at New Cipher. I know you're wondering why a business guy is doing this talk, but I'm also a software developer, so New Cipher lets me do both. I'm here with my colleague Ryan Caruso so you can come check us out throughout the weekend. And I just want to talk to you a little bit about New Cipher today. We are the or. We have a privacy layer for decentralized apps.
00:00:28.738 - 00:01:21.160, Speaker A: So for those of you wanting to build privacy preserving apps, we are the go to solution for that. At least we think so. And so just a bit about us. I mean, a lot of you guys hopefully were at the opening ceremony, so I won't labor on this for too long. But basically we build cryptographic infrastructure for privacy preserving apps and, you know, sort of specific to blockchain. We have our data privacy layer, which is our new Cipher network, which helps with secrets management and dynamic access control, so management of sensitive data. And so I'm sure most of you want to build a D app this weekend, but I'm just going to go through sort of where we fit in this space and why apps tend to need us, especially when they're dealing with sensitive data.
00:01:21.160 - 00:02:05.010, Speaker A: So how would you share data in a scalable, trusted way or trustless way? Sorry. And so usually people start off and they say, well, I'll just use public key. Great. You know, we all know about Asymmetric crypto private public keys. If you are Alice and you have data encrypted for alice has data encrypted for herself under her own public key. If she then wants to share that data with Bob, she has to decrypt it first and then encrypt the data with Bob's public key. And same goes for Charlie if there's multiple recipients and that's all well and good, but if you dig into that a little bit more, you'll see some limitations.
00:02:05.010 - 00:03:06.918, Speaker A: So the first question is, does it scale? So maybe if you just had to encrypt for Bob and Charlie that's sufficient. But if you had to do that for 100 a 1000 10,000 people, that would be very cumbersome. Also think about if each of these people wanted to access that data at different times, alice would have to sit down and do this at a bunch of a variety of times throughout the day. Clearly it just doesn't scale very and feel free to ask questions as I go through here. So the next problem is the ability to do this know, where does that, you know, the most secure thing is probably for Alice to do this on her client. So Alice would decrypt the data locally and then send the data encrypted for Know after she's done. You know, that obviously means that Alice has to be online to do this.
00:03:06.918 - 00:03:47.430, Speaker A: So that's not really convenient. And so usually what happens is that you use a service. So that's like your Google Drive, your Dropbox, et cetera, and you have this service share this data for you. So like share with a link in Google Drive, which I'm sure you guys saw me use earlier. And so now what you're doing is you're really trusting a server with your data because at some point that data is decrypted. So at some point that data is decrypted on the server. You have malicious actors trying to get in and hack into the server, or maybe even malicious actors working for the service, right? So that's not ideal.
00:03:47.430 - 00:04:47.074, Speaker A: And then you're in this sort of decentralized arena or environment, and now you no longer have a centralized service to do this for you. So now maybe you're using IPFS to store your data in a decentralized way. But if you're storing data on an IPFS node, that node is somebody's computer in their basement and server side decryption is just not going to cut it. In this case, the malicious actor is the node, or could be the node itself. So them seeing your data in plain text is obviously not ideal. So then you're like, well shit, what the heck do I do now? And that's where sort of new cipher comes in. So we use something called proxy re encryption and all that is it's just a more scalable form of public key cryptography, so still asymmetric crypto.
00:04:47.074 - 00:05:47.178, Speaker A: But it basically allows this untrusted entity, a proxy, to transform or re key encrypted data from being under a particular public key into being under a different public key. And it does this without that decryption step. Nor does the proxy have to know private keys, right? So is this ciphertext to ciphertext transformation? And the proxy never sees plain text data. So you might be wondering, well that's strange, how the heck does it do that? Well, the only way that proxy can re encrypt the data is by the data owner Alice, creating this thing called a re encryption key. That re encryption key is generated from Alice's private key and the recipient's public key. So you generate one of these per recipient, essentially. And once generated, you can't derive Alice's private key from it.
00:05:47.178 - 00:06:51.934, Speaker A: So Alice will generate this reencryption key, issue it to the proxy, and the proxy says, okay, now that you've given me this reencryption key, it means that, let's say it's a re encryption key for Bob. It means that I can now re encrypt data from being encrypted under Alice's public key into being encrypted under Bob's public key. And again, that's the only thing the proxy can do. The proxy never sees plain text data, and the same can be done for Charlie. So basically you can encrypt data once under your own key and then delegate access to your data by issuing this re encryption key. Now the other part of it is that you might be wondering, well, what about data size, right? Like, what if I have a gig of data that needs to be re encrypted for some reason? Does that take longer than a kilobyte? And that would be a valid question. So what we've done instead is you can encrypt data with a symmetric key and then encrypt the symmetric key with the public key.
00:06:51.934 - 00:07:35.034, Speaker A: So that encrypted symmetric key we call a capsule. So you basically have an encrypted key and then the actual encrypted bulk data. So now, if you think about it, the only thing that needs to be re encrypted is just the capsule. Yeah, the symmetric key is just. So the symmetric key is symmetric key cryptography. It's the same key used for encryption and decryption, right? So you encrypt data with this symmetric key and then you encrypt that symmetric key with your public key. And so now the thing that gets transformed by proxy re encryption is just the capsule.
00:07:35.034 - 00:08:19.820, Speaker A: So now the recipient would then re encrypt the capsule. So now the capsule is encrypted under their public key. They decrypt it to retrieve the symmetric key and then use the symmetric key to decrypt the data, right? Hopefully that makes sense. So it's a little bit of indirection, but what it enables is that it's now a fixed size because the symmetric key is bytes. So whether your data is a kilobyte or a gigabyte, because you're only re encrypting the capsule, not the data itself, you're always re encrypting the same size. And so let's just go through sort of how that would work. So the sender has some bulk data.
00:08:19.820 - 00:08:57.320, Speaker A: That bulk data is encrypted with a symmetric key. The symmetric key is encrypted and you store that data in storage somewhere. Like we're storage agnostic, it doesn't matter where you store the data. And then the sender decides, I want to delegate access to this recipient. So the sender will obtain the recipient's public key to then generate that reencryption key and then issue that reencryption key to the proxy. Now the sender is already granted access, so the sender can go away, doesn't have to be online. That's how we solve the Alice having to be online problem.
00:08:57.320 - 00:09:28.706, Speaker A: And now when the receiver wants to actually access that data, they go to storage, get the data that was encrypted. Obviously, that data wasn't encrypted for them. So they don't have access to it. They just see garbage. They then take the capsule, send that to the proxy. The proxy re encrypts the capsule so that now that capsule is encrypted under the recipient's public key. The recipient then decrypts the capsule, gets a symmetric key, decrypts the data, and no problem.
00:09:28.706 - 00:10:04.510, Speaker A: You could do this over and over again for bulk data chunked, however you decide. And the beautiful thing about proxy re encryption, unlike public key cryptography, is that you could actually revoke as well. Now, just to clarify, what I mean by revoke is that regardless of what crypto scheme or crypto system you're using, you can't revoke access to data that's already been obtained. Right. If I see your address, you can't revoke access to your address. Right. This is more along the lines of if you think about continuous data.
00:10:04.510 - 00:10:54.174, Speaker A: So if you think about things like, let's say you have a heart rate monitor and you're monitoring your heart rate every minute or every second or whatever, what revoke means is that from the point at which the revoke happens, any further data can no longer be accessed. Any data that you access before that, that's fine. You've already seen it, you can't unsee it. But from that point forward, data is no longer going to be re encrypted. So the way that revoke works is that the sender just says, hey, proxy, delete the re encryption key. Now the proxy can't re encrypt for the receiver anymore, and therefore the receiver can't access your data, any data, from now onward. So is that the big benefit of using the proxy, is this revocation of access? Yeah.
00:10:54.174 - 00:11:30.810, Speaker A: So we sort of look at it as there's three main benefits of using proxy re encryption. One is that now Alice can go away and have the proc. Like Alice issues access policies and then can go away. The proxy handles enforcing those access policies. The next part, which I'll talk about in a little bit, is that you can disaggregate the data owner from the data producer because of this access. You can sort of issue access policies but still have data be generated in the backgrounds. And the other part is revocation.
00:11:30.810 - 00:12:07.990, Speaker A: So those are the three big benefits of proxy re encryption. I thought I saw a hand somewhere else. Reencryption key. Yeah. So you're going to see that in a few slides, but great question. You'll see, like, I'll talk about the incentives for the proxies. So what we've done is instead of having one proxy, so if you think about it, if you just had one proxy, you have an availability problem, right? Like if that proxy goes down, your data is now not going to be re encrypted and therefore you're kind of screwed.
00:12:07.990 - 00:13:07.110, Speaker A: So what we've done is we've created a scheme called Umbrell, and Umbrell is a threshold split key reencryption. So that's a lot of words. All it does is that instead of having one reencryption key go to one proxy, you take that one reencryption key and split it into a number of shares, issue each share to a different proxy, and then require a quorum of those proxies to come together to have to re encrypt the data. So to explain that, let's say so you could do something like a three of five threshold where you say, I'm going to split the re encryption key into five shares. Those five shares are going to go to five different proxies. And now I'll require any three of those five proxies to be needed to get the data re encrypted. And so that's how you create this decentralized kind of network of proxies.
00:13:07.110 - 00:13:37.218, Speaker A: Yeah. So that quorum you specify as that policymaker. So you're, Alice, you say, I want to issue this access policy for Bob, and I want to force Bob to have to require three out of five or two out of ten. It doesn't matter. It's tunable. So you could tune it to your threat model. So the quorum is what Bob has to do.
00:13:37.218 - 00:14:03.574, Speaker A: So instead of talking to one proxy to get the capsule re encrypted, bob has to talk to those. Exactly. He has to talk to multiples of them instead. Yeah, any three, not five. You could say five of five. But again, you still have an availability problem. If one of those proxies goes down, your data is not going to get re encrypted.
00:14:03.574 - 00:14:48.610, Speaker A: Right. Because you could only get four out of the five piece one, two, and five of the key. So don't, don't yeah, don't don't think about it as piece, you know, 12345, it's five pieces, and only three are needed. So if you think about it in mathematical terms, if you had two variables, like, you have a system of equations, you needed to figure out how to solve for two variables. But I can create five different equations, and you could take any two of those equations and solve for two variables if it's a two variable equation. So that's sort of the underlying math of it. But that's what we mean by don't think about it as like piece one, piece two.
00:14:48.610 - 00:15:19.330, Speaker A: Each piece only provides information that you can exactly. So the way we do it is with shamiro secret sharing. But instead of sharing a secret, the secret is the re encryption key. And so this M of N threshold. And so we use this key encapsulation mechanism. That's the capsule that I was talking about earlier. And one of the interesting thing is, remember, the proxy is taking in ciphertext, pushing out ciphertext.
00:15:19.330 - 00:16:26.354, Speaker A: So if you think about sort of security with encrypted data, you're not supposed to be able to tell the difference between ciphertext and garbage. So you might be wondering, well, what if a proxy produces garbage, right? Like, if a proxy just returns garbage to Bob? Bob. How would Bob know that the data was correctly re encrypted? So each proxy, when they do a re encryption, produces this cryptographic proof that proves that they've performed the correct re encryption. And so Bob can check that to ensure that the proxy is produced correct data. And so what we've done at New Cipher is we have a decentralized or we're creating a decentralized network of nodes, this decentralized network of proxies, essentially, that perform this re encryption for apps. So it's like a service, a decentralized service that apps can use to facilitate data sharing. And so it's decentralized permissionless and censorship resistant.
00:16:26.354 - 00:17:18.454, Speaker A: All we mean by that is this threshold allows proxies to go down, but you can still use it. It's decentralized in that we, as a company, we only run a subset of the nodes, but the general public can run nodes on our network and provide this reencryption service. So if you have some machine, you can provide the reencryption service if you run our code. And we have an incentive model for that, which I'll talk about in the next few slides, it's extensible in that right now, we provide proxy reencryption as a service. But potentially, you can add shamir secret sharing, like just raw shmir secret sharing as another service on the network that the nodes just run. And one of the cool things is, if you decide to use our API, we've written it as characters. So in typical cryptography, you hear about Alice and Bob.
00:17:18.454 - 00:17:40.394, Speaker A: We added two more characters, and our code is written, as in Alice grant to grant access, or Bob retrieve to get the data. And I'll show you that in a little quick demo, time permitting. So we have network characters. There's Alice and Bob. Alice is typically your data owner. Bob's a recipient. We added two more characters.
00:17:40.394 - 00:18:12.022, Speaker A: One is Enrico. So that's what I mean by proxy. Re encryption allows you to separate the data owner from the data producer. And the way to think about a real good, easy way to think about it is think about if you have a smartwatch on and that smartwatch is producing data for you. You could tell that smartwatch, hey, encrypt data with a particular encryption key. And all that smartwatch does is produces data and encrypts it with that particular encryption key. But it's encrypted for me, and I can decide who I'm Alice.
00:18:12.022 - 00:18:31.550, Speaker A: I can decide who has access to that data. So there's that difference. And then Ursula, who's our character name for the proxy, right? So this is the example of Enrico. Enrico could be like anything. It could be like an IoT device. It could be your car. It doesn't really matter.
00:18:31.550 - 00:19:05.510, Speaker A: All you do is you tell Enrico, encrypt data with a particular key. Enrico doesn't know anything about data sharing, doesn't know who Bob needs to be. All it knows is that it's encrypting data with this key, and Alice decides who has access to that encrypted data. Ursula does the re encryption, as we mentioned earlier. And so also, instead of just having re encryption keys, you can build policies around this. And what do I mean by policies that you can make it things like time based. So I can say, let's say you're working with a contractor.
00:19:05.510 - 00:19:31.938, Speaker A: You're only working with them for a month. You only want to grant re encryption to them for a month. So you could say, here's an expiration on the access policy. Only allow this access policy for a month. And once the month is done, ursula will get rid of the key, no longer reencrypt for the contractor. That's the end of it. Later, down the road we're looking know, you can do things like conditional proxy encryption, so only re encrypt if payment was made.
00:19:31.938 - 00:20:02.878, Speaker A: So, like, you could think of somebody paying you for your data, essentially. And then you could do things like execute this check, this smart contract to see if conditions are perfect for re encryption or some condition has been met. And so you're wondering, how do we trust the Ursula nodes? So, we trust the Ursula nodes two ways. One is we have a token. So all nodes on our network have to stake our token. Our project is a bit different than other projects. We don't use our token for payment.
00:20:02.878 - 00:20:38.310, Speaker A: It's purely for staking. So that stake acts as, like, a security deposit. So if Ursula nodes ever act maliciously or incorrectly re encrypt data, their deposit gets slashed. And so that's that economic incentive for them to act appropriately. We use a proof of stake mechanism. So work is allocated probabilistically based on stake. So if you stake 5% of our nodes of our token sorry.
00:20:38.310 - 00:21:25.480, Speaker A: You probabilistically get 5% of the work in terms of re encryption work. And this zero knowledge proof that I mentioned earlier, bob can send that proof to a smart contract, and that smart contract will slash that Ursula if it's verified that they re encrypted incorrectly. And some of that is based on the key. So if we detect that data is still being re encrypted for a key that's been revoked, it'll get slashed. And so this is sort of just an overall architecture of what it looks like. Alice can issue a policy to the ethereum blockchain. She then sends out these policy arrangements to our network here.
00:21:25.480 - 00:21:54.746, Speaker A: She could then provide Enrico with an encryption key. Enrico produces data of some sort, or Alice can produce the data herself. It's up to her. Bob then gets the data, has to get it re encrypted from the network, and then the Ursulas get paid, essentially. And fees for Ursulas are paid in ETH, not in new. Right. So, the new work token is only for staking summerly users.
00:21:54.746 - 00:22:36.010, Speaker A: You'll notice a lot of medical data. So if you could think of something like patient control, medical records let's say you're a patient. You go to see your doctor. You can selectively grant access to your doctor for that visit or for some period of time. If you decide you want to change doctors for some reason, you can revoke access to that doctor and then grant access to your new doctor. There's this concept of data marketplaces like Datum, where you can sell your data to marketers or advertisers. Like, for instance, Facebook makes money off of you right now, but you could decide, I want to sell my browsing history to some advertiser for some reason, because I fit their demographic.
00:22:36.010 - 00:23:05.890, Speaker A: I could say, okay, if you pay me, I'll then selectively grant you access to my data sharing economy. You could think of, like, a decentralized airbnb where if you pay to rent the property, then that data gets selectively re encrypted for you. Because now that you've paid, you deserve to get information on the property. So I just want to show you a quick demo. We're on public testnet on Gorely. So we have a network of nodes. So this is nodes on our network.
00:23:05.890 - 00:23:38.900, Speaker A: I don't know if you guys can see that. We have about 91 active nodes right now, all staking new. These are a bunch of the nodes here. This is one of them. One interestingly that I run. And so what I'm going to do is I'm going to use this network to reencrypt some data. So what I did beforehand, just to save time on this demo, I have a gorlif node running here.
00:23:38.900 - 00:23:58.120, Speaker A: This is Alice. Alice has granted access to a Bob using this command. To save time, I executed the command beforehand. So what Alice is doing here is she's granting access. This is how she learns about the network. This is Bob's signing key. That's how you prove Bob is who he says he is.
00:23:58.120 - 00:24:21.434, Speaker A: This is Bob's public key, his encrypting key. This is a label. So what labels are, are logical groupings of data. So you could say things like a label could be like a folder or my health data or my work data. For instance. I set an expiration on it for two days from now. This is the threshold.
00:24:21.434 - 00:25:07.722, Speaker A: I just use one of one for demo purposes. This is just to connect to the network. And this is me specifying the payment I'm going to make to Ursula's that controlled this policy. And so Alice basically issued this policy and now this policy has an associated encrypting key here. So now I can say and when I say our stuff is written as characters, you'll see what I mean here? So this is new cipher commands. I have Enrico commands here. By the way, our quote is written in Python.
00:25:07.722 - 00:25:57.200, Speaker A: This is just a CLI to the Python. So I can say Enrico encrypt. I can specify a policy encrypting key for him to use, which was the key that Alice just specified. And I can provide a message says ETH is fun, right? So that produced this message kit. So this message kit is that capsule and data that's been encrypted, right? So that data would typically be stored somewhere on some storage for demo purposes. It's not. And so now, again, written as characters, you can see what Bob can do.
00:25:57.200 - 00:26:46.270, Speaker A: So Bob can do a few things. I can say bob retrieve. In other words, this is Bob to go get the data, re encrypted and decrypted himself. So what do I need? I need a label, which I had as ETH wadalu. I believe I need the policy encrypting key which is here. I need Alice's verifying key. That's to prove that Alice is who she says she here, whoops obviously I need to provide the message kit that needs to be re encrypted.
00:26:46.270 - 00:27:37.070, Speaker A: Right. Because Bob can actually read that. I need to specify the teacher on the network, and I'll put debug so you can see what's going on. Exactly. So Enrico encrypted for that policy key that I specified that Alice created based on the label. And so that data is encrypted under that key. And now what Bob is doing, he's going to take that data, get it re encrypted, get the capsule re encrypted by the proxy, and so that now he can decrypt it himself.
00:27:37.070 - 00:27:50.830, Speaker A: Exactly. He's gonna get the symmetric key. Exactly. The capsule is going to get re encrypted. Symmetric key is going to be obtained symmetric key to get the data. Right. So what Bob's doing here is just learning about the network.
00:27:50.830 - 00:28:32.922, Speaker A: We have sort of a slow learn of the network right now, but that's going to be improved by Bob number two. So Bob number two has to have Bob's private key to be able to get it right. Because remember, the data gets reencrypted for Bob's public key. So Bob needs a private key to then decrypt the data. Right. So this is the data that's been re encrypted and decrypted by Bob's private key. It's in base 64, because data can be in byte.
00:28:32.922 - 00:29:00.280, Speaker A: Right. If I show you that base 64 decode and that's that data, right? If so, yeah. So feel free to use our stuff. Check us out. We're on the Efuadalu discord. To be honest, our devs are on our own discord. I'll show the link in a second.
00:29:00.280 - 00:29:28.740, Speaker A: So you can talk to our devs there if you have any questions. We have a bounty here for $2,500, and that can be split across teams. Potentially, it doesn't have to be one person, but just for cool use cases and cool implementations. And here are some cool links to check out. We have like a hackathon repo for you to get caught up on proxy re encryption and some of these demos. And our Docs Docs Newcypher.com has a lot more information on there.
00:29:28.740 - 00:29:52.540, Speaker A: Yeah. Maybe I'll take a few questions before we stop, just because we started a bit later. Yeah. Could you just reiterate those three highlights? Yeah. So, disappearing Alice, we like to call it, instead of doing all the key management stuff with your AWS, you can dump the data and then go offline. Exactly. You can dump the data.
00:29:52.540 - 00:30:25.518, Speaker A: You can even grant access before you dump the data because you know what key you're going to use. So you can issue an access policy and then Alice can issue an access policy. Go away. She can configure Enrico to continue to produce data and she can go away. Exactly. So that decoupling between the data owner who's Alice and the data producer who's Enrico, it's kind of like Alice can go away as well and have Enrico in crypt. But that's what we called Enrico.
00:30:25.518 - 00:31:20.834, Speaker A: And then the last one is replication. We have a really cool article sorry, when you say replication, what do you mean by revocation? Yeah, we have a really cool article outlying those three things on our blog. If you check it out. Justin wrote it. He likes to call it disappearing Alice. Enrico. And so, remember, in this case, alice is encrypting data once and then granting access to it, right? So instead of having to encrypt data for each individual person that she's sharing with, she only encrypts the data once, issues an access policy to the proxy.
00:31:20.834 - 00:31:53.262, Speaker A: And then all the other data owners just end up getting the data re encrypted without Alice having to do anything. Yeah, she re encrypts per person. Yeah, per recipient. But you remember and again, you're only re encrypting that capsule. Right, but that's not something that Alice has to worry about. That's why Alice can go away and the capsule is don't handle remember, in that process, we don't handle private keys at all. Right.
00:31:53.262 - 00:32:33.360, Speaker A: Like, Alice only issues a re encryption key, so the proxy never sees her private key. Bob never sends his private key to the proxy either. Bob gets back data that's encrypted for his public key. So the management of the private key is up to you and your yeah, I mean, yeah, that's what you want for a private key, right? Like only Alice and Bob. Alice and Bob should always have control over their own private key and never expose it to any external entity. Yeah, we started a bit late, but yeah, maybe one more question. Yeah.
00:32:33.360 - 00:33:10.162, Speaker A: Let's say Alice. Yeah. And then she just wants right? Yeah. Yeah. So that's where Alice has to think about the labels, right? Because label, you're granting access per label, essentially. So what she could do is, if she wants a per song granularity, each song should be its own label. And then she creates policies per song.
00:33:10.162 - 00:33:30.702, Speaker A: Exactly. Yeah, exactly. So you could think of just think about it as like a folder, right? If you do the label as the folder, then everything in the folder is accessible. If you do it per file, then only each file. Right. So Ryan and I are around. Feel free to come to our table and ask us more questions if you like.
00:33:30.702 - 00:33:31.500, Speaker A: And thanks, guys.
