00:00:04.890 - 00:00:14.766, Speaker A: So next up, I want to invite Bobin to talk about polygonmiden. So, Bobin, whenever you're ready, feel free to get started. Welcome.
00:00:14.948 - 00:00:43.980, Speaker B: Thank you, Kartik. And hello everyone. Very excited to be presenting amongst such brilliant people and talk about polygonmiden. Let me just share my screen. All right? I hope everybody can see the presentation. Everything is good. All right, so before I explain what polygonmiden is, let me give you guys a bit of history.
00:00:43.980 - 00:01:32.086, Speaker B: So I've actually started working with Zero Knowledge tech and Stark specifically in spring of 2019. And the first thing I did was build this Gen Stark library, which was a Stark prover for aiming to be able to generate proofs for kind of any kind of computations. And once I built it, I realized that it's extremely difficult for regular developers to just pick up and start using something like this. And I can spend a few months trying to figure out how to make it easier and try to develop it first. Kind of that means specific languages that would make it very simple to create Stark proofs. But even that turned out to be quite complicated. So the next thing I try to do is I start to think about Stark based virtual machines.
00:01:32.086 - 00:02:17.106, Speaker B: And I actually made this E Three research post early in February 2020 describing kind of my thoughts on it. And at the time, I actually didn't think it was going to be very powerful machine. I didn't think it was going to be Turing complete. But as I started working on it, I realized that there are a lot of things that we can unlock and there is actually a way to build a practical start based virtual machine. And a few months later, I built the first version of and improved it over the following months. And this VM is actually one of the foundations for polygonmyden. The other foundation of polygonmiden is Winterfell, which after I worked on VM, I joined Novi and as part of being there, built this Winterfell.
00:02:17.106 - 00:03:00.774, Speaker B: Stark hoover it's in a way very similar to Genstark, but it is much, much more performant, modular and up to date implementation of Stark protocol. And now polygon midnvm is kind of a combination of Dstaf, VM and Winterfell. And in a way, it is a culmination of what I've been working on for the last two years, so to say. So I'm very excited to kind of talk about it. So what exactly is polygonmiden? Polygonmiden is general purpose Stark based ZK roll up. And I know a lot of people here are already familiar with all of these terms. But for those who are not, let's go through these terms one by one and start with a ZK roll up.
00:03:00.774 - 00:04:06.090, Speaker B: So what is a ZK roll up? In a ZK roll up we have users, operators, and then we have an on chain contract which is on Ethereum main chain. And the idea is that users send transactions to operators, and there are many users and operators aggregate those transactions into batches and then they submit kind of the state change or whatever has changed in the internal state of the ledger that the operators are managing. Together with the ZK proof that they verified all of those transactions to the on chain contract. Which verifies that. So why do we care about this type of setup? And one of the answers is that it gives us lower fees because we can compress a lot of things using ZK proofs and there are other reasons why, for example, we don't have to include every single transaction. If some transactions happen between the times that we verify ZK proofs then those transactions can actually be completely absent from the kind of the state change that gets pushed into the main net. So we can get up to actually over 100 x reduction in fees as compared to Ethereum.
00:04:06.090 - 00:04:59.706, Speaker B: And the other thing that is important is we can get this without sacrificing security. So in the ideal scenario, the ZK roll up is just as secure as Ethereum itself because it inherits security from Ethereum. There is no way for operators to submit invalid transactions or submit a state transition in AZK proof for something that is not really valid. So if they didn't have a transaction to verify, they couldn't make it up. And the other exciting part is that roll ups can be very high throughput. And the reason for this is that unlike let's say in a decentralized ledger of the way Ethereum is, the operators can be fairly heavy and they can have very sophisticated hardware to process a lot of transactions. And we only need to really to have one operator that is honest for the roll up to work.
00:04:59.706 - 00:05:45.018, Speaker B: And even if the single operator, for whatever reason decides not to be honest, the users can still go directly to the on chain contract to reclaim their funds. So we of course want to have the roll up to be decentralized. But this kind of setup allows us to have much more flexibility and experiment with different consensus models, execution models and structures of the ledger and achieve this high throughput lower fees while still maintaining the same level of security. And that flexibility portion is something that is really really exciting to me personally. Okay, so this is a very high level overview. I'm sure most of the people here already knew what a Z roll up is. But just to kind of set context okay, so let's talk about the next term Stark based.
00:05:45.018 - 00:06:18.514, Speaker B: So before we talk about what a Stark based means, we need to talk about proofs of computational integrity and we talk about this as ZK tag. But actually the thing that we really care about is this proving that the computation was done correctly. ZK in many ways is incidental to a roll up. Although it is a useful property if we want to achieve privacy as well. So in terms of proofs of computational integrity, usually there are two parties. There is the prover and the verifier. And Approver wants to say that they ran some kind of computation and they have gotten some kind of result.
00:06:18.514 - 00:07:12.870, Speaker B: In the context of a roll up, the computation is verifying all the transactions that they want to put into a batch and they want the prover to accept that they've computed the result correctly without the verifier having to rerun those computations themselves. And obviously we want to be in a setting where we don't want to trust the prover on their word. So the verifier cannot just accept the proverbs result. But what we do is the prover can send this zero knowledge proof to the verifier. And the verifier, by examining the proof, can be convinced that the prover has run the computation and received the claim result without having to do this computation themselves. And it's very important in our context that the proofs are small and fast to verify. So overall, in terms of proofs of computational integrity, there are two large families, Starks and Snarks.
00:07:12.870 - 00:07:48.500, Speaker B: And Starks stands for Scalable transparent arguments of knowledge. And they were developed by brilliant people at Starkware. And there are a lot of different Snarks developed by many different teams. And they stand for succinct non interactive arguments of knowledge. But rather than saying like there are two different families, there's actually a lot of overlap between them. So a non interactive Stark is actually also a Snark and scalable transparent Snark is also a Stark. So in our context, we're actually working with non interactive Starks, which means also that our system is a Snark as well.
00:07:48.500 - 00:08:32.826, Speaker B: Right? There are a few advantages and reasons why I think Starks are a very good choice for a roll up type system. And I'm going to go through them in the next slide. So Stark advantages, as I mentioned or comes from the name Starks, are transparent and scalable. So means there is no trusted setup. We don't need to worry about toxic waste or trusted setup being compromised and potentially somebody one of the operators or provers generating fake proofs. So that's a very good fundamental property to have. The other advantage of Starks is that they use very lean cryptography.
00:08:32.826 - 00:09:16.618, Speaker B: And what I mean by this is that they rely only on collision resistant Hash functions and that makes them post quantum secure. And in many ways it's a future proof technology. They're very flexible. And here I'm getting a little bit too technical, but we had the talk from Polygon Zero where they talked about selection of a field and the same applies to starts as well. You can choose a specific field which is very performant and allows you to generate proofs faster. You can also dynamically kind of trade off between prover time and proof size. So you can increase prover time while reducing proof size and play with different security levels.
00:09:16.618 - 00:09:58.522, Speaker B: Without having to modify anything kind of in the proving system, you can do it. You don't need to choose a different elliptic curve, you don't need to redo your circuits, you can kind of dynamically trade off these properties and tailor it to a specific use case. And then in terms of performance, this is, I think, one of the big advantages of Starks as well. First, the verification is very light in terms of like real world performance. Most of the proofs that for any practical computation are just single digit milliseconds to verify. And the description of the computation is succinct as well, because there is no preprocessing that needs to happen. And then on the prover side, the proof generation is also very fast.
00:09:58.522 - 00:11:01.854, Speaker B: So a few benchmarks on the current implementation of midnvm is that right now on a single CPU core you can verify, you can execute about ten k instructions per second, which is 10 Hz. If you think back to Daniel's talk a little bit earlier, where he mentioned that it took like multiple seconds for a single instruction to be executed on tiny random, this is already many orders of magnetic improvement. But it gets better because we can paralyze very easily. And even with the current implementation, we can get up to 400 Hz if we spread the proof generation across multiple CPUs. And we believe that with some additional work, we can improve this significantly in the future. And then if we go to GPUs and FPGAs in the future where there is hardware acceleration, this is going to be in a megahertz range and probably very fast. For all practical purposes, Starks are not perfect.
00:11:01.854 - 00:11:38.490, Speaker B: There are some disadvantages to them. And the biggest one is the proof size. Usually proofs are in dozens of kilobytes, so just a few benchmarks for miten VM. In its current form, if you execute 1000 cycles, the proof size is about 35. For a million cycles, it's around 80. If we need to grow more, it grows, but it grows logarithmically. So it's not going to get too big, it's probably not going to exceed 150 or 200 most for pretty much any practical computation.
00:11:38.490 - 00:12:22.870, Speaker B: This kind of like the proof sizes lead to relatively large gas cost when we try to verify proofs on ethereum. So between three and 5 million gas for verifying a Stark proof, probably closer to 5 million on ethereum. But once EIP 4480 comes through, we should see that gas cost drop to hopefully under a million. But this will need to be verified. But again, because the actual proof is very fast to verify it's, just the proofs are large. Once the cold data costs get reduced, the cost of verifying Stark proof will get reduced significantly as well. The other thing is recursion, and it is possible to do recursive Starks.
00:12:22.870 - 00:12:58.514, Speaker B: They haven't been demonstrated yet, but especially in a context VM, this becomes like having a virtual machine. This becomes a real possibility to build recursive starts proof as well. And this is something that we will investigate on our end too. Now let's talk about general purpose. So if we think about ZK rollup specifically, there are two ways to think about them. So there is a specialized type of ZK rollup which handles a specific use case like payments and exchanges, NFTs and so forth. And then there are general purpose ZK roll ups which allow you to write arbitrary smart contracts.
00:12:58.514 - 00:14:00.458, Speaker B: And this is the more exciting type of a roll up which developers can build their own logics smart contracts that we can think about and have the full power of ethereum type environment within a roll up. And building a general purpose ZK roll up requires to have or at least you need to have a zero knowledge virtual machine. So in the context of polygonmiden, well, let me talk about first about what the zero knowledge virtual machine is. So zero knowledge virtual machine is you can think about as a virtual machine that takes some initial state and says set of programs executes them and gives you some final state, but it also gives you a proof that it has executed everything correctly. And this is the crucial part where you can execute many different programs on the CM. They don't have to be all the same program, they could be different programs and you'll get a single proof that says all the programs have been executed correctly. And one other distinction is that you can provide this witness data.
00:14:00.458 - 00:15:01.820, Speaker B: For example, in the blockchain context, this could be signatures that once the VM has verified them, you don't really need to include them into your proof that goes onto your team. So you can basically discard this witness data or it gets discarded and that allows you to significantly compress things that need to go onto the main chain. In the context of polygonmiden we have Midnvm, which as I mentioned is based off of Tstaf VM. And let me give you a few highlights about the VM itself and where we're going with it. So one of the main focuses that we want to have is to have the VM be developer friendly and by that I mean we want it to be as close as a typical virtual machine that you might have encountered outside of zero knowledge or cryptographic context, so that you don't really need to learn anything about cryptography. So for example, it's going to be a simple stack based machine. This is what polygonmiden is right now.
00:15:01.820 - 00:15:58.890, Speaker B: It is going to support natively 32 bit integer arithmetic, so no need to think about field elements or understand finite fields or anything of that sort. You can just work with 32 bit integers. It will have read, write memory, so very easy to kind of learn how to use it. It will have native exception handling, which is very important in the context of smart contracts where one contract can call another contract and the other contract can fail. So we want to make sure that even if there is a failure somewhere, we can still prove that the original smart contract that called the field contract executed correctly. And we are planning to build a very extensive standard library which will support all kinds of goodies that developers for smart contracts in DeFi might be interested in. The other important thing that I want to mention is that we want to make Mitanvm a multi language.
00:15:58.890 - 00:17:19.434, Speaker B: Solidity will be the first class citizen in this VM, but we also want to make sure we can support other languages such as for example, Move or other languages that people would want to compile into Mitvm assembly. And one of the other design goals, and it is kind of related to multilingual support is that we want to make the VM safe and actually safer than EVM itself. So we will not allow dynamic code targets and you still can compile Solidity into this and still will work fine. But underneath the VM will be safer than the EVM itself, which will also make bugs potentially much much more difficult, or putting bugs into your smart contract and then taking some hints from Rust programming language, all operations in the VM are safe by default. And there is also privacy focus, kind of like we want to build in some privacy features into the VM, but this is not the focus right now. But we do want to make sure that the groundwork is there where we want to support both data and functional privacy in the future so that the VM can execute kind of privacy preserving smart contracts. And just to kind of show this diagram of how we think about multi language so Solidity, we can be compiled into intermediate representation right now.
00:17:19.434 - 00:17:54.690, Speaker B: And then we'll have this Yule to MIDN transpiler which will transpile Yule into MIDN assembly language. And then the MIDN assembly language is the native language of Midland Em and then other languages will be able to compile into MIDN assembly as well. So I talked a lot about where we want to go. Now let me give you a little bit of a roadmap of how we will get there. And right now, basically last month we released the version 0.1 of Mitenvm. It already has kind of stack manipulation, arithmetic operations and basic control flow implemented.
00:17:54.690 - 00:18:53.090, Speaker B: In a few months from now we will be releasing the version 0.2 which will have memory native support for 32 bit integers. We'll have procedures and we'll keep building on top of it over the next year to add such things as storage and support for things that are important for EDM compatibility. And our plan is within a little over a year to get to a point where you can compile solidity into mitan assembly and then in parallel toward the kind of late Q Two of next year, we will start building the actual roll up around the VM as well, starting with initial couple of alphas. And then hopefully by Q One of 2023, we'll have data in production to experiment. This is a fairly aggressive timeline, but we'll do our best to make it happen and then to wrap up. Just wanted to talk a little bit about kind of some of the values that we have with Polygonmiden.
00:18:53.090 - 00:19:42.086, Speaker B: The first one is we do want this to be a community driven and fully open source project. So the source code for even the early version of Midnvian is fully available right now. We do want to collaborate with anybody who is interested in building on Polygonmiden or even just using VM for whatever purposes they want to have. So please check out the repo and feel free to start using it and let us know if there are any features that are missing. So we really want to make it so that we built it with the inputs from the community. We will be releasing the initial draft of MIDN assembly probably within a week or so, and feedback on that will be very helpful. And the other set of kind of dialysis we do want to build a fully decentralized and censorship resistant roll up.
00:19:42.086 - 00:20:08.800, Speaker B: So not to have a single operator, but to have kind of a network that is fully in alignment with kind of Web three Ethos. And here is the link to the repo. So check it out and let us know if you would like to use it in some way even before it's ready. That would be very helpful. With that I'll open up to questions if there are any.
00:20:10.610 - 00:20:36.838, Speaker A: Thank you so much Bob, and this was an incredible overview on all these improvements that you've kind of made with the help of your team. We don't have any questions specifically to what you've talked about, it's just been comments from like this is incredible and some of these things are just amazing that people are enjoying. If something comes up, I will happily share them on the chat here to you in the zoom, but no specific questions about definitely.
00:20:37.004 - 00:20:43.460, Speaker B: And if somebody thinks of something else later on, feel free to drop me a line on Twitter or anywhere else. Perfect.
