00:00:08.010 - 00:00:40.022, Speaker A: Hello. Welcome to Learn Noir in an afternoon or get your money back. I'm Jose Petersoza. I'm a Devrel engineer at Aztec Labs. And today we're going to be talking about Noir, dedicated, developed by Aztec Labs. We're going to be talking a little bit about ZK. What is ZK? What can you do with ZK? We'll also talk a little bit about Noir.
00:00:40.022 - 00:01:42.400, Speaker A: Why are we doing this? Why is Noir needed? What can you do with Noir that you can't do with other Zkdsls? Then we're going to present our project, our little project for today. And finally we're going to hack it and just start hacking stuff. So we know that zero knowledge proofs are really powerful. You can do stuff that you can't do with any other tech, basically. But usually with great power come univarial polynomial commitments. And this is kind of the problem, because if you don't get the math behind ZK, usually you're just left in the dark. And basically the purpose of Noir is to make this go away and just abstract all the complexities from the mathematical part of the ZK space.
00:01:42.400 - 00:02:19.594, Speaker A: So we need this usable, universal ZK domain specific language. And yeah, we like rust. Rust is cool. So, yeah, we just went and copied the syntax from Rust. And so if you try to find the difference between the two programs, usually you're going to have very bad time. And so this is just an example. If you try to spot the difference between these two snippets, yeah, you're not going to find them.
00:02:19.594 - 00:02:54.542, Speaker A: One of them is trust, the other one is Noir. And as you can see, there are little differences. In this case, there are zero differences. We want you to write code instead of writing circuits. So if you've used other tkdsls in the past, maybe you've written like, circuits on a piece of paper and then connect the wires. And that's basically how you write the circuit. We believe that the best paradigm is the one that we are used to, which is just writing code, like just writing actual programs.
00:02:54.542 - 00:03:44.222, Speaker A: Like you write solidity or JavaScript or rest. And this also allows you for very experienced developers to just use Noir to abstract their own stuff. So maybe they just want a very easy way to use ECDSA signature verification, for example. So maybe they don't want to write their own stuff and just use Noir modules or external libraries. While this is still easy for beginners to start using ZK. So today we're going to be building a little project. I'm going to show you next what it is, and we're going to divide this in like three chapters.
00:03:44.222 - 00:04:31.860, Speaker A: The first one is literally about Noir and especially Nargo and Noir. How can you simply get started with a new Noir project? I'm going to be talking about the syntax of Noir. I'm going to be writing tests. Actually, they're built in with Nargo. But I'm going to show you how to make them fail and stuff. And finally what we all care about, which is proofs, actually generating the proofs and verify them. We're going to also be integrating some libraries, namely the standard library that you will find many of the built ins in and other libraries, like external libraries built by the community or libraries that you want to build yourself.
00:04:31.860 - 00:05:07.534, Speaker A: And finally we're going to be looking at the browser usage. It's a bit of a beta, but you can still do it and you can use it in your DAP. And I'm going to show you how we're going to be leaving behind the verification of proofs on chain. I'm going to show you basically how to generate the contract. But from then on, I'm assuming that you know how to deploy a contract with Foundry or truffle is not around anymore, unfortunately. So that's it. I'm just rambling here.
00:05:07.534 - 00:05:42.946, Speaker A: So it should get started finally. Yeah, you should check out the workshop resources as well. Special the workshop resources you're going to have repo there with the stuff that we're going to be using for today. So I highly recommend you to scan this QR code. Also the noir docs. This is basically the documentation that the Noir team has been putting on and it should give you most of the answers you're looking for. And finally, my link tree.
00:05:42.946 - 00:06:13.826, Speaker A: It's not linktree, I think it's limo. Yeah, it's a limo thing. You can check out all my Twitter handle and telegram and stuff so you can talk with me and ask questions if you want to. And so that's it. Let's start hacking basically. So I'm going to pull up my Vs code editor here. As you can see, this is already in the workshop resources that I just mentioned to you.
00:06:13.826 - 00:06:56.622, Speaker A: And if you check out the README, you're going to find this Noirapp tool. So Noirapp is if you used to CLI tools like Rust app or Foundry app, which is actually here, it's basically a CLI tool that will install Nargo. And if you used to Rust, you also know Cargo, which is kind of an NPM thing that will install like package. It's a version manager, a package manager, and also runner and run scripts and stuff. So that's basically what Nargo does. So to install Nuarap, you just go and install it. Like you can just copy this, you can trust me bro, and just copy this thing.
00:06:56.622 - 00:07:44.510, Speaker A: It will install NARAP for you. It's going to take a little bit longer for you, so just pause the video and wait for it to complete. It says that you should just run source and just source the Bash file or just start a new Terminal session. And then finally you should have NARAB around and you can check exactly what does it do and you can get the options for it. And so it's pretty powerful. You can install specific versions and branches, PR schemes and stuff in this case, even though I think the latest version of Nargo is zero point ten, let's just go ahead and install like a specific version for that. So I'm going to install like version zero point eleven.
00:07:44.510 - 00:08:33.540, Speaker A: So you just go and install that and it will download and install for you. I guess that's the one I had already because it was really fast. And then you can just go and run Nargo version and finally you should have here your version. Another thing that you could probably find useful is the Vs code plugin. So if you use Vs code you can just go here extensions and basically say just write Noir and you're going to get here Noir Language support. So yeah, it's a very alpha version but it's really cool and it can run like it has some code lengths that can be useful for you to run. You also get like syntax highlighting which is always cool.
00:08:33.540 - 00:09:15.760, Speaker A: So with Nargo you can basically do all kinds of really cool stuff like running your code and installing package and starting a new project and that's basically what you're going to be doing. So let's just go run Nargo help to see what can we do with Nargo. In this case we're going to just use the new command and just call it like Noir project. And yeah, it will generate a new project here and you have two files. Basically nargo TUML is basically the source of your project. You can define whether it's a library or a binary. So yeah, also define dependencies and workspaces here.
00:09:15.760 - 00:09:56.090, Speaker A: For now we're just going to leave it as it is. Don't change it. Also Nor generates a main Nor file for you which basically has a very basic circuit. You can test and run and do whatever you want and so yeah, let's just go over it and see how can you run your own. So let's start with the FN syntax, which means function basically. And you need to have a main function that's part of it because you're running the main file if you have other files. Yeah, you can have modules and stuff.
00:09:56.090 - 00:10:41.180, Speaker A: You can look at it in the documentation. You also need to define the name of your input and also their type. And you also need to define whether they are public or private. So we think that privacy is normal. So you only need to define the stuff that you want to make public. And so the biggest difference is that obviously if you have something that it's public, you got to assume that the Verifier has that in their possession while for private it's stuff that it's only on your machine that you don't want to reveal but you still want to prove some calculations on it. In this case we're going to use the field type which is basically an element of a finite fill.
00:10:41.180 - 00:11:32.022, Speaker A: So you can treat it pretty much as a kind of a big integer and make all kinds of really cool operations or arithmetic operations on that. That's basically what field is for practical purposes. If you want to define an array for example, then you just do it just like in Rust, you define the type and then define how many elements does your array have. One thing that you should notice is that you need to know this at compile time, there was no way of just passing like a slice. This doesn't work with basically any of the ZK languages I've ever worked with. So yeah, this is not new. Another thing you can use is like some really cool return values.
00:11:32.022 - 00:12:33.342, Speaker A: So you can have public field and make this return a field. And so you can have like for example, let's Z and say x plus y and then just assert like x is different from y and then just on Z and yeah, this, this will return you fill. And some people ask me why should I have public outputs for return values? Why do they have to be public? And the reason is basically the way it's treating the return value. It actually as an output, as an input. So this would be just the same as returning something like this public field and then just constraining at the end. So as you probably noticed, I already use some arithmetic on it. You can sum them up, you can subtract them, you can do all kinds of really cool stuff.
00:12:33.342 - 00:13:19.820, Speaker A: And if you know exactly what can you can do with fields, you can actually just check the noir docs do that for you. Just here are the noir docs. You can go here on the language concepts and see all the things you can do like logical operations and just send them and even like bitshift and stuff as long as they are integers. So this list will hopefully give you some examples as well. You can skim through if you're interested. Also the shorthand operators which are really useful at times. You can also use loops and control flow stuff like ifs and else and stuff.
00:13:19.820 - 00:14:13.260, Speaker A: So basically the way you write them, it's just like in Rust you'd say for I in some kind of range, you say oh thanks GitHub copilot. It already knew some example for you. You can run your follow ups for loop just like this. You can also do it like a conditional. So you can say if x is not one or if it is one then Y is something like this. So yeah, you can run if else just like you do with Rest. There's also the assert keyword that you probably saw at the beginning and that you're going to say assert x is different from Y.
00:14:13.260 - 00:14:53.130, Speaker A: So this is something that you don't get in rest. So if you try to run this it will say it'll complain that doesn't know what assert is and this is basically what you want your program to do. Basically I want this proof to generate some constraint and say that this proof will only be valid if X is different from Y. And I don't want to reveal what X is. That's what a sort keyword does. Another really cool thing they can do is structs. So yeah, you can define like a new struct and say struct person, for example, and just have some stuff like not strings.
00:14:53.130 - 00:15:28.770, Speaker A: We have strings, but yeah, let's not use them, not today. So you can define strikes and just pass them. Like you can pass here. X could be a person, for example, with X age, et cetera. So for our project, let's imagine that you are the owner of a fight club. So you're going to say that each fighter is a person and that person has an age which is going to be a fill, for example. And you want to check that only people with a certain above a certain age are allowed into your fight club.
00:15:28.770 - 00:16:12.578, Speaker A: You also want to check, for example, that they know the password to enter your fight club. There's a secret password that you don't want to bouncer to know what it is. And so let's just go through it and say, yeah, there's a person, this is going to be a fighter that has a certain age. And then you're going to have like, for example, a password. And obviously a password is a private input, so let's not reveal it. But the hash of the password, that's definitely something that can be known because it's very difficult to figure it out. And so let's just get like password hash, password hash going to be a public input and let's say that's going to be also going to be a fill.
00:16:12.578 - 00:16:51.722, Speaker A: And so in your program, all you want to do, it's basically two things. One is just like, check if age is bigger than minimum age. And the second thing is like, you want to check if the password hash is equal to the hash of the password. So, yeah, GitHub cop out, already know how to do it. Yeah, let's just see how can you use this hash thing? Another thing that can be useful in this case, for example, is global. So you can go and say global and say global. Minimum age is going to be a field and let's say it's 18.
00:16:51.722 - 00:17:31.342, Speaker A: Because I'm in Europe, I don't know if it would be different in any other country. Let's just get ourselves some space here. Let's just go and you can literally write two lines of code and see, fighter age of the fighter needs to be higher than the minimum age. This takes care of your first assertion. And I can just go and test it already. I can go and say, let P is a person with H, for example, H 19. And so I can say that 19 is here.
00:17:31.342 - 00:17:57.362, Speaker A: I'm going to just pass whatever random values for the other two. Yeah, and see. This should pass. I'm going to go and run Nargo test. Okay. Oh sorry, I need to city into that project and then go and nargo nargo test. Oh, wait.
00:17:57.362 - 00:18:13.980, Speaker A: Sorry. I forgot. SP. Yeah, it will complain that fields cannot be compared. Yeah, that's something that's true. You can compare fields. So let's just cast them as U eight.
00:18:13.980 - 00:18:49.458, Speaker A: Let's say actually make this already a new eight so it's easier and yeah, this will hopefully pass them. Another really cool thing we can do with Nargo, at least the latest versions is to write in test shoot file and this can be useful, very useful I guess. And just go and call test should file and then you can run and test should file. Let's just go. I hope GitHub okay. He knows already. He knows.
00:18:49.458 - 00:19:45.046, Speaker A: So yeah, you can go and run Nargo test. And this should pass because this test should fail regarding the password. So we have our password and know that the verifier knows what the password hash is. So that means in our circuit we need to hash our password and just check if the provided if the hash that everyone knows is equal to the hash that we are calculating in our own private input. So basically we are saying the hash of the input that only I know is equal to the hash that everyone knows because it's like in a smart contract or just everyone knows for some other reason. And how can we do that? We basically do that with the standard library. So the way you import it, it's very easy because you can just import like this.
00:19:45.046 - 00:20:16.900, Speaker A: It's just a standard library. So just dependency standard library. You don't even need to add anything to Nargo samo. It will work out of the box. Let's just go on the browser to see basically what you have there. And you have a wall chapter for standard library. And you have really cool things like recursive proofs and merkle trees and stuff and also all the cryptographic primitives that we currently support.
00:20:16.900 - 00:21:31.994, Speaker A: Ash for the hash methods, you have many hashes that we have implemented already. Some of them are what we call black box function. And this basically means that this is just provided by the backend. So if you use different backends, they may not be implemented. If you're looking for a hash method to use, I would recommend it to use some ZK friendly hash that would be for example, Pederstone or Poseidon. Let's just go on Poseidon because I like yeah, the way you import it is just like this and I'm actually going to copy this so you can see and go over on my Vs code window as well and just paste it here so I don't forget how to use it. And so the way you import it is you have STD so you can actually go here and import it here so you can have more granularity on what exactly are you trying to import and say just leave it at is as this is.
00:21:31.994 - 00:22:19.814, Speaker A: And so this way you can have your program be a little bit less verbose and just have the module you're importing specifically. And so in this case we want to check like you want to it's not really that as GitHub says. So you just want to check that your password hash is equal to the hash that you're trying to do. In this case, you just go and run password. And the reason GitHub thought I was trying to pass an array is because, yeah, password should be an array. So he was kind of right. So, yeah, in this case, as I told you, you need to know the size at compile time.
00:22:19.814 - 00:23:19.702, Speaker A: So, yeah, I'm hashing two values, so I'm passing the hash two. So it would be three or four or five or whatever depending on what exactly are you trying to hash? It says that's not being used, which is a lie. Okay, now it's okay, yeah, that's it. Now for testing, basically it will complain that, yeah, it expects a field too, which is kind of true. And so here's what, the utils folder can be useful because you do have an implementation of Poseidon that you can actually run on your machine and see how does a hash look like. So you just go here, you just change your inputs and then run this, like with TS node for example, and you're going to get an output. So in this case, I think I already have two values here that can be used for positive.
00:23:19.702 - 00:23:57.078, Speaker A: So if you have like one, two, for example, the hash of that should be this. So yeah, in this case I'm going to just paste and say, yeah, the password is one two, which is a very weird password, but let's forget about it and just say the password hash is this one. And while we are here, let's just go and do the same for the test that should fail. So I'm going to just change and just change this eight for a B and this hopefully should pass like both tests. Let's go and try. Yeah, as you see, they all pass. This one passes because the value is correct.
00:23:57.078 - 00:25:01.898, Speaker A: This one passes because the value is incorrect. If you've seen the utils folder, you also have another one called Ketchak, which is basically the same thing but using Ketchak which is a hash function that is widely used in Ethereum, but it's not very KEYK friendly. So one thing that you want to do basically is to prove stuff and that's all fine to run tests, but they are just tests you actually want to prove and the verification stuff. So the way you do it is just run granargo check and you have this prover and verifier files. This is basically where you put your values and to be proof, to be proven. So in this case we know what they are already. So I'm going to just go and put my password here, just here and my password hash in quotes, inside quotes here.
00:25:01.898 - 00:25:59.760, Speaker A: And the age of my file there's going to be 19. So you want proof on this and because this is noir, it's as easy as just running Nylo proof. You're going to see here like the proof, it has the name of the project and it's very difficult to understand but as you can see it's kind of succinct, which is what we want in the end. It's snark right, it's supposed to be succinct. If you want to verify that, you just do the same thing, just go Nargo verify and you're going to verify the default proof that's going to be in this directory with the name of the project. At this point you're probably asking how can I do that in a smart contract? And as always, it's pretty easy. You just go and run Nargo code, the gen verifier and it can take a little bit but it will generate a smart contract for you.
00:25:59.760 - 00:26:56.414, Speaker A: It was fast actually this time. So you have a smart contract here, which was written by very smart people. And yeah, it's going to be a little bit difficult to understand all of this, but, yeah, this is a smart contract. You can deploy the relevant function. Here is probably the verify function, and this is basically what does it expect to be passed on? At this point you may want to explore a little bit more about standard library and you'll probably notice that it doesn't do everything you want and that's okay, we expect that. And so there's a very easy way to just import other libraries. One of my favorite libraries is the EC Recover Library and this is by one of our community members called Colin.
00:26:56.414 - 00:27:49.454, Speaker A: And Colin just put this library to basically recover an address from a signature. How can you use that? So let's go back to Vs code and just go on the Nargo tunnel. And here you have dependencies here and actually just an example of how can you use Ecrecover which is like this, you go Easy Recover. You check the tag and then if you want to import it, it's very easy. You go here and you just import it. Just use depth, easy recover and there you have it. So as promised I'll show you how to use this in the browser.
00:27:49.454 - 00:28:43.038, Speaker A: So the way you can do that, we're not going to use Nargo anymore, I believe. So let's just close this and just leave the circuit here. And basically the way you do it is with three packages. As I've explained before, there is no R and that's basically the language that you're writing and that compiles into Acer which is the intermediate representation. And then we have two more packages which is the ACVM that will translate that into a constraint system and then finally your actual backend. And so the way you use it on the browser, it's just importing these three packages separately. So here in our project folder you have the browser package, sorry, a browser folder.
00:28:43.038 - 00:29:12.382, Speaker A: And this is a basic react page. If you see here like my component, I'm going to input some numbers x and y. I want to check if that X and Y are different. Kind of the other circuit that we know already. And then once the user picks calculate proof, it will calculate the proof. And so, yeah, it will generate witness and generate the proof. So the witness is like this ACVM part.
00:29:12.382 - 00:29:38.918, Speaker A: And then from there with the witness you can generate your proof. So you have here the class Noir. You are initializing as noir. New Noir. And so yeah, let's get started. I'm not going to write the whole thing, but there is a sheets file here. We can just go and copy line by line and just check and see what exactly does it do.
00:29:38.918 - 00:30:05.680, Speaker A: We're going to import our actual backend which is bratzberg. Then finally we're going to have also the init ACVM. This is needed only for the browser that you need to init the ACVM. It's going to be doing some awesome stuff in the background. And then finally the execution of the circuit and the compressed witness if you need to compress it. And we're going to do that. We're going to need that.
00:30:05.680 - 00:30:39.660, Speaker A: You probably noticed that there isn't any JSON file in our project and that's because I just forgot to compile the circuit. Yeah, basically that's what we're going to do. So we are in that folder already. So I'm just going to go and run nargo compile and it will compile my circuit into the target folder. Then we are finally like the big stuff. We are initializing Beretenberg with four threads. So you can actually make this six or eight or whatever.
00:30:39.660 - 00:31:33.834, Speaker A: Yeah, just basically there's multi thread support in that's why it's actually so fast. We're also getting like the circuit size because we need to allocate some memory for our WASM stuff. So this is basically what it's doing. And finally we are just storing the ACU composer, which is very handy interface to generate your proofs. As for the proof generation, I'm just going to go back to my cheats file and just copy this. Just last two things and yeah, while we're here, also copy the destroy method and let's just go over them. This is actually the easiest part.
00:31:33.834 - 00:32:07.942, Speaker A: So if you have the witness already, you just call Asy, create proof from your initialized API. So if you remember, this API comes from the Brattenberg. And so you've done a bunch of things to bratzenberg to make it ready. So then it's just easy to go and call Acrite proof. And you need to pass your ACU composer and the buffer uncompressed. And yeah, you need to decompress your windows because it comes out of ACVM decompressed. And this false, you can just ignore it.
00:32:07.942 - 00:32:35.642, Speaker A: It's meant to be used for recursive proofs. So we are actually also abstracting this away from you. And finally you should have your proof here. This should output your proof. As for the verify proof, it's kind of the same thing. And then, yeah, you have the verified proof, actual verified proof with the issue composer and the proof. And that flag that you can ignore.
00:32:35.642 - 00:33:13.046, Speaker A: Regarding recursive proofs, this is how you would do that in the browser or basically also in node JS. So I'm going to show you in roster you have some examples. One of them is the next hard Hat, which is basically our project, but it's ready to use so you can see like details. It also integrates ether, so it already verifies on chain. Your proof as well. And yeah, that's it. There's a circuit.
00:33:13.046 - 00:33:42.190, Speaker A: Circuit is again, very easy circuit. You can see it just really basic. So, yeah, as you see, this is initializing the noir like that init function. Then I'm passing just like two different values. And you see, this is really fast until calculated your windows, your proof, verified it and then verified on chain. And this is it for Martin and Afternoon. I hope this was useful.
00:33:42.190 - 00:34:04.100, Speaker A: Just let us know if you have any questions. If you want to do something more difficult and you're having trouble, just reach out there's the noir discord, you should join. And also, yeah, you can just get in touch with us on Telegram or Twitter or by any other means. Thank you.
