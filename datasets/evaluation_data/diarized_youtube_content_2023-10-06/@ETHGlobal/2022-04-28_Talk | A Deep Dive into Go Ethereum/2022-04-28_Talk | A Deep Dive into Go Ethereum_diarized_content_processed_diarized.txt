00:00:20.050 - 00:00:55.380, Speaker A: Right. Hello, everyone. My name is Marius, and I'm going to talk about Go Ethereum today. I didn't have much time to prepare my slides, as you can probably see on the site. So I'm just going to wing it, and we're going to go a bit into the code. I'm going to talk a bit about what the different modules of Go Ethereum do. And then I thought we can just make a lot of time for questions and discussion and stuff like that.
00:00:55.380 - 00:01:49.522, Speaker A: All right, I wanted to show you how a transaction travels throughout Go Ethereum. And this is the rough overview. We submit a transaction via RPC, and it gets inserted into the transaction pool. And from there, we have the ETH package, which handles a lot of so we have the ETH Protocol, which defines the network messages and stuff like this, and the way we interact with the network. And from there, we take the transactions and we use the peer package. We're going into the peer package and send the transaction to another peer. This peer goes the same way back through the ETH package into the transaction pool.
00:01:49.522 - 00:02:33.038, Speaker A: All right. I think it's most interesting to actually see it. So when you send a transaction via MetaMask to your local node, then you will always send a raw transaction. You will sign the transaction not in your node, but you will send the signed transaction to Go Ethereum, and it will end up here. And from there. This internal ETH API has a lot of these API methods that you're very familiar with. Like, ETH send transaction.
00:02:33.038 - 00:03:37.734, Speaker A: ETH send raw transaction. ETH get block. All of these are defined in internal ETH API. And if we follow this now, we submit the transaction. And what we do, we do some basic checks before inserting it into the transaction pool. And so we check that we have enough fees and that the fees don't exceed a certain amount, because we had a lot of people mixing up the value of the fee and the gas price. And so they were sending transactions with a really high gas price, and then they were complaining, why did I lose so much money? And so we have some extra checks there to make sure that this doesn't happen.
00:03:37.734 - 00:04:05.054, Speaker A: And, yeah, then we go to Send Transaction. Send transaction is actually in the interface from the transaction pool. So this is implemented by the transaction pool, this interface. And we end up send transaction. Send TX something like this. No, not here. We end up in the API backend.
00:04:05.054 - 00:04:43.550, Speaker A: Sorry. Yeah, send transaction is in the API backend. The API backend is something that we use for a lot of these APIs. And it's a collection of methods that are useful to have for creating the RPC APIs on top of that. And one of them is Send transaction. Send transaction just adds the transaction as a local transaction into the transaction pool. So if we follow this, we come to the transaction pool, add locals, add transactions.
00:04:43.550 - 00:05:22.486, Speaker A: So the transaction pool, it has all of the transactions, of course. And we sort them. We sort them by the gas price. And we also have to with 1559, we have like a two dimensional gas price. Sorry, a two dimensional gas price. And it's a bit more complicated how to sort the transactions. Because some of the transactions might be valid at a certain base fee.
00:05:22.486 - 00:05:55.060, Speaker A: Some of the transactions are not valid at a certain base fee. So we have to continuously update which are the valid transactions. Because we built a pending block. The pending block is just the current block that you have. And you pile all of the transactions on top so that you know roughly how the next block will look like. With the emergence of a lot of this mev stuff, this pending block is basically useless. And we're trying to get rid of it.
00:05:55.060 - 00:07:00.326, Speaker A: The problem is that the pending block is used everywhere. And for example, if you create a transaction, you will need the nons, right? And if you already send a transaction to the transaction pool that is not confirmed yet, you will need to know that there's some transaction so you can increase the nons once more in order not to replace the transaction. If you send the same transaction, if you send a different transaction with the same nons, you actually replace the transaction. But only if certain conditions are met. And the conditions are the max base fee per gas has to be 10% more than from the a transaction that you want to replace. And the max tip per gas also has to be 10% more. And there's some discussion about this if this is actually the right mechanism.
00:07:00.326 - 00:07:59.926, Speaker A: But the problem is, if we don't have this, if we let someone just update the transaction without increasing the amount that they pay for it, then people can just spam. The transaction pool always resend the same nons. And we have a lot of churn in the transaction pool, which is bad. Yeah. So here we're trying to add the transaction to the transaction pool. We extract the sender. So we do the EC recover on the signature for the sender address and we add it to the transaction pool, right? Yeah.
00:07:59.926 - 00:08:41.490, Speaker A: We add it to the transaction pool. And here we look, if we already have the transaction in the transaction pool, we validate the transaction. And if it's underpriced, we discard it. And there's a lot of stuff going on here. And in the end, we NQ the transaction. I wanted to go into detail about the transaction execution later on, but I can do that. No, I'm going to do it later on.
00:08:41.490 - 00:09:53.690, Speaker A: So the basic idea is we're adding this transaction into the transaction pool and somehow the transaction pool has all of these transactions. Now we have to if we go back to the picture we started with the RPC, we submitted the transaction into the transaction pool. Now we have to send this transaction to our peers. So we have in the ETH protocol, in the ETH packets, so you can always see the packet that we're in up here, if you don't know. And in the ETH packet, we have the handler, and that handler has the sync transaction function. And whenever a new transaction so it periodically asks the transaction pool for the pending transactions because of someone, we have different concepts in the transaction pool. Pending transactions are the transactions that are actually executable.
00:09:53.690 - 00:11:20.200, Speaker A: We also have gapped transactions. So if I send a transaction that has 9000 and I didn't send 8999 transactions before that, then this transaction is gapped. It's non skipped because there could be some race conditions about the transaction propagation. We actually don't want to throw away all of these gap transactions, but we want to store a couple of them. So if someone then sends, like, the missing transactions, we can validate them and add them to the pending transactions. So what we do here is we get the pending transactions and we send the hashes to a subset of our peers. So oh yeah, it's some of this stuff is a bit hard to follow, but the idea is we shove the transactions into this announce channel and now I have to sorry, here we go.
00:11:20.200 - 00:12:14.032, Speaker A: I have to look where these transactions are actually ending up. Sorry, here. Yeah, in the broadcast, it's in ETH protocol. ETH, sometimes the package names and the packages are not really great and yeah, so in the handler, we shove the transaction into this queue and we unqueue the transactions at the other end and put them into this queue. And this is an infinite loop that runs. And if we have transactions in the queue, we get them. So we only have the transaction hashes in the queue.
00:12:14.032 - 00:13:17.864, Speaker A: Yes, we actually fetch the transaction from the transaction pool if it's still there. By the time that we ended up here, the transaction is not anymore in the transaction pool, we just ignore it. But yeah, we add it to the pending and we send the pool transaction hashes. And here we go back where we started. And this actually sends the transaction hashes to our peers. So what we do is we announce like, there's two different ways that we send transactions to a subset of our peers, we send the full transactions and to all peers, we send the transaction hashes. And if someone receives a transaction hash that they're curious in, they can fetch it from our node.
00:13:17.864 - 00:14:14.760, Speaker A: But we don't want like if we were to send our transactions to everyone, there would be extreme transaction churn and a lot of bandwidth that we don't really need because you would get all the transactions from every peer at all times. And so we don't want to do this. Yeah, so now we go to the P two P packet. And this just writes the message onto the wire. We managed to push the transaction to the peer. Now we have to go to the other side and actually receive the transaction. And this is done in the transaction fetcher.
00:14:14.760 - 00:15:06.540, Speaker A: The transaction fetcher initiated here and we have some loop. Yes. And okay. I've never seen this code before. It yeah. So we that's a timeout the wait notify yes. We get notification of someone sending us transactions.
00:15:06.540 - 00:15:47.790, Speaker A: And so we check whether we already got the transaction. We have the announcement from someone else. If not, we actually ask them to send the transaction. So we schedule the fetches. And for each peer, we ask them for the transaction. And if they have the transaction, they send it to us. If we get a transaction, we actually call the add transaction function.
00:15:47.790 - 00:16:12.880, Speaker A: No, sorry. Add transaction. This one. Okay. Sorry. And yeah. So this includes the transaction the transaction into the transaction pool.
00:16:12.880 - 00:16:36.324, Speaker A: So this add transaction function actually puts them back into the pool. And so we end up in the transaction pool again. We are at remotes. So we also have this concept in the transaction pool. We have the concept of remote transactions. Those are those that we get from our peers. And we have the concept of local transactions.
00:16:36.324 - 00:17:16.600, Speaker A: Local transactions are those that we get over the RPC. We want to handle them differently because we don't want to drop our own transactions. So we always say if you send a transaction over RPC, this transaction will never get dropped. If a transaction from the wire is replaced by something that pays more, then we can drop this transaction. And so we have this notion of local in the transaction pool. Sorry. And yeah.
00:17:16.600 - 00:18:03.408, Speaker A: So that's roughly how transaction propagation works. The next interesting part is how do we create a block so the miner any questions to the transaction propagation? Yes. So how is it working? How is it gossiping the transaction further to other peers? So in one when I'm receiving a transaction, I'm recognizing I didn't saw this transaction yet. So I'm assuming like then I'm just also doing the same thing. I'm forwarding to transaction. You're forwarding to the square root of your peers. And then you're forwarding the hash to all the other peers.
00:18:03.408 - 00:18:57.770, Speaker A: And if you receive a hash and you have never seen this transaction hash before, then you ask the peer that sent you this hash for the transaction. Am I forwarding all of the transactions or do I validate them first? I have to repeat the question. So the question was if we are forwarding all the transactions or if we're validating them first and then forwarding. And the answer is we're validating all the transactions before forwarding. So our transaction pool only has valid looking transactions. So valid looking means the sender has enough money to cover the transaction cost. And the nonce is roughly what we expect.
00:18:57.770 - 00:19:37.200, Speaker A: There might be some other conditions, but I don't know them. I'm quickly going to close the door because there's some sound coming from there. All right, let's get to creating a block. So now we have a lot of transactions in our transaction pool. We are a minor. We want to seal a block. How does this happen? For that, we have to go to the minor package and the worker.
00:19:37.200 - 00:20:08.220, Speaker A: Yes. So in the minor package, there's a lot of stuff going on. The minor is extremely complicated. So I already made sure that we are in the right vicinity. We somehow end up in the commit work function. So the minor starts a loop. And whenever a new block comes in, we need to update our work package.
00:20:08.220 - 00:20:57.084, Speaker A: So we need to build on top of the block that we just received. And for that, what we do is we prepare the work that generates um, yeah, sorry. No. All right, where were we? No, we were under worker yes. Commit work. We have to prepare the work. We have to yes, prepare work.
00:20:57.084 - 00:21:23.188, Speaker A: All right. Yeah. We have to set a couple of fields in the block. For example, we have to set the parent hash to the correct hash. We have to set the correct timestamp. We have to calculate the gas limit per block. You can shift the gas limit by a tiny amount, either up or down.
00:21:23.188 - 00:21:50.876, Speaker A: And so we have some configuration. The gas ceiling or gas target. This is what we want to end up with. So currently, this is set by default, set to 30 million. All the miners are trying to hit 30 million. But you can also configure this. So we have to calculate the gas limit.
00:21:50.876 - 00:22:37.334, Speaker A: We have to set the coinbase. This is where all the transaction fees are ending up. In the end, if we have London chain rules, then we need to do the base fee stuff. So we have the consensus engine. This can be either Ethash click or the new Beacon Consensus engine. And we have to make some environment. Once we prepared the block, we actually need to fill it.
00:22:37.334 - 00:23:49.082, Speaker A: So we need to apply the transactions. Sorry. So what we do is we fetch all the transactions, all the pending transactions from the transaction pool. So pending just takes the transactions that are actually executable, and then we first take the local transactions, order them, and then we take the remote transactions and order them. And then we commit the transaction to the pending block, to the pending work package that we're trying to build. And so what that does is we have to set the gas limit and stuff like this. We calculate the sender again, we prepare the state, we have the state database.
00:23:49.082 - 00:24:29.050, Speaker A: And we have to set some fields in there so that we can later on query them during the execution of the EVM. And then we call commit transaction. And Commit Transaction actually does apply transaction and with Apply transaction, we go to the core package. So the core package is responsible for most of the core stuff. The TX pool lives there right now, which is not great. We should move that to its own package. But yeah, so all of the interesting EVM stuff is in the core package.
00:24:29.050 - 00:25:09.558, Speaker A: So we're in the state processor now. We're creating a new EVM block, context a new EVM and then we call Apply Transactions. Apply transaction does apply message and apply message calls. This new state transition transaction database. And this is where we actually do the execution. Or we start the execution of the EVM. So we start the execution of the EVM by doing the pre check.
00:25:09.558 - 00:26:01.900, Speaker A: The pre check has stuff like get nons. We verify the nons. We verify that if it's not fake, yes, we verify that we actually have code there. No, we verify that the sender is an EOA. This is a pretty new change. Previously it was theoretical possible to send a transaction from an address that had code deployed. It's not really feasible to do that because you have to find a collision between a code hash and an address that you know the private key for.
00:26:01.900 - 00:27:09.920, Speaker A: But if you set code to an address that you know the private key for in the Genesis block, which is possible, then you could end up at some weird state. So we don't want to have transactions originating from a smart contract. Then we have to verify the base fee and then we have to buy our gas and buy gas, just calculates how much gas we are, the maximum amount of gas that we are going to use in the EVM execution later on. All right, so we did the prechecks. We have a lot of code here for tracing. So you can trace the transaction, you can trace each upcode, you can see which operations are executed, what's the outcome and stuff. So if you see config debug or something with tracer, you can just ignore it.
00:27:09.920 - 00:27:53.050, Speaker A: It's not really interesting. And then we check the intrinsic gas. We check whether the sender has enough money. And if we post Berlin, we prepare the access lists. So in the Berlin hard fork, we changed the rules a bit so that you can provide an optional access list. And calls to the contracts that are in the access lists are cheaper. You can pre warm a contract.
00:27:53.050 - 00:29:18.870, Speaker A: And we decided that calls to the pre compiled calls to the sender itself and the recipient should also be warm cost. So the idea was we want to increase the cost for calling a cold address that we have to fetch from the state database, because that's a pretty expensive operation. But that would break some contracts that have some hard coded limits for interacting with another contract. And so these access lists are to unbreak those changes. And so in the future, they're optional right now we could make them mandatory mandatory access list is like the concept of mandatory access list is also something that comes up in Stateless. If you're doing Stateless, you will provide the prestate as a kind of access list, execute the transaction and then also provide the post state so that everyone can verify without having to have the state. All right.
00:29:18.870 - 00:30:01.800, Speaker A: And then we check if this is a contract creation. Contract creations. If you send a transaction to no address, to zero address with code, then the code gets executed and we call the create operation. And otherwise we call the code at the address that we send to that we're doing the execution to. Are you more interested in Create or call? Create. Call. Okay, let's do the call then.
00:30:01.800 - 00:31:16.590, Speaker A: All right. In Call, we're first checking if when you call a contract, you can attach a value to that. So we're checking whether the address, that central transaction, the originator has enough money to cover that cost. Then we take a snapshot of the state database and then we check the pre compiles. And there was so there's some issue here. I don't know how many people actually know this, but back in the day, you could self destruct contracts. Like, there was a hard fork after the Shanghai attacks that destructed all the addresses without code, without storage.
00:31:16.590 - 00:32:01.820, Speaker A: And the problem was that Vitalik wrote a script to do all of this, but unfortunately and without a balance. Unfortunately, one of the precompiles also didn't have like, it doesn't have code because it's a precompile. It also doesn't have storage and it also didn't have a balance. And so he successfully destroyed the precompile. And so this clause actually checks that. We don't hit that. All right, then we're doing the transfer.
00:32:01.820 - 00:32:48.620, Speaker A: We're just sending the money. And if the code that we're sending the money to or that we're calling so we first send the money and then we're starting the code that is on there. If it's a pre compile, we run the pre compiled contract. So in Core VM, we have the pre compiles? Yes. In the contracts. Yeah. So this is like the different pre compiles for the different rules.
00:32:48.620 - 00:33:32.360, Speaker A: For example, in Istanbul, a new pre compile was added, the Black to F precompiled. So it's like that. There are different pre compiled depending on the chain rules that we have. And these precompiles have a run function and a required gas function. So if you want to implement a precompile, you have to fulfill this interface. And, for example, the EC recover precompile for the required gas. It's a fixed amount.
00:33:32.360 - 00:34:21.290, Speaker A: It's always 3000. And if you run, it will validate the signature values, make sure that we're not inputting something really weird and then does the EC recover of the public key and returns a public key of that signature. And so this is like a pretty nice file. There's a lot of really cool things there. And I like this code a lot other than some of the other code that I showed previously. And yeah, we're in the call again. If it's not a pre compile, we get the code of the address that we just called.
00:34:21.290 - 00:34:58.400, Speaker A: If there's no code, we are done. Really done. But we're finished for now. If we have code at that address, we have to trigger that code. And so we set the call code. You have three different ways of triggering code. You have the Call code, some other stuff, a static call.
00:34:58.400 - 00:36:03.762, Speaker A: And then you call run on the contract and run. We, we fetch, basically we fetch in a for loop. We fetch the next operation and then we look into the jump table to see the program that we have. Program is like what the Opcode actually does, and then we execute it. So how does an Opcode look like in the EVM? You can see I don't know. We're going for the London instruction set. Are we going for the Merch instruction set? You're probably all interested in the Merge, doesn't do that much.
00:36:03.762 - 00:36:53.810, Speaker A: Berlin, Istanbul. Okay, here we have some instruction sets where some instructions are actually set. So in Constantinople, we had a few new Opcodes. We have the shift left, the Shift right, the shift arithmetic right, xcode hash Create Two. And they all have a Stack requirement, a gas function. And they have a constant gas and a dynamic gas if there's some dynamic gas. So for some of the operations, like Add or sub static gas, makes sense.
00:36:53.810 - 00:37:44.130, Speaker A: You're adding 256 bit elements together. There's not much that can grow out of bounds. But for some operations, you want dynamic gas depending up the amount of work that you actually have to perform. And so, for example, for Create, you want to spend as much gas that's proportionally to the length of the code that you are going to deploy. And we can now look into one of these operations. So these are functions actually that are in there. And we can look at one of these functions.
00:37:44.130 - 00:39:06.040, Speaker A: For example, the Create function takes some stuff from the Stack, it uses some gas, and then it calls the Create Two, which just creates an address and then calls Create with that. And yeah, if we started with the Create route, we would have ended up right here, but we wanted to look at Call instead. So, yeah, so that's roughly how the EVM works. You have these operations, maybe something easy. So this is like an easier function in the EVM. You just take two values from the Stack, add them together and that's it. And yeah, so did pre compiled? Yes.
00:39:06.040 - 00:40:16.220, Speaker A: And we, we are back in Call if something happens. So if there's some issue, if the contract reverts in the call, then we have to revert the transactions. And so if you remember up here, we took a snapshot before we applied the transactions. And if it reverted, then we have to reload this snapshot and throw away all the modifications that we made to the state database. All right? And so after after we executed the transaction, we know how much we know how much gas there was. We have some refunds. So for example, if you clear storage or if you call the self destruct opcode, you're getting some gas refunded.
00:40:16.220 - 00:41:08.640, Speaker A: So we have to refund that and we also have to pay the coinbase. So this line is where the transaction fee actually goes to the coinbase. And then we return the transaction result back to apply message and apply message. And now we have the result. And before by Sentium, we calculated an intermediate state route after every transaction. This is a lot of work. So after bicentium we decided to not do this anymore.
00:41:08.640 - 00:41:56.480, Speaker A: And then we also have the receipt where we set if the transaction failed, we are going to set the failed in the receipt. All understand this. And we also set the locks and the Bloom. So the Bloom is a Bloom filter where all the locks are in. So the locks we have the return opcode that you can use to not the return. How do you emit an event, whatever. If you emit an event in your smart contract, then it will end up in the logs.
00:41:56.480 - 00:42:36.380, Speaker A: We want to filter these logs. So, for example, you are interested in all the events that originated from your contract. That said, I don't know send successful or whatever. So you have the Send successful event, those are in the logs. And now you want to quickly filter through all the blocks. And this is where the Bloom filter comes in. So we put all the locks into this Bloom filter.
00:42:36.380 - 00:44:12.110, Speaker A: What a Bloom filter is, I don't know. Probably half of the room knows that. I don't know if I should start going into this. But basically you take some piece of data, you hash it and you set some bits in this plume filter and later on you can hash it again and see if these bits are set. And if these bits are set, then you most probably had this event originate from you did apply this event to the Bloom filter beforehand. There's a chance that you didn't and there's some hash collision. But it it makes it very easy to query for logs to see if like something if these events, if these logs actually are in the in the blue filter and sorry, it's 200, no 4000 bytes, something like this to 2048 bit it's fixed link.
00:44:12.110 - 00:45:55.370, Speaker A: It's not really valuable anymore, and we would also like to get rid of it. But it was valuable at some point because you could just go through all the blocks, look at the Bloom filter, and quickly decide, okay, this block has none of my stuff in it, so I'm just going to ignore it and look at the next block. If you actually find something in the bloom filter that looks like what you were looking for, then you need to go into the block, look at the receipts and see if that was actually what you wanted. And, yeah, that's basically it for apply message. And, yeah, we just return the logs from the receipts and we have some error conditions where we're back in the worker where we committed a transaction to the pending where we committed a transaction to the pending block, and now we have built a pending block. First of all, we set the fields, like the parent hash and timestamp and stuff like that. Then we went through all the transactions, applied them one by one, and now we have a valid block and now we need to actually finalize it, create the proof of work.
00:45:55.370 - 00:46:04.250, Speaker A: But I'm unfortunately out of time, so we're going to do that some other time. Thank you very much.
