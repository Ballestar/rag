00:00:07.370 - 00:00:26.550, Speaker A: Hi, everyone. Yes, I'm Marcus. I'm working on the graph. I work for a company called Edge and Node. And welcome to this presentation, an Introduction to the Graph. Quick start to subgraph development and querying. So let's get into it first and foremost.
00:00:26.550 - 00:00:48.518, Speaker A: Oh, we got some Internet issues. There we go. Let's try that again. Interesting. Well, we're going to be presenting here. That is totally fine. There we go.
00:00:48.518 - 00:01:11.502, Speaker A: And for some reason that's going. Okay, let's keep going. All right, so if any of you all want to hop into our hacker dashboard, we've got a few different things on this dashboard that would be of interest to you. We've got prize information. We've got the Telegram group also, and then also this presentation, as well as all the repos. So we're going to be doing a little bit of live coding. Feel free to scan that.
00:01:11.502 - 00:01:29.590, Speaker A: Let's get going. Okay, so first things first, an overview of the workshop. We're going to go an introduction to the graph. A high level overview of what's going on when you are getting your data from the graph. We're also going to talk about what subgraphs are. All right, that's really important. We're going to go through that.
00:01:29.590 - 00:01:55.294, Speaker A: We're also going to go through deploying a subgraph. And then also we're going to compare queries between two different subgraphs, the subgraph that we deploy, as well as a well developed subgraph. Okay, let's get into it. First an introduction to the graph. So when you go to, thegraph.com first thing you're going to see is this access the world's blockchain data. Let's go ahead and parse that.
00:01:55.294 - 00:02:11.250, Speaker A: Let's go ahead and see what that means. And we're going to go all the way down to the Smart Contract layer. First things first. A Smart Contract really is just a bit of data storage. That's all it is. And you're looking at this. This is a CryptoPunks example, kind of a mockup, where it's just some data.
00:02:11.250 - 00:02:46.794, Speaker A: That's all it is. Now, if you have this data, what about the data in the past? What about how that has interacted with other data points? Well, what you're talking about is this type of history. All right? We're looking at historical data. And you really have to understand in Smart Contract land, everything can interact with everything. So we have to understand really all of those different types of interactions and seeing how really are we able to get that information to you in your DApps. And this is really a problem, really, because the blockchain is write optimized. What I mean by that is it's easy to write to the blockchain.
00:02:46.794 - 00:03:18.726, Speaker A: Relatively speaking, we're able to write to the blockchain, especially with L two S now in a rapid and affordable way. Now that's really creating an indexing issue where now we have to organize all of this data. And when we're here, now we have to read that data. We have so much data, we are sending our information to the blockchain. And then now we need to read that. Who here today has interacted with Instagram or some type of social media app on Web Two? There we go. All right.
00:03:18.726 - 00:03:46.062, Speaker A: Have you posted on Instagram recently? Okay, so that's a write, and that was a single write. And then with as many followers as you have, hundreds, thousands of followers, that's the read. And that's the exact same thing we see on the blockchain, where there's a lot of reading going on relative to the actual writing that's occurring. So in Web 2.5, there's a certain amount of solutions for this where anyone here could spin up an indexer on their own. They could do it. That's totally fine.
00:03:46.062 - 00:03:57.542, Speaker A: There's other ways to index as well. That's totally fine. We call those centralized indexing. Okay. And so if you have a data point that you're looking for and you want to get it and it goes to your front end, awesome. All right. That's a really awesome thing.
00:03:57.542 - 00:04:29.210, Speaker A: However, when that goes away, your DAP goes away. All right? And that's really, really a problem. The Web 3.0 solution is to have decentralized reading and decentralized indexing from the blockchain. And so what you have here is a single data point going to lots of nodes, and all of those nodes are able to populate your front end. And if anything should happen to any one of those nodes, you're still intact, you're still good to go. And that, in a nutshell, is a high level overview of the graph.
00:04:29.210 - 00:05:01.594, Speaker A: We love this. So let's think about what this means because is that too loud? There we go. We good? Yeah. Okay, cool. So what that means is we have a read layer that is amazingly, we take the advantages of the blockchain and its decentralization, and we apply that to the read layer because the blockchain is very much you're writing to it all the time. If you're reading in a centralized way, well, that's a problem because now you have the Web 2.0 type of issues.
00:05:01.594 - 00:05:31.422, Speaker A: And then from there, if you decide to decentralize also your front end, you can actually have truly decentralized apps. And that's a really powerful thing. So to overview the graph network, which is the decentralized network of indexers the world over, we have over 450 permissionless indexers working worldwide. There's redundancy between them. If anything should happen to one another, one will pick it up. It's fast, cheap, and reliable, and it's a global open API. Okay, so let's get into subgraphs.
00:05:31.422 - 00:06:03.658, Speaker A: Who here has deployed a subgraph? Okay, got a few people. Awesome. So let's get into subgraphs. What are subgraphs? Why do we need subgraphs? Let's talk about it. We are swimming in blockchain data all the time, all right? Being able to write all of this information to the blockchain, all the l two capacity, it's amazing. A subgraph essentially is a way of organizing that data. You're providing instructions to indexers around the world to say, this is the information that I need and I need it organized and I need to be able to query that information.
00:06:03.658 - 00:06:40.622, Speaker A: That's essentially what a subgraph is. It's a set of rules that you give to the indexers around the world and say, hey, I need the data prepared in such a way that will be useful and queryable, okay, that is a subgraph. So like I said, subgraphs are instruction for indexers. Let's break down the pipeline in a high level overview of what that might look like. You might be looking at on chain data, you might be looking at off chain data, specifically IPFS that's currently supported. There's also a push to support more off chain data, but right now it's just IPFS. You will define your subgraph in the subgraph manifest, also known as the subgraph YAML.
00:06:40.622 - 00:07:24.962, Speaker A: You want to think about that as like the rules and overview of kind of the shape and structure of your subgraph. From there you're going to give that information a little bit of logic and that is in the mappings TS file. And you're going to say, hey, we're pulling this information in. Do we want to put any logic on it? Do we want to actually start to transform it that's in the mappings TS. And then from there we've got this schema GraphQL where you can actually have your data in nice easy buckets, also known as entities. And you could send GraphQL queries to those buckets and get your data on your front end and it'll look something like this. All right? Instead of going through etherscan, instead of parsing through, you could send a simple query in GraphQL that's very easily read and from there get your data through an API endpoint.
00:07:24.962 - 00:07:54.130, Speaker A: Okay, so that's a high level overview of the graph. We are seeing around one to 2 billion queries per day. There's over 1000 subgraphs published on the graph network with the indexers all over the world. And there's 450 plus nearly 500 at this time. Okay, so if you'd like to scan this, feel free. I love QR codes. They're easy way to communicate where you have learned about graph, about the graph protocol and subgraphs.
00:07:54.130 - 00:08:12.450, Speaker A: And once I see the phones though, we will continue going. There's a phone there. Awesome. Okay, awesome. Got it. Okay, finally, part three. Let's go ahead and deploy a subgraph.
00:08:12.450 - 00:08:41.294, Speaker A: All right, so if you would like, here is the repo that you can star and reference. You don't need to actually clone this. This is just for reference and kind of just getting these overviews of what I'm talking about today. And there's also going to be another repo that we'll look at in just a little bit. So once I see phones down, I'll keep on going phones down. Cool. All right, so first things first, you're going to want to go to the graph.com.
00:08:41.294 - 00:08:50.562, Speaker A: If you want to participate with this, you're more than welcome to. I'll take my time. Is anyone going to be live coding with me? You're welcome to yes. Okay. Kind of, sort of. Okay. Yes.
00:08:50.562 - 00:09:06.598, Speaker A: Awesome. Saw some hands. Also, you're going to want to pull up miniscan Https, miniscan the XYZ. Those are really the only two things you'll need. And then also, of course, Ether scan. That would be helpful too. Okay, those are the three tabs you'll need.
00:09:06.598 - 00:09:32.942, Speaker A: And what we're going to do in this deployment is we're going to deploy the subgraph and then we're going to trace the punk transfer event. Because subgraphs are optimized to look at events, we're going to look at this punk transfer event and we're going to see it on chain. We're then going to see it in the subgraph manifest. We're also going to see it in the logic. And then we're going to actually be able to query that in the schema of GraphQL. That is the pipeline we're going to follow from beginning to end. Okay, let's go back and we'll start.
00:09:32.942 - 00:09:57.266, Speaker A: So like I said, we'll need some tabs open. First things first, we'll go to the graph.com and studio see and make this a little bigger. Very nice. And we're going to create a subgraph and we'll say live at eGlobal Waterloo. And we're going to be looking at Crypto punks. All right, we're going to be looking at the CryptoPunks smart contract.
00:09:57.266 - 00:10:10.778, Speaker A: So what we're going to do makes it a little smaller. There we go. It'll be on Ethereum and we're going to create a subgraph. Now, this is the subgraph dashboard. We have yet to deploy our subgraph. It is not published onto the network. It is just something we are working on.
00:10:10.778 - 00:10:28.866, Speaker A: When we do get to the point where we want to query it, this is our development query URL, where you could actually query that in the front end. Just getting you guys familiar with this. You're free to fill out description, information. All of this is all great. Just providing information. I'll tell you why this information is important in a minute. Let's keep on going forward.
00:10:28.866 - 00:10:50.506, Speaker A: First things first, you're going to want to install the graph CLI. All right? So open up your terminal, copy there and paste Internet. Yes. Now we'll see all right, as that's spinning up right there. There we go. Yay. Awesome.
00:10:50.506 - 00:11:09.230, Speaker A: So we've got the graph protocol, graph CLI installed. From there, we want to initialize our subgraph. We'll copy this and paste it right into the terminal. A lot of copying and pasting, that's all it is. So here you're presented with a selection of protocols we had near on earlier. So, awesome. We index on near.
00:11:09.230 - 00:11:28.694, Speaker A: That's also there for you, we have Cosmos, Ethereum and Rweave. Now, we know our smart contract is on Ethereum, but any EVM compatible chain that we also support is through Ethereum. We index right now, I believe, 40 chains. 40. 41 chains. And some are EVM compatible, some are not. So just go ahead and dive in.
00:11:28.694 - 00:11:50.510, Speaker A: Since we know this is Ethereum, we'll click on that subgrass slug, it automatically populates from the CLI and directory automatically populates. And here we're given all the chains that are EVM compatible. We know it's on Mainnet. So there it is. And then contract address. This is where we can start doing a little research. So let's go to Etherscan and we'll type in Crypto punks.
00:11:50.510 - 00:12:16.178, Speaker A: There it is. And we're going to get the smart contract address. That too small, that might be too small. That's fine. We'll be here just for a second and then we're going to go to Miniscan XYZ. And here I love miniscan. It's incredible because you're able to select a smart contract address and find relevant subgraph information really fast.
00:12:16.178 - 00:12:48.474, Speaker A: All of this information you may need for your subgraph, some you definitely do for depending on the smart contract, depending on the chain, there's different interactions that you will have depending on what is supported on a certain chain. But a lot of that information is just right here. Do you want the abi? Do you want the code start block? All of that is here. Do you want the name? It's all here. Why would you need this? Let's go back to the terminal and find out. We're going to copy the terminal smart contract, paste it in, it's automatically going to be the Abi and this is okay. Sometimes it fails just due to internet issues just through the chain.
00:12:48.474 - 00:13:30.282, Speaker A: This literally was working all day today and now it's not no big deal because what I did was I have the Abi here. So I'll pop this open. Very nice. There we go. Control A, control C and I'm going to pull up a new window and we're going to folder list group twelve reports what will the demo, that's where we are at and we're going to open that up and we are going to create a new file and we're going to list Abi JSON. This is what you do if your Abi is not able to be gathered. And now we have it right there, right click and then you have the path.
00:13:30.282 - 00:13:50.818, Speaker A: So that's what this CLI is asking for. Oh, so close, so close. Copy path. There we go. There it is. Okay now a lot of times the start block is also populated. But just in case it doesn't populate, depending on the situation at the moment, you have it right there.
00:13:50.818 - 00:14:19.622, Speaker A: Copy and paste into terminal. Okay. Now the contract name subgraphs can index lots of smart contracts all on the same chain all at once. So it's important to name your smart contract by its actual name. You don't want to just have the demo name of contract because if you have 2310 smart contracts, not helpful. So I'll go here. Hey, there it is and copy and from there paste a lot of copying and pasting.
00:14:19.622 - 00:14:56.550, Speaker A: Very convenient from the scanner right there from Miniscam now, this is the, I think, impressive thing. The most impressive thing is when you actually see this occurring, this is the index contracts events as entities, any events being emitted. Remember that little blocked pathway that I showed you where it had subgraph YAML and it went all the way to the schema GraphQL. This is where that connection is occurring. All right. When you just press true right there, you're having this scaffold out and it's connecting all the things in the backend automatically for you to look at all the events in historical data that you can query using GraphQL. So that's all doing that right now while this is occurring.
00:14:56.550 - 00:15:19.994, Speaker A: Let's see. Come on. Any questions so far while this is spinning up? Question. Yes, I'm sorry, a single subgraph. So that's not there. Right now we have a single subgraph for a single chain. You could index as many different smart contracts you want on that same chain.
00:15:19.994 - 00:15:51.706, Speaker A: If you have a different subgraph that'll be for a different chain, then you could separate it like that. You could pipe all those different APIs into your front end and work with it like that. But good question. The initiation or the contract? The second. So wherever you want to start gathering information, you can do that if you want your subgraph. Yeah, correct. The initial deployment of exactly right where that smart contract was initially deployed, it automatically finds it for you.
00:15:51.706 - 00:16:07.274, Speaker A: And there perfect. So now we could add another smart contract. We're not going to do that right now. So we'll say no. And you are welcome to run through these steps here. I like to go back to Subgraph studio at this point. And here, which is more copying and pasting.
00:16:07.274 - 00:16:25.762, Speaker A: Super quick, super easy. You're going to authenticate. First things first. Very nice. And you're going to CD. Just copy paste, copy paste and then graph CodeGen and graph build. Graph code gen is type safety, making sure all those connections that you've built up, let's say you make any modifications to your code.
00:16:25.762 - 00:16:43.702, Speaker A: It's important to keep those connections fresh. And then graph build compiles everything. And you could read a lot about that in the documentation. Totally fine to do that. We're just going to go ahead and graph code gen and graph build what has been scaffolded on the back end. We're not doing any changes, so that's fine. And then we're going to deploy.
00:16:43.702 - 00:17:09.682, Speaker A: Now, just so you know, when you deploy here, you do want to have incremental versioning. And also when it is deployed, you should see the front end of the dashboard also respond nicely. There it is. And it responded very nicely. So the build is completed, it has been deployed. We have our development endpoint that is active right now. It is currently syncing at 73%.
00:17:09.682 - 00:17:55.590, Speaker A: So it's gathering more information takes a little bit of time. Just so you know, when you deploy a subgraph for the first time, it takes about five minutes before it's queryable because there's a certain amount of cacheting going on in the back end, at five minutes it is going to be active. So just be a little bit patient. Right now though, let's go ahead and head back to the presentation as this is getting ready and let's keep on going in the presentation as that's going. So where are we right now? Okay, as that's spinning up, let's go ahead and do a reference for subgraph patterns. You may see these sometimes, you may not see these sometimes, but these are relatively common. And then we'll see if these exist in the actual boilerplate subgraph that we spun up with our graph CLI.
00:17:55.590 - 00:18:38.000, Speaker A: And then we're also going to compare that to a very well developed subgraph as well. And you'll be able to compare and contrast something that's relatively simple, that is a boilerplate one to something a little bit more advanced. So if you are indexing a crypto punk, if you're trying to gather that you're going to pipe that into an entity and an entity is in the front end, really what you're going to be querying. So what buckets do you want to create? Generally speaking, you are going to create a contract entity, an account entity, NFT entity trait entity metadata and event interface. These are like different buckets that your subgraph will create and pipe the data into. And let's go ahead and go back to the actual code and see if that's the case. So head back to Visual Studio code.
00:18:38.000 - 00:19:06.226, Speaker A: And there it is. Nope. Okay, so let's look at these buckets right now. Everyone, let's say hey, schema GraphQL, hey, these were automatically created for us. We have an entity that is an assigned entity, a transfer entity, a punk transfer. These are automatically created and these reflect the events that have been emitted from the actual smart contract. Just for the sake of this demo and just for the sake of being focused, I'm going to focus on the punk.
00:19:06.226 - 00:19:41.746, Speaker A: Let's make it big so everyone can see the punk transfer entity. Let's just focus on that and we're going to trace that all the way into our actual root level of the smart contract. So we have this entity right here, this punk transfer. How did this get here? How did this punk transfer entity appear here? Well, remember, if you take one step back from the different blocks that we were just at, it went from the schema to the mappings. We got to go to the logic and that's going to be in the SRC folder. So let's look and see how this punk transfer event is actually getting populated. There it is.
00:19:41.746 - 00:20:09.450, Speaker A: Okay, we have export function handle punk transfer. So when a punk transfer occurs, this handle punk transfer handler triggers and there's the event right there. You can see everything light up right there very nicely. Thank you. Vs code and an entity begins to be populated and we see this event right here. This event params from this is an event right here that is being emitted. And the from from the chain is going to the entity, also named from.
00:20:09.450 - 00:20:28.018, Speaker A: Very nice. We have event params two, and then that's also going to the two event params punk index. That's also going to the punk index. Also we have event block. Events also carry block information that's carrying the number. It's all just being piped right into this entity and it's being saved. All right, that's all that's happening.
00:20:28.018 - 00:20:51.198, Speaker A: It's simply coming from the event and being piped into our entity. Right there, the entity is being saved. I'm going to slow down. Got a few minutes. Any questions so far? Am I going too fast? Are we good? We're good. Question. Yes, it's just a way of looking at the entity and saying, hey, this is how it's organized.
00:20:51.198 - 00:21:03.950, Speaker A: I'm going to send a query to those entities. Yes, great question. We'll get to that in just a second. So here we are. We have our handler. That is, we're going from the front, which is the schema. Now we're going one level deeper to the handle punk transfer.
00:21:03.950 - 00:21:26.886, Speaker A: How was this actually defined? Well, that was in the manifest. Let's go back to the root and we'll go to the subgraph YAML, which is the manifest. And this is really how your subgraph is defined. It's really important information. We have everything that we put in the CLI, the address, the crypto punks market, the start block, important information. I'm not going to go over mapping it's a little bit right there. But let's look specifically for the event handlers right there.
00:21:26.886 - 00:21:50.140, Speaker A: And then there it is, the handle punk transfer. And it's looking at the event from the smart contract indexed uint. And we have a uint right there. We have a few different informations. Right there. The address that's really all the way to the front of this diagram that I had a second ago. Let's go back here.
00:21:50.140 - 00:22:18.550, Speaker A: And here it is. So we just went you could look at this from back to front or front to back. And you'll need to do that regularly when you're developing on subgraphs because you'll be interacting back and forth. So let's keep on going and let's look to see are there any Immutable events? We're running low on time. We're going to keep on going. This is something that you'll see regularly. Immutable events are important for just keeping logs of straight up blockchain information.
00:22:18.550 - 00:22:50.746, Speaker A: If it's in blockchain information, you should keep it Immutable because you're simply just keeping a log. That's just something you should look into. Aggregation entities. Entities that have a lot of information from various sources on the blockchain you want to have on a single entity like a contract might have information that is being aggregated. Definitely have that in there. And linking entities to have a little bit more power on the front end you could link entities using one to one or even one to many or many many to relationships and also reverse lookups. You also want git or create helpers because assembly script needs null checks.
00:22:50.746 - 00:23:30.218, Speaker A: Just check on those and there's a few other tips and tricks. So document your schema well. Let's go into that really quickly as well so we could see how important that is. When you document your schema well that allows people to really understand what they're querying. And let's go ahead and go into a subgraph that is now published on the Graph network that is well designed because remember, the Graph network is not just indexers, the Graph network has subgraphs. Those subgraphs are also part of a marketplace. Let's go find a subgraph that is also indexing the CryptoPunks smart contract in a more built out way.
00:23:30.218 - 00:24:00.022, Speaker A: So we're going to go to the Graph.com and explore and you can see all of the subgraphs that are currently active. We just spun up a subgraph and we haven't published it yet. But now these are all published and what we want is a crypto punks subgraph that is currently gathering information. There we go. So we can see a few different crypto punks subgraphs. Which one do you want to choose? Generally speaking, the one with the most signal, generally speaking, that is being incentivized by the marketplace itself.
00:24:00.022 - 00:24:26.638, Speaker A: That is the GRT utility token that is incentivizing. This right here. So we're going to choose that one and you can see it's gone through a few different versions. We can go into all of this but what we really want to do is go to the playground and also from here we want to go, let me go back. We want to go into where is it? There it is, the actual GitHub repo. All right, so we have the GitHub repo. We're seeing how this is being built and we can also query it.
00:24:26.638 - 00:24:53.154, Speaker A: Let's go ahead and take a look at the GitHub repo. And see here the Schema GraphQL which is really what you're querying. You're sending your queries to this. These are the buckets. Remember that. Okay, so remember we had the punk transfer entity before that, we were tracing that. Well, this developer here, he had the kindness to actually put in the actual things you're querying.
00:24:53.154 - 00:25:33.486, Speaker A: So if you're looking at a let's not look at interfaces, let's look at an entity. Here we have an aggregation interface right here where we have an account and there's lots of different properties on this account. And he's done such a nice job with the mappings and also with gathering blockchain data and organized it so well that when you type in a query, a GraphQL query to the account entity, you know exactly what you're going to be querying. Do you want to know punk transfers by account and you put in the account number. You can get that right there. It's very nicely well documented. From this, which is of course, we don't have documentation on our actual not abi JSON.
00:25:33.486 - 00:26:18.766, Speaker A: We don't have it on our schema GraphQL because this was just boilerplate. But when you're building out, have some nice documentation, tell developers what you are actually doing and that helps them from there. Let's go ahead and go to the next part of this presentation where there we go. We can compare queries with two different subgraphs. We have our boilerplate subgraph that we spun up and we have a more advanced subgraph that we spun up. And then from there well, what type of questions can we ask to this subgraph? Could we ask some questions to this basic subgraph? Sure we could. Or could we ask some more advanced questions? And if you guys want, we have this presentation right here with all of these questions where you could practice and see okay, well, if I could look at the schema and trace it all the way back to the blockchain, that would be helpful on your subgraph.
00:26:18.766 - 00:26:45.066, Speaker A: Or if you would like to use the more advanced subgraph, some of these questions can be answered by the more advanced subgraph. Let's just go ahead and do the first one just to do that. And then you guys on your own are free to go through this on your own. Tell me about CryptoPunk number one's, transfer history. So what we're going to do is go to subgraph studio. So we have this setting up right now, and we'll go here on the right. And this is our little explorer right here.
00:26:45.066 - 00:27:09.730, Speaker A: We can send some test queries. We're not, of course, going to the API endpoint. And remember that punk transfers event that we're looking through from the very beginning. Let's go ahead and look at that. We have the punk transfers event. And what we want to do is we want to go ahead and let's go ahead and look at punk transfer ID. We want the puke transfers.
00:27:09.730 - 00:27:42.910, Speaker A: There we go. Punk index and first ten where the punk index is equal to one. Okay? And we want to see the punk index, which is the first punk one right there. It's the first ten right there. And we want the punk index. We want the ID, we want to, we want from let's see where it came from, the timestamp and why not? Let's get the transaction hash two demo gods. There we go.
00:27:42.910 - 00:27:52.606, Speaker A: Oh, dang it. Let's go ahead. We've been having that happen. There we go. So I pulled this up earlier. We're having Internet connection issues sometimes. And here it is.
00:27:52.606 - 00:28:13.410, Speaker A: We have this punk transfers, punk index number one, where you have the ID and then to and from and the block timestamp all the way through, all the way from the chain. And then you're able to organize. That the front end. There we go. Okay, that's the end of the presentation, everybody's.
