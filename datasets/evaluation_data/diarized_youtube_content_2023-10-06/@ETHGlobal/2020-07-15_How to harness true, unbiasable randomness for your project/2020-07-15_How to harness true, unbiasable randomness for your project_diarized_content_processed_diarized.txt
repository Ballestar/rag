00:00:00.410 - 00:00:01.374, Speaker A: Super quick.
00:00:01.572 - 00:00:30.374, Speaker B: Yeah, it goes directly to YouTube, which is perfect because we don't have to save it to our computer. Then upload it. All these servers are just probably in the same server, even the same data center. It just stays there, but yeah, it's really convenient. Awesome. All right, again, sorry for the delay. Anybody who's watching this live on YouTube and those in the zoom call, but we'll get started.
00:00:30.374 - 00:00:59.838, Speaker B: Welcome, everybody, to this hackerfest workshop. Today we have Alan and David. They're with the protocol labs team. They work on some specific things within that part of the ecosystem, and they'll talk about that just after I pass it over to them. But before that happens, let's see if there's any logistics for Hack FS. Today is Wednesday, midweek in week two. Everybody should have had their check ins, their first check ins.
00:00:59.838 - 00:01:57.294, Speaker B: Already you've been putting Cohort channels in the slack if you aren't familiar with what that is, or you were surprised to find yet another channel. That's the way we keep track of teams and projects that they're working on so we have a way to track chunks of hackers and their teams and the progress that people have been making throughout the week. So that's what Cohorts are for. If you haven't already, go to your hacker dashboard and that's where you'll actually be inputting your weekly check ins, and then that ends up in our back end. So make sure you're putting it in both places, both your cohort channel and your hacker dashboard. We have a couple more events there's, I think two office hours tomorrow with some of the sponsor teams. I would check that out in the Hack FS schedule channel, and you probably all have received several calendar invites, so if you haven't, check your spam.
00:01:57.294 - 00:02:31.930, Speaker B: Maybe it's going there. Hopefully not. I think that's about it. All the logistics stuff I had to cover for Hackfs, it's been great. This week is a little bit more relaxed than week zero and week one. So I know Andrew and I are happy, but we're glad to be continuing to provide workshops and running these sessions for everybody, and we can turn it over to Alan and David. Do you want to give an intro to yourself and what you're going to be talking about?
00:02:32.080 - 00:02:54.782, Speaker A: Of course. Thank you so much. Hi, everyone. Really excited to be here. If you are looking for some runner ness, you are in the right place. Welcome to the vRAN Workshop, where you will learn how to harness the power of true, unbiaseable runner ness for great, good, and fun with friends. So my name is David, or David, whatever you prefer.
00:02:54.782 - 00:03:28.142, Speaker A: I'm a research engineer at Procolabs, working on the research group Resilient Networks Lab, resident lab for short. I've been with Procolse for five years now. And when I joined, I joined to work specifically on the IPFS project and the lead P to P project that you might have heard about or maybe even used, like twelve weeks ago. I joined this new project, the Dran Project, to take it from a research experiment to a production service and you will learn more about it. Alan, do you need to give us a quick introduction about yourself as well?
00:03:28.276 - 00:04:07.866, Speaker C: Sure thing. I've been working for Protocol Labs for around, I guess three years now. Before that, I had my own business with my friend and we were building crazy things for entrepreneurs that had little amounts of money, but also organizing events and meetups and things in London, UK, IoT stuff and other application things. When I joined Protocol Labs, I was mainly in the web and GUI team, and then I kind of transitioned to doing JS IPFS and leading that for a while. And now I'm just guns for hire on whatever project, and now I'm working on Dran with Divi. So that's me.
00:04:08.048 - 00:05:03.982, Speaker A: All right, thank you. So, yeah, Dran is a distributed randomness beacon that offers you verifiable, unpredictable and unbiased random numbers as the service. So it's kind of unique in its kind. But before really going into the details of DRAM, start with a quick motivation and understand why runner ness is important. And so runner Ness has a ton of use cases in all kinds of applications that we use and all kinds of businesses that we rely on. Things from lotteries, election event audits, controlled trials, even in the protocols that we use. From the ability to choose random peers for our gossiping protocols, the ability to have random numbers that get used for cryptographic protocols and much more.
00:05:03.982 - 00:06:33.978, Speaker A: However, despite this being such a useful thing and a used thing, the reality is that historically, having pure and secure randomness is incredibly hard. And the fact that we have used less than secure randomness in the past has led to many attacks, many scams that were able to be possible just because the randomness was not secure. That led to either stealing money or even just taking services down. Additionally, while we are in the hack FS the Ethereum IPFS and Filecoin hackathon, you might know that runownness is really critical for Blockchains. So all kinds of cryptographic protocols used in blockchains from proof of stake replication, retrievability verifiable computation, proof of stake require runnerness, and despite it being such a requirement, there still isn't a one size fits all solution for runners that is also unbiaseable and available. Most protocols, most proof of Stake protocols attempt to solve it, but at a big cost by adding a lot of complexity and brisalness to the protocol. And often the way that it gets done, it gets so integrated with a lottery use case on the blockchain itself that it's not really usable by the applications that are riding on top.
00:06:33.978 - 00:07:32.566, Speaker A: Most of the solutions that exist today took years to produce, but they still have yet to stand the test of time, so they haven't been battle tested enough. The randomness that gets used in these protocols is for the random leader election, which is a hard problem. You might be familiar with some solutions that get used in different blockchains from proof of work, which is probably the most widely used one, but as we know, it's extremely expensive computationally and financially. And also the economies of scale typically forced some degree of centralization on the network. Then there's on chain runners that gets often used for proof of state protocols. However, from what we can gather, most of the variations out there are actually still biasable by agents such as miners, so they are not 100% secure. One thing that is very promising is verified delay functions.
00:07:32.566 - 00:08:33.890, Speaker A: And so a verified delay function is just a function that executes for a period of time and that you are able to prove that the function executed for that period of time, not more, not less. That is going to be very useful because we can combine that with a zero, like a ZK snark, a circuit in which we can have something that is completely a black box, opaque, that generates randomness at every epoch that everyone can verify. However, the theory is being developed right now. The research is being developed. There is nothing that exists in practice despite a lot of R and D and we believe it's coming. But it's still probably like two to five years away, if not more. The reason why, because this problem is so hard and because existing solutions are either brittle or expensive or not ready yet, there is a reason why protocols such as Ethereum Two and File Point are moving to separate chains to get their randomness sources.
00:08:33.890 - 00:09:41.810, Speaker A: And so in addition to that, we actually believe, Percolabs and the DRAM team, that as Internet users, as Internet builders, we need a randomness service. In the same way that we have a name service like DNS, same way that we have a time service like Nptp PKI and Certificate transparency. We also need to offer a core service to the Internet that offers a secure randomness source. And so this is where we actually enter Dran because Dran is an unbiaseable randomness beacon that is tested, audited and ready to use. So how does Dran work? The simplified version there's a lot of dark magic happening underneath the hood, but the simplified version is a Dran network is composed by two or more Dran nodes and ideally these nodes are independent and then the network itself is assembled in two parts or phases. There is the setup phase where there is a distributed key generation ceremony. This is where before even generating any randomness nodes get together and they agree on a threshold parameter.
00:09:41.810 - 00:11:06.046, Speaker A: So the threshold parameter is the number of nodes that need to be online in order to generate randomness. So imagine like the network of ten, if you set up the threshold seven, then as long as seven nodes are up, you can generate randomness and then you also agree on the period like the epoch. So if you are going to generate a randomness value at every 30 seconds, at every 25, at every minute and so once they agree on these values, they generate their own key material and they create their signature so that they can verify other node signatures and complete the distributed key generation phase. Then it goes into the second phase and this is the final phase where runownness can be generated forever. And so in a runownness generated regeneration phase, we basically at every epoch, every node will generate a partial signature using their key material. And once there is a threshold of nodes that collects enough partial signatures from other nodes, they can smash them together and create a single signature that then gets broadcasted to the world and it's where with that single signature that nodes will verify that it was indeed generated by the partners from the network. So it's verifiable and we'll get the renderness by ashing the signature.
00:11:06.046 - 00:11:59.394, Speaker A: So the renderness will be the ash of this signature and this is just a typical BLS signature that you might have heard about. If you want to understand the guts and the math that happened inside Dran The Dark Magic there's a very interesting talk on Proclab's research website. You also have the link here down below where Nicholas, the author of Dran, actually goes into the detail of how this works. So if you are into that, definitely check it out. With this construction, what we get is a network that is decentralized, where the nodes are operated by different entities and there is no central point of failure because one node can fail. As long as we have a threshold of nodes, the network can continue to operate. It's unpredictable because the randomness is like multiple partial signatures coalesce together.
00:11:59.394 - 00:12:42.400, Speaker A: So only when you have all these partial signatures you actually can see the value. So no node can actually predict what is the next value because it will need to collude with the other nodes. It's unbiaseable. So even if there is a node that is malicious and can attack the other nodes to get their key material, there is no way that the runnerness would change. What they could do in that scenario would be just like to predict the future. But in that case there is a way to do a resharing session where the key material gets rotated and then it's verifiable. Like clients can verify that the runnerness came from exactly the network that they trust, that was generated at the precise moment that they wanted and they therefore can use it for their application.
00:12:42.400 - 00:13:40.334, Speaker A: If you are interested on understanding how this works underneath and what is the threat model, we actually have all this information available right now in our beta website where you can understand what is the threat model and why we are able to make the claim that these properties are there. Well, this is D Rand, the protocol and the project. But then there is D Rand, the network. And you might have heard about the League of Entropy. So the League of Entropy is the first incarnation of a Dran network that is operated by these multiple partners. And the League of Entropy had an amazing launch with companies like Cloudfare, Kudowski Security, C 40, T, PFL University, Chile, and Percolabs joining to have a network that can then generate run rest that could be used by other projects. And apparently my screenshot is still loading.
00:13:40.334 - 00:14:23.598, Speaker A: Thanks. Google slides. But no worries, you'll see it on Alan's part. I was just like showing fresh randomness there. The next point is really the network keeps growing, so the network becomes more and more secure as more partners join. And so we went from the previous partners I already talked about to include ECL ChainSafe, Truffle, Emerald, Onion, Ethereum, PTSP, Cello, and many more are joining as we speak. And additionally, now that this network is moving from a research experiment to a production service, we actually are getting the first production user, which you might have heard about it, it's called Filecoin.
00:14:23.598 - 00:15:20.270, Speaker A: So Filecoin is going to be the first production user of the Drand protocol and the League of Entropy service. Filecoin decided to do that so that he has a secure and unbiaseable randomness source for the random leader election problem that exists, or the random leader election challenge that exists inside the Filecoin Protocol. And so we have been getting the Dran project ready for this big user and for this big launch. And so we have been working to get the version 10 ready. And I'm really happy to share with you all that it has been launched this month, actually like last week. So when you install Dran, you're already using the latest version, version 10. And what got included with version 10 is that we upgraded the network from a single layer to a tree layer.
00:15:20.270 - 00:16:00.762, Speaker A: So now we have three layers where the first one is just like the DRAM nodes connecting to other DRAM nodes. And they are protected like there is no one from outside Internet that can connect to them. And this is where the runner mess gets generated. Once the runner mess is generated, it gets pushed to the distribution layer. And the distribution layer are multiple CDNS like Cloudfare CDN, Cloud Front, and even like leap peer to peer pub sub relays. So that we have multiple transports to get the randomness to clients depending on their geographic location and network conditions and so on. And additionally, there is a client network which in addition to just acting as clients, pulling the randomness from the network, they can also help each other by being pub sub relays.
00:16:00.762 - 00:16:46.106, Speaker A: And so, like, a client can also share the remnants, broadcast the remnants to other nodes. We deployed a network observatory. So this is a way for us to measure the quality of service that Dran is offering to the network. And we have multiple probes all over the world that are always taking samples and measuring what is the latency from randomness being generated to randomness being received. And one thing that we are really happy about is that we managed to get a 400 millisecond delivery boost to the nodes in China, thanks to the lipid to peer pub sub relay. So we managed to get a 400 millisecond speed boost in comparison to the popular CDNS. We also have network monitoring, so we are now monitoring all the nodes.
00:16:46.106 - 00:17:18.774, Speaker A: And there is a status page that you can check to see how live the network is. There is a new documentation website right now. It's available on beta Dran Love. We are sharing with this group, with the ACFS group. We haven't volunteered to the world yet, so please just know that when you tweet about it. And what you can expect is that there will be a League of Entropy mainnet upgrade coming really soon. And so this upgrade, just to be very clear, is that there has been a League of Entropy Maintenance running for more than a year now.
00:17:18.774 - 00:17:56.406, Speaker A: We launched a League of Entropy testnet to test all of these latest features and we are going to do the actual launch of the upgrade very soon. Nevertheless, don't despair. You can actually use the League of Entropy testnet just fine. It's literally a replica of the mainnet anyway, so you can use the testnet to build your applications while you are in the hack FS hackathon. So now, with all of this, let's get into the middle of this workshop, which is actually the fun demos and hands on material that Alan is going to walk us through. Thank you. And I don't see questions so far.
00:17:56.406 - 00:17:57.378, Speaker A: Go ahead, Alan.
00:17:57.474 - 00:18:02.520, Speaker C: Well, thank you, David. Okay, so are you ready?
00:18:04.330 - 00:18:04.694, Speaker A: Okay.
00:18:04.732 - 00:18:49.894, Speaker C: You will look ready, I'm sure. Okay, now you know a little bit about what Drand is. We're going to use the Go and JS clients to get hold of some of that box fresh random goodness from the Drand nodes that the League eventually run. And so today, what we're going to do is mostly get randomness from the JSON http API. But we're also going to try and get a live feed of randomness using Libhtp Pub sub if we have time at the end. So this is a workshop, so you can try and code along with me. There's a lot to cover, so I'll go reasonably fast, but don't worry if you get lost or can't follow quick enough, it's fine to just watch and take it in.
00:18:49.894 - 00:19:20.190, Speaker C: I will publish or give the Walkthrough the recipe that I'm using for all of the work that we're doing at the end of the workshop. So you are welcome to just watch. That's fine, too. All right, so let's get on with it. Let's get some information about the chain of randomness. And we'll use the Go client for this. And so just to explain about the chain of randomness, dran produces this chain of randomness and each new beacon points back to the previous beacon.
00:19:20.190 - 00:20:03.294, Speaker C: And so when I talk about getting hold of the chain information, the kind of information that's useful to us is the period, the period between beacons. So every so often, randomness beacons are generated and emitted. And so knowing the time between them is useful. Also the genesis time, the time that the chain actually started. And with the period and the genesis, we can then say, well, the next randomness beacon is expected to be generated at this point in time. So that's useful too. And then the public key is interesting chain information because that actually allows us to verify that the randomness beacons that we get hold of are valid and good.
00:20:03.294 - 00:20:35.078, Speaker C: All right, let's get going. I'm going to share my screen now, so hopefully this will do good. You should see the DRAM website here. So this is, like David said, it's at Beta Dran Love at the moment. It will be available at Dran love soon. If you head on over to the developer section, you will see there are documentation for the two client libraries that we're going to be using today and also for the HTP API. It's super simple.
00:20:35.078 - 00:21:04.702, Speaker C: There's only three endpoints, but there's documentation for that as well. But we're going to use the client libraries today to get hold of that randomness, which is going to be fun. So let's start. Let's get coding. First of all, what I'm going to do is make a new directory for this. You'll need go installed. If you don't have it already, if you don't have it already, then probably now is not the time to go and install it, but maybe wait till the JS part and then you can do that.
00:21:04.702 - 00:21:26.214, Speaker C: But if you do have Go installed, then make a new directory in your Go path. Mine is if you're anything like me, it's at the default path of Go folder in my home directory. So I'm just going to create a new directory. I'm just going to open that up in my favorite editor. So here we go. Here it is. Cool.
00:21:26.214 - 00:21:55.186, Speaker C: And first thing we need to do is I'm going to move this, move it over here. I'm going to make this all a little bit bigger so you can see little bit bigger. Let's not get crazy now. So go mod in it. Let's just create a new Go module. And then after we've done that, what we're going to need to do is get the Drand dependency using GoGet. GoGet GitHub.com
00:21:55.186 - 00:22:26.762, Speaker C: drand. Drand. All right, so this is actually the whole of Drand, but it has the client in it as well. What we need to do next is create a main Go file here. And once we've done that, we'll type package main at the top because that's what you need. We're going to import this Drand dependency that we just installed. So that's what I just typed here.
00:22:26.762 - 00:23:02.210, Speaker C: But we're actually going to import the client, which is at client, and that is the main client. But we're mostly going to be using the Http client. There's multiple different clients. It works over gRPC. And as I said earlier, Lippy to P, we're going to use Http mostly today. These commas shouldn't be there. All right, so next up, if you're following us along, we're going to have a constant we're going to have our chain hash.
00:23:02.210 - 00:23:37.890, Speaker C: And I've got my handy notes of the chain hash. All right, so chain hash, let me explain about chain hash. The chain hash uniquely identifies the randomness chain. So it's a hash of the public key, the genesis time, and the period that I was talking about. And what it does is we pass it to the client and the client will actually ask for the chain info and then use that hash or hash that chain info and compare it against the hash that we give it. And that allows the client to verify that it's talking to the correct randomness chain that we expect to be talking to. So it's really useful.
00:23:37.890 - 00:24:25.358, Speaker C: And the information that it gets, it will also get the public key and it can use that to verify the beacons that are emitted from Drand. Next up, we need some URLs of Http endpoints that our HTP client is going to contact today. We're going to use just free URLs of League of Entropy. So protocol outs are part of League of Entropy, and we have a testnet running at the moment with free endpoints in various different regions. So we need a car. We're just going to have URLs, and that's a slice of string for now. And I have those URLs written here.
00:24:25.358 - 00:24:47.190, Speaker C: Here we go. So these are the URLs that our Http client is going to connect to. There's three of them. There's one in the US. There's one in the EU. There's one in Singapore, I think. Cool, right, once we've got those URLs, right, let's start actually, let's try and instantiate a client.
00:24:47.190 - 00:25:13.682, Speaker C: So we need a main function. And first thing we're going to do is convert that chain hash that we've got as a string into a slice of bytes. The chain hash is actually Hex encoded. So we just need to use Hex decode. Decode string. We're going to decode that chain hash. There we go.
00:25:13.682 - 00:25:57.418, Speaker C: So my editor will have imported encoding Hex for me, which is super useful, decode string. And then we're going to instantiate our client. And for this, we're going to use client wrap. It takes an array of clients and then a bunch of options. We're going to use the Http four URLs helper function, and that takes an array of URLs and creates a number of clients, or as many clients as the URLs you've passed it. So I'm going to pass it. Those URLs going to pass it, that chain hash.
00:25:57.418 - 00:26:43.274, Speaker C: And then I'm also going to use with chain hash. Okay, now let me explain this just a little bit more. So what Client Wrap does is it creates a single Dran client from a set of concrete transport specific clients. And what it does is it adds failover validation and caching. And so this array of slice of clients that we pass it in here can be of the same type. Like in this instance, we've got multiple Http clients, but there could be different types of clients like that. There could be gRPC clients or there could be pub sub clients looking to be pub sub clients.
00:26:43.274 - 00:27:26.602, Speaker C: And the idea being that if one doesn't respond, then it will fail over to a different one. But also it periodically speed tests these clients so it will ask the fastest client each time for the information. So my server, wherever I'm running this is kind of in the US. And it's likely to be using this endpoint most of the time, but it will test these other ones periodically to ensure that they are not faster. So that's what client wrap does. That's what it's doing with chain hash. This is passing in that chain hash that we had up there.
00:27:26.602 - 00:28:14.710, Speaker C: If we wanted to, we could use Insecurely. Insecurely, I don't recommend you use this unless you're in development because it disables this check that the client has to ensure that it's talking to the correct randomness chain. So we're not going to do that today. We need the chain hash. The idea is like, you either pass the chain hash or all of the chain information under normal circumstances. And it's easier to have the chain hash than it is to have a kind of file or some sort of plate store of all of that chain information. All right? So once we've got a client and we've instantiated it, then we can just use the info endpoint to grab hold of the chain information context.
00:28:14.710 - 00:28:43.940, Speaker C: We're just going to use the background context. We're going to assign that to info. We're going to ignore errors in all of this and hope that everything works first time. So hopefully that'll go okay for me. And then we're just going to print out a bunch of all of this chain information. That's interesting. So we're going to print out the public key, public key plus B.
00:28:43.940 - 00:29:33.170, Speaker C: We go public key. We're going to print out hang on, we need a few of these genesis. We're going to print out the genesis time, the period and the chain hash. So genesis time, as I said, the genesis time is the time at which the chain actually started. So that's expressed in seconds. And so all I'm going to do is convert this into a time so that when it gets printed out, it's going to print out nicely for us, period. As I said is the time between beacons.
00:29:33.170 - 00:30:25.070, Speaker C: This comes back as a duration. So we can just print this out and it will come out nicely. Nice human readable. And then chain hash, we're going to print this out because we should be able to compare it with the chain hash that we got up here and they should be the same. So chain hash, when it comes back to us is just a slice of bytes and we're just going to encode it to a string in hex info hash. Okay, so if I save that stuff, then it will have imported context, format and time. Got rid of all of the red stuff.
00:30:25.070 - 00:30:59.258, Speaker C: This is why is it not in my go mod file? Yes, we have okay, so in theory, I should just be able to run this now. Run name. Okay, great. So we can see here that we've got the public key, we've got the genesis time. This was 25 May. Yes, 25 May. And the period for the testnet is every 25 seconds.
00:30:59.258 - 00:31:18.310, Speaker C: So every 25 seconds we'll get a new beacon generated. The chain hash eight, four, B, two, A, four, B, two, two is exactly what we expected. So everything is working correctly. All right, that's fun. But there's no randomness here. This is just information. Let's get some randomness.
00:31:18.310 - 00:31:53.630, Speaker C: What we can do is use client get. That takes a context, like all of the functions in the client. And what we're going to do, the second parameter is the round rounds start at one. If you specify a zero, then you'll get the latest round. So you don't need to know what the latest round is. You can just say, get me the latest one, and it will get you that. I'm going to assign that result to a variable.
00:31:53.630 - 00:32:44.394, Speaker C: I'm going to ignore the error again. And then we're going to print out that randomness. We're going to print out the round number that is here we go, latest round function. And we're going to print out the actual randomness that we received as well. And we're going to encode this is, again, just a slice of bytes. So we're just going to use hex encode string again to make this reasonably readable. Okay, so that's how you get randomness.
00:32:44.394 - 00:33:27.530, Speaker C: How do you get the latest random value from Drand? So if I run this here we go. So the latest round, we're on round 175,581 and the randomness is all of these bits and bytes there. Cool. All right, so how do I get a specific round? Well, it's kind of obvious. We can get an old round by just specifying the round number in the call to get. So if I get 12345, which we have done already, and we'll print that one out, here we go. Old round, old round.
00:33:27.530 - 00:33:47.510, Speaker C: Save that, run it. We should now see the latest round has incremented by a couple. It was more than 25 seconds since I last run. This. And the old round 12345 has this value of randomness hooray. All right, it works. That's how you consume randomness.
00:33:47.510 - 00:34:18.320, Speaker C: Now that's kind of interesting, but what's even more interesting is getting a live feed of randomness as it occurs. So let's do that. Right, so we can use watch because the client has a watch function and we can use that in a four range loop. So I can use for rand equals range C, watch. That's cool. Context background. There we are.
00:34:18.320 - 00:34:49.980, Speaker C: So every time a new randomness value is generated, it will be assigned to that variable there. And I'm going to print it out just like I did for these other ones. New round, new round. And and this is I called this rand here. Rand. Cool. So then we've got and then what I'm going to do is I'm just going to put done when we're done.
00:34:49.980 - 00:35:33.320, Speaker C: Okay, so now I should be able to run this and we should get not sure what that is, but here we go. New round. So five eight six is this round five eight seven just got generated. And so when I watch, I should get the current round straight away. And then when the next round is emitted, then I should get that round. And so in 25 seconds, because we know the period between rounds is 25 seconds, I should get a new round appearing here, you should note that watch is kind of best effort. There's the possibility that the channel that it returns will close.
00:35:33.320 - 00:36:06.510, Speaker C: And so if you really care about continuing to watch, you should reopen that watch if it happens to close. But in an ideal world, that will just continue to watch for new randomness and output it as it happens. So, here we go. We've got five eight seven. Not sure what these are, but I'm going to ignore them for now. That's cool. And so if you'll notice, we never get to done because watch never closes.
00:36:06.510 - 00:36:46.080, Speaker C: We've not finished it. So typically in Go, you'll use context to cancel things. So we can cancel our watch when we don't want to do it anymore by using a let's just use a timeout context with timeout. So what we'll do is after, say, 30 seconds, we'll stop watching context background. We use that as the parent and then we can use time second times. Yes, 30 seconds. I said 30 seconds, didn't I? Okay, cool.
00:36:46.080 - 00:37:29.882, Speaker C: And then instead of using the background context, we use this new context that we've got. And then, so basically we should see after 30 seconds, we should see Done printed. And so we get the current round, the latest round, we should see another round because we've got 30 seconds to work with. If we were really quick, we might not have been quick enough, but we might see another round or we might not. Either way, that's how you cancel a watch. If you just bear with me a few moments. You should see this cancel and then there we go.
00:37:29.882 - 00:37:49.070, Speaker C: Done will be printed. All right, cool. That's the Go client. Fun times. Let's do it with the JavaScript client. Okay, so this is going to be fun, possibly more fun. For this you need an index HTML file.
00:37:49.070 - 00:38:17.370, Speaker C: And in that file, just before I start, we have docs for JS client as well. They are, like I said, in a developer section under JS, it's written using Es modules. So it's all fun times. New stuff that works in Dino and Node and on the web. So we're going to just use a HTML file for the purposes of this. It's a HTML. Whoa.
00:38:17.370 - 00:38:57.990, Speaker C: Okay, so that just tells it that it's a HTML file. We need a script tag with a type equal to module. And then from there we need to import our client, import client and the Http client, just like we did in Go. And that comes from any CDN you want, really. It's on JS deliver. So good a place as any, I guess, forgetting it. So this works, this is cool.
00:38:57.990 - 00:39:20.510, Speaker C: And we need that chain hash again. So I'm just going to steal it from over here. Some of this syntax is pleasingly similar. We also need the URLs. Let's grab the URLs, let's put them in here. That's a constant as well in JavaScript. This is just an array.
00:39:20.510 - 00:39:46.040, Speaker C: There we go. URLs. We've got some URLs, got that chain hash. And then what do we need? We need a main function. So I'm going to make an main and then that doesn't get called for us automatically. So I'm just going to call it there. But in this main function we're going to instantiate the client just like we did in Go.
00:39:46.040 - 00:40:24.690, Speaker C: And we use await client. We're going to use wrap again. So you'll notice that the API is very similar. We have capitals in different places. We've capital lovers in Go at the start of the words. So http http for URL There we go. We're going to use our URLs, we're going to use that chain hash and we're going to pass in that chain hash as well to the client.
00:40:24.690 - 00:40:50.874, Speaker C: There we go. Okay, so I'm not going to get the info because it's a similar thing. You can call info on the client. So let's get the latest one again. Latest equals await on C get. And we don't need to pass any parameters. You can pass it zero here, but it's JavaScript so it doesn't matter.
00:40:50.874 - 00:41:35.542, Speaker C: It's fault B, so it will just get the latest if you don't pass it a particular round number. We're going to log out console log. We're going to log out that latest round. Oh man, my typing is getting worse as it goes on, isn't it? Okay, latest round, log out that latest round and we're going to log out the randomness as well. There we go. And in theory, I should be able to just run this. I'm going to go open index.
00:41:35.542 - 00:41:55.380, Speaker C: There we go. Open it up. And I should see a blank screen, as I am expecting. But in the console I should see logged out the latest round on 7560. I should see the latest randomness. So that's all working in JavaScript as well. Hooray with pleasingly similar syntax, we can get the old one as well.
00:41:55.380 - 00:42:24.422, Speaker C: Let's do that. It's fun. Old 12345. Let's do it. Got an old round, 12345. And so in theory, this old round, seven, three, five, F, 6114. If we go back over here and have a look at our go up.
00:42:24.422 - 00:42:42.634, Speaker C: Seven, three, five, F, six, one, four. Okay. They're getting the same information from the same chain. So stuff is working. We can watch in JavaScript as well. I'm not sure if I said, but watch. For the HTP clients, it's actually not a real stream.
00:42:42.634 - 00:43:27.520, Speaker C: So for the gRPC clients, it's an actual stream. It's an open connection that remains open. But for HTP, the HTP client calculates when the next round is meant to be available and then makes HTP request when it's available and then yields it essentially all right. In a similar way, we can use for await C. Watch. Okay, so in JS, when you watch, it returns an async iterable and then we can use that in a for await loop and to do something very similar to what was happening. What was happening in Go.
00:43:27.520 - 00:43:45.234, Speaker C: We're going to log that out. We've got our new round. Happens every so often. New round, new round of this round. Round. Okay, let's have a look. There we go.
00:43:45.234 - 00:44:18.302, Speaker C: So that's the current round and the next round has just come through. It all works. Hooray. What's kind of cool is that? The rounds in JS, when the rounds come through and the client verifies them, that's done using the code that is written in the Go client, it uses WASM. It's compiled to WASM and it's downloaded and verified using the WASM in the browser. So it's nice and fast. A previous iteration with the client was doing that verification in around a second.
00:44:18.302 - 00:44:34.898, Speaker C: Now it does it in between 81 hundred milliseconds. So that's much better than it was. And cool. That's the JS client. All right. Now the most fun bit. This is getting more fun as time goes on.
00:44:34.898 - 00:45:06.320, Speaker C: All right, check this. So we've done some getting randomness using JS, but let's get some randomness and use it in a web application. How do we even use this? All right, so this is our web application. This is our dice roller. It's chosen by a fair dice roll. It's guaranteed to be random when we roll. It sort of does a roll for about 5 seconds and ends up on four.
00:45:06.320 - 00:45:30.120, Speaker C: When we roll again, it does the same thing. So we need to fix this because it's just a four roller. And as David showed in his slides, if you're familiar with the Xkcd, then you will be laughing at this already. Cool. So let's fix this up. Let's go back to let's go to a different project. Here we go.
00:45:30.120 - 00:45:59.818, Speaker C: Dice roller. Here we are. Now I'm just going to start serving this. Let's look here. Okay, so what is this? So this is the HTML code behind the page that I just showed you. There's some style that you don't need to worry about, but it's essentially a div with the dice value on it. There's a button that says roll.
00:45:59.818 - 00:46:49.854, Speaker C: That's cool. And then there's this little script which we're going to start with main JS. And all a script does is obviously it gets hold of that dice element, gets hold of that roll button and then it adds an event listener, a click event listener on that button and it disables the button stops people from pressing a button after they've pressed it once it starts the roll. So we're not going to look at this, but this magicness starts the dice rolling. So all it does is it takes the dice element and it puts random numbers in the dice so it looks like it's rolling whilst we get our random value. And whilst that's rolling, we set a timeout for 5 seconds and then we stop that roll with the value four. So that's what's happening every time I was pressing the button just then and then undisabling the button.
00:46:49.854 - 00:47:22.780, Speaker C: So we're going to fix this so that it works. In using dran. JS for that, I need the stuff I had up before. Let's grab that. I need this chain hash and the URLs that I was using. I'm just going to add them in at the top here. Here we go.
00:47:22.780 - 00:47:40.990, Speaker C: Okay. And then I'm going to import and instantiate the client as I was previously. I just need that import again from here. Import it. And client. Here we go. Here's the client.
00:47:40.990 - 00:48:05.154, Speaker C: Oh, yeah, not there. We're going to put it in here. Instantiate it when we call main. Here we go. So now we've got a client that we can use. Oh, we need to make this an async function. And so instead of this stuff, we're going to keep that remove attribute.
00:48:05.154 - 00:48:48.510, Speaker C: We're not going to stop the dice rolling at the number four. So we're just going to remove that bit. But after we set the dice rolling, what we're going to do is we're going to figure out what the next round number is going to be. So we can do that by next round number equals we can use round at. So this is a function on the client that's available in JS and in Go. But you give it a time and it gives you a round number back. So for right now, it's going to calculate what the round number is, what is the randomness value that has what is the round number of the randomness value that has been generated.
00:48:48.510 - 00:49:36.882, Speaker C: And we're going to plus one onto that because we actually want the next round that hasn't yet been generated. And then what we can do is we can say rand equals get that next round. The interesting thing that happens here is that when you ask the Http endpoints for the next round, you can't ask for future future rounds, but you can ask for the next one. It will block until that round is available. So it won't return until that round has been generated. So I can await on this get next round. And then once it comes in, I need to convert that randomness value, which is big log string of hex encoded data, into a number for our dice.
00:49:36.882 - 00:50:37.320, Speaker C: Right? So say NUM equals we're going to use big INTs because that's fun, right? We're going to say that it's some sort of hex here randomness. And then what we're going to do is we're going to mod that by 20 because we've got a 20 sided dice. So we want a value that is in that range of zero to 20, right? Or one to 20, essentially. But this will give us in a range of like zero to 19, so we're going to add one to that. If I want to use mod and plus, then I have to tell JavaScript that these are big numbers and I can put N after them for that. And then once I've done that, once I've converted the randomness from Drand into a number that can be used in my dice, I'm just going to call two string on it. It was base ten.
00:50:37.320 - 00:51:21.000, Speaker C: And then I can use my current role. Stop. Pass it this number instead of four, and that should, in theory, work, although I haven't demoed this, so we'll see if it actually does work or not. We did a run through and this didn't occur. So I've started this up on localhost 8000, I believe, so it should be here if there's no errors in the awake. Yes, it's true. Okay, here we go.
00:51:21.000 - 00:51:44.350, Speaker C: Okay, async I think that's okay, let's try again. Get out of the way. Okay, that looks like it might have worked. So I should be able to now roll a dice and it should yes. Here we go. Six. Hooray.
00:51:44.350 - 00:52:25.580, Speaker C: All right, that is super rad. And I should be able to there's always a chance that it lands on four and then I'm like, oh, no. So rolling it again. So the interesting thing is it can take up to 25 seconds to roll the dice now. So that's an interesting, interesting so we're on nine, but now we have unbiaseable verifiable randomness driving our dice. No one can interfere with our dice rolling. And you can use this when you need to roll a dice for some board game or something.
00:52:25.580 - 00:52:39.054, Speaker C: So super simplified use case, but you get the idea. Right, okay. Hooray. All right, so how much time have we got left? Okay, not very long at all.
00:52:39.252 - 00:52:41.646, Speaker B: If we go over a couple of minutes, that's all right.
00:52:41.748 - 00:53:17.402, Speaker C: Okay, cool. In which case, the next bit is lippy to be pub sub and getting randomness off the lippy to be pub sub network. I'm going to explain why you might want to do that and then I'll show you. I've got a precanned already done. I won't have to actually code it in front of your eyes thing that I can show you. So I'll do that and then if you want to explain it and if you want to go and use it, then you're quite welcome, but that will hopefully save a little bit of time. Cool.
00:53:17.402 - 00:54:06.934, Speaker C: Okay. So the next bit is kind of watching for randomness over Lib PTP pub sub. So using Lib PTP pub sub as a transport is a means of mitigating risk. If you rely on receiving the randomness that Dran generates, then using different transports with the client gives you alternative means of getting hold of that randomness. And that might be because it's more reliable, but it might also be a little bit faster if you use different transports. So, for example, you might find whilst your Dran client is running an ISP blocks Http traffic to a particular URL, so maybe a different transport can then service your request. Maybe, I don't know, maybe DNS goes down or is sabotaged and pointed to like, a rogue Drand machine.
00:54:06.934 - 00:54:44.840, Speaker C: I mean, that's kind of okay, because if you get pointed at someone and they're generating random values, then you won't be able to because the client verifies the random values and they'll be thrown away, essentially. But other transports will be able to satisfy the requirements. So that's good. And I think David already said that we've observed that actually receiving randomness over lippy to be pub sub is faster than over HTP in China due to the overhead that the firewall adds. So that's fun. So anyway, let's get on with it. Let me show you this.
00:54:44.840 - 00:55:20.242, Speaker C: So, recent one, here we go. So I got this all done. This is similar to what you saw already in the Go client. This bit is new. So previously we had let me show you just here, I've basically deleted this stuff. Now I've deleted that stuff and added this stuff. I've also added this listening address.
00:55:20.242 - 00:55:56.490, Speaker C: So this is a listening address that Libptop can listen on. But the most important thing is these relay addresses. So these are lip to P nodes. That the league of entropy that Protocol Labs are running that you can connect to with Lipita p's pub sub and listen for randomness. Cool. So what I've done is why I haven't deleted this, because what I'm trying to do is prove that this works entirely over pub sub. And so we're going to create a client, or we create a new client.
00:55:56.490 - 00:56:53.774, Speaker C: We create one client and then we create another one. We create this new client and that has no ability to talk over any other transport other than PubSub. And so the reason why this is a little bit weird is because with PubSub you can only receive new randomness. There's no way to ask the PubSub network for the chain info. There's no way to ask for that. So what we're doing is we're getting hold of the chain information from the Http client first, and instead of passing the chain hash, we're going to pass the chain info to the client, which means that it doesn't need to then go and get that chain info so that it can verify that it's talking to the correct chain. And so verifying Pub Sub messages or randomness beacons that come over Pub Sub is extra important because over Pub Sub over peer to peer Pub Sub, the randomness beacons can come from anyone.
00:56:53.774 - 00:57:24.282, Speaker C: Like they're not coming direct from Drand servers or Dran relays. So that's kind of good. So here we go. So we've done a little bit admin here. There's a lip P to P package in Drand which has some helper functions for constructing a host, loading public keys and private keys, sorry, or creating them. But essentially the interesting bit is we've got G client, I've called it G Client. So we're importing Client from Lib P to P.
00:57:24.282 - 00:58:02.950, Speaker C: G is for gossip because that's the flavor of Pub Sub that we've got implemented here and we're using. So we create a new client, we're just using Pub Sub and then we're watching for randomness. As I said before, the interesting bit about this Pub Sub client is that it has no facility to get the info. You can't ask it for any round. Like you can't say give me round number one, because it can only give you back stuff that it receives, it's seen before, has been published to it. So you can ask it. So you can call see client get for any round that you've seen before because it might be in the cache.
00:58:02.950 - 00:59:14.842, Speaker C: But as it is here, you can only watch for stuff, essentially. But typically what you'd do is you'd add this Pub Sub client in combination with a Http client so you could go and get the info and it will fail over to Http or vice versa if maybe the randomness beacon doesn't come through PubSub in time. So it will come from HTP, it will work it out for you essentially anyway. So that's the explanation of everything that happened here takes a lot longer if I just type it out as well. In theory, I should just be able to run this main go and this client, which operates only over lipid to P Pub Sub, should then start receiving. So we shouldn't worry too much about one of these endpoint temporary. Yeah, this is fine because what it's trying to do is the optimizing client that we're using is speed testing all the clients it gets and it's speed testing the PubSub client, which as I just told you, it can't get any old random value.
00:59:14.842 - 00:59:34.734, Speaker C: And for the speed test, it tries to get the first round from the chain. And we haven't seen that over at Pub Sub yet. Okay, so what happened here? Okay, so we got a new round. Oh, we still got our context with timeout. So it timed out after 30 seconds. But this worked. This got the round 175645 over a lib TTP pub sub exclusively.
00:59:34.734 - 00:59:59.450, Speaker C: There was no other way for it to get that round from anywhere else. So I'm super happy. And that is essentially all I have to tell you about the Drand client and I hope you enjoyed it as much as I did. I can take your questions now if we have any time, if anyone wants to say.
00:59:59.600 - 01:00:03.806, Speaker B: That was amazing, great stuff.
01:00:03.988 - 01:00:23.090, Speaker D: I have questions, many actually. So first, how is the period? I guess it is network based because decentralized time or getting a trustable time source is already a big problem. So how does this period.
01:00:25.270 - 01:00:25.682, Speaker C: Come?
01:00:25.736 - 01:00:35.080, Speaker D: So if you get a timestamp, you get an absolute time, how do you come to that? And what is the variation in that?
01:00:36.170 - 01:01:26.902, Speaker A: Yeah, I can take that one. So that is because the randomness comes from a small number of nodes, which are the Dran nodes, and they are all synchronized by just using standard NTP. And so the nodes themselves will generate a partial signature at every epoch. So that epoch gets defined when there is a Dran ceremony to set up the network. And so if it's 30 seconds, then they all agree that at every 30 seconds they generate a partial signature. And so when they all generate a partial signature and that partial signatures get assembled, then that thread and node gets broadcasted. But so the way to think about it is you have a small core of protected nodes that are with their clocks synchronized because it is simpler to have a small group synchronized than try to synchronize the whole world.
01:01:26.902 - 01:02:10.760, Speaker A: Right? And so you are able to rely on that clock time. But when it gets to the client, like that timestamp that you see on the client, you can measure the discrepancy between the previous round and what you just received. And so you receive a round, you measure from here, I should be receiving another round in 30 seconds. And if there is some delay there when you receive it, you can either give that to the latency between the vRAN node network, distribution network, the client, or might be some other issue in the middle. But yeah, I hope I answer your question.
01:02:12.810 - 01:02:21.590, Speaker D: Let me ask a high level question. So it is a permission network yeah. With a setup ceremony. If there is some leak, it's unsecure.
01:02:21.670 - 01:02:48.034, Speaker A: In the setup ceremony. Yeah, if enough nodes well, let's define insecure. So in order for someone to gain a privilege, such as being able to predict the future, they would have to compromise enough nodes, and that enough is N equals the threshold. Right. So if the threshold is seven of a network of ten, then you have to compromise seven.
01:02:48.072 - 01:02:53.486, Speaker D: Yeah, but with a small permissioned network, they could collude to do it's.
01:02:53.518 - 01:03:01.490, Speaker A: Different operators with different interests, with different geographic locations under different but I cannot.
01:03:01.570 - 01:03:03.990, Speaker D: Verify because it's a permission network.
01:03:04.490 - 01:03:12.540, Speaker A: Well, you are verifying that you trust when you accept the league of entropy, you are trusting the partners. Right.
01:03:14.510 - 01:03:14.874, Speaker C: Okay.
01:03:14.912 - 01:03:51.862, Speaker D: But it's interesting because it's a very hard problem. And usually the problem is with this kind of time synchronization, all kinds of synchronization is the communication overhead. And this is why proof of work is so strong, because it solves the communication overhead, because you don't have to communicate to come to consensus. So it scales better in the number of nodes. Of course, it's energy intensive. You said that verifiable delay functions are out two or three years. I'm very interested in that because it's kind of like a proof of work, which is not paralyzable, but it's serialized proof of work.
01:03:51.862 - 01:03:59.942, Speaker D: So you cannot compete. So it would solve the energy problem. Why do you think it's two or five years out? What's so hard on the problem?
01:04:00.076 - 01:04:09.580, Speaker A: That's a great question. And so I'm actually not a VDF researcher. I got that information from the team. That is like doing research on VDF. So that's what they told me.
01:04:09.950 - 01:04:12.160, Speaker C: Yeah. Okay.
01:04:13.730 - 01:04:16.394, Speaker D: Thank you. Great initiative.
01:04:16.442 - 01:04:18.622, Speaker C: Great project. I love it. Yeah. Awesome.
01:04:18.676 - 01:05:06.778, Speaker D: Thank you. One other question, because bring it up. If you have reliable, decentralized randomness that would solve many problems in consensus based systems. But what I don't understand, how can it solve the problem if you have a separate chain? That let's say they have solved the civil problem, they have a permission set of verifiers and they want to use randomness to, let's say, select the leader of the next block. Then they would still have to rely on an external source for the randomness with Drand. And this is, I think, a problem within any kind of consensus system that is closed.
01:05:06.874 - 01:05:14.618, Speaker A: Not sure if I follow, too. You're saying that even after using Dran, they still need to rely in an external source? Or like Dran being the external source.
01:05:14.634 - 01:05:32.360, Speaker D: In the first, you know, look at any blockchain, like Ethereum or whatever, they cannot rely on any external information to come to their consensus because external information is unreliable in the sense that you might not be able to connect to the network. The DNS might be spoofed or whatever.
01:05:33.290 - 01:05:41.210, Speaker A: Yeah, you're right. And so one of the attack vectors is that if the network is down, if there is an outage.
01:05:42.910 - 01:05:43.578, Speaker C: Depending on.
01:05:43.584 - 01:06:56.580, Speaker A: The construction of the blockchain that is using the randomness, it could either halt or could either lead through some uncertain behavior. And so the way that we approach this, falcon actually adds in its protocol ways to be able to make progress even if there is a Dran outage. But then the premise is that Dran by being a distributed network run by multiple parties where you only need a threshold of parties for the network to have liveness and because these parties are running their drama nodes in different infrastructure, right? So we have people running in private clouds, in public clouds, in other data centers there's all sorts of diversity in terms of geographic location, connectivity, infrastructure, hardware there's so much diversity that in order for an outage to be complete, like a complete blackout, essentially you are attacking the whole internet, right? Because now you have to take down all of these other centers at the same time. You have to compromise these organizations all at the same time. And so it just increases the cost of the attack very high. Right?
01:06:59.030 - 01:07:27.078, Speaker D: I guess that separate chains that want to rely on some kind of distributed or decentralized randomness could integrate Drand into their project directly. I think that would be yeah. How many can be in the set of you said it's a small core. How big can be the set of nodes that come to consensus about the randomness?
01:07:27.254 - 01:08:10.998, Speaker A: It can be as big as we want. Of course, when we reach to a big number, then if we were to have 1000 nodes or a million nodes to be part of it, then we have another scalability problem within the small group. But right now we are already over 13 nodes and we seek to increase that number. And so the more nodes we add, the more secure the network is. But also as we increase the number of nodes, we also increase the threshold. We have a way to kind of project what is the best threshold for a network size n. And typically it's like anything between more than half and below three quarters of the network.
01:08:10.998 - 01:09:42.390, Speaker A: So that you have a network that is both secure, that has a very high cost to attack, but also that has a very high probability of having liveness. If you have some safe assumptions such as if you assume that between ten to 20% of the network can have an outage at any point in time because all kinds of services have outages anyway. And then if you take into account and then if there is an attacker trying to compromise nodes how many nodes do you have left? That could be the threshold so that the network has livenets. And then the other thing is in the case of events that someone compromises the network for some reason, let's say that there is a very rich malicious actor or there's not a lot of friends in a lot of companies from different countries, from different industry sectors, right? And is able there is always a way if the network alts for that reason there is always a way to see which nodes stop generating the partial signatures and. Do a reshare or even a new ceremony to kick those nodes out that are behaving incorrectly. And so it's kind of like better safe than sorry. Make sure that have a network as diverse as possible and a very tight monitoring, but in the case of a potential attack, the equivalent to fraud detection, monitor some weird behavior and exclude the weird behaving nodes out of the network.
01:09:43.530 - 01:10:05.126, Speaker D: Okay, so what is the precision of the clock that you get, basically? So are you off by if I connect to one of the nodes and get the randomness beacon, do I have a margin of error of a second, 2 seconds, 5 seconds milliseconds?
01:10:05.158 - 01:10:08.000, Speaker A: You mean from generation to actually receiving it?
01:10:10.610 - 01:10:16.606, Speaker D: I don't know how the time is fixed to anything because there is no absolute time in the sense of yeah.
01:10:16.708 - 01:11:04.266, Speaker A: So from our monitoring so we have this thing that we call the Network Observatory, where we have just multiple probes in multiple geographic regions that are just like receiving the randomness and see how fast they get the randomness from the multiple distribution network. Endpoints. And so it went between 500 milliseconds and one 2 seconds, right? So the slowest would be receiving the randomness like one 2 seconds after. But if you think about it, because the randomness gets generated every 30 seconds, it means that if every node gets the latest number between 500 milliseconds and one 2 seconds, everyone still has like 29 seconds or close to 29 seconds with a value already cached in their node.
01:11:04.298 - 01:11:04.494, Speaker C: Right?
01:11:04.532 - 01:11:14.130, Speaker A: And so it gives you a lot of time for everyone to receive the randomness and ensure that everyone has received the randomness before the next round is produced.
01:11:15.750 - 01:11:25.414, Speaker D: Basically, which entity in the network sets the final time of a randomness beacon? Some leader node or who defines that.
01:11:25.452 - 01:11:51.742, Speaker A: Time think that we are all independent in zoom, right? And so every 30 seconds, I will generate a partial signature. And then when there is one of us and then I'll send a copy to each one of you. Right. When one of us has enough pieces and enough is equal to threshold, he says I mashes them together and pushes to the distribution network. And that's like when others receive it.
01:11:51.796 - 01:11:53.440, Speaker D: And she writes the time.
01:11:56.230 - 01:11:58.898, Speaker A: I'm not sure, maybe I don't understand just the question.
01:11:59.064 - 01:12:18.550, Speaker D: Yeah, well, there is a time associated with the randomness beacon and you say, okay, I collect all the signatures. If I am a node, I have all the signatures that are enough to come to a decision and then I write in the time and send it out. Or where is the time fixed?
01:12:19.290 - 01:12:39.262, Speaker A: I got your question. Now you are asking if the time is the time that is like when the partial signature is created or when the partial signatures plural are assembled. That's a good question. I don't know if it's fresh in my memory. Hector or Alan. Do you actually know right now at the top of your head. Otherwise we can always check.
01:12:39.316 - 01:13:02.840, Speaker C: No, I don't think there's a timestamp that gets saved anywhere for when something is ready. There is a time when it should be, when it's meant to be, when it should generated and then there is a time between that and the actual thing being ready and available to the network. That's just a small amount of time.
01:13:03.290 - 01:13:49.538, Speaker A: Yeah. Because there is a period right. And so independent of wherever your clock is synchronized to, you can always estimate because given that the epoch is fixed like 30 seconds well, in planetary is 30 seconds for everyone. When we have multi interplanetary randomness, that will be different. But as soon as I start receiving randomness I can then predict when I should be receiving the next one. Right, and so this is where we see the discrepancies. Yeah, but I'm also happy to follow more on this question because I see that you asked a couple of times so maybe there's something more that we can just demonstrate.
01:13:49.538 - 01:13:53.634, Speaker A: Okay, if you think us on the swack on the Icafe.
01:13:53.682 - 01:13:56.840, Speaker C: Yeah. Okay, thanks.
01:13:59.530 - 01:14:21.438, Speaker A: Okay. Something about DDFS, but I keep mentioning Juan Stock. Yeah. There was a question brought up here in Chat, just like for the record. Yes. When you are using cryptographic code, definitely make sure that gets audited. You should not just download things from the internet and just trust it.
01:14:21.438 - 01:15:11.760, Speaker A: Because if you download some client library that was manipulated by someone, the best that we can do is make the code available so that you can check it out and audit it, and then we can ash it. And when we publish it to a CDN, we can provide the ash so that when you download the code, your browser can verify the integrity that the code that you downloaded is actually the one that reproduced. And this is one of the techniques used in the web JS world. For the Go world we have signed commits. So you can always git, clone and build your own or just import the library and then build it yourself to make sure that you have the right thing. Definitely always be extra careful when importing anything that has to do some cryptographic verification because if there is someone that is able to mess with that code then could potentially be fooling you.
01:15:12.690 - 01:15:29.730, Speaker C: Yeah, you can do the same thing with JS as well. For a lot of applications you'd bundle up that with your application code. So yeah, it doesn't have to come from a CDN. Yeah, that sounds convenient.
01:15:31.350 - 01:15:33.960, Speaker A: All right. I don't see more questions are people.
01:15:35.210 - 01:15:37.480, Speaker B: I added one more if you want to hit that.
01:15:37.850 - 01:16:31.062, Speaker A: Is there a way for an attacker to affect liveness if it belongs to round n and attackers make sure that the CLI or consumer may not be able to consume. So you are saying or rather than attacking the source, attack the destination. So eclipse the receiving node. And so if you have the power to did I get the question right? Yeah. So if you have the power to eclipse entirely, let's say you have the power to completely shut down the Internet of my home, you will effectively have the power to isolate me from the rest of the network. That said, we are making it extremely hard because let's say that I am in a network that has blocked cloudfare, I can still go to Cloud Front or I'm in a network that just blocked DNS as a whole. I can still use Leap to peer pub sub that doesn't rely on DNS to fetch the randomness.
01:16:31.126 - 01:16:31.354, Speaker C: Right.
01:16:31.392 - 01:16:54.980, Speaker A: And so we have multiple transports to deliver the so it is incredibly hard. Of course, if someone cuts the cable that offers internet to the location where your machine is, then, well, you have other troubles as, like, it's not just the ran that goes off, it's the entire Internet. I hope that I answered your question.
01:16:56.790 - 01:17:33.962, Speaker B: Yeah, I think that probably covers it. It looks like Will has actually been in the YouTube chat answering a bunch of questions, so that's great. I think he covered. So we could probably wrap up there if there are no last minute questions, if anybody's still unsure about things or has additional insights that they're looking for, you can definitely connect with David and Alan in The Slack. They'll be available in probably all of the channels. Thank you both for presenting. Alan, when you went through, I could feel your excitement at the correct results.
01:17:33.962 - 01:18:05.062, Speaker B: That's always nice when it works the first time, so congrats on that and thank you for giving an excellent workshop. And this is perfect because we have it recorded and it'll go directly onto the ETH Global YouTube, like I mentioned at the start. I think we can probably wrap it up there. Andrew, we'll see everybody in black and their office hours tomorrow, and as well, the hack feedback session on Friday. Thank you.
01:18:05.196 - 01:18:07.494, Speaker A: Thank you. Thank you so much for hosting this. It's great.
01:18:07.532 - 01:18:07.940, Speaker C: Yeah, thank you.
