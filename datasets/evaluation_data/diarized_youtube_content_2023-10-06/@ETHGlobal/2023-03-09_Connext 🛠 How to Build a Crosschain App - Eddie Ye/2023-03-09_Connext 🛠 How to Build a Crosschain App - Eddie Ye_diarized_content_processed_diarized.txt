00:00:06.170 - 00:01:05.460, Speaker A: Welcome, everybody, to the Scaling Ethereum Workshop for Connect. I'm Eddie, an integration engineer at Connect, and I'll be walking through how you can use Connect to build a cross chain application. So we're going to start with the Docs site here at Docs Connect network, and at the bottom of the homepage, you'll find a bunch of helpful links, including a link to our bridge UI and the Explorer site. But right now, we're just going to jump into the concepts to do a quick review of what Connect is. So Connect is a modular protocol for securely passing funds and data between chains. What this means is that you can not only send assets between chains, but you can also send any kind of arbitrary data, such as data that specifies a call to a function on another chain. And what we're going to be doing in a few minutes here is walking through how to build a cross chain app, or Zapp, as we call them.
00:01:05.460 - 00:02:21.878, Speaker A: One thing I want to touch on in relation to modularity is that we've built Kinext as a system which derives its security from Ethereum and it plugs into these canonical messaging bridges of each chain. So Kinext is actually able to shortcut the normal waiting time for messages to be passed between chains by aggregating all the merkle routes generated on each chain, passing them to Ethereum and then verifying their correctness off chain. This kind of faster optimistic layer expedites data passing as long as no fraudulent transactions are detected by monitoring agents or watchers. Otherwise the system will fall back to the full waiting time for the chain's canonical bridge. And this mechanism gives you the best trust guarantees because we ultimately defer to the security of the underlying bridge used by the chain itself. And we just have this fast optimistic layer on top that's secured by a one of N liveness requirement, meaning only one honest watcher needs to be online at any time to fully secure the network. And that's not really a difficult requirement.
00:02:21.878 - 00:03:11.130, Speaker A: In fact, anybody can run a Watcher. So if you're really skeptical, then you have a trustless way to guarantee the liveness requirement of the network. Now, if you want to get a deeper understanding of the architecture and bridges in general, I invite you to take a look at this page. Look through the rest of those pages and Docs here. But for this workshop, we will focus solely on how to actually build something using Kinext. So we're going to jump into the developer section here, and as a general outline of what we'll touch on today, we're going to look through a few examples of crosschain applications using Connect. And then we will talk about a couple of critical concepts that are important to understand as a Zap builder.
00:03:11.130 - 00:04:12.830, Speaker A: So the quickstart guide will actually walk you through, step by step, how to build a crosschain greeter. It basically assumes that you have nothing set up. So it'll show you how to install all the prereqs and how to use Hard Hat, which is a smart contract development toolkit to deploy the contracts that you can just copy and paste from this page. But for this workshop we'll take a slightly different approach by cloning this Zap starter kit that we've built. This is just a GitHub repository that contains all the examples and docs and it will be slightly more favorable for people who just want to have a running start with something that works out of the box. So let's open this up and take a look at what we're working with here. To build a Zap, you are going to be calling a single function exposed by Connect on any of our supported chains and that function is called Xcall.
00:04:12.830 - 00:05:33.910, Speaker A: And we will see very soon what kind of parameters actually go into this pretty shortly. But in general you are going to be sending either assets or data to be used for a cross chain function call or maybe a combination of the two. But if you're sending data there is a distinction to be made between unauthenticated and authenticated calls, which we will talk about later. And the call flow between the two chains that you're interacting with is going to look something like this where you have some origin chain and some destination chain. You're going to be writing a source contract that's deployed to the origin chain and that contract will call Xcall, sending in the appropriate parameters and then Connect system will basically route that data and any sort of like asset transfer to the destination chain. If you happen to write a target contract and deploy that to the destination chain, you can specify that target contract as the target address that Connects will call. And Connects will basically be able to unpack any call data that you send in with the X call and use that to call a specific function on your target contract.
00:05:33.910 - 00:06:38.246, Speaker A: In some cases you don't actually need to deploy a target contract. So if you're just doing something like sending assets across chains, you really only need to build one contract on the origin side. And we have an example of that called the Simple Bridge, which is just transferring tokens from a user on the origin side to some specified address on the destination side. And since there's no actual function call that's needed to be called on destination, you don't have to deploy a target contract. But for today we are going to jump into a greeter example and this greeter is going to do both an asset transfer and an unauthenticated function call. So what I mean by unauthenticated call here is that the target contract has a function that we want to call but it's not permissioned in any sense. So it's not looking for some kind of owner.
00:06:38.246 - 00:08:00.710, Speaker A: It's basically just completely open for anybody to call. So the context for this example is we have a destination greeter contract on the destination chain. It stores a Greeting variable that we want to update and the update greeting function is going to provide the logic to update that variable. And then we'll have a source greeter contract on the origin chain that uses Xcall to send encoded call data and then have that routed by Connect and called by Connect's system to ultimately update that Greeting variable. Okay, so if you have cloned this repository, you can go ahead and basically take a look at what's going on in this example. So I've done the cloning, I've done the sort of setup that's laid out in the preparation steps here, which is including Downloading Foundry, which is another smart contract development toolkit, downloading make and also minting myself some testnet tokens. So the easiest way to do that is actually just to go to our testnet bridge UI, and at the bottom here there's a faucet so you can select whatever chain you want and then mint yourself a thousand test tokens on any of those chains.
00:08:00.710 - 00:08:42.210, Speaker A: But we're going to look at the greeter example here. So that's a source contract examples and greeter, you'll see two contracts here that are basically fully implemented and ready for you to deploy. So we're just going to talk about what's kind of happening in these contracts. So starting from the source side, this is the one that will be deployed on the origin chain. The first thing we do is we need to import these interfaces. So the iconnect interface is the interface that will contain the Xcall function. And then IERC 20 is just going to help us do some subtoken function calls.
00:08:42.210 - 00:09:38.550, Speaker A: You can ignore this interface for now. This is just used for the scripts that we will go through later on. The main contract here, or the only contract here is the source greeter. And you can see that in the constructor we're going to pass in the address of the Connect contract on the origin domain and we're also going to pass in the address of the token that we're working with on this domain. In this case, it's going to be a test token because we're on testnet and the Connect address, all of these addresses for the tokens and for connect addresses can be found in the docs as well under Resources. So for this workshop, we're working with testnet contracts and you'll find the core contracts, the assets and all their addresses in all these available chains. So back to the source greeter here in the constructor we've passed in those values.
00:09:38.550 - 00:10:35.240, Speaker A: The main function that we're working with right here is X update Greeting, which is the function that's going to be called by a user to trigger this crosschain update. So you'll see here that it's going to pass in a target address, which is the address of the destination greeter contract that we're going to deploy. After this. It's going to pass in the destination domain, which is the specific domain of the chain. So actually every bridge basically has its own mapping of domain IDs. So for Kinects we have ours listed here. The first thing that's happening in this function is there's a requirement statement because the user is going to be sending funds to the source greeter contract and then the source greeter contract is going to be sending those funds into Connect.
00:10:35.240 - 00:11:37.146, Speaker A: That first leg of the transfer is going to require that the user does a token allowance approval. So this is just checking that that allowance has been done and then the user is going to have those tokens transferred into this contract. This contract is going to do a similar approval to Connect and we're going to have call data encoded, which is going to be the call data sent into the Xcall. So to understand what you need to pass in here, we need to take a look at what the destination greeter function requires. So what we're going to be calling is ultimately this update greeting function and you'll see that it takes a string memory new greeting. So any string that you want passed in is going to be used as the new updated greeting. So for the call data that you need to pass into Xcall is going to be an encoded string and you can see that that's also passed in as a parameter to this call.
00:11:37.146 - 00:12:49.700, Speaker A: So the user can specify whatever string they want. The other parameters here are an amount, so the amount of tokens that you want to send in with this. And one thing that I forgot to mention at the beginning here for the context of this example is that this greeter contract is actually going to require that some payment is made to update the greeting. So just to create a use case for why we're sending tokens into the call as well, basically that update greeting function is going to be okay as long as you send any amount of test tokens greater than zero. So that's basically what the user will be sending in here for amount anything greater than zero will work. Slippage is the other parameter that needs a little bit more sort of context, but for now we are just hard coding that to 10,000 and this is denominated in basis points. So 10,000 is equivalent to 100% slippage and we'll talk about what the slippage actually means in a moment here.
00:12:49.700 - 00:13:55.270, Speaker A: The last parameter that we're going to feed in is the relayer fee. So you'll notice that it's passed in as the value to this X call. So what you're doing is you're actually passing in the native asset as the relayer fee. And the relayer fee is this fee that's paid to off chain agents to actually execute your call on the destination chain. So if you recall up here, once you do the X call and the off chain relayers do their thing to route this message across the chains, somebody has to kind of trigger the call on destination, like somebody with gas. And in most cases you don't want that to be the user because some users might not have gas on the destination chain and they will basically be constructing a meta transaction for relayers to submit on their behalf. So in order to incentivize those relayers to trigger that transaction on the destination chain, you have to offer them some kind of incentive.
00:13:55.270 - 00:15:01.118, Speaker A: And that incentive is this relayer fee that we're passing into the Xcall. Now, what you actually use as the relayer fee is something that you have to estimate and we have an SDK that you can use. So back to the docs here. Under the SDK, you'll find that the base class has an estimate relayer fee function and you can basically construct this in any kind of, like, node environment or front end pull in the connect SDK and then call this. Estimate relayer fee using the origin and destination domain parameters to determine how much this relayer fee needs to be to incentivize relayers to actually move the transaction along on the destination side. We will eventually have on chain methods to do this, but for now, this is a fully off chain calculation. And for the purposes of this example, we are actually just going to hard code the relayer fee as well to some value.
00:15:01.118 - 00:15:38.016, Speaker A: That is a conservative estimate that should go through. All right, okay, let's look at the destination greeter now. So for the destination greeter, you will also have to import a couple of interfaces. The main one being this IX receiver. This IX receiver says that any target contract that's going to be called by Connect has to implement an X receive function with exactly these parameters passed in. We're not using a couple of these in the function. That's why it's highlighted here.
00:15:38.016 - 00:16:31.312, Speaker A: But you can kind of just ignore that for now. But basically, if you are going to capture any X call on the destination side via a contract, that contract has to implement this function. And you'll see that in the constructor for this destination greeter, we're also taking in the address of a token and this is going to be the test token on the destination side. So in the XRC function, we first check that the asset coming in from the X call is the right asset that we've instantiated this contract to take in. And it also is enforcing that cost that I mentioned earlier. So anything greater than zero will be okay for this contract to update the greeting. And then what we're doing is unpacking the call data that came in with the Xcall.
00:16:31.312 - 00:17:24.820, Speaker A: So this encoded call data is being unpacked on the destination side. So new Greeting is decoded and we're calling update Greeting with that decoded new Greeting stream. And that's really it. That's the source and the destination. And in the README of the Zap Starter kit, if you scroll down a little bit. There will be a deployment section where we already have built out a bunch of different forge scripts that can do the contract deployments and it can do the function calls without you having to muck with MetaMask and go to Etherscan and interact that way. So there's a very simple make command that you just run to deploy the source greeter and the destination greeter.
00:17:24.820 - 00:18:07.120, Speaker A: And you'll see that in the env example here, there are a bunch of different variables that you need to fill out. So your private key, Etherscan API key for verifying the contracts, and anything that's between these brackets are variables that you need to fill out eventually. We do have some filled out already. And this is assuming that you're sending from Gorely to Optimism Gorely. It already has the origin, destination connect contracts, the domains and the tokens filled out. The default is to send one test token to use 100 as the slippage and I believe this is 0.3 E as the relayer fee.
00:18:07.120 - 00:19:10.224, Speaker A: So when you look at this and you deploy your contracts, it's going to show you the address of where that contract was deployed to. So for the greeter example, you'll want to fill out the address of that greeter and the address of the destination greeter. And then you'll also want to update what the new greeting you want will be because the next step after deployment is to actually test it. So we also have Forge scripts that call the X Update Greeting function here already and you can find all these scripts under your script. So script greeter destinationgreeter s sol and sourcegreeter s sole are the deployment scripts. And then Update Greeting is going to be the script that actually calls X Update Greeting. So what it's doing here is it is minting you some test tokens.
00:19:10.224 - 00:20:14.000, Speaker A: So if you forgot or didn't actually mint yourself some tokens earlier, this script will actually do it for you automatically because the test token on testnet is freely mintable. And then it will approve the token allowance from your wallet to the source greeter contract. And then it's going to just call X Update Greeting with all of those parameters filled out, most of those coming from the end. So once you run where is it? Once you run the makeup day command, which is going to run this Forge script, you'll see a transaction hash that pops out and you'll be able to actually track the status of that transaction hash. So in the interest of time, I'm not going to go through and actually deploy these contracts. I'm just going to use two pre deployed ones. So the source greeter on Gorely and a destination greeter on Optimism Gorely.
00:20:14.000 - 00:21:01.944, Speaker A: And we'll just take these addresses and we'll fill out our M here. So down to the greeter. Yeah, I already have these filled out, but the source greeter address from Gorely and then the destination greeter address from optimism, Gorely, and then some new greeting that I want. And then I will just run the Update greeting command, which is make update greeting. This will start the Forge script. It will go through all those steps that we just looked at, which is to mint and approve and call Update Greeting. Forge is relatively fast, so we should see our transaction pop up here.
00:21:01.944 - 00:21:56.620, Speaker A: All right, there it is. There's the hash on Gorely. If we look this up, we can see that it is still pending. But now the next step is to kind of determine at what state your transaction is in. So you want to track, like I sent the X call, what's its current status? And so in our docs here, we do have a section to show you how to track these X calls. One method is to query the subgraphs directly so you can navigate to the reference, go to subgraphs, look at resources, and then all of our deployed subgraphs are going to be here. So you can do something like open the Gorely subgraph paste in the sample query to find all the details of the Xcall.
00:21:56.620 - 00:22:39.000, Speaker A: Alternatively, you can just look at our Explorer UI, which is sorry, it's in this page, which is going to be here. It's at testet connectscan IO. And you can just input any transaction hash. So the one that we just sent, we'll look that up in the Explorer here and you can see that there's already a registration here. So we're already tracking this X call. It has been sent on the destination, on the source, and we're just waiting to have that be received. Awesome.
00:22:39.000 - 00:23:23.564, Speaker A: There it is. So after about a minute, this was received and we can look at the transaction hash if we wanted to, just to see the assets actually being delivered. So the test token was delivered and there will be another part of this that gets filled out called reconcile. And that's a different state. That's basically when the routers that are in our system providing fast liquidity get reimbursed. But from an end user perspective, the receive is all they really care about because that's when their assets get delivered. So not only do the assets get delivered at this point in time, but the destination contract also gets called.
00:23:23.564 - 00:23:38.810, Speaker A: So what's happening is that connect let me get back to the right page here on the receive. Kinext is going to call X receive on target contract. So if we look at our destination contract again.
