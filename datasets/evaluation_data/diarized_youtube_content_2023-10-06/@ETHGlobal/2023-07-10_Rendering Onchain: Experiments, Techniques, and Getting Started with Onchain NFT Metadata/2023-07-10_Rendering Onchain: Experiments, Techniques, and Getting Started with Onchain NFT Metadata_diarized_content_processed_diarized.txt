00:00:07.610 - 00:00:47.370, Speaker A: All right, hello. My name is Nicholas, and today I'm going to be telling you about my adventures rendering SVGs on chain. I'm going to be showing you some experiments that I did, some techniques and lessons that I learned along the way, and giving you a repo that'll be really useful if you want to do some on chain SVG, maybe even during this hackathon on so thank you for coming. So this project started when I decided that I wanted to give juicebox NFTs metadata. Maybe show of hands, do people in here know what juicebox is? Have you ever heard of it? 1230. Hey, four. So for people who don't know, juicebox is an immutable and open source protocol on Ethereum.
00:00:47.370 - 00:01:24.358, Speaker A: It lets anyone permissionlessly issue tokens in exchange for contributions to treasuries. And those treasuries are called juice boxes. Because everything is on chain. Prospective contributors can diligence the juice box's parameters before they interact with it. So before you make a donation to a project, you can discover who controls it. How are they going to spend the money? Is the token issuance stable, or will it change over time? And can I get a refund if I decide I want to quit the project? These kinds of on chain features are enabled by being an onchain protocol. There's over a thousand projects on Juicebox already.
00:01:24.358 - 00:02:06.130, Speaker A: Some of them are very big and famous constitution, Dao, Assanged, Spicedao. Others are smaller, many small charities. For instance, Marin County Swim Association is a local charity in Marin supporting youth access to aquatic sports. There's also some open source projects that are developing business models on the blockchain with blockchain revenues. One interesting one is Planetable, which is an Mac application for creating IPFS locally hosted blogs. So that's a bit of a background on juicebox. The reason I mention this is because each juicebox project is represented by an NFT.
00:02:06.130 - 00:02:55.650, Speaker A: The owner of that NFT is able to configure the juicebox project. And by this mechanism, juice boxes are composable with all kinds of governance and management systems. So for instance, you or I could create a juice box and hold it in our MetaMask rainbow or other EOA wallet and control it. That way we could pass it to a Gnosis safe and have a multi SIG govern the project. We could give it to an on chain governance protocol like OpenZeppelin Governor or compound Governor. We could put it into a specifically designed contract, or we could burn the ownership of the project altogether by sending the NFT to the burn address. So by having access controls over the project controlled by an NFT, it's composable with any form of future smart wallet or EOA, et cetera.
00:02:55.650 - 00:03:47.970, Speaker A: The problem is that before I started this project, these NFTs had no metadata. So when you go to the collection on OpenSea or other marketplaces, or if you go and check out these NFTs on Etherscan or using whatever kind of interface you choose, they have no metadata, or they didn't, at least at the start of this project. So when you ping this token Uri function, it returned nothing, an empty string. So I decided to solve this by creating some metadata contracts that would bring life to the protocol visually and through structured metadata properties. And so I embarked on this project and I'm going to tell you about that journey, what I learned, and I'll give you some resources so that you can check it out on your own and make your own SVGs, integrate them into your own projects. So there were two goals for this project when I set out. The first was to render project data to NFTs visually.
00:03:47.970 - 00:04:34.302, Speaker A: The idea essentially I wanted to surface live blockchain data from the status of these treasuries, how much ETH is inside of them, how many tokens have been issued against these projects, et cetera. To emphasize the on chainness of the projects, I wanted to visualize that directly in the image without recourse to IPFS or any kind of Https hosted metadata. I wanted to do it entirely on chain. The second thing that I wanted to do was maintain the ethos of project sovereignty that we have at Juicebox. The Juicebox contracts are all immutable. While we do release upgrades, it's up to a project owner to choose if they would like to apply that upgrade and no upgrades are applied, like pushed to the projects themselves. So I wanted to carry that ethos through to the metadata.
00:04:34.302 - 00:05:53.710, Speaker A: So I wanted to simultaneously in the first goal, provide some kind of visual information related to their onchain status live analytics metrics about the project and also allow people to opt out and have their own metadata if they prefer, if they're willing to write their own metadata contract. So what's so interesting about onchain metadata anyway? There's many cool things, and the ones that stick out to me are, first of all, that we avoid having off chain dependencies like IPFS, which often require using a service like Infura or Pinata, which are centralized services that do the pinning for you. Alternatively, you can do it yourself, but with the consequences of the metadata being served quite slowly if you're hosting it on your own machine or on a single instance on AWS, et cetera. Another cool thing about on chain metadata is that it allows you to compose with other contracts on chain. The UIs that are generated with on chain data are also provably, accurate and censorship resistant. They're permanently hosted, they don't depend on anything off chain. And most of all, I think visualization is like a first step on this journey towards a hypothetical future that a lot of people are excited about, where NFTs begin to merge with apps, where NFTs allow you to not only surface data from the blockchain, but also enable interactivity.
00:05:53.710 - 00:06:46.490, Speaker A: Finally, it's just fun and an interesting experiment to do things on chain. So the first step in this project was to visualize protocol data, the protocol's data in an SVG. And I began with the aesthetic question of what should these things look like. So I sought to take aesthetic inspiration from these very exciting, I don't know, enigmatic, old school CRT CLI interfaces with this orange glowing feel to them. And I took that inspiration into Figma, where I designed an SVG. There's many choices of where you so I guess I should preface this by saying I decided to take a path of creating on chain SVG specifically because it suited the requirements for the project. So I found inspiration in these old images of CRTs and I took it into Figma to begin designing.
00:06:46.490 - 00:07:16.706, Speaker A: I made the choice early on to use a monospaced font in order to be able to do the layout on a row by row basis. Here I'm showing some iterations of the design from Figma, and the reason I chose a monospaced font is because it allowed me to deal with the variable length of the data that I was going to be fetching from the protocol. That varies between all the different projects. Makes it easier to think about. So I prototyped this in Figma and there are many different tools that you could use. Originally. I started with inkscape.
00:07:16.706 - 00:08:25.594, Speaker A: In my past life, I worked in a digital fabrication lab where Inkscape is an open source SVG editing tool. That's very cool, and I highly suggest however, Inkscape generates quite ugly SVGs if you actually look at the text of the XML. So I ended up switching to Figma, which generates cleaner SVGs. Nevertheless, one lesson to take away from this is if you are planning to do on chain rendering, you will have to go and manually edit the SVG, even if you get it from an application like Figma, because it adds all kinds of cruft that you don't really need on Shading. Additionally, you should confirm as early as possible in the process, earlier than I did, that all of the effects and styles that are being applied by your SVG editor of choice are going to be represented similarly across all browsers. So, for instance, I had problems with I decided to use the Glow Effect in Figma, and when I brought this into my Solidity contract and started playing with the actual files, it turns out that in Safari the Glow Effect is a style that is not supported currently. Moreover, the way that they deal with white space, like multiple spaces in a row, it wasn't displaying correctly.
00:08:25.594 - 00:09:20.970, Speaker A: So I had to deal with these issues later. So I suggest early on in your process, when you're moving from your prototyping stage into your Solidity, quickly check that it's working properly in all browsers that you expect to be viewed in at least. So how do we actually write the contract? So I've taken some snippets out of the contract. I don't want to bore you with too much technical detail, so I'm just going to get to the core functionality that I had to implement in the contract and how it works. I decided to use not only a monospaced font, but actually a font that is on chain. There's a developer, another contributor at Juiceboxdown named Peripheralist who created an NFT project called Capsules, which you can check out at Cpsls app. And this is an NFT project and as a part of it, he created his own font and deployed it to the blockchain so you can ping his contract and it will return a base 64 encoded string of each of the font weights for this typeface that he created.
00:09:20.970 - 00:10:21.886, Speaker A: So in the first section of this slide, what I'm showing is the code that goes and fetches that base 64 encoded string representation of the 500 weight font from his contract. Once we have that in the contract, it's time to go and collect all of the data from the juice box protocol to grab all of the treasury information about a given. And just to give you some context, this code will be executed when OpenSea or whatever marketplace or other browser goes and fetches the token Uri from the NFT contract. So we're creating the possibility to generate the SBG that we ultimately want to return here. So once we collect the juice box data, which takes quite a few calls to many different contracts to go and explore, because the projects can have different treasury configurations, they might be interacting with different projects. This is quite an involved process. Once we have the treasury information and the typeface, we can begin concatenating this into one big SBG.
00:10:21.886 - 00:11:20.882, Speaker A: This is a very dense function that really does need to be broken up into many smaller functions. So if you are planning to create an onchain SVG or any other kind of onchain XML or HTML something else, I highly suggest that you break it into functional pieces, into the smallest functions possible, because you will hit a stack two deep error very quickly if you're concatenating and creating something really large. Especially the string concatenation causes stack to deep errors frequently. So the first lesson is to break your onchain SVG creation if it is complex, into multiple functions to avoid stack 2D pairs. Also avoid the temptation to use via IR. Vir is a function in any compiler, but Vir is what it's called in a flag is what it's called in Forge. What it does is essentially instead of compiling your solidity directly, it compiles it to an intermediate representation where it can squeeze out some additional efficiency.
00:11:20.882 - 00:12:14.134, Speaker A: This is cool because it means if you're getting a stack two deep error because your function is too long and you have too many variables in memory, VIAIR will compress them and allow you to get away with a less than efficient function. However, VIIR is slower to run in tests, so it will slow down your development process. It also makes tracing errors very difficult because the errors will correspond to the intermediate representation code rather than to the Solidity that you wrote. So it will be difficult to find where the problems are in your code. Finally, Ether scan verification, at least at the time when I was deploying these contracts, did not allow you to verify a contract compiled with via IR. So you may do the entire project and everything is working, and then you go to verify your contract on Etherscan and it doesn't work, which can be quite disappointing. Next, you have to test what you're doing as you're developing and implementing the code.
00:12:14.134 - 00:12:40.670, Speaker A: That the imagery that you've developed in your visual mockup. You need to test and see that it's actually working. And there's many good solutions for this. One of the most exciting ones is a project called Hot Chain SVG by a developer named Winter, which gives you hot reloading SVGs. So essentially, you have your solidity code you save, and it immediately refreshes a browser window with the changes that you've implemented. This is very cool. Feels like developing react, for example.
00:12:40.670 - 00:13:37.890, Speaker A: However, it doesn't support mainnet forking. And for me, this was very important because the contract that I was working on had to interact with several protocols, namely ENS many, many juicebox contracts as well as existing projects. And this typeface, it would be too complicated and time consuming to redeploy each of those protocols inside of my test environment, as well as populate each of those protocols with example projects and cover all the potential use cases for those projects to get a representative sample when testing. So I decided to pursue a main net forking strategy, which meant that I couldn't use this Hot Chain SBG project. If your project doesn't have that requirement, then I encourage you to check out Hot Chain SBG for me. Because I needed to do mainnet forking, I had to develop something of my own, and I turned to a friend of mine from Montreal, Jaton Kernu, who created an FFI script. FFI is a function in Forge that allows you to call JavaScript and other software on your computer during a test.
00:13:37.890 - 00:14:20.240, Speaker A: So on this slide, I'm showing you the JS that runs every time I run a test, where I want to visualize the output that I'm rendering. And what this essentially means is you call for test FFI and it will instantiate the contract. Run the test, then take the output from your token Uri function, save it as an SBG on your file system, and open it in your SBG, your default SBG application, which for me is the browser. So basically, you hit test and suddenly brave pops open with the SBG right there. This is very cool. And yeah, if you need to do main networking, feel free to grab this code. Everything's open source, of course.
00:14:20.240 - 00:15:19.246, Speaker A: So, hey, it works. We've got a contract now that is able to render these images, these SBGs, which are representing live on chain data. So what are these things showing us? So in the top left you can see we have the project handle, which is a contract that connects Juicebox to ENS. These are ENS names. We also can see the cycle number, which is to say how far along we are in the project's life, as well as how much time is left in the current cycle. We have the balance of the project, how much ETH is inside of it, are there any payouts scheduled? If so, the value that's scheduled is there, as well as the total outstanding token supply and the address of the project owner abbreviated so that it fits into the space. There one thing that you can't see here is that actually the project name, the Juicebox emoticon, and the project owner address are all A tags which do work inside of SVGs.
00:15:19.246 - 00:16:03.614, Speaker A: You can use some HTML tags inside of SVGs in OpenSea and we'll talk about this a little bit more in a second. OpenSea serves cached versions of any on chain metadata. And so in OpenSea, for security reasons and because they're serving PNG cache, you can't click those links don't work. However, if you were to render this on your own site, you could click those links. And for instance, if you click Jiggly Jams, it'll take you to the Jiggly Jams project. So I also wanted to let people express their attitude of their project through color. And so I also included in this contract a theming system, which is a mapping of project ID to theme Structs.
00:16:03.614 - 00:17:08.300, Speaker A: And a theme Struct just contains three hex values for colors, which I concatenate into the token Uri if they have been set. Yeah, so we covered the first aspect, the first goal, which was to provide the default metadata for every project. But I realized as the project went on that I didn't want to be didactic, and I wanted to let people create their own metadata if they prefer, in the spirit of the protocol. So the second goal was to let any project choose to replace the metadata with their own contract. I chose a registry architecture to achieve this, so project owners can decide if they want to set their own metadata contract, and if they don't, we serve the default metadata that I just showed you previously. If they do choose to set their own metadata when OpenSea or a user goes to grab the token Uri from the contract, it will check. Have they set a custom contract? If not, serve that orange or customized color default metadata? If they have, serve the metadata from their contract.
00:17:08.300 - 00:17:56.088, Speaker A: It's pretty simple, it's just a mapping, but it is effective. This registry also allows us to create sophisticated contracts that are not intended to be the metadata for a single project, but even metadata for multiple projects. So to demonstrate this, I created another metadata renderer. This one allows you, any project owner, to set for their project IPFS, Https, rweave or other string where JSON can be fetched that populates the metadata of that project. So for this example, I created this contract that lets you set a custom IPFS CID for your project. And here it's pulling up a picture from IPFS for this particular project. So we're not strictly stuck in on chain metadata with this registry design.
00:17:56.088 - 00:18:38.484, Speaker A: You can also have off chain metadata if you prefer. Finally, don't forget to refresh your caches. If you're doing on chain metadata, one thing you need to be careful of is, as I mentioned earlier, OpenSea and other providers and many DApps that rely on OpenSea for fetching metadata, it can fall out of date. And if you are familiar with NFTs, you're familiar with clicking refresh metadata on the Openc page, that's fine. But if the whole purpose is to demonstrate live metadata, then you need to have some kind of solution for this. There is an EIP ERC 4906 that lets an NFT contract emit an event, and Openc and other indexers listen for those events. And if they hear it, they refresh metadata cache.
00:18:38.484 - 00:19:40.680, Speaker A: Because some change has happened. However, four nine six only works in the context where the metadata is changing due to a contract interaction on the NFT contract itself. But if your NFT contract is pointing to another contract that renders your metadata, events on that contract will not tell Openc to change to update their cache. And so four nine six is useful if all of your metadata is being rendered inside of your contract and if it only changes when someone executes a transaction. In this case, that's not how it works because the time is always ticking down in the time left in the current cycle, for example. So to solve this in TypeScript, I wrote a process that runs in PM two on a VPs that goes and fetches all the token IDs what is the number of IDs in the NFT contract and tells Openc to update each one one after another. Ideally, this is made obsolete in the future by OpenSea supporting an API endpoint where you can know, just tell them one time, update the whole collection.
00:19:40.680 - 00:20:21.732, Speaker A: So far that's not the case. So if you have this problem, you can also go and steal this repo and maybe it'll be useful for you. Once the metadata rendering was complete for the Juicebox protocol, I decided it would be fun as a stretch goal to make these things collectible. Because, as I mentioned, these NFTs the juicebox NFTs represent ownership of a juicebox. And so not everyone can have them and you can't sell them because that NFT is the ownership of the project. And so you probably want that in a multisig or in an onchain governance contract. So how are people actually going to see this metadata that you've spent so much time creating? My solution was to create something called Juicebox cards.
00:20:21.732 - 00:21:08.122, Speaker A: This is an 1155 open Edition contract with a very low mint price. When someone mints one of these cards, they receive an 1155 in their wallet. The proceeds go to the project in question, and the metadata for this 1155 Open Edition is simply a reference to the Juicebox project's own metadata. So as a consequence, essentially, these Open Editions are like little billboards that can be in your followers wallets, in their rainbow wallet. They can check the status of the project by having an Open Edition that has the exact same metadata as the project itself. So you can make your own metadata too. And I thought it would be nice if I provided something to get you started so you don't just have my project.
00:21:08.122 - 00:21:48.082, Speaker A: As an example, here are a few links. The first one, I think is the most interesting one. It allows you it's essentially a Forge Solidity repo, where if you download it, install the dependencies by calling Forge Install and Yarn Install, the instructions are in the README and then hit Forge Test FFI. You'll immediately have an SVG rendered from Solidity in your browser. So I think we have a few minutes, so maybe I can actually demonstrate that. Actually, before I do, I'll just explain the other links. So the first one is this SVG demo repo that I'll show you.
00:21:48.082 - 00:22:14.446, Speaker A: The second one is a boilerplate. If you wanted to write your own metadata contract that's compatible with the Juicebox contracts that I wrote, you can fork this project. It has all of the imports already in there. It's going to work right out the gate. So it's sort of a little bit of stuff on top of that SVG rendering boilerplate in the first link. And the third link is to the docs for everything that I've talked about today. Actually, here, I'll quit out of this for a second.
00:22:14.446 - 00:22:51.788, Speaker A: So this is that repo I mentioned in the first link. Oh, you can't see that, can you? There we go. So this is that repo no, sorry, this is the wrong one. Oh, I see. I have to look on this. Okay, so you can see here, these are the properties that will be like the properties of the NFT. Not visual properties, but properties that you can sort by in OpenSea, for example.
00:22:51.788 - 00:23:29.450, Speaker A: And here we're generating the actual SVG. So if you download this and you simply install the dependencies and there's instructions for that in the README, and then you call forage Test FFI, it's going to open it on my screen. So I got to move this over. So this is rendered from Solidity. So if we go here, it's a little difficult for me to see. But if we change this to, I don't know, blue, obviously better to use actual hex colors. Sorry, it's on my screen.
00:23:29.450 - 00:24:14.236, Speaker A: There we go. So you can start playing with an SVG, like, right away. It's very, very fast, and I encourage you to do that. So one of the next steps. So in this project, what I've shown you is some tips and some lessons learned from creating an on chain SPG rendering contract that just visualizes what's happening on chain in a dynamic image. The next step is to create an NFT that is interactive. And to do that, you would need to bundle in something like Ethers or Web three JS into the NFT, potentially drawing it from an onchain source or potentially grabbing it from a regular Http route like from a CDN, et cetera.
00:24:14.236 - 00:25:02.692, Speaker A: So the promise of this is that we can have NFTs that not only visualize what's happening on chain, but allow you to write to the chain. Also by constructing a transaction request that MetaMask or whatever wallet you're using can understand and then propagate it to an RPC. The problem here with a missing piece is that as we mentioned earlier, OpenSea, sandboxes and caches NFTs. And so you can't have interactive, you can only have limited interaction inside of the OpenSea frame. And so the second piece that I think is interesting that people might want to work on is an NFT app browser, that is to say a website most likely, that allows you to browse NFTs and interact with them to do things like construct transactions that you can propagate on chain. So that's my talk. Thank you very much for attending, and if anybody has any questions, I'd be happy to answer.
00:25:02.692 - 00:25:44.610, Speaker A: Thank you. Any questions? Yeah. Oh, good question. I'm not super deep on what all the prizes are that are available. I don't know if there's anything where this will be particularly beneficial, but one that comes to mind is I know 6551, the token bound like NFT owned wallets. Could be interesting to have those wallets rendering something on chain representing what's inside of them with no off chain dependencies. So for instance, yeah, you could have an NFT where you set it in an asset and then it shows it and it's not relying on IPFS or Http.
00:25:44.610 - 00:27:32.456, Speaker A: I think also some of this on chain stuff could be very interesting on nosis chain or Polygon or other L two S or side chains where gas fees are lower. You could do even more aggressive things, not just with the rendering, but with having more interactivity to write to them to change what's being shown. Any other questions? Yeah, if you're yeah, there's you most likely have to sign a transaction if you're logging into an app that wants you to verify that you own a certain wallet or if you want to send a transaction. So those are cases when yeah, the question is, if you're making a game, do you have to pop up a transaction request every time you want to do some in game interaction? And if the game state needs to be modified on chain and you want to restrict actions to the owner of a certain wallet, then yes, you probably do. One alternative is to write your own app, let's say a mobile app, where you keep the keys, and it's more of a custodial system. So instead of asking the user for permission to their key, you make every button just work. And you don't ask them for permission to sign with their private key, you just do it on their behalf.
00:27:32.456 - 00:27:50.260, Speaker A: That's a way around that. Yeah. I would suggest you probably want to make your own wallet built into your game. Yeah. Any other questions? Okay, thank you very much.
