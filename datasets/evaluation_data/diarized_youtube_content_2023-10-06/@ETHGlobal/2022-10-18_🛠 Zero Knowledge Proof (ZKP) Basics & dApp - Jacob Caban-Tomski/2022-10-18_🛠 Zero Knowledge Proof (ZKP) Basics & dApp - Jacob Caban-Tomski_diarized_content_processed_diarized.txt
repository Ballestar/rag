00:00:06.570 - 00:00:29.670, Speaker A: Hey, everyone. How's it going? My name is Jacob Kabontomsky. I'm a member of the Privacy and Scaling Explorations Group at the Ethereum Foundation. And today we're going to go over some zero knowledge proof basics. And we're going to go over a template DApp project that uses zero knowledge proofs. So kind of go over all the things we're going to cover today. We're going to set up the template repository.
00:00:29.670 - 00:00:56.480, Speaker A: We're going to go over very high level kind of how zero knowledge proofs work. Specifically non interactive zero knowledge proofs. We're going to go through a single EdDSA signature demo. Time permitting. We'll also go through a modification to that to handle multiple EDSA signatures. And then I'll cover some additional resources for follow up if you want to learn more. And then finally, we should have a good amount of time at the end for any questions people might have.
00:00:56.480 - 00:01:26.040, Speaker A: So first for the template I'm going to be going through today, we're going to just go over some of the kind of setup instructions. This is called ZKP App boilerplate. It is an app that some colleagues of mine have made. You can find it@github.com at privacyscaling explorations. ZKP App boilerplate. You can choose either to just clone it directly or there also is a use this template if you want to have something you can directly commit to on GitHub or show off.
00:01:26.040 - 00:02:12.760, Speaker A: As far as the dependencies go, like kind of a standard DApp, it does use the Node JS ecosystem and hard hat for all of that. It also uses yarn. And yarn workspaces for kind of managing everything in there. It does also require in your machine rust and circom. Two, those last two which are there are links for those on the main README for installing, take a little bit of time to download and run, especially on kind of the local network here what you get with that. Boilerplate is going to be a kind of react web app. You're going to get the proof verification contract and a very simple EDSA DSA mouthful circom circuit that you can kind of mess around with.
00:02:12.760 - 00:03:13.750, Speaker A: All right, what are zero knowledge proofs? So in a general kind of setup for that, we have a prover and a Verifier. And so generally the prover is going to be the person who generates the proof and the Verifier is going to be the person who checks it. And so in order for the prover to generate that proof, it's going to provide a number of public and private signals as well as with the kind of proof itself to generate a proof that it's going to use to send to the Verifier. We're then going to send from that prover to the Verifier that proof plus all of the public signals, but none of the private signals in for that. And then finally the Verifier is going to check whether that proof is valid using those public signals and that proof. So basically we're just going to generate it, transmit it, and then verify that proof. This is also known as a non interactive proof.
00:03:13.750 - 00:03:59.020, Speaker A: In some zero knowledge proofs, there is kind of a back and forth where the Verifier will ask questions of the prover that it has to answer successfully. This requires kind of a lot of chatting and so it has been simplified down to kind of this three step process as far as how that looks from those two different entities, the prover and the Verifier. They kind of have a different view into what's going on inside of that proof. In this case, for the prover, which is going to be the DAP actually generating it, you're going to have your public and private inputs, which in this case are just going to be numbers A and B. There's going to be a check inside of the circuit. In this case, it's very simple. A times B equals C and there's going to be an output at the end of the proof, which is just going to be that result C.
00:03:59.020 - 00:04:35.214, Speaker A: So essentially the prover has kind of that full global view over everything that's going on for the Verifier. It does not know any of the private inputs that are going into that. And so it's just going to know the public inputs. In this case, A, it's going to know the output and it's going to know the check that's being run. So in this case, it knows nothing about B. For this simplified example, it would be pretty easy for someone to figure out the private inputs. So if you had an output of C, say six, and an input A of two, input B of three, well, six divided by two is three.
00:04:35.214 - 00:05:26.270, Speaker A: But in more kind of complex examples, it's going to be more difficult for the Verifier to kind of reverse engineer or figure out what those private inputs are. For this demo app, what we're going to have is we're going to have the DApp connect to their browser wallet. It has a prover inside of it that it's going to use to generate those proofs. We're going to submit them as an actual ETH transaction to a ZK app contract. So we're going to have that proof plus those public signals as the data inside of that transaction and then finally submit that to an RPC endpoint or a node. And inside of the EVM, that Zkapp contract is going to talk to our Verifier contract, which will be generated from those circuits and it will basically just return a simple boolean saying whether it was successful or not. Cool.
00:05:26.270 - 00:06:03.022, Speaker A: So let's go ahead and dive in to that example. For this case, let's go ahead and just start with the repo. I already have most of the dependencies installed, so you normally would just have the, as I said, rust circom. And then you're going to also just do a normal yarn install to download all of the NPM dependencies you then to compile all the resources in the repo we'll just call Yarn build. This is going to compile and transpile all of the circuits for Circom. It's going to generate that solidity code. It's also going to compile all of these solidity contracts as well.
00:06:03.022 - 00:06:37.900, Speaker A: So right now this can also take a little bit of time. This I think on average for me takes between about 40 seconds to a minute. On this older laptop right here, you can see it's generating the actual circuit. One thing we're also not going to go over in this is going through the actual as part of generating those circuits. You'll generally have a setup ceremony to generate kind of trust for that proof that's kind of all abstracted away inside of this project. But you can certainly dig into it to see more how it was happening there. Yes, sir, we're going to get into that right after this.
00:06:37.900 - 00:07:10.326, Speaker A: So we finished that step and so let's go right into what is the circuit. So I'm going to go through this repo and in general there's going to be, as I mentioned, kind of the different components. We have the actual app up here which is going to be the actual web app that's run. We have the circuits and then we have the contracts and the circuits, the circuits being the lowest level one. And so let's go ahead and dive in right away to that main Circom. Can everyone see this? Okay, cool. So in this sample code we have here and let me scroll down a little bit.
00:07:10.326 - 00:07:39.790, Speaker A: We're using Circom Two. We are bringing in a library. We are using the Circom lib has a EdDSA poseidon Verifier, which is what's going to actually verify those signatures that we send in. And so we're going to talk about let's go to this template and I will go down a little bit. Okay, so inside of our sample we have all of our signal to be they're split into public and private. In the comments we'll get into how we actually define what's public and private. At the bottom of the template.
00:07:39.790 - 00:08:34.586, Speaker A: The first input is going to be M, which is the message that we're signing. Ax and Ay are the public key and that's going to be the two components of that. And then private we're going to have the signature and then the R eight in X and Y are essentially components of that signature as well. We're going to instantiate as a component that Verifier here, enable it and then we're going to pass through all of those inputs to this Verifier to be enabled if for even a more simple circuit, you can go to something like Zkrep and let's see if this will zoom. One of the simpler circuits you can do is just doing that multiplication like I mentioned in that first example, which would just be A star B output C. For this one though, we're going to be demoing with those signatures in there so we have this sample. Okay.
00:08:34.586 - 00:09:22.654, Speaker A: And then finally for our main, we're going to define our public components which are max and Ay and we're going to instantiate that sample down below. So this is a very simple single signature verification circuit. What this actually is going to generate when we run that transpile is a bunch of additional assets including some JS code and some kind of lower level bytes for that circuit. What the actual verification contract looks like is pretty complicated. It's going to have a library built in which is going to be doing all of the pairing cryptography that's going to be involved in the proof verification. So you can see a lot of that here. And then I'm not going to spend too much time on this, but feel free to dig into it later.
00:09:22.654 - 00:10:13.646, Speaker A: And then we actually have the verifying contract. And the important part of this one is going to be this proof. The proof is going to have three components, a, B and C, which are just going to be points from that pairing cryptography inside of it and then we're going to have the actual verify function. So this is what's going to end up being called to verify the proof that we pass in as well as all of the public inputs signals that we're going to pass into there as well. Since this is a generated file, you should not modify this directly because your changes will get overwritten on the next generation and this just ensures that the proof is valid as well. So that kind of covers the circuit and then what we're going into as far as generating on the solidity side that we're going to use to verify that. So now let's actually go into the demo app that we're going to use to kind of show this off.
00:10:13.646 - 00:10:48.410, Speaker A: And for that you just run after you've kind of set everything up and built. You do yarn demo. You do need an address to kind of bootstrap this process. For me, what I've done is I've actually loaded in the hard hat account at number zero and just loaded that inside of MetaMask. You also need to reset your transactions to make sure that the nonces that you're using in that wallet match up with your newly started kind of hard hat node. For that you can also use another address. Just make sure you transfer some ethereum to it so it has gas to pay for the local network.
00:10:48.410 - 00:11:27.464, Speaker A: And then this is just the note once again to reset those MetaMask accounts. So this is going to do a bunch of different steps there. Let me think if there's anything else I'll jump into for that. So this demo app contained within it basically has a bunch of different components. It will deploy the contracts for you through the interface. It will have a way to generate the signature that you need to pass in as that public signal, and then finally, it will be able to generate that proof and submit the contract there. So let's go ahead.
00:11:27.464 - 00:12:07.290, Speaker A: Yes, starting up there's. How's everyone's hackathon going thus far? Good. Bad. Nice. While we're waiting on that, I can talk a little bit about this, which I think is helpful. This is Zkrepl Dev. This is kind of an online editor you can use to modify circuits.
00:12:07.290 - 00:12:45.580, Speaker A: In this case, you can actually test and define everything inside of here. And it allows you to actually run the circuits. You can change the inputs here as well. So, for example, if I wanted to, say, get 100 as an output, or let's just say 120, let's see if that'll run. Yes. And so we can see here we have the different parameters that we passed in the generated assets from the hash that we're using for this poseidon hash component. And then finally, importantly, that input output, which is 120, which was what we expect from ten times twelve.
00:12:45.580 - 00:13:18.628, Speaker A: All right, still spinning up. There we go. Okay, so to start off, this is going to connect to your local wallet. It also supports Wallet Connect if you're using a different device. I'm going to go ahead and just connect that hard Hat account here. Next we're going to deploy the Verifier. So that's going to be that generated contract that we had, and that will be a transaction.
00:13:18.628 - 00:13:56.980, Speaker A: As you can tell, my hardhat network is extremely busy right now handling all of these transactions. And then finally, we're going to deploy the ZK app contract. All right, so we've deployed it, we've connected. Let's look at actually that Verifier contract to just kind of go over what's inside of that. So this is our verification contract. We have an interface that we're going to use for that verify proof function that we're going to pass through. And then for the actual ZK app, we have defined that proof structure.
00:13:56.980 - 00:14:43.044, Speaker A: Here's the Verifier that we're going to connect to. And then here's just a simple list of records that we're going to store after each signature verification. The actual call we're going to do into this contract is record, which we're going to pass in those public signals. Once again, that message, and then the two components of the public key, and then the proof, which is then going to call verify. And then if that is successful, we will just add to that records variable inside of the contract. For the verify, we wrap that generated Verifier contract in that interface, call verify proof, and then we just get a simple result. Did it work or did it not work? And then finally, to kind of see updates on whether it succeeded, we have a total records that we'll check on the actual demo app itself, which is going to be this highlighted amount right here.
00:14:43.044 - 00:15:28.370, Speaker A: Let me zoom this in a little bit, too. So first we're going to create that local signature. And so that was pretty quick. What this is doing on the front end inside of our react app is going to be using the sign EdDSA signature here, which is going to be using a local component to kind of generate that signature. Normally in Ethereum for EOA accounts you're going to use an ECDSA kind of cryptography which is going to be very similar to EdDSA. The major difference from what I've seen is that EdDSA does not use a random nonce as part of the signature. So the signature should be deterministic for any given public key and message.
00:15:28.370 - 00:16:11.368, Speaker A: Otherwise they're very similar with some differences in the curves and some of the other things they're using. So we went ahead and generated that signature. We're now going to create a local proof with that public input and signals. And as you can see, we kind of enabled that there. So now we have our public signals and we also had our private signals, which is the signature and the components of that signature. Now we have the proof and now we're going to submit those as an actual transaction with the public signals and the proof to that ZK app contract. And there we go.
00:16:11.368 - 00:16:48.420, Speaker A: So it was verified and confirmed. We have our records updated. So we now have one record inside of there. I could potentially I don't think there's anything preventing me from sending the same proof again since this doesn't verify that there's any sort of confirmation for that. Yeah, that is kind of that basic DApp example running through that. And then let me also show real quick just what it looks like inside of the app for that submission for the send transaction. And so let's see here 1 second proof, proof, proof.
00:16:48.420 - 00:17:30.432, Speaker A: Yes. So we generated the proof and set it here into the state variable. We're passing it through the actual call we're going to have to send. The transaction is going to be just like any other kind of contract interaction. So in this case we're going to go to our ZK app contract, we're going to connect our signer so we can do a write to that and then we're going to call the record with those public signals and the proof. Once again, the components of that record are going to be the public signals, the message and then the public key components and the proof with those A, B and C components that were generated in that build step. And so yeah, that is our kind of very minimal basic functioning Zkat boilerplate.
00:17:30.432 - 00:18:36.200, Speaker A: Are there any questions? Yes. So this signal is actually creating the signature. So we're taking a let me go into that real quick. So we're going to grab our account that we've connected and use that as our private key, very secure, obviously. And then using the public key that we generate off of that, using that signing signature, that signal, that's input inside of this set for this, that is going to be our actual input that's the signal is that actual signature along with the public key or sorry, not the signature for generating the proof. The signature is one of the private components that we're passing in. So to go back once again to our circuit here, so we've just generated the signature which is this input S.
00:18:36.200 - 00:20:01.880, Speaker A: And then we also pass these other components in the R eight which are derived from that signature. This message is just going to be let me find that is going to be the simple constant, just 1234 and hex. So that will be the M component that we're passing in here and then for Ax and Ay is going to be that public key. Does that make sense? So yeah, when we go to actually generate that proof right, we do not need a private key but we're only providing as our public inputs that message and the public keys, our private inputs in this case it's a bit contrived but it's the signature essentially that we're doing is the private input. So when we and that DAP are generating that proof, we are going to have both of those components, the signature and then the message and private key. When the Verifier and the contract is running, it is only going to be able to see the message and the public key for that public input. It cannot see the actual signature itself that we've used to sign it, but it knows it exists and it verifies via the kind of underlying cryptography and math in that proof that that output is correct.
00:20:01.880 - 00:21:29.350, Speaker A: Cool yes, sir. Why do you need it in the first place? To generate the signature locally. But you don't need the private key inside of the proof to actually verify that signature because you already have the components you need to verify the public key, the signature and the message. In this case you could generate an ECDSA signature but you could not generate that EdDSA signature. For that we actually have to go and use the JavaScript code that we generated from that build step inside of our client and I can dive into that real quick as well. So that's going to be inside of this sign component and then this hook has been set so we can just more conveniently use it. So we have this from our circuit library and then inside of there is where we're going to actually init the signer with a private key and then we're going to use that component once again here to actually sign that message.
00:21:29.350 - 00:22:42.900, Speaker A: Cool james yes. Eventually if you are using a say more account abstraction, you will have the ability to generate different signatures that you could use from a wallet natively. Cool yes. Would be possible to reveal to show that I have another wallet actually is the owner of and that makes sense where I want to use this. Do things on chain. So that is a bit outside of the scope of what I'm going to cover here. The general thing that I'm not covering here that you would bring in is something called a nullifier.
00:22:42.900 - 00:23:31.712, Speaker A: And essentially you have an internal state managed by say, like a merkel tree and you use that nullifier to essentially claim or burn ownership when you're moving those assets around. That's what, for example, Zcash uses for transferring those different assets. I would probably look more into examples that are doing that kind of more asset transfer based thing. There are also our group which I'll bring up a link at the end to our website. We have a number of projects that build on top of this technology for anonymous social media applications, asset transfers within say like a ZK or optimistic roll up. And that would probably be a good place to start to kind of investigate that more. I think there's also been some other talks that dig in more to that more asset or kind of nullifier based circuitry.
00:23:31.712 - 00:24:31.840, Speaker A: But for this we're just going to cover and for my own knowledge personally, just kind of this higher level basic circuit. Yes. Yeah. So the Verifier is only checking. The Verifier only has access to these top three components. You as the prover or in this case the DAP has those private components, but the Verifier doesn't have access to those through how the math, once again a bit above my understanding. The cryptography and mathematics involved in that verification process allow for the Verifier to be sure that given those public inputs and the output that comes out at the end, that C, that it is a valid proof and that those were valid inputs for that proof.
00:24:31.840 - 00:25:24.270, Speaker A: Does that make sense? No. Yes. So yeah, inside of that check for that proof, that is what is actually going to run inside of that Verifier component we brought in. That is what is actually going to check that that private signature input in its kind of abstracted form matches the inputted message and public key. Cool. Any other questions? Yeah, you can do a lot of things. One of the bigger ones, as gentlemen over here mentioned, is being able to kind of privately swap assets is a big use case.
00:25:24.270 - 00:26:26.656, Speaker A: You can do things where I've seen examples where you may as, say, like a bank be able to have someone verify who they are by passing in, say, their Social Security number, date of birth and a pin as private inputs and having a circuit that runs to verify that they are the correct person without revealing those private inputs. So I think in a lot of cases the big two ones that are kind of always mentioned are going to be scalability and privacy. There's going to be a lot less data for some larger computations that you pass from these proofs and these signals into your actual verification, say, on chain in the EVM versus if you were to directly run all the computation yourself to check those in a contract in, say, like normal solidity code. And then obviously the other big component is going to be privacy. So if you have inputs you do not want to reveal to anyone else, any case where you might be able to use those would be potentially a good use case to use a ZKP. Cool. I think I have roughly about two minutes left.
00:26:26.656 - 00:27:17.840, Speaker A: So I'm going to jump right to the end. I am going to skip over kind of that multiple example for the zero knowledge proofs, but if you want to check it out on this repo, there's actually a branch already set up for this. You can ignore those wonderful errors. You can actually just go and there's a tutorial in that README and a branch for that that you can check out that modifies the circuit. So now, instead of just doing one of these signatures and messages and sorry, one of these kind of payloads, it now can do in this case, we're setting it to three. But you can see here how you can kind of expand upon some of those simpler examples and build them out into kind of bigger use cases. Finally, a couple of other things if you want to look for some additional resources.
00:27:17.840 - 00:28:07.920, Speaker A: Ethereum.org has a really good overview of zero knowledge proofs, and the further reading has some really good deep dives into the actual technicals of what math and cryptography are being used to generate these proofs and verify them. The Circum docs are really good if you want to learn more about writing circuits and the different components you can put into those. Circom Lib, which I showed with that sign. Verifier has a lot of templates and primitives you can use when building circuits. I showed off the kind of online Circom editor you can mess around with things. And our group also has a bunch of Zkjs Libs in ZK kit that you can use in your kind of scripts, servers, or front end applications along those lines, if you want to learn more about us and some of the applications and things we build, you can find us@appliedzkp.org.
00:28:07.920 - 00:28:36.420, Speaker A: And then finally, if you have any questions about this project or anything else ZK related, you can jump into our PSE Discord and we have a channel called Got a Question? You can also find that discord on that applied ZKP website. And I believe I'm out of time. Oh, one last question. Sure. You're welcome. Cool. Awesome.
00:28:36.420 - 00:28:37.050, Speaker A: Thank. Thanks, everyone.
