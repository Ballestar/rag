00:00:09.510 - 00:00:40.014, Speaker A: All righty. Hi everybody. Welcome to the Diving into Ether Cards workshop. Here we have Mickey who is from our sponsor Ether Cards. He's going to be sharing a lot about the Platform and what you guys might be able to do with it during the hackathon. So if you guys have any questions, just shoot them right into the chat and I'll try to get to them at the end. But if you don't get your question answered or if you have any other questions after this workshop ends, feel free to contact them in the sponsor Ethercards channel on Discord.
00:00:40.014 - 00:00:41.860, Speaker A: All right, Mickey, take it away.
00:00:42.310 - 00:01:50.140, Speaker B: Awesome. Thank you. So my name is Mickey, Sokach I'm one of the blockchain leads at Ethercards and I'm going to basically present the Platform and some inner workings of the system as an intro. Ethercard is a custom NFT platform that helps engage, grow and monetize your community. By using Ethercard's technology, you can or anyone, including artists, musicians and athletes, influencers and even nonprofits can create an unparalleled experience for their supporters. Now what I can show you right now is the NFTs that we've created for our own community and they are multiple classes creators, OGS, Alphas and founders which are delimited by their IDs. So basically we have the creators which are 00:29.
00:01:50.140 - 00:03:38.282, Speaker B: Then you have OGS, which start at ten and go up to 99, alphas that start from 100 and go up to 900 999 and founders which go up to from 1000 to nine nine as you can see the best cards out there. So creators, OGS and Alphas have custom visuals and founders have what we call layers. So every card has a couple of layers and those layers are somewhat of a trait or a property that are generated from. So the five layers to generate the image that you see and each one of them is created by someone and you can sometimes get a perfect one or get one that's been created by one specific artist. Now, Ether cards themselves have traits. These traits are basically properties or functions of the card. If you own one, what you can do with it.
00:03:38.282 - 00:04:58.226, Speaker B: For example, let's look at the reforged trait. This is a one time ability to randomize any or all selected layers of your cards accidental art image. So if you use this, you can reroll the layers that you have one moment. If you have the Art drop, for example, you get free NFTs from drops that launch their campaigns through either cards. If in terms of the architecture and how it actually works, we have two systems. We initially started with Trades off chain which were stored in an IPFS file. So if you take a look at the contract itself so this is an ERC seven to one NFT contract.
00:04:58.226 - 00:06:41.160, Speaker B: And when you take a look at the token Uri and you query the ID, you're going to see you're going to get a URL to a JSON file. Now this JSON file is served by a metadata server which loads the data from IPFS and manages or changes it in order to allow us to change it whenever you do something with it. So let's say for example, you use the reforged trade or you use the free ticket trade, then it's a lot cheaper to do it off chain in the metadata server. Yet some systems, like the reforge for example, really need the data on chain. So for that purpose we created the EC registry which I can show you here. It basically registers the fact that a card has a trait. It does just that and if that trait requires an implementer so for example, you have a trait that has a number or a value, let's say for example the limited trait slot or the punk battle ticket, you need a way to store that value.
00:06:41.160 - 00:08:28.470, Speaker B: And to store that value we have implementers. So if we take a look at the registry itself versus the JSON file from the metadata server, you're going to see that when you actually query the token data for a token ID, it's quite different, mostly because of storage considerations. We basically save a unitate array and in that array we use bits. So let's say you have token ID 58 and Token ID 58 is stored in the 7th byte of the bit array. And then the traits themselves which are let's take unicorn or reforge, they're stored in the same way, except that they have an implementer. So for trace that need an implementer, it's present here and you're going to see in a couple of minutes why and how we actually do those. For reading the onchain data and setting the onchain data, we provide an NPM package which you can find at Dashutil.
00:08:28.470 - 00:10:02.306, Speaker B: You're going to see this used in the testing suite for creating or decoding the bit array data, which is again for the trades themselves and for the tokens themselves. Going back to how it all works, what you have in blockchain systems usually is a front end that connects to a blockchain node and that blockchain node usually reads data from smart contracts. If you have a simple sale contract, if you have a simple crowdfunding contract, it's all good. You can just do, I don't know, 510 node calls whenever you load the front end. But when you have 50 trades and you have to load every single one of them, it's a lot harder. Especially when, let's say, for example, you want to view multiple cards from a front end which would require thousands of calls to the chain. For this thing we have the Metadata Caching server.
00:10:02.306 - 00:12:25.266, Speaker B: So the metadata server as well as a metadata view contract which is basically just a batch caller on chain which lets us read whatever contracts or properties we want up to like 1000 properties per call. You're going to see that used in our front end. So what else can I tell you about this? The EC Registry itself also provides access controls for the implementers which are then used by the card upgrade, battle royale or token sale contract, as well as forges, reforges and whatnot. And let's now take a look at a trait, the new trait that we're working currently, which is the dust generator trait. Now, when you design a trait, you want to be mindful about the user experience. So what happens when someone wants to claim their balance or they want to spend their balance to do something? So the dust generated rate is basically an implementer that generates an ERC 20 token which can then be spent in the ecosystem to unlock different things. And what I mean when I'm saying that you want to be mindful about it is if you want to make it easy for people to actually use it, you want to have methods on that dos generator trade that allows them to claim partial or full balances, claim multiple balances from multiple cards at once, as well as either go through approvals or not.
00:12:25.266 - 00:13:42.574, Speaker B: So when you do money RC 20 transfer, what happens? You have to first approve the transfer, then send the method call that you want to spend something. In order to just have one transaction that does this, you can basically upgrade your ERC 20 to a seven seven seven contract and use the unreceived method for it. So let's look at the code itself. Where's the GitHub repository? So this is public, you can take a look at it, you can use it. We have added the mainnet and the ring betasnet contracts. Right now you guys will not have access to actually write into them. So you can use the repository to deploy your own set of contracts, which is basically the ERC, DC Registry V two.
00:13:42.574 - 00:15:32.030, Speaker B: And if you need you have an NFT toolbox which is basically just an ERC seven two one with some superpowers like Mint, a specific ID or batch mint or take a token and give it to someone else so that should help you view and use the system. Okay? And why we have the ethercar straight registry hot pink edition. It was an in house joke about dyeing our hair pink if we didn't release this in time, but we actually did, so we got away there. So what you actually expect from the registry is just this. You have a trait with a name and implementer type and based on the type, it's either a normal trait that uses every single storage slot as so if the trait exists on a token ID, it sets a one in that position. But to be efficient, we added a second type, which is an inverted trade and then an inverted range. So let's say you have, for example, 10,000 tokens and 8000 of them have a trait.
00:15:32.030 - 00:17:21.020, Speaker B: If you invert the range, the trait itself and you just store the last 2000 as not having it, you save up three times the gas or four times the gas, mostly because you just save 2000 instead of 8000. So four times the gas. Yeah, it and in terms of implementers, the simple unate implementer is basically you're just setting some data for a token and that's it and you can get it later. This is useful again for ticketing systems, for the Battle royale, for Raffles, or even for the layer system in the Uintate array version. And what you basically do when you want to create a new one, you just extend the value implementer that you have and you deploy the contract with the registry's address and the trait ID that you expect this thing is going to have. Yeah, you're going to have access to the code and the deployers and everything else. I've included some extras.
00:17:21.020 - 00:18:50.000, Speaker B: One of the extras is the Ether cards forge. This is an on chain layer transfer system. So if you have let's look at a founder. So if you have two founders, one of them where is it? Here? So if we have a founder or another card, it doesn't really matter, and we have layers on it, and we want to shift the layers from one card to another, then we can use the layer forge to do this on chain. First of all, you have to save all the data on chain, which is quite interesting, mostly because it's quite heavy. So if we take a look at the actual image for the layers, you're going to see that we use hex values for layers. So you have five layers and you're going to have five hex values.
00:18:50.000 - 00:20:17.180, Speaker B: So what we do is have the accidental collaboration with five values, which can then be manipulated by the forge when it receives this, the exercise itself. So what we're actually looking for is new traits that might be interesting in different cases. Let's say, for example, you have a community that doesn't really need layers. They're not artist based, so in that instance you're not going to have them. What can you have? So the whole idea is we're looking for new traits that you guys can come up with and better storage optimizations for the existing traits. Because this thing, for example so the UN eight array val implementer this one. What does it do? It uses a mapping of the token ID UN 16 and then a UN eight array.
00:20:17.180 - 00:21:38.188, Speaker B: And this is a dynamic array, which means it uses 32 bytes to actually store five, which is really bad. What we can do is shift it around and have a five level mapping and then have 10,000 values per level, which would reduce that quite significantly. The problem with that is you have to write some assembly to actually get into the storage space, mostly because you can't reference storage space from memory, at least not in the current versions of Solidity. Any, any questions? I was kind of curious. What about the front end? Do you guys have some kind of way to spin up the front end as well? We do have a testnet implementation. This is the one that we use for testing purposes. I can give you guys access to it as well.
00:21:38.188 - 00:22:45.310, Speaker B: And it's just a react boilerplate based on Ethers JS, which uses our component. Yeah, we've added our own components into it and you're going to be able to spin it up pretty easily. And the other one is this one. So I'm going to add links to the batch caller that we're using in the front end to get 1000 properties off chain in one call through JS and Solidity. So, yeah, I'll give you access to these things in a moment. Thank you. Yeah, that's about it.
00:22:51.960 - 00:23:14.890, Speaker A: Okay, awesome. Thank you so much, Mickey, for this workshop. And thank you to Ether Cards for sponsoring ETH online this year. I do want to encourage everyone to continue this conversation on Discord through the Ether Card Sponsor Channel. And yeah, everybody have a really great day. Thank you again and and I'll see you at next.
