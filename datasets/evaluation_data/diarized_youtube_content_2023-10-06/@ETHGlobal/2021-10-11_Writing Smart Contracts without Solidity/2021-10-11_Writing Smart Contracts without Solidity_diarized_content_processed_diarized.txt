00:00:06.650 - 00:00:28.760, Speaker A: And next up we have Gilbert, and this is a very interesting topic that I'm super excited about. Gilbert is going to be talking about how do you actually write smart contracts without Solidity. We're going to go into some internals about how all of this works under the hood. And without further ado, let's welcome Gilbert. I'll ask you to turn your camera on and we're good to go.
00:00:31.130 - 00:00:54.900, Speaker B: Thanks a lot. Let me share my screen real quick. Perfect. All right. Hello everyone. My name is Gilbert. I am a smart contract auditor and instructor at Optilistic.
00:00:54.900 - 00:01:40.392, Speaker B: At Optilistic, we do smart contract audits and we also train people how to write smart contracts and then place them. But enough about me. Let's talk about smart contracts without Solidity. So we're going to go over several things in this talk. First, we're going to go over why should you learn EVN Opcodes as a smart contract developer. We're going to go over how to deploy a smart contract, or in other words, how to write Opcodes for deploying a smart contract without Solidity. We're going to take a quick look at a little new language called Trim.
00:01:40.392 - 00:02:20.340, Speaker B: And then we're going to implement a full smart contract using these Opcodes. So first. Why learn EVM opcodes? Well, essentially, you want to become a better Solidity engineer. What does that mean? If you know Opcodes, then you are better prepared for low level hacks and issues. Solidity's compiler has had problems in the past. If you understand Opcodes, you'll better understand why those things happened. Second, you want to have a deeper understanding of common design patterns, especially related to proxies.
00:02:20.340 - 00:03:08.564, Speaker B: Proxies use Opcodes all the time that are not available normally in Solidity. And it's great to have an internalized understanding of how smart contracts actually run when you're making transactions to these contracts. Okay, so to start, we're going to look at what I call BASM, which is bear assembly. And basically what this is is we want to be able to write these Opcodes without writing the raw bytecode. So on the left you have the bytecode, on the right we have vASm. So we definitely want to write what's on the right so that we don't have to. Well, I mean, it's pretty straightforward.
00:03:08.564 - 00:03:41.904, Speaker B: You don't want to write what's on the left. And yeah, this is pretty much all it is. There's pretty much no features in this language. All it does is that it takes your Opcodes and then converts it into its respective bytecodes and puts it all together. So let's use this to actually write some code. So for the first contract that we're going to look at, we are going to deploy a contract and it's going to be a very simple contract. There's not going to be any functions in this contract.
00:03:41.904 - 00:04:50.872, Speaker B: All it's going to do is whatever transaction that's made to this contract, it's just going to return the number nine just blindly. It doesn't even care doesn't care about what function you're trying to call, doesn't care about your arguments, it'll just return the number nine. So as you probably know, when you deploy a smart contract, you deploy the code of that smart contract, but also some additional initialization bytecode. So here we have some init bytecode. And the way that it works is that the bytecode that you use to deploy needs to return the runtime bytecode. So in other words, in this example, the init bytecode we have here the goal of this init bytecode, it can do other stuff, but ultimately it needs to return the data that represents the bytecode down there. So when we make a deploy transaction, the runtime bytecode is not going to run at all.
00:04:50.872 - 00:05:47.100, Speaker B: Only the initial bytecode runs just because of the way we wrote it, and then it will return it. So let's look a little bit at the details of how this works. So first we have a code copy, and this copies into memory a piece of the entire bytecode that you're running in your create Smart contract transaction. So the first argument here, what I have here is EVM is a stack based language. So all this code that you see on the left is pushing onto a stack. And then when you run code copy, it just pops off the top three items in the stack to do whatever it needs to do. So on the right hand side, we just have a syntax that's a little bit more readable for those who are not that familiar with Opcodes.
00:05:47.100 - 00:06:33.260, Speaker B: So this code copy takes three arguments, and the first one is where you're going to copy to when you do code copy, you are copying your bytecode data into memory. So zero just says stick it into this flat. And as you can see, this is going to copy some code and we're going to see exactly which code it's copying. The second argument is the offset of your contract by code. So this we hard code zero x zero C because it's 13 bytes before getting to that point. So that second half is our runtime code. We want to start there when we do the copy.
00:06:33.260 - 00:07:13.930, Speaker B: Then lastly, we tell it how many bytes to copy. So last over here we have ten bytes because our runtime code is ten bytes. So that will copy ten bytes into our memory slot, which is at zero x zero. Now that it's in memory, we can use the return bytecode or the return Opcode to return it. And return takes two parameters. First one is the memory offset we just wrote to zero x zero. So we want to start returning data from that point.
00:07:13.930 - 00:08:10.090, Speaker B: And then secondly, the length, which is again ten, because there's ten bytes of memory that we need to return. And that's pretty much it. So this memory or this data that we're returning, the green box, this is the code that the EVM will take and store at your new contract address. Now, whenever anyone makes any sort of transaction to your contract address, it's going to be running that specific bytecode, which again is the green box. So this works, but there's a problem. We are hard coding some bytes. And when you're writing code, you definitely do not want to be manually counting bytes so that you can just get it to run.
00:08:10.090 - 00:08:48.580, Speaker B: Adding one line of code will cause these values to be wrong and that's really bad. So that is the motivation behind the language Trim. So Trim is a little language that I wrote in a few days. And the idea is just to have a mostly purely syntax transformation so that you can write your code in a little nicer manner. You're still dealing with Opcodes. With Trim, there's not any fancy function calls or stacks or memory management. It's almost purely syntactical.
00:08:48.580 - 00:09:34.100, Speaker B: So instead of writing what you see on the left, which is the code we just saw, you can optionally write the thing on the right. Basically, the rule is anytime you have apprentices now, you're in S expression land and you can reverse the order of your arguments and it'll just translate it back to the left. So that's pretty straightforward. If you don't have parentheses, then you're still in Opcode land. For example, the stop on the right, that is just a plain Opcode feature. Number two is labels. Labels is how we solve the problem of manually counting bytes.
00:09:34.100 - 00:10:22.624, Speaker B: So on the left, we have zero C and zero A. These are hard coded values based on the length of our code. Now on the right, we can write this hashtag runtime, and that just represents a location in your code. So the last runtime on the right, that is the actual label. And then when you reference runtime within an S expression, it will fill in that location for you. So this is a way to get around manually counting bytes. The first line, we subtract the total code size with the position of runtime and that'll give us our runtime code size and we dupe it so that we can use it twice.
00:10:22.624 - 00:11:11.312, Speaker B: And then we code copy from zero to the runtime position with that length and return the length. So that's pretty handy. And last feature with Trim is instead of manually putting in strings, you can just write the string and it will translate it to that push statement for you. So again, these features are mostly syntactical. It's not going to manage memory for you. You're still writing Opcodes. Okay? So lastly, we want to look at an example of writing a full contract.
00:11:11.312 - 00:11:48.080, Speaker B: So here we are going to Emulate, or we're going to implement a version of this in Opcodes. So here's the solidity code. This is a little bit different from the standard greeter contract that you get from generating a new hard hat project. The main difference is it uses bytes 32 instead of string. And the reason for that is, just for teaching purposes, string is a lot more complicated than bytes 32. So I avoided that by just using bytes 32 directly. The other thing to note about this code is it has initialization.
00:11:48.080 - 00:12:25.324, Speaker B: So our bytes 32 greeting variable is initialized with Hello EVM. So that's something else that we're going to have to implement as well. So let's do it. All right, so on the left we have our initialization code, and it's pretty much the same as what we just saw in two slides ago. The only addition we have is the S store. We are storing in storage slot zero, our string Hello EVM. And that's pretty much it.
00:12:25.324 - 00:13:01.924, Speaker B: That's all you need. You just need these three opcodes. One opcode for S store, one opcode for push zero, and another opcode for pushing the string value. And then that's your initialization. Because it's initialization code, it's not going to make it into your runtime code, which is good. Now, on the right hand side, we have a reference for API encoded function cults of Greet. This is a function ID for Greet and then on set Greeting, that does have an argument.
00:13:01.924 - 00:13:44.240, Speaker B: So you have the function ID plus the value of that bytes 32. And that's what that looks like. We're going to be using that or referencing it when we write the code to access that. All right, so we just omit the init code for the slideshow. Didn't make more room. The first thing we want to do is copy the function ID onto the stack, and this is the transaction data. So on the right, this reference, I didn't mention, it's the data that you send with the transaction.
00:13:44.240 - 00:14:21.730, Speaker B: So if you're making a transaction to our contract, most of the time you're going to be encoding your data using API. And that's what we see on the right hand side. So if they're calling Greet, then it's going to look like that. I can use my mouse, can I? If they're calling Greet, then it's going to look like this right here. If they're calling Set Greeting with this parameter, it's going to look like that. In either case, we need to handle different functions in our contract. And the conventional way to do that is by using an API encoded function ID.
00:14:21.730 - 00:15:06.210, Speaker B: So we need to see if the first four bytes of our transaction data or our call data is either this here or if it's this here. And based on that, we're going to run different code. So that's what this first one does. Call data copy will read data from your call data. And the offset four is the length that you're reading. Zero is the starting point and one C here. This is the position in memory that you're writing to or you're copying to.
00:15:06.210 - 00:16:04.720, Speaker B: So zero, we want to start at the beginning, obviously, because the function ID is the first part of your call data four. We want to read four bytes. Four bytes is eight Hex characters so that we read the function ID and nothing else. And then this is actually 28 because this just makes it easier to deal with called Data copy. We want to write it as A-U-N 256, which is 32 bytes, but we're only writing four bytes. We're just doing this so that we can slot it into a very specific spot in memory to make things easier. And then here we are loading from memory position zero and M load will load 32 bytes so it will catch the data that we just wrote.
00:16:04.720 - 00:17:02.722, Speaker B: After that, we want to see if it matches a no function ID. And the reason we do that is because we're using Trim. Now we're going to have two different labels. One label for our Greet code and one label for our SEC greeting code. So this here, this is pushing a known function ID onto the sac and then it's duplicating the input function ID. And if they match, then it's going to jump to that label. So EQ will take the top two items of the stack and if it's true, it'll push a one, if it's false, it'll push a zero and jump.
00:17:02.722 - 00:17:42.690, Speaker B: I will only jump if the top of the stack is not zero. So in other words, if this matches the Call data's function ID, then it's going to jump to Greet and we're going to do the same thing for Stack greeting. So if this does not match, then jump ID or sorry, then jump. I will not jump. And then we'll move on to the next one and then we're going to check. Well, does our input match this function ID? And if it does, then we jump to set greeting. Otherwise we revert.
00:17:42.690 - 00:18:28.180, Speaker B: But this logic here, this is how Solidity gets compiled down. Obviously Solidity compiles into more bytecode than this with some extra features. But this is essentially how it works. It's basically a case statement. Does the function ID match this go here? Does it match this go here? And that's it. So now let's get into writing the actual code for these functions. It's a convention to have a jump destination opcode for places you expect to be jumped to.
00:18:28.180 - 00:19:28.450, Speaker B: It actually doesn't do anything, but I guess it makes the code a little nicer to read. And for Greet, the only thing we need to do for Greet is we need to load the current greeting. So first we load the storage at position zero and then we store that into memory because we need to return from memory and then we return it. So in other words, we're loading from storage into memory the current greeting and then we are returning that value. And that's the entirety of our Greet function secret greeting is pretty similar. In fact, it's even simpler. Call Data Load will load again 32 bytes from your call data and here four is the offset.
00:19:28.450 - 00:20:23.160, Speaker B: So we are skipping four bytes because we want to skip the function ID. And then the next 32 bytes we know is our parameter. So we load that onto the stack. That comma shouldn't be there, that's a typo. But we load the string onto the stack and we store that into storage slot zero, and that updates the storage. That's the entirety of the secret reading function. Then here we have a stop because just in case later we want to add more functions, we don't want to accidentally run over the normal problem, which statements you just kind of go over your case.
00:20:23.160 - 00:20:57.906, Speaker B: So that's what stop is done, that's what stop is doing there. So, yeah, that's the entirety of the contract. But how did we do? So if you compile this in Solidity, you end up with 404 bytes. And the code that we just wrote is only 76 bytes. So that's pretty cool. Of course, this is not without its trade offs. We are not checking call data length, for example.
00:20:57.906 - 00:21:52.774, Speaker B: Solidity checks call data length by default. That avoids, for example, accidentally setting an owner address to zero without providing a zero without providing an address and some other stuff. Solidity also makes sure that all your functions are not Payable by default, which means that it generates spike code to revert if the transaction has ether value in it. It does that for all functions unless you specify payable. So there's trade offs there, but it's pretty cool. We can write some Opcodes and we can be how many times is this? Like four times smaller than the default Solidity bytecode generation. But yeah.
00:21:52.774 - 00:22:50.034, Speaker B: So hopefully that gives you a good taste of how to write smart contracts without Solidity with plain old Opcodes. We use Trim as a language just to make things a little bit easier to read and write, but ultimately it's still just Opcodes. So learning this stuff will make you a better engineer. It will help you internalize how things work at the lowest level of the EVM. And Opcodes are just good to know in general because things like Proxies and static calls, those are all using Opcodes that are not available in normal Solidity code. And lastly, we teach smart contract engineering and security at Optilistic. So if you or anyone else is interested in becoming a smart contract engineer, we take mostly senior engineers.
00:22:50.034 - 00:23:05.394, Speaker B: We only make exceptions for special cases. But yeah, if you're interested, then visit our website and contact us. Awesome.
00:23:05.512 - 00:23:21.198, Speaker A: Thank you. Gilbert, a couple quick questions. Where can people learn about Trim? And could you talk a little bit more about some resources to sort of play with it or debug things and just how people should think about trying it out when they're doing an October directly?
00:23:21.394 - 00:24:02.242, Speaker B: Yes. So preparing for this was a little bit rushed, I'll be honest. Trim is not published yet, but it will be soon. And we also have a really cool in browser tool for kind of writing Trim and it just automatically runs your code as you type it and it shows you the results, it shows you your memory, it shows you your stack usage, your gas usage and all of that. Yeah, if you're interested in knowing when it does get released, just shoot us an email in optilistic and I'll put you on a list. Awesome. Wonderful.
00:24:02.306 - 00:24:08.710, Speaker A: Well, thank you so much for that amazing demo and presentation and can't wait to see how to play with Trim.
00:24:09.850 - 00:24:11.380, Speaker B: Thank you very much. Great.
