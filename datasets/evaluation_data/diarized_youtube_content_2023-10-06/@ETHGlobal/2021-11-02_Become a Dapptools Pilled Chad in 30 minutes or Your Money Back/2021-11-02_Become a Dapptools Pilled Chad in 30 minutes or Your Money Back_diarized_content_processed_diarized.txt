00:00:00.090 - 00:00:17.520, Speaker A: Have transmissions here, he's going to be eluding it. And yeah, if you have any questions, feel free to pop them right into the chat and he'll try to get to them at the end. But if not, then you can reach him on the DevTools Chat K transmissions. You can take it away.
00:00:19.970 - 00:00:22.160, Speaker B: Cool. Does everyone hear me all right?
00:00:23.570 - 00:00:25.040, Speaker A: Yes. You sound fine.
00:00:25.690 - 00:00:47.658, Speaker B: Awesome. Okay, so, yeah, as explained, this is the kind of Daptools intro talk you see, a kind of compendium of Daptools excitement tweets. So if you've already tried Daptools, hopefully you can learn something from this talk. If you haven't, buckle up. How do I move? Slides on. Okay, there we go. Really quick.
00:00:47.658 - 00:01:11.090, Speaker B: I am a developer of our capital. I'm a DAP. Tools convert and vocalshill on Twitter. I mix literally a library sometimes. You can find me at transmissions Eleven on GitHub and Twitter. Just going to acknowledge Giorgios, who helped with some of the images on this talk and also some of the content. This talk is for developers who are already comfortable with Hard hat.
00:01:11.090 - 00:01:57.038, Speaker B: If you haven't started with Ethereum at all, you might want to go learn about some of those basic concepts first. But otherwise, yeah, we're going to take to the next level. So I'm going to start off by posing a question. What do these two contracts have in common? They're the top Ether balance contracts on Ethereum, the ETH two deposit contract and the wrapped Ether contract. They add up to hold like, 13% of all Ethan existence at casual $60 billion. As might be obvious from the talk, they're both built with DAP Tools. You can see in the consensus specs repo, they're importing DS test, which is the DAP Hub test framework, and same with the Weath repository.
00:01:57.038 - 00:02:33.066, Speaker B: So if the two biggest contracts on Ethereum trust Daptools, maybe you should consider trusting it too. So what is this Daptools thing? It's tooling for writing, testing, fuzzing and deploying Slitty smart contracts. You hopefully know at least three out of four of those things, what they mean. It was developed by the DAP Hub team, which is like MakerDAO's engineering division back in the day. That's Andy in the top right presenting it at like, DevCon three. It's been used by the E two deposit contract, makerdal Fractional, Reflexor, Pickle Maple, countless others. It's got almost 1000 stars on GitHub right now.
00:02:33.066 - 00:02:55.710, Speaker B: And I just gave some logos here. Yeah, really quickly out of the way. It's like kind of a replacement for Hardat. You can use them in the same project, but they kind of serve the same role. And you can get mostly the same features out of both. But DAP Tools has some couple of bonus ones that I'm really excited about, and I'll be showing you in the talk today. So really quickly? Why not? Hard hat.
00:02:55.710 - 00:03:27.086, Speaker B: You might really like hard hat. So why should you consider switching to DAP Tools? First of all, nothing super wrong with Hard hat, like no shade intent at all. But writing tests in JavaScript is just not enjoyable for me. And yes, that includes TypeScript. I'm sorry, there's just way too much boilerplate. There's like hundreds of files if you look in like Paul's Ethereum template, which is great, but there's like a million dot files and config and it takes a while to install and there's a pre commit hook. There's all this stuff about managing big numbers.
00:03:27.086 - 00:03:59.378, Speaker B: BNJS. BN. JavaScript now has its own native big number. This is all a pain to convert between and when you're just trying to test your Solidity smart contracts and you have to operate in this whole JavaScript world of converting these numbers, it really kind of takes you out of the mood. And it's also just slow for complex tests because you're running JavaScript isn't a fast language. And some of the time you're actually interfacing with the kind of EVM over RPC even, which is going to be even slower because you're making network requests each time. And the main reason I don't like it is just because it's context switching.
00:03:59.378 - 00:04:29.470, Speaker B: I want to focus on my Solidity. I don't want to be debugging some random issue with big numbers or other JavaScript stuff that's kind of in the way. It's kind of a whole level, a different level of abstraction which is separated from my Smart contracts. And then the other thing is not enough tools. So you might be familiar or might not with fuzzing and symbolic execution. Here's some really advanced testing tools and get you a lot more confidence that your code works as intended. But currently you need to use separate tooling to access them, like Manticore Ekidna.
00:04:29.470 - 00:04:55.046, Speaker B: These are separate from your hardhat project. They're kind of a pain to set up, especially if you're writing similar tests for both. But they're in entirely different languages in one project. And because of this, not many devs kind of integrate these tools and they're really awesome. And they can save your contracts from getting hacked for millions of dollars. So if we want devs to write more secure code, we need to give them better tools. DAP Tools.
00:04:55.046 - 00:05:22.180, Speaker B: Is that better tools? All right, DAP Tools 101. Like, kind of why DAP tools now? No JavaScript. You write your test in Solidity. For some of you, that might actually sound pretty bad. I know a lot of people kind of have this grudge against Solidity because it's like, well, it's not JavaScript. It's not super powerful. Okay? There's just kind of a really nice I think you'll find that there's a really nice just kind of vibe with being very close to your code and not having this layer of abstraction that is JavaScript most of the time.
00:05:22.180 - 00:05:41.434, Speaker B: So you write your test in a function, in a t sol file, which indicates this is test. Here's an example of a kind of test function up here. And then we got features. It's fast. It's really fast. You can run builds in less than half a second. You can run a whole test suite in seconds or two.
00:05:41.434 - 00:06:13.342, Speaker B: You can run invariant tests, symbolic tests, and these can all run at most couple of seconds and with fuzz test a little more. But it's fast, it's low boilerplate. I'm going to show you that we can spin up a batteries included DAP Tools project that is like completely production grade in 10 seconds with no kind of templates necessary. It's got powerful cheat codes, which we'll explain more. It's got gas snapshotting, main net, forking stack traces. Here's an example of stack traces. Look, you can see all the events emitted functions called where it reverts.
00:06:13.342 - 00:06:57.386, Speaker B: You've got a visual debugger console log equivalent. I know many of you probably love console log deploying verify on ether scan install dependencies from any GitHub repo, built in test coverage, invariant tests, property tests, symbolic tests, and it's all through the command line. So you can kind of build your own kind of abstractions on top of Daptools like really easily, just with bash scripts. So really quickly, Daptools has a lot to offer. It's actually a collection of tools. There's Seth, which is this tool that lets you read and write from the chain, DAP, which is what we're going to be focusing on today, which is for compiling, testing and debugging smart contracts. And then DAP kind of uses this lower level tool they've written called Hevm, which is like a custom EVM implementation designed around debugging and symbolic execution.
00:06:57.386 - 00:07:28.890, Speaker B: So we're going to focus on DAP and what the rhythm for building and testing smart contracts look like. But I encourage you and maybe I'll have a follow up talk sometime about trying to explore Seth and Hevm on your own. So really quickly, I'm probably going to be going at a pace too fast to follow along, but just I'll have these slides. I'll send a link at the end so you can kind of use this as a reference. You install Daptools, you install Nix first. Then you install Daptools with the shell installer. Make sure if you're on an M one Mac, you do this in a Rosetta terminal.
00:07:28.890 - 00:07:47.902, Speaker B: Okay? Creating a new project. It's really this simple. You create a new directory. You enter the directory, you call DAP init, boom, you're done. Those are two tests that are already spun up and running. That's literally it in 10 seconds. We spun up a fully functioning, batteries included DAP Tools project with two tests that just ran.
00:07:47.902 - 00:08:23.202, Speaker B: And look at that little time window at the bottom that took 6 seconds for the tests and the spinning up of the project. So the speed to getting started with Daptools is really second to none. So, compiling, you see this is the kind of default Daptools project structure. We have an SRC folder, some git configuration. The main thing you want to focus on is SRC folder. We have the test project Sol, which is like our contracts, and a test project T Sol, which is our tests. I purposely edited the kind of default to have some broken code that doesn't compile.
00:08:23.202 - 00:08:47.118, Speaker B: You test that by running DAP build and you'll see this kind of colored compiler output that tells you, look, you didn't declare these identifiers. That's pretty obvious. And yeah, this is less than half a second for a build. So let's do some basic testing. So if we go back to that function, we remember we have this Add x plus y function. How are we going to test this? Well, first, let's kind of understand our tests. So in the test project T Sol file, this is where we put our tests.
00:08:47.118 - 00:09:05.020, Speaker B: You can see that here. Let's keep it simple for now. You can see that we have this kind of test project contract. It inherits from this DS test thing. It's got a setup and it's got a test. So what are all these? The red stuff is the DAP Tools Testing Framework. It's kind of the solidity library you import that has these helpers for you.
00:09:05.020 - 00:09:48.454, Speaker B: You declare the kind of contracts you want to test using state variables. You have a setup which gets run before each of your tests. And the cool thing about setup, which makes Daptools so fast, is you may be used to fixtures in hard hat, which you have to explicitly declare a kind of state you want to roll back to. Daptools automatically just runs your setup once it kind of caches that state and just rolls back to it for each test, which makes it much faster than rerunning it each time. You can see with the cyan, we have a test, and then we have like an assertion inside that test which looks kind of similar to normal, solidity assertions, but there's some more powerful versions that we'll see. So this is how we're going to test our Add function. You see, we call our project contract and we call Add.
00:09:48.454 - 00:10:17.140, Speaker B: We pass the arguments one plus two. We assert that this is true, that it equals three. So how are we going to actually run these tests? Well, we run the Dat test command. You put this in your terminal in the same directory, and you'll see this output. You'll see it runs the test and it gives you the gas usage of the function, which is super dope, and it tells you that it passed. All right, that was pretty easy. What did that take us, 15 seconds probably, to get that started.
00:10:17.140 - 00:10:48.170, Speaker B: And you can also use this verbosity, three flag, to kind of see a full stack trace for the test. You can see that it ran, set up, it created our test project. It called Add, and then it returned three. Okay, now let's try making our test fail. We change this to this from three to four. We introduced a bug, so this should fail right we run DAP test again and says assertion failed. The problem is, this error kind of sucks.
00:10:48.170 - 00:11:32.986, Speaker B: Maybe for now, because it's really simple test, we can know exactly what's going on. But if we've got really complex tests with lots of different values, we really want to get a better error message than this. Luckily, Dapsils to the rescue. Dstest has a crap ton of assertion functions that you could take advantage of that are much, much better. So we can swap out our assert true for assert equals, which all you do is you just kind of put the thing it should be equal to as the second argument. And now when we run our test, we see this beautiful stack trace that shows us the uns didn't match what we expected it to be and what it actually is. Okay, now let's make a new function.
00:11:32.986 - 00:12:05.454, Speaker B: Say we have this function called no Fun add. No Fun add doesn't let you it acts like add, but it doesn't let you add two values that would equal 69 or 420, and it will revert with you cannot have fun. So how are we going to test this? How do we test for reverts? So let's first just make a normal test. Like this wouldn't revert. We have this test add no Fun numbers. We assert that zero plus 69 equals 69. But this is going to fail, right? Because our thing reverts.
00:12:05.454 - 00:12:29.894, Speaker B: So, yeah, just as expected, if we run our test with that test again, we can see that it reverts. Test add fun no numbers. We can see no fun. Ad It reverts on line twelve in there with the you cannot have fun message. So how are we going to assert that it's reverting here? Right? It's probably simpler than you're expecting. That's it. You just prefix the test with fail.
00:12:29.894 - 00:13:03.510, Speaker B: So test fail indicates that the test will only pass if the function reverts. And now when we run it, we can see it passes. So test fail makes the test kind of act in the inverse of a normal test. A normal test will fail if the test reverts or an assertion is violated. Test fail will fail if an assertion is not violated or the test succeeds. So this is demoed here. If we like no fun add, zero plus one won't revert because that's not one of our funny numbers.
00:13:03.510 - 00:13:34.044, Speaker B: The test fails because it didn't revert. All right, so here's the problem with these kind of concrete tests that you're used to in hard hat and you just saw, okay, well, this is pretty cool. In DAP Tools, I can write it kind of similar way, but here's where Depth Tools really takes it to the next level. So this test doesn't really give us a ton of confidence our ad function is correct. Like, what if the add function just always returns three? Our assertion wouldn't catch that bug in the code. To be really sure our function is correct. We need to try lots of inputs on it, right? So we could duplicate it a bunch of times.
00:13:34.044 - 00:13:59.268, Speaker B: We could have one plus two, one plus three and assert on all this. I mean, it's better, but there's still millions of combinations we aren't trying. Right? So this is where Fuzz testing comes in. What if Dapsols could generate random inputs for us? So here's how you do that. You have this test add numbers function. This is our normal test, but we adapted it. Now it's taking arguments, it's taking a UN, it's taking another UN x and y.
00:13:59.268 - 00:14:40.580, Speaker B: We call project add with those UN values and then we assert that it's equal to x plus y. Test functions can take arguments. Daptools is now automatically going to try random UN arguments on this test function for us. We don't have to define values in advance. So if we run DAP test, you'll probably be surprised to see that it fails. Okay, what the hell is going on here? This is a bit of a complicated error message revert screen and our function looks correct, right? It's just adding x plus y. So if we kind of zoom in on this, you'll see that it failed, it's got red and you see this big stack trace and it shows us a kind of counterexample the inputs that cause the test to fail.
00:14:40.580 - 00:15:14.750, Speaker B: You can see it failed due to a revert. And test can either fail because their assumptions broke or a function call reverted. In this case, it was a revert. This is a solidity panic, which means it's kind of a solidity compiler check was broken. We can look in the documentation. Since it ends with eleven, this means there was an overflow that happened and now this input starts to make sense. We're trying to add these two huge numbers together, which is going to cause an overflow and cause our test function to revert, which is going to lead to Daptools thinking that something is wrong.
00:15:14.750 - 00:15:47.796, Speaker B: So we can solve this pretty easily just by changing the arguments of the test function to be UN 128. If both parameters are UN 28, the max UN 128 plus the max UN 128 cannot ever like it can't exceed UN 256. So if you run our test again with these modifications, they pass. It ran 100 times. It's pretty neat. DAP Tools is spamming our tests in essence with a bunch of inputs, which gives us more confidence. Our code is correct by default.
00:15:47.796 - 00:16:13.600, Speaker B: It tries 100 different inputs. You can increase it with this. Fuzz runs flag. Now it tries 10,000. Okay, this is cool, but it really isn't good enough yet. We need to be sure every possible combination works if we want to be sure our contract works as intended. This might seem kind of trivial with like an add function you're like, okay, I mean, it's adding two numbers, but when you're dealing with your kind of D five project or whatever, where there could be a math bug, somewhere that could wipe the entire system.
00:16:13.600 - 00:16:39.172, Speaker B: You really need to be sure that every last number is accounted for. The kind of problem with doing this with fuzzing is beyond a certain point. Like, every fuzz run takes some time. And if you want to assert 10 trillion fuzz runs, that's going to take 10 trillion years. All right, how do we fix this? Symbolic execution. So this is kind of an advanced topic. Symbolic execution is a way to test code for correctness you as the developer use the same way you use fuzz tests.
00:16:39.172 - 00:17:24.488, Speaker B: You define inputs. You run code with the inputs, make assertions. Daptools will let you know if it can break your test and give you inputs on how. So we're not really going to go into depth about how symbolic execution works, but just kind of under the hood. It kind of converts your code into math, and then it uses a math solver to kind of point to places to kind of find ways to all the states your code can be in. And if any of those states violate some of your assertions, dab tools lets you know we're not going to go into detail. So how do we make our boring old ad numbers test a symbolic test that will basically, in effect, try every possible input? Do you catch that? We just renamed the test from test ad numbers to prove ad numbers.
00:17:24.488 - 00:18:07.636, Speaker B: That's really it. So, yeah, Daptools makes it trivially easy. Turn any fuzz test into symbolic one. Now, if we run DAP test, you see it passes and Daptools is able to kind of reduce this down to math, kind of solve it and show that no branches kind of violated our assertion. This is super sick. And now, assuming there aren't bugs in DAP tools of the solver, we have 100% certainty that our assertion holds over every single possible input that a system can be in. So why should we ever use a fuzz test if symbolic execution tries every input and is still fast? Like, can we just throw away test and use prove? Symbolic tests are great, but sadly, they can't be used for everything.
00:18:07.636 - 00:18:44.780, Speaker B: They're constrained by the complexity of the code they're testing. Blah, blah, blah. Basically, the more complex your code is, the more states it can be in and the more kind of math equations the solver has to find. So symbolic execution basically becomes infeasible beyond a moderate level of complexity. So use symbolic tests for, like, math functions which don't really have a lot of possible branches or isolated parts of your code base, but you're probably going to end up using fuzz tests for larger parts that are too complex to symbolically execute. Just a quick comparison. So fuzzing, you get fairly strong assurance.
00:18:44.780 - 00:19:27.660, Speaker B: It depends on how long you run the fuzzer. And there's no limit to the complexity of tests it can run with symbolic execution, you get near 100% assurance, but it can only be used for kind of simpler code. Let's discuss one last DAP Tools test type invariance invariants let you test function test assertions about your higher level state relationships. For example, like the total supply of the wrapped ether token should always be equal to its ether balance. So invariant tests allow us to kind of just write that and not define all the functions Daptools needs to call. We just kind of let Daptools explore our contracts on its own and test the assertions to ensure they're always true. So how do we do this? We have this contract called increase.
00:19:27.660 - 00:20:01.464, Speaker B: It is a value state variable, and it has a value times two state variable which we want to assert is always twice the value of value. So we know we can use invariant tests. So how are we going to do that? Invariant tests look similar to normal tests. They don't have arguments and they're prefixed with invariant. Instead of test approve, daftools is just going to look at all the contracts that are stored in your test contract and call them with random values. So we can write our invariant like this. And variant times two, we have an assertion.
00:20:01.464 - 00:20:31.110, Speaker B: We say that the project value should always be equal to value times it should always be value times two should always be equal to twice project value. So that's a typical assertion. If we run this with that test, we'll see that it takes like, about 6 seconds. And it tried over 2000 call combinations. And after, none of them did our invariant break. So this is pretty good. Like, we got some nice assurance about that.
00:20:31.110 - 00:20:57.260, Speaker B: Wait, did I just okay, yeah. So let's add a new function to our test called breakthean variant. Not to our test, but to our project. So we have this breakthean variant function. It takes a UN eight. If the number doesn't equal 69, it's going to revert. But if it does, it's going to mess up value times two.
00:20:57.260 - 00:21:14.752, Speaker B: So if anyone calls this with 69, our invariant will break. So let's see if DAP Tools can catch this. We're not going to change our test at all. Yes, it did. We ran DAP test and we can see our invariant failed. And we can see this kind of big stack trace. And we can see it found a way to break it.
00:21:14.752 - 00:21:34.250, Speaker B: It expected three, and it was actually four. You can see in the red all of the calls it's making. It first called increase. Then it called break the invariant with 44 and that reverted. And then it called it with 69. And then it saw the invariant broke. So we can see it first tried calling with the wrong number, and then it called it with the right number.
00:21:34.250 - 00:22:00.272, Speaker B: And after every call it makes, it checks the invariant holds the first two times it did. And after calling break the invariant with the right number, it broke. So this is pretty neat. We didn't have to write any specific test logic testing to break the invariant function. Adaptools just kind of found that for us, which is pretty amazing. So it held each time, except for the last. Okay, now we're going to get into some kind of assorted stuff.
00:22:00.272 - 00:22:23.304, Speaker B: If you're a hard hat user, you'd probably have fallen in love with console log. Where's your console log? Don't worry, it's right here. So we have these kind of it's slightly different. You use events, these log events, which get printed to your stack trace. It'd be trivially easy to make a console log type library that just wraps these events. If you don't like it, if anyone wants to work on that, reach out to me. But yeah.
00:22:23.304 - 00:23:00.640, Speaker B: So you just emit log UN, which is the type we're logging here. So we log an unsigned integer and we'll see if we run our test, that it shows our value here. And basically, these logs only show up if your tests fail by default. But we need to use a verbosity of two to see logs for passing test, since the test isn't failing. All right, you might be wondering, okay, this is kind of confusing. Can I give this log a label? Wait, where did my label slide go? The answer is yes. You just use log named UN with the label.
00:23:00.640 - 00:23:29.688, Speaker B: So there's a log for every function type. All right. Some other features you have built in coverage. So you can have all your tests written, and then you can kind of run DAP test coverage. And it gives you this output that shows for every line of your code. Does a test at some point touch that part of the code? So you can see here we have coverage for this file. And in the console, it shows us, highlighted in green, the lines that are covered.
00:23:29.688 - 00:23:47.920, Speaker B: So everything's covered here. But here in this function, not everything is covered. So red areas indicate that code is not reached in any of your tests. So you need to write some tests where that code is written, and then it'll turn green. This is really sick. I'm sad I have to gloss over this because we're kind of running out of time. But DAP debug.
00:23:47.920 - 00:24:26.428, Speaker B: You can run Dapdebug in your console. It opens up this kind of visual menu where it lets you select which tests you want to debug. You select one of them and it gives you this really kind of, at first confusing, but really powerful debugger view where you can kind of step opcode by opcode through your code. You can see we have a stack trace on the right that updates as you step through your code. We see which part of my code is executing in bold, we see a live view of the EVM stack. And this is really useful for seeing why your code takes so much gas. You can see all the opcodes that are run and be like, oh, there's an extra s load here, let's cache that.
00:24:26.428 - 00:24:48.740, Speaker B: And it's also useful for seeing what part of your tests execute when things are breaking. But is there main net forking? I see this question a lot and for some reason people assume DAP Tools wouldn't have main net forking. It definitely does. You can see this in the docs. You just run DAP test with the RPC URL flag. In this case we could use like COVID infura and then your tests will run in that environment. You just write them as normal.
00:24:48.740 - 00:25:27.830, Speaker B: What if I want to change the current block? The current timestamp update a storage slot cheat code depth was this thing called cheat codes. They're implemented basically as function calls to the special address. There's set block timestamp, set block number update a storage slot, load from a storage slot, and this kind of other crazy stuff. Here's an example of using them. We define this kind of hevm interface, we define the hevm address, and then in our test we can call hevm warp. And this moves the block timestamp five days in advance. This can be used for testing functions that depend on the time, right? Like compound interest.
00:25:27.830 - 00:26:01.176, Speaker B: Yeah. So that was all I want to go through. In terms of slides, I'd suggest starting with I know I said no templates are necessary, but there are some kind of helper scripts you can get, and especially if you're using something like Vs code which doesn't recognize Daptools projects by default. I'd recommend trying out Giorgios's Daptools template. Daptools doesn't end with just the DAP command like I showed you. Make sure you try out Seth. We've compiled the list of Daptools projects to learn from as examples in this Rajiv PO awesome Daptools repo.
00:26:01.176 - 00:26:27.380, Speaker B: I'm a maintainer you can find the slidestalk atoolstalk and if you have any questions, please reach out at htpsdap chat. This is Daphub's or Daptools'kind of chat room. There's a lot of awesome developers in there ready to help you out. I am one of them. I'm quite active in there. I say good morning every day in the random channel. Please join.
00:26:27.380 - 00:26:46.200, Speaker B: Authentication is broken for everything except Twitter right now, so don't be disheartened. Just make sure you're logging on with Twitter in there. I'm active. You can ask questions about this talk. Just ping me or DM me at t eleven s or adaptos in general. So that's your place. Thanks for listening.
00:26:46.200 - 00:27:12.016, Speaker B: That was our Quick DAP Tools overview. I think I have about at least like four minutes to the end of this talk. Might be able to abuse my little five minutes. I can use after to give a quick demo of how we'd write and test the weath function. Not the weath function, a wrapped ether contract. So I'm going to try to go ahead with that. So here's a test project I just spun.
00:27:12.016 - 00:27:39.656, Speaker B: Up in advance. So we have this we test, we have this we. I'm going to start out really simply by so this is one of the awesome features of Daptools is you can install GitHub repos as kind of dependencies. You don't need NPM modules. You can just do HBS GitHub.com. Or wait, you can just type it as like this. You can type Rari Capital Soulmates as kind of a library of sliding functions.
00:27:39.656 - 00:27:58.852, Speaker B: Oh, I have to commit this on Git first. Sorry. One little quirk. Add an existing repository desktop test project. We can add this repository. We're just going to commit this. Okay.
00:27:58.852 - 00:28:34.072, Speaker B: So we can install the Soulmate repo, which is like a kind of open Zeppelin replacement in some ways. It installs it into our project and now we can import it. So I'm going to import the ERC 20 base contract from Soulmate. So you just do it like this soulmate tokens, ERC 20 Soul. And we're going to have our Weath contract inherited. Because Wrapped Ether is an ERC 20, it's going to want a name. So we're going to name it Wrapped Ether, going to give it a symbol WETH, and we're going to give it 18 decimals.
00:28:34.072 - 00:29:05.720, Speaker B: This is the typical Ethereum decimal scheme. And now we don't need any constructor because width is pretty simple. But we're going to need to implement a deposit method. So deposit is an external payable function. And just to save a little time, I have the code already implemented down here. So I'm going to put this in here. I have this other safe transfer library which is just kind of for handling ETH transfers safely.
00:29:05.720 - 00:29:27.484, Speaker B: All right? Boom. So we have a minimal version of the Wrapped Ether library implemented here. Of the Wrapped Ether contract implemented here. Now let's test it. So first of all, we can just see our test over here. We can build the contracts really quickly to make sure everything works. So we type that build in our console works perfectly.
00:29:27.484 - 00:29:57.320, Speaker B: We see that little check mark so we know it's working. Let's implement a really simple concrete test. We can test test deposit. So our test contract actually starts out with Daptools with a crap ton of Ether in it. So we don't need to get Ether anywhere. We can just write we deposit value and let's do one Ether. And now we'll make an assertion that we now have our test contract, which can be accessed under address.
00:29:57.320 - 00:30:18.512, Speaker B: This has one ether of weath. So the wheat token is minted when we deposit one ether of wet. So we run DAP test. Boom. Our test passed. So you're probably thinking like, okay, you just showed us all this fuz testing stuff. Why don't you put it to work? Let's put it to work.
00:30:18.512 - 00:31:07.016, Speaker B: So we'll do UN 256 amount to deposit. One caveat here is, since we don't have unlimited ETH that starts out in this test contract, we have to ensure that our balance, that this amount is not greater than our balance. So if this amount is greater than our balance, we exit the test early. And now otherwise we can just replace all of our hard coded uses of one ether with amount. And if we run depth test, you're going to see it tried 100 combinations there, and our test passed. That's a really simple fuz test. And if we want to be a little more confident, we can bump this up a bit and you'll see that it's just going to try to grind basically our function for any function, for any values you can find that break it and it passed.
00:31:07.016 - 00:32:01.440, Speaker B: Our weak implementation is looking pretty good. I was going to demo withdrawing, but just to kind of speed this up a bit, let's show off invariants really quickly. So to kind of implement an invariant like the Weath balance, I gave this example in the slides, but we might want to say a total supply invariant, which is like the Weath total supply is always equal to the balance of the Weath contract. Oh, maybe I'm a little zoomed out by the I hope everyone could read that. So this invariant now Daptool should try to call our wheat function a bunch of times and see if it can break this invariant. Let's run this. So it's going to first test our test deposit function, and that's going to use our test invariant.
00:32:01.440 - 00:32:43.950, Speaker B: And both passed. So what was that, three minutes? And we have a wheat contract that we just fuzz tested with invariants. Yeah, let's demo one or two more features we might want to demo. I'm going to turn this back into a concrete test really quickly, just for simplicity. We can demo our DAP test coverage view. So if we reset our terminal here and we write DAP test coverage, you can see that our We Sol contract, we tested the deposit function, but we didn't test this withdraw function. So that's something we have to be aware of.
00:32:43.950 - 00:33:04.404, Speaker B: We can try out the DAP debugger really quickly just to show what that looks like. So we have this test deposit function, and we can kind of step through every part of it. So you can see this is the constructor being called. Let's just skip down the stack trace. Okay, now here's the juicy part. So we deposit we call this mint function. We get the message center message value.
00:33:04.404 - 00:33:26.476, Speaker B: You can see the stack updating. You can see the opcodes going one by one. You can see it minting the token, and you can see the event showing up here on the right. That's the debugger. That's invariant test, that's coverage. And this was all with straight out of the box DAP tools, no config required. So that is the end of my talk.
00:33:26.476 - 00:33:31.230, Speaker B: I would go longer if I could, but I know that we're already over.
00:33:32.640 - 00:33:57.136, Speaker A: Hey, thank you so much, transmissions for logging on and doing this really great workshop. Thank you for everyone who tuned in through Zoom. And thank you to the 20 or so other people who are watching from YouTube. I want to encourage everyone to, again, reach out to transmissions, keep this conversation going, and, yeah, have a really great day. Bye.
00:33:57.328 - 00:33:57.970, Speaker B: Thank you, everyone.
