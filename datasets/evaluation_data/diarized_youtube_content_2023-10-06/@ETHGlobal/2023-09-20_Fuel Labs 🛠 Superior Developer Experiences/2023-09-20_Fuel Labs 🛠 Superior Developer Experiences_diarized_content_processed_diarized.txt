00:00:07.530 - 00:00:54.190, Speaker A: Hi, guys. So today I'm going to be talking about the superior developer experience at Fuel Labs. My name is Carl Delegation and I work as a developer relations engineer at Fuel. And in this presentation, I'm going to talk about what Fuel is at a high level, why you should care about developer experience, and showcase some of the unique features of Fuel, namely predicates. And so you're wondering to yourself, what is Fuel? Fuel is a modular execution layer. It is a L two, and we have our own Fuel VM and we don't use the EVM. So we have our own language, our own compiler, and our own stack.
00:00:54.190 - 00:01:56.594, Speaker A: And so if we talk about blockchains in a traditional sense, there is the execution layer, the settlement layer, the consensus layer, and the data availability layer. And so when we talk about monolithic blockchains, namely Ethereum, it does everything from top to bottom. And so we can replace the execution layer with Fuel. And so you would execute your transactions on Fuel and settle on Ethereum. And so what makes Fuel so fast is that we are again building our blockchain from the ground up and we are using a UTXO model instead of an account based model, which allows us to run transactions in parallel. And that's why we're the fastest modular execution layer. So with the next piece, I want to talk about the developer experience and why you should care about the developer experience.
00:01:56.594 - 00:03:08.140, Speaker A: And if we take a look at Ethereum, the typical onboarding flow is that you as a Web Two developer coming to Web Three, you might come across maybe some basic tutorials like Crypto Zombies or do a few solidity CFTs on Open Zeppelin. And now that you're a little more comfortable with Solidity, you want to develop full stack applications. But then there's so many frameworks to choose from, like Truffle, Hard, Hat Foundry, and then let's say you're pretty comfortable with Solidity now, but you notice all the shortcomings that happen with Solidity. So you move on to Viper, maybe. And then when you do have your fully built out application, you would go through static analyzers, like slither a bunch of different audit companies to choose from and spend a bunch of money on audits. So the point I'm trying to make is that the development experience is a bit fragmented in the Ethereum world and sometimes it can just be simply overwhelming. So let's compare it to the Fuel stack from top to bottom.
00:03:08.140 - 00:03:55.640, Speaker A: Everything is made in house. So starting from our language, that targets the Fuel VM, our Swaylang and the surrounding SDKs, the TypeScript SDK as well as Rust SDK, and last but not least, the indexer. So, you know, everything works from top to bottom. And so I wanted to showcase some of the Sway code. So if you want to pause the video right now and try to identify what is wrong with this contract written in Sway, feel free to do so. But the bug is reentrancy. And reentrancy has been around since 2016, since the Dow hack and it's still prevalent today.
00:03:55.640 - 00:05:06.618, Speaker A: And over the years it's cost our ecosystem hundreds of millions of dollars and we're just setting that money on fire. So we can talk about the Sway compiler again, built from the ground up, the Sway compiler can detect re entrancy bugs at compile time. And this really helps with the developer experience because now you have web Two developers who are really excited about the Web Three world. They don't have to know about all these little nuances of solidity, all these nuances of different types of bugs that can be prevalent. To be honest, some audit companies might not even pick up on and so the barrier to blockchain development just got lowered. So there are going to be less hacks in the future, less friction and faster development overall. So right now you might be curious about Fuel, maybe you're not, but I want to showcase one more unique feature that Fuel offers and that's predicates.
00:05:06.618 - 00:05:55.760, Speaker A: So there are four programming types in Sway. There are your traditional smart contracts that you're probably familiar with, there's libraries, scripts, and the last thing is predicates. So what are predicates? Predicates are just simple programs that are stateless and they can return true or false. And just to reiterate, they are just a piece of code. If you hash that piece of code, you get an address and you can send tokens to that address. And the rules of the predicate, again, if they evaluate to true or false, you can unlock those tokens. So predicates cannot be created or deployed because they're just a hash of a piece of code into an address.
00:05:55.760 - 00:07:15.890, Speaker A: And some of the properties are they can't read or access any data on chain, they can't read data from smart contracts, they can't check the date or time, they can't read the block, hash or number. But what they can access is the transaction data, which is some of them include the input parameters, input coins, output coins, transaction scripts and bytecode of the actual transactions. And you might be still asking yourself why is this useful? And one of the main problems of Ethereum is that there's a lot of state bloat and with predicates and account abstraction we can prevent a lot of state bloat that happens on chain. Some of the limitations of predicates is that you cannot update a predicate because it's just hash of a piece of code. So anytime you rewrite the rules you would need to remove the assets that you've put into a particular address, into the new address. So just to highlight some of the features of predicates, I'm going to do a short demo on how to create a predicate based multisig. So in this part of the tutorial we'll be building a multisig predicate.
00:07:15.890 - 00:08:20.082, Speaker A: And for those of you who don't know what a multisig is, it's essentially just a digital signature scheme that requires M of N signatures to authorize a transaction. So if you have two out of three signatures in the multisig approving A that signs a transaction, then you can unlock the utexos that are locked behind the predicate. And so this is what we're building. So like before we're going to do fork new multisig predicate demo and then this generates a Sway project for us. So we'll just go into the multisig predicate demo and then open it up in Vs code. So we can go ahead and remove the preloaded contract from before because we're going to be building a predicate program, not a contract program. And inside this we'll be needing several things from the library.
00:08:20.082 - 00:09:43.470, Speaker A: Standard library, sorry. So use the standard library and we'll be grabbing the transaction witness data, the transaction witness count, and the transaction ID. And here we can use the B 512 type as well as the elliptical curve recovery function. And I'll be explaining shortly why we need these things as we're building out our predicate. Okay, now we can define our configurable and what a configurable is in Sway is just a fancy constant that can't change during an execution but can be adjusted after building through the TypeScript or rust SDK. So this is similar to Immutable variables in solidity. So here we can define all three of the addresses that we'll be using for this multisig.
00:09:43.470 - 00:11:02.270, Speaker A: And then let me just grab some of the private keys I'll be using. And within this multisig we need M of N signatures. So N being three, we've defined three signature or three public keys in this multisig. And we probably require two out of the three to sign in order to unlock some of these tokens that are inside this predicate. Okay? And then just to reiterate, the predicate only evaluates to true or false. So if two out of the three signatures are verified, then it can unlock the UTXOs inside this predicate. So our main function would just return our true or false and then we can define the key addresses here.
00:11:02.270 - 00:12:47.910, Speaker A: Okay? And the next step is to define some of these mutable variables. So one of the edge cases is that we don't want, let's say two of the input, like one of the public keys signs the transaction twice. So we want to make sure that the input witness data in the transaction is unique. So we'll be keeping track of that. And we'll also be keeping track of all the valid signatures that are coming in as well as the transaction signature count. And the last thing that we need is actually the message hash that is the transaction ID. Okay, so we're going to loop through the transaction count and once we've hit zero, then we can exit and check all the transactions, check all of the signatures to make sure that there's enough valid signatures, unique valid signatures.
00:12:47.910 - 00:15:37.880, Speaker A: Okay, here we are taking in the first signature and we're going to do let the current address matcher. So we're making sure that the sign message matches with one of these private keys here. Okay? And now if the current address signature and here we're doing the actual check, then we would increase the count by one as well as the number of valid signatures. And that's it. So all we have to do now is to check if the signatures are unique, as well as ensuring of course that M of N signatures are present to unlock these UTXOs hit the valid. So if all of this is good, then we would return true. If it's not, we simply just return false.
00:15:37.880 - 00:16:51.468, Speaker A: And for those of you who have been following along, if you guys are having any issues with compiling the predicate here, please refer to the GitHub in the QR code to continue to the next step. Okay, now that we've written our predicate, we can simply just do the exact same as we did with any other contract or program type. We generally just run fork build and it returns us a predicate route, which is just a hash of this code that we have written. And we would send our UTXOs to be locked behind this multi SIG to this address. I want to highlight some of the other applications that are possible with predicates and are currently being built on. Fuel right now is order books. So predicates, let's say this particular type of predicate is an over the counter order of a token.
00:16:51.468 - 00:18:22.120, Speaker A: So let's say you deposit token B inside this predicate and if someone comes along and sends you X amount of token A, then you would return true and unlock token B to whoever the buyer was. So you have your USDC, you put it into the predicate address and then someone comes along, they send in token A and then unlocks the USDC. So you can imagine a bunch of these orders for your token A. And on the other side you have a bunch of the orders for token B. And you can imagine that everything is stateless because again, predicates due to their nature, they're stateless you can do all the matching of all of these orders off chain, which can save a ton of resources. So the main takeaway from this presentation is that there are these cool new features that Fuel is offering and I would love for everyone to kind of explore and play around with Fuel and just to expand on what people traditionally know about blockchain development. And so if you want to come talk to us, we'll be floating around in East New York.
00:18:22.120 - 00:18:34.700, Speaker A: And this is a QR code that you can scan to visit our docs and hopefully I'll see more of you in our ecosystem and building on Fuel in general. Thank you everyone. Bye.
