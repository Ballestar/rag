00:00:00.250 - 00:00:16.160, Speaker A: Thank you so much for joining. Via YouTube or on the zoom call, we have Zach Furland from Ceramic three box, who's going to give a presentation on managing identity with ceramic. And with that, I'll let him take it away.
00:00:17.170 - 00:00:18.014, Speaker B: Great.
00:00:18.212 - 00:00:19.230, Speaker C: Thanks, Heather.
00:00:20.210 - 00:00:20.862, Speaker B: So. Yeah.
00:00:20.916 - 00:00:36.600, Speaker C: I'm Zach from Ceramic. You may also notice as a team that built three box before, but today we'll be talking about ceramic. Yeah, we've been to a few of the e global events before. We're excited to be building with everyone again here.
00:00:37.690 - 00:00:38.054, Speaker B: Yeah.
00:00:38.092 - 00:01:09.730, Speaker C: So today I'll do kind of an intro to what ceramic is. And the main thing we're building on top of that is something called IDX right now. And then the last two thirds, I'll basically do a bit of a workshop step through some code. It's going to go pretty deep at the lower level since we're still building a lot of this stuff right now. And we want to build with everyone and kind of we're still building a lot of lower layers, so it should give you good insight into what's there. And that should take up about 45 minutes. And we'll leave the last bit for questions.
00:01:09.730 - 00:02:01.970, Speaker C: And definitely during the workshop section, feel free to ask questions at any point. Yeah, I'll start with intro through a few slides, tell you what ceramic is and IDX. All right, so like I said, today we'll focus on the part of IDX, and that's an easy way to manage decentralized identities. No servers, no silos. The big value idea is that with these decentralized Identifiers, you don't need to run any back ends, you don't need a third party to say who you are. You have access to this global local network that you can resolve this data, resolve these lookups, and someone can always prove that and everything's public and verifiable as well as that, you often don't have to run even other data layers because you can basically hook into these other layers. So you can hook into IPFS filecoin other decentralized DBS.
00:02:01.970 - 00:02:44.334, Speaker C: All you have to consume is a simple library. And then you get access to most of this. A big thing here is now when you have this user centric model, users control their data, control who has access to it, and when the data resides with the user, you can let them share data with your app. So no longer do you have to go ask permission somewhere else to get data, you ask the user. And if they want to share data that they have in one app share data, they have another place they can now do that. So now you can look up data across applications, across places, across different even like decentralized protocols. And like I said, users now they're the ones that are in control there.
00:02:44.334 - 00:03:14.266, Speaker C: They can access control that. They can decide how they want to let you use it, what you can read, what they will assign for. So a core part of this is DIDs. These are decentralized identifiers. This is an open standard. As I said, it's a way for no one says who you are, you can prove it yourself. And people can implement different did protocols that allow you to then take this Identifier with you and link a bunch of things to it.
00:03:14.266 - 00:04:12.190, Speaker C: So for example, we had used these already in three box and you could link like a Twitter account, you could link Ethereum accounts and eventually you can link across different chains. Really allows you to way to tile this data to it in a publicly verifiable way. As I said, on ceramic itself, you can actually store data. So we'll go through what it actually looks like, kind of what that underlying structure looks like, but it is built on IPFS, and in these data structures you can store data in itself, so you can have JSON documents, any other kind of structured data. In that way you can basically link it to these decentralized Identifiers. Then there's ways to look them up, way for people to index them and all up to the user and what they want to link or not. Even more interesting after is you don't have to necessarily just link to another object in IPFS for example, or link to another document in ceramic.
00:04:12.190 - 00:05:11.274, Speaker C: You could actually link to any other kind of system, whether there's other PDP databases, it could be something like orbitdb textile threads, anything like that. And along with this data now that you could just say like here's the data here. And you can also add stuff in that document in ceramic that basically says it meets this schema, this is how you interact with it, this is how you kind of control it or look it up. All this metadata can exist in ceramic tied to your Identifier. So when you bring your data somewhere, another app knows how to resolve it, knows what dependencies they might need to use to get it, they know what form it's supposed to be in and what it's supposed to look like. Yeah, I was already saying these things don't exist in a silo, they don't exist alone. When you crane them, you're actually linking these to basically an index.
00:05:11.274 - 00:05:25.746, Speaker C: You think of it? Just like you're. This key value mapping that's linked to your did has links to a bunch of these documents that say, I have some of this data that meets this schema here. I have some data in this other place that looks like this. And this allows ways for people to discover this data, look it up, and.
00:05:25.768 - 00:05:29.480, Speaker B: Like said, consume it. Let's see.
00:05:31.050 - 00:06:15.922, Speaker C: And yes, the nice effect of that once you start building these graphs and all these linked data is every user gets to bring this kind of social user data graph with them wherever they're going. And you can actually allow access control on certain parts of the graphs. You can write queries against it. All on top of this underlying graph structure. So that's a lot of what the value looks like for IDX, which is the identity index. I'll kind of go into more details there after this is built on top of this thing I was talking about called Ceramic. So Ceramic is this global general purpose, basically document based storage that kind of the interface to the user.
00:06:15.922 - 00:07:00.946, Speaker C: It just looks like JSON data, but allows you to securely publish, link, query, and publish as Verifiable information, saying when consuming these documents, can verify them. The underlying structure is on IPLD. So you actually have this immutable data structure underneath the document that looks like this log of basically a log of updates. But since the user is signing every update, you have a way to also update these documents, change them and still verify them. All these things, like I said, are signed by Dads, so anyone can resolve those, look them up, verify them. There's some rules for how you can update them that implement the system, and you can define different rules as well.
00:07:00.968 - 00:07:02.690, Speaker B: For these state transitions.
00:07:03.430 - 00:07:12.230, Speaker C: You can think of it as you basically just get this JSON data in a doc. You can edit it, verify it, but when you resolve it, the underlying stuff is verified.
00:07:14.250 - 00:07:15.560, Speaker B: So go here.
00:07:16.490 - 00:07:38.762, Speaker C: Yeah, I kind of covered a little bit of this. I said everything is a Verifiable doc in the end, just looks like this Verifiable JSON object. Even though the underlying part has a submutable data structure that you can resolve. Everything is linked, anchored, verified. These all form a graph. I said an IPLD. These documents and their updates are anchored in a blockchain.
00:07:38.762 - 00:08:18.262, Speaker C: Right now they're anchored in Ethereum, but you could anchor them in any chain. So basically, it's just saying like this update. When you're verifying it, you say, this update has been included at this point in time in some chain you sort of DIDs before. We built three ID, which is one implementation, but you could also use other DIDs in the system. So you might have these other identities that can sign document updates, create new documents. You could link DIDs to each other, for example. Um, so there's no global view in Ceramic.
00:08:18.262 - 00:08:50.680, Speaker C: These docs are just these chains of data, and people share updates when they see them. So you don't have to have a global view of the system. People can build local global networks, and all these networks can have even different properties. So you could have one that's, like I said, for example, just it's anchoring in Ethereum, while another one is anchoring in Bitcoin. You can have different storage layers. So one could use IPFS, one could use something else, like you could use Filecoin here, but a lot of these other layers are configurable. You don't need any global view.
00:08:50.680 - 00:09:08.682, Speaker C: But within that data, you usually have a way to say, I can resolve stuff in this network or this network. And you'll see kind of what that looks like after. So now this. Starts going a little deeper and I'll show this in the code as well.
00:09:08.736 - 00:09:09.340, Speaker B: After.
00:09:10.270 - 00:09:32.786, Speaker C: Like I said, the user interface for a ceramic document is just this key value object that you can store anything in. But underlying that it actually looks like this. So it says made up of a chain of records here that make a log that then the document is constructed from. So when you create a document, there's a certain doc type like I.
00:09:32.808 - 00:09:32.946, Speaker B: Said.
00:09:32.968 - 00:10:03.100, Speaker C: And the doc type defines the kind of rules that govern these state transitions. So, like, right now, we have a thing called a tile. And the basic update mechanism there is that this record must be signed by the Owner. So In The Genesis Record, you Create This JSON Object that Has Some Did As An Owner. It Says What Tile It Is. It Might Start With Some Initial Data, and Then That Doc Type Defines How You allow these updates. So anyone making those updates and verify that the state transitions happened, as you would expect for that record.
00:10:03.100 - 00:10:37.542, Speaker C: So for this record, you would want to say that it was signed by the DD. That it. Was anchored after each update that this data met a certain standard, a certain change. You could actually have different kind of doc types eventually that had different basically state transition rules or other update mechanisms. So you could say like, the owner of it is actually like a nifty on Chain. And then if you want to verify that someone owns it at that point in time, you would maybe do that look up on Chain. And that's how you'd verify these transitions, but you could build lots of other mechanisms as well.
00:10:37.542 - 00:11:11.650, Speaker C: And then it's up to each client consuming that to verify that according to that so the underlying log, I said, has this so every time. You make an update you press Create Genesis record. You sign those updates. Each update then has anchor record so the anchor record would point to your last signature record which is your last update and you continue to build. This chain. So as I do, each update, you'd end up with this whole list of records. And then each anchor record has a structure of a proof on some blockchain.
00:11:11.650 - 00:11:44.314, Speaker C: So you can always verify these proofs. Most of. These are merkel proofs or the actual just hash or CID of this record could be published on chain, allowing someone to verify and look this whole thing up. So this is like the actual data model. Another part of ceramic is that you need a way to always gossip about the most recent update. So if I want to get the whole data for this document, I want to be able to resolve this entire log, not just the genesis record. A ceramic document is identified by a Genesis Record.
00:11:44.314 - 00:12:38.270, Speaker C: But then you need a way to ask for the most recent update. So for this one, I want to be able to get this most recent anchor record. So users Lip BDP and most of the Nip Fest and all these peers will connect and you'll want to share and gossip about whatever ceramic documents you care about. So if someone else had this record and I just came online, I'd be like, I'm looking for this document with this Genesis record CID some other peer would be like, I heard about this record, I heard about this one, and I want to find the latest. And for the most part, you don't have any sentence to withhold this. Then once I get that able to resolve this whole thing and get a document so that's the two parts. Now I'll kind of step through what this actually practically looks like in code and so try to make it a little more concrete.
00:12:38.270 - 00:12:45.940, Speaker C: So I set up a simple demo that already had some things loaded. So our core libraries are loaded here?
00:12:47.350 - 00:12:47.714, Speaker B: Yeah.
00:12:47.752 - 00:12:52.146, Speaker C: During this part, feel free to ask any questions. I said there'll be some time at.
00:12:52.168 - 00:12:53.300, Speaker B: The end as well.
00:13:01.690 - 00:13:03.480, Speaker A: It seems like we're all good.
00:13:05.530 - 00:13:08.758, Speaker B: Oh, there we go. I just had the YouTube video playing.
00:13:08.774 - 00:13:14.300, Speaker C: In the background of myself. Okay, let me open.
00:13:15.310 - 00:13:17.766, Speaker B: Okay, here we go. Yep.
00:13:17.798 - 00:13:43.490, Speaker C: So I said, I have this demo open here and the library is already loaded. So the core library when you're interacting with ceramic is going to be ceramic JS. And that's right here, this is how you're going to create documents, verify them, look at them. So I have this library. I already have this object on the window right here. It could just be some JSON. I want to put this content somewhere.
00:13:43.490 - 00:13:51.270, Speaker C: So now I'll use ceramic to create a document.
00:13:56.410 - 00:13:56.898, Speaker B: Excel.
00:13:56.914 - 00:14:04.058, Speaker C: I'll create a tile. So it's going to follow those rules for state transitions and updates, and that's how people will verify them.
00:14:04.144 - 00:14:06.842, Speaker B: Object One zach, we got a question.
00:14:06.896 - 00:14:16.800, Speaker A: In the Zoom chat here from Matthew asking are we creating pair wise did for each connection or just a single did? I get it.
00:14:19.170 - 00:14:39.270, Speaker C: Yeah, I'll cover that a little bit after. Yeah, there's one did right now, but we do want ways to delegate the other DIDs. And ideally, you would create pairs as you interact in different places and you would either link and do some object capabilities or something there rather than using the same did across all instances.
00:14:39.610 - 00:14:47.800, Speaker A: Nice. One quick question. Is ceramic JS available on React native through Shimming or something?
00:14:49.050 - 00:15:34.520, Speaker C: It's probably hard. So a lot of people trying the big blocker was it's hard to get IPFS to run there, but I know that some people are working on it for the most part, ceramic right now, ceramic JS will just consume like a IPFS HTP client or even a ceramic Http client. So ceramic JS itself should be easy to run in that context, but you would be running like a ceramic node or an IPFS node somewhere else. So for the documents, so I created this document here with this object. You can see now I got back a doc. So this is the main interface for a document. Like I said, it has a doc content.
00:15:34.520 - 00:16:02.506, Speaker C: So while the underlying thing has all this IPLD graph, these updates, this is verifying it. This is just building the ultimate object, the most recent state that it knows. So you have that doc, you can see that it has an ID. So ceramic IDs look like this. Right now these might change a bit. Right now they're just CIDs but they probably will specify the network, what docs they are and that other kind of stuff as part of the ID.
00:16:02.548 - 00:16:03.140, Speaker B: After.
00:16:04.950 - 00:16:18.854, Speaker C: They have said the Doc ID is of the genesis record. But as you add updates, there's going to be most recent latest pointers in that graph. So that's the head, let's see. So that's the CID object, I'll turn.
00:16:18.892 - 00:16:27.206, Speaker B: It to a string. Wait Doc, you can see here, this.
00:16:27.228 - 00:16:31.130, Speaker C: Is the point to Niplv node. That's the latest update of that document.
00:16:32.590 - 00:16:33.660, Speaker B: That's that.
00:16:34.350 - 00:16:41.230, Speaker C: Now I'll use ceramic to update this document. So I just have the second object here. I'm going to write to it.
00:16:41.300 - 00:16:51.360, Speaker B: So I'll doc, let's say, wait doc change. I'll do the second object.
00:16:54.690 - 00:17:15.526, Speaker C: All right, so that updated now. So I said in the background that would have add a new record, signed it and anchored it as well. So we should be able to see now that the content has updated. Yes, so we got new content here. I just wrote that update. You can see of course, it still has the same genesis record.
00:17:15.628 - 00:17:17.320, Speaker B: So the ID is still the same.
00:17:17.850 - 00:17:55.140, Speaker C: But now you'll see that the latest update is different than it was before. So now it's pointing to another node here. So I said if someone else created this document and I wanted to resolve it, I basically would have come onto the Pub sub network and said, hey, I'm looking for this ceramic ID. Someone else would have gossiped about oh hey, this is the most recent IPLD node in this graph that allows you to resolve that whole log. So I would have got this and been able to load that document. And that's what this library is doing in the background. Of course it's all local here, so it's kind of just pulling that locally from IPVs and resolving that.
00:17:55.140 - 00:18:17.098, Speaker C: Now that we have these things, I can actually step through what this looks like underneath. So I could do so I have IPFS on this window as well right now, just loaded in a browser. Like I said, this is a CID. So we can actually resolve this in IPLD right now and actually take a.
00:18:17.104 - 00:18:19.100, Speaker B: Closer look at it to see what it looks like.
00:18:19.890 - 00:18:22.720, Speaker C: So do IPFS dag get.
00:18:24.450 - 00:18:27.840, Speaker B: And I want to take the Doc ID wait in the doc head.
00:18:30.370 - 00:18:47.942, Speaker C: So this resolved this IPLD node. We would expect to get anchor record here in ceramic. So yeah, that's exactly what we get is this anchor record. This has two pieces. Like I said, they're always pointing to the previous entry in the log. So it's pointing to another node. And then there's proof right here.
00:18:47.942 - 00:19:22.880, Speaker C: We'll step through that after, but we can actually keep walking through this. So see, previous is a link, just another CID object. There's a few cool things here. So you would recognize these codecs in IPFS, just defines how you might resolve or read that data, what structure it looks like. We're working on, along with some other teams on something called Dag Jose, which is going to be a new codec and IPFS that allows you to actually have these signed, basically signed and encrypted IPLD nodes and links. So that's already using this right here. So you'll see how that's signed after.
00:19:22.880 - 00:20:00.620, Speaker C: So saying it's pointing to this IPLD node just like we resolved the other one. I can resolve it that way again. So now I'll do say pre. Okay, so I'm walking down this log. Now we get to a signature record and this is like what it looks like for Dag Jose is that we have these signatures. This is actually signed by my did. And we'll see that a little clearer after.
00:20:00.620 - 00:20:20.930, Speaker C: And then that just represents another link. So saying I signed this link with this key and it points this other node. So we can keep walking that we'll take the link. Now we just spectate to get the actual content or like the most recent update. And here we go.
00:20:21.000 - 00:20:22.082, Speaker B: So we have the data. Now.
00:20:22.136 - 00:20:49.366, Speaker C: You can see this is my most recent update. So when you write new data to it, it's not copying the entire object, it's using something called JSON patch. So all these operations get added. You're basically just writing the diff of the JSON object every time. And then when you're loading this document in ceramic, ceramic is actually taking all these and applying them together to get the final output. So you just see a single update here. Again, it keeps walking.
00:20:49.366 - 00:20:58.350, Speaker C: So you see there's a previous. Again, we'll keep going one more step. Now we'd expect to get back to another anchor record again for the last update.
00:20:59.490 - 00:21:00.800, Speaker B: So we do this.
00:21:03.750 - 00:21:07.700, Speaker C: And here we are, another anchor record. This time I'll show what the proof looks like.
00:21:09.510 - 00:21:10.580, Speaker B: Open that.
00:21:14.310 - 00:21:37.530, Speaker C: Yes, the proof has a few parts, you just need the context to look it up on. So it shows here, it shows the chain. This is the chain ID for Ethereum mainnet. So it's in this block number and this is the root. So if you're going to verify this, you would just say like also we see here that we have this transaction codec. I don't have that codec loaded in IPFS right now. So I can't really resolve read that data.
00:21:37.530 - 00:22:22.218, Speaker C: Basically look for this transaction hash that exists in this block and includes this route. A lot of times you could delegate this to other anchor services. So Ceramic, when we first network first launches, we may run anchor service or someone else, but people can basically group all these transactions together. You can publish these anchor records yourself or you can have a service publish them and then in that case they would create a merkel tree and a merkel proof here, which would just include the merkel route in a path. Since I just published my own update here in Chain or there's a single update at the time from my anchor service, the root is actually just another link to my last update in my graph. So I can actually take that.
00:22:22.384 - 00:22:23.290, Speaker B: We'll see it again.
00:22:23.360 - 00:22:33.406, Speaker C: So we'll take the root. There it is, I think. One more.
00:22:33.508 - 00:22:39.598, Speaker B: Let's see. Yes.
00:22:39.684 - 00:23:01.270, Speaker C: And so now we finally walked the entire log and we got the Genesis record. So you can see, like, the initial data. We can see here that it has some metadata. And right now it just has the owners. And this is my did. So you expect all updates to be signed by this did? If not, it's not a valid update and it follows like transition rules or verification rules for a tile.
00:23:02.170 - 00:23:14.330, Speaker B: That's the root. If I go back a step to root. Let's see here.
00:23:14.400 - 00:23:27.246, Speaker C: So now we got the Genesis record. You can see this is the CID of it. And you'd expect this to be the same as the Document ID in ceramic. Oh wait, I resolved the wrong one.
00:23:27.348 - 00:23:30.640, Speaker B: Let's see. Root here we go.
00:23:42.470 - 00:24:19.838, Speaker C: So you see here, it's the same CID as what makes up the document ID. So now we walk the entire chain, kind of see what the underlying structure looks like. So I was doing all this, I said I had this did in this window. So one of the other core libraries here is something called Identity Wallet. And this library is kind of how you manage this library allows you to manage your keychain in ceramic. It allows you to manage these DIDs as well as add keys, add other links and do those kind of things. So I already have that load in the window and I have load the same one each time.
00:24:19.838 - 00:25:18.466, Speaker C: You can see that my Identifier is right here so this was the did that I used to update this document prior right there like I said, DIDs are basically just opaque Identifiers. Anyone allows you to link, the main thing you want to link to it at least is signing keys, that kind of stuff so this protocol allows you to take this and pick Identifier and then resolve the same keys that then you can use to verify when someone signs something. So of course with someone else's did I could resolve their did, get their public keys and then it allowed me to verify their signatures under the ceramic docs. When you're implementing these, like, say we implemented our own called three ID here, and we have resolver here for them. So I can actually show you, anyone can implement these resolvers as long as they meet the spec and they meet what a did document should look like. So I'll actually resolve my Didcument right here.
00:25:18.648 - 00:25:20.210, Speaker B: So heaven ceramic.
00:25:34.570 - 00:25:43.274, Speaker C: So it resolved my did. It resolves this didcument. And you can see here that yeah, I have some keys attached to it already.
00:25:43.472 - 00:25:44.460, Speaker B: There we go.
00:25:45.630 - 00:26:14.494, Speaker C: So that document I just created, if anyone else wanted to verify it, they would resolve my did. They would be able to resolve these keys here and then verify that I actually signed those record updates that's there. Like I said, anyone can implement them. One cool thing. So you'll see actually that if you look at our Identifier here, ours actually includes, you can see an IP fest CID. So if we look that up, you'll.
00:26:14.542 - 00:26:15.140, Speaker B: See.
00:26:17.530 - 00:26:19.078, Speaker C: So we'll get that again.
00:26:19.244 - 00:26:20.840, Speaker B: IDW, ID.
00:26:25.690 - 00:26:28.074, Speaker C: Oh, see, I can't resolve the did one.
00:26:28.112 - 00:26:37.340, Speaker B: We'll do, we'll just take it. Here.
00:26:43.170 - 00:26:50.190, Speaker C: We go. So you see that actually we implemented our did method on top of IPFS, so you can resolve the CID.
00:26:50.530 - 00:26:51.758, Speaker B: And there you go.
00:26:51.924 - 00:27:29.962, Speaker C: So it has some of the stuff in here. So even more interesting is you'll see that this is just not any IPFS object. This is actually also a ceramic document. So the cool thing here is now you have a way to actually update the data that's linked the keys, do key rotations, all those kind of things, on top of these documents, you don't have some static update here. So you can see like given this ceramic document, I can then map that to meet what's defined as a did doc. So that's mapped from here to here. You can see that this already didn't have all the updates that I have.
00:27:29.962 - 00:27:38.960, Speaker C: So there's already some updates in here. Yeah, you could see that I could actually open this in ceramic instead, and that might be more interesting.
00:27:39.570 - 00:27:42.590, Speaker B: I could do doc. Let's create a new doc.
00:27:43.810 - 00:27:53.646, Speaker C: So my did is actually implemented as a document in ceramic. Wait, ceramic?
00:27:53.838 - 00:28:10.746, Speaker B: Actually, yes. I'll just load the doc. Wait, let's and then we'll do I.
00:28:10.768 - 00:28:14.970, Speaker C: Already have it here. So it's just saying esramic the CID.
00:28:16.270 - 00:28:21.674, Speaker B: We'll do that. There we go.
00:28:21.712 - 00:28:49.638, Speaker C: So now we got what represents the underlying document for my did. And now you can see it has all the updates here and this is what you can use to map the document there. That's most of that. Like I said, those did now are signing all these updates and then we can resolve this and verify them. And now I can add these kind of links and stuff. So there's another interesting thing here. So I was talking about IDX before.
00:28:49.638 - 00:29:33.090, Speaker C: IDX is one of the first kind of standard documents on top of ceramic. You can see I have this thing in my did that's just linking to another ceramic document. And these are basically indexes of key values that allow you to attach all this kind of data in some way to your did. And I have the IDX library already here. So most of the time you'd actually be using IDX probably unless you're implementing new doc types or any lower level stuff. But for any identity stuff in your app, you'd be using IDX. So IDX is this identity index.
00:29:33.090 - 00:30:15.280, Speaker C: And basically what it does, it has key values and it basically maps from these things we call definitions, and then they map to a reference. So a lot of them look like basically a definition is a way to say kind of describe the data that you're pointing to. So whatever the reference is, the reference could be another ceramic document, it could be my profile, for example. And then the definition would basically say, oh, here's this profile, it meets this standard. This app might have created it, or it might have also the metadata on how to resolve that data if it was in another protocol besides IPFS, or besides if it was in Orbitdb or Textile or any place like that.
00:30:17.110 - 00:30:17.426, Speaker B: I.
00:30:17.448 - 00:30:26.662, Speaker C: Can show you what they look like. So as I said, these documents can have schemas attached to them. So if I want to make a profile, already loaded some schemas in here.
00:30:26.716 - 00:30:30.760, Speaker B: For IDX, so I'll just play those.
00:30:32.490 - 00:30:41.770, Speaker C: Now, the cool thing is you can see that schemas themselves are also ceramic docs. So you have these schema definitions and you can have them also have updates as well, and you can reference versions.
00:30:42.190 - 00:30:43.980, Speaker B: As people are creating these.
00:30:44.510 - 00:30:51.070, Speaker C: So we can actually take a look what the schema looks like, we can again just open it as a document.
00:30:51.490 - 00:31:04.050, Speaker B: So I'll create another doc, I'll just load the doc and I'll do let's do the basic profile.
00:31:15.110 - 00:31:47.680, Speaker C: As a document again. And now you can see what these schemas look like. So a lot of these right now are just JSON schemas. They say what keys you'd expect to find, what values they should have and how they should meet that. Then the schemas, like I said, can be basically referenced when you're creating other ceramic docs. So you could expect a ceramic document, for example, to meet a basic profile schema. So if a document had this schema, someone loading it would expect to be able to load it in this way or possibly find these values and know how to format them, show them, display them.
00:31:48.690 - 00:31:49.694, Speaker B: That's what it looks like.
00:31:49.732 - 00:32:22.918, Speaker C: There's a few other ones already, standard ones. We expect people to define lots of other ones, we'll have some standards, and ideally people contribute other ones for other contexts. Ideally you want to eventually have some consensus about what certain schemas look like for a certain context. So other apps can always load. These different things. Like I said, these don't have to be attached to ceramic documents. You could even have for example, a definition that says here's this data in this API, but it still points to a ceramic schema.
00:32:22.918 - 00:32:37.838, Speaker C: For example. So you say I expect to resolve the data at this endpoint in this way and this is how you get it. So those are the schemas. And then IDX, I will now create a definition so you can see exactly.
00:32:37.924 - 00:32:48.080, Speaker B: What this looks like. So I'll do IDX definition, let's say.
00:32:58.090 - 00:33:22.186, Speaker C: Okay, so I have this here. So in IDX I'm going to create a new definition. Like I said, this is a really simple one. This is actually just saying this is going to point to another it's going to point to another ceramic doc in this definition. Like so I could have pointed to any other service or any other API. All I'm saying is it has some name for it. So I create a definition once I've had a profile and I would just for example, I want a namespace here.
00:33:22.186 - 00:33:38.930, Speaker C: So I have an app that has a separate profile than my global profile. But I want to add this to my Debbie index like this. So someone looking for my profile on a particular site would basically look for this definition with this ID here. Then I'm saying I want the data to follow the basic profile.
00:33:40.390 - 00:33:44.340, Speaker B: So I'm going to create that. Here we go.
00:33:46.150 - 00:34:05.500, Speaker C: So that definition create a ceramic doc itself. So this definition is now another document in ceramic that can get added to my identity index. Now that I have a definition, I can write stuff through IDX to these different objects. So I can do, let's say.
00:34:08.830 - 00:34:09.242, Speaker B: Set.
00:34:09.296 - 00:34:36.740, Speaker C: So I'm going to say, yes, I have this here. I'm going to say I'm going to set for this definition ID in my identity index. I'm going to set the content for it. So I'm setting it to a basic profile reset. Now this itself like that. Since this data is stored in the ceramic itself right now this is actually creating another ceramic doc as the reference. If I loaded that, you would see this content in it.
00:34:36.740 - 00:35:06.160, Speaker C: But we have an easier interface in IDX to just look this stuff up and set and get that stuff. So now I should be able to get that data. Same thing again. I'm going to say I want to get it from this definition. There we go. So we're able to resolve that content. For me, what's more interesting is you can actually say like this.
00:35:06.160 - 00:35:30.038, Speaker C: So you basically say here is like you could pass a did. So you could say I want to get this particular definition for this did. I don't have someone else's right here, but if someone else here had a profile, I knew their did. I basically say I want this definition ID. So it's like saying I want the profile for this app and this did. And then I would ask IDX to resolve it.
00:35:30.124 - 00:35:31.400, Speaker B: That's what it does here.
00:35:32.090 - 00:35:59.040, Speaker C: The actual flow looks like actually last part. So we can see all this stuff as we created these should have got added to our actual identity index, which if you remember is a ceramic document itself. So we had that up here before. That was right here. So you can see in my dad I had this IDX document. Now we should expect to find those entries in there. So I'm going to load that as a document again.
00:35:59.410 - 00:36:17.590, Speaker B: So let's load another doc, one content IDX.
00:36:18.970 - 00:36:56.574, Speaker C: So just loading that doc three. Now we'll look at the content of that doc. All right, so for my did, this is my identity index. So you can see here, this is the entry we added. So I basically added this thing that said this definition points to this reference. This is the definition I created that says this is a basic profile here's for my app, has other metadata and in this case points to another ceramic document, which is this profile document right here. So I said if I want to look up someone else's profile, I'll be able to resolve their did, get their identity index, ceramic doc, then load be able to resolve keys and values inside that.
00:36:56.574 - 00:37:32.590, Speaker C: So I could resolve this here, then look that up. I said I could point to a textile thread as well. Now you could load that and you could define stuff like access control or like encryption keys or that kind of stuff inside this definition as well. So it's kind of a space for these DIDs to coordinate over this kind of data, whether you're sharing with apps or other people or anything like that. Yeah, so that's most of the demo. Those are the main libraries we have right now. Like I said, a big thing is also you can see here that this has some auth keychain data.
00:37:32.590 - 00:38:23.210, Speaker C: So one particular thing we're doing now already is that we have a hosted basically version of Identity Wallet. So if you're using this in a browser in any way and you want users an easy way to permission stuff, sign stuff, we have someone called three ID connect here. So this operates like Identity Wallet in an iframe and this allows you to get the same interface that I had here. And someone has like a shared persistent Identifier across applications. One of the cool things you can add in IDX is basically links to other accounts, so you can have links to Ethereum accounts. So one of the things we do already is like if you authenticate with Ethereum account, that adds that as auth method. So it's adding it to my auth keychain here and it makes a publicly verifiable link as a document inside my ceramic IDX.
00:38:23.210 - 00:39:07.878, Speaker C: So if someone wanted to say, I know someone with this Ethereum address, they could then resolve my did then resolve all the other links to it. So if I had a profile, it'd basically be like this ethereum address. I can resolve this profile or I can resolve what my Twitter profile is. You can link all that kind of stuff to it. So we're really interested to see what kind of stuff people can build as basically new definitions, schemas what other kind of data we can add and link here, as well as make sure we can interact with other protocols and resolve data in all these different places. So that's it for the demo. I said eventually there'll be other things built on top of ceramic besides IDX.
00:39:07.878 - 00:40:14.110, Speaker C: But this is really a core part we're focusing on. Yes, to recap, the big thing now is we have this base layer and these basic definitions and ways to link data, resolve data, but right now it's mostly in Ethereum and just in these actual ceramic documents itself. But we want help and people building on stuff to make sure we actually can resolve stuff in different blockchains, different data stores have integrations with one of the definitions in your IDX should say, like, my data is persisted in filecoin and it's stored in this DB. And you should be able to link accounts across different chains and stuff so you can have your Ethereum account linked with any other blockchain account. So we wanted to work on that and I said IDX is the first use case we're focusing on and especially know input and people building different definitions and references in these integrations. Like I said, we have this all our stuff is in JavaScript. You can find most of our libraries are in this monitor repo here, JS ceramic.
00:40:14.110 - 00:40:44.326, Speaker C: There's some CLI tools and some other tooling interact with it. Like I said, everything also operates against HTP, APIs and gateways. So you can run it in most contexts. Yeah, for ETH online we have the three bounties. So one, best overall project using IDX, two, best social common chat implementation using IDX. And then lastly, best tooling for IDX or ceramic that makes it all easier.
00:40:44.358 - 00:40:45.340, Speaker B: For us to use.
00:40:47.790 - 00:41:18.820, Speaker C: And lastly, so you can find some more info at fridayx on IDX XYZ. So that's here that has links to most of our docs and stuff. The other link is ceramic, ceramic network. And you can find us on Discord, our own Discord as well as sponsor ceramic. And we have office hours twice a week where you can just come and ask stuff about AuDX or ceramic. You can find us on Twitter. That's all from us.
00:41:18.820 - 00:41:22.998, Speaker C: And yeah, if you have any questions about anything that was shown here, I.
00:41:23.004 - 00:41:24.360, Speaker B: Think we can answer those.
00:41:25.450 - 00:41:48.000, Speaker A: Awesome. Thank you so much Zach, it's great. I don't see any questions from YouTube at the moment, but maybe Andrew, if you could allow guests to unmute themselves, they could jump in and ask questions of Zach here. Yeah, and Maul's got one. Let me see if I can do it.
00:41:49.330 - 00:41:51.418, Speaker D: Yes, I was able to unmute.
00:41:51.594 - 00:41:52.320, Speaker A: Great.
00:41:53.990 - 00:42:01.650, Speaker D: Joseph, I think, had a question before. Should I go ahead or should I wait for Joseph's question to be answered?
00:42:05.430 - 00:42:08.680, Speaker C: What was the question before? I think we have time for any of the questions.
00:42:09.210 - 00:42:25.770, Speaker D: Okay, my question was specifically, I was exploring three ID Connect, IDX and ceramic, and I was wondering when should I use each one of those, or are they interchangeable and then exact use cases for each of them specifically?
00:42:26.430 - 00:43:22.480, Speaker C: Yeah, it kind of depends what layer you're building at. So if you're an app that just mostly if you already want to just consume stuff that might be linked to the IDs or consumed from different data sources, then you probably just use in the future, most people just use IDX and there'd be a whole bunch of schemas and definitions and attach stuff to a profile. And you probably just set and get stuff from there and create whatever schemas and definitions you need. But since it is kind of early, there's not a lot of, for example, schemas and definitions defined. So we also expect, like a lot of people might be you can use IDX to create those as well. Like I said, there might be other cases where people are exploring what other doc types it looks like. So I guess it depends you're building and if you're building in Web, the best thing to use is three Ad Connect as a way as that keychain for your did.
00:43:22.480 - 00:43:34.900, Speaker C: You can use Identity Wallet for testing and stuff. Like identity wallet. Basically runs inside three ID connect. It's just this hosted way information flow for users for apps to access that.
00:43:36.470 - 00:43:45.838, Speaker D: Got it. I can use three ID Connect along with Idxr as well, right? Probably set some did provider.
00:43:46.014 - 00:44:10.060, Speaker C: Yeah, you should be able to easily do that. The interface is three ID connect. Basically gives you a did provider and then that's like an RPC layer. In this case, like a three ID connect that just makes calls over the Iframe window. Yeah, the interface is the did provider, and then you should be able to take the did provider to any of these libraries. So you can use it in the ceramic library or you can use it in IDX. Awesome.
00:44:10.370 - 00:44:11.120, Speaker B: Thanks.
00:44:16.450 - 00:44:19.454, Speaker A: Joseph. Did that answer your question or do you want to?
00:44:19.652 - 00:44:20.400, Speaker C: Sorry.
00:44:20.850 - 00:44:21.920, Speaker A: Okay, great.
00:44:23.030 - 00:44:24.020, Speaker C: Found it.
00:44:24.470 - 00:44:32.370, Speaker E: So, yeah, my question was, how does the performance compare to traditional document stores like Firestore?
00:44:34.470 - 00:45:07.840, Speaker C: Yeah, I would say it's not really comparable. I mean, the model and thinking, like, how you might get it. But of course it depends on the local configuration. So if it is a document that is not you don't know where it's necessarily stored or anything, then you basically would be looking at that document, asking for it through peers that you connect to through DHT, and then resolving that data through the IPFS. DHT and that's not necessarily always performing. And it has some context. Depending on what peers you can connect to.
00:45:08.370 - 00:45:14.690, Speaker E: You still have to incorporate, I guess, in that form, like a cold start kind of thing, like a cold read.
00:45:14.760 - 00:45:40.550, Speaker C: Or you have to dig deep down to find the document. Yes. It's quick to load. I mean, once you have a lot of documents locally. Okay. So a lot of people also going to run info where you're listening for a lot of the documents that you're interested in. Like you might run your own ceramic node and you basically say, I'm interested in these types of documents, and then you constantly listen for updates for those and you would be probably pinning those also in your ceramic node.
00:45:40.550 - 00:45:54.346, Speaker C: And most of the time then you might run that as a service that then your app uses and then you're resolving data pretty quickly through that and then pinning it locally. And you always have those updates available most of the time. Got you. Yeah.
00:45:54.368 - 00:45:57.742, Speaker E: So it kind of just depends on the distance of where we're caching it at.
00:45:57.876 - 00:46:16.262, Speaker C: Yeah. And for example, we're going to be running a ceramic node at first, so a lot of people will be just connecting to our ceramic node and we'll be pinning a lot of documents there first, so most people will be able to pretty quickly resolve those docs. And then once you do yeah. It gets pinned locally and you might continue to listen for updates at the same time. Okay.
00:46:16.396 - 00:46:23.158, Speaker E: Another question too, I had real fast is the IDX uses ceramic JS in the background, right?
00:46:23.324 - 00:46:24.040, Speaker C: Yes.
00:46:24.890 - 00:46:25.446, Speaker B: Okay.
00:46:25.548 - 00:46:41.040, Speaker E: So the whole point of asking these questions is because I'm on a mobile app, React Native, and I'm trying to find a way to incorporate some kind of identity service and switch away from my traditional Firestore document store.
00:46:44.610 - 00:46:45.134, Speaker C: I guess.
00:46:45.172 - 00:46:52.526, Speaker E: My question is, is there active development? Because I couldn't actually hear earlier because.
00:46:52.548 - 00:46:53.566, Speaker C: My connection was messing up.
00:46:53.588 - 00:46:59.620, Speaker E: But is there active development or active eyes looking at a React native port or shimming process?
00:47:00.390 - 00:47:29.210, Speaker C: Yes, what we have now. So I said it should work in the context that you run the ceramic node as like an HTP client. So you don't actually have to run the whole full IP fest node, ceramic node inside that client or browser or wherever context you're running it. They all have these HTP APIs. So like a ceramic instance can spin up its own instance locally of IPFS and everything else, or a ceramic instance can basically just be a wrapper around this HTP API.
00:47:30.750 - 00:47:32.794, Speaker E: I'm guessing the ceramic JS, it's really.
00:47:32.832 - 00:47:34.398, Speaker C: Simple to point it somewhere else.
00:47:34.564 - 00:47:34.894, Speaker B: Yeah.
00:47:34.932 - 00:47:55.780, Speaker C: So what you do is you'd run a ceramic node, some routes, the ceramic instance in your client would just be pointing to that endpoint like HTP API, and then you would pass that ceramic instance to IDX. That makes sense. Okay, thank you. And eventually we all want IPFS to run in mobile everywhere? Eventually, yes.
00:47:57.110 - 00:48:08.860, Speaker A: Zach? I've got a question from Stefan on YouTube who says, last time I tried creating Docs, I never received anchor documents. Is your default anchor device 7007 operational for everyone?
00:48:11.070 - 00:48:26.366, Speaker C: Yeah, I don't know what configuration you might have had. We do have a dev anchor service that we use right now, so we should be able to have you connected. I don't know what point you're referencing now, but you could follow up with us. But you can run it locally pretty.
00:48:26.388 - 00:48:27.950, Speaker B: Easily as well for testing.
00:48:28.370 - 00:48:33.570, Speaker A: Great. I'll direct Stefan to you guys on the Discord.
00:48:34.230 - 00:48:34.980, Speaker B: Great.
00:48:38.870 - 00:49:02.630, Speaker A: Cool. Maybe if there's any more questions, now is a good time. Otherwise, we could wrap it up and let Zach follow up with you guys. If you have questions on Discord awesome. Thank you so much, Zach. Super exciting stuff. I know people are really excited about using this, especially the IPFS folks.
00:49:02.970 - 00:49:04.706, Speaker B: Sorry. Yep.
00:49:04.818 - 00:49:08.360, Speaker C: Thanks, everyone. And, yeah, we're always on Discord, so find us there.
00:49:08.810 - 00:49:10.140, Speaker B: Cheers. Later.
