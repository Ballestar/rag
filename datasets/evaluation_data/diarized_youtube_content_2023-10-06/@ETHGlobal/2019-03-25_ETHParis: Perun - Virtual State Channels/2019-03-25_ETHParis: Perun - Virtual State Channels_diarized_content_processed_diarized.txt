00:00:01.210 - 00:00:27.926, Speaker A: Hello, can you hear me? Hi. Hello everybody. I'm Sebastian Stamler from Perun Networks. We are a research group within the Technical University of Darmstrad and we are researching state channels. So why state channels? This is a blockchain and blockchains do not scale very well. We have a fixed block size, we have a fixed average block time. And as we know, for example from the crypto critics example, couple blockchains do not scale very well.
00:00:27.926 - 00:00:56.990, Speaker A: And as we can also see here, we also have a high pending transaction count. In Bitcoin, we only get seven transactions per second. Ethereum 15, not very good. So a couple of solutions are increasing the block size, changing the parameters. Sharding is another solution and we are looking at off chain solutions here. So there's Plasma, there's ZK, Snarks and Starks also coming up for scaling solutions. And this talk will focus on state channels as a solution for scaling.
00:00:56.990 - 00:01:34.150, Speaker A: So for going off chain, we have the following goals. We want to have instant transaction processing so that parties can just have a two party protocol by which transaction is final. We don't want to have on chain transactions for each subtransaction. We only have a transaction for opening and closing the channels. We still want to have of course, the same security guarantees and it also develops increased privacy. I want to start with the easiest example, which is a payment channel. In a payment channel, both parties, they fund a contract, a payment channel on the blockchain.
00:01:34.150 - 00:02:07.618, Speaker A: Then their money is locked, they do all their off chain payments can be like as many payments as they like. And at the end of it they can pay out. And what the blockchain then sees is only the net balance of all the payments, right? Who knows payment channels or state channels in general? Who knows about the concept? That's good, quite a few people. So I can go through this very quick, I guess. So that's just a basic payment channel protocol. So Alice sends an opening request for payment channel. This is like a pseudo payment channel contract.
00:02:07.618 - 00:02:38.558, Speaker A: So she sends an opening request and also states how much she would like Bob to invest in the payment channel as she has sent the request. This request is already acknowledged. Now either Bob does not reply within the timeout and then she can just refund it. But let's now assume that Bob did reply within the timeout and then Bob funds it as well. And now they have that payment channel open. Now they would exchange messages. The messages contains the whole state.
00:02:38.558 - 00:03:14.506, Speaker A: So the state here would be the balance of Alan's, the balance of Bob and a version counter. The version counter is very important for disputes. And now Alice sends for example, the first payment of three ether to Bob by sending an updated state of two eight and her signature sigma A one. Bob confirms every message that he receives his signature and of course. Also, Bob could send messages to Alice, in which case he would send signatures and Alice would sign back the new state. Now, we look at a closing protocol where Bob is malicious. So Bob wants to send a closing request with an obsolete state.
00:03:14.506 - 00:03:28.062, Speaker A: So let's assume they had eight transactions in total. The latest balance was 64. The balance before that was one, nine. So this one is much better for Bob. He has six. Sorry, that one was better for Alice. She has six.
00:03:28.062 - 00:03:58.722, Speaker A: Bob only four. And here, this one's better for Bob because he has nine. And he submits version seven without Alice knowing initially. And when he sends that look, that at this point, the ledger only knows five ether. That was the initial balance, right? So now the ledger knows Alice has one ether, Bob nine. So that's the state that he submitted. And now Alice has a timeout that's very important for having always a timeout period in which the other party can react if the wrong state was submitted.
00:03:58.722 - 00:04:40.018, Speaker A: So now there's a timeout of 60 minutes in which Alice can react. Of course she does react. She sends a new estate. This smart contract can check that eight, in this case is higher than seven. So this state will actually be initiated and at that point, they can both withdraw their latest state. Now, we want to do this more general, which means we have like some game, for example, chess, and they want to play chess, and whoever wins the game wins the amount that was locked inside the chess contract. For that, instead of generalizing this idea again and again to payment channels, we develop a concept which is called a state channel contract.
00:04:40.018 - 00:05:06.894, Speaker A: And this contract does something similar to the payment contract that you saw before. So it also keeps track of the money that was inside of it. But now what you can do is you can, so to speak, deploy a game off chain and then play it and only at the end of it, you can then close the state channel contract. And you can actually have several games within the same state channel contract, also in parallel. Yeah. So those are the functionalities. You can create it.
00:05:06.894 - 00:05:38.866, Speaker A: You can add a contract. Once a contract within the state channel, note that there's no interaction with the blockchain. You can execute actions within the state channel and then you can also close it. So optimistically means no party misbehaves and adheres to the protocol. In this case, you can do this on chain. You have to do this on chain, obviously, because it's a state channel contract. But the playing and executing is happening off chain for adding a contract.
00:05:38.866 - 00:06:18.450, Speaker A: Let's say Alice and Bob have, in their state channel contract, have invested X, A and XB. That's like ten and ten. And now you have like a subcontract in which both want to invest one. So they want to play chess and the winner gets two. In order to do this, Alice she sets up the initial state of the game chess. She sends her signature and Bob's confirms with his signature. Now what happens is the game is instantiated within the state channel contract and from the so to speak, the wrapped state channel contract has like one fund less that is free floating so to speak and it is locked up in that contract.
00:06:18.450 - 00:07:01.438, Speaker A: Now they can play it and see. So this is like some pseudocode that shows how you could implement that. So you have a state channel contract with users alice and Bob. A user actually is an address and a balance, right? I mean you also have an ID of the state contract but it doesn't matter right now. And then only in a dispute case this one should actually also be read. So only in a dispute case would you submit a state like an instance of a game or of any contract to the state channel contract and then you could register it by which the inserted into the map and then you could execute new actions. That is like force playing on the contract because one party doesn't reply anymore.
00:07:01.438 - 00:07:50.818, Speaker A: So an instance of a contract is the code of the contract which in Ethereum could for example be just the address and you could even use counterfactual instantiation to use the new skinny create too. So you write a contract, you know, if you were to deploy the contract, you know the address of it, this would then be the code reference. The state is just like a serialized state of the app and you have a version counter and the version counter is very important. It has the same function as in the payment channel before. So the state itself, the contract states it always has to have like a user, a left and right user. The reason this is not Alice and Bob comes later because when we talk about stage channel networks we have so called virtual channels where we have two channels within the same contract and then you have a left and right user where user switches roles. But let's stick to this now.
00:07:50.818 - 00:08:44.910, Speaker A: And you also have the locked amount that was like the two Ether for example in the chess game. And then you have some app storage that's just app specific. And the state machine, I mean this is just one way of implementing it is you can have a state machine and a contract. The contract itself for example could not have any storage but you always submit for example the init function could be like the constructor. You submit some arguments and what you get back is a state that this constructor would cause. Then you can also execute the contract on that state, mention the action and the arguments to that action and the terminal would just be like a boolean telling you is the contract finished or not? And this is very important for State Channel closing because if you want to close a State Channel, all the contracts that are just currently being run in the State Channel should already been terminal. Yes.
00:08:44.910 - 00:09:29.022, Speaker A: So what happens now if there's a dispute in a State Channel? So let's assume a situation in which Alice and Bob played I moves of a chess game. She now found out how she can set Bob up to checkmate. She signs the new state I plus one, signs it, sends it to Bob, bob doesn't react. Now she can register the latest state I on the State Channel contract. Remember that was the registry function from before, because before that all the gaming was just happening within Alice and Bob. There was no interaction even with the State Channel contract. It was all just happening between Alice and Bob.
00:09:29.022 - 00:10:03.982, Speaker A: But now, because Bob deviates from the protocol, alice has to register the state on the State Channel contract. Bob, just like in the payment channel example, can try to submit an earlier state, for example, chess one. But of course the State Channel contract knows that I is higher than one, so he does not accept it. And I is the latest state. Now she can make like a force move. Yeah. So now she can do like a move on this contract, say, move the king to G two.
00:10:03.982 - 00:10:42.698, Speaker A: And that would set Bob checkmate. And that's the move playing on the ledger channel now. Now we come to networks. So for example, you have Alice has a State Channel with Ingrid using a State Channel contract on the blockchain. Now we also have Bob with Ingrid estate channel with another estate Channel contract. And now if Alice and Bob want to open a State Channel, what they could just do obviously is just deploy another State Channel contract on the blockchain, right? Just like Alice and Ingrid or Ingrid and Bob. But what is much nicer is to create a so called virtual channel.
00:10:42.698 - 00:11:39.190, Speaker A: And a virtual channel is like reapplying this idea of a State Channel contract recursively to run this contract in this and this channel. And they are like mirrored images of each other, but where the roles are swapped. So in an optimistic case, all this is happening off chain, right? Because now you're working in the State Channel already, which does not require any interaction with the blockchain. So this is all happening off chain in an optimistic case. So how does it work? If we want to create one, they first initiate two instances of a Virtual Channel contract. Virtual state channel contract. But of course, because it's like a mirror image of each other, ingrid would play the role of Bob in the left contract and Ingrid would play the role of Alice in the right contract.
00:11:39.190 - 00:12:30.406, Speaker A: Now they could deploy those contracts in their respective state channels and the virtual channels open and now they can use it for applying any contracts within of it. Now you can apply this concept recursively. So now you have two contracts, two virtual channels here and now you can do like another virtual channel over, sorry, over the virtual channels. You can even apply this to build multiparty state channels. Which means on the ledger you have two party state channels and then you deploy to those state channels so called multiparty contracts and then you have true multiparty state channels. You can even let someone not participate and like in a black box form combine those different ideas. So to have a virtual channel between Alice and Bob, for example, here Charlie would only be an intermediate.
00:12:30.406 - 00:13:05.030, Speaker A: Was it even Charlie? I don't remember. No, that was Ingrid, I guess. So here would be Ingrid. And then you can run a multiparty state channel on a combination of virtual channels and state channels. This is an overview of all the work that we did. This has already been done and this were a couple of papers published at those conferences here. So you have virtual channels for payments in the original peru paper, but it was just published this year.
00:13:05.030 - 00:13:43.486, Speaker A: In the first paper that got accepted we had virtual channels. But within the virtual channel you would only run one contract, but you could run several contracts in a state channel. And then very recently we also submitted a paper actually it got accepted to Eurocrypt on virtual multiparty state channels. The approach generally here is the modern cryptography approach. So you define security protocols, you define the security of the protocols that you want to have. You model the adversary and stuff like this and then you design the protocols and then you prove the security. And this is usually an Iterative process, right? Because you don't really get a protocol right in the beginning.
00:13:43.486 - 00:14:41.090, Speaker A: So you prove the security of the protocol and then do it again and again. Yes. So, I mean, we have seen many examples of ad hoc secure designs by also very smart people. But because they didn't really try to prove the security of it, eventually there was like a bug in the protocol itself. And I mean, you also probably heard about the Zcash protocol problem that was released a few weeks ago and there was just one example of that, that they were proving the security of the protocol after the fact that they implemented it and suddenly there was a huge bug in it. We are collaborating with Bosch on an implementation. So what they've already done so far is a basic node software that's like the perun node here and here the nodes are connected on the one hand to an ethereum client so they can interact with a blockchain.
00:14:41.090 - 00:15:24.930, Speaker A: They also have a WebSockets between them so they can interact with each other and for the future is planned that they also have a gRPC interface by which, for example, edge devices or user interfaces could connect to. Yes, the virtual channels will come in their next iteration and a GitHub release in the second quarter of 2019. And this is our roadmap. So we applied to the German government for a fund to get funding for five developers. And then we'll also be hiring. So if anyone is interested in developing crazy cryptography and building smart contracts and the infrastructure for Ethereum of the future, contact us. We'll be based in Frankfurt and Damscht at the beginning.
00:15:24.930 - 00:15:50.934, Speaker A: Yes. So the first goal is a Go node for ledger state channels. It should have a gRPC interface. Then we'll follow the virtual channels. It's also called meta channels, as you will hear by Liam in the Talk in 1 hour on counterfactual. This should work then in a Hub network. I mean, if you remember the slide before with Ingrid in the middle, this is kind of a hub.
00:15:50.934 - 00:16:16.434, Speaker A: So you have many users connected to the Hub. And then over the Hub you can open a virtual channel, then follow multiparty state channels, which is still active, research how to do this in an efficient way. And finally you can do cross blockchain virtual channels, possibly with Quorum. That's pretty easy because it's also running Ethereum. But you could also do it on fabric. And that was a backup slide. And that's my last slide.
00:16:16.434 - 00:17:31.508, Speaker A: Thank you. Questions? Yeah, please. I'm not saying it's like super, super complicated, like not solved. But we want to focus on building a state channel network in a single blockchain realm first and then we want to expand it because I mean, in a cross blockchain, what you really have is you have like an intermediary that is connected to two blockchains, right? Then you have, for example, an intermediary that is acting in both chains. Then you could over this intermediary, do a cross blockchain channel. Yeah, but yeah, so, I mean, how let's say new. I mean, we are very closely collaborating, for example, with Counterfactual, with Liam.
00:17:31.508 - 00:18:10.790, Speaker A: And it might just be that we use the same protocol release so that we have actually compatible Note software. We are like talking about it right now. We hope that we can find common ground. So we have common protocols that we implement. But like I said, we want to focus. I mean, that's our vision for the next year that we want to do like a node software in Go that can work for IoT devices or something. And for example, counterfactual is concentrated on focused on, for example, MetaMask apps where you can use state channels within it.
00:18:10.790 - 00:19:04.480, Speaker A: But I'm not saying that it's very separate from each other. It could actually be compatible. You mean like in general? Why is there an interest in state channels? From a business perspective, you mean? Yeah. Okay, so one easy answer to this is in this first year we are going just to build an open source implementation because we think it's an awesome technology and we just want to have it built so there's not like a big business perspective on that. In the beginning, we really just want to have something running and done. But I think for the future you could also imagine how to call for blockchain consortias. They would be interested in doing that.
00:19:04.480 - 00:19:46.348, Speaker A: In the background, we are talking to a couple of consortias, for example, for energy blockchain networks, for smart grids and that kind of stuff. For them, it would be very interesting to have smart to have state channels, for example, to enable microtransactions. You can also have microtransactions between, for example, cars at at stations like electricity stations. And you can have microtransactions even offline using virtual channels. So there's even an interest in the industry to implement this. We're just starting. Yeah, there's not a node yet.
00:19:46.348 - 00:21:50.086, Speaker A: If you want to look at a pretty far project already, counterfactual, I think it's basically already available on GitHub. There's not a lot of documentation, but their implementation is quite far already that you could use it, for example, for in browser applications already. And like I said, so Liam is going to give a talk on that in 40 minutes. To be honest, I'm not very deep into connex, so before I say half, but Marius, he's from my team, he maybe has a better answer. All the cool stuff. Oh, yeah, you told me. They like bolded down to a very basic thing, which was one thing.
00:21:50.086 - 00:22:51.498, Speaker A: To add to that is this is one of the well, I don't want to say problems, but the protocols if you read the papers, the protocols were designed and written up in a fashion that makes it provable in a cryptographic modeling framework. So the protocols were not written and designed in a way to make it implementable, but to make them provable. So this is something that you will realize if you read the papers. And this is also a process that we are going through now to kind of look how we can transform the protocols still being provable or make them more implementable. All right, any more questions? Intermediaries. I mean, I just have the general answer that anyone else can give, like Enlightening. You can do fees, you can easily implement fees and model fees in this scenario.
00:22:51.498 - 00:23:58.180, Speaker A: So what you would do, if you remember there was this one slide with the I don't want to scroll back to and there was this one slide with a virtual channel with the intermediary Ingrid. And then you have those two subcontracts where Ingrid takes a role of Alice in the one channel and Bob in the other channel. And then what you could do is design the contracts in both that there's some fee left, right? So at the end they cannot pay out the full amount that they paid in, but only their amount minus a fee. So that can be easily extended in that way. But that's like, I think the general concept that you can do in any state channel networks to easily include fees? Yes. In the recursive virtual channel model, yes. It grows linearly because actually I have it on a backup slide, I think.
00:23:58.180 - 00:24:35.774, Speaker A: So if you have like a channel over another channel and then you have a dispute, and then you would try to solve the dispute over this channel. And if that doesn't work, Bob is also malicious. Then you try to resolve the disputes in the corresponding channels here in those state channels. And if that doesn't work, you finally go to the chain. And this of course, every time you have a new timeout, so the timeout adds up linearly. But this is like an old approach where you have this so called indirect dispute. And in the newest paper, there's also a model with a so called dispute board.
00:24:35.774 - 00:24:58.080, Speaker A: And then whenever there's a dispute, you can go directly on chain to resolve the dispute in the dispute board. So you only have a constant timeout for waiting. And this is then also much more similar to counterfactual. We also have some kind of a dispute board. Yeah, that's the direct dispute with the dispute board. Yeah. Thank you.
