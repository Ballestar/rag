00:00:00.170 - 00:00:51.190, Speaker A: Click the link right there. And I'm not going to keep the chat open because it takes up a lot of real estate here in the slides. So if you want to watch a recording of this, there's a couple of them at these links at the top and otherwise I'm going to go through the presentation. But I'm highly interruptible. So what that means is if something doesn't make sense, or more likely if you know something about what I'm saying, maybe more than I know about it and you want to interrupt and kind of correct me or add a little bit of color or texture to the conversation, don't hesitate. I think that's really the best way to make this work. So I guess the fastest, easiest way to do that is just to kind of type something in the chat and then Heather will be your voice to interrupt me and then we can kind of talk through whatever it is that you have in know.
00:00:51.190 - 00:01:34.940, Speaker A: We've got about an hour together. I'll do my best to make sure this hour is useful for you so we can just kind of get started with that. So this workshop is intended you tell me if it works to be an Intro to Nier protocol for Ethereum developers. I myself am not an Ethereum developer, so I'm taking a big risk by claiming that I can actually make a workshop that's an intro for Ethereum devs. So you'll see along the way kind of where I've done my best to learn about the Ethereum ecosystem and building on Ethereum. Here on the first slide again, you'll find the recordings at the top right, a couple of install steps. If you've never installed node on your computer, then I wouldn't do that now.
00:01:34.940 - 00:01:56.894, Speaker A: But if you have it, then you can install the Near CLI, the command line interface for near in just a couple of quick minutes. And you can make a test account for yourself on near. And that way, whatever it is that you see me talking about or doing, you can just verify yourself. All right, so why near? That's probably your first question. So here's why. Near is cheaper, faster and easier to use. That's our claim.
00:01:56.894 - 00:02:45.934, Speaker A: I'm going to do my best not to read off the slides, but I'll talk kind of around and about them. So when you're building contracts on Nier, you can use Assembly, Script or Rust. Those are the two languages that you use to build contracts that you can then compile to WebAssembly, WASM, and then you deploy to near. And that's different from Ethereum in that you would use Solidity. Typically, I guess there's another language, Viper. I don't know how popular that is, but you would use Solidity and then you would compile that to whatever the EVM bytecode is that it expects and then you would deploy that to the EVM. So with Nier you're building on languages that have these communities that are not necessarily specific to Blockchain.
00:02:45.934 - 00:03:19.334, Speaker A: So Rust obviously is a high performance systems programming language with a lot of type safety rich tool chain, huge community. The rust WASM connection is really tight. It's maybe the most mature WASM compiler out there. If you're dealing with high value contracts, you want to use Rust. So any contract that's going to be dealing with a lot of value, you want to use Rust. But assembly script is familiar to JavaScript and TypeScript developers. In fact, it's a strict subset of TypeScript.
00:03:19.334 - 00:04:02.170, Speaker A: So if you are familiar with front end dev, then Assembly Script is just a snap to pick up. It's really easy. And the mental models of near don't change across these two languages. So if you're coming from JavaScript or TypeScript, you want to get started right away, dive into building contracts with Assembly Script, figure out how near works, and then if you want to learn Rust, you can go and do that. If you're already familiar with Rust, or if you come from like a high performance systems programming background, C or whatever, and you're familiar with Types or strictly Type languages because the Rust type system is unforgiving, then go for Rust right off the bat. Nothing wrong with that. Okay, so that's kind of the high level story in terms of development.
00:04:02.170 - 00:04:44.150, Speaker A: And the argument there is that it's cheaper to onboard devs. The learning and development troubleshooting debugging process is faster and easier to use because of the maturity of these tools in production. Gas fees are designed to be lower. So orders of magnitude lower than those of Ethereum just out of the box from the primitive level operations. And obviously those can be changed through governance processes. But at Genesis, on mainnet testnet, whatever, they're super low. So there's also these mechanisms where contracts can earn fees.
00:04:44.150 - 00:05:50.594, Speaker A: Currently at Genesis they were set up as 30% of the transaction fees go to the contract itself or allocated to the contract account. Which means developers have a mechanism for revenue collection that's baked into the protocol that lowers your total cost of ownership of contracts, obviously, and some other benefits there. And in terms of kind of it being snappy, we're talking about like 1 second block time, three second finality, which is significantly faster than Ethereum. So that's the argument. Why you would think about Nier is that it's cheaper, faster and easier to know ethereum and the Ethereum network and the Ethereum community is where it's at, it's where it's been and where it will likely be in the future. And so I think the argument here is really that we'd like to play with and alongside of these applications. And you'll see a bridge in a minute here where we're talking about connecting the two networks.
00:05:50.742 - 00:06:00.990, Speaker B: Sharif, we've got two questions. Just what WASM interpreter do near clients use and what aspects of the Rust tool chain speed up development?
00:06:02.210 - 00:06:45.950, Speaker A: Yeah, so I think we use Wasmar and I think Wasma WASM time. And there's another one maybe, but I think it's wasMr is the short answer to that. And if you want to dig into that, I'm happy to connect you with the devs. But if you go to Near Chat, you'll jump into our discord and you can ask there and devs on the core dev team will be able to respond with more detail. I think the short answer is wasmer in terms of the Rust tool chain that make things faster and cheaper to build with. In general, when you're building software, I hope I don't come off as like a know it all. I'm trying to answer your question here, so let me see if I can do it justice.
00:06:45.950 - 00:07:53.182, Speaker A: When you're building software, a big part of the cost of development comes from the maturity of the tools that you're using. So if you're building against like an Esoteric language, or a custom built language, or a language that has sort of an isolated community, then typically there's going to be rough edges in the tools testing Debugging, the kind of the development testing Debug cycle itself might be a little bit slower. Setting up a test environment, setting up a dev environment, all those things are going to be a little bit rough around the edges compared with an environment where there's a large community of developers that are innovating for many different target environments. And so whether you're building on a Mac or Windows or Linux or whatever, you should have a smooth experience. Basically, the more mature the language and the community and the tools that they use are. So hopefully that answers the question. In general, any kind of custom language is going to be a little bit rougher on the edges compared with a general purpose language.
00:07:53.182 - 00:08:23.418, Speaker A: So that's the argument. I'll just keep going, Heather, and if there's more follow up, maybe you can just kind of interrupt me again. I'll assume that's okay. All right, so several examples and starters, if you go to near dev, you'll see maybe twelve or 15 examples. Some of them are written in Rust and assembly script. And basically you can go in, you can check out the source code. Everything I'm talking about, including near protocol, is all open source.
00:08:23.418 - 00:09:19.838, Speaker A: So you can check out any part of any of these tools or systems that I'm talking about here. And the examples on near dev you can actually run right in Gitpod, which is a web based editor that we're using to kind of gives you a Visual Studio code like experience. You can go in there and just start tooling around without installing anything locally. So that's pretty cool. And of course these examples are going to range from random things that we've decided to build to ERC 20 and ERC 721 clones, that kind of stuff. So implementations on near of those specs, and we call them something a little bit differently on near, but you'll be able to read more about that. So anyway, these are examples you can just kind of get started with and you can actually get started building a near app in just a couple of minutes.
00:09:19.838 - 00:09:55.562, Speaker A: So if you want to start typing like now and see something work in the next 30 to 60 seconds, NPX create Nearapp and then whatever your app name is, in this case it's Banana. And then just run the you'll get an assembly script contract by default with a plain JavaScript front end. By default you can switch that to Rust and React. But I would recommend against that because with Rust you're going to need a little bit more tooling to do your development. The compilation process is a little bit slower. Assembly script is going to be super fast. And then if you're not familiar with React, obviously that's going to add overhead to your learning process.
00:09:55.562 - 00:10:27.314, Speaker A: So just like plain JavaScript is the simplest code you'll find there. So NPX create near app and then whatever your app name is, it'll generate a folder, build the thing, you jump into that folder, NPM install and then NPM run. Dev will create an account. Deploy this app to testnet for you and it'll load on your screen. You'll be up and running it's pretty fast. If anybody's curious, just shout out in the comments and I'll do it for you really quick to kind of give you a sense of what that feels like. So in general, same but different when we're talking about Ethereum.
00:10:27.314 - 00:11:02.526, Speaker A: So talking about primitives, for example. And here I've just picked a few things. So accounts, state transactions, gas and blocks. With accounts you're talking about on Ethereum, two kinds of accounts is my understanding. So externally owned accounts and then contract accounts. And there's some things you have to know as a newcomer to Ethereum. Like externally owned accounts are basically the last 20 bytes of maybe the implicit key generated from the public key of the public private key pair or something like that.
00:11:02.526 - 00:11:39.660, Speaker A: I might be getting that wrong. And the externally owned accounts are the only things that can generate new calls. Contract accounts don't have a key pair, they're controlled by the contract. So there's some specific constraints on accounts and what you can do with these accounts that makes perfect sense once you get it with near, there's basically just one kind of account. You may or may not deploy a contract to that account and it's fine whether you do or don't. The account holds its own. State can have many keys, unlimited number of keys per account.
00:11:39.660 - 00:12:17.014, Speaker A: And so there's a detail there. You'll notice that nonces are kept on the keys, not on the account. For example, with State, Ethereum, state is replicated across every node and you've got this kind of single threaded machine that's moving with near. State is isolated to whatever the home shard is on your account. Mainnet is currently only running one shard on your testnet is running one shard. We have a guild called the Sharding Guild a group of people who are dedicated to kicking the tires on a multi sharded environment. I think they've got four shards running right now.
00:12:17.014 - 00:13:06.870, Speaker A: That was the last I heard a couple of weeks ago. What happens is when you deploy an account as a developer, you don't think about what shard it goes to. The protocol, decides where to put it. And then if an account gets particularly hot, like a CryptoKitties account, and starts consuming the capacity of a shard, then the protocol reserves the right to move that account to its own shard, to isolate it so that the other accounts can take advantage of whatever the throughput capacity is. So I think it's 200 transactions a second is the upper bound if you kind of tune the transactions but it'll almost certainly be lower than that for sophisticated transactions, I guess. So 200 TPS per shard is like the upper bound on that and then it would scale almost linearly per shard the system. And so with near you can think of it as like a multithreaded system.
00:13:06.870 - 00:14:03.514, Speaker A: Each shard is operating as its own thread and then they get reconciled through consensus over time. I guess the closest thing to that in the way we talk about this stuff is like a bunch of side chains that get merged into some kind of like home chain or beacon chain or something like that. I'm not a blockchain protocol expert by the way so if I'm not making sense at this point, please forgive me. Transactions with Ethereum. You've got the idea of, like, a transfer, a contract deployment and a function call and contract deployment is like you send a transaction to a particular address and then the protocol knows that when you do that, that it's. Going to take whatever the data payload is, turn that into a contract account that's generated from whatever your public key is on the EOA that made the transaction incrementing the nonce once. So you get this automatically generated contract address.
00:14:03.514 - 00:15:07.194, Speaker A: There's a bunch of this implicit stuff that happens in Ethereum with transactions and so with near, conversely you've got these eight basic actions and you compose those into a transaction that you then send to the network. And to deploy a contract, for example, you just make an account and then you deploy a contract to it. You can make a single transaction that has create account action, deploy contract, add key and then invoke a method in one transaction and do that all at once if you want as well. Those are choices that you make with those actions. You can basically compose these actions into a sensible transaction and sign it, send it to the network. Gas price in Ethereum is determined by network load and profit motive to make sure that people kind of keep the machine working the way you would expect. Whereas near's gas prices is algorithmically controlled to try and converge on 50% congestion in a shard.
00:15:07.194 - 00:15:54.986, Speaker A: So if the shard gets over congested, then the gas price goes up at a maximum of like 1%/second 1% per block, basically. And since the block is about 1 second, that's about how fast it will go up to try and disincentivize people from using the network. And then if the congestion goes below 50%, then the gas price will drop at the same rate, 1%/second 1% per block, to encourage use of the network. So there's that kind of stuff, it's a little bit different. And then Ethereum currently is proof of work, obviously moving to proof of stake soon. And there's a consensus at a rate of one per 15 seconds or minutes. I'm sorry, I forget right now.
00:15:54.986 - 00:16:41.226, Speaker A: And that seems like a silly thing not to know off the top of my head. And with near, blocks are produced with proof of stake consensus at a rate of 1. That's kind of like the high level of these primitives in terms of some features. There's this kind of standard comparison. So ERC 20 with fungible tokens, ERC 721. With NFTs, the equivalent is NEP 21 to match the ERC 20, and then NEP four to match the ERC 721. The differences in these NEPS, the idea is that we're taking advantage of the sharding mechanism and how accounts are used, and so that there's a few slight differences in the interfaces there.
00:16:41.226 - 00:17:12.950, Speaker A: And some new proposals for improving on those as well are currently in process. For a transaction result, you check Etherscan on the Ethereum side. You just kind of look it up there. With near, you can use Near Explorer or you can use the CLI to check the transaction status by passing in the hash. There's a couple of special data types and I just kind of wanted to draw some parallels here. So with Ethereum, you've got the address type, you've got the mapping type. With Ethereum, all accounts are string type.
00:17:12.950 - 00:17:51.810, Speaker A: And so you can validate using a regex, basically is valid account ID. And for mappings, we've got a set of collections. So the storage in Nears, all key value pairs. And then on top of that key value pair data structure, we've added some other abstractions, right, like a double ended queue or a vector or a map or whatever. And so there's a bunch of those. Anything that's in blue in these slides, you can click on a link to get to it. And just to remind you, I posted it already in the chat, but it's bit lynch to get to the slides.
00:17:51.810 - 00:18:39.390, Speaker A: So any of these links you can click on, that'll take you right into the list of the collections. In Rust or assembly script, for example, Ethereum has a payable method, near has a payable macro that you put on Rust methods. And in assembly script you would just have to check to see is there some attached value. And if so you might want to throw or something like that. And then there's an event model in Ethereum where we don't have an event model in near. But you can pull this particular RPC method called experimental changes with some parameters and that'll give you filtered log events, basically a filtered sense of what's happened on chain. And then to run a node you would use something like Ganache, I think a state of the art in Ethereum.
00:18:39.390 - 00:19:15.840, Speaker A: With near. There's a near up. It's a Python script that kind of manages whatever it needs to do in the background, spinning up nodes and so on. And you can tell the nodes to run in local net or testnet or mainnet or whatever with some command line switches. So that gives you kind of a high level comparison of maybe some features in terms of deployment. Again, I'll just remind everybody if you've got questions, you want me to stop or go back or something like that, just interrupt in the chat. If I don't hear from you, if I don't hear Heather interrupting me, I'm just going to assume that you want me to keep going and that the pace is okay because you're not saying slow down.
00:19:15.840 - 00:19:54.330, Speaker A: For Ethereum deployment, the idea is that you would compile this contract bytecode, compose a transaction, attach the bytecode, maybe some initial value sign and send the transaction to the special address. That then creates the new account, deploys the contract and you get the new contract back. Right? So with near similar, you compile the bytecode and then you compose this transaction. But the action that you use is deploy contracts. It's one of those eight actions. You can also add things like create account with it. If you don't already have an account that you're deploying to, you might want to add a key to allow you to control that account.
00:19:54.330 - 00:20:48.742, Speaker A: You might want to transfer some value as well. When you do that, you sign and send that transaction and then you receive the outcome. Basically, of course, if you have a full access key maybe I shouldn't say of course because you're just learning this, but every near account can have many keys, I think I mentioned that before. And the keys can be one of two types full access, which basically lets you do everything including send money, delete the account, deploy contracts, and a function call access key which is constrained by budget, a set of methods and a receiver. The receiver can be the account itself on which the key is set. Or it can be a separate account that you can use as like a proxy budget. So I can use a function call access key to spend a developer's money in a trial basis to call a contract account that they've deployed.
00:20:48.742 - 00:21:25.526, Speaker A: And so you could use that for like a freemium model, for example, to onboard people without having to create an account and do all sorts of stuff anyway. So we can kind of mess with these actions is the idea here. And then just kind of looking at this as a picture. Ethereum transactions, near transactions, you can kind of think of them as having this metadata attached value and then like some kind of payload. So metadata maps nicely here. Origin is VRS details from the signer. You can figure out who the signing account was.
00:21:25.526 - 00:21:57.790, Speaker A: In near, you actually have the signing account and their public key is included in the metadata of the transaction destination. Ethereum calls the recipient. Near calls the receiver uniqueness. There's this idea of a nonce and the nonce is really like part of the key in near. And then cost control. You would handle that through a function call access keys if you wanted to set limits and budgets. So that's part of the metadata and Ethereum transaction where you set the gas price and the limit.
00:21:57.790 - 00:22:34.922, Speaker A: And then there's this idea of recency with the block hash because of the proof of stake is my understanding. So you have to include something from within the last window of time. That window is set at Genesis as a configurable kind of limit on how sort of proof of recency for the transaction. I think it's set something like 4 hours or whatever it is. But you can look that up. It's just part of the Genesis configuration. And then value is basically just attached Ether, the native token in Ethereum and attached near tokens in near protocol.
00:22:34.922 - 00:23:16.618, Speaker A: So nothing really different there. And then in terms of the data, if, for example, we're making a function call, the data would include like a selector of the function signature or whatever, some prefix, I guess. First four bytes or whatever it is, of the function signature. And then arguments encoded in some way. And then on near, the actions are these eight actions that break up into these four categories. So identity related actions like create account, delete, account security related actions, add key, delete key. There's two kinds of keys full access and function call, access value for transferring and then Staking, where you kind of lock value up to maintain the integrity of the network and you earn some interest on that.
00:23:16.618 - 00:23:38.420, Speaker A: And then Code, where you deploy a contract or make a function call. So that's kind of the deal there. Here's a little bit more about each of those eight actions. I'll just take a breath for a minute and let you read this slide. Any questions? How's the pace? Should I speed up or slow down? Sometimes I get to talking a little bit too fast.
00:23:43.310 - 00:23:45.030, Speaker B: I don't see any comments.
00:23:45.110 - 00:23:50.270, Speaker A: So should be all good or everybody is asleep.
00:23:51.010 - 00:23:53.680, Speaker B: Pace is okay. Speed is near perfect.
00:23:54.850 - 00:23:58.080, Speaker A: Okay. Wait, was that a pun? Near perfect.
00:23:59.010 - 00:23:59.950, Speaker B: Well done.
00:24:00.100 - 00:24:15.558, Speaker A: Yeah. Nice. Well played, sir. Okay, so moving on. Mapping concepts. So ethereum and near here custom language custom VM on ethereum. So obviously the pros are like all this stuff is designed for the blockchain, so maybe you can even formally verify it.
00:24:15.558 - 00:25:02.274, Speaker A: There's a bunch of good stuff there and it's proven, it's been around for years now and it's managing a ton of value. The cons are you can't really reuse solidity anywhere. You can't bring in libraries from anywhere. It's just solidity in that custom language. On near you're dealing with assembly script and Rust, the WASM VM and so some of the things that we talked about before, the tooling, the community, and obviously some cons is that it's not designed for blockchain. So some things you can't do like anything that reaches out to the machine, any libraries that sort of expect there to be a clock for example, that's not going to work, or a file system, obviously that's not going to work because it's a resource constrained environment on chain. So it's a little bit different that way.
00:25:02.274 - 00:26:03.270, Speaker A: But it's kind of pros and cons here of some of these ideas and then pros and cons just on near of using assembly script versus Rust for sure. If you're coming from a web dev world like assembly script, probably would take you like an afternoon to get to intermediate or expert level in writing assembly script. And if you're familiar with TypeScript, it's even faster. It's just like a no brainer. But the compiler is immature and so we don't recommend assembly script for high value contracts prototype to your heart's content, but the minute you're going to manage a significant amount of value rewrite your contracts in Rust and it's the type, safety and the maturity of the compiler there that gets you that safety basically. All right, so we can talk about some differences here because near is sharded and accounts can be kind of moved around by the protocol to maintain maximum throughput across all shards. Yada, yada.
00:26:03.270 - 00:26:34.674, Speaker A: There's this idea of asynchronous calls. So this is a view of asynchronous calls. I've been trying to figure out how to explain this best. So here's maybe like draft number two to try and explain this. The top half of this is stuff you already know as a developer has nothing to do with near. The bottom half the internal stuff is asynchronous calls from inside of your contract code. That's the new stuff.
00:26:34.674 - 00:27:11.246, Speaker A: And I'm going to go top right counterclockwise, strange as that may seem. Counterclockwise ABCD in order to explain these. Okay, on this picture here we've basically got external and internal batch and then promise. So the promise is what you would see if you look up JavaScript promises on Mozilla Developer Network. That's what that top right hand side is. And there's a similar thing in contracts where you can make a call to another contract. You can fire and forget it'll happen at some point.
00:27:11.246 - 00:28:19.250, Speaker A: You can fire and register a callback to come knock on your door. Whenever that contract's done doing its thing, you can pass parameters over and you can expect parameters to come back, obviously structured types that you would set up those arguments, whatever you're expecting the data to move back and forth. On the outside of near, we call the payload of instructions a transaction once it passes the boundary of the network and it's happening inside, including these promises, we call it a receipt. And there's a term collision there in Ethereum, because I think a receipt is like what you get back when a transaction gets processed. But in near, a receipt is what you call a transaction. Once the signature has been verified and validated, the account's validated, it's got enough budget to actually do the work and et cetera, et cetera, it's on the inside of the network, then you call it a receipt. And those receipts can kind of propagate around multiple accounts around the network, kind of causing other receipts to be generated, et cetera, et cetera, depending on these cross contract calls.
00:28:19.250 - 00:29:03.582, Speaker A: So that's A is the promises that you know from JavaScript, and there's an equivalent inside of contracts that you can do that with, and then B this idea of a batch. You can basically use the near libraries to create a transaction, putting together a bunch of actions, those little yellow stickies inside the blue one, and then you can send that off to the network to be processed as a batch action internally. You can do that from a contract as well. Any of the eight actions that are supported by the network, you can compose into a transaction and send that over the wire. I'll show you code right now. So here's what the kind of standard top right hand side A looks like. This is just standard promises in JavaScript.
00:29:03.582 - 00:30:16.214, Speaker A: This is moving now counterclockwise B, this is how from the outside you would use our API to create a deploy contract transaction, where you load a WASM file off the file system and then compose a function, call action calling some function with some arguments at attaching some value gas in this case. And then you would push those on to the transaction, just an array, and then you would sign and send that transaction to some account on testnet in the last line there. So this is a batch action from the outside of the network, inside the network, from inside of your contract code. You could create this contract promise batch. It's a mouthful, but it's basically this collection of actions that you can execute. And so you would say, make this batch for the account, the banana on testnet. I want to create the account, transfer some value, add a full access key that is related to mine, if I'm the one who's signing the transaction that invokes this code, the sender public key.
00:30:16.214 - 00:30:47.122, Speaker A: And then I want to create the account called peel the banana on testnet, transfer some money, add a full access key and deploy a contract there. Then I want to create the account called eat the. Banana, transfer some money, add a full access key, deploy the contract there. And so all of these things will be applied as the code reads, basically as these batches. So here's the transaction. It's this collection. Then I want to apply this other transaction with a collection of three or four actions in there.
00:30:47.122 - 00:31:10.662, Speaker A: So hopefully this makes sense. And then the last one. Now D, we're at the bottom right hand side of that quadrant I can call kind of a fire and forget. In this case, peel the banana using fingers is the method on the account. Peele the banana testnet, throw some gas in there. There's no parameters in the empty quotes. And then maybe I want to eat the banana using my face is the method on the eat the banana contract.
00:31:10.662 - 00:31:53.986, Speaker A: Lots of gas, no parameters, and I can pass in a callback as well into this, but this example doesn't show that that's kind of the promise, but from inside of the contract code. So that would be completely new coming from an Ethereum space is my understanding. All right, so that's the end of the intro to near. Maybe we can pause there and take, like, a deep breath. Any questions? Any comments, any concerns? Did I say anything misleading or absurd that somebody wants to troll me over or something like that? Anything that we need to talk about, any feelings we need to get out about that? If not, we can just dive into the Rainbow Bridge.
00:31:54.098 - 00:32:06.890, Speaker B: There's one question here from Leandro. ETH Two is going to run on eWASM. Some features that you are presenting won't be native question mark, also coding in as or Rust.
00:32:09.890 - 00:32:44.150, Speaker A: I'm not sure I understand that question, and I don't know enough about ETH Two to say anything useful, frankly, so forgive me. I do know a lot of layer ones are using WASM as well, and Rust. And so it's not an uncommon combination if that's where ETH Two is going, but I really can't speak in any meaningful way about that. In terms of Assembly Script or Rust, I'm not sure what that means. If you're talking about with ETH Two, I have no idea. If you're talking about with near. We support both.
00:32:44.150 - 00:33:07.710, Speaker A: Assembly Script is easier for JavaScript and TypeScript developers to get into. Rust is better for high value contracts. I'm sure that you must mean something else by that last question. I just can't imagine what it is he says. Okay, cool. All right, so Rainbow Bridge is this bridge, and just keep firing away questions. If there's something I'm missing or something else you want to follow up on, just keep asking.
00:33:07.710 - 00:33:34.678, Speaker A: Be selfish with your requests and maybe generous with your support. If someone asks a question, I'm not answering it effectively. If you know something about it, dive into the chat and be generous there. That would help. So Rainbow Bridge is this connection between near protocol and Ethereum, and I'm going to do my best to explain it to you in the next few slides here. This is a picture of what it looks like. There's the setup, this use case example.
00:33:34.678 - 00:34:43.294, Speaker A: And then you can extend it from the top to the bottom there, set up use case extend and the two networks and all the kind of moving parts. So at the top level, sort of the foundational layer of this, you could flip this whole thing over and call it like the base layer. But there is this pair of Light clients that live on either network. So in Rust, written in Rust is an Ethereum Light client that has been deployed to near protocol, and that client sits there. It's a contract listening for headers that are sent by some thing that's off chain. And you could imagine it's an Oracle or it's a collection of virtuous servers run by community members, cooperatively or maybe competitively somehow to try and get the right kind of data into this Light client, effectively headers from the Ethereum network. Okay? And so we talk about trustlessness in that area there, but it's not part of this story.
00:34:43.294 - 00:35:20.966, Speaker A: So maybe it's like a node program or a shell program, some script that's running this ETH to near relay that's sending headers from the Ethereum network to this Light client sitting on near that's written in Rust and deployed on near protocol. It's an Ethereum Light client. The inverse is true. Written in solidity. There's a Near Light client sitting on the Ethereum network listening to a near to ETH relay that's sending headers from near protocol. Those Light clients are like the base layer of truth where the network can watch each other. On top of that, we have provers.
00:35:20.966 - 00:36:15.100, Speaker A: And these provers right now are simple, but you could extend them, you could write other ones to prove other things. The Ethereum prover, the one written in Rust, living on Nier, is able to prove that an event has been recorded on the Ethereum blockchain. Effectively, you give it the event and say, was this event recorded? And the Ethereum prover will interrogate the Light client for headers and merkel proofs and other fancy things and basically say, yep, I see evidence of this event happened on Ethereum. It was recorded, I don't know, whatever time ago. And on near the near prover interrogates the near light client. Near prover is written in solidity lives on Ethereum and interrogates the Near Light client about transactions that have been processed by near protocol in the same way has this transaction been processed by near protocol? Then your Light client finds proof of that and says, yeah, it has. All right.
00:36:15.100 - 00:37:16.734, Speaker A: So from there we can do things like build this particular use case where we have a token locker on Ethereum that lets you lock tokens, ERC 20 tokens. And this mintable fungible token contract on near that lets you mint NEP 21 equivalent to ERC 20 tokens on the near side and so what you do is you lock up tokens on the Ethereum side. The relay sends evidence of that to the Ethereum Light client on near. The mintable fungible token contract interrogates the prover, hey, did these tokens actually get locked on Ethereum? And when they have been, then it mints those tokens, the equivalent wrapped version of those on near protocol. So here's an example of what that looks like. So let's say we've got these rain tokens and we say we're going to do that. We tell the token locker to take care of this.
00:37:16.734 - 00:37:43.590, Speaker A: We confirm that we're going to transfer these tokens. Some locked event is emitted by the token locker. The prover verifies that. And then we wait for these blocks. Essentially 25 blocks is fairly conservative bit there a little fast forward. If there was more value, we could wait longer. Obviously on the near side, we tell the mintable fungible token to mint these things.
00:37:43.590 - 00:38:19.380, Speaker A: We need a little deposit because the data to track that minting is going to cost money on near. And then our tokens arrive on the near side of the network. And we can reverse this by burning these wrap tokens and then they would be unlocked on the Ethereum side. So this video is available in the slides and it basically walks through this process. And then these blue bits of text are links directly into the code base where each of these things happens. Like the approval, locking the token, emitting the locked event, waiting 25 blocks, et cetera. All the blue text there is basically available.
00:38:19.380 - 00:38:41.114, Speaker A: Sorry, I didn't mean to kind of rush away from that. I was trying to avoid the video replaying. Okay, so hopefully that gives you a sense of what we're talking about. We're talking about locking tokens on Ethereum Minting, a wrapped version of those tokens on near. And this is this bridge technology that we've put together. And there's a bunch of sample code all open source. You can check all this out.
00:38:41.114 - 00:39:11.662, Speaker A: We just wrapped up a hackathon or are wrapping it up this week, I guess, to encourage people to play with this tech. And then here are those four steps that you saw earlier. One, two, three and four with some overlaps and an activity diagram, I guess is what we'd call this. And there's all the different components. There the Ethnode, the locker, the contract and so on. So if this helps you kind of visualize what's going on, it's just a different perspective on that same thing. And then here are some of those repositories.
00:39:11.662 - 00:39:41.274, Speaker A: So the example is this thing on the left, ERC, 20 to NEP 21. And it's just GitHub.com near examples. And then that repo and you can run everything locally there. It might be a bit tricky to set up, but the docs should help you with that. And then on the right hand side, we're just going to GitHub.com slash near and we query rainbow to see the half a dozen repositories that are related to this bridge, specifically the CLI Rainbow Bridge.
00:39:41.274 - 00:40:15.606, Speaker A: CLI is what you would use to run the bridge, deploy contracts, things like that. Get things set up. The Token connector is a generic token connector across the bridge. It's not specific to rain like the example on the left here. It's a generic token connector that you can reuse for other things. And it's written in Rust mostly there and then Rainbow Bridge. Rs and Sol are the two kind of sides of the Rust side would be like the Ethereum Light Client and Approver that runs on near.
00:40:15.606 - 00:40:51.970, Speaker A: And then the solidity side would be the near light client improver that runs on ethereum. The Lib is some factored out components there for you from dealing from the front end because it's in JavaScript. So hopefully this gives you a good sense of how you can get started with the bridge. And then here's know, using the CLI kind of getting started there. Some of the costs of running the bridge, it's expensive is the simplest way to say it right now to run this thing. But we're working on that so you can get a sense of kind of the prices there. They're pretty high to kind of get things working on the bridge.
00:40:51.970 - 00:41:10.140, Speaker A: All right, so then maybe your question is how do I get started with these toys? Here it is. Create near App. We talked about that earlier and you can actually do this right now if you want to follow along with me. So before I dig into that, any questions about the bridge? Any questions or comments about the bridge that we want to cover?
00:41:18.030 - 00:41:19.820, Speaker B: Nothing in the chat so far.
00:41:21.230 - 00:41:30.750, Speaker A: Okay, yeah, no worries. I'll keep going. If you think of something, feel free to interrupt. So how do I get started? It's. This create near app. Just like, create, react, app. It's create near app.
00:41:30.750 - 00:42:05.050, Speaker A: And we talked about this earlier. Basically, depending on the things that you pick, you get one of these four generated applications, right? And so this is like a simple demo that you can use to explore near and how it works. I recommend that you start with the default which is going to be JavaScript and assembly script. The one on the far left. You can add React to it if you'd prefer that you can use Rust, the two on the right. Again, there's not too many different things here. I've highlighted in yellow some visual anchors to help you quickly scan the file systems and some bold files to compare some of the things that are kind of the critical components.
00:42:05.050 - 00:42:34.482, Speaker A: Anything in bold is what you want to look at first when you generate the project. Basically that's where the meat and potatoes are. And so here in step one, you can literally do this right now. If you've got Node installed, you can run NPX, Create Near App, Banana, whatever your app name is, you'll get this output here. Yarn dev, yarn test, yarn deploy just like NPM run dev or NPM run test. And so yarn dev or NPM run dev. It's one of the scripts in here.
00:42:34.482 - 00:42:59.486, Speaker A: It'll run nodemon to watch your project get things kicked off. And then you'll see this appear. This browser will open up to port 1234 if you're not signed into the wallet. You'll see something like what's on the left. You click sign in, sign in, create an account, whatever it is, near wallet on testnet. And then you'll see the greeting here on the left hand side. You'll be able to change the greeting in the text box, click Save.
00:42:59.486 - 00:43:40.342, Speaker A: And then you'll see that updated little piece of toast pop up and say, hey, your message has been changed on chain. And you'll actually be able to see that in the Explorer if you want. And then here's some questions for you to kind of encourage some exploration. So if you want to get a sense of how this stuff works, you can ask yourself, where are we setting up the connection to near? And if you want to look for it yourself, you can. Or just search for the word keystore and that'll take you right to the code where the connection is happening. Where do we log into the near wallet? There's the hint to search for it, which lines of code wire up the contract. There's the bit of code that you can search for to get right there.
00:43:40.342 - 00:44:08.990, Speaker A: And then if you want to control stuff, you kind of maybe mess around with this little challenge. But coming from an Ethereum background, this is probably trivial for you. So hopefully that gives you a sense of what's going on. And fundamentally, this is probably already in your comfort zone. But you're talking about contract development, UX development, right. So you can either develop contracts with Assembly, Script or Rust, as we said, and then you're using Near API JS. It's modeled similarly to Ethers.
00:44:08.990 - 00:44:39.402, Speaker A: JS, I think is the inspiration for Nearapi JS. So you might notice some similar interfaces and structures there. And that just wraps the JSON RPC API that we've got. And so that's your two kind of interfaces for development extension customization. Here's a picture from very high level. Your DAP on the left using this API to send and receive with the blockchain layer contracts written in Assembly, Script or Rust that you deploy. They get loaded into this virtual machine, read and write to storage based on their execution.
00:44:39.402 - 00:45:32.638, Speaker A: And then response comes back, here's what a lifecycle looks like. Again, coming from an Ethereum background, most of this is probably a shrug for you, probably pretty obvious. And then there may be some interesting bits here where each account holds a contract and state, you can have one and only one contract per account. And what you'll see is if you type at the command line near state, and then account name. You'll see this metadata come back including the amount of value that the account is holding. A code hash that's all ones. If there's no contract deployed to that account or some other fingerprint, which is the Sha 256 digest encoded as Utf eight, I guess if I remember correctly, whatever this code hash is of the contract bytecode and so it's not all ones.
00:45:32.638 - 00:46:22.780, Speaker A: If it's something other than all ones, you know, a contract has been deployed to it and this fingerprint will always be the same. For any given WASM file, any given bytecode, the fingerprint will be the same. So you could check whether or not an account has a specific contract deployed to it. We don't currently have deterministic compile on our contracts, but we're working on that. And so if you have the same already pre compiled contract you can redeploy it to multiple accounts and test because the fingerprint will be the same. But if you recompile the contract from source it may not necessarily generate the same fingerprint, although I expect it's such a high priority feature that we should have that soon. And then for data it's just key value pairs, in this case encoded as base 64 and it doesn't have to be, but in this case it is.
00:46:22.780 - 00:47:05.900, Speaker A: And then if you decode those you'll find just key value pairs as you would expect. Some of the higher abstractions like the vector and DQ and map and stuff will have these kind of prefix structures where you pick a letter or some text prefix for whatever the data is. And then for Rust contracts there's this reserved keyword called state where the contract code will actually live. And if you have any data that you're storing with the contract it'll get serialized into this value. And then when you're talking about writing contracts, here's what some of the assembly script looks like. Here's what some of the rust looks like for the data aspect of it. And so near Bind Gen you see is this attribute or decorator or whatever for this posted message class.
00:47:05.900 - 00:47:47.400, Speaker A: This is for the guest book example there's. Whether or not it's premium is a boolean. The sender is a string and then you put in some text and then we kind of check here to see attach deposit based on the transaction that was used to invoke this message that decides whether or not it's premium. You capture the sender as well from the context. And then here's kind of the equivalent in Rust basically on the right hand side. So near bind gen you've got some serialization there for putting data on chain your struct and then this method to create a new message. And the same tests in the behavior side, we've got a message limit adding a message.
00:47:47.400 - 00:48:34.200, Speaker A: We make a new posted message and then we push. So the distinction here is that in Ethereum, my understanding is that basically any variable assignment that you do in ethereum gets recorded on chain. Maybe that's wrong. I guess you can have some variables that are set as memory that are ephemeral, but generally when you assign a variable or whatever that's going on on your contract that gets recorded on chain, it's not. So with near you have to explicitly call storage set, storage write that's happening inside of the persistent vector class here. It's basically calling that if you look at the source code somewhere will be like a storage set or storage write. And so the posted message again is even higher than that because it's our custom domain object that we've made that represents the message.
00:48:34.200 - 00:49:25.846, Speaker A: You're not going to see any kind of writes here, but whenever you push this message onto messages underneath the hood, that's getting written to the chain and then get message, we're kind of reading this back and returning this collection of posted messages. Again, the same thing here in Rust where we've got this guest book as like the main contract and then we can add a message and get a message here. And you'll have to forgive me, I wrote this, but didn't test the Rust side of this code. So if you find a bug in the Rust side of the code, that's on me, no matter what, the output is always a WASM file. And with can, actually the WASM is really easy to read. Sorry, the WebAssembly is text representation, so the WASM you won't be able to read obviously, but the WebAssembly is text. Is this other representation? It looks like kind of a lisp, I guess.
00:49:25.846 - 00:50:10.774, Speaker A: And you can see a bunch of the names of these tokens like get message, the name of the functions, add message, get messages, you can see them right in the code and you can practically read the Wat format to see what's happening on the stack here, getting things, pushing them on stack, popping them off, et cetera. That's the Wat format. And with assembly script contracts, because the compiler is so close to the code, there's not a lot of machinery in there for assembly script. So the WAP files are much more readable. With Rust there's a lot of machinery. It's going to be hard to read the Wat file like this and then we could walk through the guest book. But I think we're close to running out of time here with eight minutes.
00:50:10.774 - 00:50:40.880, Speaker A: So I'll just continue unless I'm interrupted by questions. So again, the guest book, a couple of main folders, assembly and source and here's the data model. So posted message, you've seen this. Here's a little bit more explanation of what that looks like. I'll just let you read this probably faster than me speaking it out and you have access to the slides as well. So there's the data model, here's the behavior. We just saw this a minute ago.
00:50:40.880 - 00:51:28.954, Speaker A: It's some configuration so we know where the network is and then the front end. So here we're connecting to near, wiring up the contract. We get this object, a JavaScript object that's like a proxy for the RPC interface excuse me. With some methods here that we can call. And then the application that loads this up. This is a react version using some hooks, and we request sign in. The wallet handles the redirection to the wallet back and forth.
00:51:28.954 - 00:51:55.782, Speaker A: Your private key is stored in your local storage. And then a little bit more here where we add the message and then get messages as a result of that, promise resolving. And then we load the page. So whenever you add a message, the page refreshes. Okay, so that's the end of the presentation. Got about five minutes left for questions or comments or corrections. Wide open for feedback on this stuff.
00:51:55.782 - 00:52:42.360, Speaker A: This is definitely not all in my comfort zone. Maybe half, if I wanted to be ambitious of this is stuff that I'm very comfortable with. But there's a lot that I said here tonight that I would appreciate your critical feedback on. Slides are at bit lynch. Near Chat is where you can get a hold of us on telegram. Near Help is kind of a high level overview of all the ways you can get in touch with us. And there's a couple of recordings of this presentation on the first slide here in the top right hand side if you want to check those out as well.
00:52:43.850 - 00:52:54.626, Speaker B: Awesome. Thank you so much. Sharif, good feedback here. Really like the S two near, we'll be trying this. Thank you. Sharif. From Leandro.
00:52:54.626 - 00:52:57.910, Speaker B: And thank you from everyone at East Global. This is a great presentation.
00:53:01.000 - 00:53:02.700, Speaker A: Wonderful. My pleasure.
00:53:04.240 - 00:53:25.690, Speaker B: If anyone has any more questions, feel free to unmute yourself, jump in, and if not, you can always reach out to the near team at Near Chat. As mentioned earlier, you definitely want to integrate near into your hack for ETH Online. Cool.
