00:00:00.490 - 00:00:56.414, Speaker A: What is enzyme finance? It is a decentralized asset management infrastructure built on ethereum, which is a great series of words, but what does it actually mean? So, in practice, what it means is that an asset manager can spin up an enzyme vault that's capable of accepting investments and issuing shares and using the funds from those investments to allocate across various decentralized financed primitives and protocols. It's essentially an aggregator of these protocols. So that's also cool. But what I think would maybe be best is showing how to create a vault and then a quick overview of what is possible within that vault. So this is the web app. This interacts with the enzyme smart contracts to create a vault. It's pretty simple.
00:00:56.414 - 00:01:16.506, Speaker A: It's five steps. We'll name this ETH. Online. First, you select your denomination asset. This is important because the performance of the vault is measured in this asset or against this asset. It's also the asset in which you will accept investments. Next, you can set up fees.
00:01:16.506 - 00:01:51.514, Speaker A: So as a manager, in order to get paid, you need to configure management performance and entrance fees. There's a lot that goes into thinking about how you want to do this. So I will post a link to the documentation before because these are also permanent. Once you set these fees, they're encoded in our fee manager contract and you cannot change them. Next, there are some deposit settings. So these are changeable after you spin up a vault. You can limit who can deposit.
00:01:51.514 - 00:02:33.326, Speaker A: So this is essentially creating a permissioned list. This works if you have like a KYC program or you're working with a regulated entity that wants to control which ETH addresses can invest in your vault. You can also limit the deposit amount if for some reason you wanted to cap it at ten grand or put a floor at ten grand, ten grand being an arbitrary number, you can control that as well. So these are configurable after you deploy the vault. Next, there's a redemption setting. In principle, your investors as vault manager, your investors will be able to redeem their shares for their portion of the vault. 24/7.
00:02:33.326 - 00:03:12.938, Speaker A: There is one little nuance in that we integrate with synthetics. And synthetics has a settlement process which isn't instantaneous. So there could be an instance where you buy or sell a synthetic asset. The trade hasn't settled, someone tries to redeem their shares, and the calculation of the share price is incorrect because you don't actually have those synthetic assets yet. So what this does provides a window which essentially locks you out of trading and synthetics during this time period. There's some advanced settings, including a time lock. So this would mean that you require investors to hold shares for at least this long.
00:03:12.938 - 00:03:41.346, Speaker A: This prevents various types of arbitrage. We use chainlink as our price Oracles and sometimes they update at different cadences depending on the Oracle. So there can be some arbitrageable opportunities. This hopefully prevents that. We also have some more risk management policies which I won't really go into. You can limit the adapters that you interact with. Again, all of this stuff is in the user docs, which we'll post.
00:03:41.346 - 00:04:12.010, Speaker A: So once you've done all that, you have a review here. You agree to the GPO three terms and conditions and you create a vault. I'm not going to do it. This is actually gas must be pretty cheap. No NFT drops happening at the moment right now because this is a pretty good deal. What you're doing when you submit this transaction is creating custom smart contracts, which I will describe right now. Well, in a second actually, because first I'm going to show you what you can do as a vault manager.
00:04:12.010 - 00:04:38.600, Speaker A: So this is a vault that I created a while ago. Nobody's invested in it. I haven't invested in it. It just serves the purpose of showing how you can do things. So first option, you can trade and swap. As you can see, this aggregates a bunch of different decentralized exchanges, including Paraswap, which is itself an aggregator. So you have essentially access to every Dex out there.
00:04:38.600 - 00:05:30.246, Speaker A: You can provide liquidity on curve and uniswap presuming. You hold those tokens in your vault. Once you've provided liquidity on curve, you can stake it in the staking tab, those LP tokens and you can earn yield on various protocols compound, Ave, urine, Idle, Alpha, More, et cetera. So this is essentially the universe of possibilities that you can allocate to with the funds that you garner through people investing in your vault. Cool. So that's a very high level. I want to just talk briefly about how it works under the hood and then I'll pass it off to Gabriel who's going to talk a little more in depth about the contracts themselves.
00:05:30.246 - 00:06:06.050, Speaker A: So an enzyme vault is at its core two main contracts deployed to ethereum. So the first is the vault contract. This is where all the assets are held. This is also where share price is determined and share issuance logic is held. So when people invest and redeem, all those calculations happen here. The next is a comptroller. So this is permission to spend the funds in the vault and it's configured to talk to the outside world.
00:06:06.050 - 00:07:08.706, Speaker A: So it does so through a layer called the extensions. This is another layer of smart contracts that controls how the or allows the comptroller to interact with, for example, a performance fee contract for the fee manager. Policy manager will talk to compliance policies and risk management. And then I think most interesting from a hackathon perspective is the integration manager. So this is essentially where the comptroller and the vault are connected to decentralized finance. The sort of flow here is that the comptroller will call a function on the integration manager and tell it which adapter to talk to. So if I wanted to buy tokens on uniswap, for example, the comptroller would call the integration manager and it would say call on adapter and it would pass it the uniswap adapter as well as the parameters of the trade.
00:07:08.706 - 00:07:57.350, Speaker A: Uniswap adapter would then go out and talk to the actual swap smart contracts, execute the trade, and it would all flow back into the vault. Flow back into the vault. We're currently integrated with a bunch of different DeFi protocols, uniswap compound curve, idle, ave, et cetera, synthetix. But there are obviously a ton that we haven't integrated with. And I think there's a really interesting green field of opportunity here to talk to things like staking contracts for Sushi or perp or that kind of thing. And I'm going to pass it off to Gabriel, who's going to talk more about the protocol repo that we have set up in order to make it easy to develop these adapters.
00:08:00.490 - 00:08:46.130, Speaker B: Yeah, cool, thanks a lot, Aaron. So, yeah, now I'll be sharing a bit on how you can get started to actually test some adapters, write some of your own. And yeah, we've created a repo that I'm going to share right now in the chat. It's enzyme finance hackathon template that really provides the scaffolding that you need to get started locally, provides a hard hat config where you fork mainnet and can play with enzyme smart contracts without requiring to pay gas and all of that, obviously. So let me actually share my screen. All right, cool. Can you see the screen? Yeah.
00:08:46.130 - 00:09:06.346, Speaker B: Good. All right, thanks. So this is the repo. So to get started with that repo, you simply click use this template. This is going to prompt you to fork this repo into your own GitHub username. I won't do that now because I've already done. Yeah.
00:09:06.346 - 00:09:57.862, Speaker B: So the first thing you're going to need to do, the instructions are here in the README, but you're going to need to provide an environment variable for an ethereum node because that's what we're going to need to deploy some contracts. And that example is here. So ether scan API key is just optional if you want to verify your smart contracts. Eventually when you deploy to mainnet or to Covan, you're going to need that, but you can leave that blank when developing. And then yeah, you're going to need ethereum node mainnet, that could be an alchemy node, that could be an infra node, that could be your own client that you link to whatever you prefer. So when you have that set up and you've cloned the forked repo, you're just going to run Yarn or Yarn Install. So once that's complete, you're going to run Yarn compile.
00:09:57.862 - 00:11:09.940, Speaker B: And what Yarn compile is going to do is take the smart contracts that you've edited or built or just the ones that are default in that repo and compile them, provide you with some TypeScript interfaces. Our repos is TypeScript. So once that's complete, you can test it with Yarn test. It's going to run the default test that we have for deploying contracts, making sure everything is correct, but it should be at that point. So the first thing we're going to want to look at is we've provided one contract for one adapter that we already have integrated, Paraswap, which is just a dex aggregator. So through Paraswap, you can, for example, interact with Uniswap, you can interact with Kyber, interact with Curve, and it just filters the best price, the best price after your net of gas and allows you to trade for you. So an adapter, if you recall from what Erin mentioned earlier, is really what does the integration with the external DeFi world.
00:11:09.940 - 00:11:53.018, Speaker B: So when you want to interact with, for example, par swap, you need to go through the adapter. Going through the adapter. What does the adapter actually provide? It mostly provides a set of methods that converts a call from enzyme into a call to the external adapter in a consistent format. So here you have V for adapter contract. It has an Identifier. Every one of your adapters should have an Identifier, and then you have a set of methods. One of the first methods that every adapter is going to have is just a parse method, which is basically just a helper method that's going to take some encoded arguments.
00:11:53.018 - 00:12:37.694, Speaker B: These are going to depend on the integration that you are doing and convert them into something that can be sent to the external adapter. And then you're going to see some for example, in this case, we have a take order function that takes these encoded arguments, takes a vault proxy. This just means the vault address, the fund address, and then does that action on behalf of the fund. Now, you don't call that adapter directly as a vault manager. You call it through other smart contracts, as Erin had mentioned. I'm just going to go quickly back to one of the pages that Erin had shown earlier on and show a couple of smart contracts here. So this is the manager address.
00:12:37.694 - 00:13:23.610, Speaker B: This is the public address that's allowed to do actions on behalf of the vault, for example, trading or staking or whatever. And these are the smart contracts. The vault is really the main part of the fund. This is what holds the funds. The controller is what you're going to be concerned with in most cases when you do actions on behalf of the fund. So this is really the gateway that you interact with in order to perform certain actions on behalf of the fund. So going back to the code, we have a small test here where in order to do an action with the adapter, we first instantiate a controller.
00:13:23.610 - 00:13:56.274, Speaker B: So this is going to be the address. This is specific to every vault. So we're going to use the address of that controller. And then, yeah, we're going to use a provider, as we mentioned, that comes from your infura or your Alchemy instantiate. It as JSON or RPC provider. In this case with Ethers you could be using Webtree if you prefer. So yeah, we have some helper methods that convert human readable ARGs into encoded ARGs.
00:13:56.274 - 00:14:35.246, Speaker B: So in that case it's named parswap v four take order ARGs. So it's used for paraswap V four for the take order method that we saw just earlier on right here. And it's going to convert a couple of relevant parameters into something that we can actually call the adapter with. So yeah, in that case we're trading cryptocurrencies. So we're going to provide the outgoing asset, the incoming asset and the corresponding amount that we expect to get back. In the case of paraswap, we need to provide a path. The reason for that is that paraswap integrates with many DEXes.
00:14:35.246 - 00:15:20.820, Speaker B: So you could be going through curve, you could be going through uniswap, you could even be going 50 50 if that's what provides the best price. So in that case I just have some mock data and typed it as any because this changes that as time goes by. So you'd have to fetch a recent path for that to work. So that's the first step. Now we have the arguments that are really what's necessary to take an order from paraswap. But then we need to call that through our controller that we mentioned earlier on. So the way this works is you interact with the controller that calls the Integration Manager, which in turn calls the adapter our par swap v four.
00:15:20.820 - 00:16:11.666, Speaker B: So here we have call on integration arcs. This is what we're going to provide to the Integration Manager to know to which adapter you should dispatch the action. So we have the address of the adapter, which if you want to interact with various adapters, we have a reference that's been added here at the bottom, enzyme protocol addresses. So for example, if you wanted to interact with parswap v four, you have that address here. If you wanted to interact with synthetics, you have another address here. And if you want to interact with whatever adapter of your choosing, you're going to need to deploy it and then use that specific address and provide it to the Integration Manager. So going back here we have the address of the adapter, we have the encoded call arguments that we just declared earlier on.
00:16:11.666 - 00:17:00.514, Speaker B: So these are the encoded versions of the argument. And then we have a selector. Now a selector you're going to need to choose which selector you need when you create your adapter smart contract if that's what you decide to do. So this really permissions which adapter does what and helps us identify the types of actions that are allowed by a certain adapter. So in this case, not sure if I can quickly find it yet. So when we do parse assets for method, which is just turning the params into something that the adapter can use, we require the selector to be take order selector. Otherwise, if we use a land selector, if we use a redeem selector or whatever other selector we could have, it's not going to work.
00:17:00.514 - 00:17:47.662, Speaker B: And all these selectors are you can access them, you can quickly import them with timescript. I can perhaps show you a couple if that's useful. So, yeah, you see, take order selectors, take selector, redeem selector lenselector. So whatever action you'd want to do, there's probably already a selector for that. I don't expect that you'd need to create your own, but you will need to use one when calling on integration arcs, because that's a standard method that you're going to have to call if when interacting. So then, as we mentioned earlier, you're instantiating a controller Lib for the controller of the specific vault that you want to perform an action on behalf of. And then you're just calling the controller Lib that you've instantiated.
00:17:47.662 - 00:18:33.700, Speaker B: You're using the call and extension method because you're really prompting it to call something outside of itself. And then you're providing it the integration manager, because it's calling the integration manager, not the policy manager, not the fee manager. And then you're saying, yeah, we're calling an integration. We're providing you the call ARGs that we've defined here, and we're sending that from the address of the vault Manager, in that case, the Manager wallet that we found here. So since this is a hard hat and you fork locally, you can always impersonate any address and test a lot of things out. And then, yeah, you would be sending a transaction and providing gas in that case. But yeah, I haven't done that here.
00:18:33.700 - 00:19:33.598, Speaker B: So, yeah, that's pretty much it for the way you would implement and test your own adapter. One of the things that is important to know and to add here we have that in the tests, is that when you create an adapter, it's not going to be allowed to be used by the Integration Manager by default. And this is for security purposes. We don't want random people creating hacky smart contracts, calling them adapters, and getting someone to call them through their enzyme vault. So every adapter has to be registered on the Integration Manager, so it is registered on a network level, not on a vault basis. So we do that here with the let me just look like we're deploying the parswap adapter and then we are instantiating an Integration Manager, just a smart contract. Again, similarly to the way we instantiated a controller Lib.
00:19:33.598 - 00:20:26.360, Speaker B: And we're calling the register adapters plural with that adapter's address. So if you have an integration that uses three different adapters, you would register all three of these adapters in that array here. And then, yeah, you can test by calling on the Integration Manager. Get me a list of the adapters that are registered and it should obviously include your registered adapter. So, yeah, that's pretty much it for the code. Obviously you can ask questions and we'll be monitoring the discord because we expect, as you go and test things out, maybe you're going to have questions with the protocol. We do have good docs that we've linked in that repo, and I think that Darren shared them in that chat as well.
00:20:26.360 - 00:21:18.820, Speaker B: One of the specific pages that I would recommend in the docs is linked at the end of the GitHub repo here. It's called extensions and plugins. And that really goes over exactly what I've been just going through now, the way the permissions are set up inside of enzymes. So you first have a controller, which is really the part that's most trusted, and then you have managers like fee managers, integration managers that in turn call their specific fees or policies or in our case, adapters, or I think they're called plugins here that just do actions and with external DeFi protocols and yeah, there's a summary here of what I pretty much gone through with the so, yeah, I think that's pretty much what I had to yeah.
00:21:19.690 - 00:21:20.102, Speaker A: Cool.
00:21:20.156 - 00:21:24.520, Speaker B: So we can go on to questions or erin, perhaps you wanted to add something?
00:21:24.970 - 00:21:57.940, Speaker A: No, thanks, Gabriel. That was good. We did have one question from Thomas. Can we connect the adapters for other similar vaults that hold multiple assets but to other purposes as asset management? Can we connect to other similar vaults that hold multiple assets but for other purposes as asset management? I'm not quite sure what you mean there, and I'm not sure what the permissions are in terms of who can call contract functions on the adapters. Do you know that?
00:21:59.030 - 00:22:16.280, Speaker B: I think it has to understand the question. Do you mean? Well, every adapter is always available for all vaults, unless a vault know specifically mentioned that they want to prohibit a specific adapter. Is that kind of what you're asking, Thomas, or am I off?
00:22:17.130 - 00:22:18.906, Speaker C: Can I maybe unmute myself?
00:22:19.088 - 00:22:20.620, Speaker B: Yeah, sure I can.
00:22:21.070 - 00:22:47.490, Speaker C: I think my question is more, for instance, for a lending protocol. If I want to have a vault, but with multiple assets in it to use as collateral, and there as well, I need to have some price points for the multiple assets to come up with one value of the total vault, for instance, that could maybe as well be solved with the adapters you guys created. I don't know if that clears the question.
00:22:47.640 - 00:22:51.166, Speaker A: Interesting. So using, like, vault shares as collateral?
00:22:51.358 - 00:22:52.100, Speaker C: Yes.
00:22:55.450 - 00:23:10.326, Speaker A: I think that would depend on the external protocol. Like, for example, well, there's nobody out there that does that at the moment, but it's an interesting proposition because the vault is like an aggregation of a.
00:23:10.348 - 00:23:16.810, Speaker C: Bunch of different assets and it's all denominated in a single unit, a single token.
00:23:18.830 - 00:23:55.270, Speaker B: I think the issue you would run into at this point, although that's going to be challenging, that's going to be not fixed, but it's going to be implemented in our next V Four release coming out in a month or two is shares at the moment are not transferable. So when you deposit into a vault, you get an ERC, 20 token representing shares of the vault, but you cannot send these shares to arbitrary people. So I can hardly see how you could use that as collateral since that the counterparty couldn't use them or redeem them on your behalf.
00:23:56.650 - 00:23:57.400, Speaker C: Yeah.
00:24:01.470 - 00:24:19.520, Speaker A: So shares will be transferable, or managers will have the option to create a vault in which shares are transferable in our next release, Zulu, which will be sort of like middle of Q four. So that it could be an interesting thing to think about once that is possible.
00:24:20.610 - 00:24:23.214, Speaker B: Yeah. I really like that idea, though.
00:24:23.412 - 00:24:34.730, Speaker C: Okay, now hoping that the Hobadi steals it for the hackathon. It's a very cool project, by the way. Thanks for the presentation.
00:24:34.910 - 00:24:35.510, Speaker A: Thank you.
00:24:35.580 - 00:24:36.600, Speaker B: Cool. Thanks.
00:24:39.850 - 00:24:41.080, Speaker A: Anyone else?
00:24:48.120 - 00:24:51.144, Speaker D: Well, that brings me back.
00:24:51.342 - 00:24:52.456, Speaker A: There he is.
00:24:52.638 - 00:24:53.610, Speaker B: There he is.
00:24:54.700 - 00:25:36.676, Speaker D: If that's all the questions, that was a super interesting presentation and workshop and a lot of good stuff in just a half an hour, which is impressive. Again, thanks to the guys here for putting it together. Everyone stick around in the discord and you can reach these guys in the hackathon discord or their own contact information. Thanks, everybody, for joining. This has also been recorded and it'll be on the E Globe global YouTube site for ETH online event. And with that, thanks, guys, for a great workshop and we'll see you.
00:25:36.698 - 00:25:37.510, Speaker A: Thanks, everyone.
00:25:38.040 - 00:25:39.040, Speaker B: Have a good thanks, Andrew.
