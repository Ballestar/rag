00:00:08.380 - 00:00:44.744, Speaker A: Then you have some functions to, let's say, push money into the vault or either like deposit or mint deposit is meant for. So it basically does the same thing. But one you specify how much underlying amount you want to deposit and the other one you specify how much, how much, sorry, how many shares do you want to get from your deposit. And then kind of the logic takes care of how much underlying to take from your allowance. On the ERC 20 withdraw is practically the same. So you have withdraw and redeem. Withdraw is for your underlying.
00:00:44.744 - 00:01:38.808, Speaker A: So you say hey, I want to withdraw say ten die. Or if you hit redeem you say hey, I want to redeem nine Yvdai shares which is the vault share token. Then you have a lot of utility or view functions which are here defined as external, but the vault wrapper or the 46 26 uses them as well like inside the code. So you will probably have to redefine them as public variables. Sorry, functions. But yes, basically how do you convert shares to assets? How some internal accounting or everything is pretty flexible. So if you do have well you will see as we go through but here you can add specific logic depending on what you are wrapping.
00:01:38.808 - 00:02:25.740, Speaker A: In this case, obviously, we'll see an example of the V, two vaults of yarn. And then there are some functions, either for user facing or for integration contracts, which are okay, let's say I want to deposit 100. I how many shares would I get so I can check? Or I want to withdraw. I want to redeem X amount of shares. How many underlying or assets would I be getting? Then I have some kind of functions that set some yeah, well here it says limit logic. Sometimes you might have a vault that doesn't really want your money per se. We usually have vaults that do not have or have a big deposit limit.
00:02:25.740 - 00:03:28.460, Speaker A: But in some cases you want to just limit a vault or a certain iteration to a certain amount of money. Either one, because you don't feel comfortable holding billions or millions of TBL in a single contract because you are not going to effectively use them. So they will probably dilute the APY for the users that are already in or for any other reason you might find. There is also the same kind of functionality but adapted to vault shares which is max amount of mint. Other shares the same with withdrawals. Sometimes you might have a vault that let's say doesn't have the possibility to give the underlying back or does require some other mechanism for you to get your withdrawals. Let's say in the case of yearn we do have some vaults that have a big buffer, but let's say if you're really big whale or you're in a vault that most of the assets are being utilized in locking strategies.
00:03:28.460 - 00:04:36.340, Speaker A: You might either one, if you're an Iterator and you're probably like in the partners program for yearn, you probably will ping us and say, hey, we are planning on withdrawing 500 million, how can we coordinate? And we unwind the strategies for you to be able to get out. But if you're a user, this can also be useful for, let's say, knowing how much can you withdraw one either without incurring losses because there are supposibility that when you withdraw if you hit a strategy. So if you go out of the buffer that the bot has and you need to go into a strategy that might be a lossy strategy, you might incur in some losses. We'll go into this over and then I notice this the same function for redeem. So basically you have just really a few functions. One for each, one for share management, one for underlying management. So you will see a lot of internal accounting, but most of these should be quite common for you guys if any of you have been working around urine or yield bearing tokens.
00:04:36.340 - 00:05:25.076, Speaker A: So what we did here is vault wrapper, which is basically a contract on top of Yarn V Two vault which is written in Viper that basically is kind of a proxy for your deposits or withdrawals or for your interaction. This contract per se is not an ERC 20. So it doesn't have a token itself. It's just routing funds in and out, both underlying and shares for the depositors. And let's say if you also want to, let's say, add a fee or whatever, it can also route fees into another separate contract. The idea of this contract is to not hold any value at all. So we started constructing the contract right now.
00:05:25.076 - 00:05:51.176, Speaker A: It's pretty simple. This was hacked quite quickly, so there might be some incongruencies. We checked it and it looked fine. But if you guys see anything that's wrong, ping me on Twitter or whatever. We'll open up the source code for this so you can open up issues whenever the repo comes up. So since this is one contract right now we have a constructor for the wall. This can be also a contract that has clone functionality.
00:05:51.176 - 00:06:38.844, Speaker A: So you'll have to deploy the contract again and again and it's a little bit cheaper to deploy. Obviously you might really want to customize these wrapper contracts for yourself, but if you do customize them and you want to tackle different vaults or multiple vaults, it's also recommended to have some sort of this cloning mechanism to basically not waste that madagasch on deploying the same bytecode over and over again. So here we define vault token and decimals. These decimals are defined just to avoid having to do one extra call. You'll see this in a moment. And now here comes the tricky part where we have to comply with all the interfaces required by this new beautiful EIP. So it's quite similar to what we have on vaults V Two.
00:06:38.844 - 00:07:17.636, Speaker A: But there are some naming and some yeah, since now we are required to both handle deposits via, let's say deposit which takes shares, and mint which takes, sorry, which deposit that takes underlying and mint that takes shares. We have to do some tricks around but yeah. So first this is the first sample asset. We used to have it as token. So for us it's basically the same but this is an easy way to kind of rename it and then into the fun part. So deposit here takes an amount of assets. So let's say 100 I and a receiver.
00:07:17.636 - 00:08:13.916, Speaker A: The receiver doesn't necessarily has to be the message sender in the case of you wanted to or whatever wanted to deposit for another person. But the internal deposit function does take message sender. So if we go here, which is just below like at the bottom of the contract is an internal function that takes the depositor. So the message sender is our depositor in this case which is the person that we are going to take the tokens from. There is no logic obviously to take the, let's say for you as a message sender to set a depositor into another for another address because obviously you will be kind of draining the allowance for another person. So here it's quite simple. We set some values in memory just to avoid having to re access the same storage slot over and over again.
00:08:13.916 - 00:09:27.030, Speaker A: If we do have UN 26 max which is basically try to deposit as much as possible, we do check either which is like the minimum amount between the user balance or the allowance. The user might have infinite allowance as well but the actual balance might not be obviously infinite UN 26 number or the other way around the user might have a shit ton of balance but only allow the vault to access specific amount like 100 i. If not, we will take the amount as a predefined amount by the user which might be also correct. And if it's not correct, either we have a revert here trying to transfer from a user that doesn't have allowance et cetera, or that doesn't have the actual balance. So the first thing we do is we pull the funds from the user which is from the depositor yeah, let's say correct to the phrasing here from the depositor into the vault wrapper. So we are not actually sending this directly into the vault because we require to have these funds in the vault wrapper for us to be able to call the deposit function later. This is a weird one but we need to check.
00:09:27.030 - 00:10:27.936, Speaker A: So you have two options here. One you initialize when you initialize the vault wrapper, you set allowance infinite to your vault which I think it's okay, or seconds which is kind of easier, but you are just screwing your first depositor. If you have your first depositor approved, like give the max allowance into the vault. So yeah, you probably want to be the first depositor. This might not ever run out, possibly not sure how it will run out. But there is a check for if it's not enough, you can reappro, et cetera. But should be okay to take this outside just to one, save some gas on deposits and secondly to have basically more control over the allowance from the wrapper to the vault here, we need to check if the vault wrapper has some dust in underlying.
00:10:27.936 - 00:11:07.488, Speaker A: So we check, let's say somebody mistakenly sent one die into the vault wrapper instead of doing an allowance and calling deposit. Sorry, it will mess up somewhat with the internal accounting of this function. So we check pre and post balance in the middle we call deposit. So vault deposit should be here. Vault deposit though this is in Viper, but it's pretty easily and self explanatory. You can check that as well in the urine vaults repo if you want to. We check how much tokens we have left.
00:11:07.488 - 00:11:56.132, Speaker A: So there is a possibility that the deposit doesn't really take all of no, actually no, the deposit will take all of the amount that you send. But this is done just for ability to give some gas. And then if there is anything that might be refundable, you send that back to the depositor here in the vault deposit you set the receiver. So this can be either yourself or it can be yourself, not the depositor itself or a third party that the depositor choose. Let's go back up. So for Mint is practically the same. Well, obviously the deposit function returns both the assets that it used and the new Minted shares and it emits and a deposit event for Mint is the same.
00:11:56.132 - 00:12:30.392, Speaker A: The only difference is that the user specifies the numbers of shares and for the withdrawal, which is a little bit tricky. And it really depends on kind of how and in which state you are hitting the vault. So we have a bunch of different kind of scenarios that might happen. As I said, the depositor right now or the withdrawal. Let me check what's the actual name here. Okay. The sender for some reason is the one that has the vulture token.
00:12:30.392 - 00:13:14.460, Speaker A: So remember, this sender doesn't actually so since vault wrapper is not an ERC 20, you are still interacting with the vault as it being behaving as the vault API. So that has the deposit withdrawal all transactions. But since also the vault is an ERC 20 because it has its own share, so it does the accounting of its own share, it behaves like an ERC 20. Obviously in Viper you don't have the open separate ERC 20. So probably here you have like transfer, blah blah blah. So everything is kind of implemented internally, which I've heard is more gas optimized. So shout outs to Viper and then yeah, it's basically kind of similar but the other way around.
00:13:14.460 - 00:14:00.120, Speaker A: So we do need to calculate how much available shares does the vault has, or does the user has basically to withdraw. Then we calculate depending on the PPS of the vault. So this is the price per share. Let's say you enter in a new vault, probably the PPS, or not probably, but the PPS will be one. If that vault through a strategy receives profit, the PPS will increase, if receives losses, the PPS will decrease. So on and so forth. Yeah, basically some internal accounting which if you really want to go deep into it, you can, but pretty straightforward.
00:14:00.120 - 00:14:42.868, Speaker A: Then we take the vault shared tokens from the sender into this address. So because as you remember, we need to hold these first to be able to interact with the vault. And differentiation with the deposit function is that the withdrawal function doesn't really need allowance because when you are interacting with the vault, the vault doesn't really need you to give allowance for its own token to itself because it will be dumb. So you don't need to handle that. You just hold your token so you can interact with whatever internal vault functions that you want without giving it allowance. And here we also do check pre and post balances to one. Okay, and here comes kind of the different scenarios.
00:14:42.868 - 00:15:54.940, Speaker A: So there is a possibility that when you withdraw you might not get all the amount of say underlying that you wished for one, because of the buffer we talked about, maybe you go over that and there are no other withdrawal strategies. So we have something called a withdrawal queue where we set the more EC or liquid to withdraw strategies on top. Those strategies also might not have any withdrawable liquidity or withdrawal underlying on them. So as you go into the queue, you might end up without fulfilling your full amount. Obviously, if you withdraw less, it will be possible to cover up for you full amount, but if you withdraw a shit ton of underlying, it might get trickier on the more illiquid vaults. So yeah, here we withdraw. And so we have to do some checks to know either how many actual shares were burned because obviously if you say hey, I want to withdraw 100 shares and this is also a differentiation between deposit and withdraw.
00:15:54.940 - 00:16:58.704, Speaker A: On vaults V two you deposit underlying, but when you withdraw, you withdraw with your shares. Since in the vault wrapper we are accommodating for both withdrawing, saying hey, I want to withdraw 100 Ion or I want to withdraw 100 or 99 vultures, we do accommodate for both. But here the vault V two might not really need to burn all your shares because obviously if it can only give you 50% of the estimated underlying that those shares are worth depending on the PPS. So the price per share, it will only burn 50% of your shares, obviously, because if not, we are basically ragging everybody. So you send let's say the estimated amount of shares per the amount that you kind of want to get. You specify a receiver as well and then this vault withdrawal will return you. So vaults v two call will give you how much underlying you got for those shares.
00:16:58.704 - 00:17:33.632, Speaker A: And here this is why we calculate how many shares were burnt. And if we do have any unused shares still we do return them to the sender. So that's practically it. Then we do have some obviously the same functionality with redeem. So in this case, this kind of is the more native approach or the approach that is more similar to V two. And this is the weird one which uses assets instead of shares. And on deposit is the other way around.
00:17:33.632 - 00:18:10.140, Speaker A: We usually take assets as deposit and mint is this. So this is why you see different accounting prior to calling deposit or withdraw. Then you have some asset sets here, some accounting logic. It's really simple. So you really need to know the total assets that the vault really has. This is just like proxying the call to the same function. In V two you need to know well, we went through the same EIP, so everything is practically the same here we just accumulate for the decimals and the price pressure, et cetera, et cetera.
00:18:10.140 - 00:18:57.850, Speaker A: We also have max deposit function. So all the limit function that we talked before, which might be useful for one, avoiding reverts on the UI. And secondly, and I think it's most important to also let's say integrators know the exact max amount they need to get. So probably you would call max deposit and then deposit that max amount that might be in some cases the max sorry, uint 256. Same for mint, same for withdrawal, same for redeem. Let's go into the more interesting stuff. This is kind of boring and introduction but I think it's good to know.
00:18:57.850 - 00:19:51.756, Speaker A: So I think I rewrote to do here. Let me check. Okay, so yeah, on max deposit, let's say the EIP 46 26 kind of lets you do whatever you want inside. So if you want to take fees on top of the deposits, you can, if you want to limit deposits or to block deposits for certain users, et cetera, et cetera, you also can same for withdrawal, you can add both fees on deposit. On withdrawal you can add fees depending on the amount being deposited or withdrawn or depending on the difference of the PPS increase. So let's say you don't really want to make your users lose money, but you want to take a percentage of their profit. And this might get tricky, but you can kind of save how much kind of relative PPS a depositor has and then take a percentage out of it.
00:19:51.756 - 00:20:43.404, Speaker A: So like a percentage out of their APY increase or PPS increase, let's say. A way to do this I think should be pretty easy. So you would define let's say fear receiver here that let's say it's C four address. And obviously this won't compile just for a little bit of loss. And here on deposit, you can basically rag some percentage of it. Let's say you want to do oh, sorry, this is a weird computer. So you get the token you want to do.
00:20:43.404 - 00:21:50.316, Speaker A: Let's say you want to transfer from or yeah, okay, let's do this on deposit so we can both run deposits on shares and underlying so here where we are transferring. Let's say we can do something similar. Let's copy this. Let's say we want to send from to well, but you know, you get the gist, so maybe we can do this amount. So we get a tiny percent from the user and then we do sorry amount. So we update. So it's quite easy to add different type of fee mechanisms for you to earn on top of what the depositors have.
00:21:50.316 - 00:23:02.030, Speaker A: Obviously, it's always a good practice to be transparent with your user. So if you are doing this, make them know that you are taking a small cut either on withdrawal or on deposit or if you also want to build up some more complex stuff around the PPS increase just for you not to have your users lose money on either deposit or withdrawal. Yeah, that's it. Don't know if any of you guys have any specific questions that you might want to tackle or we're good. Okay, awesome. Thank you guys. Thank Sam.
