00:00:07.130 - 00:00:34.280, Speaker A: Alright guys, thank you very much. Very happy to be here. My name is Martin, I'm from Quantstamp. We are smart Contract security auditors. So, you know, I'll be talking about best practices for smart contract development and best practices for developing smart contracts in Solidity. Specifically, the talk is aimed towards beginners. So if you're a very well versed Solidd programmer, probably you will be bored in here.
00:00:34.280 - 00:01:23.538, Speaker A: But hopefully for the rest of you, I will be able to pass some good notes. So the agenda for the talk at first I'm going to introduce Solidity as the language and EVM just so that we are on the same page of what kind of execution environment we are talking about. Then I will be talking about some specifics that Solidity as a language has over other languages. And then I will be covering the best practices those do's and do nots. So, introduction to Solidity and EVM you're at an Ethereum hackathon, right? So you probably have heard the word Ethereum virtual Machine before. Ethereum Virtual Machine is a virtual machine that is powering the Ethereum blockchain and that is powering the execution of smart contracts on Ethereum blockchain. It is a stack based machine.
00:01:23.538 - 00:02:31.014, Speaker A: And when you develop Smart contracts, pretty much what you are doing is typing some high level programming language that gets compiled to bytecode and that bytecode then eventually just contains opcodes that somehow manipulate the data on the stack. So we have Opcodes such as Add which adds two numbers on Stack. We have Opcodes such as Call that sends transactions. We have Opcodes such as Load or Write for writing and reading from the memory or storage of a smart contract and so on. Then the EVM uses something called Gas to measure how much computation was carried out and bills the users who triggered the computations for that, right? It's for a very good reason because all the miners or validators in the network will be interpreting those transactions and will be running those computations. And we don't want anybody to be running computations on our machines for free, right? So that's why Gas actually exists and the actors on Blockchain are identified by addresses. We have two types of actors.
00:02:31.014 - 00:03:09.510, Speaker A: One is the general people who transact through something that we called externally owned accounts. And then we have smart contracts. The difference between Smart Contracts and externally owned accounts is that Smart contracts do not have private keys or nobody knows what those private keys are. So Smart Contracts cannot sign or initiate transactions. Everything comes from people's own externally owned account for which we do have private keys, right? This is how we have created and generated those accounts. So this is kind of the setup that we are going to be talking about. Now, the language that we use to develop smart contracts I already mentioned is called Solidity.
00:03:09.510 - 00:04:13.114, Speaker A: So Solidity is an object oriented statically typed language. It's similar to JavaScript, Java, C or anything of this similar category, but it is specifically catered towards developing Smart contracts. So it provides us with data types that we will find on blockchain, right? Those addresses, those unsigned INTs and bytes and it will provide us with blockchain specific functionality. So for example, functions for sending and receiving ether can be controlled through primitives of this language, right? Unfortunately, compared to other languages that you might be used to, it actually has a limited standard library. So it doesn't contain whole bunch of things that I will be talking about a little bit later that you might be used to. And it also has many blockchain specific Gotchas that other languages do not really have or are not relevant in other settings. So let's take a look at something that is kind of sort of special to Solidity.
00:04:13.114 - 00:05:14.238, Speaker A: First of all, Solidity similarly to other programming languages, contains some access modifiers that allow us to indicate whether certain variables or functions should be accessible from other Smart contracts, right? So it has something called keyword private, which if you are used to developing in other languages, just signifies that external classes or external actors cannot access our data, right? So this is the first gotcha for Solidity. Anything that is marked as private really means that you cannot query it directly on chain. But it doesn't mean that that data is private. At some point it made it on Blockchain using a transaction. The transaction can be queried from the archive nodes and any participant in the world is essentially able to derive what the particular private variable currently holds as data. So even though stuff is sometimes marked as private, it's actually not truly private. Private only means that you cannot query it on chain.
00:05:14.238 - 00:06:05.890, Speaker A: It's definitely possible to learn what is in those variables. The next special thing that Solidity has over other languages is that stuff that allows us to interact with Blockchain and reference the blockchain context itself. Right? So we have context that relates to blocks. At any point, we can query these environment variables that are initialized with the block number timestamp and hash. And then we also have some environment variables that relate to the context of a transaction and message itself. So who was the initial person who sent the transaction? What was the gas price that was allowed for this particular transaction and for this given message that arrived directly to the Smart contract? Who is the sender? What is the value that is being sent along with this message? What is the call data? And so on. So this is something that we have available in Solidity.
00:06:05.890 - 00:07:17.206, Speaker A: What we do not have available in Solidity over other programming languages is floating point arithmetic and floating point numbers. That doesn't exist at all. Solidity only has integers, okay? So that comes in question when you are dividing or when you actually want to use those floating points numbers, right? So all division in Solidity will always be integer division. So one over two will result in zero and similarly and analogously other divisions will behave. And when you need to somehow have access to floating point numbers, you essentially have to simulate them, right? So what we usually do in Solidity is that we say, okay, we will work with really long numbers and past certain point all the zeros past this point will be dedicated to representing the decimal positions past the floating point, right? So that's something that is very important to remember. Whenever you work with something especially like Ether, you are always working with super long decimal numbers. So Solidity doesn't have floating point.
00:07:17.206 - 00:07:54.622, Speaker A: Another thing that Solidity doesn't have is random number generators. There is no way for you to go and say, hey, smart contract generate a random number. People really like having that functionality, right? Because we want to develop games, we want to develop lotteries, we want to develop stuff that actually has some randomness in it. But unfortunately it doesn't exist. And again, it doesn't exist for a very good reason. Because we know that the transactions that will be executed will be executed by a whole bunch of miners and validators in the internet, right? And they have to be deterministic. They have to have deterministic results so that everybody arrives to the same state of the blockchain.
00:07:54.622 - 00:08:42.718, Speaker A: So therefore, generating random numbers is not a thing in Solidity. So what people very often try to do, they actually try to exploit those environment variables that I was talking about a little bit earlier. So what is my blog hash, what is my transaction? Hash what is the current timestamp? And use that as a source of randomness. But that is not really random, right? And it is also predictable. So it's actually wrong to be using that for randomness. And if you at some point require using random numbers in your software development, what you need to do is actually use random number generators in the form of Oracles, which I will be talking about a little bit later as well. So we don't have random numbers and we need to remember that I already said that smart contracts are accounts that have some code associated with them, but they do not have private keys.
00:08:42.718 - 00:09:21.550, Speaker A: So another thing that you might want to do, but will not be able to do is schedule some transaction and have it be initiated by a smart contract that doesn't work. Smart contracts cannot initiate anything. It's always people and externally owned accounts that actually can sign and create transactions. On this particular slide I have two words that I want you to understand for the rest of the talk. So one word is called Immutable. It means that once you put something on blockchain, it stays there forever. You cannot change that and you cannot delete that.
00:09:21.550 - 00:10:08.698, Speaker A: If you work with Immutable data, it will just be there and it will not change. Even if you work with data that is not immutable. And you somehow explicitly allow for your smart contracts to change and for these pieces of information to be somehow replaced with other pieces of information, the history will still be available as well. So just the sheer fact that you've put something on blockchain that you've changed, it doesn't mean that nobody will ever be able to see what was in that variable in the past. The other thing that I want you to understand is atomic execution. So what we have on Ethereum is transactions. And those transactions are being executed in an all or nothing fashion and nothing can interrupt the execution.
00:10:08.698 - 00:10:45.260, Speaker A: So there is nothing like a processor where you would have multiple processes. And sometimes this guy gets the core, sometimes this guy gets the core and that's somehow interleaved and preempted that doesn't exist. Transaction starts running and it finishes all the way to the very end unless it reverts. If it reverts, nothing ran, it rolls back all the state. Okay? So that's the property of the runtime that we are having. So transactions are atomic. The other thing that we do not have available, and we would very often like to have available, is access to external data.
00:10:45.260 - 00:11:34.294, Speaker A: So you might want to develop a smart contract that, for example, provides entrance for delayed flights, right? And a normal Web Two developer, the way how they would think about such a system is, okay, well, I need a system that will query some API that will learn whether my flights were delayed or not, right? So sometimes developers try to stuff access to API and Internet into smart contracts. But there is no such thing. It just doesn't exist. You cannot query the Internet from smart contracts. Smart contracts are only capable of querying data that is already recorded in some other smart contracts. And so companies and the Ethereum community developed something called Oracles. Where Oracles are smart contracts designated specifically for this purpose.
00:11:34.294 - 00:12:17.742, Speaker A: They are made to record some kind of information. And then communities and external actors, they record this type of information into smart contracts. So if you want some specific data, you have to find an Oracle for it and then you can query that Oracle's API. So, this is kind of the situation that we are at with Solidity. And now I will be going through a very long laundry list of what you should be doing and what you should keep in mind when developing your smart contract. So the first thing that I want to cover is check effects interaction pattern. So you might be able to Google whole bunch of lists with best practices for developing smart contracts in Solidity.
00:12:17.742 - 00:12:48.258, Speaker A: And every single list will contain this check effect interactions. This rule specifies the order in which you should be making actions inside of your functions. So here I have a snippet of code. It has two functions. One is called bad withdraw. One is called good withdraw. Both of these functions have some state check, right, that's the require at the beginning then it applies some or they apply some changes to the state.
00:12:48.258 - 00:14:21.520, Speaker A: That's the line where I am decreasing the balance of the message sender. So in the good withdrawal that happens right after the require check and in the bad withdrawal that happens at the end of the function and what is in between in the bad withdraw is the interaction, it's the transfer of a balance that is actually making a call to the message sender, right? And that actually transfers the execution power to the message sender because when we send ether in solidity what gets invoked are some special functions in smart contracts. So in the bad withdrawal we are actually not respecting this pattern check effect interaction. That interaction should come at the very end in the order that I have it in the good withdrawal and the reason why this is really really important is a very profoundly known vulnerability called retrancy. So what can go wrong if you have effects? Sorry? If you have interactions in the middle of an execution somebody in the middle of that transfer of ETH can come and they can make another call to your function, to your bat withdrawal and this pattern is designed so that in 99.9% of cases it actually protects you from such defects. So whenever you are doing stuff, whenever you're interacting with other contracts the interaction comes always at the very end after you update the state.
00:14:21.520 - 00:15:25.650, Speaker A: The second item that I want to cover here are pull patterns and push patterns. So what people want to very often do is somehow give something to other people to other addresses and accounts on ethereum, right? So imagine that you have some treasury and the treasury wants to distribute some rewards or some NFTs or something like that. So you have two options either you actually do it actively you are the treasury and you are going to dish out the gas and you are going to pay for transfer of the asset to every single person, right? Or you can adopt the philosophy where you say you are entitled to get something from me but you have to come and you have to grab it. In such a case you will not have to pay gas for transferring the asset to every single person, right? The person came initiated transaction they are paying for the gas on their own. So we always prefer pull patterns over push patterns. The reason why we actually prefer pull patterns over push patterns is not that push patterns would be way too expensive. That's usually the secondary reason.
00:15:25.650 - 00:16:29.862, Speaker A: But the real reason is that the push pattern can actually fail because if you imagine that you are transferring ether to a smart contract, to whole bunch of smart contracts one of these smart contracts can just say no, I'm rejecting this ETH, I don't want it. I'm going to revert your transaction and if you remember my spiel about atomic transactions, that means that nobody is going to receive the ether right, because the entire transaction is going to revert and is going to be rolled back. So that's the problem with the push patterns. They have so many, so many interactions that can actually dos your system. So we prefer pull patterns over push patterns. The next thing that new developers in Solidia are very confused about is the difference between Assert and Require. So both these keywords serve the purpose of reverting a transaction if some kind of a condition is not fulfilled, but they behave differently with respect to refunding the gas to the transaction initiator.
00:16:29.862 - 00:18:01.078, Speaker A: So in the case of Assert, if you're asserting that some condition holds in Solidity, if the condition doesn't hold, your transaction will be reverted, but all the gas that was provided to this transaction will also be consumed. The invoker of the transaction will not receive anything back. On the other hand, with Require, the person who invoked the transaction will receive all the gas that is left back and that kind of drives the difference between the two functions. We use assert to make sure that some conditions, some kind of state that we are assuming holds. So if you're assuming that your system is in some particular state, you check it with assertions and if one of those assertions fails, it means that either you have some bug in your smart contract and that smart contract got to a state where it should never, never work or somebody's actually attacking you, right? They found some attack vector and they decided that they will use this attack vector to bring the smart contract to a state where it shouldn't be and shouldn't operate. And in such a case, it's actually very okay for you to burn all the remaining gas for this transaction and say fine, we are done, we are just going to revert in here, right? On the other hand, Require is used to check results where you fully expect that the result of an external call to somewhere might have failed. You called some smart contract, the smart contract was like, nah, I won't do that.
00:18:01.078 - 00:18:53.414, Speaker A: And you say yeah, this is fine, this is a perfectly fine outcome. Maybe, I don't know, I didn't provide enough tokens, I didn't have balance or your smart contract just like rejected and that's okay. So Require in the cases where we are anticipating a possible failure and just wants to say no and assert in cases where we are making sure that we are in a good state before we do anything cool, the next thing that I want to talk about are modifiers. So this is a special feature of Solidity as a language. You will not find custom modifiers somewhere in Java. You might find something similar in Swift in the form of extension. But essentially modifiers allow us to add code that will be executed before or after or both to a function.
00:18:53.414 - 00:19:44.290, Speaker A: Here I have actually an example of a modifier. I have function non reentrant where I do something and it's annotated with that word lock, right? And lock is a modifier that at the beginning acquires a lock. So it checks that the lock is oh sorry, a log checks for us that nobody else holds a lock, right? And it requires a lock. Then I have that underscore and semicolon which says execute my function and then in the end we release the lock. So those are modifiers. What people started doing is the modifiers, they are originally intended for checking stuff, right? So that would be where you do your checks in the checked effect interaction. But people actually started stuffing a lot of logic into these modifiers.
00:19:44.290 - 00:20:23.106, Speaker A: We see it very often in audits. What it results in is a spaghetti code. If you go back to your intro to programming courses and the languages that contain the Goto statement you've probably heard many many times do not ever use Goto because it just breaks the flow of the code and it results in spaghetti. Same thing happens if you start stuffing the modifiers with too much logic. The example that I have in there, this is the only acceptable example of where you can put some right logic and some side effects into a modifier. There is very little of it. It's literally three lines of code.
00:20:23.106 - 00:21:02.362, Speaker A: So that's probably roughly the maximum and the effect is not permanent, right? This modifier itself, it locks and then unlocks. So it's predictable. So do not put too much logic in your modifiers. I'm going to skip this slide because I want to get to some more interesting stuff. So for this slide only, remember, if you want your smart contracts to be able to receive ether you have two options. You either can implement function called receive or function called callback or both of them. And there is a difference when these functions get invocated.
00:21:02.362 - 00:22:23.034, Speaker A: So look it up in the documentation if you do not know the one gotcha that I am going to definitely mention in here is you can never assume that your smart contract has zero ether balance even if you do not implement these functions. So even if you say hey, my smart contract can never, never accept ether, it is absolutely possible to force sent ether using instructions called self destruct. So never make an assumption that your contract has a zero balance unless you actually check it directly in the code. Here is a slide about pragmas. So pragma declares for us what kind of version of solidity we are going to be working with and what kind of version of compiler we are going to be compiling these high level words that are very similar to English into bytecode, right? So that's that line that I have there in the example underlined we can declare pragmas in two possible ways. We can either declare a pragma that is fixed version that's right here, 0.8.15. Or we can put that like little carrot character in front of it or the greater sign, right, which allows floating pragmas, which essentially mean that I will be able to compile this code with anything that is 0.8.15
00:22:23.034 - 00:23:23.006, Speaker A: or higher. So best practice here is always lock pragmas of your smart contracts. And the reason why you should be locking the pragmas of your smart contracts is the software development lifecycle. So imagine that you are developing, right, and you're working on a big project and you are done, and then the rest of your team is not done and you are just waiting for one to two more months for the rest of the team to be done and then maybe audits to happen, right? Eventually somebody is going to come and will wants to deploy your code on Blockchain. But within that time span, those two months, three months, however long this took, it's totally possible that the compiler has changed, right, that two new versions actually came out. And so then when somebody starts deploying your smart contract, it's totally possible that they compiled it with a different version of the compiler than the version that you actually have tested it with. So the code that ends up on Blockchain is different from what you've tested and that might be wrong.
00:23:23.006 - 00:24:16.650, Speaker A: And yes, compilers do have bugs, they get fixed all the time. But the way how you should keep up with your compiler and have it be up to date is by declaring fixed pragmas and then updating them deliberately every once in a while. I'm slowly running out of time here, so let me maybe mention something about timestamps. I had a lot more slides, but we will not be able to cover that. That's fine. So using timestamps in smart contracts for any kind of logic and decision making is an anti pattern. When we were in the Ethereum proof of work situation, we would have multiple miners, right? They would be trying to solve the proof of work puzzle and at some point they would be successful and they would start propagating these blocks throughout the network through something called Gossip protocol.
00:24:16.650 - 00:25:10.666, Speaker A: Well, the Gossip protocol, it's a peer to peer communication protocol. It has some latency, right? It takes time for me to produce a blog and send it all over the world to the other side. So this network, it admitted tolerance in timestamps to roughly 15 seconds. So me as a miner, I would always be able to push that timestamps a little bit to the future, a little bit to the past, whenever it was convenient for me. Now this is no longer the case because since Ethereum transitioned to proof of stake, I am not able to do that anymore. We have a fixed interval of 12 seconds where every single block has to fall into, right? So timestamps are predetermined, but there are many chains in the world that still do not have predetermined timestamps, because they do operate on some kind of a proof of work system, and they are forks of ethereum. So never assume that timestamps are not manipulable.
00:25:10.666 - 00:25:43.480, Speaker A: And a good rule of thumb is think about also tolerance for yourself. Think about those 15 or even 30 seconds. If your smart contract can operate with 15 or 30 seconds tolerance, then your usage of timestamps is okay. If it cannot, and if you required the time that it got reported is absolutely accurate, then you are doing it wrong. Okay? So very careful about timestamps. All right, looking at the clock, 10 seconds left. I'm going to stop right here.
00:25:43.480 - 00:25:52.174, Speaker A: If you have any questions, please shoot them right now or find me or Jan sitting in the back after. Here the hackathon. We'll be happy to help.
