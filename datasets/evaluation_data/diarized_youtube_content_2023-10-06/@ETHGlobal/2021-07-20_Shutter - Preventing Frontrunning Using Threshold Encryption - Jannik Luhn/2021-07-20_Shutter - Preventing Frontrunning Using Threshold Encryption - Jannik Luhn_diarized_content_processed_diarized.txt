00:00:00.330 - 00:00:44.326, Speaker A: Hi, I'm Janigen, work for BrainBot at a project called Shutter. We try to prevent front running using threshold encryption and we've heard about this a couple of times today already, but I still want to talk about the problem a little bit to set the scene. So if you send a transaction to pretty much any blockchain today, it will not get included into the chain immediately. It will first have to travel through this dark forest, the peer to peer network, where everyone can see it. And also the miner can then try to include it only later, wait a little bit and decide to include it. Not at all, maybe. So, all in all, there's some time that passes between the transaction being sent and the transaction being included.
00:00:44.326 - 00:01:30.074, Speaker A: And during this time the transaction can be overtaken by some other transaction, by a front runner. And the front runner can see what transaction you sent and depending on using that information of your transaction, change the transaction that they sent and by using the knowledge that your transaction will come later, extract some value from you. And people don't usually like this because it reduces, they lose money, basically. And therefore we try to prevent it. And the simple way we do this is simply by encrypting it. If it's encrypted, it can still be front run. There's still time that passes between sending and inclusion, but there's no information visible for anyone.
00:01:30.074 - 00:02:37.280, Speaker A: So the front runner can't extract any information or any value from your transaction. Unfortunately, if we now end up with an encrypted transaction, the blockchain doesn't help us very much because in order to execute it, we need it in plain text. So therefore, at a later point in time we provide the decryption key, then everything is fine, the chain can decrypt it and execute the transaction. Of course, here I only showed a single transaction, but in practice there will be many transactions encrypted using the same key for the same key and then this process will repeat all the time. So after one batch of transaction is encrypted and executed, or decrypted and executed, another batch will come next. Where does the decryption key come from? It can't be the user. Unfortunately, that would be the easiest solution, but it doesn't work because it would prevent front running but it would allow the user to decide to not decrypt or not release the key.
00:02:37.280 - 00:03:47.422, Speaker A: And using that technique, they would have a free option and that would create some problems in some applications. So we need some way to make sure that this decryption key is provided in any case, whatever happens. And therefore we use threshold cryptography. So we have a set of nodes which we call keepers, because their job is to provide keys. And as long as the majority of the set is honest and not malicious or offline, then these keys will be generated and also they will be generated at the right point in time and not too early because if they would do it too early they could read the transaction and front run again. Now ideally the set is very large, the larger the better because the larger the harder it is to attack the protocol. And this has to be repeated many many times for every round.
00:03:47.422 - 00:04:45.858, Speaker A: We call these rounds epochs. They have to generate a new key. And unfortunately these protocols get very inefficient if there's many people or if you have to run many times. So therefore we collaborated with some cryptographers and together with them we developed kind of a new protocol to make this more efficient, this key generation process by having a kind of a setup phase first. So we have first traditional DKG distributed key generation phase that provides what we call the eon public key and the eon secret key shares. Eon is like this very long geological timescale. Ideally this would be we can just say it will only be run once and it will output a public key and a secret key share, one secret key share for every keeper that they will keep private and the EMP key will of course be published.
00:04:45.858 - 00:05:26.534, Speaker A: And then in the next phase we will derive from these keys, epoch keys. So for every repetition of the protocol we get a new key pair. The epoch public key can simply be derived from the eon public key. Every user can do that on their own machine. No additional communication is necessary. And for the epoch secret key shares each epoch secret key share is derived from the keeper's eon secret key share. So this one for this and so on.
00:05:26.534 - 00:06:03.890, Speaker A: And once we have published enough and once we've got enough epoch secret key share we can combine them to receive the epoch secret key. So this sounds maybe a little bit complicated, but it's actually quite easy. For the eon public key we don't need any additional communication. So it's very efficient. For the secret key we only need a single message per keeper. So for every round the protocol is very efficient. Only the Eon DKG process takes some time, but this is fine because it has to run only very seldomly.
00:06:03.890 - 00:06:53.280, Speaker A: Now, this is a very general technique that I just described in the whole process and it can be applied in many different domains. We think the most obvious one is a blockchain and in particular at the base layer of this blockchain. So this encryption and decryption process can be part of the block production mechanism itself. And this is basically the ideal system. But there's other applications too. For example, centralized institutions might also be interested in something like this because they suffer from front running too. And that's what we built so far.
00:06:53.280 - 00:08:16.710, Speaker A: We can even apply it on top of an existing blockchain. So even if the blockchain itself does not use this process, we can protect transactions from being front run. We call this on chain shutter because that shutter that runs on Ethereum on a blockchain and it's basically a set of contracts, smart contracts running on this chain where people can deposit their transactions in encrypted form and then at a later point in time they will be decrypted and sent to the target contract they specify. And if this target contract is careful and only accept transactions that came through this mechanism, then they're protected from being front run and it's running at the moment on Gurley. You can try it out we host the keepers for now and we deployed a very simple example application so you can try it out. It's a very simple message billboard so you can simply publish messages for other people to read in a front rank protected way. Kind of that's all I have.
00:08:16.710 - 00:08:21.690, Speaker A: I was probably relatively fast so maybe I saved some time me thanks for listening.
