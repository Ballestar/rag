00:00:00.650 - 00:00:33.880, Speaker A: Thank you everyone for joining today. We have Ceramic with us, joining us today, specifically Joel Torstensen, who will be presenting a workshop on primitives for dynamic data on Web Three. Thank you so much. I will let you take this over in a second, everybody. If you have questions, please feel free to put them in the chat and Joel will get to them as he goes on with his presentation. I'll hear to you now.
00:00:34.810 - 00:00:55.578, Speaker B: All right. Thanks, Catherine. Let me share my screen, get started. All right, so kind of just going to start with a few slides to give you guys an idea of what Ceramic is. So I think the screen should be showing now. Let me know if not. Yeah, Ceramic.
00:00:55.578 - 00:01:55.214, Speaker B: So Ceramic is a protocol we've been working on for a while. It came out of some insights we had while working on a previous project called Three Box. And really what Ceramic is, it provides really kind of lower level primitive for having mutable data on Web Three without having to put all the things on the blockchain. Yeah, it's basically mutable data on Web Three. And how does that work? So in Ceramic, an object is also a stream, and basically stream is a bunch of events that are linked together and then there's a processing on top of the events and then you get like a state and that's like the current state of the object. And as I kind of mentioned, you can view this as like a minimal building block for data that mutates over time. And these streams have a stream ID and they act as persistent identifiers.
00:01:55.214 - 00:02:35.386, Speaker B: And that means basically that you can always use the same stream ID to fetch the content of the current state of the stream and you will always get the latest state. And so Ceramic is a global environment for mutable data. So I can run a node on my machine and then load some stream from someone else's machine. And one of the main differences between this and blockchain is that I can trustlessly verify just one stream. I don't need to verify an entire blockchain worth of data. So this makes it kind of very decentralized and scalable. And so underneath the hood.
00:02:35.386 - 00:03:23.500, Speaker B: This is using IPFS for content, pieces of content and ethereum to anchor and get an audit trail of updates and yeah, So commits the events in the streams are originate locally. It's signed by the user and the streams themselves are made of an append only log and a few different kind of stream types are supported. So stream type basically defines the update logic and conflict resolution strategy. If there is a conflict in this append only stream of events, how do we resolve the conflict? And it's a dag data structure. So that might be like one append only log. It might be in the future. We wanted to support forking and merging back again.
00:03:23.500 - 00:04:34.450, Speaker B: Yeah, that's kind of a general overview of the primitive. So I'll jump in a little bit into kind of how it works and then soon we'll kind of jump in and get started with playing around with the CLI. So commit streams I'll talk about to the right you can see how the data structure kind of looks like. So you have Genesis commit which contains the first update you make or the creation event and then it can be anchored into a blockchain. And then basically right now Ceramic has the concept of anchor service which takes a bunch of different streams, bashes them into big merkel tree and puts the root of the merkle tree on chain so we can minimize the amount of transactions we need to make on chain. And then basically we have these signature commits so they include like a patch to the state. And so you can imagine the state is like a JSON object that mutates over time and the signature commits contains the patches to the object and then the stream kind of progresses like this as the user makes updates.
00:04:34.450 - 00:05:09.440, Speaker B: And the nice thing is I can process each stream independently. And I kind of mentioned this earlier. You can sync an individual stream. You already talked about stream processor, stream types and then checkpoint things. Yeah, I mentioned this as well periodically. It's anchored into the blockchain. And one of the reasons for this is it gives us kind of a proof of publication that this commit, like the signature commit for example, existed at a certain point in time and there's no way someone could fake that.
00:05:09.440 - 00:06:12.098, Speaker B: All right, so I'm going to talk a little bit about using Ceramic. So you can use Ceramic protocol directly and that allows us to create, read and write streams and it allows us to have full control over the data flow. So if you want to really control how your application works and how it interacts with these kind of lower level data objects you should be using Ceramic directory. We also have a kind of protocol on top of Ceramic which is called IDX which you can think of as kind of like a decentralized user table where you can store data and the data is stored with the user so the user kind of gets full control over the data. Every change that's made is actually signed by the user. And the nice thing about IDX is you can kind of semantically define the data sets that is associated with the user. So they have to include JSON schema which exactly describes the kind of data that's expected there.
00:06:12.098 - 00:07:16.390, Speaker B: And generally IDX is the best place to store user generated content. We also provide something called 380 Connect which is an interface in Ceramic. We use something called DIDs which is decentralized Identifiers. I'm not going to go deep into that now but it's basically a way to interact with a user identity and request signatures and request things to be decrypted and stuff like that. So three Ad Connect allows any blockchain wallet, really to authenticate and start reading and writing data on ceramic. And three A Connect also allows you to tie an Ethereum address to your did. So you can look up data based on an Ethereum address, but you could also tie that to other blockchain addresses like Filecoin or Cosmos or polka dot, what have you.
00:07:16.390 - 00:08:02.662, Speaker B: So it kind of really enables the data that the users have to be interoperable across the web. Three ecosystem. Yeah, so that was kind of short presentation. If you want to jump into looking at the documentation we have that at Developers Ceramic Network. And if you want to learn more about IDX, you can just go to IDX Xyc. And so before I kind of jump into the workshop itself and looking at how to use ceramic directly, I would love to answer if there's any questions on what you just heard. Hi.
00:08:02.716 - 00:09:05.740, Speaker C: JOA's case. Hey, I have a question about the anchor commit, actually about the Genesis record. So in IPFS, if I would publish an item like, let's say I use schema.org and I say Company and I say Three Box Labs and I'd be the first to do know, in IPFS it doesn't really matter because that content is just going to determine the hash enhance the address. In Ceramic, if I would do this same content twice, I'm guessing the Genesis block would look different because I'm using a different bid, I'm using a different timestamp. But what if I wanted to sort of search all the documents that have schema.org Company TreeBox Labs in it, in the content? Is there some sort of indexing that we could use for that?
00:09:06.190 - 00:10:08.480, Speaker B: Yeah, that's a really good question. So right now you could build an indexing service that listens to the gossip that happens in the ceramic network and see like, oh, this is a stream that I know about, and then load that, check if it conforms to or it has a specific schema. But obviously that might be pretty expensive and it's also subjective to the node that listens to the gossip in the network. We are working with the graph to natively index ceramic and basically it will look at the anchor commits and the anchor services can include like a Bloom filter that says like, oh, there was a stream with this specific schema that was included in this anchor batch. And so then an indexing service like the graph could look at that information and find the relevant streams and make an index based on that. I have a question.
00:10:09.810 - 00:10:31.494, Speaker D: The data is that stored on I'm guessing it's the nodes running on the ceramic network. Like on IPFS you have to pin files. Is there some sort of a pinning mechanism or for long term ensuring that the data is always sort of accessible. What's the solution for that?
00:10:31.692 - 00:11:19.394, Speaker B: Yeah, so right now if you run a ceramic node, you can pin screens. And what that means basically is that the ceramic node will the commits themselves. The ceramic node uses an IPFS node underneath so it will pin the commits on the underlying IPFS node. But the ceramic node will also keep track of any new update that comes in for that stream and keep track of what the latest date is for that stream. So we have for kind of the persistence of the commits themselves like the IPFS objects. We have a backend to make deals with filecoin to back those up. That's modular.
00:11:19.394 - 00:12:14.470, Speaker B: So that could also be plugged into an external IPFS node that's run by a third party service or it could potentially be plugged into something like Rweave. So we really want that commit persistence to be very flexible in terms of which decentralized storage solution you want to use because our weave has different properties than python. And then in terms of keeping track of the latest state and the latest updates to stream right now you actually need to run a ceramic node and have at least one ceramic node that keeps track of that. In the future we will be working on adding an incentive system that you can basically pay to keep track of your streams for you. Then that would look like some set of validators that basically work on tracking the pin streams that have been paid for. Yeah. I hope that answered your question.
00:12:14.620 - 00:12:15.462, Speaker D: Yes, it does.
00:12:15.516 - 00:12:49.182, Speaker B: Thank you. Cool. So let me jump into the example that I wanted to show. Oh shit, I stopped sharing. Give me 1 second. All right so what I'm going to be doing is basically just using the ceramic CLI to get you an idea of how you can start using these primitives and how to think about them. So the first thing we want to do is create a ceramic daemon.
00:12:49.182 - 00:13:33.710, Speaker B: And what this does is basically it will start ceramic on the testnet and it will in the background spin up an IPFS node and connect to an ethereum node. I think by default it connects to inferra if I'm not mistaken. And if you don't pass a configuration you might run into rate limiting. So you can pass like IPFS API and you can pass like ethereum configs. There's a bunch of configs you can pass to the ceramic daemon like Ethereum, RPC or other things. But yeah, right now we're just going to kind of run the vanilla. So yeah, this just starts ceramic.
00:13:33.710 - 00:14:17.786, Speaker B: See it listens on IPFS and has some config. It connects to the ceramic network and then starts the ceramic API. All right so then next what we want to do clear up here a little bit is we can use the ceramic CLI to create a tile. And I prepared here. So here we is going to create a stream in ceramic which is called tile. So Tile is basically the JSON object or JSON document on ceramic. So we can create this and as you kind of expect it just like gives you back content which you used and then you'll get a stream ID which is the kind of permanent Identifier.
00:14:17.786 - 00:15:30.710, Speaker B: So if we do Ceramic Show and this stream ID we will again see the content and we can also update this stream so let's do that. So I'm just going to copy this and add some more stuff here so description all right and we make an update. So now you can see the new state. So obviously this is just pure kind of content of the document. We can also look into the kind of underlying state of the ceramic stream so we can do Ceramic state and then okay that's not right. Copy the stream ID again and now we can look at the states. So here there's a bunch of stuff but here we can see the document type which is a tile but in kind of a binary representation.
00:15:30.710 - 00:16:42.522, Speaker B: Here we see the whole kind of state. So there's a bunch of stuff in here content is the content of the genesis right now there's some metadata and in here we see which dad is being used. So by default the Ceramic CLI provides keydid which is basically the public private key pair and unique allows basically when you create tile in ceramic it will automatically add some randomness to that. So you can create the same content multiple times and get different stream IDs which in most use cases you want, in some cases you might want to create the same and there's options for that but I'm not going to go into it right now. Then we can see that it has been signed there's like a signature status. And now we can also see that we have an anchor status that's pending. And that basically means that our node, or like our local ceramic node that we have started has made a request to an external anchor service that will eventually anchor this commit.
00:16:42.522 - 00:17:41.262, Speaker B: And here we see a log. So here we have type zero that's the Genesis commit. Here we have type one that's a signed commit or signature commit. And so yeah the log is basically all of the updates that we've seen we see here also when the anchor is scheduled for. One thing to note here is next contains kind of the state that we updated to and once the anchor is kind of executed then this kind of next state will be finalized and will become part of the main content up here. But if you do use to like ceramic show right now, that's annoying ceramic show, it will just kind of grab the latest kind of pending content here. Right? So let's see.
00:17:41.262 - 00:18:32.186, Speaker B: This is actually scheduled for that's too late. I think this anchor service runs like once every 15 minutes. So we might not be able to observe an anchor. Cool. So I see there's some question in the chat so is the signature done by an external node or the one running locally? So it's done by the local node. And so right now, the CLI here, we have the daemon, and then we have the command that executes. And in the background, this is just running an yeah, so the keys live locally with the if I'm actually now going to show you actually let me show another thing on the CLI.
00:18:32.186 - 00:19:35.170, Speaker B: So I can also do list the commits here. So I'm going to type ceramic commits and we copy the stream ID and now we can see that there are two different commits here. One is genesis commit, one is the commit ID of the kind of first signed update. So we can actually now do ceramic show and the genesis commit and then we will see what the state was before. See there's another question in the chat will it cost any ETH to anchor the stream? Practically it depends. Generally you usually configure your node to work with an external anchor service and this anchor service basically takes a bunch of updates from a bunch of different streams and makes one transaction on chain. So it's the anchor service that makes kind of the on chain transaction and pays ETH.
00:19:35.170 - 00:20:24.980, Speaker B: So on the testnet, you can use that kind of for free because it's on Robson. On the main net, you might need to engage with some service provider that does the anchoring for you. And then maybe you pay ETH to them. Maybe you pay by some contract, some kind of fiat. But it's really kind of up to the application developers to set up that agreement. So next question I see, which makes sense. Is there any decentralization on the anchor service itself? So right now there isn't but anyone could run an anchor service so there's no centralization on any one particular anchor service.
00:20:24.980 - 00:21:28.522, Speaker B: But I mentioned earlier when I was going through the slides that we are working on like an incentivized system for keeping track of the state and that will actually decentralize the anchor service as well. So that's plan but yeah, there's no lock in into a particular anchor service. So if one anchor service would be censoring you for example you could just engage with another provider. All right so now I'm just actually change directory here. So now I'm actually going to show you the HTP client that you can use in JavaScript. So the first thing we're going to do is require and just import the ceramic network HTP client which is an NPM package that you can find on NPM. So we're just going to load that.
00:21:28.522 - 00:23:16.982, Speaker B: Then we're going to do let ceramic equals new ceramic and we're just going to point this to our local node that we had here. All right so what we want to do now is basically just like load the documents so load doc equals or let doc equals ceramic load stream and we're just going to pass the stream ID we created over here's I did not do this in the right way because this returns a promise I need to wait. Call it tile. So Tile we can just do content now we see kind of the same content that we saw before and we can also do like dial metadata and we'll see like, oh, this is the owner of the data stream. Now, we could make basically we can just show that we can observe kind of updates here so we can do Tile. Actually, let's go back to here and let's make another update and just add some word here you can see we have made an update so I think if we just do kind of content here again, we'll see the old content. This is because by default we don't subscribe to updates.
00:23:16.982 - 00:24:15.920, Speaker B: I think we can do Tile Sync and await this and we should be able to look at the content and yeah, we can see the updated content. I think if I remember the API correct we can do subscribe here. So this returns a kind of observable but I wonder if we just do that we might get the content for free. Let's try again. Now I can see okay, yeah, so that I misunderstood here. So basically you need to consume this observable to get like a stream of updates that comes to the Tile. So, like, now I guess if we sync again, we'll get the content here.
00:24:15.920 - 00:26:18.210, Speaker B: All right, so I think we have five minutes left. So I would love to answer questions if any questions came up or if there's something specific people are wondering about all right, if not, I can actually try to show like a last thing but Katherine, anything else you wanted to oh, there's a good question in the chat, actually. Do you have support for JSON LD or Seaboard LD? So there's a native support one thing that you can do, however, is just like, put JSON LD content inside of a tile document in ceramic and that basically is you include the context and that's basically it. You then have JSON LD inside of a ceramic document and another thing that ceramic supports which I think it's too little time to demonstrate here but you can actually create a JSON schema. So JSON schema is basically some JSON data that defines like, a schema for other JSON data. So you can create one of these tiles that is a schema and then when you create a tile you can do like you can specify the content but you can also specify schema and the schema can be a stream ID as well. So if you created a schema first and then create a new stream you can reference the schema stream in your new stream and then Ceramic will automatically enforce that the JSON content in the schema or in the stream conforms to that schema.
00:26:18.210 - 00:26:44.060, Speaker B: So that will kind of give you more guarantees around what the data you can expect when you load a screen. This is also something that's used in IDX to kind of more semantically describe data you can expect when you're requesting data from users. All right, any other last questions, I guess, before we close?
00:26:49.330 - 00:27:29.000, Speaker A: Anything else coming up? Well, I will invite everyone who has any remaining question to simply go to the Discord and connect with the Ceramic team on Discord. This is really the best place to get in touch with them and and ask your questions as you hack along during the next few days. So thank you so much, Joel, for your presentation and for all the answers to the questions. I think that was super informative for everyone.
00:27:29.530 - 00:27:31.590, Speaker B: Cool. Yeah. Thanks, everyone, for joining.
00:27:32.250 - 00:27:33.540, Speaker A: Great. Have a great day.
