00:00:25.630 - 00:01:18.002, Speaker A: Waiting to confirm stream. Yes, looks like the stream is good. All right, welcome everybody, to the second day of week zero sessions, workshops, brainstorming, events. Today we're starting off with Balancer, which, if you're not familiar, is protocol that launched this year on Ethereum. And we have John from the team with us today and he's going to be walking us through what the protocol is, how you can use it in your hack, and some of the prizes that they will be offering for ETH online. So I will let John start his presentation and just before that, we will just hit some quick logistics things. If you haven't staked yet for the event, please make sure to do that before the kickoff on Friday.
00:01:18.002 - 00:01:53.346, Speaker A: This is the way that we make sure people are engaged and committing to finish out the event by submitting a project. Of course, you do get your stake back at the end once you submit. So don't worry about losing a significant amount of money as well as if you have any teammates who you plan to have join your team. They must apply individually. So, again, do that before the kickoff on Friday, ideally tomorrow or Thursday. I think that's it for logistics. I will let John start.
00:01:53.528 - 00:02:31.706, Speaker B: Cool, thank you. And thanks everyone for joining. My name is John and I'm a software developer at Balancer. The plan today is just to give you a quick overview of what Balancer is, what it can do, and then do a bit of a demo of how you can use one of our latest kind of features, which is smart pools. So Balancer is a protocol for programmable Liquidity. You can think of it as a generalized AMM or market maker. The building blocks of the protocol is Balancer pools, and the pools are smart contracts that hold two or more tokens.
00:02:31.706 - 00:03:14.430, Speaker B: And every token has its own weight, representing a proportion of the total pool. The feature of the pool is it is continuously and automatically rebalanced at no cost to the Liquidity providers. So you can think of it as a portfolio or an index fund. It's highly configurable, very flexible. So you can have up to eight tokens per pool. You can configure the fees to be whatever you like, and you can configure the token weights to represent what you like. One concept that you should be aware of when you're building is the idea of controlled versus finalized pools.
00:03:14.430 - 00:03:46.950, Speaker B: All pools, when they are created, are initially controlled. And this just means that you can think of it as like a private pool. The pool tokens can be reconfigured, the weights can be reconfigured, the swap fee can be reconfigured. And at this stage, only the creator of the pool can add liquidity. Any controlled pool can then be made, finalized or public. It's a one way action and it basically locks all the parameters. And it allows, at that point, anyone to add or remove liquidity.
00:03:46.950 - 00:04:42.570, Speaker B: There's different categories of users who interact with balancer pools. So if we take an example pool, the first user is a liquidity provider who provides liquidity to the pools in the form of tokens and they earn passive income from trading fees and in return, their portfolio is auto rebalanced. The rebalancing itself is basically done through economic incentives. If you imagine if the tokens are out of balance, there's a profit to be made and an arbitrager will seek to claim that profit. So they'll basically buy your token and sell it on another exchange. And in the process of doing that, they rebalance your portfolio and you earn the fee from the trader. Alternatively, there's also retail traders, traders who want to exchange tokens.
00:04:42.570 - 00:05:39.958, Speaker B: The Balancer protocol provides access to all the liquidity through the pools. So you can go to something like the Balancer Exchange to make a basic retail trade or through aggregators and in return they get low slippage and favorable rates. And finally, other smart contracts who are seeking liquidity can interact with the protocol. So there may be many pools in balancer that contain a token pair that you're interested in. For example, if you were to swap west to Dai, it's very likely that there are many pools that contain both WETH and Dai and there needs to be some way of aggregating that liquidity for the user. So we have the concept of the Smart Order router or the Sor, which is an off chain library available on NPM. And it basically finds the best orders across all the pools and provides the best price for a swap.
00:05:39.958 - 00:06:28.294, Speaker B: It returns a list of swap pools and swap amounts that you can then execute yourself and that'll bring you to the most efficient trade. And we're going to take a look at that in a bit and finally just introduce the concept of the smart pools. It's something that we've recently released. Smart pools are pools that are controlled by smart contracts instead of an externally owned account. The benefit of smart pools is that it allows liquidity providers to provide their liquidity to the pool, but it also has flexible parameters that the liquidity providers can see and be aware of. This opens up many novel use cases. So it's probably a very good thing for you guys to look up for your projects.
00:06:28.294 - 00:07:05.542, Speaker B: For example, you could have change in weights of the pools over times. You can have change in swap fees. So you could have the concept of like surge pricing. If things are very busy, you can up the the exchange fee, things like that. It's a very large and open area to build on. And just recently we've actually released a Configurable rights pool, which is a reference implementation for the smart pools. And it also has a user interface which can be used to easily set the parameters that you can change at create time.
00:07:05.542 - 00:07:07.480, Speaker B: And we're going to take a look at that now.
00:07:09.390 - 00:07:11.020, Speaker C: So let's close this.
00:07:14.910 - 00:07:51.366, Speaker B: So what we want to do is we're going to create a smart pool with the CRP template using the user interface and then we're going to write some scripts to just change some parameters programmatically. And this will demonstrate how you can interact with a smart pool using your code. And then we're going to use the Sor to find available swaps. And then finally we'll make a trade on a balancer pool directly. So the first thing that we want to do is we can go to the configurable rights pool which is the reference implementation. It's open source and available in our GitHub. It's being fully audited now.
00:07:51.366 - 00:08:26.162, Speaker B: It's got documentation within the README and within our own documents. And this initial section here is where it shows you what rights we've included as part of this reference implementation. So just to give it a quick overview and you can read more about it in the docs. It allows you to pause swap in, change swap fees, change weights, remove or add tokens, create whitelists for LPs, change the cap of the pool and you can remove all the tokens. The first thing we're going to do.
00:08:26.216 - 00:08:28.290, Speaker C: Is actually clone this repo.
00:08:34.230 - 00:08:40.050, Speaker B: Because we're going to actually compile the smart contracts and use some of the abi's to interact.
00:08:40.210 - 00:08:41.720, Speaker C: So if we just change.
00:08:44.090 - 00:08:44.646, Speaker B: While we.
00:08:44.668 - 00:08:45.800, Speaker C: Install that.
00:08:50.990 - 00:09:09.822, Speaker B: We'Re just going to wait for that to install. And while we do, we're just going to set up separate directory to write some scripts to interact. I'm just going to yarn a bit.
00:09:09.876 - 00:09:12.800, Speaker C: To set up the project.
00:09:14.150 - 00:09:57.100, Speaker B: I'm just going to add a couple of libraries that I'm going to use to start with. Just going to write it in TypeScript. It should be easy to take this kind of example and add it into any of your front end code or any kind of node package. We're going to use Ethers to interact with a Covan testnet. Everything that we've got at the moment is deployed on Covan as well as mainnet, which makes it nice for testing. I'm going to be using an environment variable just to include some keys and things. So.
00:09:58.830 - 00:10:00.220, Speaker C: Just add these.
00:10:02.310 - 00:10:03.060, Speaker D: It.
00:10:15.750 - 00:10:37.706, Speaker B: So we can see here. This is a configurable rights pool that I downloaded from Git. We've got the contracts, we've got a full range of tests, which is a good place to go and look at how you can interact with different functions. And what I'm going to do to start with is I'm just going to build this compiler so that I could.
00:10:37.728 - 00:10:40.730, Speaker C: Get access to the contract.
00:10:52.790 - 00:10:53.298, Speaker D: It.
00:10:53.384 - 00:11:16.982, Speaker B: So the first thing I'm actually going to do is I'm going to deploy a brand new ERC 20 onto Coban. The reason I'm doing this is just to show that at the moment this ERC 20 won't be included in any of the test pools on Covan. So it helps demonstrate. So at the moment all I'm doing.
00:11:17.036 - 00:11:22.090, Speaker C: Is just going to copy over an environment variable.
00:11:28.270 - 00:12:07.830, Speaker B: So, yeah, I've got an environment variable environment file that's got my infuria key to access the network. We're just importing ethers. I'm going to copy the token artifact from the compiled contracts here, which is just test ERC 20 that we use and that'll give me access to its API. And then all I'm doing is using Ethers to get a provider connect my Coban wallet instantiate. The token contract I'm going to deploy.
00:12:11.470 - 00:12:14.170, Speaker C: Let'S just call it D Token.
00:12:14.830 - 00:12:18.218, Speaker B: We're deploying it Ll. Finally, I'm minting it for my address.
00:12:18.384 - 00:12:34.896, Speaker C: So if I go ahead so this.
00:12:34.918 - 00:12:36.208, Speaker B: Is going to be the address of.
00:12:36.214 - 00:12:39.564, Speaker C: Our new token which has now been minted.
00:12:39.612 - 00:12:41.148, Speaker B: I'm just going to make a note.
00:12:41.164 - 00:12:42.770, Speaker C: Of that for later.
00:12:43.620 - 00:12:46.720, Speaker B: And if we go to Etherscan, this is my test account.
00:12:46.790 - 00:12:51.110, Speaker C: It'll probably take a little bit of search.
00:13:12.870 - 00:13:43.050, Speaker B: We can see here that it's been deployed and I've got now 1000 of the token. So the next thing I'm going to do is I'm going to set up a separate script to use the smart order router. So I'm just going to create a new file here called Sor. And the first thing I want to do is pull in the Sor library itself, which is at Balancer Labs.
00:13:43.490 - 00:13:44.240, Speaker C: Sor.
00:13:46.770 - 00:13:59.730, Speaker B: This is fully documented as well. And I'll point you to our documentation after. And I'm going to add the big number library because we're interacting in waveformat.
00:14:04.170 - 00:14:10.120, Speaker C: So just going to copy some code over.
00:14:16.170 - 00:14:47.502, Speaker B: We've deployed a bunch of test tokens on Coban that again are fully documented in the documentation. They also have faucets so you can actually claim some of the tokens, which again makes it easier for testing. You'll find that a lot of these tokens are already included in bouncer pools on Covan, which makes it nice for testing, swaps and things like that. For this demo I'm actually going to use, I'm going to set up a swap between WETH and my custom token. I'm just going to set my token.
00:14:47.566 - 00:15:08.410, Speaker C: Out address to the address of token that we got to run the script.
00:15:17.550 - 00:16:06.460, Speaker B: The first thing we're going to do is we're going to use the Sor and we're going to use a function called Get Pools Tokens and we're going to call it for Token In and Token Out. And what this actually does in the background is it uses the subgraph to find all the balancer pools that have both of these tokens within them, which at the moment should be no pools because we haven't actually deployed any pools with that token. Just to point you to the subgraph, we've got a full subgraph for Covan on mainnet and there's a whole bunch of useful data that you can pull there. We use it across our front ends. It's extremely useful and you could probably build a lot of interesting things with that data.
00:16:08.030 - 00:16:14.958, Speaker C: So we're just going to access the pools and because we expect it to.
00:16:14.964 - 00:16:15.902, Speaker B: Be zero at the moment.
00:16:15.956 - 00:16:24.960, Speaker C: We're just going to put that I'll change once we deploy our smart pool, this will say.
00:16:30.450 - 00:16:31.200, Speaker D: It.
00:16:32.450 - 00:16:34.254, Speaker B: So if we run that, we'll just.
00:16:34.312 - 00:16:36.920, Speaker C: Confirm that we see what we expect.
00:16:39.690 - 00:17:23.650, Speaker B: Okay, so we can see here that there has been no pools retrieved and we're going to change that now. So to change that, let me show you. We already have a deployed pool management interface, which is what people use at the moment to create pools to manage their liquidity, things like that. This is a beta version of the pool management interface that includes smart pools. It's very close to release and this is a kind of test version that you guys can probably have access to if we go to the smart pool section, sorry, create a pool.
00:17:24.070 - 00:17:27.670, Speaker C: We're going to choose Smart Pool and.
00:17:27.740 - 00:17:33.494, Speaker B: Here'S where I can add the assets that I want or the tokens that I want within my pool. So at the moment I'm going to.
00:17:33.532 - 00:17:43.914, Speaker C: Choose west and I'm going to choose the token address because it's not been.
00:17:43.952 - 00:17:47.498, Speaker B: Whitelisted yet, because it's just been created. I need to enter the actual address.
00:17:47.584 - 00:17:49.420, Speaker C: It comes up with the sign.
00:17:50.510 - 00:18:11.060, Speaker B: And here's where I can set the weights. So the weights, like I said previously, are fully configurable. If you want a 50 50 pool, you can just put the equal weights. Or if you are more kind of bullish on WETH or you want more exposure, you can make it a 90 ten pool. We'll just make it a 50 50.
00:18:12.390 - 00:18:16.760, Speaker C: And just add initial amount.
00:18:17.770 - 00:18:23.110, Speaker B: So when I'm first interacting with the pool with a new token, I need to give an allowance.
00:18:23.850 - 00:18:25.830, Speaker C: So I need to unlock my token.
00:18:26.650 - 00:19:09.554, Speaker B: And it's probably a good time to point out that for our front end in the pools, everything goes through the maker DS proxy. This is a way of us making it more gas efficient for users because it allows the token allowances to persist across all the pools. So instead of having to set your allowance for every single pool, you do it once on your DS proxy, which is deployed when you very first interact with the pools interface. Once you've approved one token on one pool, it is then available across all the pools. Again, the swap fee is configurable. So we'll make it quite a high swap fee.
00:19:09.602 - 00:19:10.440, Speaker C: 5%.
00:19:12.090 - 00:19:15.426, Speaker B: The smart pool itself will have its own symbol.
00:19:15.538 - 00:19:32.254, Speaker C: So we can set that to let's just call it D's, where you can.
00:19:32.292 - 00:19:43.082, Speaker B: Set what rights you want to be made flexible. And once these are made flexible as part of this, then it will be ongoing. So for this one, I think we'll.
00:19:43.146 - 00:19:48.980, Speaker C: Do pause, swapping change, Swappy change that we'll do.
00:19:51.590 - 00:19:58.246, Speaker B: And then all we have to do is hit Create. It gives you a warning to check that your balances that you've inputted are.
00:19:58.268 - 00:20:01.000, Speaker C: Going to be correct and then hit continue.
00:20:01.450 - 00:20:38.514, Speaker B: So in the background. The user interface is going to call the Configurable Rights Pool factory, which we've made available on both main net and testnet. And it's basically creating a new Configurable Rights smart contract specifically for us. While it does that, it also deploys a balancer pool that it is in control of. And while it does that, it pools the balances that we have set here from our account and inputs them into the smart pool. So we saw that the notification said.
00:20:38.552 - 00:20:56.714, Speaker C: That that had been created. So if we just go into Smart pool, just need to refresh it while we wait for the subgraph to catch up.
00:20:56.792 - 00:20:57.420, Speaker D: It.
00:21:32.870 - 00:21:35.480, Speaker C: I'm hoping this is just a subgraph issue.
00:21:45.050 - 00:21:46.406, Speaker B: While we wait for that, we'll just.
00:21:46.428 - 00:22:11.850, Speaker C: Continue a bit with the sore.
00:22:12.150 - 00:22:12.900, Speaker D: It.
00:22:16.230 - 00:22:50.540, Speaker B: Okay. Finally, sorry. So we can see here that it's been created. We can see that's our token address, which was the A seven E. So what's shown here is this is the smart pool itself and we can see it's just showing us what the weights are of what the balances are. Once you open up that for other people to add liquidity, the pool balances will change over time, but it'll always show your balance and your percentage. So at the moment, because I'm the only liquidity provider, it's got 100% share.
00:22:50.540 - 00:24:01.294, Speaker B: So we could go to the about section which then shows the rights that we set on create time. This is publicly available for everyone, so it gives people confidence that the smart pool that they're interacting with is safe and they know what can be changed. The controller address is the CRP contract that was created from the factory when we created the new Smart pool. And the Smart pool controller here is my DS proxy address, which is basically me. You can interact with the factories directly without going through the DS proxy and in that case you would be the controller, your externally owned account. And within settings we can see the rights that we set can then be changed at any point and we can even change the controller itself. So if we go back to our Sor contract now, there has been a new pool, we can rerun the Sor and this time we can see instead of returning no pools, it's actually found pools.
00:24:01.294 - 00:24:21.162, Speaker B: And so we're just going to build on that to see what the swaps would be recommended. So first thing we want to do is we want to use the Sor parse pool data function and we pass.
00:24:21.216 - 00:24:32.460, Speaker C: In the list of pools that was returned along with the token in and token out.
00:24:33.010 - 00:24:52.962, Speaker B: And that's going to parse the pool data into the correct format for the rest of the Sor to use, which is the Way balance. The subgraph is storing everything in ether balance, so it's just converting it to way and then we can use that.
00:24:53.016 - 00:24:59.206, Speaker C: To get the source swaps using the Sor Smart order function.
00:24:59.308 - 00:25:34.474, Speaker B: And this is basically the function that's going to take most of the trade data and return what we want. So we pass in the format data. The next parameter is swap type. So we've got two different kinds of swaps. We've got swap exact in and swap exact out. A swap exact in trade is when I say I want to send one WETH. The Sor will make sure that I spend only one WETH and will return the maximum amount of my token out that it can swap exact out would be the opposite.
00:25:34.474 - 00:26:19.354, Speaker B: So I could say I want ten of my token and it will tell me how much of the WETH I need to input to make that swap. The next one is the input amount. So we're just going to say format this parameter is the number of pools that we want to make a swap. So in an ideal world, we would trade against every single pool that had wealth in my token. But the more pools you interact with, the more gas it's going to cost. So there's a balance and we probably recommend between three and four pools at the moment. And this final parameter is called the cost of the output token.
00:26:19.354 - 00:26:29.298, Speaker B: It's another bit of information that can be given to the Sor to make it more efficient gas wise. And you can check out the documentation for a bit more detail on that, but for now, we're just going to.
00:26:29.304 - 00:26:31.634, Speaker C: Set that to zero so that will.
00:26:31.672 - 00:26:41.880, Speaker B: Return the swaps and we're just going to use another helper function to format that.
00:26:43.930 - 00:26:45.750, Speaker C: Into a better format.
00:26:48.190 - 00:26:49.946, Speaker B: We take the output of that which.
00:26:49.968 - 00:26:51.530, Speaker C: Is the source swaps.
00:26:54.350 - 00:27:08.814, Speaker B: Max UN, which is the max price that we're willing to pay, and the minimum amount out which we're just going to set to zero. And then finally we can use another help for function just to make things.
00:27:08.852 - 00:27:18.914, Speaker C: Easier, which is calculate total output and that just takes the swaps and the pool data.
00:27:18.952 - 00:27:29.640, Speaker B: And what this one does is for every swap that the So I recommend, it's going to calculate the amount out from that swap and just sum them all so that we know exactly what we're getting out.
00:27:31.850 - 00:27:33.794, Speaker C: Then we can see what it returns.
00:27:33.842 - 00:27:40.710, Speaker D: Here'S.
00:27:43.550 - 00:27:45.100, Speaker B: If we run this again.
00:27:49.630 - 00:27:49.946, Speaker D: So.
00:27:49.968 - 00:28:26.520, Speaker B: We can see that it's returned one swap, which is what we would expect. There's only one pool available. If there was more pools it would return a maximum of four because that's what we set. And each swap has its own information. So it's got the pool address that you want to trade against and this pool address is the actual balancer pool that contains the tokens. It's got the token in parameter which is the amount of tokens that you want to put in for that pool. It's got the token out parameter which is the price, sorry, the minimum amount out and then the max price.
00:28:26.520 - 00:28:28.346, Speaker B: So we can just take a quick.
00:28:28.368 - 00:28:30.060, Speaker C: Look at this address.
00:28:45.970 - 00:29:06.006, Speaker B: So if we go to the contract we can see here that it's a balancer pool. That's the code for the balancer pool that you can find on the GitHub and we can actually read the contract. So it's worth just showing you here. These are the tokens that we've inputted earlier and this is the controller which.
00:29:06.108 - 00:29:08.280, Speaker C: Reflects on the.
00:29:11.290 - 00:29:12.680, Speaker B: Controller here.
00:29:15.850 - 00:29:16.600, Speaker C: Okay?
00:29:18.110 - 00:29:41.274, Speaker B: So the next thing we want to show you is how we can interact with a smart contract and change some of the settings using the script, which is again something that you guys could do using a front end or even like kind of Cron job or something to change swap fees, change token weights, things like that. So we're just going to make another.
00:29:41.392 - 00:29:47.410, Speaker C: Quick okay script controller.
00:29:54.230 - 00:30:13.706, Speaker B: In this script we're actually going to toggle the swaps off and that should make it no longer public, which means that there should no longer be trades against it. So it's a way of basically switching off your balancer pool or your smart pool. So to do that, we're going to.
00:30:13.728 - 00:30:18.810, Speaker C: Take the actual configurable rights pool from the compiled contract.
00:30:23.010 - 00:30:41.106, Speaker B: And we also need for this demo, we're going to use the DS proxy because the pool was created using the interface, we need to interact with it via the DS proxy. If you're doing this directly then you.
00:30:41.128 - 00:30:43.220, Speaker C: Don'T need to go through the proxy at all.
00:30:49.850 - 00:30:52.914, Speaker B: We're going to use the same basic.
00:30:52.962 - 00:30:55.526, Speaker C: Setup using Ethers to access it.
00:30:55.628 - 00:30:59.610, Speaker B: And the first thing that's going to be different is we're going to get controller.
00:31:04.110 - 00:31:05.754, Speaker C: And this has to match the.
00:31:05.792 - 00:31:22.900, Speaker D: Controller from here's it.
00:31:24.470 - 00:31:46.194, Speaker C: So this is the actual address of the configurable rights. So instantiate this new Ethers contract controller.
00:31:46.242 - 00:31:52.934, Speaker B: Address and we're going to use the CRP artifact abi.
00:31:52.982 - 00:31:57.130, Speaker C: So this is the configurable rates pool and the provider.
00:31:59.730 - 00:32:08.830, Speaker B: And to start with, we're going to just make sure that we can read that contract and see that the public.
00:32:08.900 - 00:32:17.780, Speaker C: Swap setting is what we expect it to be, which at the moment should be true because it switched it's toggled on.
00:32:29.850 - 00:32:30.710, Speaker D: Swap.
00:32:35.130 - 00:32:40.890, Speaker B: The other thing we're going to query it for is the owner of the.
00:32:41.040 - 00:32:48.300, Speaker C: Configurable rights pool itself, which we can do get controller function.
00:33:05.780 - 00:33:08.976, Speaker B: This should match our user proxy address.
00:33:09.078 - 00:33:10.480, Speaker C: Which we saw earlier.
00:33:17.700 - 00:33:19.104, Speaker B: If we just take a very quick.
00:33:19.142 - 00:33:26.164, Speaker C: Look at the configurable rates pool itself, we can look for this is the.
00:33:26.202 - 00:33:38.330, Speaker B: Contract and we can see it's got this as public swap. So this is the first function that we're calling. These are all detailed with the documentation as well.
00:33:45.920 - 00:33:48.910, Speaker C: Let's just make sure we can run that for now.
00:33:56.720 - 00:34:11.910, Speaker B: Okay, so we can see that the public swap is returning true as we expected and we can see that the controller is the same address. So that's a good sanity check. And what we're going to do now is we're actually going to turn that off so we're going to set the.
00:34:12.520 - 00:34:15.408, Speaker C: Public swap to false.
00:34:15.584 - 00:34:48.928, Speaker B: So to do that we're just going to use a bit of a nondirect method which is using the DS proxy. So we have our proxy actions address that we use and we've got the abi colon and we're getting the interface. And to use a proxy we actually need to encode the data for the function. So we're going to use encode function data and function. We're using a set public swap and.
00:34:48.934 - 00:34:50.480, Speaker C: We'Re going to change it to false.
00:34:50.980 - 00:34:53.536, Speaker B: And then we're calling that against the.
00:34:53.558 - 00:35:00.230, Speaker C: Controller address and then we just need to do the actual proxy itself.
00:35:09.640 - 00:35:14.776, Speaker B: We can call the execute function on the proxy which is what's going to.
00:35:14.798 - 00:35:29.630, Speaker C: Actually call the code for the function.
00:35:31.040 - 00:35:32.892, Speaker B: And then we're going to just check.
00:35:33.026 - 00:35:54.710, Speaker C: That it has been set to false as we expect. Let's just output the TX hash so that we know it's doing something. Okay, so now if we run this we should actually interact this time.
00:36:00.210 - 00:36:04.278, Speaker B: Okay, so we can see that the TX hash here has set as false.
00:36:04.314 - 00:36:07.502, Speaker C: And just as our reader confirmed it as false.
00:36:07.566 - 00:36:10.322, Speaker B: But just to double check, what we can do is come back to the.
00:36:10.376 - 00:36:17.798, Speaker C: Smart pool user interface, just refresh this and go back to the settings and.
00:36:17.804 - 00:37:01.906, Speaker B: We can see here that this has changed to pause. So instead of using interface to swap it, we've just used it programmatically and you can access all the configurable rights so you can set a different swap fee, you can change your tokens, you can do all that using your own project. And then just to demonstrate that again with the sor this should now mean that it sees no more swaps available. So because it's been paused the subgraph doesn't count that or we're looking for pools that have got public swap set to true. So when we call that Sor helper function it's returning no pools. So the final thing is going to.
00:37:01.928 - 00:37:03.934, Speaker C: Show is an actual swap.
00:37:03.982 - 00:37:05.574, Speaker B: So I'm going to toggle this back.
00:37:05.612 - 00:37:26.986, Speaker C: On using interface, confirm that, just need to wait for the subgraph again and.
00:37:27.008 - 00:37:50.462, Speaker B: Then we're going to just build on our Sor quadrack to actually interact with the balancer pool and swap it. So we saw previously that sor swaps was returning the pool address. We're going to take in our normal provider with the wallet and this time we need a pool artifact. So we're going to interact with the balancer pool.
00:37:50.526 - 00:37:54.206, Speaker C: So we're going to take the compiled.
00:37:54.318 - 00:37:55.330, Speaker B: Bpool.
00:37:57.350 - 00:38:12.650, Speaker C: Copy that overload API.
00:38:13.390 - 00:38:17.062, Speaker B: And the first thing that we're going to use is from the swaps output.
00:38:17.126 - 00:38:22.606, Speaker C: Which hopefully we can see here, we're.
00:38:22.638 - 00:38:28.806, Speaker B: Going to take the very first swap because we know there's only one. And we're going to take its pool attribute, which is the address of the.
00:38:28.828 - 00:38:31.320, Speaker C: Balancer pool that we want to interact with.
00:38:33.130 - 00:38:35.100, Speaker B: And we're going to use that to.
00:38:35.470 - 00:38:54.990, Speaker C: Access the bouncer pool to sell the contract. And we'll connect to that using the wallet.
00:39:07.510 - 00:39:23.990, Speaker B: And then we need to bring in the token because we're swapping directly with the pool, there's been no pre approvals. So what we need to actually do is approve our WETH, the balancer pool to take our WETH.
00:39:24.830 - 00:39:36.090, Speaker C: So we're going to use contract that we saw earlier.
00:39:40.110 - 00:39:40.860, Speaker B: Later.
00:39:48.630 - 00:39:49.380, Speaker D: It.
00:39:53.830 - 00:39:54.770, Speaker C: Let'S just.
00:39:54.840 - 00:39:59.730, Speaker B: Do log to set it for approval.
00:40:03.910 - 00:40:13.558, Speaker C: TX equals wait token contract and it's.
00:40:13.574 - 00:40:16.634, Speaker B: Going to be the pool address. And for the moment we'll just give.
00:40:16.672 - 00:40:23.340, Speaker C: It the max approval wait.
00:40:25.630 - 00:40:43.490, Speaker B: Once that approvals through, then it means we can interact with bouncer pool. If you're ever coming up against strange reverts or errors in your code, I would say always double check that your approvals are correct. It's definitely one of the number one problems that people come up against because they just forget to do it, especially.
00:40:43.560 - 00:40:46.690, Speaker C: When they're just using code instead of an interface.
00:40:47.510 - 00:40:56.166, Speaker B: And then we're going to use the Bouncer pool function, swap Exact Amount In. So if we take a quick look.
00:40:56.188 - 00:41:02.360, Speaker C: At the documentation here, I can get around this drop time.
00:41:04.650 - 00:41:36.206, Speaker B: Within the Smart contract section under the API core Bpools, it lists all the functions that you can interact with the balancer pool. So we've got swap exact amount in, swap exact amount out, which is similar to what the sor we explained earlier. You can join and exit the pool by providing liquidity. You can join and swap at the same time. And then there's a bunch of functions you can call to get spot price, things like that. If you click on any of these, for example, swap Exact Amount and that's what we're going to use. You get more details.
00:41:36.206 - 00:41:41.822, Speaker B: So there's loads of documentation. So the first parameter is the token.
00:41:41.886 - 00:41:43.998, Speaker C: In, which is going to be web.
00:41:44.184 - 00:41:46.434, Speaker B: And then we can use the output.
00:41:46.562 - 00:41:53.350, Speaker C: From the Sor to get the token in parameter.
00:41:55.850 - 00:41:59.894, Speaker B: Which is going to be the amount of wealth we are input.
00:41:59.942 - 00:42:05.900, Speaker C: Into the swap token out and we use the token out.
00:42:06.910 - 00:42:25.570, Speaker B: So if you were doing this with a swap that had many pools or more pools than just one, you would basically do this on a loop and you would just do this for every single swap that the Sor returns. And it's a really efficient way of making a good swap.
00:42:26.470 - 00:42:27.860, Speaker C: Then let's just.
00:42:30.630 - 00:42:32.050, Speaker B: DX hash.
00:42:43.630 - 00:42:44.380, Speaker D: It.
00:42:51.470 - 00:42:54.650, Speaker C: Okay, so hopefully this will execute the trade.
00:42:58.370 - 00:43:01.230, Speaker B: So the first thing we're seeing is it's going to approve.
00:43:01.810 - 00:43:19.730, Speaker C: Hopefully this goes through and this will show us our TX hash.
00:43:24.390 - 00:43:49.280, Speaker B: Okay, so we can see that that's already gone through. And if we just take a look it's coming from my account. It's interacting with the balancer pool. It's taken the 0.1 WETH and it swapped it for the D token and it's output eight, six, seven, which you can see on the output of the Sor is exactly the amount that we expected it.
00:43:52.610 - 00:43:55.054, Speaker C: So I.
00:43:55.092 - 00:44:59.282, Speaker B: Hope that's given a kind of quick Whirlwind introduction to some of the things that we can do with the Balancer protocol, especially with our new smart controllers, I just wanted to show you a bunch of resources that you can go to for the Smart pool itself and the Configurable Rights pool in particular. There's a lot of detail in the documentation under the Smart contracts and there's also a whole section on Smart pool templates and that's given you some ideas and actually some pointers to some smart pools that have already been used. So for things like Liquidity Bootstrapping Protocol, ampleforth are using it to change the supply. Things like that can give you inspiration further down. We've got our actual hackathon section which is a good place to start. It's got some introduction and quick intro material that if you've never dealt with Balancer before, is a really good place to start. It's also got a link to our Discord, which is a good place to come.
00:44:59.282 - 00:45:46.770, Speaker B: There's a lot of community interaction, people willing to help with questions as well as like the core devs are there. We've got the hacking and testing section which will give you details about all the deployed contracts on Covan, the subgraph. We've got our Exchange app and our Pool Management app which are both available on Covan and Mainnet. And that's a good place if you want to get started hacking. Just a quick bit of information about what we're looking for when we're judging. Definitely worth a read. And then finally some ideas that the team have kind of come up with that we think would be interesting to see and that would also maybe give you some food for thought for coming up with your own ideas.
00:45:46.770 - 00:45:50.530, Speaker B: So any questions? Hopefully that helped.
00:45:52.630 - 00:46:17.210, Speaker A: Wow, super. That was really in depth. Sure some people are going to go back through and rewatch it to just get all the no, no, it was really good. This would be a good resource for anybody. Does anybody have any questions? I see Jacob has his hand up on mute.
00:46:18.370 - 00:46:38.850, Speaker E: Hi, thanks. Question on sort of just generally understanding the adjusting of weights in smart pools, do you think that could be used to avoid impermanent loss? Like if you hooked it up to a price feed and dynamically adjusted the weights in the pool, is that a way to potentially avoid those type of losses?
00:46:40.150 - 00:47:17.840, Speaker B: I think it definitely changes the spot price. That's one thing that changing the weights does do. So if you go to the blog, I don't know if you've seen our blog, it's actually linked in this hackathon resources on the front page. There's been some examples written there by our CTO about the Liquidity Bootstrapping Protocol, which is kind of similar, so as over time they adjust the weights and the price gets forced down, I don't think I feel confident enough to say that it would get rid of impermanent loss because a lot of people would say that. I don't know if that's ever possible.
00:47:18.290 - 00:47:19.040, Speaker C: But.
00:47:20.850 - 00:47:26.260, Speaker B: If you could do it, that'd be great to see and it would definitely make an interesting experiment if nothing else.
00:47:27.430 - 00:47:44.360, Speaker E: What happens to the tokens that exist in the pool when you tweak the weights? So, say maybe as an easy example you have a 50% die, 50% ETH and you switch it to 80 20. Now there's all this existing liquidity that's balanced at 50 50 does then that gets swapped to become 80 20?
00:47:44.730 - 00:48:17.326, Speaker B: Yeah, I think you definitely go and have a read of that section. In particular. In the documentation there's two different types of functions that you could use to change the weights. There's a continual adjustment which would be used in the LBP pool which you have to set like a start block and an end block and it can only change the weights very gradually. That leaves the token balances the same. So it's slowly changing the weights and slowly changing the price. But you can also call a kind of straight weight swap.
00:48:17.326 - 00:48:44.010, Speaker B: But when you call that it does actually maintain the spot price. So it will either subtract or add tokens from your balance. And it's basically so that you can't be changing the spot price when people have provided their liquidity. Otherwise you could screw people over. So it's just to give people confidence in that itself. You could do that yourself on like a private pool, but other people wouldn't be able to provide liquidity.
00:48:45.230 - 00:48:47.950, Speaker E: Can you have a private pool controlled by a contract?
00:48:49.010 - 00:49:27.786, Speaker B: A private pool? Yeah, I mean, I think that is basically what the smart contract is. Ours is just the idea of the configurable rights pool is to have like a reference implementation. The trade off between a smart pool and the flexibility is trust. So the more you make it flexible, the less likely people are to trust it and the less likely they are to provide any liquidity. So the idea between the CRP is to basically give people trust that this is an audited pool, they can see what's fully configurable and they can trust to put their liquidity in there. But yeah, you can make it as.
00:49:27.808 - 00:49:29.100, Speaker C: Flexible as you want.
00:49:29.550 - 00:49:30.522, Speaker D: Great, thanks.
00:49:30.656 - 00:49:31.580, Speaker C: No worries.
00:49:34.670 - 00:49:52.542, Speaker A: Anyone else? Let me just check YouTube. Al Hume says the documentation is really good, by the way.
00:49:52.676 - 00:50:14.306, Speaker B: Oh, great. That's good. We're definitely open to feedback or even pull requests. If anybody sees anything missing or if anybody thinks something could be added, please let us know and we'll get updated because we want to make it as good as possible. And that goes for everything. Like README things like that, tests, things like that.
00:50:14.348 - 00:50:15.658, Speaker C: So please let us know.
00:50:15.824 - 00:50:19.530, Speaker A: Did you cover the specific prizes you're offering?
00:50:20.750 - 00:50:32.880, Speaker B: No, I can't remember the details for them off the top of my head. I know we've got three different prizes. I can't remember the values. I think it's 1st 2nd. 3rd.
00:50:35.650 - 00:51:04.806, Speaker A: Yeah, I'm just going to pull up the prizes page. Or you can just if anybody has questions on prizes, just go to the Balancer Sponsor channel and I'm sure the team will be able to answer the questions there. All right, well, thank you again, John. Like I said, this was really great walkthrough of code and how people can actually use it. So I'm sure hackers, both in this session and then watching the recording, are going to really find this helpful.
00:51:04.918 - 00:51:06.700, Speaker C: Great. Thanks very much, guys.
00:51:07.630 - 00:52:00.102, Speaker A: Thank you, everybody else, for showing up and sticking around a little bit later. We do have the team formation session at 230 Eastern, so in 40 minutes, if you're signed up for that or you haven't signed up and you're still looking for a team, please make sure to attend. If for some reason you haven't gotten a calendar invite, just reach out to any of the team members and they'll give you the zoom link. And then there are two more tutorials workshops later today. There is the Intro to Reach, which is a programming language, and Textile, which is a tool for interacting with filecoin and IPFS. So if you're interested in working with either of those protocols, please make sure to RSVP and show up because they're going to be pretty awesome. And then again, more content tomorrow, more content Thursday.
00:52:00.102 - 00:52:19.746, Speaker A: And then the kickoff is Friday starting at eleven. So really packed week, but we are looking forward to anything and everything, right? We'll hopefully see you in 40 minutes, if not at some of the later sessions today, tomorrow or Thursday. Thank you again, John. Have a good day.
00:52:19.768 - 00:52:22.210, Speaker B: Everybody excited to see what you build. Bye.
00:52:22.630 - 00:52:26.030, Speaker A: Thanks. Bye.
