00:00:01.290 - 00:00:55.686, Speaker A: Everyone. I'll be talking about universal logins and design, mostly code design, it's complicated, right? So I think we are hearing like this debate scalability versus usability where oh, the blast. Alex just said you need usability but I mean, you need to scale now. And I'm here to argue the other thing that usability is as important or maybe more than scalability. And the reasons is first, in order to have a billion transactions you need a billion users or something on the order magnitude. So if you have like 10 million users, it doesn't really matter that you don't scale. But even if you do scale, I would argue that we have already a lot of good enough scalability solutions today, right? You have a lot of small things that you can do that will may not work for a billion users.
00:00:55.686 - 00:01:58.254, Speaker A: But we will allow your app to like your app to have a plasma, your app to have a side chain that will allow you to do a few thousand transactions per second. And more than that, you can't know what to solve for the future until the users get there. Right? Because we are all optimizing. The scalability is transactions per second, transactions per second. But often that's not necessarily what you want from your user, right? That's not the problem your user has. Maybe all your user wants is to have one type of transaction and that can be solved by a state channel or you can solve it in other ways, right? And so anyway, I want to talk about usability, and I think the things that we need to focus on good design is, hey, first, if you want to build something, let's try to fix a problem that wasn't created by crypto, in the sense that everyone is, let's build a new wallet. Let's build a new, easier way to trade ITER for bitcoin and et cetera.
00:01:58.254 - 00:03:43.698, Speaker A: But then first we need to focus on what is the sort of magic power you're giving to someone who is not into crypto which will convince them to get into crypto because most of the world is not into crypto already. And for that we need to do onboarding and onboarding and Onboarding because for very essential apps they will figure out, right? Like people figure out their taxes every year because otherwise someone will knock on their door but for something else it's sort of good that you have good visibility. It's important to have good design and good design is not decoration, right? The difference between that clock and that clock is not what I'm calling design. Right? That's just something you call like someone to paint something on top of it. What I like to think as design is the way that all the complexity of the clock in itself is hidden and then you get that face on top, right? If the color of that face, the skin is not that important. But the thing is there's a lot of complicated things in the back end if you want to show something simple on the front end. More than that, a good design hides option I would argue, right? Because if you're in a discussion and if a designer, your solution is let's add a user setting and then the user can decide if he wants A and B you are slowly killing your app this way, right? Just make the choice for the user and if it's very important we can talk about later adding an option.
00:03:43.698 - 00:04:39.206, Speaker A: But don't avoid taking the decision by just giving the decision to the user. Giving too many decisions to the users who make that's how you get a very bad design and the follow up on that is good design is opinionated, right? Of course you made the decision. Your decision may be wrong but the reason that users come to they come to you is that you're making a choice, right? So if there is like 100 ways in which you can trade if you want to do something where you can trade dai for ether and you want to buy a die, you can do a bunch of exchanges. You can do uniswap, you can do shapeshift and you can tell your user. Look, here is a list of 100 exchanges. Decide which one you want to use. Or you can simply say, look, here's what you want to do.
00:04:39.206 - 00:06:07.778, Speaker A: I'm going to do the exchange bit. I'm going to choose this thing because I know it's going to work better. So here's a scenario, right? Imagine a DeFi wallet or as the new kids like to say, dopefi for some reason so lending, right? And the basic DeFi wallet that I think of is basically you have a bunch of crypto assets. You can use them to lend them and you can gain interest on them or you can stake them and you can borrow something out of it, right? So that's I would say the basic thing and there's tons of like compound and Dharma maker is also doing something like building, let's say you are building a DeFi wallet, right? You can point the user look, I want to integrate all those things and you can show the user all the options and everything that's there or you can just choose something for them, right? And just look, I'm going to pick this thing that has the best compound interest and I'm going to put there, I'm going to take your money, I'm going to put it to create compound without having to ask you because that's probably what you want. And if you didn't want that you can just go to another wallet. So imagine your user has 1000 die. I would argue that the first thing I would do is just don't call it die, just call it cash or something like that and show them in dollars.
00:06:07.778 - 00:06:44.910, Speaker A: Maybe it's die but it's not important. And more than that, how do you show them that you are actually how do you show them the option of creating lending it so you can create compound interest. I would argue that the best way to do it would be to do this. Don't show them already, put that in practice and just show them only growing up. And I think this is a nice interface because it's addictive. You instantly understand what's going on and you want to put more money here. Here's a nice thing.
00:06:44.910 - 00:07:27.402, Speaker A: First of all, notice how many the orograph magnitude of the thing is very small. But you can just add another number here and the person will just look, oh, that's nice, my money going up. And you don't need to follow it block by block. You can just show them, look, I know that each block, it's 15 seconds. So that's 2 /second, so just show them already. That right? So that would be like part one of how you do a lending wallet, right? Just put the money in and the money grows. That's how I would do it.
00:07:27.402 - 00:08:33.226, Speaker A: Then there's a second part where you can use that money you have already to borrow. And there's tons of stuff, tons of ways in which you can do it, and tons of levers, and you choose a collateral rate and there's like a payback, and there's a bunch of numbers. And if, let's say you just want a very simple wallet like, you do the thing where you show how much cash the person has, you show them how much assets they have and you can do this. You could simply say you can spend up to this amount, right? The idea behind this is you could hide all that complexity and just tell them, look, you have $10,000 of assets, you have $1,000 of cash. If you go over this, we will do the whole crypto loaning loan thing and give it to you. My point is, it could be as simple as what the user is used to in your bank. That's not something for most user, for every user, but that could be enough for 80% of your users.
00:08:33.226 - 00:09:03.802, Speaker A: So here's another thing. Let's try to avoid asking for downloads, right? Why do you need to necessarily have the user have a MetaMask, right? Maybe it's just a small amount. Just manage the keys on the browser. And I think the best example of that is burner wallet, right? Where the burner wallet has such a great onboarding. Exactly. Because it doesn't ask you for, hey, install MetaMask, save this private key, generate this thing, and it's a burner thing. It's like one dollars, $2, $5.
00:09:03.802 - 00:09:51.418, Speaker A: Hey, you've lost it, that's okay, right? It's not for your life things. And the nice thing about this is that it keeps the keys locally with you. And the next thing you can do if you keep the keys is you can start avoiding asking for ITER, right? How do you do that? Magic. It's called metatransactions. And you can always try to do it. And the idea being simply is that you have a bunch of keys and let's say each tab or each transaction or each device you use has its own key and each one could be a burner wallet. But instead of storing funds here, you store funds on a contract and you interact with that contract as the key.
00:09:51.418 - 00:10:56.222, Speaker A: So you're basically using your key as an authorization token, which just says, look, I'm just basically signing a message telling a contract to do something and that contract will do something. You give it to a server or a network of relayers or maybe a single relayers and those people take that transaction, put it on the blockchain. And here's another nice thing you can avoid asking for gas. Also, I think gas is one of the most complicated parts, especially when the user converts all their eater and then they realize they don't have eater anymore, then they have to buy more eater for gas. You can try to avoid all that using Metatransactions too by paying them in tokens. Wait, how does that happen? Remember that you have the keys over here and you have the relayers. What you can do is whenever a relayer makes a transaction for the contract, the contract can pay that transaction back and they can pay in dai or any tokens that you want to create.
00:10:56.222 - 00:11:45.354, Speaker A: Which means that the user themselves, they not necessarily need to have ITER like the relayers will need ITER. But you can have whatever token you want to have. And also, let's not show them hex codes, right? I would say that give them the NS name, right? And if you want to do a link, like if you want to call an action, try giving a link. There are multiple link standards. Links are better than QR codes, but you can have links, QR codes are better than hex addresses and so on. So I think the last option you want to give your user is someone think that they need to copy paste hex addresses from one side to the other. So if you go back to our little crazy, I forgot to take off the animations.
00:11:45.354 - 00:12:56.738, Speaker A: But if you go back to our thing, basically what you have right now is we have a ENS address pointing to our contract, right? So that is the basic architecture I suggest everyone does, right, which is like every time you add an app, you have a key on your browser or your app or your machine. Use that to sign messages. Instead of signing keys, give them to a relayer or a network of relayers. Those will go to a contract which you can deploy using create two. So you have the address, you give them ENS name and then they pay back the relayers, which is I would say, a sort of complicated thing for you, especially for you to build in a hackathon. Which is why we build this little thing called universal login, right? Universal logins is an SDK that sort of takes all those architectures and gives you in a very simple, easy way. And how it could look is you can see yourself by going to example, the universal logins is basically your login into application.
00:12:56.738 - 00:13:43.666, Speaker A: Could be you just go into your app, you type a username that you want and you create it, right? You just type create and you won't need to have a metamass download or anything like that. It will just create it for you. And we do give you some tokens that allow you to do interactions with that application. And that's whenever you do an interaction here, we take some tokens out of you. And the nice thing, like I gave you those tokens, I have whatever spam mechanism I need. And then if I want to log in, I never typed a password or anything. And if I want to log in in a second device oh, here you go.
00:13:43.666 - 00:14:12.974, Speaker A: You can see a bunch of people that interacted with that. You can see it's live on example, let's say. How do you log in again, if you don't have a device? Like if you don't have a password, you can just go to your other device and type also the same name. Notice that now Bob is instead of created, says connect. There's also cover. We won't go into that. But the idea is basically you just request and you will receive the request here.
00:14:12.974 - 00:15:23.170, Speaker A: What's happening actually is that this browser has a private key. This other browser has another private key. And this request there is asking authorization for adding this guy's private key as one of the authorized keys in the address. Which is great, meaning that now you have two sort of keys storing the same funds and you can see it's the same address for any app, right? For this app here, which doesn't know anything, if you click here or click there the app, you only see that that particular address clicked on it because you could call it a personal dow or a modisig or a smart contract account. And I think that's a much nicer or easier way to do the onboarding because we are removing so many steps. So how you can play with that, right? You can go to Universalogin IO. We have a website where you can take a look.
00:15:23.170 - 00:16:57.078, Speaker A: I even created like if you go there, we have a GitHub universal login. And there's even like a universal login for hackathons where you can just use a quick and dirty boilerplate which you can try to access. You don't need to like this link you can find from here. So don't worry about it. Right? So how many minutes do I have? Okay, so I have about ten minutes, right? So try to show how it sort of works, right? Because I just wanted you to show the hackathon thing so it's like go to the universal login hackathon and you don't even need to get cloned, right? You can just use those commands here. It will create a little script app for you and then it's a simple thing here where it's like 50 lines of code. Oh, sorry, okay, I think it's yeah, I forgot it's on mirroring display and arrangement.
00:16:57.078 - 00:18:34.422, Speaker A: Mirror displays, okay, you see it now. So universal logins, the universal login hackathon, universal logins IO you will be able to there's a quick and dirty thing how to create your own react app. In a few instance. You just add a few things and then what's going to create for you is an app that sort of looks like this, right, where you can just add any username here, you register it and it's going to basically make a contract, deploy, register, ENS, and then create a device. Private key. Create a contract key and you can do a bunch of other stuff later, right? And it creates a short react app that you can use to play and start learning about it, right? So I highly recommend anyone wants to play around with ENS with that. So, questions? So I would recommend not putting that information on chain, right? And I think the best I would use for that, I think that Tree box is a good solution because TreeBox is basically a way for you to keep a database of private information for one single private key.
00:18:34.422 - 00:19:49.892, Speaker A: It's not perfectly working with universal logins because universal logins you have multiple private keys. But I think we can make it work by simply sharing the information between them because I don't think your bank information should be put on chain. It's just probably information that you trade between multiple accounts. It is a modi signature wallet. One of the cool things that we are doing is I say that we are tricking users into using a modisig because it's a contract and that contract has multiple keys and each key has different permissions. And we start by default by having like any key can do anything but you can just increase that query querying for two keys so you can confirm something with your device like your laptop on your phone. And more than that, what we actually want to do is for you to be able to give some specific permissions to keys saying, look, you go to, let's say, kickback event app and you add the kickback event key.
00:19:49.892 - 00:21:39.260, Speaker A: And then you can tell. Look, kickback event key has the right to spend up to 50 die and to do unlimited transactions that are to the kickback contract, right? So we whitelist three contracts that they can interact to and they can interact as much as they want with that contract and they can interact with Dai up to $50 per month or something like that. And once you have those permissions, you only need a single key for doing that. If you go above that, then you need a second key. First of all, I would disagree that there are not a lot of people experimenting on that. I would say that there are people trying to do game experimentations. And I would say one of the nice things about this pattern is that once you have a key that is controlled by the browser, you can do multiple signatures or you can do multiple actions without having to confirm each one of the user, right.
00:21:39.260 - 00:22:33.164, Speaker A: Your app has permissions, and once you have those permissions, you can do a bunch of transactions with the user, sign them constantly, and then only put a few things on chain. And it permits you to do stuff where you're playing the game. And you don't need to every time you do something, there's a new pop up window you have to confirm. Pop up window you have to confirm, right? Because the game interface is already the confirmation. I think that's super interesting, especially if you're using a side chain, right? Maybe your whole game is a side chain and it is controlled by a key that is stored on either your device or your browser. So I think that's very exciting. And the second part about Gamification is that because you can use internal tokens and most games already have tokens, what you can do is you do, let's say, a simple verification, some sort of verification.
00:22:33.164 - 00:23:41.596, Speaker A: You give them 100 game credits already and then you're basically charging them in game credits. Another interesting thing you can do is, since the relayer is a volunteer thing, the relayer doesn't even need tokens. You could have a schema where the relayer is just posting any transaction from a list of whitelisted addresses. And those whitelisted addresses are customers who are, let's say, subscribing via credit card, right? So you have a monthly subscription using an old thing like the credit card. And then what you do is the game will be paying your transaction fees. And the nice thing that it adds, this centralization is that since the game is online, what happens is if the company that is receiving the credit card goes bankrupt or disappears, you can replace all that by just adding another or running your own relayer and start paying your own transaction fees. I think that's it.
00:23:41.596 - 00:23:45.130, Speaker A: Any last questions? Okay, thank you.
