00:00:06.170 - 00:00:20.398, Speaker A: I am Richard Gottlieber. I'm a developer advocate at Chainlink Labs. You can see my Twitter and email there. If after this you want to reach out, chat about this presentation. Anything else? Blockchain. Not blockchain related. Whatever.
00:00:20.398 - 00:01:09.940, Speaker A: I am game to chat. Love chatting with people. Yeah. So I'm going to be talking about Chainlink and some of the really cool things that come along with Chainlink and Oracle networks. So to get going, just to make sure we're all on the same page, you all probably know this already, but smart contracts are this new thing that enable you to have cryptographically based agreements. And one of the big powerful things about smart contracts is that they enable you to have agreements that are based on truth instead of trust. And what I mean by that is traditionally agreements are based upon a third party being involved to ensure that the agreement happens.
00:01:09.940 - 00:01:47.200, Speaker A: Personally, I live in the United States. Legal system here, pretty much always ensures that agreements that are legal agreements happen. But even that pretty much kind of bothers me a little bit because I think the world would be a lot better place if everyone had access to agreements that you knew were guaranteed to go through. And that's where cryptographic agreements come in. So they are based upon cryptographic truths. And smart contracts are these agreements. They enable you to have a contract, an agreement that you know is going to work.
00:01:47.200 - 00:02:24.074, Speaker A: But along with blockchains, there comes this other thing where there is this decentralization and distributed piece as well. And in order for that to work, blockchains have this weird quirk where they need to reach consensus. They all need to agree. And yeah, I think Luke mentioned I'll do my best to answer questions. If you have any questions, toss them into the chat here. But I'm going to ask you all a question real quick and see if we can reach consensus. Can anybody, several of you hopefully tell me what one plus one is? And that was a hard question.
00:02:24.074 - 00:03:12.810, Speaker A: I'll wait for answers in the Luke's being a problem. So one plus one, normally that is what we would call a deterministic value. We can all agree normally that one plus one integers are two, right? And that's a deterministic value. It's always going to be the same. If I present you with that problem, the answer will always be the same. Now, if I were to ask, what's the temperature outside? I don't know if anybody wants to answer that, but I'm going to go ahead and predict the future, that we're going to have different answers and then we're going to have answers. Maybe some are in Fahrenheit, maybe some are in Celsius.
00:03:12.810 - 00:04:09.702, Speaker A: And it's going to depend. Like even if you ask me that question, when you ask me that question, it could depend on which thermometer outside I'm looking at, right? And those are non deterministic values. And the real world is made up of a lot of values that are nondeterministic. Temperature is one example of this. Things like generating a random number, anytime you ask somebody to give you a random number, odds are it's going to be different than another person. And that makes it very difficult to come to consensus, right? If you imagine the blockchain and all the different nodes that need to all agree on what has happened, trying to agree on something like give me a random number, it's going to be problematic. This is often referred to as the Oracle problem, bringing this non deterministic real world data into the blockchain.
00:04:09.702 - 00:04:54.122, Speaker A: And blockchains, they have all these benefits, but I kind of think of them as being like isolated in this deterministic bubble where their benefits can only exist because they live inside this bubble. So given that, and given that disconnect, that's where Chainlink comes in. So chainlink is a Oracle network and it's a distributed Oracle network. And why that is important is you could definitely set up your own Oracle. And I'll pause your questions here in just a minute once I get through kind of this, just to make sure that we're all on the same page. So you could spin up your own Oracle node. Definitely.
00:04:54.122 - 00:05:41.702, Speaker A: You could bring data into a smart contract and feed that data into blockchain. But if you remember I mentioned that one of the benefits of blockchains is that they are decentralized and that they're distributed. If you spin up your own Oracle node, you've now taken that decentralized power and essentially centralized it into that one node. That's a problem. You've introduced a single point of failure. That could mean if that one node goes down, so maybe you build in redundancy, but then you have one operator controlling that group of nodes, that's redundant. There's no guarantee that that operator is doing things in a truthful manner.
00:05:41.702 - 00:06:40.506, Speaker A: And so you again kind of lose the power of decentralization unless you have your Oracles in a decentralized network. And that's what chainlink is. So chainlink is a decentralized Oracle network that provides access to off chain data to the blockchain. So I'll pause here for just a minute if y'all have any questions so far. I see Lucas is asking what about legal considerations when you use Chainlink for gambling games? I don't know. As far as this talk goes about answering that, I think that that would be probably an it depends situation, depending on where you are and whatever the rules are and laws are around that. As far as ensuring things for gambling, like ensuring that the random numbers that are generated are actually random, chainlink can do that.
00:06:40.506 - 00:07:39.900, Speaker A: And we'll talk about that in just a moment. But I'll pause for a minute and see if anyone else has any other questions so far, or if everything is clear as mud centralized Oracle network that can bring data on chain. And that solves the one problem about bringing that data on chain. But we also have the problem of the data that's being brought on Chain being nondeterministic. And one of the solutions to this is to have a mechanism for reaching consensus within that process of bringing the data on chain. Within chainlink. One of the common use cases is bringing pricing data for different assets into smart contracts.
00:07:39.900 - 00:08:47.204, Speaker A: And as you can see, you have the node network and each node is reporting slightly different prices. Those nodes, the way that this works to kind of reach that consensus is to each node reports the value along with their signature so you know which node is reporting the value to a smart contract. That smart contract acts as an aggregator and it takes the median price in this example to ensure that there is an agreed upon value. So even though all the different values come into the contract, you can have a deterministic value based on the different values fed in because every time you look at that set of data you can get the median and then that is a deterministic value. So that's one way to deal with the issue of nondeterministic data and bring it into a deterministic bubble. That is the blockchain. This enables you to create hybrid smart contracts, which are smart contracts that have both on chain and off chain data.
00:08:47.204 - 00:10:27.566, Speaker A: And in my opinion, this kind of unlocks another world of capabilities when it comes to smart contracts. And I think that's really exciting and we'll talk about some of the things that chainlink offers in a little bit more detail next. But before we get into that, are there any questions so far? And too as I'm going through, feel free to just pop questions into the chat, too as they come up and I can read them as we go. Can you make a scoring mechanism, one to ten and nodes people say, ranks smart contract, compiles the aggregate score? I'm not sure I understand the first part of your question, Brian. So yes, if nodes are reporting different values, that's where the kind of deterministic piece would need to happen within the smart contract so that you can have those Oracles reporting their different values and then you need to I guess kind of implement, however you see it as being the proper way to implement it. The method of getting to a single answer, like a definitive answer for those different values. Does that make sense? Okay, cool.
00:10:27.566 - 00:11:26.686, Speaker A: So what does Chainlink offer currently? We offer data feeds, which as the name implies, are feeds of data to bring data on chain VRF, which is a verifiable randomness function. When I see VRF I think random numbers and then keepers, which are fast becoming probably my favorite thing that chainlink does currently because I see a ton of potential there. Keepers are essentially a way to automate smart contracts and we'll actually be looking at a demo that uses keepers here in just a little bit. So data feeds first and foremost, as name implies, like I said, it's bringing off chain data on chain. It's enabling that data to be brought on in a secure and reliable format. The reliability and security comes from the fact that, again, you have that decentralized Oracle network. The different nodes within the Oracle network are run by independent operators.
00:11:26.686 - 00:12:21.134, Speaker A: So there's not a single entity that's controlling the node network that helps increase the reliability and security of that network of Oracle nodes. So you can bring on everything from financial data, APIs from different websites. So APIs being like any sort of programmatically generated data, like weather, sports scores, you name it, there's probably an API out there for it. I think there's one for Pokemon and getting all the information about Pokemon sky's limit when it comes to that. But essentially it enables you to bring any off chain data on chain to enhance your smart contracts. If you head over to Data Chain Link, you can see the price feed data, which is one of the most popular current uses of data feeds. It's essentially asset pairs.
00:12:21.134 - 00:12:58.154, Speaker A: So in this example that you can see here, it's ETH in terms of USD, and you can see that there are different Oracles, each reporting their own separate price. And then consensus is reached on what that trusted answer is. A couple interesting things to point out here is that there are trigger parameters. So there's parameters that will cause the price to be updated. One of them is a deviation threshold. So it's going to be if the price changes a certain percentage, it'll update the price within the smart contract aggregator or if a heartbeat occurs. So every so often it depends on the price feed.
00:12:58.154 - 00:13:45.132, Speaker A: The price is just updated regardless of deviation in value. So, yeah, I don't know if there's any questions about those so far. My imagination is not that great. And so thinking about price feeds and lens protocol, I'm not sure where that would go. But that's probably why I'm not in the hackathon. I do think from a data feed standpoint, there is any API function which will allow you to call any API. And that could be very interesting.
00:13:45.132 - 00:14:40.710, Speaker A: Thinking about this hackathon and possible uses there, I will say we very much support using that and suggest using that for things like hackathons. When it comes to production projects, any API is not recommended simply because it's not distributed decentralized. You're using it as a single instance. Do all these companies pay to validate the data or are they collectively paying gas? This is an interesting question when it comes to how are these things paid for. So let me just head over to this and we'll just take a look at one of these really quick. So each of these is a node operator and they're all operated by different entities. You can kind of see who the different operators are given their logos, you might recognize a few of them.
00:14:40.710 - 00:16:00.430, Speaker A: But the node operators, so they operate their own node, they pay to operate their own node independently. And then as far as the cost of this being brought on chain, when you make any, what we like to call a state change to a blockchain that costs gas. So anytime that you were to update this trusted answer so this value is actually stored within a smart contract whenever that's updated, yes, there is a gas fee associated with it. To use this data feed is essentially free as a consumer given that reading from a blockchain has no cost associated with it. However, if you're building a project that relies on this value being here, you're kind of incentivized to ensure that the node operators are bringing that data on chain. So that's why if you look on these pages you can see some information like the price history information about the different Oracles. And then down here we have users and these users are kind of like sponsors in that they are incentivizing the node operators to have this data feed available.
00:16:00.430 - 00:16:38.932, Speaker A: Does that make sense? Cool. Sure thing. All right, so that was data feeds. Now let's talk about VRF. VRF, like I mentioned, is randomness. It's generating random numbers in a verifiable fashion. And that is really important when you need numbers that are provably random and that you can ensure are actually random.
00:16:38.932 - 00:17:36.008, Speaker A: And what I mean by actually random is when we're on the blockchain we mentioned that we need deterministic values. One way to generate a random number is to use some sort of seed that would in theory be random into a hashing function. And what that hashing function will do is it will take the input and create a hash and that hash can then be used as your random number. Now on the surface it seems like that will be totally random and it is to a degree. Let's take a look here and pretend for a minute that we're simply betting on the outcome of a coin flip. If I win the bet and I call heads or tails correctly, I win, say a million dollars, I'm incentivized to win. If I'm running a node, I can know what the function is that's generating the random number.
00:17:36.008 - 00:18:13.124, Speaker A: If it's being generated on chain in a smart contract, smart contracts are transparent. That's a very good thing. But it's also a risky thing if you're not careful. This is one instance of that. So pretend that we are using the current block hash ID as the seed to generate our random number. I can as a miner on a blockchain, choose to either mine the block with that randomness or not. So it's kind of like if we're rolling dice, I can choose.
00:18:13.124 - 00:19:08.040, Speaker A: I guess I'll go back to the coin flipping example. I can't choose the outcome of the coin, it's still random, but I can know the outcome ahead of time and choose to reflip. And then once the flip is advantageous to me, I can say, yes, that's the flip that we're going to be using for this bet. So you can't fix the random number, but you can regenerate random numbers potentially if you're a malicious actor when they're generated on chain. So that's where VRF comes in. VRF uses the node network, so the decentralized Oracle node network to generate a random number with a proof of randomness and then that number is submitted back to the chain. So there isn't a way for the random number generation to be maliciously tinkered with in the same fashion.
00:19:08.040 - 00:20:21.970, Speaker A: There are projects like Pool Together and Avagatchi that are using this pool Together uses it to pick their lottery winners, which kind of a big deal. I know in the past there's been some shenanigans about actual lotteries off chain not being honest, and then Avagatchi uses it for picking random traits within their ecosystem of NFTs. So, questions about random numbers, the last one, which is my personal favorite at the moment, and that's Keepers. Keepers are essentially in my mind like if this, then that for smart contracts. We've talked about all these benefits about smart contracts, all the things like truth based agreements, the fact that they are decentralized distributed, the transparency. One thing to know about smart contracts is, in my opinion, I like to call them unmotivated. They don't do anything by themselves.
00:20:21.970 - 00:20:56.110, Speaker A: That's where Keepers comes in. So Keepers gives you a event driven framework to execute smart contract functions. So that can be time based or based on other events. Like for example, looking back to our data feeds, the price changing. Essentially the Oracle network will monitor whatever the triggering event is that you have set up. In the case that that event happens, it will then call a function within your smart contract. We'll actually take a look at that in the demo here in just a moment.
00:20:56.110 - 00:22:06.684, Speaker A: Again, this kind of goes back to the same conversation as the Oracles and setting up your own Oracle. You could set up a computer to call your smart contracts functions, but then you're relying on a centralized source to ensure your smart contract is being executed properly and Keepers abstracts that away and kind of takes care of the DevOps type work for you in a distributed fashion. So before we get into the demo, here's a link to the code and all the links that will be in this. Do we have any questions before we dive into the demo? Can you make time based events as one time thing or is it so you could set up one time based upon different triggers? And actually I think that we can address that in the demo. I can show you that in the demo. So let's dive into the demo. This one's kind of about NFTs.
00:22:06.684 - 00:22:47.288, Speaker A: We're going to make an NFT grow from a seed to a little seedling to a full flower using Keepers. So one NFT is going to change state based on a Keeper updating it. So yeah, let's dive in to the actual code. This contract is essentially an ERC 721 contract straight from Open Zeppelin's, ERC 721 wizard with a few couple minor changes. I have an array of strings for the IPFS Uris. Essentially this is the metadata that will inform the NFT about the different traits. Attributes of the NFT.
00:22:47.288 - 00:23:24.730, Speaker A: For the seed, it looks something like this. We have the name of its current state, a description, the image and a few attributes. Both the metadata and the images are stored on IPFS distributed File system. It's pretty cool. It's the Interplanetary file system, which just sounds really cool. We have our ERC 721 with its name and its ID. And then I've added this function, Grow Flower, which essentially is going to look at the current stage of the NFT and then take it to the next one if it needs to.
00:23:24.730 - 00:23:50.324, Speaker A: So that's pretty cool. So let's make this dynamic. Let's use Keepers to do this. So as with everything chainlink related, the Docs are the best place to start. Docs chain link. They're kind of broken down by type of chain. We have EVM, chains, ethereum, Binance, Polygon, you name it.
00:23:50.324 - 00:24:25.292, Speaker A: Solana and Terra. We are going to be using Keepers. So we'll head to the Keepers bit and we'll look at making compatible contracts. Keepers requires two main functions to be added to your contract in order to make it Keeper compatible. The first is check upkeep. And to your question, Brian, this is where you would have some sort of value that would be false if it had been triggered already. So what Checkupkeep does is it says does the Keeper network need to execute the perform upkeep function on this contract? This is going to be a view function.
00:24:25.292 - 00:24:48.228, Speaker A: It's going to return data. There's no gas fee associated with check upkeep. So the Keeper's network will kind of pull to see does this contract need to be updated. If this is true, then it's going to run perform upkeep. Those two functions are what make a contract Keeper compatible. There's examples here. I like to go all the way down to the bottom.
00:24:48.228 - 00:25:31.696, Speaker A: And here's a full Keeper compatible contract that will increment a counter based on Keepers. But I like to just kind of steal the code right here and then modify it for our needs. We'll go ahead and take this code, pop it in here and you'll see this contract is based on a couple of things. It's going to be based on the timestamp of the block, the last time it was updated, and then this interval. So we don't have these two variables in our contract, so let's go ahead and add them to our contract. The first one is what was it again? It's last timestamp. So last timestamp.
00:25:31.696 - 00:26:20.592, Speaker A: And that's going to be a unit and then we also had a uint called interval. So interval is going to be how frequently we want the Keeper to run the perform upkeep function within our contract. I would like to put that N as the constructor just so that every time this contract is deployed, I could choose how frequently it updates. So we'll go ahead and take that in as a value here and then within our constructor. So the constructor runs whenever the contract is first deployed to the blockchain. Within our constructor, we'll go ahead and set those two values as well. So we'll set interval equal to the value that was passed in and we'll go ahead and set last timestamp.
00:26:20.592 - 00:27:09.596, Speaker A: So this will be the last time we checked to see if we needed to run our upkeep to block timestamp. And that will get us our current timestamp for when it's deployed. So at this point, check upkeep should be good to go. It'll tell us if upkeep is needed, if the difference between when this is running and the last time it ran is more than the interval that we want to update. Sweet. We also need to update perform upkeep to not do this, which is to increment the counter, but to grow the flower. And grow flower takes in an integer that is the ID of the NFT.
00:27:09.596 - 00:27:57.600, Speaker A: In this case, we're just going to force it to be the first NFT that's minted just for demo purposes. One other thing you may notice is this code here looks oddly similar. And that's because anytime we perform upkeep, it's kind of a best practice to ensure that you still need upkeep just on the off chance that something has changed in between and you don't actually need to perform the upkeep. So we're rechecking that we need to perform our upkeep. So at this point, we are ready to deploy this. So we'll go ahead and pick all the things here and we'll set our interval to say, 30 seconds, we'll deploy it. I'm putting this on the Mumbai the Polygon test network.
00:27:57.600 - 00:29:05.514, Speaker A: So while this is deploying, does anybody have any questions? So why not use require? I don't know that it would make a difference, really. I think this similar outcome. You could always set the state in the contract and require state to be zero. Why did I delete override? So I don't understand the robert I don't understand the you could always set state bit. Why did I delete override? Because in the example it's overriding something and when I'm using it here, I'm not overriding anything. In the example, it's a Keeper compatible interface. And so that already has these two functions and so it's overriding those functions in that interface.
00:29:05.514 - 00:29:36.374, Speaker A: And since I'm not importing that, I don't need to override them. Cool, so we'll head on over to keepers chain link. Oh, cool. Thanks Robert. Head on over to keepers chain link. So we have created our contract. We now need to create the Keeper and inform the Oracle network that, hey, there's a new upkeep that we want to be keeping track of.
00:29:36.374 - 00:30:12.990, Speaker A: So we'll do register a new upkeep. There's a few things here that you need to fill out. Email address is important because there is a balance for this. Imagine this is a bucket of link. Link is the token that the Oracle network uses, and if that were to get too low, it'll email you and say, hey, your keepers are about to stop working because you've run out of link, things like that. One other thing here is that you need to provide the address of your contract. So first you have to deploy your contract.
00:30:12.990 - 00:30:53.098, Speaker A: We did that. We'll grab the address here, and then you create the Keeper or the upkeep. So we add that in here, we register and we approve it. And while that's happening, before we can upkeep a NFT, we need to mint an NFT. So I'll go ahead and create eight R1 quick. And there's a couple of different ways to see this kind of evolve. We can look at the actual stage, which will go from zero to one to two, or we can look at the actual Uri.
00:30:53.098 - 00:31:34.090, Speaker A: Remember that's these values here and they end in kind of a different name that we can take a look at. So you'll see it's a seed here, and then finally, if OpenSea is being friendly and updating quickly, we can take a look at it here and maybe see it. Okay, it's already gone past the seed. I missed the seed on Openc because I took too long. It's more than 30 seconds had passed. If we look at our upkeep, we can see we funded the upkeep and then we performed the upkeep. So that's why it went from the seed to the little sprout.
00:31:34.090 - 00:32:31.280, Speaker A: But we did see here before that happened that it was zero. At this point, it's one, and we're at the sprout here. And in just a moment, we should see that it goes to its final stage. It may take 30 ish seconds. While we wait for that to happen, though, thinking about this hackathon, thinking about ways to maybe use something like keepers within this space, I think that anything that you think of where you want to either retire or get rid of things on a certain time frame or pull information from a smart contract on a given time frame, or have when something happens, have it trigger something else. These are all different ways that you could use keepers within your smart contracts. I know there's some conversation going on, but I don't know if anybody has any questions while we wait for this.
00:32:31.280 - 00:33:40.620, Speaker A: It should be up to date. So if we just refresh the metadata here, we should see it's currently a sprout. And then if we refresh and we refresh the page yeah, so the keepers have turned it from the seed to the sprout to the full on blooms. So just like that, like every 30 seconds it was updating the different values? I don't know, I think it's pretty neat. But yeah. What questions do we have? How do I stop other actors from calling my upkeep function? So the upkeep function you could limit it to, I believe is it where did it go? You could put a require statement in here to do that to ensure that it's only being done by the keeper network. But I would posit that anything that's within an upkeep it's going to be called on a regular basis.
00:33:40.620 - 00:34:39.670, Speaker A: And so that's why you'd want the checks in there, to ensure that that upkeep should happen. If someone wants to perform an unchanged like state change transaction for you and pay the gas fees for you, I'd say more power to them because they're paying for your smart contract to be updated, which is kind of cool. But yeah, I think that within that function you should think of it as this can be called at any time and kind of structure the logic in there accordingly. Does that make sense? Yeah. I don't know if anybody else has any questions, thoughts? How do we deploy an API? I don't have time, I already like past time. But within the docs, any API will get you that information. And it's the same level of example code here.
00:34:39.670 - 00:35:31.670, Speaker A: You can just click open and remix it'll, take you to the contract here, you can deploy it and mess with it there. When Oracle is updated, who is paying the gas? Or do the users sponsors pull money into the need? Just curious, state chains gets paid for. So the Oracle nodes, when they are actually making a state change, they are paying the gas, they are, I guess, compensated to do that. They're incentivized to do this via link token. So for example, when this upkeep ran, it costs a little bit of link. The amount of link it costs will be dependent on which network we're running on. This is on polygon, so it's not a lot of link.
00:35:31.670 - 00:35:57.564, Speaker A: But yeah, that's kind of how they're incentivized to do this work is through the link token stuff. Everyone continue this conversation. Discord. Yes, on discord would great, cool. I think we're good. Right on everyone, thanks for asking such inquisitive questions there. And thanks Richard for going deep to answer all of them.
00:35:57.564 - 00:35:59.960, Speaker A: That's been super helpful. This has been an incredible presentation.
