00:00:06.250 - 00:00:30.120, Speaker A: Hello. ETH global paris. Hackers. Today we will be talking about how you can augment your hackathon projects with tools developed by the Ethereum Foundation's privacy and scalability Explorations team. My name is Jack Gilcrest. I'm a former PSE grantee and I'm focused on applying zero knowledge cryptography to shield data and scale decentralized systems. Let's get into it.
00:00:30.120 - 00:01:19.714, Speaker A: PSE is a multidisciplinary team supported by the Ethereum Foundation. PSE's mandate is to conduct open source research and development on applications of cryptography like zero knowledge. Zero knowledge is a powerful privacy preserving tool. However, as you may know from ZK rollups, a consequence of ZK proofs is compressing the cost of verifying code execution. Thus, as the name suggests, the Privacy and Scalability Explorations team is focused on integrating ZK primitives that augment both privacy and scalability of decentralized applications. First, we'll run through a quick primer of the theoretical use case of zero knowledge proofs. Next, we'll go through four of the most exciting projects.
00:01:19.714 - 00:02:08.470, Speaker A: PSE is incubating, Semifore UniRep, rate limiting, nullifier, and end to end Zkedsa all offer novel tools that you can extend to hack on projects with superior privacy preservation. So let's start by talking about the basics of zero knowledge proofs. Now, there are two sides to a zero knowledge proof. There is a prover and there is a Verifier. The prover is often a client user at their computer. But this could just as easily be a server that wants to convince a client or some other server that a computation was done correctly. And the Verifier could also be another client, could be a centralized server, or it could even be a smart contract.
00:02:08.470 - 00:03:16.250, Speaker A: And generally the PSE applications that we will demonstrate in future slides have a user that will generate a proof and settle those proofs on a blockchain using a Verifier smart contract. Breaking down these perspectives a bit more, let's take a look at a simple example. We as approver want to prove that A times B equals C. Now A and C are values that should be publicly known and B is a value that is known only to us, the prover. And we want to build a proof that we know some value B that will cause the equation A times B to equal C. And we want to do this without revealing B. Now, as the Verifier, we have a verifying key which can take a proof and these public inputs and outputs to determine the veracity of the proof and notice that we don't actually need to know B as the Verifier.
00:03:16.250 - 00:04:18.240, Speaker A: The zero knowledge proof with the public values, the input and the output is sufficient to convince us that the prover knows the value of B that satisfies our computation. Now, A times B equals C is a pretty simple example and obviously it's very easy to reverse that. But you could substitute the private value for the pre image and the public value for a commitment or a hash and use a very similar expression to convince a Verifier that some public value is the decipher text for a secret value that we don't want to reveal. And this becomes a lot more useful. And we'll see some of this in the next demos in a couple of slides. Let's review the order of operations for using zero knowledge proofs. First, the prover gets the public and private inputs that they need to make some expression like A times B equals C.
00:04:18.240 - 00:05:14.290, Speaker A: The prover generates a zero knowledge proof that demonstrates the integrity of that statement. Second, the prover transmits the zero knowledge proof to the Verifier along with those public inputs only. In the case of our smart contract Verifier, this would take the form of sending a transaction to an RPC for the EVM to then verify. Finally, the Verifier uses the supplied public inputs to check that a proof is valid, returning either true or false. Here is a succinct version of that. There's a lot that is not covered. Here we glossed over how the prover uses a zero knowledge circuit to compute a proof and how the Verifier needs to use a verifying key to check the proof.
00:05:14.290 - 00:06:12.200, Speaker A: We skipped the math that makes zero knowledge possible, and all of the cryptographic primitives that one might use inside of a circuit to build effective tools. We skipped the trusted setup ceremony, which is required in almost all proving schemes, as well as talking about why they're even needed. We skipped over the different proving schemes themselves. And there's also the difference between Snarks and Starks not covered. Similarly, we didn't introduce the various ways that one can create a zero knowledge proof, including domain specific languages, software development kits, and virtual machines. This is just a taste of what goes into zero knowledge proofing, but hopefully you've gotten the gist of what a zero knowledge proof is and how to use it in theory. Let's now talk about some of the applications PSE has been working on that you could build applications on top of.
00:06:12.200 - 00:06:54.660, Speaker A: Semaphore is a gadget for preserving private identities within a public group. The private identities can prove membership within the group, then publicly send signals without revealing these individual identities. Signals are arbitrary actions such as votes, endorsements or plain text messages, to name a couple of possible examples. Semaphore is a fundamental primitive with wide reaching applications. In fact, we will see with the Ron application in the next few slides. It actually builds on top of the Semaphore gadget. There are many other examples of uses as well.
00:06:54.660 - 00:07:52.150, Speaker A: Haynoun is a private message room where nouns NFT holders can voice their opinions on proposals without reputational bias. There's also WorldCoin, which has a Semaphore group of verified humans, and proving membership in the WorldCoin group is a mechanism for proof of humanity. You could even imagine a Semaphore for individuals employed in a large company or government organization for the purpose of whistleblowing. A whistleblower could provide strong evidence that they're an employee of, say, Evil Corp with their identity shielded from retribution when they step forward. To start, let's look at the creation of a new Semaphore identity. We can randomly generate an identity, as is shown here or we could provide a secret seed value to deterministically build the identity. Secret values.
00:07:52.150 - 00:08:43.670, Speaker A: The identity at its core is comprised of trapdoor and the nullifier. For a given signal there's a public external nullifier and this is hashed together with an identity nullifier. This is used then to prevent an identity from sending multiple signals. It literally nullifies the identity from further actions. The identity trap door simply provides a blinding factor that makes it impossible for an attacker to link signals back to an identity. Even if they managed to brute force a nullifier hash, they would only obtain the nullifier and would not be able to actually figure out the identity commitment. Together, the hash of the identity nullifier and the trap door make the identity commitment.
00:08:43.670 - 00:09:48.780, Speaker A: The identity commitment, which is a public value, is inserted into a merkel tree that represents our Semaphore group. Now, given that we've taken the nullifier and the trapdoor and committed them into the Semaphore group, we can now use merkel inclusion proofs to leverage our group identity. A signal is an arbitrary message. It could be a yes or no vote or it could be some random text or really anything else that you could find a use for. Now, as we mentioned, there's an external nullifier and this is used to prevent double signaling for any topic. We only want an identity to send a single signal and we can enforce this by publicly adding the external nullifier into our proof. The hash of the external nullifier and the identity nullifier is going to be deterministic and we can prevent double signaling when an already seen nullifier hash is presented again.
00:09:48.780 - 00:10:56.100, Speaker A: Finally, we see the process of actually generating a zero knowledge proof using the Circom DSL in JavaScript and this proof is generated via full proof. And we could take this proof and we could put it on chain using the Semaphore contract or we could locally verify it as is demonstrated below. Next, we have UniRep. UniRep is a protocol for private and non reputable reputation applications which are known as a testers assign positive or negative reputation and by using a common set of proofs, reputation can even interoperate across different applications. Reputation is a widely used mechanic across applications. For instance, take gig economy and contracting apps like Uber, DoorDash, Airbnb and even Upwork. These types of applications which coordinate service suppliers with consumers, require a reputation system to properly function.
00:10:56.100 - 00:11:57.010, Speaker A: Social media apps are also ripe for integration. Applications like Four Chan quickly become overrun with unsavory content. But what if there was a way for anonymous communities to target users posting undesirable content and exclude them from certain communities using reputation range proofs? This is just one way you could use the anonymous reputation mechanic that UniRep provides in anonymous social media. Though there are many other ways to explore how UniRep can be used. Like a blockchain, UniRep state changes occur over epochs. Epochs are configurable by the application or in this case the tester, meaning that you can set the epoch length to be an hour or a day or anything else depending on the use case. Once a user is signed up, epoch keys serve as temporary pseudonyms that are publicly available for each of the epochs.
00:11:57.010 - 00:13:01.182, Speaker A: A user can have multiple epoch keys in a given epoch and use the nonce to specify each key. Here we see the generation of an epoch key for a given epoch, a tester and identity as well as the nonce. Next epoch keys are supplied to an application server, generally a relay which can attest to data for a given epoch key for the application. The Attester. Primarily this is used to drive the numerical reputation scores. However, there's also field the replacement field which can hold arbitrary data and this can be completely replaced at any given point during an attestation. Once an attestation has been made for a given epoch, a user can call the user state transition both as a proof and then a contract call which is used to prove that for a given epoch the state transitioned from one value to another for the user.
00:13:01.182 - 00:13:57.690, Speaker A: And this can be both the reputational score which is numerical and can go up and down additively, or it could be a replacement of data. Once user state has transitioned, users can generate proofs that their reputation is in a given range. So a user could have reputation of five and want to prove that they have at least reputation of three and this could be used to gate certain activities. But this can be done without revealing the exact amount. There's a lot more to UniRep and you can look into some of the existing integrations or you can look at create UniRep app. There's a lot in the documentation and the GitHub repo but there's definitely more to explore and understand. Overall, UniRep is a very strong way to deal with reputation in a private and trustless way and there's a lot of different use cases that you can explore.
00:13:57.690 - 00:14:47.930, Speaker A: Now we have rate limiting nullifier. RLN is a novel mechanic for spam and DDoS prevention by using Shamir's secret sharing. Clients submit shares of keys with their messages during a given period of time. If too many messages are received in that period, the secret can then be reconstructed and the offending message sender can be penalized by slashing financial stake or revealing reputational identity. As a side note, perhaps this could even be combined with UniRep's reputation. This has wide ranging use cases in infrastructure. Of course, chat applications are susceptible to spam and centralized services like Discord or Telegram have message rate limiting features.
00:14:47.930 - 00:15:40.810, Speaker A: RLN provides a mechanic for such rate limiting to be done in a trustless and anonymous manner. You could similarly envision such functionality being quite useful at the blockchain infrastructure layer. RPCs are susceptible to spam, and a network could protect itself from denial of service attacks by requiring the use of RLN across communication mediums. Like UniRep, RLN is built on top of Semaphore to provide anonymous identities within a group. Here, the initial RLN JS object is constructed and builds its own Semaphore identity. However, you could supply an existing one should you desire. The RLN identity must be added to the Semaphore group, just as with Vanilla Semaphore to leverage signaling via inclusion proofs.
00:15:40.810 - 00:16:34.990, Speaker A: Once an identity is inside the group, you can begin sending messages. These messages are again sent with signaling proofs. These proofs are added to the RLN cache, and this cache is responsible for tracking messages per epoch. The circuit computes this equation y equals a zero plus x times a one. When making an RLN proof, users supply two secret shares, x and y. The user hashes the Semaphore nullifier and trap door to get a zero, then hashes a zero with the signaling external nullifier to get a one. If more than one pair of the XY shares are used to send messages with the same external nullifier, anyone can derive the value of a zero risking their identity to be revealed.
00:16:34.990 - 00:17:34.330, Speaker A: Thus, as the cache stores these messages, if multiple messages from the same identity are received, it can compute the secret value needed to target and slash the offending identity. Lastly, we have EndToEnd ZK ECDSA. EndToEnd ZK ECDSA Verifies Ethereum accounts directly and shields them in privacy sets. Now, it may seem that e to Ezk ECDSA is similar to Semaphore in its use case, and in theory this is true. However, Semaphore creates a new identity with new secrets that a user must manage. This is beneficial for certain use cases, given that the cryptography is optimized for the efficiency in circuits. However, many use cases may be built on top of Ethereum addresses or any SCCP.
00:17:34.330 - 00:18:13.450, Speaker A: Two hundred and fifty six k, one key pair. For that matter, EndToEnd Zkedsa is uniquely secure in this case. There's no need for users to manage new secrets. Instead, we can rely on MetaMask or even hardware wallets. Further, we can shield public analytics from linking onchain actions to the addresses that are permissioned to authorize them. While SilverFor might be a better tool for offchain solutions, EndToEnd Zkecdsa is uniquely qualified for onchain privacy sets. This includes private airdrops and even confidential governance.
00:18:13.450 - 00:22:27.690, Speaker A: In fact, we've seen this pattern pursued in the nonstyle private voting R D, where Zkecdsa verification paired with storage proofs provide especially powerful and trustless private voting solutions. Let's start by looking at the actual proof composition in EndToEnd Zkecdsa. As a precursor we need to import the dependencies for EndToEnd Zkecdsa proving we need to supply the addresses that will actually be used in the Privacy Set and we need to instantiate our proving artifacts next, we want to build a merkel tree of all the addresses in the Privacy Set by supplying the addresses we had in the last slide this incremental merkel tree object handles the insertion of the leaves into the tree we're going to prove that the first address is a member of our Privacy Set so we go ahead and generate a merkel proof of inclusion for that leaf we can use an arbitrary message for the membership circuit the important part is that we can verify that a signature on that message is from an address that we want to prove inclusion for we do that with the private key here now we compute the proof the witness contains all of the data that our circuit constrains and is given to the proving key to generate our proof it's a little out of bounds of what we need to go into but just for some context now the membership circuit itself needs our message it needs the vector commitment of the merkel proof which is the path elements, path indices and the merkel tree root it needs the public key that we're proving is included in the merkel tree and finally it needs the signature that is made by this public key with the R and S elements the circuit will verify that we are authorized to prove inclusion of an address by checking that we supplied a valid signature for that address once the circuit has been convinced of the authority of the address it uses the merkel proof to check inclusion in the Privacy Set through these steps we're able to demonstrate that we control an address in the Privacy Set without revealing which address it is we finally can check at least using a mock prover in this case that the proof is valid EndToEnd Zkedsa demonstrates this use case with the Anonclub product there are repository ships with a CLI that we can use to run a production grade Privacy Set membership proof in this case we'll prove that we control an address that is in the set of holders of some ERC 20 token we can prompt the CLI to retrieve all of this information for us and it will automatically inject it into our proof as with the test case, we can supply an arbitrary message we also need to supply the signature by the address we want to prove membership for on that message the CLI has a proving server running in a separate terminal and this will submit the private and public inputs to generate the proof as the output shows, this computation is expensive and takes some time to generate but soon enough our proof is ready with that proof we can privately demonstrate our address is in the set of holders of more than 1000 of this ERC. 20 token and that's it. PS See has a discord where each of these projects live, so you'll find ample support for integrating with these projects here or just for general questions on hacking with the ZK stack. So definitely go ahead and join. Thanks for listening.
00:22:27.690 - 00:22:34.650, Speaker A: I hope this has been informative and helps you win some of the prizes available for hacking with these projects and other ZK solutions.
