00:00:08.760 - 00:00:52.488, Speaker A: Okay, so Enigma is a privacy layer for Ethereum. What it does is that it enables decentralized application to compute over encrypted data and we'll go into the details exactly how it works. We use trusted execution environments to accomplish this and can compute on our we can perform arbitrary computation. So it's slightly different from things like zero knowledge proofs. This is an overview of the network itself. I'm just going to go over this very fast. Victor already presented this in the morning.
00:00:52.488 - 00:02:03.504, Speaker A: But ultimately the way it works is that we've created some client libraries that can be used in an application. For example, a Gui application web application, where inputs of a particular computation can be encrypted locally. Then those inputs are sent into the Enigma network, a network of workers see here in the middle to run in a secret contract. So suppose you have a secret contract for coin mixing and you're trying to send your address, the address you want to send your coins to. Then you would have a pre deployed coin mixing contract. You will encrypt your address and then locally, and then you would send that to the Yuma network and a worker of one or many workers on the network will perform the computation of the function that you're calling for, the coin mixing. Once the computation is done, the encrypted input will go back to you as the caller and you're free to decrypt it with your key.
00:02:03.504 - 00:02:41.630, Speaker A: Nobody else can access them. And optionally, a secret contract function, which is our smart contract, can call an Ethereum function. And you might do that if you want to, after a secret computation, publish some aggregate, for example. So you can do that. This is kind of how it works protocol in general. Now, coin mixing coin mixing is sort of the first application that we're doing live with that we're building. Welcome.
00:02:41.630 - 00:03:32.940, Speaker A: And the reason why we're focusing on this application is it's a great fit for our network. And we see that there's a problem right now with Ethereum transactions being public. Of course, when you transact with Ethereum, use your wallet, which is pseudonymous. But there are more and more Ethereum DApps. And some of these DApps, I don't know, have KYCs and other things that de anonymize you. And presumably, if you de anonymize yourself once, someone can easily analyze your chain and see who you are everywhere, that's no good. So the solution is to the easiest solution, the one that we're focusing on today, would be to mix coins to hide user history.
00:03:32.940 - 00:04:32.240, Speaker A: So essentially the idea is that you would take your coins and you would send them to another address that is fresh, that cannot be repeated. Now, there are currently some coin mixing solutions even in the Ethereum ecosystem. There's been some bitcoin coin mixing solutions for a while, but there are problems with it. First of all, they are centralized mixers, but they don't have a great reputation. You could easily see how they could be honeypot like you mix your coins in these centralized servers. These servers could easily know who you are when they have a huge leverage against you. There are some decentralized mixers that are being built right now and released, but a lot of it have problems, especially the ones around zero knowledge proof tend to be expensive and a bit more cumbersome.
00:04:32.240 - 00:05:37.264, Speaker A: I think we're going to go to some of these specifically later in the presentation and especially with these mixers. Also they may not be secure. So I don't know if any of you guys are familiar with zero knowledge proof based mixers, but the way it works is you make a deposit and then after making that deposit, you receive a note and that note certifies that you've made a deposit for a certain amount. But then whoever has that note, whether it's you or someone else, can withdraw that amount. So essentially you have to keep that note safe. Otherwise it's basically a blank check to anyone to withdraw that amount. And you have to do this withdrawal transaction where if you're trying to send your coins to a brand new wallet that hasn't been touched, just created, then you have this Genesis problem where you have to have eat in this wallet first to pay for the gas of withdrawing those coins.
00:05:37.264 - 00:06:15.520, Speaker A: So you would need to have maybe some coins that you bought from a guy in person or that you mixed before. It's complicated. And of course these mixers are finding some workarounds for this, including say using your relayer. But the way that they use this relayer makes it possible for this relayer to de anonymize yourself unless you're sitting behind Tor and your DNS is well hidden. So it creates a pretty cumbersome user experience and also like one that could be unsafe. So why we built Satan is kind of a response to what I just said. Usability.
00:06:15.520 - 00:06:49.416, Speaker A: We think that it's a much easier solution. It's kind of a fire and forget thing. You just make it about later and the cost. Also, juvenile screws are expensive things and they require many transactions, including the withdrawal. And our salary solution is basically a single transaction. So yeah. Why do we choose to present this today with regards to email protocol? Because it demonstrates some key features of the protocol.
00:06:49.416 - 00:07:36.508, Speaker A: It demonstrates how to use encryption libraries in secret contract, which is a use case that is going to come up for most enigma related application. This idea of proxy encryption and also it shows how to make ethereum callbacks within secret contracts, which is also going to be a popular feature. Yeah. So essentially Salad is the product. Anything about base coin mixing, it's a coin join implementation. It's noncustodial and non interactive. The non interactive part is what I alluded to earlier, where you don't have to come back and make withdrawals and just make deposits and get your funds when it's ready.
00:07:36.508 - 00:08:09.430, Speaker A: And it requires some thresholds. Basically requires that each I call them deals. The coins that are being mixed within a group, I call them deals. So each deal requires some number of participants, require time interval and so forth. So that's pretty much what the product is. Okay, so this is a demo. I'm going to run this and you can see the product at least where it's at today.
00:08:09.430 - 00:08:53.968, Speaker A: This is not part of it for animation. Yeah, I'm just going to run through it. So essentially you see here on the left there's the browser where we're just booting the application, the satellite application. And then we left the log on the right hand side so you can see what's going on with the covers. What it's doing right now is it's fetching a encryption key from the Enigma network in order to warm up the application, in order to be able to work and use this encryption key to encrypt the user's deposits. Now I'm just verifying as a user my account. And I'm selecting this account, this MetaMask account, as the sender.
00:08:53.968 - 00:09:14.808, Speaker A: And I'm selecting my recipient address. This recipient address is never leaving the browser. It's getting encrypted as soon as it's submitted. And I'm selecting the deposit amount one Ether. Now I just made a deposit in an Ethereum contract that is locked in. Now I'm coming back with another user. See, I'm switching here my user to account two.
00:09:14.808 - 00:09:56.650, Speaker A: So we have a deal with two users in it. Now my sender is me, the disorder address I just picked and then another recipient address doesn't matter right now. The amount is free form. So we're picking one. But really we're going to make this amount kind of selected manually. So now, because this deal had a quorum of two, so it required two participants to be executed when the second participant made its deposit, that triggered the deal. So now the deal is being executed and that's why there's more things going on.
00:09:56.650 - 00:10:49.348, Speaker A: Now what we see in here, it's almost impossible to see, but essentially we see Enigma receiving the deal, decrypting the recipient addresses and outputting some log message and mixing the deals. And now you saw the notification at the bottom saying the deal has been executed, essentially, which means that the deal has been executed on Ethereum. So after Edinba mixed the addresses, it also committed these addresses and the information about the deal on Ethereum and the funds were distributed to the recipients. I know that was quick, but hopefully it made some sense. You can check it out in the code and everything on this repo. That could be a good starting point when you're building an application. Again, it uses some key feature of Enigma.
00:10:49.348 - 00:11:22.176, Speaker A: It has a Web UI number. It's useful. So how it works, just going to summarize it because I tried to explain as it was running, but basically there's a deposit contract on Ethereum which holds the funds of the participants. So say there's two participants in a deal. Each provide one ether. First thing they're going to do is to deposit this one Ether on Ethereum. Then there's a secret contract which randomize the recipient addresses.
00:11:22.176 - 00:12:06.380, Speaker A: So they're going to take their address where they want to receive the fund, encrypt this, send that to an Enigma secret contract. And the secret contract is going to decrypt this and just shuffle it so that you know who the participants are, who the recipients address are. You just don't know which participants is associated with which recipient address. The only thing that knows this is the enclave, the trusted execution environment of Enigma. No human can ever read this information. And there's also a relayer or operator, aka operator that we're using here. And the purpose of using this is it makes the whole system more efficient.
00:12:06.380 - 00:13:04.710, Speaker A: So instead of each end users making a transaction on Ethereum or Enigma after their deposit, what we're doing is we're sending those encrypted and that's the key. We're sending those recipient addresses encrypted to the relayer so that the relayer isn't able to de anonymize the user in any way. And the relayer just kind of holds onto it and submits it in batch to Enigma when it's done. And it also prevents spam by doing some accounting. For example, making sure that the encrypted address that's been received is associated with the right account that has deposited its fund. So it basically does accounting to make sure that the deal is properly funded before sending the data to Edigma for mixing. So this is like how it works, basically.
00:13:04.710 - 00:13:58.096, Speaker A: So so this is kind of how the, this section here doesn't describe how to deploy the secret contract, but describe how the application warms up, essentially. Well, yeah, it's two parts. The key here is when the secret contract gets deployed, it generates a key. And that key is what is being used for encryption by the users who want to submit their deposit. So when the secret contract gets deployed, the key is generated. And then when the relayer comes online, it fetches the public key of this key pair and caches it and gives that to each user as a way to encrypt their recipient address. And the users of the system don't use that key directly to encrypt.
00:13:58.096 - 00:14:48.740, Speaker A: We use like a Dclman scheme where users generate their own key pair and then take the encryption public key, derive the key from this and encrypt with that. Just describe how the cryptography works at a high level. Point being that the recipient address is always encrypted until it reaches the object. Okay, so to go over the flow how it works more specifically. So first a user gets the public key from the relayer to encrypt the recipient address, as I just mentioned. Then the user sends his deposits to the Ethereum smart contract. Then the user encrypts its recipient address where the mixed coin should be sent and signs this and submits this to the operator.
00:14:48.740 - 00:16:08.184, Speaker A: And this is what I was talking about, where we use a DFL man and we do a local, perform local encryption of this recipient address to make sure that it's not known by anyone other than the user. This is all done locally using a client library that we built, JavaScript library. Then the operator receives those submission, those deposit and watches for the threshold to be met. So for example, if a deal requires two participants to execute, then if the operator receives one, it's going to first verify that the deposit is indeed in the smart contract, that the signature is valid, then it's going to wait for the second participant. That's what you saw earlier when I was using the system and also in the deal kicked off, I put a second participant and yeah, so when the conditions are met, essentially the operator is the one that submits the deal information encrypted to the most secret contract. So yeah, this here just describes the parameters of the deal. Like each deal includes a number of participants deposit addresses, so basically the sender's addresses and the encrypted recipient addresses and so forth.
00:16:08.184 - 00:16:53.710, Speaker A: And this is what's being sent to Enigma to do the mixing. This section here is important. This is what happens in the secret contract when the mixing is being done. So remember, we just had an operator detecting that the new deal must be created. Then the operator sends the encrypted recipient addresses and the other deal information to the Enigma secret contract. And the Enigma secret contract has some business logic that is written in rust, as Victor showed this morning, that decrypts the recipient address, again using the reverse Defiant key derivation scheme, decrypts the addresses. And Enigma also has a randomness services that's very important.
00:16:53.710 - 00:18:16.788, Speaker A: As part of the secret contract API, we provide a randomness service where one can get a random seed that is generated from the electric current that passes through the secure enclave. So basically like a randomness service that's quite safe and impossible to predict. So this is how we reorder the addresses using that randomness service over here. So once the work is done, like once the enema secret contract mixed those addresses, now no funds have been redistributed yet, right? Enigma isn't really capable of doing that on its own. So what happens is that Enigma has a function which is called an Ethereum callback. So after the addresses have been mixed, decrypted and mixed, the Secret contract will perform a callback to an Ethereum smart contract, the same smart contract that holds the deposit saying, hey, here are the ordered recipient addresses. And then the smart contract will verify again the parameters of the deals, will receive these ordered recipient addresses and we will then distribute the funds to these addresses after performing the correct verification to ensure that all the parameters of the deal were legitimate.
00:18:16.788 - 00:19:26.744, Speaker A: So that kind of describes the workflow of the typical application. And you see here that the sensitive data were only available once when they were in the enclave. Everything that's happening outside of the enclave, it's either for the user's eyes only, its own data, or available publicly for the stuff that's been pushed to Ethereum simply for the financial functionality that Ethereum has distributed funds and so forth. And one thing that's important too, like to point out, is in this particular application, the enclave is trusted for privacy. Correctness? Is actually insured by Ethereum itself. Which means that well, suppose it's impossible that an enclave will ever be corrupted, but suppose a theoretical attack that an enclave will be corrupted somehow. Then the worst that could happen is that the user addresses will be de anonymized, not that funds will be stolen from the users.
00:19:26.744 - 00:20:08.728, Speaker A: So that's just the characteristic of this application and the kind of things you think about when using the system. Like you have to think about the criticality of your data and try to make things as correct by consensus as possible. Yeah. And there's also this notion of gas. So, like Enigma requires gas, and similar to Ethereum, but gas is paid in BNG, our own token. And there are different schemes there. For example, in this particular case, we achieve economic abstraction because the relayer is kind of brokering the transactions.
00:20:08.728 - 00:21:07.188, Speaker A: So, for example, if a user mixes some Ether, the UI would tell the user, okay, you're mixing one Ether, you're going to receive 0.99 whatever, minus the cost of the transaction is. And that cost will be the cost of doing business for the operator. So the operator programmatically would know how much Eng has to pay to submit this transaction to Enigma and will take a cost from the user's deposits to cover this. So it's like full economic abstraction where users don't have to worry about owning Eng. And similarly, the worker, the Enigma node that performs the computation and commits the results back on chain, has to pay Ethereum gas for this. And similarly, he gets compensated in Eng, which covers this cost of doing business, which is now in heat.
00:21:07.188 - 00:22:01.120, Speaker A: So it's kind of the reverse dynamic for the worker. But the point being that there's sort of economic abstraction end to end there to manage the cost of this system. Yeah. So just a comparison here, essentially, between Salad and some ZK based system. You can see we've done some analysis on the gas costs and we estimate that it costs about five to ten times less in gas to mix a deal in Enigma than it would in a decay based system. A lot of it has to do with the cost of evaluating zero knowledge cliffhanger chain. And even if it's not for that, it also has to do with the fact that there needs to be a withdrawal transaction for each participant, while with Enigma it's like a single distribution transaction.
00:22:01.120 - 00:23:00.288, Speaker A: And there's also usability differences in a ZK based solution. As I mentioned earlier, it's interactive, meaning that you make a deposit you have to hold on to your ZK proof like your note and then submit that at a later point to withdraw. And some of these implementation have taken some interesting workaround where you have to leave your browser window open for 24 hours and hope that it doesn't crash. Can submit the key for you. Right, so not so sure it's going to work well, but in our case, in the case of status, all you have to do is basically make your deposit. And because of the sort of cryptography that we're using, everything can be automated, which means that this is not present in this transaction in this version, but in future version. What we're planning to do is having some sort of reentry where maybe like each deposit, each deals are done with fixed amount of say 0.1
00:23:00.288 - 00:24:00.260, Speaker A: Ether. Right? But let's say you want to mix one full Ether in a ZK solution you would have to return ten times and mix 0.1 Ether ten times interactively. But with this, what we're using is you make one Ether deposit and the business logic in the system would be responsible for dispatching that across like ten different deals without your intervention in a way that's secure. And that's interesting because we can also use this to like even perhaps before we do this, we can use this to create liquidity where we can have liquidity provider that don't necessarily care about being anonymous but they collect a reward, perhaps they share the fees. And what they would do is that they would provide liquidity to the system. So you would have these different liquidity provider that would provide liquidity to the deal to avoid cases where for example a whale tries to come in and de anonymize people and so forth.
00:24:00.260 - 00:24:19.630, Speaker A: This non interactiveness really helps us achieve high level of liquidity in the system which is challenging using the rest of the and yeah, that's pretty much it I think. Questions?
