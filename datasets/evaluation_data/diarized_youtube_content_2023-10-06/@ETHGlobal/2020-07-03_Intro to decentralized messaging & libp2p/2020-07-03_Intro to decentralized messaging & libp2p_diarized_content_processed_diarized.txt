00:00:00.930 - 00:01:03.806, Speaker A: It stream. Good. Awesome. Let's kick it off. Welcome everybody to I think this is probably the fifth hackath event before kickoff. We've been doing a series of workshops related to Filecoin lib P to P. Basically the whole tech stack this week just to get people familiar with these new sorry, I just got distracted getting people familiar with new stuff if they're not familiar with the Filecoin ecosystem.
00:01:03.806 - 00:01:41.390, Speaker A: And today we are really excited to have Jacob Hoyne with us. He will be giving an overview of centralized messaging and lib P to P. He is the JS lib P to P tech lead at Filecoin. And like I said, we're very happy that he was able to join us today and he's going to share some of his expertise on this topic before I pass it over to him. To start off a few things. Like I said, make sure you've staked for Hacka Fest. This is how we ensure that people are really committed for the event and we want to make sure we're supporting people who are committed.
00:01:41.390 - 00:02:07.174, Speaker A: It's only 30 die and you get it back after the end of the event. So please make sure to do that before Monday. If you have any issues DM, anybody from the team, we will look into it for you. We've got one more event tonight after this, which is the brainstorm session. Whereas the previous events this week were more workshop focused technical, this brainstorm session is going to be a little more open ended. Come chat about ideas. 08:00 p.m.
00:02:07.174 - 00:02:45.106, Speaker A: Eastern tonight. Hopefully that's not too late for some of you, but looks like we're going to have a good showing. What else? Of course, the kickoff is on Monday at 12:00 P.m. Eastern. Hopefully everybody gets used to translating from Eastern to their local time, if you're not already. But that's just what we've chosen to get people on the same page. And one other thing we like to do in these events before kind of getting into the swing of it is we play a game that I invent every time.
00:02:45.106 - 00:02:59.510, Speaker A: This time we're going to do the one we did yesterday. You turn on your videos. Let's see. Andrew, I need you to count. Since you and Jacob have colored shirts on, that's what we're going to count. Colored shirts. And I will be Team Monochromatic.
00:02:59.510 - 00:03:14.620, Speaker A: All right, let's see how many black shirts we've got. Andrew and Jacob, please count the colored shirts. Let's see who wins. One, two wait, no. Nazareno, you've got some stripes, man. I don't know. I don't know about that.
00:03:14.620 - 00:03:27.070, Speaker A: 123456 only got like two colored shirts. Eight. I thought it was going to be more balanced.
00:03:27.810 - 00:03:29.842, Speaker B: Bring some color into your life.
00:03:29.976 - 00:03:48.230, Speaker A: Yeah. Come on, people. No, wait. No. I'm Team Monochrome Sorry, I failed to account for striped shirts, so we'll have to consider that for next time. So I think the black shirts win this time. Last time it was a tie so go Team Dark Shirts.
00:03:48.230 - 00:03:58.940, Speaker A: And with that, Jacob, we're done with the games. The floor is yours. Give us a little intro about what you do, what you have done, and what you're going to talk about.
00:03:59.470 - 00:04:42.866, Speaker B: Yeah. Hi, everybody. So as Trent said, I'm Jacob Hoyden. I have been working with Protocol Labs for a little over two years now, primarily focused on the JS side of Lipid to P and Jsipfs. You'll also see me popping up in Golip and Goipfs from time to time, but primarily on the JS side of things and helping out with release management and release planning. So if you really, really want things for Lippy to P and IPFS, I am a great person to throw requests at, so feel free to do so today. What we're going to be doing is kind of giving you a brief overview of decentralized messaging.
00:04:42.866 - 00:05:48.320, Speaker B: We'll kind of talk a little bit about how is that different from centralized and how is it different from distributed, which is the thing ideally we'd like to get to and we'll talk about how to do that in Lib, P to P. Today we're going to be going through the JS implementation of Libidp, specifically in Node. But for those of you who you can either follow along there, the workshop is kind of broken down into chapters to kind of step through where each subsequent chapter has solution code already in place. So if you get lost partway through, you can just change into the next directory and get that running. And if you aren't in a coding mood today, there is a browser version in the repo and that is up on the gateway of IPFS so you can chat to your heart's content. This is a very basic chat application in React, so if you want to use a nice chat application, maybe use Matrix and not this. But we'll play around with this today.
00:05:48.320 - 00:06:09.940, Speaker B: All right, so I'm going to go ahead and share my screen and we will jump into it. If you guys have questions along the way, feel free to shoot them into zoom. I'll do my best to answer them along the way. So I reorganized chat because zoom is mean.
00:06:12.170 - 00:06:13.240, Speaker A: Do you have a.
00:06:17.770 - 00:06:47.840, Speaker B: Yeah. So go ahead and pop stuff into zoom as we go. Otherwise we're just going to go through this and then I'll leave space at the end if you have broader, more in depth questions. So here is just the README for the workshop. So if you want to pull that down, feel free to do that and we will get started. If you haven't pulled it down already. Here is what the web chat app looks like.
00:06:47.840 - 00:07:22.282, Speaker B: You can see this is a very depictive picture of what the Internet and Lipidp looks like today, with this green one being a Node JS node. And the not very well connected browser node is in purple. But let's go ahead and jump in and start talking through this. Yeah. Again, code for today, it's up there. The branch is Hack FS, if you want to follow along there in the main branch. We're also kind of updating this along the way as we release new versions of Libby to be.
00:07:22.282 - 00:08:52.118, Speaker B: So the Repo is just a good place to come back to if you ever want to see how we're going through and updating from like 27 to O, 28 and beyond. So talking a little bit about centralized, decentralized, distributed. Right now we're kind of in this era where we're pushing more towards decentralized. But we've been in a centralized structure for so long where these center nodes are heavily controlled. By a few very large corporations like Google and Amazon and there are intrinsic problems with this that a they're the places where all the data goes so they can house as much as they want they can keep that we have GDPR in places like Europe but in the US they kind of have freedom to pull all that information Another consequence of that is that it's very easy to censor single points and that becomes difficult for people living in China or Turkey and places that are kind of restricting those endpoints. So ultimately what we want to do is we want to get to a point where we're able to develop a full peer to peer network and this is really this distributed side of things, this full mesh looking infrastructure. The problem with that is that talking directly peer to peer is very difficult.
00:08:52.118 - 00:10:33.186, Speaker B: Building a distributed system is very difficult in today's technology setup especially, we look at, like, browsers and being able to connect to them. And so kind of where we're at right now is this middle ground of we're building a decentralized network in Web Three on our way to getting fully distributed, and we do this thing with rendezvous servers and WebRTC, which we'll talk a bit about today with circuit relay nodes, things like that, where we can have these centerpoints where lots of people can connect to and then create peer to peer ecosystems from there. So not quite what we want, but it's a good stepping stone to get there. So how does Lib PDP play a role in this? So Libidp is the networking stack that IPFS Filecoin, Ethereum Two and a few other ecosystems are building on and the reason for this is Lib PDP is designed to be a modular system of protocols. As we get better support for distributed systems and as the Internet and our infrastructure evolves over time, we need to make sure that we're building a networking layer that's going to be able to adapt to those changes. And so this is really what Lib PDB is trying to do, is create that foundational layer so that people can build awesome applications on top of it. So getting down into the bits of Lib PDP, the first thing we need to look at is like transports, because transports are the foundational layer that Lib PDP uses to connect to other nodes on the network.
00:10:33.186 - 00:11:23.430, Speaker B: And there's a wide variety of them and they're continuing to grow as technology grows. And as more and more people are joining the Lib PDB ecosystem, they're starting to develop more interesting and neat ways of passing that data around. So each transport comes with its benefits and its drawbacks. Here's a very basic table of where things are at today. This only includes Node, Go and Rust, but we have currently today seven implementations of Lip PDP. We also have Java, python C plus plus and NIM. And so this ecosystem is growing and it's making it easier and easier to develop Lipidp across different platforms.
00:11:23.430 - 00:12:15.110, Speaker B: So today what we want to look at, because we're building this in JavaScript, we're building a node only application right now, but we also want to make sure that this chat app that we're all in, we have the ability to also connect to the browser. So looking at WebSockets and WebRTC, so talking through a little bit more of these transports, like TCP is a very basic transport that a lot of the servers are using. So Go uses it, Rust uses it, and Node uses it. So this is a pretty prevalent, widely supported transport. But it does have its drawbacks. Like we can't talk to browsers, it can't run in browsers. WebSockets is nice because it's widely supported in the implementations and it allows browser nodes to talk to server nodes.
00:12:15.110 - 00:12:48.500, Speaker B: The big drawback here is that WebSockets in the browser have to have an SSL certificate at the node that they're trying to talk to. So if you run a server in Node or in Go, you have to put an SSL certificate in front of it and a domain because currently at this point in time, SL certificates don't work for IP addresses. That might be a thing in the not too distant future, but that's currently in limitation, which makes this very painful to make a peer to peer network explicitly on that.
00:12:51.430 - 00:12:51.890, Speaker A: Cool.
00:12:51.960 - 00:13:27.054, Speaker B: And then WebRTC, WebRTC is really nice. There is working support for it in Go. It's not quite there yet. We're probably going to be looking at reevaluating that because one of the nice things about WebRTC is it has built in hole punching. And hole punching is the thing that lets us talk from browser directly to browser. So like using this chat app in Chrome or whatever browser you're like, we're connecting over a Rendezvous server and then we're doing hole punching to actually talk directly browser to browser. So we don't actually go through a relay server, which is really nice.
00:13:27.054 - 00:14:01.914, Speaker B: It's a very efficient form of communication. And then we're working on an evolving Quick transport. So the RFC for Quick, it's still in progress, but it's being finalized. And so the latest RFC is implemented in Go. And we've actually been working with the node JS team to get support in node JS. So that is coming hopefully in the not too distant future. I think it's already experimental in node twelve, or at least a fork of it, so you can play around with it there.
00:14:01.914 - 00:14:59.294, Speaker B: I think we have a very rudimentary version of that in node, but not quite there yet. So looking at what we're building today, we said, okay, let's look at node because that's what we're running. And then we want to make sure that we're able to talk to browsers. So what we're going to do is we're going to add TCP, which is going to let us talk to things like DHT servers and other server nodes. WebSockets is going to let us talk to any bootstrap nodes that are on the network because all of the bootstrap nodes that the Protocol Labs team supports, all of our Lip PDP bootstrap nodes, those all have SSL in front of them, so we can totally get that out of the box and connect to the network. And then WebRTC we're going to use so we can actually talk directly to one another over browsers. So over this, we're going to kind of skip through some of the chapters just so I can get this done in roughly 60 minutes.
00:14:59.294 - 00:16:07.646, Speaker B: And so we're going to go through several of these concepts along the way. And then when we get to the basic setup for Libidop, we'll jump into the code and see what that looks like and then from there we'll move on. Even for localhost, localhost is actually a secure domain. So when you're testing locally, you don't have to worry about it. You can connect to your localhost server. So now that we've selected our transports and we know what we're going to use, what we need to do is look at like, okay, how do I contact you on the network? If you think about things like today, us as people, we have telephone addresses, mobile phone addresses, email addresses, postal addresses, telegram accounts, we have all of these various ways to contact people and there's not a clean way to do that. If you were to fill out a form with all of your contact information, you would have to have a ton of different fields formatted differently and those change over time and that becomes very painful to represent.
00:16:07.646 - 00:17:05.282, Speaker B: And what we want to do as lumpy to P is make sure that that is somewhat future proof that we can evolve these addresses over time that have a singular structure, so we don't have to worry about that. We can just derive addresses from that. So what multi adders do or multi addresses, they allow us to compose flexible addresses in a path like structure when they're string representation. So they also tell us a ton about the host that we're going to contact because we need that information. So we're going to step through a few multi address here because they can be a bit difficult to consume. But the first one we have here is your very basic listen address that you'll see in IPFS. And what it's saying is I'm looking for an IP four address at this IP address localhost, and I want to connect over TCP.
00:17:05.282 - 00:17:43.810, Speaker B: So this is defining our transport and then we're going to connect on port 4001. So fairly straightforward. The next one is almost the same sons of the port change, except we have WS at the end. And what this is telling us is we're going to run a WebSocket connection over a TCP transport because WebSockets traditionally run over TCP connections. Looking into some much more verbose, we've gone from the simple thing to the much more complicated thing. But this is one of the servers that we're going to look at connecting to. Actually today we'll be connecting to one of the subservers of that main domain.
00:17:43.810 - 00:18:50.390, Speaker B: But here we have a DNS four. So we're running a DNS domain address, which means we are going to need to do an IP DNS lookup. So this will probably automatically happens in Node, but for things like the browser, we actually have to do resolution. And that becomes painful because we actually don't have a way to do that in the browser without doing DNS over Http, which is kind of annoying. What we want to do is we want to resolve the webrtcstar discovery lipdp IO address, that is a TCP connection that's running on a secure port of sorry, secure port of four, four, three. And then you'll notice instead of WS, this is WSS, which indicates that this is a WebSocket secure connection. This is required for browsers, but things like Go and Node don't actually require SSL certificates, so you can actually make secure connections just over WebSockets, which is nice because we can just fall back to the PDP decryption.
00:18:50.390 - 00:19:27.598, Speaker B: And at the very end of this is a thing that tells us this is a WebRTC star connection. And so this is a WebRTC rendezvous server, which is going to allow us to negotiate WebRTC hole punching. So the next thing here is similar to TCP, except we're going to be running a UDP connection. So this is going to be packet based switching instead of TCP. Then that's going to be running on 4001. Again, this is like your default IPFS implementation. If you have Quick enabled and Go IPFS, and then that's running the Quick transport.
00:19:27.598 - 00:20:08.278, Speaker B: And then we see here that we actually get this PTP. In the past, if you've been working with IPFS for a while, this was typically IPFS, but because Lippydp is for many more applications than that, we've changed that to just the PTP protocol. What that indicates is there is a peer ID that's about to happen. In this instance, it's a truncated QM relay, is the peer ID. And at the very end of this, we see that this is a PTP circuit. So when the transport when the switch goes to look at this, it says, okay, I am going to make a relayed connection to this peer. So I'm going to dial this peer over Quick and then negotiate.
00:20:08.278 - 00:20:51.950, Speaker B: So this was what you might use for a listening address if you wanted to listen over this relay. Okay, so once we have that, really what we need to do is like, okay, we have some understanding of can you talk a little bit more about the circuit and how it might be shared? Yeah, we can look at that. We'll touch base back at that at the end. Please remind me. Ready? So adding the multi adder once we do that, once we've figured out our multi adders, we'll go through this in a little bit. And to look at like, okay, what does this set up actually look like? We need to actually specify what are our listen addresses. We might want to change what our announce addresses are.
00:20:51.950 - 00:21:34.426, Speaker B: So, for example, if you are running a server and you want to put a domain name in front of it, you want to announce addresses that you're not listening on. You want to announce that domain address. And we'll kind of look at some of what that looks like. So the next thing we need to do for our base connection is look at connection reusability. So in Lipidap, there's a variety of protocols. There's application level protocols, pub sub messages, DHT queries circuit relay is a protocol file exchanging like IPFS and filecoin. And then the chat protocol that we're building today, at least the first part of it.
00:21:34.426 - 00:22:26.490, Speaker B: And then if you build something new on top of loop at hackfs, you're going to need to create your own protocol for that. And so how do we handle this with singular connections to other nodes? How do we handle all of these things? We don't want to create new connections for each of those. We want to be able to reuse that. And so if you kind of think about this, the concept of if you've ever heard about or seen a tin can phone, basically the idea of I have two tin cans, and I punch a hole through it and have just a string running through a top string, you can speak through that and that will transmit information. But if you try to have multiple people talking into it at the same time, you're not going to get anything out the other end. It's just going to be garbled. And so what we want to do is to be able to take this very PTP connection, and we want to be able to do multiple virtual connections over it.
00:22:26.490 - 00:23:11.500, Speaker B: So it's kind of like this idea of we're creating virtual strings across our chincan phone so that we can run each protocol on those streams and we'll look at a little bit more of what that looks like. So this is called stream multiplexing in leapadb. And multiplexing is a concept that actually dates back to early days of telephony in telephone lines, what they actually will multiplex multiple conversation over different frequencies. That's how they handle it in telephone. TCP connections do it over multiple ports. So you're not getting multiple connections per port. You have singular connection that will multiplex over multiple ports to the applications that are receiving that.
00:23:11.500 - 00:23:53.206, Speaker B: And then for Mplex, which is the it's not the only multiplexer. For lipid to P. We have yamux. And Quick has a built in multiplexer. But Mplex has the widest support right now because it's relatively easy to build compared to some of these other things. So once we have that, we have our transports, we have our multi editors for people, so we're able to connect to them, we're able to multiplex the connection, so we can have multiple conversations over a single connection. The next thing we need to do is encrypt this because we don't want this data just free flying over the Internet and plain text.
00:23:53.206 - 00:24:43.430, Speaker B: That's not good life for anybody. So what we want to do is encrypt that. So when selecting our encryption protocol, we need to think about a few things. So our current supported protocols in the various languages are TLS One Three, which is used right now by default for Go, and then Noise, which is noise, is going to be the default security transport, I believe, for ETH Two. And the reason for this is noise is a framework for building security protocols. And it's actually pretty easy to implement, relatively easy to implement in the various languages. Like TLS, we have to deal in node we need a TLS 13 implementation working in node JS before we can do that.
00:24:43.430 - 00:25:21.240, Speaker B: And then we're blocked on the browser because the browser doesn't have TLS 13 support. With Noise, we can write all those protocols and then we can just handle that exchange. And we have full support already in JavaScript and Go, and we're working on getting those downstream in the other implementations, which are very close. Then again, Quick has a built in TLS security. And Secio, you'll probably see that around. That was originally developed as a stopgap solution for TLS One Two not being able to do self signed Certs. And so SEC IO will be phasing away as we have these new security transports in place.
00:25:21.240 - 00:26:02.430, Speaker B: And here's just a quick capture of wireshark. I don't want to bore you with all of the details here, they're too nitty gritty. But what you'll see here in the top right is really like once you've encrypted a connection, you'll see that the thing that gets exposed is the original multi stream handshake. So we go in and say, Hi, do you speak this multi stream protocol? And then we'll reply back with, yes, I do. And then we select from there crypto. And as soon as we agree on crypto, in this case SEC IO, everything is immediately moved into crypto handshakes and encryption. So everything's secure.
00:26:02.430 - 00:26:45.854, Speaker B: If we did this in plain text, you would see a variety of protocols being negotiated. We can table the key exchange one for the end. So base configuration, we've talked about a lot of things. This is a lot to absorb. Let's kind of like jump into the code here and get a look at what exactly this looks like. So if you are following along in the code, we're just going to jump into chapter four protocol. Okay, so just kind of stepping through the setup here.
00:26:45.854 - 00:27:09.320, Speaker B: And if you follow along at the beginning, start at like chapter one, it'll kind of guide you through requiring some of these things. But here's the baseline of setting up multiplexing and encryption. So right at the top right, we have our transports that we talked about. We've got lib. PDP. TCP. We have lib, PDP, WebSockets and WebRTC star.
00:27:09.320 - 00:28:02.374, Speaker B: The next thing we need because Node JS doesn't actually have support for WebRTC out of the box, so we need to custom install that module in the browser. In most browsers we get WebRTC for free. It's already there, but we need to bring it with us when we're building Node. The next thing is our multi adder module that's going to let us do all the multi adder creation from there. Mclex here we're using both noise and Secio is more of like a fallback. So what we want to do is we want to default to noise as that's going to be the de facto going forward eventually. And then Secio is kind of a fallback and so that will allow us to talk to legacy nodes on the network who are still only speaking SEC IO and haven't had a chance to upgrade to noise, which is really important to be able to kind of have that gap of letting the network upgrade from there.
00:28:02.374 - 00:29:00.890, Speaker B: We'll look at the chat protocol in a second, but this is just a file that pulls in like a very rudimentary chat protocol and then lippydb core, which is what we're going to plug everything into. So here we just have a main Asynchronous function because we need to do some awaits in here because a lot of the code is promise based. We moved away from Callbacks about a year ago. And so in here what we want to do is we need to create the Lib PDP node. So there is a convenience constructor because oftentimes the construction needs to happen asynchronously it's promise based because we might need to generate keys or peer IDs if you haven't specified one in advance. So from there we can actually select our addresses. And here we talked about creating the listen addresses specifically like we want to listen on a wild card.
00:29:00.890 - 00:29:33.982, Speaker B: So what this means right here, IP 40 zero TCP is I want to listen locally on any port. Just give me an open port. I really don't care what it is and then later on we can announce that to the network and Lib PDP will handle that automatically. And then the next thing we want to do is we want to make sure that we have our WebSocket connection as well. And so we're adding the listen address, same thing. It's going to listen wildcard, find any port that it can and listen in things like IPFS. These are going to be hard coded.
00:29:33.982 - 00:30:04.602, Speaker B: So you've got like 4000, I think the other one is 4002. And the reason for this is you can predict what those ports are going to be on. If you want to set up port forwarding on your router at home, you can do that instead of port sharing. And actually it's easier to plan that way if you don't have upmp set up on your home router. And then the last address here is the WebRTC transport and that's the multi header that we kind of showcased. Although this is a little bit different. This is one of the WebRTC addresses.
00:30:04.602 - 00:31:00.210, Speaker B: So if you go to the WebRTC repo, we've got a list of a couple servers that we now host so that you can troubleshoot, you can play around with it and then you can always run your own WebRTC Star server. From there we get into actually specifying the configuration. So going in and saying, okay, the transport I want to pass in TCP, WebSockets and WEBR TZ Star. These are also going to be kind of in order of preference. And so in this instance, if the peer that we want to dial has TCP addresses, we're going to try to dial those first in order we do do parallel dials. I believe it's up to eight by default that will try at any one time, but any TCP ones will be prioritized in web socket and WebRTC and usually because these are like the more efficient ways of connecting. So we want to try to prioritize that performance.
00:31:00.210 - 00:31:52.206, Speaker B: So from there we look at the streamuxer which in this instance is Mclex, and then connection encryption again, noise and Secio. This is preference based so we're going to attempt, when we're connecting to somebody, we're going to attempt to negotiate noise first and then if that fails, we'll try Secio. This does have a consequence of it costs around trip. So there is some latency there if we're trying to talk to legacy nodes, but we get the advantage of slowly upgrading the network over time. Typically if we're rolling out a new transport like right now in Jsipfs and in Goipfs, these are switched. So we'll actually do Secio first because I upgraded first, I don't want to immediately take the performance of a round trip. So I'm going to upgrade, add support and then I'm going to let the network upgrade for a little while before I switch those priorities.
00:31:52.206 - 00:32:41.662, Speaker B: And then eventually we'll just decommission noise. But for this we're going to leave noise. As the preferred one. This thing here is a little bit Kludy and we're going to be working on making the transport configuration, just configuration in general better in the future. But all this is it's kind of a hack of saying, okay, when we construct the transport because Lib PDP needs to inject itself into transports on creation, I also want to pass it these additional properties. And so what we do here is look at WebRTC Star and we get its symbol string tag. We can't use like constructor name or anything like this because when you go in a browser and you bundle it, it totally obfuscates the name of the constructor and that's just going to cause you nightmares.
00:32:41.662 - 00:33:29.280, Speaker B: So we have this kind of convenience constructor and in the future that will be easier to do. But all we're doing here is saying that WebRTC module that we included, we want to pass that in to the WebRTC transport so we can leverage that. Then from there, that's the basic we we don't really have Discovery built in right now. There's nothing specified. We'll talk about that a bit more in a minute. However, because WebRTC Star is a rendezvous transport, we will automatically check for the Discovery component and if it's there, we'll bind to it and we'll immediately listen. So this you're automatically getting some Discovery for free for finding WebRTC Star peers, which is pretty nice.
00:33:29.280 - 00:34:20.562, Speaker B: From there. What we want to do is this is just a basic thing that as we connect to peers, so listening to the connection manager, anytime a peer is connected, get that connection and then we can look let me just shrink this a little bit so you can see. We can look at and say, okay, whenever I'm connected to a peer, each connection has remote peer on it, which is peer ID. So we can stringify the implementation of that and we can log it out and we can see what that looks like in a second. And then we'll get into the chat protocol handler a little bit and then from here we're just going to start the node. And that's the basic gist of getting everything running. One of the problems this has, this is just some logging information here for the string ID.
00:34:20.562 - 00:35:20.910, Speaker B: And then the multi editors that we're actually listening on is like this concept of bootstrapping which we'll talk about in a second with Discovery. And right here we're doing a very crude thing of we're just going to get the address of one of the bootstrap nodes and I've hard coded it here and we're just going to dial to that. If you want to take a look at some of the servers that we have running, you can actually do a Dig. If you have Dig on your machine, you can do Dig type TXT and then we can actually look at this bootstrap Lib IO record and then we need to preface that with DNS adder. The reason for this is this is how the DNS address lookup works. You can just remember that because the DNS adder is at the front, it just needs to underscore. So when we dig that information, we're going to get back text records.
00:35:20.910 - 00:36:13.382, Speaker B: So Lipidp Bootstrap IO is kind of a round robin gateway that houses all of these bootstrap nodes. And if you just try to dial Bootstrap Lib IO, it's going to fail because it has no idea who it's going to talk to. And we currently don't support blind dialing for kind of encryption purposes, but you can look at this and see, okay, we've got a bunch of DNS adders back. And so what we ended up doing is just selecting one of these and then from there you look at it's a DNS adder again, so you can additionally resolve that. And those individual ones are going to resolve to IP addresses. But for the sake of this, we're just going to target one of the bootstrap nodes and then we're just going to dial it from there. So if we run that again and we say we're in chapter four.
00:36:13.382 - 00:36:59.490, Speaker B: So if I do node four, I'm in root node four protocol index and I can run that. So we're going to see our peer ID and we are listening on the following addresses. So we see the wildcard zero got replaced with our external port. And then so we've got a couple of TCP addresses. These are all local gateway, localhost and local gateway, and then our WebRTC star server. And then you can just see as we've bootstrapped and we've connected over WebRTC, we're getting that free discovery, right? There's no other discovery protocol in place, it's just WebRTC star. And if you're looking at the browser, you probably see a lot of spam updates going on with the nodes.
00:36:59.490 - 00:37:31.086, Speaker B: Right now we are connected only to webrcps. We're connected to two peers. We're connected to the bootstrap server, which is over our TCP connection. This is the one we manually dialed. And then WebRTC star are all of our other connections. So all these other ones are going to be WebRTC star connections. So I'll go ahead and shut that down for now and then we'll take a look.
00:37:31.086 - 00:38:18.974, Speaker B: So this is the base configuration, right? We're connected to the network, we're connected to peers, we've got browser peers, we've got node peers. This is great. So the next thing we probably want to look at doing is let's get an actual protocol in place so that we can do something with this. So what are protocols in Lib PDP? It's a concept that people usually struggle with a little bit, but what you can kind of think of protocols like everything in Lib PDP is basically a protocol and they're just basically these plain strings. If you've ever messed with a rest endpoint, it's very similar to endpoints in Rest. Like these are endpoints in Lib PDP. So what happens is we register our protocol with a specific thing.
00:38:18.974 - 00:38:51.286, Speaker B: Today we're actually going to use the Lib PDP Chat 100 and zero protocol. And what we're going to do there is we're ultimately going to listen on that. So anytime a new connection comes in, a stream opens, that connection is going to come in, and that protocol is going to be at the front of it. And so we're going to pick it up and say, okay, lipid to be chat. Yes, I handle that protocol, or I don't handle the protocol. If I handle it, I'm going to take it and I'm going to pass it off to the application handler. So this is going to be our chat protocol code.
00:38:51.286 - 00:39:28.258, Speaker B: So then from there, you can send whatever kind of information you want to send over your stream, as long as you know how to deal with it. Cademly for the win. Yeah, we'll get into that a little bit. So let's actually look at what creating this protocol looks like. So we'll just pop into this chat protocol, and it's really basic. So we have a handler and then we have a send function. So looking at our protocol, right, this is the chat protocol that we talked about.
00:39:28.258 - 00:40:18.222, Speaker B: This is what's going to allow us to chat with anybody else who's doing direct messaging. We'll look at Pub sub later for actually doing chat in the chat application, in the browser that's running on the gateway that's doing Pub sub based, not direct messaging. But for getting started, we're going to do direct messaging because these kind of protocols are very valuable when you want to do, like, file exchanges, because you don't want to Pub sub that information. You want to get a direct connection before you send a lot of data. So our handler code that we're going to register takes a connection, and then it also has the stream. The connection here is really for convenience, to give you that additional information of, like, who is the remote peer here? There's a lot of information on the connection. If you want to check out the API Docs, we've done a big overhaul of the API Docs.
00:40:18.222 - 00:40:52.826, Speaker B: Let me try to preview that here on Jsleeptb website so you can look at that and get a lot more information on things that we expose. And it will include the type. So you can actually go and jump over and look at what the connection is. But we give a lot more information there now to where you can actually look at stats for the application. What are all the streams open on this connection? Like, previously you couldn't do this in JS and it was a nightmare. So you can get a lot more information there. But really what we need is the stream.
00:40:52.826 - 00:41:55.426, Speaker B: And that's the thing that like, okay, when my handler registers, it says, okay, somebody hasn't negotiated the chat protocol that succeeded here's the stream with the data on it. So what we want to do is we want to read all that out and because this is just a very basic string implementation of chat, all we're going to do is we're going to take that incoming message. So this is all like async iterators based, which are pretty nice if you've ever messed with them. But what we're going to do is we're going to pipe everything from stream and we're going to read it out in this function. So we're just going to step over every message that comes through here and we're just going to log that data out and then we're going to do replies on new streams. So all we're doing here is we're just immediately going to close our right end of it because we only care about reading in that information on the send side of it. We've just got this basic function set up that we're going to pass the message we want to send and the stream that we want to pipe data over.
00:41:55.426 - 00:42:44.340, Speaker B: And so again we're piping this message array. We could change that to be multiple messages but for now just a single message and we're going to pipe that into the stream and then we can wait for any responses there. And the reason this is kind of Kludy because nobody's ever going to reply. But if you actually look at the main branch in Lib PDP, there's a bootstrap server in there that you can run and it will actually just auto reply with some random messages. So we have that set up but in reality you don't need to do that. And here this is logging out the messages that we're actually sending. So you get that like the chat log of hey, I sent this.
00:42:44.340 - 00:43:38.050, Speaker B: So if we look at how do we actually register this thing, right? So we've included our chat protocol in the handler. Now we need to do two things. The first thing we need to do is actually register and so we need to register our handler. So Lib PDP has a handle method so we can jump down to this to do this is add chat handler so we can just uncomment that and all we're going to do is pass handle the protocol that we're going to run which is our chat protocol and then the handler and that's it. We're now ready to respond to anything that comes in but we also need to send some data. So down here if we go to our next to do this is just basic handler code that reads from standard in. So what this is going to let us do is actually fire off messages from terminal in node.
00:43:38.050 - 00:44:21.486, Speaker B: So all we're doing is listening to process standard in and every time a message gets sent based on a new line return, we're going to get that message in. What we do here is the basic slice like we trim off the new line. And we're doing a very crude thing here that you should not do in a chat application is we go through all of our peers in the store, in the peer store. We check if it supports the chat protocol and then we check if we have a connection. If we have a connection, we'll create a new stream and then we call our chat protocol send. So this is connection. Take an existing connection, call new stream on it.
00:44:21.486 - 00:45:05.310, Speaker B: That takes some time because we need to go we need to send a round trip to their multiplexer and say, hey, let's do this on Mplex. Let's create a new stream. And we want that stream to be the chat protocol. So once we get that back, we can go ahead and send our message over that stream and then that's it for the code. So if I run that again, now that we've uncommented that, I can go get some chat and then I can say hello there. And so nothing is listening to this right now. So let me pop this open node.
00:45:05.310 - 00:45:52.584, Speaker B: Oh, no, see, this is oh, I changed it. That's why this is why we use wild cards. Running all the nodes. You, uhoh I broke something. What did I break? Not run that. Oh, I broke something. Chat protocol handler.
00:45:52.584 - 00:46:14.960, Speaker B: Did I save? I did save. We don't have much time left. So this is what you do if you get stuck. We open the next chapter and we look at it. And this is going to have our solution code in there. This is a cheat. Lovely cheats.
00:46:14.960 - 00:46:44.972, Speaker B: So o, five discovery index. If I run that, then I run again over here. Node five index. Yes. I'm spamming all of my peers. And this is where we're going to look at pub sub for sending messages because it's way more efficient. So now we can see that the chat protocol is working.
00:46:44.972 - 00:47:11.990, Speaker B: I don't know what I messed up, but I must have typed something incorrectly. But if you get stuck CD into the next chapter and that's going to have everything in there. All right, that's our base protocol. So now we want to discover probably more peers. Like, we have WebRTC star, which is really nice, but we probably want to get more on the Internet. I fat fingered. Yeah, I probably did.
00:47:11.990 - 00:47:56.448, Speaker B: I've got big chubby fingers. All right, so if we look at peer discovery, there's a variety of peers or a variety of discovery mechanisms that we probably want to use. And so bootstrap is the primary one, right? Like, we did the direct dial before, but ideally we probably want multiple bootstrap lists and we might want to bootstrap to different parts of the network to avoid either networks going down. We don't want to rely on one. So having a list of nodes that we can initially dial to and bootstrap into the network is valuable. Mzns, we're not going to use that here locally today. What it is is local discovery on your home network.
00:47:56.448 - 00:48:40.860, Speaker B: Since this workshop was originally designed for people in place, people all in one place, but since we all can't be together, we will scrap Mzns. But if you do have infrastructure or an office or places where multiple peers are going to be connected, mzns is a great way to connect with other peers. So it's still very valuable. Downside, it doesn't work in the browser. DHT is also a very good way to find peers. One of the limitations there is really like, most of the DHT nodes are like TCP only, but we do happen to have a few that run over other transports like WebSockets. So you can actually technically still crawl the DHT.
00:48:40.860 - 00:49:06.616, Speaker B: Although doing that in a browser is going to be slow because you need to open up a lot of connections. It's usually like I think in Goipfs we're averaging about like 50 dials for a query. That's very expensive when you're trying to do like WebRTC, WebSocket connections. So you can use it, but it won't work very well. Disk V, five ChainSafe. Put that together. There's a JavaScript implementation of it by ChainSafe, I believe.
00:49:06.616 - 00:49:25.410, Speaker B: And this is for e two network discovery. So that's really nice. It's kind of like a DH. It uses a DHT to discover peers. So that's also a very nice way to connect. It is UDP only right now. So again, it's not going to work in the browser, but you can use it in node if you want to.
00:49:25.410 - 00:50:21.344, Speaker B: And then rendezvous servers, like Lib WebRTC Star signaling servers. And then we're actually building a rendezvous protocol. And what that's going to let you do is actually ask the rendezvous protocol for peers that have registered to certain namespaces. So if you build your own chat protocol or your own web application or anything, you'd be able to go to that rendezvous server and ask it directly for a Federated list of people who are registered to that to really kind of short circuit a lot of the initial boot time. And then we do have people who have built some discovery mechanisms in Bluetooth for local discovery. Web Bluetooth not quite there yet. But there's another interesting way to find things locally and looking at the distributed space, what we really want to get to is that's kind of like looking at the environment that you want to be is being able to discover my nodes locally and then grow to the wider network there.
00:50:21.344 - 00:50:55.240, Speaker B: So we don't have to depend on people running centralized bootstrap servers. You can trust us, but you shouldn't trust us. Don't do that. Let's make this all organic and actually make it a peer to peer network. That's what we want to see. And then DHT. Random Walk so in the DHT, the newest version of the DHT in Goipfs doesn't technically do a it's not a random walk, but it's ultimately like a refresh of your routing tables.
00:50:55.240 - 00:51:28.676, Speaker B: So if you don't know what a DHT is, it's a distributed hash table. And ultimately, it's like a big key value store of peers on your network and then peers who have certain data. And this is kind of how IPFS stores content. If you're looking for content on the IPFS network, you're going to look for that CID, you're going to query the DHT for it, and it's going to tell you who has that. Then it's just a matter of connecting to that person to get the data. But with that, we can actually use DHT random walk. And we do have support for this in JS, and we are going to run it because it's fun.
00:51:28.676 - 00:52:11.300, Speaker B: But that is a great way to just get to know more peers on the network in addition to actually finding content. So here's kind of how the DHT works. If you're not familiar with it, let's say I want to random walk the DHT. And for simplicity's sake, we're going to say, like, the DHT IDs are actually like, people's names. And so I know Alice and Bob, but I'm looking for Brandon. And so what I'm going to do is I'm going to ask Alice and Bob like, hey, do you know Brandon? And Alice is going to say, Nope, don't know anybody. I don't know anybody close to Brandon, but Bob is going to say, hey, I don't know Brandon, but I know Brenda.
00:52:11.300 - 00:52:41.692, Speaker B: Along that process of making up the ID of Brandon, like, Brandon might not even exist. We just say, yeah, give me somebody called Brandon. We learned about Brenda that way. And so this is kind of how that random walk works, right? It's like just going around a party to meet people and like, do you know Dave? Do you know Dave? Do you know? Like, Dave might not be at the party, like, Dave might not exist. But it's a way for you to find new people. So we're going to leverage that. And the best thing to do is know.
00:52:41.692 - 00:53:08.810, Speaker B: Got to catch them all. Use all of the discovery services. Use as much as you can because the more discovery services that you have, it's more tools at your disposal to get connected to nodes and allow other nodes to get connected to you. So we aren't going to use Mdns. Let me scratch that out. But we're going to use Bootstrap, the DHT random walk, and we already have the Webrt signaling server. So configuring discovery, we are a bit short on time.
00:53:08.810 - 00:53:21.550, Speaker B: So what we're going to do is we're just going to look at the Pub sub directory. And again, this is going to have not you. I want you here.
00:53:22.640 - 00:53:23.656, Speaker A: Hey, Jacob.
00:53:23.768 - 00:53:24.430, Speaker B: Yeah?
00:53:24.800 - 00:53:34.544, Speaker A: It's all right if you go over a bit because this is recorded. So if there are people following along after and you want to include anything, that's totally fine. We'll be sticking around.
00:53:34.662 - 00:54:03.864, Speaker B: Okay, great. Okay, so looking at we want to do discovery next, configure that. And due to shortness of time, I'll just kind of walk through, but again, CD into the next chapter, Pub sub. And that's going to have all the solution code. So we can ignore PubSub chat. Here's our old protocol, which we're going to end up getting rid of in favor of Pub sub, but focusing on peer discovery. So here are our things.
00:54:03.864 - 00:54:30.450, Speaker B: I lied. Mdns is set up ha. So we've got bootstrap. So rather than dialing that peer doing a manual dial, we're going to set it up in our bootstrap list. So we're using the Load PDP bootstrap module, the PDP Mdns for local discovery. So I'm going to be able to discover myself when I run two nodes, but I won't be able to discover you over Mdns. And then we're going to use the DHT for random walk.
00:54:30.450 - 00:54:53.604, Speaker B: And so again, our listen addresses are the same. Nothing has changed there modules. The only things that we're changing is peer discovery. We're going to add bootstrap and Mdns. These are exported values from above. And then we are going to include the CAD DHT. So we're running a Cademia based implementation of the DHT.
00:54:53.604 - 00:55:40.880, Speaker B: But in theory, as long as it meets the API requirements, you could run coral, you could run other kinds of like you can build your own DHT, experiment with it, play with it, see how it works. But for this, we're going to use the Cademli DHT. And then again, nothing's changed our transport. So, peer discovery, what we've done is we've taken the dial, the manual dial from down here and we've just moved this into our bootstrap list. And so what this would let us do is if I wanted to let me go look at that Dig again. So if I look at dig if I want to like, hey, let's add EWR, looks like fun. Let's add that.
00:55:40.880 - 00:56:25.100, Speaker B: The reason we have to add these individually and not just add the main thing that we did a dig on. The reason for that is currently DNS adder resolution in JS. We don't have that in place yet due to needing to do DNS over HTP in web browsers. But we can add another bootstrap node to our list. It's no problem. You can add as many as you want and when the node starts up, it will automatically dial all of this and then DHT. So we're going to turn it on and then we're going to enable random walk.
00:56:25.100 - 00:57:05.660, Speaker B: Just see these explicitly there. If you add the DHT by default, these will already be in place. I just want to kind of show you where those options would exist because there are some additional options. You can change the interval, the frequency, you can look at that in the DHT configuration, but this is kind of the base for expanding off of that. And then the rest of this code is all the same. So what we can then do is run O six Pub Sub because we're doing the previous chapter on Discovery. I'm going to run two of these.
00:57:05.660 - 00:57:38.260, Speaker B: Oh, I did something. What did we do? PTP awaits. Start something's broken. Debug star. I broke something bad. So I need to push that update. We need to actually call the main function.
00:57:38.260 - 00:58:01.210, Speaker B: It's important to run the code if you want it to work. There we go. I'll push that fix up after this. Sorry about that. So we have our base code here. Discovery is on. Once the DHT kicks in, you're going to see a lot of peers get discovered very quickly.
00:58:01.210 - 00:58:32.820, Speaker B: This is what's going on. We're doing the random walk and then if I run on the other node, we'll connect to those again. This is going to do Mdns. So if we look at our peer ID QMU, we actually discovered that very quickly, actually faster than our bootstrap nodes, because we're on the local network. So Mdns discovered really quickly. So we can say hi there, and we got that there. Hard to see amidst the connection spam, but we have that connection there as well.
00:58:32.820 - 00:59:07.658, Speaker B: So this is nice. We're connected to the WebRTC server, we're connected to bootstrap servers, we queried the network, we walked the DHT. So we're also connected to a bunch of other random peers, either over TCP or WebSockets. So there's a lot going on there. Yeah. So the dig, if you add the text type, that will give you that dig. I won't dive into implementing your own DHT.
00:59:07.658 - 00:59:19.060, Speaker B: That's a lot of work. Oh, hi. You can see my chat. I better close this. I trust you all, but I shouldn't, so I'm going to close that. But yeah, so this is great. You can see you guys actually chatting in here.
00:59:19.060 - 00:59:56.480, Speaker B: So you're connected. You're on my robots. So from there, we have Discovery in place. What next? Right, so we've at the point, like, we can connect to peers, we can discover peers. We were able to chat with one another, which is cool. But again, we are checking all of our open connections and we're spamming everybody every time we send a message. This is not polite to our neighbors, so how do we make that better? And as we kind of alluded to, this is going to get into Pub Sub.
00:59:56.480 - 01:00:30.314, Speaker B: So there are currently two implementations of Pub sub, which is gossip sub and flood sub. Gossip Sub is widely supported. Now, in the various implementations, there is an update to the protocol one. One which is being slowly rolled out. Go already has it and then JS and I think Python are working on that and the other implementations will be working on it soon. And the nice thing about Gossip Sub is if you don't support it, it will actually fall back to flood Sub. So there's really no reason not to use Gossip Sub.
01:00:30.314 - 01:01:15.042, Speaker B: You should totally use it. If your implementation supports it, use it. It's much better. So what is pub? Sub? So Pub Sub is basically what we do is we create overlays on the network. And I'm going to talk specifically about Gossip Sub, because Flood Sub is not much better than what we had before because it floods the network, it will publish to every peer it knows and a lot of times we get messages back and it floods. It's very effective at getting data across the network, but it's very bad for the network. What Gossip Sub will do is it will actually develop kind of like handprint meshes over the network.
01:01:15.042 - 01:02:13.766, Speaker B: So as more peers join who subscribe to the same topics, it will actually connect to specific peers and develop a subset and then those peers will develop their own meshes. So you'll have multiple meshes, they'll communicate message across one another and they'll share messages to a subset of peers, not to all of them, just to a few. And the reason it's called Gossip Sub is because this has an intrinsic chance of failing to deliver a message, because if I'm only communicating to a few peers, we run the risk of not getting to everybody. So what actually happens is intermittently Gossip Sub will actually gossip to everybody in its mesh and say, here are the peers. I've recently seen any peer in its mesh. Or like it will also do that to random peers like Flood Sublike. So it picks mesh peers and non mesh peers, sends that out and says, I've seen these messages recently.
01:02:13.766 - 01:03:03.706, Speaker B: Those peers can then come back and request that message if they missed it. And so this is kind of like if you're familiar with IPFS, this is like bitswap of kind of having that exchange, like, do you have this thing? I want this thing. This is what Gossip Sub kind of enables us to do, to be a bit more polite to the network and only send messages to a select few by still having some guarantee that we're getting messages. So let's switch over and change this out. So what we're going to want to do is we can again, for the sake of time, I will just pop into the seven messaging session. So what we did is we stripped out our chat protocol. Now what we're doing is we're using this Pub Sub chat and very briefly we'll look at what that is.
01:03:03.706 - 01:03:50.394, Speaker B: We'll get into this like this messaging, but it actually uses a more complex message instead of just streaming data over because more complex applications will want to use more complex messages. But this is just a basic chat protocol. We won't dive into it too much. But this will go in, it will subscribe to the Pub Sub topic, which is going to be our chat topic, and then it's going to let us do a few things. Like if you are in the browser version, you can. Actually do name and then set your name because we're doing a little bit more complex messaging, which we'll walk through in a little bit, but that's basically what it does. And then when we get certain updates, we'll notify our peer about certain changes.
01:03:50.394 - 01:04:46.874, Speaker B: Like there's the ability to send stats of, hey, what type of node am I, who am I connected to? And this lets us build the edging that we're seeing in the graph that you can see in the browser version. So from there, all we did was we stripped out the we don't need the Lib PDP handle anymore because we're not running a custom protocol, we're building a custom Pub sub handler. And so now what we have is we have this Pub sub chat constructor. So we've called that and then it's going to take Lib P to P because it's going to bind on top of it. It's going to take the Pub sub chat topic and then it's going to take a handler. And that handler is just going to have like, we've customized that inside. And so this is what PubSub is going to call back with.
01:04:46.874 - 01:05:25.590, Speaker B: It's going to tell us who the message is from and then what the actual message is. And that message is a struct of information so we can go through there. And ultimately what we're doing is kind of binding like, okay, who's this message from? We want to update any user handlers and this is the ability to change your name when we get that notification. If it's a name change, we'll update that locally. Not the best way to do this in reality, but it just kind of showcases you how to go about doing that. And then again, because we're a node, we're just going to log that out to the console. Yes.
01:05:25.590 - 01:05:57.582, Speaker B: So Pub sub, are these signed? Yes, all Pub sub messages are signed by default. So you know who they came from, they're verified. You can turn signing off if you want to, but it's on by default. Encryption part works in this. So with Pub sub encryption, everything's already encrypted. Like at the very beginning when we set up encryption, everything that goes over Lippy to P is encrypted. So these Pub sub messages, when you sign that, right, so you're going to send the Pub sub messages.
01:05:57.582 - 01:06:45.250, Speaker B: What's going to happen is first Pub sub gossip sub is going to sign it and say, okay, this message is from me. Then it's going to fire it to the multiplexer, which is going to prepend any stream data to let the other application know like, hey, this stream that we've been working on, this message is part of that stream and then that goes into encryption. And so everything is unencrypted except right before it's going to leave your machine, we encrypt it and then that goes across, encrypted the other side. The remote peer is going to take that, going to decrypt it, run it through the multiplexer, pass that back to Pub Sub. Pub sub is going to look at it, it's going to check the sign, it's going to verify the signature. If that fails, it's just going to throw the message, it's just going to discard it. We don't tell you that it worked.
01:06:45.250 - 01:07:22.526, Speaker B: We didn't tell you that we discarded it. We just silently get rid of it because we don't want to let you know that that failed for security reasons. And then all we did is we changed our chat input handler so that we are actually running Pub SubChat send. So any message that comes in again from the command line, we can just do a Pub sub chat send. So if I run that and we are on O seven, I can hit that. Notice this isn't yet doing the name change. We'll look at that in a second.
01:07:22.526 - 01:08:20.542, Speaker B: So if you're trying to do a name change in node on this version, it won't work yet, but we can get in there and say, hello everyone. And so we're getting that information. So we've gone from direct message to now chatting over gossip sub. All right, so the next thing we'll look at is the last thing is really this idea of complex messaging. And so most of the messages you'll see in Lib PDP are protobuff based, but there's no reason you don't have to use protobuff. You could use JSON, you could use Seabor, like you can use any serializer that you want to, you could use just strings if you wanted to. But ultimately the thing that you want to use, which is why we use protobuff, is to get the deserialization and to account for size.
01:08:20.542 - 01:09:16.500, Speaker B: So you may want to take that into account when you're figuring out serializers to how much data you're actually sending over, the wider that will matter. So if we look at our we'll just go ahead and look at the messages very quickly. So our messages have a request type and it's just going to say, okay, this is a message, I'm sending a message or I'm letting you know that some of my metadata changed for stats. And so from there we've just got some fields defined. You can see that the type of the message is required because we need to let you know that we're sending something and then just some additional fields there. So send message we're including the data, which is the full Pub sub message, the full signed Pub sub message. And then we have the timestamp of when it was created and the ID of the message, I believe.
01:09:16.500 - 01:10:02.350, Speaker B: And then from there, update peer. This is just our very crude message for saying like, hey, I've updated my user handle, so now you can render me whenever I send new chats as that person. And we'll see that in a second. So if I jump back over here, I think the only change we actually need to make let me check this for to do is right here to change this, not that. Oh, my goodness. There we go. All right, so ultimately here when we get a message from the command line, rather than just sending it, what we want to do is we want to check command.
01:10:02.350 - 01:10:30.314, Speaker B: And if we quickly look at check command, I believe this is going to return us a bool. Yeah. So this returns a bool that says, hey, if there was a command, we're just going to return true. So that you can know to exit. So when we go Pub sub, check command, if that happened, just exit early. Otherwise we can go through and actually send the message. And so that should be it for setting that up.
01:10:30.314 - 01:11:20.010, Speaker B: So if I run O Seven messaging again, and I'll run that again locally here, then I should be able to send messages. Yes, hello. And then I should also be able to change my name. Oh my gosh, let me get rid of all these peer connections for a second so we can actually see this do. All right, so we've got that data. And then if I do name, which you can do also, again, in the chat above or in the browser chat, we can change our name. And I'm going to say, hey, it's me.
01:11:20.010 - 01:12:02.400, Speaker B: So we see over here, we actually are displaying just a system level notification of, like, so and so changed their name, like you might see in Riot or IRC or something. And then if I send a subsequent message, we can see now that's coming through. So we were able to pass this. So using that same chat protocol, creating a complex message, and then just sending that. So we don't have to have a bunch of protocol handlers. We have one that knows how to handle more complicated data. So we've went through the writing, the complex messaging, so we're going to kind of wind things down now.
01:12:02.400 - 01:13:24.402, Speaker B: And so really talking about looking at next steps, right? Because if we built this chat application, right now we're on the public network, but what happens if we're trying to find nodes that run our chat protocol, like Pub sub protocol, or who are listening to our Pub sub topic? If the network has millions of nodes or billions of nodes publicly, if you just join and then try to publish something, you're likely not going to find the person on your topic. So how do we broadcast these messages from a set of peers or millions of the network to kind of get back down, find who we really need to really want to send to? So this kind of brings us back to the Cademlia DHT. So what we're actually able to do is we create provider records. And again, in IPFS, these are content blocks, but you don't have to use it for content blocks. What you can do is you can say, hey, I want to take this Pub Sub chat topic that I have, I'm going to turn that into a CID, which is a Content Identifier. So you would just need to for us, this would be NPM install. CIDs is the module.
01:13:24.402 - 01:14:05.334, Speaker B: There is a CID module. That's not right. It's CIDs. Unfortunately the name was taken. But ultimately what we can do is that we can then take that string of hey lipidb chat, Pub Subtopic, pass it to the CID and then we can do a find on the network for that, right? So what we might be able to do is we take this lippity chat protocol and then whenever we subscribe to the topic, we could in theory query the network and register as a provider to say, hey, I am on this chat topic. Just like we provide content, right? I download the content, I'm now a provider, you can come get that from me. So here with the DHT, we could do the same thing.
01:14:05.334 - 01:14:45.630, Speaker B: I'm like, hey, if you want to be part of this Pub Sub topic, come connect to me, I am on this topic. So then anytime we go to additionally subscribe, we boot up, we can also query the network and ask who are providers, I want to join this topic. And so we can find those providers that way and then join the Pub Sub mesh from there, and then Gossip Sub, we'll take it from there. Once we find peers, gossip Sub also incorporates a peer exchange so we can learn about other peers who are also speaking on the topic. So that's a nice way of being able to handle that. And you can do that in a variety of ways. In the feature.
01:14:45.630 - 01:15:28.960, Speaker B: Again, I talked about kind of like Rendezvous Services and that's like a Federated version of being able to do this. We're going to do that hopefully in the next few months for JS. And the reason for that is, again, running a DHT in the browser is pretty expensive. So what we want to be able to do is actually use Rendezvous servers so that you can register on the Rendezvous Service, say, hey, I'm a provider of this, or query for those providers. So I'm going to kind of just open it up into questions now. And if I missed a question from before, please go ahead and repost that. Let me check.
01:15:28.960 - 01:15:49.138, Speaker B: You set up rules for caching topics and messages that your providers hold. A few messages. Yeah. So there's actually a in Pub Sub, there's a recently seen cache. So Pub. Sub already handles this because this is where the I want I have comes in. That cache right now is just a least recently used cached.
01:15:49.138 - 01:16:43.014, Speaker B: So once you have too many messages in there, it will drop out. But in theory you could totally fork Gossip Sub or build on top of Gossip Sub, extend it, and then you could build your own cache on top of it, I think three box. I'm not sure if they still do this. If I'm thinking about the right team. They actually create, like, cafes and because, hey, right now our chat isn't persisted, but what you can actually do is we can create that cache, we can create that database so that when you join rejoin again, you can get all that data back. And I'm not sure how Matrix is doing that, but I imagine they're doing something similar in terms of being able to exchange that chat. Any other questions? Again, if you guys are working through this and you want to go through the tutorial offhand, please feel free to ping me.
01:16:43.014 - 01:17:17.010, Speaker B: Like, you can ping me in that GitHub repo, hit me up on discuss. I will be in the hackaths chat over the duration, so you can also ping me there. And I am more than happy to walk you through this or talk about any more of these complicated topics. How about robustness in this whole system of protocols if we want better discovery? I'm not sure what you mean there. Could we unmute Siddhart?
01:17:20.490 - 01:17:31.634, Speaker A: Hello? Yeah, actually, I need to know the difference. The pros and the cons of the library.
01:17:31.682 - 01:17:56.126, Speaker B: P. Two P. The pros and the cons. Yeah. So if you look at the benefit of lipidop is really the peer to peer system, like having a decentralized system so that you're not relying on centralized infrastructure. The consequence of that is that it's slower than in some instances, a lot of instances, it's going to be slower than centralized. Right.
01:17:56.126 - 01:18:28.586, Speaker B: And centralized is easier. I can spin up a server or a multitude of servers behind a load balancer, and I can have tons of peers coming to me and getting that information. The consequence of this is that there's one person who has it. If you've ever been part of an early adopter of a program or an application, and then they just like, okay, we've ran out of money. We can't support this anymore. We shut it down. We shut all the servers down.
01:18:28.586 - 01:18:44.880, Speaker B: Like, all your data is gone, right. Unless they were kind enough to extract all that for you. So really what Lib PDP allows you to do is bring some of that back, make it peer to peer so that you're not reliant on these centralized infrastructures that can just shut down at any point in time.
01:18:45.810 - 01:18:47.120, Speaker A: Okay, thank you.
01:18:54.790 - 01:18:59.220, Speaker B: Any other questions? Just perusing for questions.
01:19:01.270 - 01:19:11.240, Speaker A: Yeah, I know people asked a few things throughout, so if we kind of jumped over it while Jacob was going through his tutorial, feel free to raise that.
01:19:19.630 - 01:19:34.618, Speaker B: I don't think there was a question earlier on circuit relays that I don't think we passed over trying to find it a little bit about the circuit and how it might be shared.
01:19:34.794 - 01:19:36.030, Speaker A: Go ahead, karate.
01:19:36.530 - 01:20:05.340, Speaker C: So the question I asked is, when you were setting up a circuit and then sharing that circuit between different peers and basically being able to create multiple connections across that circuit. Or then you talked about sharing the connection. So the whole idea of the circuit and what that was. And then all these other questions you can see are transport questions for me, like identification, key exchange, then encryption. And so links are fine, you don't have to answer them all here. I just also want to say I'm grateful and I want to thank you guys for making this a lot easier than a couple of years ago. So thank you.
01:20:05.710 - 01:20:58.422, Speaker B: Yeah, for relays, and this is one of the things that we're looking at, improving the relay infrastructure. One of the consequences for relays is that they are expensive to host, especially if you're doing something like file exchange with IPFS or filecoin like running a relays, you're running multiple peers, like file downloads through multiple peers. That's very costly. And so you don't really want to do that. And so one of the things that we're looking at doing is actually building limited relays. And so what they would do is you would be able to kind of rate limit peers and do things like WebRTC peer exchange, like we could do distributed WebRTC. So rather than using centralized Ice servers and centralized signaling servers, you could actually find relays on the network via the DHT or some other discovery mechanism.
01:20:58.422 - 01:21:39.814, Speaker B: You can connect to those relays, announce yourself. So, hey, I'm listening on this relay, then re advertise to peers on the network like the DHT or Rendezvous servers and say, hey, my new addresses are here, I'm now available at this relay. From there you can also say, okay, I want to speak WebRTC Star because I'm in a browser. So you'd be able to establish the connection over the relay, do a very minimal SDP handshake because that's not a lot of bandwidth. We can do that. Negotiate with other peers next to us who have some way of checking like Nat status or giving us SDP offers like decentralized Ice servers. And then we can do a connection upgrade to there.
01:21:39.814 - 01:22:18.660, Speaker B: So taking that relay and then do hole punching and then say, okay, I no longer need this relayed connection. Now I'm going to use the direct connection that we were able to just establish. And then from there we can back off and do file transfer over like WebRTC. But that would also work for anything like coordinating TCP simultaneous handshakes to whole punch TCP connections. So there's a lot there that we're trying to look at. How can we reduce the cost, because relays are so very effective at helping with this. But we also want to reduce that cost of not sending gigabytes of data over relayed peers, because that's not very nice.
01:22:18.660 - 01:22:26.870, Speaker B: Did I answer all your questions somewhat. If there's other follow up, please.
01:22:27.020 - 01:22:30.946, Speaker C: In Slack, I'll just put the question it's about the security stuff, noise and then SEC IO.
01:22:30.978 - 01:23:10.414, Speaker B: I'll put it in Slack from will be yeah, those connections will be fully encrypted. So why you're actually like sending the you're going through an intermediary peer, right? So there's always that concern of eavesdropping, but what you're doing is we have a relay, we have peer A, peer B. Peer A is going to establish a secure connection to the relay. Peer B is also going to do that. And then as part of this negotiation process, these A and B are also going to negotiate fully an encrypted connection over this stream. Right? So it's a virtual connection. So while it's running over it, all of that data is encrypted.
01:23:10.414 - 01:23:17.510, Speaker B: So there's no chance you can't manage the middle that it's secure.
01:23:18.970 - 01:23:20.086, Speaker C: Thank you very much.
01:23:20.188 - 01:23:34.698, Speaker B: You bet. Zoom is video streaming like a Zoom clone built on Lib BDP possible, yeah. So I hope I didn't jump over questions I might have.
01:23:34.864 - 01:23:36.926, Speaker A: Yeah, there were two, but go ahead with that one first.
01:23:37.028 - 01:24:04.686, Speaker B: Okay. Yeah. So video streaming you can do. Ultimately, the thing here is to be able to run data channels. And so there are things like, I think there's already somebody working on not in Lip PDP, but using WebTorrent to run video streaming. But it's entirely check out live peer. So it's entirely possible to do that, to run video streaming over.
01:24:04.686 - 01:24:52.194, Speaker B: That the big thing there, right, is making sure that you can get that direct connection. And so, like WebRTC, you would want to make sure that you're using data channels to send this information. And there are streaming services that are already using WebRTC for video conferencing. Talkie is one I'm forgetting one of the other ones. But these applications where you're able to just open up a browser window and you immediately get end to end encryption, WebRTC, video sharing, and that's all peer to peer. Granted, there is that initial SDP exchange, so you have some central server, but in theory, that can be entirely done. Lippy to P, like you could use in the future, distributed WebRTC signaling to establish that data channel connection, and then you can stream.
01:24:52.194 - 01:25:23.310, Speaker B: Yes, Jitsi. Thank you. So Jitsi is the other one that I was thinking about, and sorry for skipping some of these questions. Go back. Can you briefly talk about exchanging streams over Lib P to P for use cases like live streaming? I think we kind of talked about that. Hopefully I answered your question. If not, feel free to follow up there from YouTube chat, what level encryption is used when the message leaves the client.
01:25:23.310 - 01:25:55.382, Speaker B: So I assume you're talking about the stream encryption. And this is noise or TLS, depending on your security transport. Right. So all of that data, whether it's pub, sub, or direct messaging before it leaves your node, it's getting encrypted with noise or Secio. And so depending on which protocol you're using, that could be symmetric or asymmetric encryption. It depends on the transports, and so those will evolve over time. But you can change those.
01:25:55.382 - 01:26:23.900, Speaker B: The noise protocol is the framework is open. We have a spec for the version of it that we've implemented. And so you can actually go look at the spec, see what's going on in there, look at the encryption patterns there. But yeah, it really depends on what version of crypto you're using. Is lit p to p. I think this is the next one. Lib PDP on mobile phone.
01:26:23.900 - 01:27:09.976, Speaker B: Doable any existing team working on that already? There are a few people working on it. Textile is actually working on they have some versions of Android and iOS for Textile. So that's like, IPFS lite. So it doesn't bring everything that IPFS brings, but it has some portion of IPFS, and then that's running Lib PDP. So it is possible there's like a Java implementation, which you'd be able to use with Android. And then for JS Lib PDP, what we're working on is better support for React native, because there are some folks who are going to be building more React native apps. So the big thing there is really, again, hooking up the Lib PP itself, bundling that in React isn't too big of a deal.
01:27:09.976 - 01:27:48.810, Speaker B: We just have to get past the JavaScript locals and then hook into writing those custom transport or those transport bridges to get TCP or UDP from the phone itself, from mobile itself. And so that's really what we're looking at now, is like, how do you bridge the transport of those modules? Do you pre use member list technique more than Libidp during implementation file exchange? I'm not sure what you mean there. If you could expand on that. Elmo.
01:27:50.210 - 01:27:51.054, Speaker A: Hello?
01:27:51.252 - 01:27:52.000, Speaker B: Yes.
01:27:52.370 - 01:27:59.150, Speaker A: Okay, now I have the member list technique.
01:28:01.010 - 01:28:02.000, Speaker B: It's against.
01:28:03.970 - 01:28:34.060, Speaker A: The library PTP. It's more faster than library to be, but maybe it's not secure more than the library to be. So I need to know more from you, more details about the more information and details about the security in the library. P. Two P.
01:28:36.270 - 01:28:48.670, Speaker B: Okay, I will try to answer this as best I can remember. This technique, are you talking more about, like, permissioning for file exchange?
01:28:52.230 - 01:28:53.700, Speaker A: It's a secure channel.
01:28:58.150 - 01:29:39.214, Speaker B: Okay, well, so all communication in Lipidp is secure. So really the question is, do you want your application to be on the public network? Oftentimes this just isn't the case. You might want to do kind of there's a couple of things you can do. You can run private networks that don't connect to the public network at all. You can also encrypt those if you want with In Lipid to P. By default, we have support for symmetric private network keys. So you can actually add a pre shared key to your swarm and everything that goes over the wire, like, there's no leak of multi stream or anything.
01:29:39.214 - 01:30:26.654, Speaker B: Everything that goes over the wire is encrypted with that private shared key. So you can ensure no one on your network is able to talk to a public node, and no public node is able to talk to your network. So as long as those pre shared keys don't get shared publicly, you can encrypt that entire network. If you're less concerned about like, okay, I'm okay being open to the network, but I really don't want to join the public network, but I want people to be able to find me. This is where you kind of get into some things that we've been looking at with the DHT of doing, like, running multiple DHTs. So in the future, we'll probably look at Lib PDP being able to run multiple DHTs. So what you'd be able to do is like, okay, for our application, we're going to run a DHT just for us, and then we're also going to run a DHT on the public so that people can find our application.
01:30:26.654 - 01:31:07.610, Speaker B: You join the public network, figure out, okay, I want to join Live Peer, this app, so then I can find peers who support that and then join that network and mesh in. So this is kind of like this is really where I think the peer to peer network should evolve over time, is being able to I want to join the public network, and from there, I want to find the peers that I care about and connect to them for network security on universities and things like that. Doing full network privacy encryption, that's a lot more valuable. But if you want to be able to at least kind of stay public, then that's probably the way to go, is isolate those DHGS.
01:31:08.030 - 01:31:09.340, Speaker A: Okay, thank you.
01:31:13.810 - 01:32:06.170, Speaker B: What is the major difference between Lipidp implementation on IPFS versus on Ethereum? So they're not really that different. So ultimately the big differences there are what's built on top of him. So, like I talked about at the beginning, like, Disk V five discovery, that's the discovery mechanism that Ethereum uses to join the Ethereum network, and it's not necessarily restrictive, right? Like, you could build an app on Jslip to P to connect to Ethereum and get the modules and connect to the right place for JavaScript. ChainSafe has a Lodestar, which is a client for Ethereum. And the other implementations have various versions of Ethereum clients, but these are all built based on Lip PDP. So noise is the same. They might use different versions of DHTs, like, might bring their own DHTs.
01:32:06.170 - 01:32:40.634, Speaker B: So that's really it. The core of Lip PDP doesn't really change. And that's why Lip PDP, we are driven by you guys wanting to do things, whether it's on IPFS or Ethereum or anywhere else. That's what we're trying to solve. Originally, Lip PDP actually came bundled in IPFS, and when we built JS, we actually built Lipdb separately. And then we ripped the Go version out of IPFS because this is a protocol that's valuable to anybody building on public networks. So that's ultimately what we wanted to do.
01:32:40.634 - 01:32:45.980, Speaker B: And we've been working with the Ethereum community to make sure Lib BDP works for their needs.
01:32:50.590 - 01:33:14.674, Speaker A: I think that might be it and we're definitely well over time. So I'm going to wrap it there. No, it's not you. This is all great, but we should probably not make this a two hour video. That was really great. I'm glad people got to follow along and see your process for all that. There were some people asking about where they could actually find the repo for this.
01:33:14.674 - 01:33:17.560, Speaker A: Is that just linked to the README you had?
01:33:20.090 - 01:33:22.680, Speaker B: Just need let me pull that up.
01:33:24.650 - 01:33:55.786, Speaker A: I guess you could just drop it in the Slack channel and that's probably the best place to find it if people are still looking for it. All right, with that, I think we can wrap. Thank you again, Jacob, for sharing some of your knowledge and the work you've done. Much appreciated. We got to get more people to this is a constant issue nobody wants to put on their video. So it looks like there's only four people here, but we had 50 earlier and looks like 30 people stuck it out to the end. So good job, folks.
01:33:55.786 - 01:33:59.214, Speaker A: Oh, there's Andrew. Andrew is jumping back in. Give the golf clap.
01:33:59.262 - 01:34:06.750, Speaker C: Yeah, that was years of me reading stuff that he just compressed into 2 hours. Yeah, that he saved us all a lot of trouble.
01:34:06.910 - 01:34:08.100, Speaker A: Like time travel.
01:34:09.270 - 01:34:10.020, Speaker C: Yeah.
01:34:11.130 - 01:34:41.150, Speaker A: Again. Thank you, Jacob. And like I mentioned, he'll be available in The Slack with links and additional feedback as we move into the actual building part of Hack FS, which consequently starts Monday or after the kickoff at twelve noon. I believe the actual hacking kickoff is at 130 p. M. Eastern. So that's when everybody can open their repos and start hacking.
01:34:41.150 - 01:34:58.002, Speaker A: I think that's it. If you haven't staked, make sure to stake. We've got one more event, like I mentioned, the brainstorm session with Juan tonight and hopefully we're going to wrangle a couple more people. It's going to be fun. Tonight at 08:00 P.m. Eastern. And I think with that we could wrap.
01:34:58.002 - 01:35:01.890, Speaker A: Thank you, everybody. See you in slack. Bye.
