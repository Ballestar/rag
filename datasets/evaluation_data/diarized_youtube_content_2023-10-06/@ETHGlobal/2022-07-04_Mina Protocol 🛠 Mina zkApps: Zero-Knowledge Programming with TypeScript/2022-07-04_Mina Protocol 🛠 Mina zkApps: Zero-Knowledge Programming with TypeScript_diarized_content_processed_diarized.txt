00:00:06.250 - 00:00:44.780, Speaker A: Hi guys. My name is Jack and I do developer relations at O One Labs, which is the company that incubated the Mina Protocol. And today I'm here to talk to you guys about the Mina Protocol and ZK apps. For people who don't know, the Mina Protocol is a layer one blockchain that is kind of built with zero knowledge proofs at the center. And so this impacts both the way that the blockchain itself works in terms of consensus and stuff, and also the way that developers build applications for the blockchain. And so we'll kind of get into that in a minute. Yeah, so hopefully by the end of this presentation, you have kind of a sense for what Mina is and also a sense for how you might go about building an application on Mina and why you might want to do so.
00:00:44.780 - 00:01:40.090, Speaker A: Here's kind of our run of the day. We'll talk about Mina and Zkaps architecture, then Snarky JS, which is the TypeScript library that we use to write zero knowledge proofs for Mina. We'll go through a Hello World example and then I'll direct you to places where you can learn more and we'll do a quick questions and answers. So first we'll start with Mina. Mina, probably you've seen the marketing. Our marketing is full of this idea that we're 22 KB other blockchains grow because you have to remember the entire history of transactions in order to be able to kind of verify a recent final state. Mina works differently because it uses recursive zero knowledge proofs to basically prove that all of the previous transactions are valid and then prove that all of the new transactions are valid inside of a zero knowledge proof that can then be put inside of another zero knowledge proof and so on and so on.
00:01:40.090 - 00:02:14.710, Speaker A: And so this is useful because the zero knowledge proofs are fixed size. They always stay well. The zero knowledge proof and a couple of other things total to 22. This is useful for some things like bridging. We'll touch on this in a minute. But it's also kind of just a good thing to keep in mind as we go towards how you build applications using Mina and why you might want to. Because the benefit of Mina is not just that it's very small, but also that it enables a huge amount of things that you couldn't do on a more traditional blockchain.
00:02:14.710 - 00:03:05.542, Speaker A: Mina is succinct, it's small, uses recursive ZK snarks to compress the blockchain into a single ZK snark. And this proof system that we use is called Kimchi. It has some kind of qualities from plank and halo two and then some things that are kind of all its own. It's trustless, it's recursive, and it's pretty efficient. It has some cool custom gates that let you do some useful things really efficiently. And so how does an Ethereum DApp work? Well, you tell Ethereum what you would like it to do and it does this on your behalf. And the result of that is that anything that you want to do on Ethereum is going to be public.
00:03:05.542 - 00:04:08.860, Speaker A: And if you want to kind of make it private, you have to really think a lot about how you're going to do that. There are ways to obfuscate the public data, but it's usually not simple and it's pretty constricting in terms of what kind of applications people have developed over the last five years. Mina ZK apps work significantly different. The computation actually happens off chain. And so you write your Smart contract in Snarky JS, our TypeScript library that I'll get to in a second and the user just runs it like they would run code that's a part of a web app, like, well, how do you keep this secure? How do you guarantee that users aren't doing things that they're not allowed to do? And that's what we use our zero knowledge proofs for. So when you interact with Mina, what you're doing is running the code yourself, you're running your transaction on your own computer, and then you're generating a proof and the relevant state updates, which can be nothing. You cannot update the state at all, or you can update the state depending on kind of if that's something that's useful to you or not.
00:04:08.860 - 00:04:46.742, Speaker A: The advantage of this is that it's scalable in the sense that there's no gas. Just the only thing that the Mina blockchain is doing is verifying your proof. And that's the same amount of work every time and it's the same size. Oh, cool, okay. Yes, that's the same amount of work and it's the same size. And so this means that every transaction, well, every ZK app transaction costs basically the same amount. It varies based on market demand and congestion, but there's no gas model.
00:04:46.742 - 00:05:34.870, Speaker A: And so you can do a little bit of computation and that will cost the same amount as doing a huge amount of computation. The only limiting factor is how long you want to sort of wait for your computer to do things on its end. It also is private because you don't have to send any of your information to Ethereum. This makes it really kind of easy to see that if you do all the computation on your computer and you send a very small zero knowledge proof and you've done a lot of computation, well, there's no way to commit to all this computation inside of this tiny zero knowledge proof. And so you have privacy by default and then you can kind of open things up as much as you want to. So you can start with a level of privacy that is sort of so extreme that it basically makes the applications useless. And then you can go all the way to this place where you just make everything public.
00:05:34.870 - 00:06:20.982, Speaker A: And so you can pick anywhere in the middle on that kind of slider, whatever fits your use case well, yeah, I think I kind of touched on this. But the off chain execution is basically unlimited. It's only limited by the kind of computer hardware that you have that's generating the proof and the amount of time you're willing to wait. So what is this useful for? So here's kind of an example of something that Mina can do that is kind of unique. And so this would be to prove that I have more than $5,000 in my bank account without revealing the exact amount or any identifiable information about me. And so this is useful because you might want to kind of just use one quality of a piece of data without having to give that data to everybody. And in the case of a blockchain, you know the entire world.
00:06:20.982 - 00:07:31.638, Speaker A: And so you can define a smart contract that will go through your financial data and prove that you have more than $5,000 and not disclose the exact amount of money that you have. You can write a program that will basically only throw true if you have more than $5,000 and you don't have to run that computer I'm sorry, you don't have to run that program on somebody else's computer in order to prove that it's ran correctly. So something else that's interesting about kind of Mina and its succinct quality is that you can actually bridge Mina state to other chains much easier than you can in other blockchains, where the total size of the chain grows significantly over time. And if you're interested in that, come talk to me at our booth. We'll be here the next two or three days. So Zkapp is what we call these decentralized applications that use zero knowledge proofs. And this word kind of includes the smart contract and the UI.
00:07:31.638 - 00:08:26.974, Speaker A: And this is cool because as I said, the smart contract is written in TypeScript now, which means that you can actually just write it in TypeScript, publish it as an NPM package, and then import it into your front end and just deploy basically your front end. So a Snarky JS contract is compiled into basically two artifacts. The code itself remains. And this is like you actually run the code that the contract developer writes directly when you use Snarky JS. But in order to constrain this code and make sure it's executing correctly, we use Approver function, which is something that runs locally, does the computation, and then generates a zero knowledge proof that it ran in the correct way. And a verification key, which is sort of like a commitment to the state of the code at the time that you publish it to the blockchain. So this is how you ensure that nobody's changing what the code does.
00:08:26.974 - 00:09:31.646, Speaker A: It's kind of how you identify it. And when you deploy the verification key to the Mina blockchain, it creates something called a Zkapps account, which is just like a normal Mina account, except for that the way that you can interact with it is now determined by whether you can create a valid proof and then you would include that with your transaction. In order to kind of just like in order to be able to interact with the account at all, you have to have a valid proof. And so you can set the account up in such a way that you'll only be able to generate a valid proof in the event that you meet some specific qualification, that would be basically what you have programmed the code to do. So, yeah, you can see here, I guess, a demonstration of that. You send a transaction and it updates the verification key for one of these accounts. And then you have a smart contract on Mina and you can't send the transaction without a valid proof and you can send the transaction with a valid proof.
00:09:31.646 - 00:10:19.182, Speaker A: And so every ZK app is compiled into a program which has the input arguments and the on chain values. So these would be the values know you're taking either from users or from the current chain state. And then outputs, which will be a list of updates to perform and a list of preconditions related to the on chain state. And so when you run the smart contract, if you run it correctly, you can get a valid verification key and I'm sorry, proving key, and you can send that to the Mina blockchain along with the state transitions that you want to take place. And as long as the zero knowledge proof is valid, mina will update these states. Okay, so kind of getting into Snarky JS a bit more. Snarky JS is written using TypeScript.
00:10:19.182 - 00:10:47.654, Speaker A: It's a TypeScript library. And you import it just like you would any other TypeScript library. In practice, it feels a bit like react to use. It feels kind of like a framework for defining zero knowledge proofs. It's very easy to use and it fits in nicely with existing tooling, which is really nice because a part of our vision for Snarky Jess is we're really ecosystem focused. We want to make it so that people can write code that other people will use. That way, if you have somebody who's really good at cryptography, they can write a library.
00:10:47.654 - 00:11:30.106, Speaker A: And if you have somebody who's sort of more entrepreneurial, they can use this library to make an application. JavaScript. And kind of the ecosystem around it has really kind of led the way there in terms of how do you get a bunch of people sharing as much code as possible. So our developer tooling is called the Zkap CLI, and you can just NPM install G, the Zkap CLI and ZK project name and you'll have a project ready to go. It'll scaffold everything and set up testing, linting, all the stuff you need to deploy to the chain. It's very straightforward to use and yeah, you can clone it.
00:11:30.128 - 00:11:30.700, Speaker B: Now.
00:11:34.270 - 00:11:46.960, Speaker A: Zkapps are written in TypeScript using Snarky JS. We use existing open technologies. It runs in the browser and node JS. You can use existing JavaScript and TypeScript libraries and tools. We kind of touched on this. You won't be able to import.
00:11:49.490 - 00:11:49.806, Speaker B: I.
00:11:49.828 - 00:12:39.002, Speaker A: Don'T know, like a JavaScript cryptography library or something because it's a bit like how you can't import Jquery stuff into a react project. It kind of has to speak the same language, but you can still use a lot of the stuff that you'd want to. You have really good Vs code support, IntelliSense and copilot work. That's cool. And so okay, what kind of data type do we use when we program these zero knowledge smart contracts? We use something called a field, and this is an element of a finite field, which is kind of like a math idea that's not super important to get way into. For most practical purposes. It'll end up feeling a lot like a UN two five six, but it's a little bit smaller.
00:12:39.002 - 00:13:28.314, Speaker A: So it's basically an unsigned integer with some added caveats, which are that you can overflow and division works a little bit differently. But we have to use this data type because it's what makes the zero knowledge proof possible. Yeah, so we went through this, it's the field type in Snarky JS. And then in addition to this, on top of this field type, we've implemented some of the other types that you might like, like booleans unsigned integers. Actually we have signed integers and we have something called circuit value, which you can use to kind of describe even more specific data types that you might want. Functions are just normal TypeScript functions. We use a decorator in order to kind of tell Snarky JS that, hey, this is something that's going to be called by a user and data are also normal TypeScript classes.
00:13:28.314 - 00:14:13.200, Speaker A: So you can see sorry, yeah, we just have a function here. Pretty simple. The only thing that's interesting is that instead of using the JavaScript infix operator, that would be like the plus sign x space plus space one, we have to call this add method. And this is because Snarky JS needs to keep track of what we're doing and we need to be working with this field type. So JavaScript doesn't have a field type and so we have to call this method in order to be able to do addition or multiplication on this field type. Other than that, it's pretty much what you would expect though. So yeah, we'll walk through a hello world example really quickly and then probably have some time for questions.
00:14:13.200 - 00:14:56.940, Speaker A: So we'll write a smart contract with a single state variable named x and it will have a method update that will let us replace X only with its square. And we can only update it if we control a secret admin private key. So this is kind of like yeah, this is how you gate who's allowed to call specific things. It's sort of a more general model than probably people are used to with ethereum. So if X is equal to three and we call update nine with our secret key, then this should work. And then if we call update 81 this should work. And if we call three to nine that works, but nine to 75 this won't work.
00:14:56.940 - 00:15:51.680, Speaker A: So to write a smart contract, we just extend this smart contract class in Snarky JS. So we're making a smart contract called Hello World and ZK Apps. By default they're associated with eight field elements that are stored on chain. And so we don't have a lot of on chain storage by default because we expect that people will use these field elements to store commitments to off chain storage or storage on IPFS. You can put the data kind of anywhere you want, you just need to store a commitment to the data on chain. And so we use this state field decorator to basically say we're making this variable X and we want this to exist on chain as a field type. So we could replace like field with bool or something else and that would work as well.
00:15:51.680 - 00:15:58.080, Speaker A: And yeah, override deploy to configure the smart contract, that's not super important.
00:16:00.850 - 00:16:01.166, Speaker B: In.
00:16:01.188 - 00:16:42.380, Speaker A: This case, initializing this date. Oh, I see. In this case, this deploy method is the method that's used to put the smart contract on chain. And we're calling this X set to three. So we're going to take this state here X and we're going to set it to three as the contract is deployed. And then we also have this party set value, this self update delegate admin private key. So this is a method, basically we're ensuring that the person who calls this contract will have the private key.
00:16:42.380 - 00:17:32.910, Speaker A: A smart contract can contain multiple methods, each will have its own logic. So here we've got this method. Decorator in front of update means that update will be callable by users and it takes in a field element called squared and then also a private key called admin. And so these describe how people can interact with it once it's deployed. And so in this case, we'll take X, we'll get it from the onchain storage, we'll store it in the variable X, we'll square it using the square method and then we'll assert that it's equal to its square. And then we'll set X on chain to squared. So if you were to pass in an X that wasn't the square of the prior X, this assertion would just fail and it would be impossible to generate a valid zero knowledge proof.
00:17:32.910 - 00:18:21.600, Speaker A: So finally we'll take this admin private key and we'll actually convert it to a public key. So this is a totally constrained method. So we can pass in a public key directly into a method that we're calling because it all happens on our local machine. And then we can compute the public key from that. And then in order to make sure that only the person who owns the associated private key can call it. We just use this account delegate assert equals admin private key. And so this basically means make sure that the person who's calling this is using the public key associated with the private key that we pass in.
00:18:21.600 - 00:19:16.910, Speaker A: And so what happens under the hood when we run update nine with our secret key? We run some code in the method with some arguments, and the result is that X goes from three to nine. And so that's kind of like what changes on chain. And then for our preconditions, we're making sure that the admin secret key is associated with the admin public key and then that the person calling it has the admin public key. So yeah, this is kind of what these contracts end up looking like. We define a bunch of state up at the top, then we define a deploy method. So this is what choose to deploy the contract. And then we have methods that are callable by users which are preceded by this method decorator.
00:19:16.910 - 00:20:01.506, Speaker A: If you're interested in learning more, you should scan the QR code because it's cool and it's full of good information and yeah, I'll give everybody a second and then we can open it up to questions. Oh, it's not working. That's not awesome. Okay, yeah, go by the booth and scan the QR code on the banner. Sorry about that, I must have broke that at the last second. So here's the information that wasn't from the QR code. So we have a discord with a channel called Zkap Developers.
00:20:01.506 - 00:20:29.620, Speaker A: This is a great place to get information if you're interested in learning about zero knowledge applications and starting to develop them yourself. And then we're also on Twitter and we have our GitHub repositories. And of course the main thing is the docs. If you just search Mina docs in Google, you'll get our docs and we have tutorials and some explanations of kind of what's going on and how to get your head around it. So that's it, I think. Does anybody have any questions?
00:20:34.870 - 00:20:37.458, Speaker B: Yeah, I guess in your example you.
00:20:37.464 - 00:20:40.370, Speaker A: Were talking about computation verification.
00:20:49.520 - 00:20:50.124, Speaker B: Yeah.
00:20:50.242 - 00:21:01.810, Speaker A: Okay, so the question is, you know, we're talking about computation on chain and off chain and where does your knowledge come into this? What can the prover hide from the verifier? I got that. Okay, cool.
00:21:03.620 - 00:21:03.984, Speaker B: Yeah.
00:21:04.022 - 00:21:49.224, Speaker A: How this ends up working is basically when you create the zero knowledge proof and you send it to the chain, that proof really just says, I did some computation correctly. It doesn't really disclose anything about the computation. And then you can kind of choose what you would like to disclose about the computation. And so if you have something like, I don't know, let's say that you want to prove that you have the private key associated with like an ethereum account, you couldn't do this on another blockchain very easily. You could sign something. Actually, sorry, that's a bad example. Okay.
00:21:49.224 - 00:22:38.530, Speaker A: A better example is a sudoku. So let's say that you have a sudoku and we've committed to the puzzle on chain and we want to prove that we've solved the sudoku. But we can't send the solution of the sudoku to the chain because then it would disclose what the solution of the sudoku was. And then people wouldn't be able to use our cool sudoku app to get an NFT by proving that they have the right solution. So in this case, what you would do is you would prove that you did the correct computation to figure out that the sudoku is valid, but you wouldn't actually disclose what sudoku you input. And so this way you can prove, I've solved the sudoku, but you don't have to tell the chain how you solve the sudoku. And that way this game can stay fun long term because after one person solves it, it's not solved for everybody.
00:22:38.530 - 00:23:39.934, Speaker A: Verification. Yeah. So the question is, is the verification sort of a claim that something is true as opposed to, I did all this computation and I'm showing it? The proof is basically a claim that you did the computation correctly without having to show it. So you can kind of think of it almost like imagine that doing the computation correctly gets you the digest to some chunk of data. When you do the computation correctly, you can kind of figure out what one of these good pre images is. That is basically the zero knowledge proof. And then if you do the computation incorrectly, then you would just have to guess over and over and over again in order to find like a fake zero knowledge proof.
00:23:39.934 - 00:23:42.660, Speaker A: Basically, yeah.
00:23:44.150 - 00:23:45.010, Speaker B: Yep.
00:23:55.100 - 00:24:50.830, Speaker A: Um, so the there's kind of like three parts. So we have like a Plonker Arithmetization scheme with some cool custom gates, and then we use the inner product argument that halo too, and bulletproofs use. And then we have something called pickles. And pickles is kind of the thing that wraps this whole proof system that allows us to do recursion well, and it informs the design of some of the other parts of the proof system, too. But really what it's doing is it's basically you kind of have two proof systems, and one proof system is able to generate proofs that are easily verifiable in the other proof system, and the other proof system is able to generate proofs that are easily verifiable in the first proof system. And so what happens is you generate a proof and it's verified in this other proof system, and then this proof generates a proof which is then verified in the first system. Again?
00:24:53.460 - 00:24:54.210, Speaker B: Yeah.
00:25:00.830 - 00:25:02.300, Speaker A: I'm sorry, say again?
00:25:08.390 - 00:25:08.802, Speaker B: Yeah.
00:25:08.856 - 00:25:57.270, Speaker A: No, so Kimchi does not kimchi is our proof system. I don't know, there might be some way to make something like that possible, but it's not like it's not something that intuitively makes sense or would be an improvement, given our situation. Yeah, so Snarky JS is calling something called Snarky, which is an OCaml library that's basically working with stuff at a pretty low level underneath that.
00:25:57.960 - 00:25:58.276, Speaker B: Yeah.
00:25:58.298 - 00:26:16.340, Speaker A: And so come to the booth, and we can talk a bit more about that. And yeah, I might even have to. Probably somebody on the crypto team at Minan I'm sorry, at Owen Labs knows better than I do. Oh, yeah. We'll be here all night, all day, all night, all the days, all the nights.
00:26:18.280 - 00:26:20.710, Speaker B: Yeah. Cool.
00:26:22.200 - 00:26:28.240, Speaker A: I don't know. There might be more questions, but I think I'm out of time, so yeah. Thanks, guys. Bye.
