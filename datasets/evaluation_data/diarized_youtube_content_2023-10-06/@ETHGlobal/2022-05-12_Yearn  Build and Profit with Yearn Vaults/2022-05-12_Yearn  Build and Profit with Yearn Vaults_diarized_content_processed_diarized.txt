00:00:21.030 - 00:00:34.140, Speaker A: Okay, we can get started now. So welcome to our last day of workshops. Right now we're going to be having a talk from Skeletor from Urine about build and profit from Urine vaults. He could take it away now. Thank you all for joining us.
00:00:35.430 - 00:01:33.854, Speaker B: You hey, guys, thank you for the introduction. Okay, as the presenter said, we are going to go through a few examples of how can you build on top of Urine V two vaults. So Urine V two vaults, as you know, are like the current vaults that we have right now. They are not a part of the new EIP, obviously. The EIP 46 26, that is for yield tokens. What we're going to do here is go through some examples of how to wrap a V two vault for it to be compliant with the new standard and how you can build on top of that or use that to integrate with different type of integrations that you might like or build so you can get some profit out of that. This profit being fees, et cetera.
00:01:33.854 - 00:02:24.110, Speaker B: And also as we earn, if you basically root funds through us, you can enter into, let's say, a B, two B system where you can get kickback out of the funds you deposit or your users deposit through your protocol. Okay, so let's start. So basically, I'm not sure how familiar are you guys with the V two code, but basically what it does is it takes a token. So this can be, let's say, dai, so users can deposit die into the vault. The vault will issue some shares for them depending on the current price per share. Those shares are also an ERC 20 token. Users that have these shares can later redeem those shares if their price per share increases.
00:02:24.110 - 00:02:58.090, Speaker B: So the vault is profitable. The amount of underlying or in this case die that they will get out of that will be higher. So basically, this is what we count as APY. So this is a simple wrapper. Actually, most of the code is inside the vault code base. This is a separate contract from the vault. So whenever you initialize it, you need to pass an argument saying, okay, which vault are you wrapping? Then it grabs automatically in the constructor.
00:02:58.090 - 00:03:45.680, Speaker B: Well, it sets the name and symbol because the EIP for 626 requires the yield token to also be an ERC 20. So here's a difference. I'm not sure if any of you watch the previous workshop, but in the previous one we had a wrapper that was not actually issuing new shares on top of this. We'll go into detail a little bit later about this. But the thing is, this wrapper will hold default shares and issue like a copy of new shares to the deposit or the user of this wrapper. So, yeah, it's pretty simple. You initialize with a certain vault that cannot be changed, obviously.
00:03:45.680 - 00:04:30.038, Speaker B: And then you have some utility functions, basically to see what's the total supply. So this is basically your shares token. As he says, it's ERC 20 token compatibility. And here comes the fun part. So whenever a user wants to deposit into your wrapper, obviously it would need to approve the underlying token, in this case die. So what we would call here, you have two separate functions for everything. So basically when you call deposit, you are working with the underlying asset.
00:04:30.038 - 00:05:24.202, Speaker B: So in this case die. So this would be like 100 die or something like that. But if you call mint, which is also like a kind of deposit type of function, but you are working with shares. So you can say, okay, give me 100 shares and I don't care how much die you drain from my allowance, just I want 100 shares. Both of those functions use the same internal function, but obviously the mint function just checks. Okay, if you want 100 shares, how much assets would you need? So if we go to this deposit function here, it's like almost at the bottom of the file, we can see that it receives an amount obviously like 100. I the receiver, that can be another account.
00:05:24.202 - 00:06:15.402, Speaker B: So it doesn't have to be the message sender and the depositor that it's the message sender. So this is where we are going to be taking the tokens from. So here we save some stuff to memory just to save some gas. We check if the allowance to the vault is correct because obviously we need the vault to be able to also drain tokens from us. This can be done here, which is basically we are making the first depositor pay for this allowance assignation into the vault. But yeah, this can also be done in constructor or in any other place. So the first thing we do is we take the tokens away from the depositor into this wrapper contract.
00:06:15.402 - 00:06:50.002, Speaker B: Obviously the amount that required, we check the allowance of the vault as well. Oh, sorry. Okay, I messed up. Okay, this is the approval and this is just to know if the because you can pass the max amount. So if you send okay, I want to deposit everything I have. You need to check if everything you have is either the amount of your balance of the token or the max amount of the allowance. Because a user might have a million die but only allowed 100 to be spent.
00:06:50.002 - 00:07:15.050, Speaker B: So we will take the allowance. So 100, or if you have max allowance but you only have 100 tokens, obviously we won't try to deposit all your allowance. We'll deposit the amount, the balance you have. Sorry for that. So then we just transfer the tokens. This is where the first depositor pays for the approval into the vault. And here comes the interaction with the underlying vault code.
00:07:15.050 - 00:07:53.562, Speaker B: So since the vault deposit doesn't necessarily take the entire amount you are depositing because it can. So the vault has a max amount of tokens that it can take. So let's say it depends on the current depth or the current assets the vault can take. This is kind of a security measurement we do at yearn. So not all vaults can take infinite amount of money. We constantly bump the amount of those. But let's say a user wants to deposit a crazy amount of money.
00:07:53.562 - 00:08:46.510, Speaker B: The vault might not be able to take all the amount that it wants to deposit but might want to take some of that. So we need to check how much it actually took for V two vaults. The only way sadly to do this is check the before and after balance. Like we check how much balance of token we had with deposit, we check how much balance of token we have after that and then we know how much it actually used and also it returns them into shares. So this is easier. Okay, these shares that have been minted from the vault are now being held in this contract. So in the wrapper this is like a big difference with the other presentation we did a few weeks ago here.
00:08:46.510 - 00:09:42.778, Speaker B: You can also avoid doing this and just send the shares back to the depositor. So you can just use this wrapper as a router and obviously this won't be like fully ERC, 46 26, 26 compatible because you are not behaving as an ERC 20 but who cares? Whatever is easier for you. Yeah, in that way also users can take their shares out of that and do other stuff. But obviously accounting becomes a little bit harder for you as an integrator because you don't know which shares actually came from your protocol. This way all the users are deposited through your protocol, you know, because you have the shares in this wrapper contract. So it's easier also for you to do the accounting. So yeah, then we check how much was deposited.
00:09:42.778 - 00:10:36.674, Speaker B: This is useful here because we will refund you all the tokens we didn't use in the deposit. So let's say you sent 100 vote, only was able to take ten. So we will refund you 90 tokens and then we mint the new shares. So these new shares are actually the vault wrapper shares which if you remember here, we assigned the name for the ERC, 20. So those will be like wide eye for 626 tokens to the receiver. So this can be either the message sender or somebody that the message sender was assigning as the receiver of the new minted shares and that's it. So then if we go back to the top so we went through deposit mint and so withdrawal and redeem is the same basically.
00:10:36.674 - 00:11:25.362, Speaker B: So on withdrawal you say hey, I want X amount of die and on redeem is hey, I want to redeem X amount of shares. So the withdrawal here basically takes the asset. So 100 die. Who will be receiving those die and who is going to pay for that. And redeem is the same. The only difference is that we have to call first preview redeem to know if, to know how much underlying assets those shares that the user is trying to redeem actually are worth. Then we go to withdrawal here at the bottom, right below deposit and it's practically the same.
00:11:25.362 - 00:12:11.040, Speaker B: So we check actually how much available shares the vault can actually basically burn. Yes, this repo is public. I will share the link afterwards. It's either like the minimum, so the amount of shares the user has or the max amount of shares the vault can take. So here's a cool thing, which is, if you remember, this wrapper has also its own shares. So right now we are redeeming these shares. So this is why this balance off because obviously this contract is behaving as an ERC 20.
00:12:11.040 - 00:12:50.378, Speaker B: But the thing is, the shares that this contract has are like one to one with the underlying vault shares. So we actually know that one vault wrapper share equals one vault share. So we can check. So there are two things that are fun here. We don't need to have permission for the user to use these shares because it's like in the same contract. And also we can map it one to one with the underlying shares. So we don't need to do approvals for the user to be able to route the shares through us.
00:12:50.378 - 00:13:26.840, Speaker B: So as the token, you remember, on deposit, we need to basically take the tokens away from the user and then approve them into the vault and then blah, blah, blah. So here we don't need that. We just like boom, use the shares because we already have them here. And obviously on the vault it's the same. The vault doesn't require you to approve the vaults to itself because it's already the same, ERC, 20 contract. We check if there are some shares available to be redeemed. The vote might not have funds available.
00:13:26.840 - 00:14:10.550, Speaker B: So this is also why we need to check this. And then yeah, we, we kind of estimate. So this is kind of a back and forth because now here we have the amount and here we need to send it back to the amount of shares that we can take from that amount or that amount. How much shares is it actually worth? So this is why we are using the price per share now. So let's say price per share is two. So we are trying to redeem 200 die. So basically we are going to try to be redeeming 100 shares because one share equals two die.
00:14:10.550 - 00:14:57.166, Speaker B: Obviously, if the vault was profitable, if the vault is not profitable and the price per share is 0.5, then 200 I are worth 400 vultures. And then we do kind of similarly we check on withdrawal as well. We need to check how much of the vouchers were actually used because the withdrawal function. So you say, hey, I want to burn this much shares or as this much shares. But sometimes the old will say, okay, I will burn 50 out of the 100 you try to, because I don't have any more basically funds to pull from. So I'm not going to give you, let's say 100 die and burn all your shares.
00:14:57.166 - 00:15:41.700, Speaker B: I'm going to just burn you the ones that are worth 100 die, the ones that you used. This obviously as well. We only burn the amount of burned shares actually from the user. This is the current bot wrapper and if we have any unused shares, we send them back to the user. That's practically. So a few cool things you can build on top here is basically you can add either fees on depositing or on withdrawing for your users. You can also do some cool stuff that we have as examples here that I will try to quickly go through.
00:15:41.700 - 00:16:37.358, Speaker B: Okay, so this is the Sugar White vault. Basically here you can deposit your vault shares or your tokens and you can assign a recipient for the difference in the yield that those shares are going to be generating. So whenever you start sharing the yield, you set up a receiver and an amount. So this can be your Netflix or whatever service you might want to pay if obviously they support or a friend or a loan receiver that you're trying to repay. Out of the yield of your tokens. We do some checks. You transfer the underlying amount, you set all the balances and stuff afterwards, just take into account that this has not been audited.
00:16:37.358 - 00:17:22.782, Speaker B: And here we can see an issue. So this line, as you remember, whenever we deposit into the vault, we are not sure that the vault will actually take the entire amount we are sending. So the amount we are basically taking away from the user here might not correspond to the amount of shares the vault is giving us back. So here you might see that the amount is 100 die, but the shares are not equal to 100 die worth of shares because the vodka could only take a half of that. So basically you're rugging the users out of half of their deposited. Underlying. This is the same when we do claim yield.
00:17:22.782 - 00:18:18.420, Speaker B: So on withdrawal it's a similar situation. So this is also something that you need to take into account when interacting with V two vaults. And also when you're tracking with any underlying protocol, you need to properly check the code to see what's going on under the hood just so you don't bubble up issues back to your users. So yeah, here you set up all the different variables that are needed for the accounting. You can also call stop sharing yield if you don't want to give free money to people anymore. And any donation recipient or user, let's say your friend or whoever can call this function, saying this would be you. So your friend will be saying, hey, claim yield from my good friend that is giving me money.
00:18:18.420 - 00:19:24.874, Speaker B: And it will check the shares, it will check here. So basically, let's say when we did the accounting, we said, okay, we deposited 100 shares, these 100 shares were worth 100 die. But right now those 100 shares are worth 200 die. So we check the difference of those balances, how much shares are worth actually. So we say, okay, then you as a good friend will only get so your remaining shares will be half because those are the ones that are worth the amount of die you actually deposited and the remaining shares or the remaining die. So the extra 100 die that was generated through APY will be converted back into shares and will be sent to your fret let me check. Yeah, I think it will just send the tokens back, but you can send default shares as well.
00:19:24.874 - 00:20:38.500, Speaker B: So your friend also keeps on getting yield out of the claim he just did. If not, he would just get the underlying token and it would be but it's okay either way should be good. And claimable basically has the similar logic from what is inside here that checks like before and after balances of how much those shares are worth and it will return you the amount of those shares converted to assets. So how much die can you claim out of that? Obviously, this only works for vaults that are profitable if the vault you are using or the yield token you're using has a negative APY. Obviously your friend will never be able to claim anything because you just give them some lossy tokens and then yeah, we have some utility functions to be able to convert back and forth from tokens to shares. So yeah, that's it. Maybe let me check if there is something else that might be good to explain here.
00:20:38.500 - 00:20:49.750, Speaker B: But yeah, that's it I think. Does anyone of you have any questions? Let me get the repo.
00:20:54.330 - 00:20:57.960, Speaker A: Yeah, if anyone has any questions, just post them in the zoom chat below.
00:21:04.590 - 00:21:32.562, Speaker B: So this is a foundry repo. This is the link for it. So Storm is a urine contributor. This is the Wisetower foundry kit. We also have a repo someone did on Hardcut for this thing. So this is an external contributor. It's also under the Storm name.
00:21:32.562 - 00:22:11.710, Speaker B: We will eventually migrate this back. So migrate this into the urine organization. But obviously, as you see, we have some like these contracts are like examples, so they're a bit party. So we don't want to introduce them into our so yeah, you can use this to shield yield rewards. I think what you're saying is okay, Mistype. Okay. But I think I understand.
00:22:11.710 - 00:23:14.066, Speaker B: Yeah, you can basically use this for any underlying that we support in a vault and you can basically have that underlying via yield. Convert that into a yield token. Yes, you can use this to share the yield rewards. You can also use this, let's say you have a ton of funds that are not being used right now. You can deposit them into yearn into a positive APY vault and you can get some APY on that while still getting your underlying available, if you need that for your users. Yeah, you can also build UI integrations on this. So basically you can root users to deposit through here because you're providing gas saving, because what you're doing is you're getting all basically the funds into a pool and then depositing all them as one.
00:23:14.066 - 00:24:29.420, Speaker B: So you're getting the funds in a separate chain and then you're breaching them, depositing them and breaching them back to your users. And then obviously you can get a cut out of that either through the difference between the PPS so the yield when the user deposits and when the user withdrawals, or just like flat deposit or withdrawal fees, either in shares or in underlying. You can also do some fun things, which is you can create a separate token that represents the yield. Because you know at all times what's the difference between those? So you can also create a separate, ERC, 20, that is the difference between the previous PPS value and the current PPS value. And you can also start like a betting market on how much APY would that get. There are protocols already doing this, but also you can so PPS value is price per share value. This is what we have.
00:24:29.420 - 00:25:14.678, Speaker B: Let me check, where was this? So here, the vault has this price per share. So it indicates how much one share is worth. And this is expressed in the same decimals as the underlying asset. So in the case of die would be 18 decimals. So it will say, okay, one die is worth X amount of shares, or one share is worth X amount of die, basically. So this might be 1.1. So basically what this says is that one share is equals to 1.1
00:25:14.678 - 00:25:29.934, Speaker B: die. So whenever you want to either mint one share, you need to provide 1.1 die, or if you have one share, you can reim it for 1.1 die. Obviously this will hopefully be always an increasing value. So this will go 1.11.21 .3,
00:25:29.934 - 00:26:01.530, Speaker B: et cetera, et cetera. So this is 1.4 would be like a 40% increase in your token value because now this is 1.4 die. So if you deposited when the Pts value was 1.1, which was a 10% value out of the underlying token, and then you are withdrawing at 40%, you basically made 0.3 worth of die.
00:26:01.530 - 00:26:35.662, Speaker B: Yes, exactly. If you deposited when the price so the question was the yield would be at 1.4 would be 0.4. Depends when you deposited, obviously, because whenever you enter the market is how much you paid for those shares. So if you paid 1.1 die for one share, obviously if you deposited one yeah, exactly. So this is why you need to calculate the difference when you deposit and when you withdrew.
00:26:35.662 - 00:26:44.310, Speaker B: And this is why here on deposit, we have all this accounting to know how much tokens you actually paid for this amount of shares.
00:26:44.970 - 00:27:14.106, Speaker A: Yeah, it great. Is there any more questions? Doesn't look like it. Yeah, I think we're good. If anyone has any more questions, you can bring them over to the Discord channel. We have a year in Sponsor channel where you can post all your questions there. Thank you very much, Skeletor. Thank you everyone for joining us today.
00:27:14.106 - 00:27:25.700, Speaker A: We do have another work workshop starting in 30 minutes with Maker Dow on how Maker Dow keeps building on dai. So please tune into that and bring all the questions over to discord if you have any. Thanks all for joining us.
00:27:27.110 - 00:27:29.950, Speaker B: Thank you so much. Have a good day. Bye.
