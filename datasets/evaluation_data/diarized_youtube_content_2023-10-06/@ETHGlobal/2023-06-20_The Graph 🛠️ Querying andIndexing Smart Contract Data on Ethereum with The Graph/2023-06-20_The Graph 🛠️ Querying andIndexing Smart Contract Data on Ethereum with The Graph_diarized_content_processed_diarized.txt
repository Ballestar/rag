00:00:07.850 - 00:00:53.950, Speaker A: The presentation that I give like usually it's half an hour or 20 minutes, but I have prepared a special one for you that is the less technical thing like how to actually query data and how to find the data and how to work with this. It depending on time, we can also go into the subgraph development. But yeah, I think it's cool to have this also that was never recorded. Subgraph development stuff is recorded from time to time. Anyways, let's get it started. So querying and indexing smart contract data on Ethereum with the graph. I start here really with the basics.
00:00:53.950 - 00:02:12.758, Speaker A: That is what is actually then a smart contract anyways. And I have an interesting example you can think about of a smart contract that it has two things. Basically it has storage like data and you can think about the storage in smart contract as a simple Google Sheets or Excel sheet where you have just rows and columns with data in it. When we look at the NFT contract, it's my main example because it's such simple in terms of technology. You would have like in a very simple way, you have an ID, the token ID of the NFT, and then you have an owner, which is an ethereum address, and then you might or might not have a metadata Uri and other stuff. But but in a nutshell, the NFT, the Esxn 21 contract defines token ID and an owner. So that's the data view on it, right? If you want to, yeah, the problem is with the data is that the smart contract and the blockchain, it usually holds the state.
00:02:12.758 - 00:03:19.930, Speaker A: As of now, it is a good tool to see who has which NFT, who owns which NFT. But it is not very good in knowing who owns the NFT before and that's exactly what's going on here. That's a problem that we don't see who owned it before. In the smart contract state by itself, this is where the graph jumps in that it actually helps to also find a way into the history of smart contract and on top of that making the current state actually are also easier to access. So you can think about without the graph it is just this and with the graph we have a history but we'll go a little bit deeper. The second thing that a smart contract does besides holding state or data is it also has rules how to change that data. And that's very important because you don't want everybody just changing who owns which NFT.
00:03:19.930 - 00:04:16.250, Speaker A: It follows certain rules which can be encoded in the smart contract and that's also why it's called smart contract because the data can only be changed according to the rules. So let's define quickly the concept of a blockchain. Again, so basically a blockchain is a distributed data storage secured by cryptography. That means that all the transactions, they are in blocks and then the hash is coded all over those transactions that makes a block and then the block is always linked to its previous block. That makes the whole thing temper proof. So you can never change one thing. Distributed means that the blockchain runs not on one server.
00:04:16.250 - 00:05:07.710, Speaker A: It is basically copied over 10,000 times all across the world. That makes it so censorship resistant that you would basically need to shut down every single node that runs the Ethereum blockchain on it or whatever blockchain in order to stop it. And that's basically impossible because we have not a global jurisdiction where you couldn't enforce such a thing. That makes it very interesting. But going forward we think of the blockchain as one thing we do not care about, that it is distributed across all these machines. So we think of it as a logical one unit. So that's just the blockchain.
00:05:07.710 - 00:06:29.270, Speaker A: And then the smart contract as I said before, is the data and the logic how to change the data that is stored on blockchain and how does it work. If you want to change the data, you send a transaction to the blockchain which is then distributed across all these copies and you sign it cryptographically with your secret key or your wallet so that everybody knows that this is a legit transaction and then the transaction is included on the blockchain. We will look at that later on. But there is a problem with the data on the blockchain, as I said before, but the user interfaces as we initially saw, they want to read, they want to write to the blockchain. And as we saw before, it is incentivized. So if you send a transaction to the blockchain you pay some gas or you have to put some gas on top of it and the gas is consumed by the miners or now it's the proof stake by the validators and then that's why you pay and by paying for it the whole thing works. But when you want to read from the blockchain there is no incentivization for anybody to provide you that data per se, not in the protocol.
00:06:29.270 - 00:07:20.026, Speaker A: So that's why when you go on Ether scan you see a lot of advertisements which sometimes are also a little bit shady in order so that Etherscan can fund its own business. Or the same is also with Alchemy. If you do a lot of requests to Alchemy or Infura you need to pay for them. So they're jumping into it. But the protocol by itself incentivize reading, that's a big problem. Going back to the analogy from before, each of these things here is one transaction. And also a bigger problem with the theorem blockchain especially is that we have all these smart contracts or DApps that have stuff on the blockchain and every time someone sends a transaction it just laid on top of each other.
00:07:20.026 - 00:09:00.730, Speaker A: So in the end, if you want to see, okay, what was actually going on, let's say in foundation, then you would need to go through all these transactions and pick the ones out that are according to foundation and that's quite tedious work and it takes a lot of time. That's not something that you want to have in the front end. And this is also what we see currently or before the graph that front ends do. This is really code from a project that I was advising how they were trying to get the data out. So for those that understand JavaScript or TypeScript that reads as follows you try to get a contract but all these await methods especially those that we see here and these here they all take 200 to 300 milliseconds to resolve because you always call back to some node, which you usually need to pay somehow, that they give you that data and then you wait and you go through. So this code, if you own, let's say, ten or 20 NFTs, easily gets five to ten or 20 seconds to load just to show you a list of the tokens that you hold. And this is super inefficient and users just move away after a while because they say like whatever, I don't have time to wait 20 seconds for my stuff to resolve.
00:09:00.730 - 00:10:29.654, Speaker A: Yes, and that's actually now we had already two reasons why the graph exists. So for one, to get the historical data, but for two, also to have a very good access to the data on the left side, you probably know it's an indexing protocol for creating networks like your Mypfs. There's also support for RV, near Cosmos and others. So in the end, the graph will index all blockchains more come soon TM on the host service you see currently one point or 1 billion queries per day or even a little bit more depends. So it is really powering a lot of the debts that we see currently. Uniswap is the most famous example that uses this but we have also kind of others like Enzyme or Audios or Mstable, there are a bunch of them and it's not only the host service, it's also decentralized indexing network protocol. So there are more than 180 indexes I think currently worldwide, owned by individuals oops and that means these are independent indexes that run with things.
00:10:29.654 - 00:11:09.860, Speaker A: So it is similar to what we talked about before, but Ethereum or a blockchain general is that we have a distributed network. There is this redundancy. So if a subgroup is indexed by one indexer across the world, if one goes down, another is still around. It also gives you fast and cheap reliable access to that data. And yeah, the whole mission is that we go towards a global open API of the data that we need. Yeah, that's very cool and in the end we can now build truly decentralized apps. That's what we try to do here.
00:11:09.860 - 00:11:58.306, Speaker A: So quick into the subgraphs. So I told you before about subgraphs. subgraphs in general are just a database. A database is the same as you saw before in these Google slides, just multiple of them. So a database consists of multiple tables and you can define the tables as you wish. Then you have the mappings, which is this gear here, that's a logic of how to get data out of the blockchain into that database and in the end you make it available. And the subgraph by itself, subgraph by itself is only the code that defines how this is done, but it doesn't do it necessarily by itself.
00:11:58.306 - 00:12:53.726, Speaker A: The indexers then need to index the subgraphs which by indexing that means they create the database and they run the code how to fill that database. So yeah, that's the quick concept of the subgroup. So what happens is that we saw this mess of transactions that are just layered on top of each other that they are created like very nice neat buckets for each of the protocol in a database per each protocol. So we can easily query that data and make much more sense about what's going on. In the end we end up with to go back to the screenshot from before that we have a very nice and neat GraphQL query. So we send one query that has a round trip of 100 to 300 milliseconds. Usually it's much quicker.
00:12:53.726 - 00:13:44.130, Speaker A: That's what we expect to get that data out. All right, I was just reading the chat, so I will also share with you that presentation afterwards. All my presentations are open, you can use them even if you want to give that presentation to someone. Maybe you want to remove the edge and node logo then. But yeah, it's public goods. So we end up with this modern DAP architecture where we have the user interface on top and then the blockchain on the bottom that we knew already. And in between is this indexing protocol that is incentivized and built for data reading and that sits in between and reads data from the blockchain and stores it in this indexing layer.
00:13:44.130 - 00:14:35.250, Speaker A: All right, so how does it look like then? How can you think about it? This is the illustration, that's the official one, how the graph node works. So again, on top is the depth adapt can be like in its purest sense adapt. It's just HTML, CSS and JavaScript that defines the DAP. It could be also other programming language, but that's all you currently see. And as we talked before, when they send transactions to the smart contract, you can change state. So that is buying an NFT on an NFT marketplace or swapping something on Uniswap or open LP position. Whatever cool thing you can do in the transactions transactions, they emit events.
00:14:35.250 - 00:15:34.594, Speaker A: And with events, the smart contract basically tells the outside world what happened. We can look into this later what an event is, but that's basically what smart contracts emit. So you can watch the blockchain or watch smart contracts for those events. These events are then ingested into the graph node which will then according to those events run mapping which is in WebAssembly module and put then the stuff into the store. So here is the database where the data is stored for later retrieval. Then the other way that we had also in this image from above is that the depth also needs queries. So if you go to uniswap at the analytics page it needs to load data somewhere.
00:15:34.594 - 00:16:48.080, Speaker A: So it sends queries to the GraphQL API which sits on top of the graph node and that GraphQL API will get data from the store and then send back to the so it's very neat, right. Also a very funny GIF that we used to displace this one like how subcrops work. So you have this mass of transactions again and then magically somehow they are sorted into this pocket so that they know what's going on, have an overview. All right. So now when you think okay, that's very cool but now how can I actually find data to query? The best thing in my opinion is these subgraphs that XYZ from Missari they are writing very sophisticated subgraphs. Okay, I also send you this thing here in the chat that's currently for me the best entry point. I mean you can also go to the Graph graph.com
00:16:48.080 - 00:17:58.086, Speaker A: and go here to Graph Explorer and then you see also subgraphs here. But the one from these are the ones that write for themselves or also some of them sorry see they are also in the tops here. But subgraphs here are very good. So we can for example say cool, let's have a look at so they have some on the decentralized network and some on the hosted service. So you can look through them and find out they have like hundreds of subgroups what is it? 27 production levy, 47, 74, 4700 development and 106 deployment cost. Why is that? Because they deploy to different chains curve. They are usually the same on all cool.
00:17:58.086 - 00:19:01.050, Speaker A: So when you want to look into one of those, another good example actually is let's switch to this one is the CryptoPunk subgraph graph here. You need to be careful to take the one with the highest correlation because somehow other people just deployed subgroups. That's downside of a decentralized network. Now if you want to query that subgroup then you can just go here and go into the playground and start to play around with that subgroup. But what I like to do and that's where I think it makes sense to see this workshop is to actually open up a little bit more sophisticated playground. Although a revamp of this one is in the works. But I can show you how this work works.
00:19:01.050 - 00:20:19.266, Speaker A: So what we do if you want to query a subgraph on decentralized network, what you need is kind of this query URL. You can copy this query go here then you can go to explore like this and paste it. Now, the problem with subgraphs on the decentralized network is that you need to have an API key and that's inside of that URL, this placeholder for the API key and where we first need to find one. Right? So let's do this together. So what you do is you go to the subgroup studio actually you connect the wallet and I will just create a new account connect and then sign in. And yeah, I use this already to deploy some test subcraft. But what's important for you is that you go to API keys and not subgroups and then you create a new API key.
00:20:19.266 - 00:21:02.548, Speaker A: Click here like demo and then I can receive frequenties that by giving an email. I think these are optional fields so I can claim the queries. Nice. And now I have 2000 free queries on this API key. That's very good. And I already have the API key here so I can just copy here, go back, go here and paste it. Feel free to just abuse that one.
00:21:02.548 - 00:21:50.820, Speaker A: Everybody can have thousands free query. Cool. Now what we have here is on the top we have the subgraph and on the bottom we have the explorer and the documentation. So the cool thing about GraphQL is because it is very strongly typed query language that we see we can have this explorer on the right we can also have the Docs GraphQL query has so called root types and here we have the root type query and root type subscription. Although subscriptions do not work currently. So we go with query. If you go on query then you see a detailed documentation about what you can query.
00:21:50.820 - 00:22:40.116, Speaker A: So in this example when you look at the CryptoPunk subgraph it has accounts which are holders of punks. Then we have the actual punks and we have metadata of the punk. And all of these you see there is this repeating pattern of account and then account with S. So the first one is to get just one and then you need to provide an ID or you can have many and then you can have a filter. We will look into this and then the result is an account or just one account or a list of account. Same with punks and receipt account punks metadata trades, asks bits and contracts and so on and so forth. There's a lot going on.
00:22:40.116 - 00:23:59.634, Speaker A: So now what do we want to do? A funny thing to do with the crypto punks actually is to say I want to know which was actually the most expensive sale ever happened on Punk. And you could go to crypto punks larvae here. Cool. And I think you can try you it largest sale. So cool. They say the largest sale ever happened is this 15822 for 8000 e. Always funny for me to see like people actually pay that much money for a pixel but yeah, that's how it is now we could try to reproduce this one and that would be cool.
00:23:59.634 - 00:25:02.946, Speaker A: We go here to the sales and I like this explorer we will have soon something like this also on the graph.com it always looks the same. We can say, okay, what we want to do, we can actually order by the amount of the sale and the order direction we make it descending. So that says it will sort the list of results by amount and the highest amount will be on the top. And then we can say, okay, in which hash it happened, we can say which ID it is, and we want to see also the amount actually want to see the transaction hash. And then we maybe want to have the from and the tube. Let's see and see this is for me a very explorative that's why it's also called Explorer.
00:25:02.946 - 00:27:17.380, Speaker A: I can just click around here and read stuff and try to figure out what data is here and then I can send it. Cool, now we see so the highest according to that chakra is actually this one and funny enough when we go back here we see this is eight k but that's the second one. Maybe I should also get the punk out here again can remove this one actually have a little bit better view so 5822 yes, that's what we saw here for eight k but a funny thing is that actually the highest sale ever is this one kept interface what's so good and and let's try again. Okay, cool. And why is that what happened here? So when we go to east to Way by the way, usually it's in Way so what happened here? This is interesting vista eight k is the highest sale that's what they say here. But actually we also see when we look on the blockchain that it is one hundred and twenty four k e for one punk. And now you wonder like why is it displayed here? We can start to do investigations and that's what I think is the graph perfect for and say there is the transaction hash we go to either scan I have a new compute so autocomplete not there yet.
00:27:17.380 - 00:28:47.030, Speaker A: Let's just start to look into this thing and what you see here is that someone made a flash loan I think. So here we see someone got what is this? 500 million die in a flash loan, I think from compound traditionally in robbed ETH. That's why we end up with this weird number and then buys punk and then gives it all back and sells punk. Again, this person tried to fake this transaction and interestingly, on the official side, they censor this, but they talk about it in an interesting way so we can try to see the punk with the number go here and yeah, see, they say I gay this blah blah, blah. They are flash loan and they send it on their website. Cool yeah. I think this explains how to query the graph.
