00:00:06.090 - 00:00:31.000, Speaker A: And our next speaker is Hari. And Hari is going to be talking about all the new features in the latest update for Solidity. So we'll just give it a second for everything to work out on the AV side. And Hari, whenever you're ready, turn on your camera and we'll get get the slide started from our end. Here we go.
00:00:35.610 - 00:00:36.726, Speaker B: Hello? Can you hear me?
00:00:36.748 - 00:00:48.840, Speaker A: Well, yes, everything is good. I know we're doing the slides on our end, so just give me one more second to pull that up and we can sure make that work.
00:00:49.890 - 00:00:50.640, Speaker B: It.
00:01:20.140 - 00:01:37.900, Speaker A: I'm sorry, this one is on Moraine. I can go present it, but I'm trying to see if I can actually make it a presentation full screen mode, but let's see if that works. There we go. Okay, so just say Next whenever.
00:01:39.920 - 00:02:10.420, Speaker B: Great. Yeah. So I'll say next whenever I want to move. Okay, great. So my talk is about two important abstractions in Solidity. And as you might already know, the 80 version was a very important release for us because it introduced a major feature that is safe map by default. But since then, we have followed up with two other major features that we believe has a similar potential.
00:02:10.420 - 00:02:58.230, Speaker B: I'm not going to say what the two features are right now, but rather, I want to slowly introduce a problem and then try to convince you why we implemented this feature and how you can solve certain problems elegantly using our new features. So, next. So let's dive straight into our toy problem. Suppose you want to write a smart contract that sells some object. The object has a price, and there is a limited quantity of the object available. And the problem is extremely simple. The problem is that a user wants to buy some quantity of the object and you want to compute the total price.
00:02:58.230 - 00:03:46.340, Speaker B: So next, the very first solution for this is the following. So you write a function which is total price that takes two unsigned integers here, quantity and price. And then you multiply it. It's very simple and perfectly valid code. But what is the problem here? The problem is that you can notice that the price and quantity are supposed to be two different things. For example, you are not supposed to assign a price to a quantity or vice versa. But in our code, we can because both of them are unsigned integers.
00:03:46.340 - 00:04:29.510, Speaker B: So from a type safety perspective, we can do much better. So in our example, the type only represents the underlying data representation and not how the data should be interpreted. So, to repeat, we would like to have two different types for quantity and price. But we already have a solution for this in the language. Let's look at another solution. So, next, the solution number two is just using structs. So we have two structs here, quantity and price.
00:04:29.510 - 00:05:16.550, Speaker B: They both have a single element. And now you can write the same function, but the arguments are now structs instead of elementary value type. So the code is much more type safe than the previous one and you can no longer assign quantity to price or vice versa. That would be a type error. But now this has some other problems. So stocks are a wonderful abstraction, but it comes with the cost. I will actually explain the cost in detail in a bit, but let's just say that it's not as efficient as the first example.
00:05:16.550 - 00:05:56.640, Speaker B: So note that a struct is a reference type. What this means is that it is a pointer towards a value in call, data memory or storage. So in this example it is in memory. So you can see it clearly because you have to explicitly specify it. You can see quantity memory Q and price memory P. So remember that I mentioned this is not as efficient. So let's forget about the problem for a bit and talk about something more fundamental.
00:05:56.640 - 00:06:54.876, Speaker B: So next so we will briefly talk about the difference between stack and memory in the Ethereum virtual machine. So, a stack is simply a data structure. The Ethereum Virtual machine is a stack based machine, which means that you mainly do operations using a stack. Speaking of operations, the main operation in a stack is to push a value to the top of the stack and then there are a bunch of operations that allows you to rearrange the stack as well as doing various computations. So for example, if you have two elements on the stack, you can add them by using the add of code. And what that does is that the two elements will be removed and replaced by the result. And let's now talk about memory.
00:06:54.876 - 00:07:50.900, Speaker B: So, memory is a temporary location in the Ethereum Virtual machine where you can store things and read them later. The main takeaway from this description should be that stack is much more fundamental than memory. So it's important because there is often this misconception that all values in Solidity are stored in memory. That is not true. In Solidity you have to explicitly say memory when you need to store or read something to and from memory. So for example, local variables are stored in stack and not memory because often they don't have a memory specifier. So if we go back to the first example, the values are actually stored in stack and in the second example the values are stored in memory.
00:07:50.900 - 00:08:37.860, Speaker B: But this still doesn't explain why one is more efficient than the other in terms of gas. Let's now try to see why that is true. Next. So, as I said before, the most fundamental operation that you can do with the stack is putting a value in it. So you can do this with the push operation. The operations is very cheap and only costs three gas. So if you consume the value, for example, when you want to add it with something that is already in the stack, you don't need to pay anything extra for consuming it, you only pay for the addition.
00:08:37.860 - 00:09:25.810, Speaker B: So consuming doesn't have an extra cost as long as the element is at the right location. But if it's not at the right location in the stack, you can use some stack operations to move it to the right location before consuming it. And each of these stack operations would typically cost three gas. But in our best case scenario, the cost for putting something in stack is just three gas. And we hope that the value is at the right place so that we don't have to do any more operations to move it around. Now let's see how to do the same things with memory. So, if you want to put a value in memory, you do it using the operation M store.
00:09:25.810 - 00:10:01.100, Speaker B: So M Store of AB will store the value b at the location starting from A. So remember that all operations have to go through the stack. So to do M store of A comma B, you have to first put the values A and B in the stack. So you have to start with B and then A. So we have already discussed the cost for doing this. So to put b in stack, it costs three gas. It is a push operation.
00:10:01.100 - 00:10:51.180, Speaker B: Similarly, to put A in stack, it cost three gas. And now the M store inspection has the cost three which is fixed, and at least another three which can vary depending on how big A gets. So the more memory you use, it can get more and more expensive after a certain point. So in total, you have to pay at least twelve gas for this operation. And similarly, if you want to read a value from memory, you do this using the operation M load M Load of A. Again, you need to start by putting the value in stack, which costs three gas, and afterwards the M load inspection, which cost three gas. So that is a total of six gas.
00:10:51.180 - 00:11:40.110, Speaker B: So, as you can see here, just to write and read from memory, you need to spend at least 18 Gias, whereas this can be done with just three Gias in stack. So stack operations can be around six times cheaper than memory. So can you go back to slides? Great. Now I hope that answers my statement. Not efficient. Now let's go to the real solution. So what if Solidity had a way to create an abstraction, but without having to pay an additional cost for it? Abstractions are amazing, but we don't want to pay more guess for it.
00:11:40.110 - 00:12:42.770, Speaker B: So let me introduce you to user defined value types. So it is what we call as a zero cost abstraction. It can be used starting from version 89, which was released exactly nine days before. So it allows you to create an alias type while having additional type safety. The syntax looks like type U is V, where U is the name of the new type and V is an elementary value type. That means V can be an address, an int eight, et cetera. So how do we solve the same problem using user defined value types? So next, so here is an example on how to write a contract to solve the toy problem.
00:12:42.770 - 00:13:25.820, Speaker B: So here you define a new type quantity and price. You see the syntax? Type quantity is uint and type price is uint. Note that these types are distinct and therefore you cannot just assign one to another. That would be a type error. So this example also introduces how we allow conversions to and from the underlying type, which is by using the function wrap and unwrap. So quantity unwrap can be used to convert from quantity to UN and quantity wrap can be used to convert from U into quantity. This can of course be generalized.
00:13:25.820 - 00:15:12.160, Speaker B: So if you replace U int to uint eight everywhere, then wrap and unwrap will correspondingly change. So next, a very important thing to note about this is that the types are fully backwards compatible. What does that even mean? So what this means is that even when you have to implement a contract that needs to follow a standard which was written a long time ago, you can still use the user defined value types to interface with it or rewrite it. For example, the ERC 20 standard requires the type for the amount of token to be UN 256. But you can define a new type with the name decimal 18, which is a zero cost abstraction over U win 256 and you can replace U into 56 with decimal 80 wherever you think that's more appropriate and it would be completely backwards compatible. So here I have two examples of interfaces and they are supposed to represent some of the subset of the ERC 20 standard and both of them would work exactly the same. But in my opinion, the first one is much more clearer because it makes it clear that the value is supposed to actually represent a number with 18 decimals, which is the case for most tokens, whereas in the second case it's not obvious what value is supposed to represent in terms of decimals.
00:15:12.160 - 00:16:16.710, Speaker B: So effectively the feature allows you to write code that is much more clearer and easy to read. So next, so there are of course some open questions about how we improve this feature and one of them is about defining operators. So user defined value types does not have any operators right now, but we would like to have them in the future. So as you can see in this example, which is again about a token, and how we have a type that represents a value in 18 decimals. So the type decimal 18. So we need a syntax to create the operator plus equal to because if you look at the function mint, you have the line balance of user plus equal to value. But we don't have a plus equal to right now but we would like to have them.
00:16:16.710 - 00:17:02.660, Speaker B: You can participate in the discussion where we propose this feature by going to the links. We would love to hear your opinion on this. I will leave a link to my slides later if you want to check out the links. So now that we have solved our first problem, let's forget about it and talk about a completely new problem. So the new problem is also very simple. Next. So the new problem is the following so how can we tell a user why a transaction failed? So suppose you have a simple contract that can only be used by the owner.
00:17:02.660 - 00:18:12.380, Speaker B: So it's typical to have a modifier that checks the sender and rewards if the sender is not the same as the owner. You can see the contract here where you have an immutable variable honor which would be set to the message center during the contract initialization. And then you have a modifier only owner which would check if the message or center is same as the owner which was saved during the constructor. And if it's not the same, the transaction would reward. For example, if you look at the withdraw function, it can only be called if the modifier only owner is true. So I have a comment here which I said don't do this but this is very typical in Smart contracts and why did I say this? So that's mainly because this is a very large reward string. It's 40 bytes, it's more than 40 bytes and large revert string add to higher deploy costs for the contract as well as higher gas costs for reverting transactions.
00:18:12.380 - 00:19:11.390, Speaker B: The deploy costs here can be especially important if your contract is getting near the contract size limit. But what if we had a way to create a high level error object? Next. And that is exactly what customers do. So it was introduced in the version 84 and syntax is very similar to how we define events. So you can see the error only honor and also notice how we use Natspec comments to describe it. If you listen to the talk about source verification by Francis that happened just before, you will see some of our goals about how we want to use Natspit comments to improve the user experience for contract interactions. So instead of a required statement, you replace it by an if followed by revert only order.
00:19:11.390 - 00:20:08.080, Speaker B: Next. So here is a short summary of the before and after. In the first example, that's how you do it classically using a string and in the second example we have a contract we use customer S and the second example is better because it has lower cost for rewarding transactions as well as cheaper contract deploy cost or smaller bytecode. And next. So let's get to the next level of reward messages. Sometimes the revert reason. Sometimes you want the revert reason to have more information than a very simple static string.
00:20:08.080 - 00:21:15.060, Speaker B: In the past, if you wanted to convey a structured message back to the user, you would have to do something like the following the context is that we have a token like contract and if we have a call to the transfer function and if there is insufficient balance, we want to revert and tell that to the user. Of course we can always reward with saying okay, insufficient balance but we want to do more than that. So if you really want to have a proper error message you could do something that looks like this. So what we have here is a function you went to STR that converts an integer to string and then you concatenate all these things on chain. I think I have a bug here but yeah, whatever, it doesn't matter. So first of all, this Uwin to string conversion is doing it on chain is paying more gas than you're supposed to do. I mean it's just unfortunately expensive.
00:21:15.060 - 00:22:20.920, Speaker B: So when I mean expensive, it's not as expensive as a storage read or storage right? But it's completely unnecessary in my opinion. Things don't really belong in smart contracts so you should try to really minimize them. And the second reason is that whenever you have a function call in solidity, each argument has to be evaluated first. So if you have F of AB and if A and B are function call, you have to evaluate A and B before you evaluate F. So in this case Abi encode path is a function call and that means that even if the condition for require is true, the reward string has to be still evaluated. So this means that you are just wasting gas for every single call even if the call is completely correct. So next so let's see how to solve the same problem by using customer errors.
00:22:20.920 - 00:23:32.096, Speaker B: So here is an example that combines multiple things from this talk. The first thing is the user defined value type decimal 18 so we have a token again and we have an error insufficient balance. So remember that I told you that customers are similar to events, you can have arguments. So here you have a revert with the address of the user, the current balance and how much is required for the transaction to succeed. It looks very similar to how you emit an event. So this is a much cheaper and much more idiomatic approach to having much more structured error than using strings. So next so customer is a feature, it's a compiler feature but it wouldn't be complete without tooling support.
00:23:32.096 - 00:24:18.960, Speaker B: So several of the popular tools actually support customers and we are hoping to see better support. So currently block explorers like Etherscan doesn't automatically decode customers and we hope this is something that would be supported in the near future. But all these tools do support it. So next. So that's pretty much my talk. My name is Hari and I hope I was able to convince you why these two major features, that is user defined value types and customer are useful and also why we need them. I would love to see smart contracts using these features and I hope I was able to influence you.
00:24:18.960 - 00:24:35.270, Speaker B: You can find my slides in the following link. I can now answer some questions. You can also find my contact in the link if you want to follow up and if you want to reach out to the compiler team. You can find the details in the link. So, questions.
00:24:38.680 - 00:25:04.510, Speaker A: That was a great talk. Just kind of sourcing everybody. I'm just looking at all the chats to see if there are more questions. I think overall people are just excited about the gas efficiencies here. Of course, this is kind of the most obvious thing that you kind of highlighted along with those Idiomatic extractions. So if anybody has we're just getting comments that people are loving this. So Richie, if you have any questions for RA, we can ask that too.
00:25:04.510 - 00:25:18.020, Speaker A: Maybe just a more future forward looking question will be what are some of these other abstractions that you're thinking about in the back burner or possible Next releases? What does that look like? And sort of how are you thinking about the future of the language?
00:25:18.760 - 00:26:28.184, Speaker B: Yeah, so something that we wanted to do was having some support for fixed point types and we think that user defined value types is like the first step towards it. So right now our thinking process is that we don't want proper fixed point types in solidity because there is no single way to implement it. If you look at the implementation, there are like multiple implementation and each one has their own advantages and disadvantages. So if something lands in the compiler, it has to be somewhat the implementation, but there is no the implementation. So we think it's something that libraries should do and we think we want to better support it by using user defined value types and that's why operators would like be the next step in user defined value types improvements. And I think that would unlock much more abstract code, that would let you write much more abstract code and also safer, also efficient code. Yeah, that's the number one priority right now.
00:26:28.382 - 00:27:05.030, Speaker A: Got you. In terms of, I mean, you kind of talked about some of the integrations that are still on track to be actually on there from the libraries to Ether scan, what have you, what is it that they should keep in mind as they think about integrating it? Obviously, I feel like you addressed that there's no backwards incompatibility, sorry, there's no incompatibility here. As people think about it, it is equivalent, it's just a high level abstraction. But for developers on this side looking to just quickly switch over to these abstract types, do you have any advice or comments on what they should keep in mind?
00:27:07.160 - 00:27:53.620, Speaker B: Not really. I think it's fairly straightforward to switch and we purposefully designed it to keep it simple. And if you have comments, if you're using the feature and want to see some changes, we are always open for comments. So the way we implement features is by starting with a minimal version that will do most of the things and we would slowly add more features to make it stronger. So if you have comments, feel free to reach out to us. As a matter of fact, the feature user defined wider types was greatly influenced by one of our user feedback. So your feedback really matters and it would influence the language.
00:27:54.600 - 00:28:00.520, Speaker A: Awesome. And the way people can get involved is it the GitHub or what is the official resource?
00:28:01.260 - 00:28:22.140, Speaker B: So you can find all our information in Soliditylang.org, but you can also come to our GitHub chat, look at open issues in our GitHub channel or in the metrics channel as well. But the go to link is soliditylang.org.
00:28:23.360 - 00:28:39.360, Speaker A: Awesome. Well, a couple people were asking for a link to the slides we just posted that so that also has the link at the end of the presentation. So thank you so much Hari, for that amazing intro or the demo of What's New and hope you have a great rest of the weekend.
00:28:39.700 - 00:28:40.880, Speaker B: Thanks. Bye.
00:28:41.780 - 00:28:44.990, Speaker A: All right, with that, we are ready for our next talk.
