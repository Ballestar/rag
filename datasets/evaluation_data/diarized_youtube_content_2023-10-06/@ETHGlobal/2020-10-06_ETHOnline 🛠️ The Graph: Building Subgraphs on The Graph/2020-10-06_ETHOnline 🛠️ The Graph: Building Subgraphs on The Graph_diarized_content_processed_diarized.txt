00:00:13.560 - 00:00:34.260, Speaker A: Hey everyone, thanks for joining. We have David from the graph. If you have questions for him, feel free to drop them in the chat here. If you're watching on YouTube, drop your questions in the chat there and I will relay them to David. So David's going to give us a talk on building with subgraph.
00:00:35.720 - 00:00:36.470, Speaker B: Awesome.
00:00:38.600 - 00:00:39.632, Speaker A: Thanks, David.
00:00:39.776 - 00:01:12.576, Speaker B: Yeah, thanks for the intro. So, yeah, I'm Dave, I work at the graph. I've been working there for the last two and a bit years and we've been working on building out the graph network and we've been around for a while. I hope a lot of you guys have heard of us. If not, this will all be new to you, but it'll be interesting and I'm excited to get started. So I'll just go a little bit of background about what the graph is to start. And this is just our home page.
00:01:12.576 - 00:02:22.932, Speaker B: And what we really are is an indexing and querying protocol that is built on top of Ethereum right now. Right now just what we allow you to tie into is Ethereum and IPFS. But we have this vision for the future of global kind of API, for data, for open data such as data on Blockchains or data that might be on IPFS or Filecoin or whatever happens in the future. So just to get kind of started, this is a little bit here's. One of the things that we use GraphQL in the stack of what you end up building on the graph protocol is called a subgraph. And I'm going to go into the details of that when I go through the documentation, but that's kind of all you need to know about us right now. There's a ton going on about the graph network and we're getting into that right now towards the end of this year.
00:02:22.932 - 00:03:18.664, Speaker B: But this is about the hackathon, so let's get started on that. Something else I should mention as well is the prizes that we are giving away for the ETH online hackathon. And so it is one prize of 1000 die for the best use of a subgraph and it is another prize for the best new subgraph. So what that basically means you can go to let's find the Explorer here. So these are a bunch of existing subgraphs that have been created by the community. And what they're doing, they're just indexing and offering up at an API endpoint a bunch of data. So these might be a lot of names that are familiar to you guys, such as like Uniswap is by far the heaviest used subgraph out there.
00:03:18.664 - 00:04:10.484, Speaker B: And if you click on it, you can basically query any data that is on the Uniswap subgraph and get back all this rich information. Any swap that's happened on Uniswap, any kind of trade volume, you can get all this here. So it's really interesting. There's a lot to it that is basically one of the prizes would be tying into any of these existing subgraphs and using it in your front end application that you're building for the hackathon. So we've seen that before and we've also seen people create their own subgraphs. And that would essentially mean you're going to deploy one to the graph hosted service, which is what basically the Explorer is. And these are all kind of featured subgraphs that we've talked to people and got them to be displayed here on the front of the page.
00:04:10.484 - 00:05:21.200, Speaker B: But there's also over 1000 community subgraphs that have all been built by people over the last couple of years and we're really getting into seeing a ton of these being built all the time and it's really interesting to see that happen. So another thing I'd like to mention about that is what we usually see in hackathons is people building on the graph and then tying it into another project. Because essentially what the graph is doing is it's allowing you to see rich data on Ethereum and display it in a front end. So you might be building on Mstable or pool together like one of these other protocols that also has a prize or else if there's a grand prize that you can win, all those kind of things. What we usually see is somebody will build like a pool together, kind of front end DAP and then they'll tie in a subgraph and definitely you'd be eligible to get both rewards in some of those scenarios. So that's basically what we have outlined for the hackathon. And what I'm going to do is now at this point show you how to build your actual own subgraph.
00:05:21.200 - 00:06:03.052, Speaker B: And the best place to start for that is our documentation. And if anybody has any questions right now, let me know, Heather. But if not, I'll continue. All right, so this is the introduction. This is basically what I just talked about. If you go to Is, there's a little bit of fine detail that has to be known here. Local development is more so if you are running your own graph node and you have a really powerful subgraph that you're doing a lot of work on.
00:06:03.052 - 00:06:44.810, Speaker B: So we're not actually looking to do that. What we want to do is use the hosted service. And the hosted service essentially is like our version of the graph node that's running in the cloud that you can deploy any subgraph to, to index and query data on for Ethereum. I guess a good point to explain. Now this starts to go into what we're going to do with the code and I'll get into that soon. But a good thing to go in right now would be what exactly is a subgraph because I said it's indexing and querying on top of Ethereum. But let's get into the details of what that really means.
00:06:44.810 - 00:07:22.580, Speaker B: So a subgraph, I'm going to skip down to this really quickly. The subgraph manifest is kind of what describes it's like the very high level explanation to a graph node what the subgraph is supposed to represent for data. So if you look at this, this is just a YAML file. And what it is, is it's kind of just explaining what the graph node should index. So we're saying, okay, there's one data source. It's an ethereum smart contract. Its name is Gravity.
00:07:22.580 - 00:07:44.060, Speaker B: It's on Main net because we can index all the testnets. And also some of the other EVM chains that are out has. This is the address on Mainnet. This is the block. It was deployed on Mainnet. So that's when you should start indexing it. And then we're actually giving it the Abi from the smart contract.
00:07:44.060 - 00:08:33.916, Speaker B: And then we're also giving it handlers that it can basically run mappings on. And I'll get into mappings in a little bit more detail soon. But all these handlers are basically things that happen on Chain that allows the graph node to recognize, hey, something happened on Chain. I want to grab the data from that event and store it in the subgraph. And basically from there on, you store it in there and you build this kind of rich subgraph full of the specific data that you want from Ethereum. And so, as you can see, you can run basically the subgraph on event handlers, you can do call handlers as well. So any function calls, you can actually get the data from that.
00:08:33.916 - 00:09:09.784, Speaker B: And you can also do it per block. So every single block on Ethereum you could actually get data from. So these three types of handlers pretty much allow you to get any type of data you want on Ethereum. And you can also call contracts directly. So let's say this new Gravatar event happens on Ethereum. It's emitted by the contract. You can actually call directly into the Ethereum node at that time and call any public functions or public state variables and get the value that's in there.
00:09:09.784 - 00:09:51.344, Speaker B: So it allows you to also interact with the Ethereum contract as well as what I already just explained was indexing data that's being emitted. And I'll go over some code that involves this a little more hands on later on. But this is just kind of high level explanation of some important parts. So this is the next part that's really important. So the subgraph manifest explains what data we want from Ethereum. So then this is called the Schema, basically, or the GraphQL schema. And if you don't know anything about GraphQL, I highly recommend you look at their documentation.
00:09:51.344 - 00:10:51.032, Speaker B: It's a really cool API language and that's very well suited for what we're doing at the graph and it's why we chose it. And you will see this example as well. But it's basically just saying this is the entity or object type that is going to be in our subgraph, which is storing data in a store or a database, right? And this is going to allow us to get and set from that store and load from that store whatever we want to do. And as you can see, there's kind of these core values like ID is definitely needed for every single entity. It has to be unique. And then we have bytes, string and boolean and a couple of others and you can keep creating them and you can embed them. Like a Gravitar could also be right here as one of the field types and I'll get into more detail about the schema later.
00:10:51.032 - 00:11:46.010, Speaker B: But basically the important thing to realize about the Schema is it's kind of like setting up your data model for what you want to be queryable in your subgraph. And then there's some more details here. Definitely I would recommend reading through all of this, but it's a little bit too in depth for just this kind of tutorial. So the last one I'll go over here is writing mappings. So this is kind of like the core of the complexity of a subgraph is how you're handling that data and how you want to store it in the subgraph. So as you can see, like this mapping right here, there's an event on a smart contract called New Gravitar. And whenever that event gets emitted by an Ethereum node, we're basically going to run this code.
00:11:46.010 - 00:13:23.320, Speaker B: And this code is assembly script code, which is similar to TypeScript, but it's just a subset of it and it's pretty straightforward. We're just creating a new Gravitar, storing some data, storing some fields from the event, so the event parameters, storing it on fields on the Gravitar and then saving it to the subgraph store. If you combine those three kind of ideas, the subgraph manifest which tells the graph node what data to get from Ethereum, and then you have the Schema which tells you how to store it, and then you have the mappings which explains how to take the data from Ethereum and store it in the store. So if you take those three kind of concepts, that's basically most of a subgraph, which is from what I just showed here, it's really simple, but it can get very complex. So at this point, what I want to do is kind of go over a tutorial and start actually deploying a subgraph. So what you can do go to the top of the page and so you'll log into your account through GitHub OAuth and you'll get here. You won't have any subgraphs if you're brand new, but what you want to do is you want to deploy a subgraph to the hosted service, so that our hosted service in the cloud can actually index your subgraph.
00:13:23.320 - 00:14:17.130, Speaker B: So we do is you go add subgraph and this is where you just give it a name. And so the example we always use is called Gravitar. It's just a really simple smart contract that it's just really good to show the power of a subgraph without getting too complex and I'll quickly show, like, an example of uniswap at the end as well and how you do that. So I'll show you kind of two different subgraphs and that should be enough to get you guys started. E global hackathon example. So you create this on the hosted service, and if you want, you can hide it so that nobody sees it in the Explorer. And I'm going to do that for this scenario because this is just an example subgraph and then you create it.
00:14:17.130 - 00:15:04.840, Speaker B: So now I have this created subgraph in the Explorer, but it hasn't been deployed yet. So I'm going to have to deploy it to here. So we kind of have some steps here that you need to do which are really helpful, and copy into your terminal and install graph CLI. So that's what I'm going to do. And quickly just go to my terminal. I got right here I have a blank folder, and I'm basically just going to start it as if I didn't know how to do a subgraph before myself. So I'm going to add graph CLI to my global package and have that installed.
00:15:04.840 - 00:15:54.696, Speaker B: And at that point, we should be good there. And then what you want to do is so we're going to do this graph init from example. So this is a command from the graph CLI, and it's just a very simple way of setting up the Gravitar subgraph. But if you want to start your own subgraph, it's also a very good way to get a boilerplate code up for your project and then go from there. So it just asks you to do basically your GitHub name and whatever you just named your subgraph. So I named it Gravitar in the explorer. And if you do that, just ask for the subgraph name.
00:15:54.696 - 00:16:12.940, Speaker B: Kind of basic questions there. Now, last time I ran this, it had some errors with the yarn installation, but actually everything checked out when I ran through it. So we might see that again. But actually it's just like a weird yarn error.
00:16:13.100 - 00:16:26.260, Speaker A: David, we've got a question in the chat from Anne Mall asking, does Textiles Thread DB support indexing of its database entries? And if not, can we use the graph to index a project's particular database?
00:16:27.560 - 00:17:31.290, Speaker B: Yeah, okay, that I'm not 100% sure personally about textiles Thread DB, I haven't looked into it personally. I've heard of them before, but to be honest, yeah, I'm not totally sure. So, Animal, if you have some more in depth questions, you could definitely join our Discord Channel. And we're super responsive there and we could dig into it more, or there might be someone else in the team who might be aware of how that works. But as far as I know off the top of my head, it probably doesn't, but I would say it probably doesn't. But we could dig into it in the future in the Discord. So hopefully you reach out to us there anyhow? Thanks for the question.
00:17:31.290 - 00:18:22.280, Speaker B: I got that error that I was talking about before but it's actually okay. So at this point I've done this and now it's telling me to deploy the subgraph to the hosted service. So that's what I'm going to do. You see you have Graph Auth right here. So this is just asking you to authenticate with the hosted service and we actually give you an access token right here. So I just copied that and I'm going to copy the access token and I'm now authenticated for that. So if we now go into the graph and yet created this folder called Gravitar, we're going to go into it.
00:18:22.280 - 00:18:57.780, Speaker B: See there's a bunch of files there and we're going to open it in Vs code. And so this is the folder that gets made and what I'm about to run is called Graph deploy. But we're quickly just going to go here. So as you can see it gets auto generated. This is the command that allows us to deploy to the hosted service. We don't have to edit anything there right now but we do do this thing called Yarn code gen or Graph code gen. And I'll actually run that right now.
00:18:57.780 - 00:19:38.782, Speaker B: And so it just auto generated some files for us. Basically if we go here. Great place to start would be the Gravity smart contract. So this is a very simple smart contract as you can see, or Gravitar registry it's actually called. And all it is is basically storing like an identity on chain. You have an owner, you have the display name and an image URL which is like kind of an avatar. That's what I was thinking.
00:19:38.782 - 00:20:09.830, Speaker B: Yeah, exactly. So that's all it really is, super simple smart contract. And we're actually going to be paying a lot of attention to these two events on it. But this is where I can go in. So let's say you found this contract and you wanted to build a subgraph from it. The first place you would start would be basically looking at the subgraph manifest that I explained previously. So like I explained in the documents before, we now have a contract address that we know is on Mainnet.
00:20:09.830 - 00:21:06.246, Speaker B: We want to do things and edit the data whenever we see these two events get emitted. So we got new Gravatar and updated Gravitar. We just passed the event signature which you can see right here. And the other thing that should be noted is it's important to get the Abi for Gravitar to actually build the TypeScript code that we're going to allow to interact with the ethereum blockchain. So that's what the Yarn code gen command I just wrote or wrote right there was. So what CodeGen does is it makes this auto generated code. It goes over this abi and so the Abi is for smart contract and it allows you to interact with it on chain, right? And it simply just creates setters and getters for these functions.
00:21:06.246 - 00:21:52.380, Speaker B: Now you don't have to read into any of this code, it's auto generated for you. But what ends up happening is it just makes it really easy for us to interact with subgraphs and it's part of what makes subgraphs so useful. And also that data you won't really have to look into, but you might have to understand it a little bit. And now we are kind of going back to well yeah, there's three topics here that I want to talk about. The three previous ones that I talked about in the docs, we also have the schema right here. So this is simple, it's just a single Gravitar. So this is like an identity that somebody's storing on.
00:21:52.380 - 00:22:51.874, Speaker B: You know, it only has four fields, these exclamation marks, it's part know GraphQL's language, but that just means it's a required field. If I remove that, it means that could also be set to null. But those are things you can learn from GraphQL documentation or also reading a little bit of our documentation. And if we go into the details here so this is the mappings that I was talking about before and essentially what this line says is hey, this event. Luckily we're basically importing these events. And this is the entity we made in the schema right here, Gravitar. It's getting imported from the generated code from Schema and we're getting these two events which are generated from gravity, which come from the JSON file here updated.
00:22:51.874 - 00:23:36.634, Speaker B: So you see there, this is basically we have this event right here, updated Gravitar. We just ran yarn code gen and that created these events right here. So now whenever you go like this event params parameters, you can see all the event parameters like display name, ID, image, URL and owner on this object that you have imported. And if you go to the contract, that's exactly the names of the contract event parameters right here. So, pretty straightforward. We have a very simple object. We're saying this event happened on chain, let's handle it.
00:23:36.634 - 00:24:12.102, Speaker B: And whenever that happens, somebody created a new Gravitar. So we're going to make a new Gravitar and assign it its ID. So whenever you make an entity in the graph, it has to have a unique ID and that ID also has to be a string. So that's why we do two hex which is just changing it to a hexadecimal string. We store three of the event parameters as fields on the Gravitar and then we run Gravitar Save. And Gravitar Save is essentially like a saving to the subgraph store. So that entity is now in there.
00:24:12.102 - 00:25:06.422, Speaker B: And what's interesting about a subgraph is we can now load that entity in the future. So we actually have another event here, updated Gravitar and we're going to handle whenever that event runs. So there's a possibility whenever it's updated that it might have already existed. So we take the ID and then we go Gravitar load. So now we're loading from the subgraph store and we're going to get all that data in the scenario that for some reason that Gravitar didn't exist, whenever Load is ran, it will either return the entity or it'll return null. So in the scenario that it returns null, we'll just create a new one, otherwise the subgraph would actually have an error and it would crash when you push it to the hosted service and you would have to debug that. But we have it working right here and these three fields, we set them again and then we save it as well.
00:25:06.422 - 00:26:04.106, Speaker B: So this is a really simple subgraph and that's kind of the gist of it. If there's any questions here, it would be a good time to ask, but if not, I will deploy it to the hosted service and we can look at what it looks like there. Perfect. So if you remember we were back here, we've already ran install and init and now it's asking us to deploy and I already did run Authenticate. So now I'm going to run this command graph deploy. So right here what we're doing is we're essentially deploying it to the hosted service and yes, the hosted service is our infrastructure in the cloud that you can push to and a subgraph will be there. You can see these are basically our IPFS endpoint and our node as well.
00:26:04.106 - 00:26:28.766, Speaker B: And we're just going to deploy and we just have to give it the Gravitar. Sorry, give it the name that we gave it up here. So if you look here, my GitHub name Gravitar. Basically you just have to do that and run graph. Oh, go ahead Dave.
00:26:28.798 - 00:26:30.958, Speaker A: We've got a couple of questions from YouTube.
00:26:31.134 - 00:26:31.860, Speaker B: Perfect.
00:26:32.230 - 00:26:47.078, Speaker A: The first one is in the subgraph manifest. Is there a way to map over many, say 100 ERC 20 tokens and listen to transfer events from them without manually adding each token's contract as a data source? That's the first one.
00:26:47.244 - 00:27:28.210, Speaker B: Yeah, there actually is best place to show that will be the docs. So yeah, it's a good question. It's something that we call templates or data source templates. So exactly what the question is saying, it's like well yeah, maybe you want to look over 100 ERC 20 contracts or maybe even a good example is Uniswap. Uniswap is constantly creating a contract for a pair of tokens. So it's like there's thousands maybe or hundreds. I'm not sure of similar uniswap contracts that are all created by the uniswap factory.
00:27:28.210 - 00:28:21.750, Speaker B: So in this scenario, if you wanted to do 100 ERC 20 tokens picked randomly for your own choice, you might have to copy paste them. But usually the pattern that I see on Chain is something like the Uniswap factory, where you can just basically source the factory and then watch for every time there's going to be an event emitted that a new pair has been created, a new contract on Chain by the Uniswap factory. And then we'll write this simple code and it'll actually track all of those. So this is just an example in the docs. I'll go over it very briefly. So data source for the main contract. This would essentially be like the factory contract.
00:28:21.750 - 00:29:17.046, Speaker B: I think the example we're actually using here is uniswap v one. So there was a factory on main net, this was its address. And then there's this event that happens called New Exchange, which is basically a new smart contract being deployed on chain to trade two tokens. So that's what you do for the factory. And then if you notice here, I'll even copy paste this so you can see it in the manifest or in Vs code. So it's actually like we have data sources as well as templates. So what a template is going to do is essentially we create this thing, it's auto generated in the code.
00:29:17.046 - 00:30:04.120, Speaker B: I can show you a brief example here, although it'll just be me kind of like free handing it. But essentially you're saying there's this template which is like in this case it's a uniswap exchange. It always has these four events. You pass it the Aabi and then what you'll end up doing is something like this. I'm just kind of like free handing it. But you will auto generate that code and it'll come from up here and it'll just be like template bind and it'll be like whatever. If you created a New Exchange on chain, like in the uniswap example, you would take that event parameter and you would take that new contract address.
00:30:04.120 - 00:30:57.160, Speaker B: And what you're actually doing here is you're binding to this template, which is like a uniswap kind of trading contract, binding it to the new address. And what you've just done is you basically told the graph node to add another whole data source. So yeah, it's 100% possible to do that and it's actually very useful. I mean, we've seen uniswap itself ends up having right now with uniswap v two, it might be around like 800 or something different data sources that that single subgraph is tracking. So there's so many events coming in through that single subgraph and we use templates for think was there another question?
00:30:58.490 - 00:31:17.630, Speaker A: Sorry, there was. It was from Morgan saying how would you run test this locally? I don't know exactly when that came in. So it could have applied to some things that you've talked about, maybe walk through some basic instructions for running tests locally.
00:31:18.210 - 00:32:34.520, Speaker B: That's a really good idea too. I'll actually run through it here in the code how we would do it, and then I'll hop back to where I was in my browser and it'll all work out perfectly. So we have this thing called Graph TS graph TypeScript and it's automatically imported when you do graph init and it has a logging kind of like basically like console log kind of debugging for your sorry, there's that file for your subgraph. So here we would go import log and maybe it's smart if I quickly go to the documentation and find where we have that logging and debugging. So yeah, under Docs assembly script API, logging debugging. This kind of explains how it gets used. I could go into more detail but it's basically just, I think it's easier if I just do it right here.
00:32:34.520 - 00:33:30.380, Speaker B: Essentially it's just a string. This is kind of similar to what's done in Rust and then you show up every time you show these brackets, it's going to show the value right here and everything has to be a string. So if we just go event params owner and we go like that. So when I deploy this, we'll actually get to see it. So sometimes what might happen is, yeah, you will run a subgraph and you'll deploy it to the hosted service and then it fails and you're not really sure how. So this is a really good opportunity to use graph log and we're going to actually see this info message now when I deploy it to the deploy to the hosted service. So if you guys remember I ran this command, I'll do it again.
00:33:30.380 - 00:34:25.254, Speaker B: So now that I'm running it again, it's actually going to deploy a different subgraph. But let's see what happens. So then, now essentially this subgraph is what I deployed and now it's actually being indexed by our graph node in the cloud. And this is kind of like how this is the playground right here and you can use this to kind of inspect your data very easily. And then on the left side here you're writing GraphQL queries to see what kind of data you're getting returned. So as we can see, this is data that's on Ethereum mainnet on this contract. And it's basically like a couple of people's identities that they made or gravitars.
00:34:25.254 - 00:35:20.326, Speaker B: So they have like an image URL their Ethereum address and their display name. And some of these are more readable and then they have an ID. It's just 1314 1211. So this is kind of like it's a very simple example, but it's really rich when you get into more complex things. And so if it actually fails, what you would see is this will say like syncing failed and it'll be red and the best way to debug that is to go into the logs. And so now this is kind of like the logs of the graph node and it should give you details on why it's failing. So this subgraph is not failing right now it looks all good, but if you had an error, you can start to decrease the logs to okay, where am I warning? Only show me warnings or only show me errors.
00:35:20.326 - 00:36:11.450, Speaker B: And then it'll give you details on what the error is. And at that point you can actually see those errors and determine what they are. So something. That's going on right now. I was going to show the log info in the playground, so I wanted message to be displayed to be showing up over here. The thing is, it's syncing very slowly right now because it started at block zero. And what we can actually do here to try to speed this up, I'm not 100% sure if it will work, but I think we had it actually in the documentation.
00:36:11.450 - 00:36:43.570, Speaker B: Um, we're here, so it might work. If I just take this block and we'll see if I redeploy it, we might actually get to see those 1st 6 million blocks get skipped and then we might get to see that log message in the subgraph. But if not, I'll move on.
00:36:43.720 - 00:36:50.730, Speaker A: We've got just one more question saying can you also run subgraphs on private chains?
00:36:54.030 - 00:37:35.240, Speaker B: I believe so. I'm not 100% sure. I'm just trying to think about it conceptually. I'm over 90% sure you can, and if not, you can come talk to us in the discord. But I'm also thinking like, well, I know you can run it against Ganache because I've done that before in the past. So, yeah, if you're running it against Ganache, I'm like 100% sure that it would work. We might have to give you some sort of configuration, but yeah, you can definitely do that.
00:37:35.240 - 00:38:27.160, Speaker B: And so if you see here I'm not sure if oh yeah, I just thought there so here we're actually message to be displayed. So I'm logging that kind of it's coming up as this weird thing because I guess I converted something to a string when it should have been a Hex string. But essentially yeah. So maybe if you're getting incorrect data and you're not sure why, you can start logging in a mapping and it'll fail, but it'll still print that information. Yeah, I was just looking at the chat. Yes. And testing and Ganache does work pretty well.
00:38:27.160 - 00:38:39.050, Speaker B: So it also works very well on testnets. Like if you're on Rinkabee and you're testing your kind of smart contracts before putting them on Mainet, it works perfectly.
00:38:39.630 - 00:38:51.790, Speaker A: Got one more question from YouTube. Don't you need to run yarn code to Gen anytime you make changes in the manifest APIs or Schema before deploying?
00:38:55.750 - 00:39:51.554, Speaker B: What happened there? I would say in general, almost always, yes. What just happened there is I actually just changed the start block here, so it'll still try to deploy if I haven't run yarn code Gen. And what yarn code Gen does is it kind of creates these TypeScript files based off the Abi and also the schema. So in this scenario, what happened is I updated start block. This manifest still gets pushed to the hosted service, but it didn't actually like changing the start block, didn't change any of the code gen files that get created. But the question is a good point because if I changed the handlers, I would have to change it. If I changed, maybe the Abi or the contract address, I might have to change it, and especially if I change anything here.
00:39:51.554 - 00:40:30.254, Speaker B: So when I added this, I definitely had to or no, sorry. No, you don't have to run yarn code gen if you're doing this. It's more so just whenever you think anything will change from generated files, you have to run yarn code gen. But I usually run it quite frequently if I'm doing a lot of development. And I'll even kind of like if you wanted, you could put it before your deploy command and just to be safe, because then you'll never because that's an annoying bug, is when you don't know why it's broken. And all you have to do is run yarn code gen before. So you can definitely do that as well.
00:40:30.254 - 00:41:17.710, Speaker B: It's a good question. Yeah, thanks. You start digging into the subgraph. Now, the thing about the Gravitar subgraph is it's kind of like straightforward and not that complex. And like I said before, if you go to Uniswap, you can see all of these. So they've built out this schema. It has the Uniswap factory, right, the amount of pairs or like, exchanges that have been created, the total volume in USD and in ETH, the total liquidity transaction count, you get all these interesting things.
00:41:17.710 - 00:41:53.626, Speaker B: And if you know a little bit more about GraphQL, you can start putting other entities as fields on other entities. So we have token day data right here. And you go into that, you have the token, the date. So this is basically what token day data? I'm not exactly sure, but Uniswap info, this application runs off of the graph. So these charts you're seeing here are actually built with the graph. And I haven't built this subgraph myself. Like, this is the Uniswap team that built it.
00:41:53.626 - 00:42:39.494, Speaker B: So I'm not exactly sure how they did it. But it's very interesting to go to like so if you go to Uniswap's GitHub, they have this V two subgraph. And this is where you can kind of see a lot more of a rich example of a subgraph in action. And they have the Uniswap factory entity typed out here, the token entity for a token inside of Uniswap, the pair kind of smart contract that's created for each trading between two tokens, a specific user and all their positions. And this is kind of minting and burning and swaps. And this is where they probably build. Like what we're seeing here.
00:42:39.494 - 00:43:19.574, Speaker B: Maybe this is hourly and this is probably pair hour data that they're kind of showing. And so they're calculating all this data. So you can imagine, like, one trade happens, but data is stored for the day, for the hour, for Uniswap total, for the user themselves, for the transaction. So you can get very rich kind of subgraphs here. And so this is a really good example if you want to look at some complex subgraphs and see what you can build, go to Uniswap and see what they have. This is exactly what I was talking about before. They have this template set up.
00:43:19.574 - 00:44:12.374, Speaker B: So this template tracks a bunch of different smart contracts for Uniswap. And then they have like normal one, the factory right there. And they also have the abis here. So interestingly, if I were in the hackathon and I wanted to build an Ethereum kind of or no, sorry, a Uniswap subgraph, I might go to their GitHub and find what I want to download. And this is one of the abis they have for pairs. So you would go, copy this not what I want. So I wish there was an easier way to get this.
00:44:12.374 - 00:45:17.660, Speaker B: There we go. So copy that. You could use like the graph init example. So this is what I did with graph init, right, kind of like boilerplate basically replace that, rename it to pair. And now I start updating my subgraph so that we can actually or maybe if you really wanted what I did there is I took the pair and now code would be auto generated from here when I run yarn code gen. But also it's like for the sake of time, if I really wanted, you can just start going like this and copying all this kind of code over and you end up building your own subgraph. Now, it's not that simple to just copy paste and make it work.
00:45:17.660 - 00:46:03.794, Speaker B: But when it comes to the subgraph manifest, sure, if you're finding the right contracts you want. But maybe you want to do something different with Uniswap so you know that they have all this trading data like this. Maybe you have some other idea of how you would want to display the trading data. Maybe it's like Uniswap doesn't have very rich user kind of charts. It's all specific to token trading. So that's even a good example right there. You could analyze all the Uniswap data and maybe show an analytics site for somebody who uses Uniswap a lot and it'll show them their daily trading amount and how much they've earned and how much they paid in fees.
00:46:03.794 - 00:46:50.966, Speaker B: And I mean, that's just one idea right there off the top of my head. But you can kind of do this for so many projects out there. You could do it for compound decentraland, some of these projects that have a lot of actual on chain activity. Aave, a lot of these. This is the Ave protocol subgraph. It's more about how their protocol works and they probably use it for their front end somewhere. But once again, you could make like a user specific Ave subgraph that allows you to log in with an Ethereum address and see all the transactions you've made on Ave and that would actually be really cool.
00:46:50.966 - 00:47:56.926, Speaker B: So that would kind of COVID like that's what we're talking about when we're saying like best new subgraph. Now you could make a subgraph for your own project too, that you've been working on for a couple of months and so that would be really cool. And then obviously the best use of a subgraph is just like actually using the uniswap subgraph in your own front could. For another example, you could take Compound and Uniswap and Aave three really popular DeFi protocols and then combine all three of those into some sort of front end and make a really cool DeFi front end for users as well. I also see there's another question right here, so I'm almost done, I'm just going to read this question really quickly. Since you can also index IPFS data, I'm supposed to pin the content on one of your IPFS nodes so the graph can resolve it quickly. Which of your IPFS nodes shall I connect? Ask to pin content to docs are a little thin on that.
00:47:56.926 - 00:49:34.540, Speaker B: Yeah, we might not even explicitly mention it in the docs, but essentially um, where's the deploy? Oh, it's in quickstart. Oh no, actually I don't no, I remember where it was. If I just create a new subgraph right now, if you look at the deploy command, it shows right here, like when you're running graph deploy, you pass this and you basically say IPFS and this goes API IPFS at the graph.com. And when you push it to that endpoint, what it's essentially doing is uploading to our own IPFS node. And yeah, you'll also see that that gets auto generated right here in the code as well. So as long as you just push to there, it will be on our node and then it'll actually index that data for sure. You want to do that? Because if you don't I'm trying to think in my head.
00:49:34.540 - 00:50:49.742, Speaker B: Yeah, it's possible that if you have your own IPFS files and you just uploaded them like it was like profile data or something, and you just uploaded them to your own IPFS node and then it was connected to IPFS, but it didn't propagate through the IPFS gateways very well. It's possible that our IPFS node will not actually pick it up and then it'll just basically kind of like time out and that data won't be displayed in the subgraph. So if you run into that scenario, come chat to us in our discord and we can definitely help you with that because it's just a matter of getting our IPFS node to actually find the files and it can happen that it might not propagate there. Okay, perfect. So yeah, basically come talk to us if that happens and we can definitely help you. And so with that, I'm pretty much done. I mean, I deployed the subgraph, not that one, I deployed a subgraph.
00:50:49.742 - 00:51:21.390, Speaker B: I showed you guys kind of like a little bit of a cooler example with Uniswap and gave some ideas there and went over the documentation. So kind of close with the prizes there and what we're hoping to see. So I guess. If there's any more questions, let me know right now. And if not, just either go to the E Global hackathon. I think you guys have a discord channel and if not, you can also come to our discord channel and ask questions. But if there's any right now, I'd be happy to answer them.
00:51:21.460 - 00:51:45.014, Speaker A: We've got two from YouTube, the first from Sahaj. Can you provide a quick example if possible? If you have a user, what how will you go about getting data on if they are using certain protocol and value in it? It's a little bit of a confusing question. Did you get what the general gist of it was though?
00:51:45.132 - 00:52:42.470, Speaker B: Yeah, I think I do understand. So essentially I hope I follow what the guy's saying. But I think one of the suggestions that I made was kind of I was like, oh, it would be cool if you use Uniswap and Compound and Aave and went and looked at a user profile perspective and show them how they're doing in all those protocols. And that would actually be very complex. Maybe a better example would be to just use just uniswap by itself because like I said, uniswap info shows more like the protocol level stuff. Maybe you could show account level stuff. So what would happen is essentially here is Uniswap's kind of like template for events that are emitted on chain.
00:52:42.470 - 00:53:52.586, Speaker B: And if we go to that's like their subgraph manifest, right? If we go to the mappings for core, maybe, I'm not 100% sure, but yeah, mint event. So what's happening here is they're making like this is handle I'm just looking for okay, yeah, here. So this is like when somebody mints like a liquidity pair on the Uniswap kind of protocol. A lot of this stuff is like uniswap protocol based for what's happening in Uniswap. But if you wanted to figure out from a user perspective you would start doing it. You'd probably make the ID like event params sender. So all of a sudden, instead of being kind of like, I would say the first class entity in the Uniswap subgraph is like an exchange and you're looking at how many trades are happening on that exchange.
00:53:52.586 - 00:54:39.606, Speaker B: But in this scenario I'll try to open this again over here. In this scenario we want to think about the end user as the first class kind of like entity. So right here we're seeing all this rich data with Tokens and we're making the ID the Token address. Now, if we go here, I think they have a small user identity right here. But instead of this, what they're doing, you create the first class entity as a user and you think about your subref in that perspective. And then you start saying you start recording all their trades. And then in here you would add another line like trade.
00:54:39.606 - 00:55:10.440, Speaker B: And then you might start recording. It'd be hard to do, but recording the profits of each trade that you could make. And so basically it starts from kind of like what you're treating as the main entity in the subgraph. And so the way to do that is first think, okay, their Ethereum address is the ID I want to use. And then you start treating kind of all the event data through that lens. And that should be able to give you kind of an idea. I hope that answers the question.
00:55:11.530 - 00:55:18.010, Speaker A: Got another one from Morgan. Will it be expensive to query subgraphs once Mainnet is launched?
00:55:18.670 - 00:56:22.606, Speaker B: Yeah, that's a great question. Essentially, what we're looking at there right now, the hosted service is basically free to run. And we've been doing that for the last two years or whatever. And whenever the network launches, there'll probably be some sort of grace period where we're still running the hosted service and then we're allowing the network to run where people are paying for queries. And realistically, the whole design is so that it should be economically viable and the queries will definitely be like fractions of a cent. But the idea is also that these people that are indexing the subgraphs will make some money. So I would expect it to be fairly cheap still, when you compare to running your own kind of infrastructure in the cloud, whatever you pay, there should be something like around that price.
00:56:22.606 - 00:57:24.660, Speaker B: But at the same time, we're still figuring all of that out. And we're also expecting, if you've ever dug into our protocol, we're doing some stuff to basically batch transactions and stuff and queries with state channels. So what we might actually see is some DApps paying for their users queries upfront. So if you're like Dharma and you use a subgraph, you might just be paying these fractions of a cent for all of your users. And at the end of the month, it costs them $1,000 for all these queries for all their users. But also, if they've created their own subgraph and they've curated on it, you can actually earn rewards in the graph network. So it's just part of the whole economics of the network and that's something that we're working on and we're excited to get when the network comes live.
00:57:25.190 - 00:57:34.866, Speaker A: Awesome. Yeah, there's another question from Ann Mall and then one from Fox, and then maybe we'll call it after that.
00:57:34.968 - 00:57:36.018, Speaker B: Yeah, sounds good.
00:57:36.104 - 00:57:44.390, Speaker A: Okay, great. So Anmol asks, in general, can we index data from other sources apart from Ethereum and IPFS? Like ceramic?
00:57:46.030 - 00:58:24.538, Speaker B: Yeah, that's a great question. Right now we do not have anything else. Basically what there is is Ethereum and then all Ethereum, like testnets a couple of other chains. Like, I'm trying to think like, I know Xdai is possible, POA network is possible, and then there's maybe a few other EVM chains. It's also really easy to add support for those ones. We also do have IPFS. We do have plans to go multi blockchain in the future, so it could be ceramic.
00:58:24.538 - 00:58:44.970, Speaker B: It could be polkadot, it could be something like that. There's nothing figured out in that domain yet because we're really focused on launching the network right now. But definitely that's part of our whole entire goal is to get multi blockchain in the future. So it's definitely something we'll be looking at after network launch.
00:58:47.390 - 00:59:09.566, Speaker A: Awesome. It looks like Fox actually has a couple questions, so I'm going to suggest that, Fox, you reach out to Dave in the discord channel just so you can dig into those ideas a bit more. Keeping an eye on the time. Awesome. Thank you so much, Dave. This is kick ass presentation.
00:59:09.758 - 00:59:15.490, Speaker B: Awesome. Thanks so much for having me. And yeah, come chat with us in the discord. Thanks a lot, guys.
00:59:15.640 - 00:59:18.350, Speaker A: Cheers. Thanks, everyone. Bye.
