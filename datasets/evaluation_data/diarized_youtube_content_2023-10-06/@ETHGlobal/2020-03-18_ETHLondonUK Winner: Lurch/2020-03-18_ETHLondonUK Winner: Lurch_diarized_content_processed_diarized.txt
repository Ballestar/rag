00:00:00.410 - 00:00:19.914, Speaker A: So what is lurch? So, Lurch is this awesome new product I built. It allows you to execute Ethereum contracts on Ethereum. It's amazing. So everyone's favorite feature of JavaScript? Come on, say it together with me. We all know that it's ah, crap. Eval. Everyone loves Eval.
00:00:19.914 - 00:00:45.958, Speaker A: It's such a useful feature. It's flexible, it's easy to use, and it throws all security right out the window. All things that we desire. So we can go a little bit better these days in JavaScript and instead use the VM module. This unthrows things out the window a little bit in terms of security, but it also gives us hookability, which I'll cover more in later. So what is lurch? It's written 100% impure EVM assembly. It's under 2 KB.
00:00:45.958 - 00:01:16.530, Speaker A: I'm not sure if people are used to writing an assembly. It just makes you want to tear your hair out sometimes. And I'm doing good though, so yes, basically it's an Eval for Ethereum. It's performant ish the cost analysis is later on as well. But basically it's an EVM emulator written in EVM. So it doesn't matter whether your contract was written in Solidity or Ll or Viper or whatever you use, it'll just work. You give us some bytecode and some call data and it just runs.
00:01:16.530 - 00:01:45.182, Speaker A: So there was two other options I was going to add, but time ran out and hackathon yada, yada, yada. This will still be complete at some point in the near future, but basically you have a smart contract. This is the solidity signature. It's not written in Solidity, it just knows how to pull Solidity signature apart. So you give it the bytecode, you give it the call data, and whatever your call in that contract for that data returns is what it will return. I will give a quick demo now. Yeah.
00:01:45.182 - 00:02:21.160, Speaker A: Everyone else has had a beautiful UI. This is the antithesis of the beautiful UI. As you can see, I've been running it before for the various things. It's going to price, say the exact same numbers. So what it's doing right now is it's deploying an ERC 721 sorry, ERC 20 contract to a DevNet at the same time it's deploying Lurch. It's then taking that same ERC 20 contract and running it entirely through Lurch as well. Just so you can see that both the real ERC 20 and the ERC 20 that's running inside Lurch are both doing the same things.
00:02:21.160 - 00:02:51.970, Speaker A: The important thing is you can see it started off with 10,000 units, and then it went down by 42 to 9958. Yes, the math works out. And that's my beautiful UI. Yes. The one other kind of interesting thing to note is so this right here I ran earlier on Mainnet. If you want to use it's at Lurch ETH, you can see there's no other transactions that have ever been sent to this contract. It was able to execute code.
00:02:51.970 - 00:03:20.454, Speaker A: Any existing way to kind of do this require like paying and doing transactions, that sort of thing. This just lets you do it for free. Let me go back to my slides again. I'm going to power through some of them because how does it work? It's a little bit like a virus. This is more complicated than I really have time to get into right now, but please feel free to come after and be like, Yo, what virus? What? And I'll explain to you. So random use cases. So counterfactual verification.
00:03:20.454 - 00:03:52.518, Speaker A: Currently, as it stands today, if you're trying to counterfactually verify something and somebody's lying, you might have to deploy a whole black load of contracts and then execute them to prove you're being lied to. Instead of all that, you can just simulate running the contracts. Yes, you can also do large contracts. I didn't get a chance to get a demo together. But for example, you could easily build a two gigabyte contract with this because you only ever need to put the piece of code around that actually gets executed upgradable. Forward storage. The next part is more interesting.
00:03:52.518 - 00:04:29.330, Speaker A: I'm going to skip by this because it's just kind of like a reworking of this. Yes. So, for example, this allows you to run arbitrary code. Anything you want to do, you can just take code from your users and do what that code does, but you can put hooks in it. So, for example, maybe you don't want a person to be able to sue side your contract. If they try, you're just going to roll back the whole transaction and consider their data invalid. You can hijack pre compiles if you're doing some cool new thing, or you want to replace a pre compile, or you just want to intercept addresses, maybe you only want to accept addresses that own a CryptoKitty.
00:04:29.330 - 00:04:49.754, Speaker A: Forwarding storage is interesting as well, but I'm trying to keep this short. So please feel free to come up and bug me with that as well. Bug me with anything limitations. I don't currently have the jump desk checking for anyone who's done EVM stuff. Push Ops have a really weird restriction for the EVM for security reasons. And yada yada, yada. It's not done, but it's easy to do.
00:04:49.754 - 00:05:13.118, Speaker A: I just haven't done it. I also eat up four slots on the stack. These things are really important for this discussion. There's no gas metering. It does cost more. So onto cost analysis. So to do a simple symbol of an ERC 20 contract, it costs about 60 times as much to run it through Lurch right now.
00:05:13.118 - 00:05:29.046, Speaker A: These will come down. But you see, like, once you start having I don't want to point at my screen. That doesn't help you forget balance. For example, you see, it comes way down. That's because you're doing a read operation. And read operations expensive. The more expensive the operations are, the better your deal is.
00:05:29.046 - 00:05:40.150, Speaker A: Which is why, if you're doing a transfer, you see you're only paying 1.6 times as much to run in this. Yes, I think that's all. So, huzzah.
