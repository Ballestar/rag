00:00:06.490 - 00:00:23.966, Speaker A: So without further ado, I'd like to welcome Garrett, who's going to talk about how do we actually use Viper and build more interesting things and use DeFi as example base for getting the best out of the Viper. Lang so Garrett, feel free to turn on your camera and get started. Excited to have you.
00:00:24.148 - 00:00:51.020, Speaker B: Hi, Karthik, thanks very much for having me. Very excited to be here and addressing everyone worldwide. I think you nailed it. We're here to talk about a lot of topics around, specifically some of the tooling that I think makes Viper really great. And in particular, the Use case that I'm going to be focusing on is how you can apply Viper to DeFi, but open to kind of talking about anything. What have been some of the kind of highlights you've seen so far?
00:00:51.710 - 00:01:10.222, Speaker A: You are the third talk and we're just sort of ramping up as we kind of go into more and more in depth of different depth tools and SDKs out there. So I feel like people are slowly building towards learning about the internals of libraries that they use, like Ethers and Wagme, and we're going to kind of start off from languages to SDKs.
00:01:10.286 - 00:01:46.666, Speaker B: So that's the plan for today. Excellent. I'm very excited to be giving this talk here. Let me get my screen share going real quick because this is a bit of a modified version of a less technical talk that I was giving in ETH LATAM back there. I was focusing on introducing Viper to a broader audience, but it was not a technical talk specifically. So in this case, I'm going to be talking more specifically about some of the tooling, specifically Brownie and Apeworks, as well as the newer Titaniboa. So all of these are really great tools.
00:01:46.666 - 00:02:32.718, Speaker B: They can be for the first two used with Solidity as well. But Titanoboa is native to Viper. So first I'm going to give a bit of background because I expect most people are very familiar with Solidity. And I wanted to talk a bit about some of the origin story behind Viper and how it is that it came to be what it is and where it might be advantageous in some ways or might have some drawbacks. So many people don't know this, but Viper was actually started by Vitalik himself. This was his concept way back. It was a language called Serpent and it has quickly outgrown Vitalik's initial vision for this.
00:02:32.718 - 00:03:13.046, Speaker B: So Viper is no longer directly developed by Vitalik, but it has sort of like evolved and the community took it over and really decided to take this into kind of the next level. And while you might think that this means that Vitalik is in some way casting Aspersion on Solidity or something like, I just want to start this by saying that I teach Solidity for night class. So I like solidity. I like viper. I think both are great languages and this is not intended to cast aspersions on any particular language, but just want to give some pros and cons of both. And also to point out that all of us are really united in our shared goal of having multiple different languages. Like the EVM.
00:03:13.046 - 00:04:28.286, Speaker B: The Ethereum Foundation is actually working on additional languages beyond just Viper and Solidity, because we want, at the end of the day, all of us are united in wanting more great smart contracts to get deployed. So if some people want to deploy using Solidity, some with Viper, and we have 15 other languages that make more developers comfortable and feel good, writing code like this is what unites all of us. So, for example, one of the other emerging options is Fe. Hopefully we end up with a lot of different ways, because at the end of the day, these are just human level abstractions. And what we're really trying to avoid is writing this extremely raw level bytecode, because anyone who's had to manipulate bytecode knows that it's not as bad as it first looks, but it's much better when you have these higher level interpreters that allow you to do that allows you to do much more significantly readable and understandable options. And this gets to why you might pick Viper over some of the other languages, because more than a lot of other languages, I really see how Viper as a language has been shaped by its core values. So from the start, when Viper was launched, it decided to rebuild this sort of concept of a smart contract programming language around three core values.
00:04:28.286 - 00:05:14.062, Speaker B: The first is security. And anyone who has been cryptocurrency knows that this is absolutely critical because there's such an amazing number of hacks, it's mind boggling. And Viper wanted to address this with this actual syntax and say that at the development level it should be possible and actually just fully natural to be able to write secure smart contracts. That is, if you're a new person writing the code, it should have security embedded by default, so that you don't have to have an advanced level of understanding to be able to write smart contracts that aren't going to get hacked. The second value is simplicity. It always strives to make the code easier to understand for the reader, even if this comes at the expense of the writer. And going a bit further, it prioritizes simplicity for readers who even don't know how to code.
00:05:14.062 - 00:05:59.546, Speaker B: And this is one of the reasons that Viper is architected off Python, because Python as code is fairly easy to fairly legible, even to people who don't understand what's going on with its human readable syntax. And this ties into the final point of auditability, because we know that auditors do their best, but they can't always catch everything. It can be very, very difficult for auditors to catch all the bugs in code. So Viper wants to make it difficult to write misleading code. And this has fueled a number of different design decisions. So if you're familiar with Solidity when you're getting started with Viper you might be confused by some of the things you're very used to in Solidity not having an equivalent in Viper. It was chosen to simply not include it at the core architecture level because it sacrifices one of these principles.
00:05:59.546 - 00:06:40.998, Speaker B: For example, Solidity, it's common to include like an only owner modifier. Viper doesn't have modifiers because they thought that it would be too much work for auditors to have to jump back and forth between modifiers and the function calls to understand what's going on. Similarly, there's no function overloading because that could be a security risk. You could have an overloaded function where you're expecting you're calling one version that's fine and you actually call a different version that does something different. Viper is not Turing complete because the EVM is itself not Turing complete. Solidity is technically Turing complete, but it's running on a non Turing complete EVM blockchain. So Viper within the language caps all of its loops.
00:06:40.998 - 00:07:17.618, Speaker B: Solidity doesn't. You could theoretically write an infinite loop in Solidity. It won't execute because the EVM will run out of memory before it can execute it. So Viper puts this restriction into the coding and this can be an issue for some people because you have to have all your arrays capped. It used to be the case you couldn't have dynamic arrays, now you can, but they still have to have a maximum size. And because of this, Viper is not having to use this dynamic array pointer when it's deploying code, which means it can deploy very efficiently. But it also has this trade off in that you aren't able to have like an unlimited array.
00:07:17.618 - 00:08:20.918, Speaker B: So for example, if you have to define the max up front, that can be off putting to some people. Another one we'll talk about is no raw bytecode and no inheritance, although this is going to change. So no raw bytecode means that there's not a way of just injecting raw a couple of lines of bytecode here or there because it sacrifices this capability of being easy to audit. With Solidity you can inject Raw bytecode and as a result, Solidity actually has the advantage on this if you need to. For example, we'll talk of a couple of examples where being able to inject Raw bytecode gives Solidity this incredible efficiency, but it comes at this expense of readability, whereas Viper forces the readability and relies on the compiler to get the efficiency out of it. And no inheritance for now is another drawback, which we're going to talk about in just a second. But this brings us to where these different principles and this difference in architecture has really caused sort of in my mind, a difference in the ideal use cases.
00:08:20.918 - 00:09:17.198, Speaker B: So Viper has a lot of advantages in terms of it's really efficient in terms of compilation costs and generally speaking it's slightly more gas efficient out of the box, but some of these things give it a bit of drawback. So I'll be the first to say that Viper has never really been good at NFTs, and as a result, I think that Viper has kind of ceded this ground because Solidity's advantages make it a sort of natural fit for NFTs. So we mentioned that some of these advantages of Viper are things like it's very good at gas optimization, but NFT people don't particularly care that much about gas optimization. Every NFT that gets minted has this theoretical optimum price, and it doesn't really matter to the user whether they're paying that to the contract or they're paying that in the form of gas wars. And as a result, we've all seen the experience of wanting to make a transaction and having to wait because the gas prices have just spiked. Because there's some new NFT drop, it costs 0.1 E to mint and people are spending $500,000 to mint it.
00:09:17.198 - 00:10:19.060, Speaker B: In fact, this year the other side, meta had set some records in terms of the amount of gas that people were paying to mint this. So even though Viper may have an advantage on gas, it doesn't really matter in this space. Similarly, Viper might be more auditable, but generally speaking, NFT contracts are fairly easy to kind of cut and paste, so they really benefit from the solidity capability of importing modules. You can, for example, use Open Zeppelin templates if you're at all not concerned about gas, they cost a little bit more, but they're very readable, so it's easy to kind of be able to plug and play. And no one is really particularly caring when they're auditing this because they're not expecting to get money out, they're throwing money at it, hoping to get an NFT out, and they don't particularly expect that their deposit, they don't worth it, gets hacked, they just care about reselling their NFT at a later time. So as long as the core NFT contract works, you can just use the Open Zeppelin documents and you'll be fine. And by and large, a lot of NFT people are not going to be reading through the code.
00:10:19.060 - 00:11:29.914, Speaker B: So the corollary to this is that Viper kind of punches above its weight in DFI in my opinion, because people do care about things like security auditability and these core values that have been built into Viper. So it's sort of slight because by far like 99% of contracts are still solidity. But I say that Viper punches a bit above its weight in terms of the total volume that's been entrusted in dollars terms to Viper contracts, even though it's about like 99% of all contracts are solidity, viper has about ten to 20% of the TBL, largely through like curve Finance yearn lido finance. Similarly, the gas optimization within solidity versus Viper benefits Viper in that a few guay worth of gas savings can be a huge difference when you're talking about smart contracts and DeFi. It can be the difference between using one exchange versus another. So for example, it's very common to see one exchange will be cheaper in terms of its underlying gas usage, sorry, it's cheaper in terms of gas usage, but it might be more expensive for slippage. And whether it's a big or a small transaction, you'll default to one or the other.
00:11:29.914 - 00:12:15.538, Speaker B: And finally, a lot of the kind of underlying properties of how viper has been architected at the compiler level includes a lot of higher level math functions, and I think that for a lot of the DeFi contracts we've seen, we're really scratching the surface of kind of more complex functionality built into it. And a lot of the math is there and screamingly efficient within viper contracts. Moreover, there's no such thing as stack two deep error within viper. So if you want to write this contract with extreme levels of complexity, it's just a bit easier to do it using viper. So my contention is that they're both good choices for in some cases they might be better suited to any use case. Both are actually solidity and viper are great for both of these. So of course there's some really fantastic protocols built in both solidity and viper.
00:12:15.538 - 00:12:59.294, Speaker B: But recently there's been this phenomenon emerging which has been popularly called hot viper summer, which is where this past summer, more people have been looking at Viper and giving it kind of a second look and trying it out. Part of this is because vitalik, former founder of viper, went ahead and started to promote it. But the real difference was when viper 3.2 to 3.3 got released and before this there was actually structural differences, like you couldn't have some abi types in viper that were supported in solidity. And this is one of the reasons that viper really was bad at NFTs, which was that you couldn't have a bytes four type in viper before version 3.3, and the openc API required this for checking interfaces.
00:12:59.294 - 00:13:35.226, Speaker B: So it was not possible to get a viper NFT on OpenSea to my knowledge. Maybe someone figured out a hack, but I believe I'm the first person to have done it, so I feel pretty excited about that. So people started taking a second look at viper and found that when they first tried it a year ago, it wasn't quite there. But now it not only has all these efficiencies, but the compiler and the interpreter is really great to work with. So this became at this point more of like a preferential choice, like there wasn't any structural reason why you might need one or the other. And people started saying, well, let's take a look and see. And now there are different arguments against viper that started to emerge.
00:13:35.226 - 00:14:36.414, Speaker B: Like some people said, the ecosystem wasn't as big as solidity, which is very much true. The solidity ecosystem is huge, the viper ecosystem is small, but very friendly, and I would definitely invite people to join the discord to find out more about it. And this brings us to Tooling, which is the second thing that was listed as a drawback because there is a lot of advanced tooling that's been created for solidity. But in the past few months, viper has really caught up on the tooling level as well, particularly when we get to Titaniboa to talk about it. So as we dive more into this question of viper tooling, I wanted to bring up one of the first things that people always bring up, which is foundry support, because viper here's one particular person who tried using viper during hot viper summer and found it worked pretty good, but was still looking for a bit more deep foundry integration. And when you were dealing with complex contracts, felt familiar with foundry. So for people who do want to use foundry, we're not going to touch too much on it, but I do want to point you to this repo that Ox Kitsune has been making called Foundry Viper.
00:14:36.414 - 00:15:10.046, Speaker B: And it's very actively maintained and it's foundry template that allows you to compile and test Viper contracts. So if you want to work within Foundry, you can do this. Similarly, if you like hard hat, there's a hard hat plugin. But a lot of people within the Viper community opt for brownie. And I wanted to walk through a couple of use cases of some ERC 20 applications using Brownie. So if you're not familiar with Brownie, it's a Python based development and testing framework and it supports Solidity as well. And it works very well.
00:15:10.046 - 00:15:43.146, Speaker B: Solidity. I've used Brownie to build entirely solidity only repositories and applications. But because Brownie is itself python based, it sort of is a natural fit for Viper, which is itself also Viper based. And it uses Pytest for its testing suite. And if you've had the privilege of using Pytest, you'll find it's a very robust framework. It can do many things that you need to do for building out tests for your contracts, including property based and stateful based testing using Hypothesis. And then there's a bunch of great debugging tools built into it.
00:15:43.146 - 00:16:58.178, Speaker B: So it's an incredibly robust framework for testing a lot of these DeFi applications that are built using Viper. So Curve has built out very extensive repositories in which they have robust testing for incredibly weird edge cases using Brownie. And because it's been very efficient at utilizing this Pytest framework, to date, there's been not a single back end hack of Curve, although I'm always afraid to say that because I might look over and see that while I'm speaking, it got hacked. But I'm going to walk through just a couple of quick use cases for how you can actually use Brownie to quickly get up and running using a simple ERC 20 token. So within Brownie, there is a bunch of pre built brownie mixes, and these are some templates that people have created and published to GitHub that allow you to just quickly import a project into Brownie. And I'm going to use the example of a Viper token which is going to just clone the repository and create a Viper token just like that for us to work with. And we'll pop into here and I'll take a look and walk through what this default token looks like.
00:16:58.178 - 00:17:46.974, Speaker B: And it's still on version 2.0, but this should still work fine if you bump it up to version three or higher, which is where Brownie is now, or sorry, Viper is now. And walking through the syntax here, you can see that the entirety of this is actually legitimate Python. So this would be Pythonic itself in terms of all the syntax. With these 1st 20 some lines there is all this up through line 31 is all the contract level state variables. So we're able to include everything we need from the ERC 20 token in terms of a single hash map of balances and allowances. And that gives us everything we need to be ERC 20 compliant.
00:17:46.974 - 00:18:31.920, Speaker B: Line eleven, here is the check for that. Line 14 through 22, we're defining the events that we're using to log and emit our constructor function, uses the underscore underscore init function and everything else. Most of it is actually the doc strings because Viper. One of the nice things is the compiler is also very strict about making sure that the doc strings are properly formatted. And as a result, most of the code here is actually just the level of documentation provided. But we see it all the balance of allowance approve, all the classic ERC 20 functions are included here. Within Viper you have to have your internal functions preceding when they're called.
00:18:31.920 - 00:19:13.642, Speaker B: So in this case the transfer function is utilizing this, which simply does an assert to check if the balances are viable. And then it makes a transfer. Transfer from works about the same. First it checks the allowances, then it updates the allowances with using subtract equal value and then we return. True. So included within this repository is also a variety of tests. So you can see within the Pytest framework, you always have a conf test which is going to be the fixtures.
00:19:13.642 - 00:19:46.204, Speaker B: In this case there's only the one to create a token and deploy it. And then loading through the tests, we'll take a look at, for example, test approvals. All the tests are written out here. I'm going to run the tests on this side so we can see what it looks like. We have 38 tests in total. The tests all they've compiled, you can see them running. They're going to be fine here because we don't have any particular issues with this.
00:19:46.204 - 00:20:38.090, Speaker B: I'll walk through what it looks like and some of the debugging tools inherent in Brownie so we can see what it looks like when the tests fail. But as expected, the sort of simple Viper contract we have is everything that we need. And if you want to also you could fire up a console either by running Brownie console, or you can run some scripts and pop into the console that way. So coming with this is a script that just deploys a token to the console. So if I run this script and then I run this in interactive mode, it's going to drop me on the console when I'm done with it. So I'll run the token script, it's going to deploy a token for me. This is the most recent token deployed here.
00:20:38.090 - 00:21:44.090, Speaker B: And now I can use this console to do any amount of interaction with this I'd like. So it comes built in with in addition to all the functions, it has a few different kind of properties built into Brownie to access these contracts. So, for example, I could transfer let's send account one half my balance and this is going to default to accounts zero unless I pass a specific object. But now I have full transaction which I could use to query a bit more information that's been added to the history object here. So I could look at history minus one and check the gas used on it, for example. Or I could get more information about the transaction which is going to give me the hash the from two addresses and all the events contained within it. And there's also the capability of running a trace on it, which is quite nice.
00:21:44.090 - 00:22:41.674, Speaker B: So this was a very simple transfer. You can see it called transfer and then it called the internal transfer function and it gives some of the gas usage. The transfer function just used 315 gas and then the internal function used the bulk of it plus 21,644 for gas. So where this is useful is of course not when the tests go well, but when the tests fail. So let's change one of these tests to fail and see what happens. So let me look at test, let's do a test transfer and let's go down to let me do transfer from actually and I'm going to change actually, instead of the test, let me change the contract itself. And we're going to change this.
00:22:41.674 - 00:23:17.720, Speaker B: Say we made a bug in this and instead of transferring money, we transferred 1000 times the money. We're going to run our tests again. But this time we're going to run them in what's called interactive mode. And when you run in interactive mode, it's going to give you if the test fails, it's going to drop you onto the console that we just saw, but it's going to drop you on the console at the place where the test failed. So in this case, this was a revert because of an insufficient balance. And when you're here, you have access to anything within this test. So if we look at the tests specifically, we are on test transfer.
00:23:17.720 - 00:24:03.826, Speaker B: The first test here and it failed. So we have, for example, token and accounts and amount are all available to us. We can see what the amount was, we can see what the token is, we can try the transfer ourselves if we want. Or you can look at the most recent transaction that was attempted kept in that history, log the final element and you could run a full trace back which gives you a Pythonic style error message telling you exactly where in the contract it was. So you can say, okay, this was at line 105 on token transfer. Sure enough, the line that I was fussing with right here, it's saying that this is throwing an insufficient balance. So of course this is a pretty easy test to figure out what went wrong here.
00:24:03.826 - 00:25:18.890, Speaker B: But when you're dealing with many, much more complicated testing, the capability of being able to bounce into the specific line that you failed on, sort of like a breakpoint and work with it is fantastic. So this is some background on Brownie, which is a fantastic tool, but for people who are new to this, I would actually recommend well, one last thing to point out is there are some more advanced features built into Brownie such as the capability of seeing a full coverage audit. So this is actually just going through the code showing the opcodes on the side, but also showing the graphical view of how well my code has been tested so I can guarantee I get to 100% test coverage. There's also like a gas profiler built in so you can pass the gas flag and see what the gas usage of all these functions were. So Brownie is great and it's an incredibly robust tool. But that being said, if you're new, I would actually recommend that you instead of starting with Brownie, you go with the next evolution up, which is Ape framework. And here we see the gas profile come out here and this is just giving the average low and high amounts of gas used for all the function calls, which is useful for seeing which functions are using gas.
00:25:18.890 - 00:26:10.230, Speaker B: Anyway, Ape frameworks is you can think of it as a successor to Brownie. So Brownie is great, but it's not really building out in the way that Ape Frameworks is. Apeworks is a clone of Brownie so you can think of it as Foundry is to DAP tools as Apewworks is to Brownie, so Apeworks is rewriting Brownie. All the functionality they just showed off also exists in Apewworks but they have a much bigger plans for going forward and they also have a bunch of great educational tutorials that you can walk through. So their APWorks Academy has the capability of cloning ERC 20 token and deploying it and ERC 721 NFT they have more that's coming and a great community. So highly recommend you check out Apeworks. I'm not going to go into too much depth on Apeworks because it's largely very similar to what we just showed off the Brownie.
00:26:10.230 - 00:27:06.142, Speaker B: But I will show off the kind of equivalent of how you would create an ERC 20 token and the very friendly way in which they do it. So uses this templating system within Ape frameworks and this is going to create ERC 20 token. It's going to ask for a few different initializations. So I could say ETH token and call it ETH token. ETH token 18 decimals. We'll add a pre mint, pre mint amount it's ownable, we'll have a Minter role, it's mintable burnable permittable and just like that it's created this ETH token repository for me right here with everything already filled out for me. So even friendlier than Brownie as you can see in terms of the user interface and actually building this out.
00:27:06.142 - 00:27:55.672, Speaker B: And it's much more recent viper version, which is nice. 3.3. I'm running a bit shorter on time, so I wanted to go through the kind of more newest tool which is titanaboa. titanaboa is this natural execution layer for Viper language code. And Titanoboa is, in my opinion, sort of mind blowing. It allows you to execute raw Viper code directly within Python. So this is incredibly useful for things like being able to create jupyter notebooks and within it actually interact directly with live smart contracts and pull the stats natively into all the advanced mathematical libraries that you can utilize using Python.
00:27:55.672 - 00:28:46.830, Speaker B: Such as you could use sklearn on this, you could use Pandas data frames. So some of the things that you can do using Titaniboa, you can do storage enumeration. And what we can see by the example which I'd walked through if we had more time, is you're actually able to read through all the storage variables of a contract, including mappings. So if you want to see mappings are not generally readable as key very value pairs. So if you have a mapping, you can't easily enumerate it within the smart contract, but you can, using Titaniboa just rip through all the storage enumerations. So you can trace and enumerate the storage with this syntax here. In this case, we're loading a contract Minting three times and then checking the three balances and looping through them.
00:28:46.830 - 00:29:22.840, Speaker B: Very recently they added the capability of doing main net forking. So just beware as you're doing. This is caching the RPC results using level DB. So subsequent state fetches the state are very very fast. And this is very useful for running simulations against the actual main net state. So this is where you can take live code and run it through your jupyter notebook and come up with very nice beautiful graphs. So here we see a test function being ran through IPython, deploying it and this on this connected to a local main net fork, is able to pull live data from the blockchain.
00:29:22.840 - 00:30:08.740, Speaker B: Gas profiling is another really useful one. I showed how you can get the function level gas usage using Brownie or Ape. But if you want to get line by line gas usage, you can enable gas profiling and walk through on every single line the gas usage of every single statement. So this has been, I feel really bad about this because I basically had to write something very similar, mostly by trial and error, when I was trying to build out a recent contract. And then after I did that and launched and shipped my contract, this got released. And this would have saved me so many hours of being able to kind of figure out the specific lines where there's issues. Also can do opcode patching.
00:30:08.740 - 00:30:54.052, Speaker B: So this is the capability of patching arbitrary Opcode implementations directly into the virtual machine in case you need to run some finely grained tests. So this here is an example of using S Store, which is touch tracing all the touched storage slots by address. Anyone who is familiar with Foundry will be familiar with user defined cheats. And this is now available using Titaniboa as user definable pre compiles. In this case you can see it registering it and executing this raw call as it is touching this right here. So this is a simple example, printing the sender to standard out. But anything that you can do in Python, you can now do here.
00:30:54.052 - 00:31:27.890, Speaker B: So you could do tracing, you could do Http requests. This kind of opens up the full power of Python to this here. You can execute arbitrary code, so you don't even need to spin up a contract. Like in the previous examples, we were writing a contract, deploying it and testing it. But there's also a boa eval function where you can evaluate raw lines of Viper code and get the result directly to standard out for debugging revert reasons. So in this case, there's two types of revert reasons. You can get the revert reasons here.
00:31:27.890 - 00:32:14.700, Speaker B: This is a general mechanism to filter on the physical revert strings. So this could be Brownie Natspec oxygen style revert strings or even compiler generated checks. And here's an example of the compiler revert reasons. So if the compiler is throwing an error, you can actually load this in and see what the error that's being called. So titanaboa is becoming a very robust and powerful tool for all of your smart contract needs. The team behind Viper is big ambitions, big tech sucks on Twitter, is one of the founding team members of Viper. He has very ambitious plans to get Viper to the best user experience and developer experience for smart contract languages, safest and most performant language for EVM programming, and highest use smart contract language for new projects within the next six months to one year.
00:32:14.700 - 00:32:46.904, Speaker B: So if you're interested, please do join us. Feel free to reach out to me. I write a daily blog on DeFi stuff, except weekends on Curve substac.com. You used to be able to find me on Twitter, but because I've been supporting the Free Alex movement I'm no longer findable on Twitter, so find me on Lens instead. Or if you're old school, you can find me on LinkedIn. And finally, if you'd like to join the Viper community, the best place is the discord, where the team hangs out all the time and returns in almost real time feature requests. So it's a fantastic place to be, and they're incredibly proactive and get some help.
00:32:46.904 - 00:32:50.490, Speaker B: So if you follow this QR code, we will see you in the discord. Thank you very much.
00:32:53.180 - 00:33:24.710, Speaker A: Garrett, that was absolutely amazing. Thank you so much for going into so many deep dives and telling us about all these tools. Even I didn't know about the last one, so that was great and learning for me, too. We had two questions. One of them was actually answered by another member, but I'll just ask it because we're also recording it, which is, when you were doing the testing, was there a way to verify the contract once deployed with the same way in Brownie, or is that only for testing in that part? Looks like the answer is you can verify it, but if you want to maybe add any other colors to that, please do.
00:33:25.640 - 00:33:52.030, Speaker B: No, I think they nailed it right on the head. It's 100%. You can do that using Brownie. Also like brownie works. I should have mentioned that. It works just as well for if you want to work in a developer local chain, if you want to work on a main net fork, or if you want to go directly on main net. So I actually do most of my smart contract interaction directly on Brownie on a main net, just because it's easier for me to query and see what's going on under the hood there.
00:33:52.030 - 00:33:53.292, Speaker B: Awesome.
00:33:53.426 - 00:33:59.630, Speaker A: And the other one was people wanted to know what is your terminal setup and what a terminal app do you use?
00:34:00.880 - 00:34:19.540, Speaker B: So, as you see, I'm fairly old school, do everything. I don't ever use any IDE or anything. I just do everything directly within Vim, and then I am basically using Brownie and Python for everything. So, yeah, I'm boring.
00:34:19.960 - 00:34:24.660, Speaker A: Okay, well, thank you so much, and I really appreciate taking the time today.
00:34:24.810 - 00:34:25.730, Speaker B: My pleasure. Thank you.
