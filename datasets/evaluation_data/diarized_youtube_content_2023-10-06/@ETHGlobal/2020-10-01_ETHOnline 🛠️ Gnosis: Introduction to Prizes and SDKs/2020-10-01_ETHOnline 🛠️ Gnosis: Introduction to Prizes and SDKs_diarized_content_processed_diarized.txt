00:00:00.090 - 00:00:25.720, Speaker A: Introduction to Genesis, prices and SDKs. Joining us today is Lucas and Herman, who will be taking us through the session. One quick reminder to everybody to stake their spot for ETH Online. If you're having any issues, please don't hesitate to reach out to myself or anybody else on the ETH Global team. And with that, I'm going to pass it over to Lucas and Herman, who will introduce themselves and get the session started.
00:00:27.850 - 00:00:56.960, Speaker B: Thanks for the introduction, Emily. Welcome, everyone. It's a pleasure to be part of EV Online, especially with Defcon that's happening this year. It's great seeing the entire Ethereum community coming together, and I'm looking forward to seeing some knowledge sharing and you guys building some cool stuff. Going to share my screen now. Just let me know in case you're not seeing my slides right now. Looks good.
00:00:56.960 - 00:01:43.406, Speaker B: Yeah. So at the beginning, you will have to listen to the product guy giving you a little intro to what Nosys does and how you can engage with us during the hackathon. And then I will hand it over to Herman, who's going to do the more interesting stuff and giving you a technical introduction to the Gnosis Safe SDKs. All right, quick intro. For those that don't know Gnosis yet, we're building essential infrastructure for decentralized applications, and we're actually having a free technology pillar inside Gnosis. That's the Gnosis Protocol, which is our decentralized exchange offering. Then we have the Gnosisafe, which is a smart contract account.
00:01:43.406 - 00:02:35.594, Speaker B: And finally the Conditional Tokens Framework, which is a token framework where you can use built in logic into tokens. I will explain in more detail later. All right. At this hackathon, we're actually having free general prices 1st, second, and third price. The requirements to qualify for these prices is that you can actually build whatever you want, but you have to make your hack leverage smart contract account capabilities. So we're actually offering, as part of our Safe technology stack, two SDKs that allow you to leverage smart contract account capabilities. That's the safe app SDK and contract proxy kit.
00:02:35.594 - 00:03:42.078, Speaker B: And I will go into more details about how they differ later. So why should you even do that? Nowadays, developers still mainly have MetaMask in mind when developing decentralized applications. Yet for the user. This doesn't provide the best user experience because first of all MetaMask being externally owned account basically if you have more complex interactions with the ethereum blockchain you will have to basically have the users sign multiple transactions which is super inconvenient and more regular users don't understand why one interaction is being split up in different transactions. And then you have all these problems around transaction fees. What's the right transaction fee to set? And then you have stuck transactions because the fee is set too low, and so on. And finally, externally owned accounts, basically being an account that's controlled by a single private key, involves all these issues around key management.
00:03:42.078 - 00:05:21.410, Speaker B: And when users lose their private keys, they don't have access to their digital assets and cannot interact with your DAP anymore. So we really believe at Gnosis that smart contracts are the future and that any account in the future will be a smart contract account which is controlled by multiple private keys or by externally owned accounts under the hood, but the actual account will be the smart contract account. And this enables developers to leverage all these capabilities of these smart contract accounts. For example, multiple contract interactions can be batched together into one single transaction and you can leverage transaction relaying broomata transactions to abstract away these issues surrounding transaction fees, or you can have your users pay transaction fees with ERC 20 tokens. And finally, smart contract accounts enable you to have more sophisticated access control schemes in your account. So it's not just this one private key controlling your account, but you can actually have multifactor authentication, multi signature accounts, but also built in account recovery schemes and other means of controlling this account. So that's really the reasons why we think that smart contract accounts will enable much better user experiences for users and enable developers to build better decentralized applications.
00:05:21.410 - 00:07:07.160, Speaker B: So, before I go into these different SDKs that we're offering, we're actually also having two additional prizes during Eve Online, where we want you to also build on the other technologies that Gnosis is offering and that's the Gnosis Protocol, which is an end to end decentralized exchange. So different from maybe some other decentralized exchange that are being launched recently, it's really end to end decentralized, meaning there's no admin key or the parameters cannot be modified, but rather and also there's no automated market maker behind it, so there's no issues of impermanent loss. All of this works with a batched auction mechanism, meaning at any time through these batch auctions, there's a uniform clearance price for users. And this is especially interesting for IDOs initial decks offerings where you can really make a fair price finding mechanism out of this decentralized exchange. The other part is the conditional tokens, which enable you to basically facilitate tokenized logic. You can imagine it kind of like if this then that built into these tokens, where the value of a token depends on the outcome of a specific event. And that's interesting for futurki applications, but also you can use it, for example, for conditional token vesting applications or for options contracts, for example.
00:07:07.160 - 00:08:29.790, Speaker B: So for these two technology prizes, we're actually having two separate workshops that are happening tomorrow right before the kickoff of Efonline. So make sure if you're interested in the technologies, or even better if you want to build something using these technologies that you're participating in these workshops. And also coming back to the prices, the prices are in a way composable. So if you're building something with these safe SDKs that's also building on top of Gnosis Protocol, you can obviously qualify for both the technology price as well as the general price. Or if you're even more brave, you can try to combine Conditional Tokens Framework and the nosis Protocol and go for all of the prices altogether. So for more information on our prices, but also just additional resources and support, you can join our channel on the Eve Online Discord or even better, join our own Discord, the Gnosis Discord, because all our developers are obviously more active there also during the hackathon. But we're trying to be as active as possible also in the Eve Online Discord.
00:08:29.790 - 00:09:14.046, Speaker B: Okay, let's get back to the Safe SDKs. As mentioned, we have the Safe app SDK and the Contract Proxy kit, which both enable developers to use these benefits of smart contract accounts and to explain what they can build with the Safe Apps SDK. I'm actually doing a little demo right now. So we'll now go to the Safe Multisig, which is an interface that we're building on top of this smart contract account standard. And I'm just going to create a new nosis Safe account. So let's give it a name. So now this account is controlled by my MetaMask account.
00:09:14.046 - 00:10:06.320, Speaker B: I could add additional signer keys, additional owners that are controlling this account, even set sort of like a quorum or threshold where only part of these signer keys are needed to make transactions with this account. I'm just leaving it with the MetaMask for now. So that's it, I need to do one transaction to basically deploy the proxy for this account. And that might take a minute. Fortunately, because we're on Rinkabee, this should go a little bit faster. We're done. So now we've created a Gnosis Safe account and obviously there's no funds on there yet, so let's just quickly send some funds so I can continue with the demo.
00:10:06.320 - 00:11:19.000, Speaker B: So now in this interface, we have this option or this tab here that's called Apps, where there's different decentralized applications that sort of work as kind of like a plugin. So we have an application from one Inch, but also a means to manage your balancer pools here, or also an app from Savelier which enables you to stream money. And I'm just going to demo this with Savelier. So the funds arrived in my account. This means that I can now initiate a transaction, sending it to my own MetaMask account, and then I can basically define here. So, Savior works basically the duration of the stream, whereas this ether is going to be streamed towards my MetaMask account. So let's say starting tomorrow until the end of the month.
00:11:19.000 - 00:12:39.520, Speaker B: Now, when I create a stream, basically the application then packages this input together to a batch transaction. So you can see this interaction actually involves multiple transactions, whereas if we would build a regular DAP, I would have to ask the user to confirm multiple times, but using the smart contract capabilities, I only need to do this once. Um, so now when that's done, basically as soon as the transaction went through. You can then see it in your transaction list, where you can see that this transaction has done multiple interactions here, sent some Ether to the wrapped Efer contract, made an approve, and then interacted with the savior contract. And that's all bundled together into one Ethereum transaction. So basically, with the Safe Apps SDK, you can build these apps and enable the communication between your app and the Safe Multisig interface. And Herman will go into more detail how this works on a technical level.
00:12:39.520 - 00:14:33.540, Speaker B: All right, the second option that you have to leverage smart contract accounts is the Contract Proxy kit, which you can use to build standalone decentralized applications that don't live purely within this Safe app framework, and where you don't assume that every user already has a Safe Smart contract. So actually, when you're using this proxy kit, whenever a user is coming to your decentralized application and is connecting, for example EOA, like MetaMask, once the user is doing an interaction with the DAP, then we're creating through the proxy kit a Safe Smart contract account under the hood. And then you can leverage this smart contract proxy as a means to benefit from these capabilities. So in what cases should you go for the Safe app SDK and when should you build a DAP using the CPK? So the Safe App SDK is really useful if you want to build a DAP that's optimized for the Safe Multisig. Meaning the Safe Multisig is used by more than 5000 people storing over I think it's 1 billion US dollar worth of digital assets, and mainly used by projects and groups of people that are managing digital assets collectively. So if that's your target group, then that's definitely a good way to expose your DAP directly to users because it's completely built into the Safemotisig. And also if you just want to build a simple DAP to demonstrate something, that's also a great way to do that.
00:14:33.540 - 00:15:18.686, Speaker B: The CPK is useful if you really want to build a standalone DAP. And that doesn't assume that the users already have a Safe account. So if you want to address a more broad market, maybe just people that don't yet have a smart contract account. And also the CPK enables you to leverage the relaying functionality. And Herman will go into that probably in more detail, but you can use the CPK to, for example, pay transaction fees for users through transactions. Yeah, that's basically it. Oh, one important thing that I've missed.
00:15:18.686 - 00:15:58.990, Speaker B: If you're building a decentralized application using the Contract Proxy kit, it's actually also compatible as a Safe App SDK. So coming back to the interface, users could actually go ahead and import an app using a new URL. And if this app uses the Contract Proxy kit, it would automatically be compatible also to be used right from the interface. So that's for the more high level stuff. I would now hand the mic over to Haman, who's going to do some more technical introduction into those two SDKs. So I'm going to stop sharing.
00:16:01.810 - 00:16:41.114, Speaker C: Hello everyone. I'm Herman. I will share my screen. Okay, so here we will see how to build how to start building an app that uses the CPK or the Safe Apps SDK to run inside the Safe Multi SIG web interface. So we're going to start with the Safe apps. SDK. And this will be an application that will run inside an Iframe that is in the Safe Multi C web interface.
00:16:41.114 - 00:17:46.100, Speaker C: So there will be some communication that needs to be there. And here we will have the documentation, the repo on GitHub. I will show you all the links later in the slides. So here, first of all, if we want to use it in a project, we would need to install it and build it the app, right jar and PN, we would do it from this repo. And then this communication will work as long as the URL of the main web. So that the Save multisig web interface is one of these. It can be Mainet Rinkav or if you are running both apps on localhost that's okay.
00:17:46.100 - 00:19:18.000, Speaker C: So when you are building your Safe app, you would need first to import the Safe Apps SDK and call the Init SDK method. This will give you an object that you will use in the communication between your save app in the Iframe and the web page, the save multisig. The events that you would have to listen in the save app are three. So to listen them, the object we just created here, the Apps SDK, we would call the method add listeners and then pass three parameters. An object with three parameters on safe info, on transaction confirmation, and on transaction rejection. Unsafe info will be used when the Safe apps the web page wants to send some information about the Safe to the Safe app, like the address, the balance, et cetera. And the other two on transaction confirmation and on transaction rejection will be received by the Safe app.
00:19:18.000 - 00:20:31.910, Speaker C: When the Safe app triggers a transaction, sends a message to the web app, then you can submit this transaction with your MetaMask or whatever in the web. And then the web will return the result of this transaction, depending on if the user confirms it or rejects it, these two listeners will be triggered inside the iframe. Before that, we need to start the transaction in the Safe app. And the way to do that is calling the method send transaction from the Apps SDK that we instantiate at the beginning here. In this method, it requires an array of transactions as a parameter. And it's an array because the Safe contracts allow batch transactions. So even if you just want to send one transaction, you should do it inside an array.
00:20:31.910 - 00:21:52.560, Speaker C: For each transaction we need three parameters. Two, value and data. Two is the address you want to call value. If you are sending Ether and data if you are sending some data to interact with a contract after this call there is a message that is returned with the request ID. We use the request ID to track every transaction that is sent from the Safe app and also this message also returns the Safe transaction hash. But that is not the same as the transaction hash of Ethereum. So if what you want is to get all the information of the transaction, the way to do that is to call the SDK, the method get by Safe transaction hash and pass here the Safe transaction hash and then this transaction will have all the information like a normal Ethereum transaction.
00:21:52.560 - 00:23:36.950, Speaker C: Some things important when you want to set up the environment in your Safe app there is a manifest that is mandatory with some properties like the name of the app, the description, icon, path and then some information regarding the name of the project and URL. This is needed because in the Save multisig web interface there is this menu with all the apps listed. So if you include yours manually, if it's already listed there, well there's a name, a description and the icon. And also it is required to enable cross site requests because the app is running inside an iframe in the web page. So this is needed and also Https is also needed if you are using react scripts. For example, the easiest way to do it is here in the start script. Just export the Https or set it to True and that will make it once you have your Safe app, the way to load it would be to go to the app section in the web and then here paste the URL of the Safe app agree and save it.
00:23:36.950 - 00:25:42.792, Speaker C: As I said in the beginning, the Safe Multi C web interface could be one of these URLs running Mainet Rinkb or Localhost. And the Safe app can also be deployed somewhere like Netlify cert IPFS or can also be running in Local host. Okay, so to facilitate all of this, Richard Manager from the Safe team created a Safe app template which I really liked and I hope you too. And this is a Create react app template. So if new project is started before creating it using the command npnx create react app followed by the name of the Safe app we are creating, if we add the property template and we write our template which is adnosis PM CRA templatesafe app, then we can start with a basic project that has everything set up. So here once you have this project, it is only needed to install it, replace the VM file, removing the sample and to start the project and we can see this template in a minute live. And one thing very important is the use of the Safe react components.
00:25:42.792 - 00:26:49.090, Speaker C: So I'm going to use two apps, one for the Safe app SDK and another one for the CPK. Probably they are not using these Safe React components, but these are just example apps. If Safe app is created that wants to be integrated in the official web page for the Safe, then it should have the same look and feel. So this library should be used to get some components like inputs, buttons and everything with the same styles. Something also very nice that has this template is that it includes a hook that also Richard created. Notice that this hook is not in the Gnosis VM GitHub. So use it at your own risk, nothing risky, but just notice that it's not there.
00:26:49.090 - 00:27:49.580, Speaker C: And this hook will simplify everything even more because it provides a Safe provider that if you are using React well, you will import it. From here you can wrap all your application with this Safe provider and then inside of the app called the Use Safe hook, that returns the Safe object. And here in the Safe object you can ask for the Safe address, the balance, et cetera. It also allows you to send the transactions as we saw before. And let's see the template. So here is it. Yeah, this is what you saw.
00:27:49.580 - 00:28:47.260, Speaker C: This is the root of the app that is wrapped with the state provider. And inside of it we have a function to submit the transactions and then we have a button to trigger them. So sorry, I have it here. This is the sales multisig web interface. I previously imported this app here in the Manage Apps add custom app. And here adding the app is running on the local host. Not ready, like not running yet, it will be running now.
00:28:47.260 - 00:29:52.162, Speaker C: Okay, so now this Safe app that is supposed to run inside the, inside the iframe is running outside. So you'll see that it's waiting for a save and it's never ending. This is because it is expecting to receive the listener with the Safe information that we saw before. But here we have it inside the iframe with the right communication between the Safe app and the web page. And the Safe app that we have selected here in the web interface, our default one is the one that is sent to the Safe app. And here we can submit a transaction. And as Lucas showed you before, there is this model coming from the web where you can submit it.
00:29:52.162 - 00:31:20.260, Speaker C: So the Safe app sent the transaction information to the web. Now the web asks for a confirmation to our owner MetaMask. I will put a high gas price here to be fast and then in a couple of seconds we will have our transaction confirmed. Hopefully well, we can see the model later the alert. Okay, so that's all for the safe apps. SDK now we will switch to the contract proxy kit. As you may know, the contract proxy kit, its purpose, instead of being just running inside the iframe in the Safe Web interface, the purpose is to offer all the functionalities that the Safe contract have to every app or to the app that is using it.
00:31:20.260 - 00:31:34.710, Speaker C: For example well this TypeScript library will create a Safe app on behalf of the user transparently and once created.
00:31:37.070 - 00:31:37.386, Speaker B: It.
00:31:37.408 - 00:33:21.562, Speaker C: Will allow to batch transactions to send metatransactions to manage all the owners this Safe has also users can reuse their existing Safes. We will see this later that if you already have a Safe you don't need to create a new one when you are using the Contract Proxy Kit. It also offers the integration with the Safe apps SDK. And last thing is that because it is a Safe what we are creating, you can always take this Safe address and load it into the Safe Multi C web interface. And there you can see all your transactions, configuration owners, the contract version and everything of your CPK which is something that would be hidden if you just use it as a library. So this is the architecture or the structure of the CPK project for using it, you don't need this but it will help if I explain a couple of things here. So these boxes are TypeScript classes, the main one is the CPK and this class offers some public methods as an API that the app that is using the CPK will call here.
00:33:21.562 - 00:34:52.214, Speaker C: The CPK has a safe apps SDK connector and this implements or integrates the safe apps SDK. So if the CPK detects that is running inside the iframe inside of one of these allowed URLs then it will know that it's running as a Safe app and will override some configuration that we will see later. And if the CPK app is running standalone outside of the web interface then this won't be needed. There are also two important classes, these are the Ethlib adapter and the Transaction Manager. The Transaction Manager is something that will allow to send transactions directly to the blockchain using the CPK Transaction Manager. Or there's also the option to use a relay, in this case the Safe relay, our relay transaction Manager. Right now if you check the CPK code you'll see that this is implemented, but right now it's not working with our backend because there are some checks that don't allow the CPK to use it.
00:34:52.214 - 00:36:06.940, Speaker C: But in the near future we will have this solved and hopefully add more relayers to make it a bit more agnostic. And finally, the Flib adapter offers some utility methods depending if the app is using the Web three provider or the Ethers JS provider. And these two classes will be used when the CPK is initialized and that's why it is important to mention them before. So we can go now to the Contract Proxy Kit repo on GitHub that I have here. Contract proxy Kit inside of the nosis GitHub. Account. And yeah, when you are creating a new or an existing app to integrate the Contract Proxy Kit, first we have to install it and import it.
00:36:06.940 - 00:37:08.560, Speaker C: The versions we accept for the providers are the Web Three One and Two. And for Ethers version Four and five when instantiating the CPK. There are two methods that can be confused a little bit in the beginning, but I will explain the difference. So there is this static method called create. And then we have the constructor. The recommended way to create the CPK is using the static method Create that will inside call the constructor. And when you use the Create it allows to initialize or to configure all the CPK while the constructor is not so flexible, let's say that way.
00:37:08.560 - 00:38:29.030, Speaker C: So here we can see an example of how to instantiate the SAPK with the Web Three provider and Ether JS provider. If we are using Web Three, we import both packages. We create an instance of Web Three and we have our object, the CPK we call the method Create. And then we have to pass these parameters that are used to configure the CPK. If you remember the diagram I showed you before, this iflive adapter is one of the important classes I mentioned and for this class you would have to instantiate it outside of the CPK. And this gives the CPK more flexibility in case somebody wants to create its own adapter or whatever. So if we are using the Web Three, we instantiate the Web Three adapter, passing the Web Three object and then this object passing it to the Create method.
00:38:29.030 - 00:39:44.830, Speaker C: Apart from the iflib adapter there are other parameters like the owner account. So the CPK will create a safe proxy contract and if we want a specific account to be the owner of this safe we must write this down explicitly to pass this as a parameter. So in this case, this account would be the owner of the sales we are creating with Ethers. It's something very similar. We have the Ethers adapter instead of the Web Three adapter and it requires two parameters, the Ethers and the signer coming from the Ethers library. And then just to call the create with this object, the last parameter we need to configure the CPK correctly. So we have the Ethlib adapter, the owner account and the last one is the network configuration.
00:39:44.830 - 00:41:19.510, Speaker C: So the CPK already have a list of networks where we have all the contracts that are used inside the CPK deployed like Mainnet, Rinkab and some others. But if somebody wants to use the CPK in a different network in the local host for running tests or whatever, it is needed to include the network ID and all these contracts that are used. The master copy address, the proxy factory, the multi send address and the fallback handler address with the addresses you want where these contracts are deployed. So the CPK we know that will create a safe account, right? So we have the safe account, the proxy and the owner. There are two methods in the main class, the CPK that offers the public API. And these methods are the Getowner account that will return the owner of the Safe and the address that will return the address of the Safe. If we are using a Safe as an owner, then the CPK detects that and he will not create a new Safe, he will just reuse the existing one.
00:41:19.510 - 00:42:31.100, Speaker C: So if we are using Safe as the owner, these two methods will return the same address that is the owner. Here we can see it very similar to the SDK, the Safe Apps SDK. We have the exact transactions with the same signature of the method. We have to pass an array of transactions. And here we have an additional property that is operation depending on the transaction you want to send, that can be a call or a delegate call. And here we can see some examples of some transactions that are executed when using the Web three or the Ethers. There are also some options to set the gas price when using a batch transaction or the gas limit.
00:42:31.100 - 00:43:53.508, Speaker C: Here you can see how to run the tests. And remember that using the CPK can or allows to run this app as a Safe app. And yeah, you have here more information here in the docs if you want to read more documentation in detail. You have the CPK markdown that lists all the methods inside the CPK class and you'll see what their parameters are and what they return. So I think now we can check the example app we prepared for this using the CPK, remembering that this app is not really using the Safe app components that should be used. And here this app doesn't have any purpose just to call these methods that are public and just list some information. For example, there is a method that is called is Safe app.
00:43:53.508 - 00:45:04.910, Speaker C: So here we have this app running inside the Iframe and it returns that, yes, it is a Safe app. If we have this same app here outside, deployed somewhere in search outside of the web, we'll see that the CPK detects that it's not receiving any information from the web page and then it knows that it's running standalone. Also you can get the CPK address with the balance the owner, which is the same here as the set we are using outside. This will be used when the relay service is ready. But here you could write the direction, the URL you want to set for the relay. And here from the other side we can send a transaction. For example, here you see that the model that Lucas showed before is the one coming from the web.
00:45:04.910 - 00:45:41.970, Speaker C: And this works exactly the same as the Safe Apps SDK. In fact, it is using it. We are on Rinkavi, we can confirm. Okay. And then there's also some new functionality in the new version that allows to configure the module. So the safe contracts. Are modular and you can add more functionality adding them.
00:45:41.970 - 00:46:33.150, Speaker C: Here you could, for example, this example module in the ring cabin network, the Daily Limit module. Here you could create a transaction to enable this module or disable or get the list of modules that are enabled for this Safe. And here, outside, we have the Safe with different data because it's not running inside the Safe. And here this will be the same. And I think that's it. Yes. So thank you very much for having us.
00:46:33.150 - 00:47:32.850, Speaker C: So, as a resume, we have two SDKs, the Safe apps SDK and the CPK. The Safefaps SDK is more focused on running inside the Safe multi SIG web interface. And the CPK, it has a more general objective or it is more flexible and can be used in every D app. And that's all. Thank you. Good luck to everyone that is participating in the hackathon this month. If you are interested in running an app, a project with any of our SDKs, just talk to us in the Discord Channel and we will be there.
00:47:32.850 - 00:47:35.010, Speaker C: So thank you.
00:47:37.060 - 00:48:01.370, Speaker A: Great, thanks guys. I think we had a question in the chat just from Alan, and yeah, it says it must have been while you were explaining it was during your section, Lucas, which was this only applies for DApps written with the latest version of the CPK 2.1.0. I'm not sure if you can answer that.
00:48:02.220 - 00:48:28.560, Speaker D: Yeah, I actually wanted to mention that the apps that are built with CPK would be a Safe app if they use the latest version. So it doesn't apply to every dev that's already using CPK already. If you just happen to know about that, at least not yet, until they upgrade.
00:48:31.940 - 00:48:42.420, Speaker C: Yeah, so there was a release recently. If you are already using the CPK with an old version, please update the version to get this functionality.
00:48:45.720 - 00:49:06.510, Speaker A: Okay, great. If there's no questions left, thank you so much, Lucas and Herman, for the session today. And you can reach them in the Discord Sponsor channel. And if there's links you'd like to share in that channel as well, that would be great for the hackers, but cool. Thanks guys.
00:49:08.000 - 00:49:09.276, Speaker B: Thanks for having us.
00:49:09.378 - 00:49:12.280, Speaker C: Thank you very much. Bye.
