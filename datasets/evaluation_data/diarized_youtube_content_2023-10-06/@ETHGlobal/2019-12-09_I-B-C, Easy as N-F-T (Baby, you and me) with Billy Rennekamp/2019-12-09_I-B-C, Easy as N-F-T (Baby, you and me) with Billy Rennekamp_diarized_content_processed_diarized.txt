00:00:00.970 - 00:00:25.346, Speaker A: Hi there. That's nice and loud. Wake up. How many people are actually just here working for ChainSafe and all? Right, great. Well, then I will be speaking directly to this camera instead of everyone in the room. But thanks for being here to be the bodies in the foreground. So, hi, my name is Billy.
00:00:25.346 - 00:00:57.520, Speaker A: I'm going to be talking about IBC NFTs and the Cosmos SDK. If you like acronyms, this is the place to be. I'm going to begin with a little bit of the evolution of blockchain, which I hope you're all familiar with. If you ever had the unpleasure of trying to build something in early days, basically your only option was forking bitcoin. You could basically tweak some of the parameters, but not really do a lot else because the code base is so difficult to use. And this sort of birthed the first wave of shitcoins. Litecoin kind of being a star player there.
00:00:57.520 - 00:01:37.610, Speaker A: Next we had the birth of the amazing Ethereum virtual machine. You were able to actually deploy your application logic to a Turing complete computation space instead of having to deploy your own blockchain yourself. Ethereum took core of the security. Thanks to the lovely ERC 20, we had the second wave of shitcoins. So Cosmos sort of proposes a third architecture, which in a way goes back to the first one. Let us take care of the really difficult parts of building a blockchain consensus, algorithms, networking, so that you can focus on the parts you actually care about, which is the application level. We hope to foster the third great wave of chipcoins.
00:01:37.610 - 00:02:15.702, Speaker A: How do we do this? One of the ways we do this is by implementing tendermint, which is kind of the golden standard of proof of stake. It's Byzantine, fault tolerant, it's well tested, battle tested. It's securing over $5 billion worth of coins at this point, but we kind of want you to not have to worry about it. The second thing is IBC. So one of the great benefits working with Ethereum is that you have this shared state. You can have this composability, these sort of building blocks of DeFi and all this sorts of stuff. Your code is running right here, but it can reach over and access and do something with this other code, which maybe does something else.
00:02:15.702 - 00:02:48.580, Speaker A: This is really lovely. And if you're building application specific blockchains, you're sort of locked into your own zone. You can do exactly what you want to, but within your own space. So how do you get the benefit of all of this composability? You have IBC. IBC is essentially a blockchain version of TCP IP, in which you are sending transactions from one blockchain to another blockchain with proof that it really came from that blockchain. And the recipient blockchain can either ignore it or it can say, oh, yeah, I was maybe expecting a call from this other one. I'm going to let it do something like transfer tokens or trigger some function inside of it.
00:02:48.580 - 00:03:28.014, Speaker A: Why would you want an application specific blockchain? Well, I mentioned briefly, but one of the reasons is specialization. So instead of trying to cram every single functionality into a tool which will no longer fit into your pocket, you might just have a toenail clipper meant for horses. It does one thing and it does one thing very well. You're also self sovereign. So you don't have a bunch of neighbors who are all complying about what your blockchain is doing and they wanted to do something else. You can think of, for example, what happened with the Dow when you have a bunch of users like oh, my blockchain didn't do what I wanted it to do, do what I mean, not what I say. And you have a bunch of other users who are like no, code is law.
00:03:28.014 - 00:04:11.814, Speaker A: That's the whole point of this thing. They couldn't come to an agreement and so there was a fork. And if your blockchain is only doing very one specific thing, it's much more likely that your user base, your entire network security, is going to agree on exactly what it should be doing and how it should be doing. So you have the ability to kind of control those upgrades and make those upgrades more attuned to exactly for what it's being used for instead of trying to appease a massive number of people at the same time. So if this all works out, we hope to see something like a internet of blockchains where you have Ethereum over here doing sort of composability shared state, maybe DeFi all sorts of great things that Ethereum is great at. You have Bitcoin doing its orange coin thing. You have binance chain, you have the Aragon chain which is recently announced.
00:04:11.814 - 00:04:53.930, Speaker A: You could maybe even have the crypto keys chain or polkadot or Tezos all using IBC to be able to send transactions between each other and talk to each other. This sort of opens up a lot more specific use cases of blockchains. And I think it really mimics the way the internet works. We don't all use one big computer. We use a bunch of different computers who have their own choices about operating systems, their own choices about code, their own choices about resources, and they use TCP to talk to each other underneath specific conditions. So the way we hope to make this really easy is by building a developer kit called the Cosmos SDK mentioned earlier. It sort of takes care of the hard part, the networking and consensus so that you can focus on the app.
00:04:53.930 - 00:05:32.098, Speaker A: It's modular modules can kind of be thought of like contracts inside of the Ethereum way of thinking. Each module would have kind of tightly coupled logic and storage modules might interact with each other the same way contracts might interact with each other and they can be reused across chains. So similar to the OpenZeppelin libraries, you'd be able to instantiate modules on your chain that somebody else uses to avoid having to do everything from scratch. Each module has messages. So instead of having function calls like in Solidity, you can think of them as messages which change state. There's also queriers which read state, but just terminology wise. Messages are included in transactions.
00:05:32.098 - 00:06:09.486, Speaker A: They modify state and they kind of get routed to different modules and they get routed via these handlers. So when a module receives a message, it gets handled. The handler is where you have some sort of like logic. If you're familiar with react and View, you have these reducers and actions and things like this. This is where all the sort of logic takes place in the action part. And then you have the Keeper where the state is actually managed and that's the sort of reducer or the mutation like. In reactor view, these also contain getters and setters so that you're going to be able to read information out of it the same way you do with a queryer.
00:06:09.486 - 00:06:43.302, Speaker A: And shared state can take place across modules. So if I have an NFT module, but I also have a DeFi module, I can read certain aspects of the NFTs and modify them, et cetera. The general flow is messages, handlers, keepers. This is sort of if you're going to be dealing with the SDK, great to know. Here's some examples of some message types regarding NFTs. So instead of having transfer function, you have a transfer message type. Send a recipient denomination ID, edit, Mint burn, they get handled.
00:06:43.302 - 00:07:16.482, Speaker A: So it's basically just a big switch statement. It points it to the function that needs to actually handle it. Here's that handler up close the Mint and you can see that it modifies this K Keeper object and that's where the state actually gets modified. Here you can see that there's some sanity checks making sure that it hasn't been minted before. But this is a module that already exists. So if you wanted to use NFTs and use those basic functionalities, you could just import this, use it the same way as Openzeppen has NFTs enabled. And inside of the handler is where you might want to modify and add your own sort of logic.
00:07:16.482 - 00:07:45.158, Speaker A: The same way with Openzeppelins you would maybe rewrite the transfer function and say it can only be transferred so many blocks, or I don't know, whatever your app does. So we're kind of hoping again for this internet of blockchain. And the big meeting piece is IBC. So I just quickly wanted to point key components of IBC are these packets. So first there's a little dance of handshakes between two different chains. And once that's been established, there's a channel. And each channel has different ports.
00:07:45.158 - 00:08:21.146, Speaker A: And those ports basically route different types of messages. So here's a packet for transferring an NFT. And depending on whether or not you're sending that packet or receiving that packet, different things are going to happen. You can imagine if you're sending it, you're going to lock up that NFT and put it into an escrow account, basically an imaginary person account. They hold it there, and the only way that they're going to let go of it is if they receive a corresponding IBC message the other way around, which says, okay, this NFT went over into the larger ecosystem. Maybe it was on an NFT marketplace chain. Maybe it was used as collateral inside some other thing.
00:08:21.146 - 00:08:55.974, Speaker A: Eventually it's coming back to the origin chain and it gets unlocked from that escrow account. You can imagine on the other side of that, you're the recipient, say your binance chain, you receive this IBC message. It says some chain exists. You either know what it is already, or you just at least know it by the channel ID because you've had some handshake between this entity. It says there's an NFT on the other side. You believe it because there's a proof that at least that chain exists. So the user gets to decide, does this chain exist? Do I care about this chain? Is this just a spam chain, or is this chain actually the CryptoKitties chain? The standard and the protocol are agnostic to that.
00:08:55.974 - 00:09:21.950, Speaker A: They don't care if it's an imaginary chain or not. They know that there's a header to something that exists. So it comes up to the users to be like, ah, yes, this is the header for that chain. I can confirm that the NFT which was sent over is actually this CryptoKitty, which is now on the binance chain to be bought or sold, and then it can be moved around in the binance chain. But it's essentially an IOU for the CryptoKitty on the original chain can actually get transferred to another chain and another chain. Take as many hops as you want. You could backtrack all the way to the origin or just keep it over there.
00:09:21.950 - 00:10:06.640, Speaker A: So one of the sort of scenarios of that that I think are kind of exciting is the idea of wrapped bitcoin. You could imagine bitcoins getting sort of transferred via IBC into a larger ecosystem, and then as the bitcoin chain becomes unsecure after the 21 million, it maybe gets shut down. But all the sort of meme space of bitcoin can live on on a more secure blockchain that doesn't require the same incentives. So on the left, there's an SDK tutorial link. There's two different tutorials for onboarding the SDK if you want to build these sorts of things. On the right is an example app that uses the NFT. And if you're interested in using the new sample of the IBC implementation, come talk to me, because it's scary waters, and I want to make sure that you have all the assistance to make that happen.
00:10:06.640 - 00:10:16.400, Speaker A: Any questions? Who's excited about the third wave of shitcoins? Cool. Thanks again very much.
