00:00:00.170 - 00:00:20.560, Speaker A: So we have new cipher Ravital coming in and she will be talking about how fully homomorphic encryption can help handle front running on exchanges. So thank you so much for joining us, Ravital. Feel free to take over with your talk.
00:00:21.090 - 00:00:52.318, Speaker B: Great. 1 second. So we'll be looking at front running on exchanges. As we just heard, this was a joint work with Gada. So, to motivate the problem, what does front running look like in traditional markets? Well, a lot of financial applications involve buying and selling goods. The example you might already be familiar with is the stock market. In auctions, potential buyers submit their bids where a bid consists of at least two pieces of information.
00:00:52.318 - 00:01:46.234, Speaker B: You need to know the number of items someone's interested in purchasing and the price per item they're willing to pay. So what is front running? Front running consists of some malicious actor seeing a transaction's details and this malicious actor reacts before this transaction is executed. So how is front running dealt with in traditional markets? Well, there's dark pools which you can think of as private exchanges. There's sealed bids which simply hide the bid. And more generally, front running is actually illegal for most securities, so you can threaten people with legal action. What are the different types of front running? Well, to start, we're going to imagine there's Alice, which is some innocent user submitting some order, and there's Eve, the attacker. For the purpose of this talk, we're going to be primarily interested in a type of attack called insertion.
00:01:46.234 - 00:02:42.474, Speaker B: So, in an insertion attack, alice needs to still run the original function for this attack to be successful. So an example might be ticket scalping, where Alice is interested in buying some concert ticket. Eve sees this, goes and buys the ticket first and then sells it back to Alice for a profit. So in this case, we really need Alice to still want the concert ticket for the attack to be successful and for Eve to have gotten some money off of this. There are other types of front running attacks, such as displacement attacks and suppression attacks, but we won't be looking at those today. So what does front running look like on blockchain? Well, we're going to look at the image on the right hand side. So you can imagine some user submits some transaction and they are interested in buying, we'll just say, 1000 shares of something, they have some gas price associated with their transaction.
00:02:42.474 - 00:03:46.758, Speaker B: A front runner, who in this case is a full node in the network so they can see transactions before they're confirmed, notices this order, and then submits a new order to buy the same amount of shares but with a higher gas price, thereby bribing the miners to prioritize his transaction over the initial transaction. So, as you might guess, this is more of a problem in the account based bottle. So that's what we'll be focusing on. Why don't the traditional solutions work for front running and blockchain. Well, first of all, these aren't necessarily securities, so we don't necessarily have the same regulations as securities markets. And additionally, you might be interested in decentralized solutions where you don't want some trusted party maintaining the order book. What are the different categories of solutions to this problem then? If we're looking at blockchain, there are three major categories and these categories are taken from an Sok from Eskandari at all about front running.
00:03:46.758 - 00:04:36.238, Speaker B: The first you might look at is could you enforce order in some way for these transactions? But this introduces some other problems and doesn't necessarily solve front running. An alternative category of solution you could look at is redesigning the entire market itself. So maybe you could try economically disincentivizing front running. The final category of solution could be adding privacy. That way these malicious users can't even see the bid in the first place. So we can look at private blockchains where we might be interested in hiding the inputs and outputs, we might be interested in hiding the functions themselves, and we might be even interested in hiding the identity of the users involved. Additionally, we can also look at sealed bid auctions.
00:04:36.238 - 00:05:30.230, Speaker B: But it's important to note that if you're taking this approach, you need some way to prevent early aborts. And by that I mean some way to prevent people from submitting sealed bids that they have no intention of acting on. So since I'm a cryptographer, we're going to look at category number three, and that is can we design some cryptocurrency scheme that offers privacy, at the very least input output privacy? And maybe this scheme can also protect against front running attacks. There are some designs out there that offer privacy. The main four we're going to look at, just because all of them use zero knowledge proofs are Zether, Zexi, ZK and Hawk. All of them offer, at the very least, input output privacy, which is necessary for this problem. They have various issues.
00:05:30.230 - 00:06:02.842, Speaker B: None of them are perfect. So starting with Zether, it has very limited functionality in the sense that you cannot get privacy for any function. Privacy is limited to functions that can be expressed via addition. Zexi and ZK have similar issues. They use trusted setups for the zero knowledge proof. But arguably you're not committed to using zero knowledge proofs. With trusted setups, these can be replaced with transparent zero knowledge proofs.
00:06:02.842 - 00:06:33.190, Speaker B: However, these constructions, regardless, are very expensive for the user. We will look at that in a little bit more detail in a second. And finally, Hawk has a semi trusted manager. So not something we would probably want in this kind of solution. We are proposing a new design that offers privacy. Our design is called smart Fhe. It will have no trusted setups, no trusted parties involved.
00:06:33.190 - 00:07:18.882, Speaker B: It's going to differ in construction from the previous four in that it will use zero knowledge proofs. But instead of using partially homomorphic encryption or commitments. It is going to use fully homomorphic encryption. It will offer input, output, privacy as needed. And the primary issue with our construction is also that it's expensive, but it's expensive in a different way. The primary problem is space, particularly ciphertext growth with fully homomorphic encryption. So what is fully homomorphic encryption? For those people who don't know, you can think of it as a special type of public key encryption scheme that offers two additional properties, namely that it's additively homomorphic.
00:07:18.882 - 00:08:07.670, Speaker B: So that adding A and B in the plaintext space and then encrypting that is the same as having encrypted A and B first and adding that in the ciphertext space. A similar relation will hold for multiplication. Something special about fully homomorphic encryption is that it uses lattice based cryptography, which is different from all the other constructions. And another thing to note is that there are three different categories of fully homomorphic encryption depending on how they model computation. You have boolean, you have arithmetic and you have floating point and we will be looking at arithmetic. On the bottom is just a diagram kind of illustrating how Fhe works. You have some encrypted inputs, you can perform computation directly on these encrypted inputs and get encrypted outputs.
00:08:07.670 - 00:09:09.580, Speaker B: So why might we want to use Fhe? Let's take a step back and kind of look at the different approaches in private smart contracts and private computation for blockchain. So on the left is an illustration of how ZK and Zexi work more generally, the idea is that the user wants to run some function and they want privacy, input, output privacy. So what are they going to do? They are going to run the function on the plaintext inputs and they're going to get some plaintext outputs, but they obviously don't want to share this plaintext information with everyone else on the network. So what they're going to do is they're going to encrypt their inputs, encrypt their outputs, and they need to produce a zero knowledge proof showing that this offline computation that they did on their own was done correctly. What do the miners do in this kind of paradigm? Well, they just show up and they check the zero knowledge proof. The zero knowledge proof is good, everything's fine. So in this case, you can imagine the user is doing a lot of work.
00:09:09.580 - 00:10:00.322, Speaker B: It is lightweight in the sense that all of this work is being done sort of offline except for the zero knowledge proof part being produced. So it prioritizes space. Our approach is going to differ in that we want the miners to do a bit more work and we don't want the user to have to do quite so much work to do private computation. So instead the user is going to provide encrypted inputs. These inputs will be encrypted with respect to a fully homomorphic encryption scheme and they need to provide some zero knowledge proof showing that some conditions dependent on the application have been satisfied for their encrypted inputs. Then the Miner comes along, they're going to check that the zero knowledge proof is good. If so great, they can run a function directly on these encrypted inputs thanks to Fhe.
00:10:00.322 - 00:10:43.974, Speaker B: So kind of balancing the work between the users and the miners, and in some sense you can think of it as prioritizing the user's time. That all sounds great, but there are quite a few challenges with using fully homomorphic encryption, especially in the blockchain setting. So we're going to look at the three main challenges. The first challenge is that Fhe is very expensive. This is sort of true. The time complexity actually isn't that bad. And we have some numbers that we ran to show that there is a bigger challenge with ciphertext growth, in the sense that the ciphertext grow quite quickly and they're quite large for Fhe.
00:10:43.974 - 00:11:37.450, Speaker B: But there are other avenues that you can explore to potentially solve this problem. Challenge number two is that unlike the other constructions, fhe uses lattice based cryptography. We need a zero knowledge proof that works with lattice based relations and allows us to prove lattice based relations. But a lot of the lattice based zero knowledge proofs themselves are very expensive. So we need to ask what kind of efficient zero knowledge proof can we use? Thankfully, there's a pretty good construction short discrete log proofs construction that uses Patterson commitments and produces decent sized zero knowledge proofs for lattice based relations. And finally, three. So if you're familiar with fully homomorphic encryption, you probably already know that you can only perform computations on ciphertext encrypted under the same key.
00:11:37.450 - 00:12:30.918, Speaker B: How are we going to perform operations on inputs, especially encrypted inputs that belong to different users and therefore are encrypted under different keys? This is going to require some additional logic in the Smart contract, but it's certainly possible. There is a different variant of fully homomorphic encryption called multi key fully homomorphic encryption, and it allows for truly arbitrary computation on inputs that are encrypted with respect to different users and different keys. But we're not going to look at this for now. So what are the cryptographic tools we'll need for the Smart Fhe construction? We need a fully homomorphic encryption scheme. As mentioned earlier, we want one using arithmetic circuits. This kind of narrows us down to BGV and BFB for basic transactions. We don't need the full power of fully homomorphic encryption.
00:12:30.918 - 00:12:56.102, Speaker B: You only need additive homomorphisms. We'll need a zero knowledge proof that helps us prove lattice relations. We're going to use the short discrete logs proof construction. And then additionally, once we have the Patterson commitment, we can use Bulletproofs for other relations. And finally, we'll need a digital signature scheme or some way of signing transactions. But that's not a problem. Just a quick look at Fhe numbers.
00:12:56.102 - 00:13:25.182, Speaker B: We ran some benchmarks of the BFB scheme from Microsoft Seal. We ran it on pretty basic machine. We have the smallest and largest parameters that are supported by default for BFB. And you can see on the right that the numbers are pretty good. The only thing that's a bit expensive is key generation for the largest parameters. But everything else is like under a second. There is, like as we noted before, an issue with ciphertext size.
00:13:25.182 - 00:14:01.606, Speaker B: So just getting a sense of how do the ciphertext grow and how large are they after you perform a homomorphic multiplication operation for the smallest default parameter supported by seals BFE, it's about 13 KB. So decently large. These are some numbers to give you an idea of the short. Discrete logs proof construction. The performance is dependent on the elliptic curve you choose. We did curve two, five, 5119. The proof size is pretty small, less than one and a half kilobyte and using multiple threads.
00:14:01.606 - 00:14:41.330, Speaker B: Decently fast. So how is our construction actually going to work? Well, we're going to look on building on Ethereum's model. So the idea is that we're going to build on top of a smart contract enabled cryptocurrency like Ethereum that supports public transactions and public operations. So we're going to have an account based model. We're going to imagine that there is still signature scheme associated with the public account. You still have a nonce that's incremented with each transaction and you support smart contracts. Every operation is still associated with some cost and there are fees attached to each transaction that affect the priority.
00:14:41.330 - 00:15:23.310, Speaker B: What new is going to be added to this construction? Well, in addition to this public account, we're going to imagine we now also have a private account. And the private account has an Fhe key set associated with it. And this Fhe key set is going to be used to encrypt the balance. That way a user maintains an encrypted or secret balance similar to the public account. We also need a nonce that is unique to the private account and will be incremented with each transaction. And the idea is that we're going to use these private accounts to perform private transactions and private smart contracts. There are some issues when we're looking at accounts with privacy and concurrency.
00:15:23.310 - 00:15:58.446, Speaker B: So we're going to introduce some sort of locking mechanism to prevent conflicts. So what does a private transaction look like in smart Fhe? Well, we have the sender and receiver. Both of them have their own fully homomorphic encryption key pairs. They both have their own encrypted balances. Imagine the senders as B and the receivers as B prime for a private transaction. Our goal at the minimum is to hide the transfer amount and the balances of the users involved. So what would go into a private transaction? We need to know who the recipient is.
00:15:58.446 - 00:16:42.110, Speaker B: We're going to encrypt the amount we're interested in sending under the sender and receiver's public keys with respect to the same randomness. So we'll need to publish the randomness and then we need some proofs. We need a proof that these two CipherTechs actually encrypt the same transfer amount and they use the same randomness. We need a proof that we've sent a non zero transfer amount to somebody. We're not sending somebody a negative amount of currency, and we need a proof that the sender actually has enough money or currency in their account to perform this transaction. And as we stated earlier, you don't need the full power of fully homomorphic encryption to actually do this. You can simply use the additively homomorphic aspects to encrypt the senders and receivers balance because they're addition operations.
00:16:42.110 - 00:17:52.702, Speaker B: So again, more generally, how does smart Fhe work? The idea is that the user provides some inputs. If the inputs are public or unencrypted, a smart contract just proceeds in the same way as it normally would, or a transaction proceeds in the normal way, as it might in Ethereum. If the inputs are instead encrypted, and in this case encrypted with respect to fully homomorphic encryption, the user probably needs to provide some sort of zero knowledge proof proving some relations on these encrypted inputs that are application dependent. The miners can come along, they then check the zero knowledge proof and if everything's good, they can perform a computation directly on the user's encrypted inputs, thanks to Fhe. So back to our original problem. What is going to happen for sealed bid auctions? So the idea is that a seller will post some items for auction, say that the seller has up to 100 items to sell, a potential buyer comes along. And the idea is that the buyer can bid on a variable number of shares.
00:17:52.702 - 00:18:45.134, Speaker B: So anywhere between one to 100 shares, one to 100 items that the seller has, and they will submit a sealed bid and then reveal their bid at the end of the auction. This isn't anything new. Sealed bid auctions have been around for a while. So in this case, we'll need a zero knowledge proof showing that buyers have enough currency in their account for the total bid value. And possibly, depending on how you want to write this, you could also have conditions that show the number of items are within the posted range, the prices within some specific range. As mentioned earlier, we're going to need a locking mechanism to prevent parties from submitting bids and then just running away with no intention on actually acting on them. And on the right here, you can just kind of see a diagram showing what a bid consists of, as we stated earlier, number of shares, price per share, and different ways of bidding.
00:18:45.134 - 00:19:47.842, Speaker B: Whether you're bidding on a fixed number of shares, in which case you need fewer pieces of information, or if you're interested in biding on a variable number of shares and how that might work, depending on if you have fully homomorphic encryption or not. So back to the kind of comparison of approaches we were looking at previously. The zero knowledge proof based approach taken by ZK and Zexi, for example, and then the fully homomorphic encryption based approach that we're suggesting and proposing here. So in a zero knowledge proof based approach, a user will need to compute a couple of different values. They will need to have the commitment or encryption to the number of items, the price per item and then the total bit value, which is N times P. They are going to need to produce a more complex Urinolog. Proof showing that they've done this update on the encrypted or committed values correctly because there is no multiplicative relation between the ciphertext and the idea is that the user performs all computations.
00:19:47.842 - 00:20:36.582, Speaker B: So, as we stated earlier, the idea is we want to rely on zero knowledge proofs to ensure that updates were in fact done correctly. So on the bottom left, you can get a snapshot of all the pieces of information that a user might need to provide to participate in a sealed bit auction. On the right we have a fully homomorphic encryption based approach, as would be in Smart Fhe. And you can see on the right that there are fewer pieces of information that a user might need to provide and the zero knowledge proof is a bit simpler. So it's an easier transaction or easier computation for the users more generally. How do these solutions map out and what do they look like? It's difficult to say. One solution is superior to the other.
00:20:36.582 - 00:21:37.820, Speaker B: It really depends on what's most important to you. There are a lot of trade offs, the main ones being are you okay with additional trust assumptions like trusted setups, semi trusted managers? Does efficiency matter to you? And if so, what kind of efficiency? Do you prioritize time or do you prioritize space? And then finally, do you need full functionality? Are you okay with, for example, Zether, where you can only do private computations on certain kinds of functions? And finally, just some last considerations. Is front running best solved by cryptography? I will not offer an opinion on that. There are plenty of different solutions you could be okay with dark pools, maybe economic disincentives make better sense. More generally, should we combine cryptographic solutions with other non cryptographic solutions? And as we suggested before, if you choose to take a cryptographic approach, what's more important to you, time or space? And that's it.
00:21:42.880 - 00:22:04.790, Speaker A: Thank you so much, Arita. That was super interesting. Let me see anyone on the chat. Please post your questions if you have anything while I ask one of the questions, as we have a few minutes, maybe if you can clarify how much of this is a proposal versus implementation that has been worked on.
00:22:06.360 - 00:22:18.810, Speaker B: So it is a full paper that's currently being submitted to the conference. There is benchmark numbers to get a sense of the feasibility compared to the other approaches, but there isn't a full working implementation quite yet.
00:22:19.360 - 00:22:43.312, Speaker A: Awesome. Second question that we have is what does the zero knowledge ecosystem needs to do to bring this to reality. I know it's rod like putting on the spot here. If you or your team is doing this.
00:22:43.366 - 00:23:13.770, Speaker B: Maybe we're not working on this actively, but I think the prover times and the verification times just need to be improved significantly. I think the fact is with whatever papers are kind of currently being written, they all use trusted setups for a reason. And it's because that's what's offering practical efficiency. So until we have transparent zero knowledge proofs with good efficiency that don't have ridiculous hardware requirements, I think we have a problem.
00:23:15.420 - 00:23:20.970, Speaker A: Do you think that any of this can be done on ethereum? I mean, it kind of goes with your question.
00:23:21.860 - 00:23:27.170, Speaker B: I'm optimistic about it, but I can't say for sure yet.
00:23:29.060 - 00:23:39.250, Speaker A: Thank you. I mean, we have a lot of smart mind on this space and it's great to have you go through it and I hope it inspires other to break their head around this problem.
00:23:39.700 - 00:23:40.992, Speaker B: Great. Thank you.
00:23:41.126 - 00:23:42.270, Speaker A: Thank you for joining us today.
