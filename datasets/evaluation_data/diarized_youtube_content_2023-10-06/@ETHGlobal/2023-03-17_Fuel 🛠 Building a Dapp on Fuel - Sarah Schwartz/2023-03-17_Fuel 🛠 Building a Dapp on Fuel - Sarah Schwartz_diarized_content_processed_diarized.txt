00:00:07.050 - 00:00:07.262, Speaker A: Hey.
00:00:07.316 - 00:00:20.080, Speaker B: Hello and welcome everyone, to the Fuel Workshop building a DAP on Fuel. Joining us today is Sarah Schwartz, who will be talking us through this session. And with that, I'll pass it over to Sarah to introduce herself and get the session started.
00:00:20.690 - 00:00:47.876, Speaker A: Hi. Thanks. Yeah. So my name is Sarah Schwartz. I'm a developer relation engineer at Fuel Labs, and I'm going to be walking you guys through the basics for how to build a full stack Dab on Fuel or Fuel stack Dab. So first of all, really quickly, what is Fuel? Fuel is a modular execution layer. So that means you can execute on Fuel and settle another L, one like Ethereum.
00:00:47.876 - 00:01:32.328, Speaker A: And what makes it really different from other roll ups you might have heard of is that it uses the Fuel VM instead of EVM, which uses the UTXO model that allows for parallel transaction execution. So it's much faster than EVM. So the basic Fuel terminology you're going to want to know as they're going through this is when I say Fuel, I'm referring to the fuel blockchain. Sway is our domain specific language. It's a Rest based language, so we don't use Solidity at all. Fork is short for Fuel Orchestrator, and it's the equivalent of Cargo for Rest or NPM for Node. And we're going to be using that to create a new project and build it.
00:01:32.328 - 00:02:14.656, Speaker A: And Fuel Up is our tool chain manager. So you can use this to install and manage versions of Fork and Fuel Core. And then Fields is our SDKs. So we have Rest and TypeScript SDKs and the name comes from like Ethersjs. So this is sort of what I talked about earlier, but it's just sort of comparing what you might be familiar with in terms of that architecture with the EVM versus. So instead of solidity, we use sway. When you're developing and deploying contracts for the EVM, you might use Hard Hat or Foundry.
00:02:14.656 - 00:03:12.890, Speaker A: But for fuel VM we use fork and fuel up. Our SDKs are called fuels. Again, it's for resting TypeScript and we have our own indexer service as well. So in general, when you're developing with Fuel, you're using tools that are all developed by the Fuel Labs team instead of a bunch of independent tools. So Solidity, as you probably know, is the OG language for the EVM and it's been there for us for a lot. There's a lot of cool projects that have come out of that, but it can sometimes feel like a minefield for vulnerabilities and really hard to get up to that level of pro. Solidity developer with sue, it's based on Rest, it's for the Field VM and it's really built with lessons learned from Solidity in mind and designed for a really good developer experience.
00:03:12.890 - 00:04:00.776, Speaker A: In general, Solidity, you can really only write contracts with Sway, there are four different program types. You can write contracts, libraries, scripts, and predicates. And I believe we have a bounty out that is just order predicates for shackathon. So here's your typical Hello World contracted solidity, right? It just has this public greeting. This is string called hello, world. And if you're familiar with Solidity, you'll know that there's a getter function that's automatically generated and here's what that contract looks like in Sway. So there are no hidden functions in Sway, sort of like what you see is exactly what's in the contract and what's available.
00:04:00.776 - 00:04:55.880, Speaker A: So we have to write our own getter function here called get greeting. And instead of just declaring this persistent storage variable anywhere in the contract that's outside a function, you have to declare all persistently stored variables in this storage right here. So we're saying we have a variable called Greeting that's going to be persistently stored, a string with twelve characters and a TELO world. And when we access this greeting variable, we do it through the storage object. And so this is really handy for preventing namespace collisions. So you don't have to worry about if you wanted to name a variable inside this function, greeting, because this persistent greeting storage variable is stored under storage greeting. So a little recap of what we just saw.
00:04:55.880 - 00:05:31.590, Speaker A: A solidity is based on C plus plus python JavaScript. Sway is based on rest syntactically. And Solidity functions are not pure by default. You add the pure keyword if it's pure and view if it's view only in sway, they're pure by default. And you have to use this like storage read or storage write annotations if you want to access persistent storage. And like I said earlier, there are hidden functions generated. Sway, the contract tells the full story.
00:05:31.590 - 00:06:46.780, Speaker A: You can put in state variables and solidity sort of anywhere in a contract except for inside a function. And in Sway they are all neatly organized in the storage block and again, they are namespace, so you have to access them through the storage keyword. Another huge difference of solidity and Sway is that Sway tries to reduce the number of global variables there are. So keywords that you can't touch and we provide a lot of stuff through our standard library and I'll show you an example of what that looks like. So when you're creating fungible tokens in Sway, so this would be something like the equivalent of ERC 20. You could actually use a function from the standard library that mints native tokens, which means that you can send them in a call, just like you would send ETH in a call for Ethereum or matic in a call for polygon. So here's what that ERC 20 contract might look like in Solidity and in sue we have this standard library that just comes out of the box.
00:06:46.780 - 00:07:29.444, Speaker A: So if you're familiar with React, it's like how you can pull in use state or use effect from React. You can pull in any function from the standard library or any constant from the standard library out of the box. So we're pulling in this Mint to address function. And we can mint native tokens out of the box to an address. And for receiving tokens in Solidity, you'd probably check this message value variable. And again, if this is for Ethereum, you know that this would be ETH because it's the only asset you can send. With Sway, you can send any asset.
00:07:29.444 - 00:08:30.060, Speaker A: So we actually have these two standard library functions, message Asset ID and Message Amount. And you can check for the amount sent in a function call and what kind of asset. All right, so now you have just like sort of the general background of things you can do. Slade and developing on Fuel, we're going to start writing a really short contract and really brief front end. It's going to be a really simple game. So to get started, you're going to have to install Fuelk, which is our tool team manager. So if you go to scroll down and find the installation command, and this is one really simple command to get Fuel installed and started developing.
00:08:30.060 - 00:09:24.320, Speaker A: So again, here is this command. And then I'm going to open a terminal, and I'll show you what that looks like once that's installed. Okay, so once Fuel Up is installed, you can use this command, Fuel Up Show to show the installed tool chains and the latest tool chains. And so right now I'm working on beta three. And if you want to install it, you can use command fillup install tool chain beta three. And this is one of our testnets. It's our third testnet, and the testnet is not actually completely live yet, so you can't quite deploy this contract, but we're going to develop one anyways and deploy it locally.
00:09:24.320 - 00:10:05.164, Speaker A: So it's actually Felib tool chain install beta three. And I already have it installed, and we're going to set it as our default with Felip default beta three. Okay, so now that we have that installed, we have access to Fork and Fuel core. So I'm going to create a new project. Let's see, let's make a new folder called Game go into Game. And we're going to use fork new. And then we'll call our contract Sway Game.
00:10:05.164 - 00:10:41.760, Speaker A: And this will create a new fork project for us. So I'm going to open this folder up in Vs code here. And here is our template, game or contract. And so we just have this test function right now, but we're going to update this. So the first thing we're going to do is we're going to make a player struct. It's going to be really simple. We're just going to have a player that has a level.
00:10:41.760 - 00:11:39.540, Speaker A: And the level is going to be a number, which is going to be a U 64, which is the default number type in Sway. And we also want to be able to update the level for this player. So we can add a method to the struct with the impl or implement keyword and we can implement the player struct and add a function called level up. And we can pass in the struct itself here to update itself. So use this keyword ref mute self, which means it's a reference that's mutable to this player. So it allows us to update it and then we can say self level equals self level plus one. And now we have this player struct and a way to automatically update it.
00:11:39.540 - 00:12:46.360, Speaker A: So let's add it into our contract. So we have this abi right here, abi essentially just an outline of all the functions in your contract, the types that are used for the inputs and the types used for the outputs. And so we're going to get rid of this test function here and add a new function and the function is going to be called new player. So function, new player and it's going to return a player struct. We use this skinny error right here, return a player. And we're going to want to copy that into our contract here so it looks identical except for we're going to actually implement the logic here and so we're going to make a new player, but we're going to want to store it somewhere, right? So we're going to add that storage block I mentioned earlier and we can store this in a mapping. So we can call this variable players.
00:12:46.360 - 00:14:01.644, Speaker A: And it's going to be a storage map, which is a special type used to store mappings. So this map to define the types in this map key and values this sort of like generic syntax right here. So we're going to save an address to a player and initialize it as an empty storage, not like this. Okay, cool. So we have our storage set up and now in our function we're going to want to add a player to storage. So we're going to need to add this storage annotation here and we're going to read and write and whatever is in the API also has to match in here. So for the sake of time, I'm going to paste logic in this function here and we're actually going to be using the standard library, something from the standard library.
00:14:01.644 - 00:15:01.168, Speaker A: So we want to get the message sender. And like I was saying earlier, in Solidity, you'd probably use this global variable to get the message sender. But in Sway we can pull in a function from the Standard library to get this and the message sender in Sway is an enum type of an identity. And identities can be either an address or a contract ID. So you can actually tell if a contract is calling your contract or someone's wallet. So in our case, we wanted to make sure that only wallets can call our contract and play the game and a contract can't. So we can check here if the sender is an address, and if so, then we'll set the address to this variable and if not, then we can revert and we can use a require statement to read from our storage.
00:15:01.168 - 00:15:43.424, Speaker A: And we use this Get method to read it. And when you use the get method in storage, at least for the beta three toolchain, it returns an option that could be either some value or none. Essentially it's initialized as everything is none. And then once you set it, then the value is some. There is some value there so we can check if there is none with this built in method here. So we're making sure that there is no player that already exists and if there is one, we have this error message. And then finally we can create a new player with this struct and we'll set the first level as one.
00:15:43.424 - 00:16:51.320, Speaker A: And then we can add that player into our storage mapping here with this insert method. So we're inserting the address and the player. Okay, and let's add one more function to level up the player. So this function will also have the read and write annotation and you can just paste that same thing into the contract implementation. Place the semicolon with curly brackets and then to get the player, we're going to use the same code right here of getting the sender or sorry, getting to level up. And then we can get the player, level it up and then reinsert the new player into storage. And so we can do that like this.
00:16:51.320 - 00:18:01.950, Speaker A: So let this mutable current player variable equals storage players get the address from the message sender. So we're getting the existing player from whoever called this contract. We're calling it Needable because we're going to level up call our level up function that just takes the level and adds one and then reinsert it into our storage mapping. And we can return the final level here like this currentplayer level. So you can actually optionally reuse the return keyword here and use a semicolon. But as a shortcut in sway and rest you can emit this and it will return this value. Okay, so let's add one more function here to read the as, like a read only function to get the player.
00:18:01.950 - 00:18:50.754, Speaker A: So here's our get player function. It takes an address and returns the player. And then to implement that function down here, we can use just this one line storage players get address unwrap. And this unwrap just unwraps the option type value to return the actual player. So without this unwrapped, this would return an option wrapped or a player wrapped in an option, essentially. Okay, so I was hoping to write a test for this. It doesn't seem like we have time.
00:18:50.754 - 00:20:53.830, Speaker A: So let's see if we can create a front end for this really quickly. So to make sure it will, we can use this fork build command. Okay, so first go into the swagging folder, fork build and okay, actually we have a semicolon here, it should be comma and that's the nice thing about this compiler is it will tell you straight up, like all the errors that are happening in your contract and wallet that you deploy unless they're all fixed. So, okay, we have our contract built and let's create a front end. So I'm going to go back into the game folder here and use the NPX create react app to create a template front end with TypeScript. And while that takes a second, we're also going to add this file called chainconfig JSON and that's going to allow us to run a local node with a pre funded wallet. And if you go to our let's see, our doc site here, fuelbook, Fuel networkmaster, and then scroll down to running the local nodes, you can find a copy of the chain, what the chain config looks like.
00:20:53.830 - 00:22:26.900, Speaker A: So I'm just going to copy this into here. And essentially the only thing you need to change is this wallet address right here. So this chain config, when we launch our local node, it will fund this wallet. And one more thing we have to do, or actually a couple more things we have to do is in our front engine we have to install Fuels, which is our TypeScript SDK and that will allow us to interact with our contract. And one more thing we have to do is use this typegen command and you can find this in our TypeScript SDK docs or in our Quickstart. So it's NPX Fuels typegen and essentially just generates all the types from the contract folder into our front end and Sway game. Okay, update a folder here.
00:22:26.900 - 00:23:34.620, Speaker A: Okay, awesome. So we don't have a ton of time left, but I can go into our app TSX file and going to replace everything here. So now that we have our chain config up, we can start a local field node and everything should be installed already through Fuela. You can do this Fuel core run and it will use this chain config JSON. Oh, this is dodged. Oops, I didn't name this. Right, here we go.
00:23:34.620 - 00:24:13.112, Speaker A: Chain config. All right, so we have that running in our contract folder. So it's on sway game. We can deploy to the local node with deploy unsigned. Oh, sorry, fork deploy unsigned. And here's our contract ID. Back in app TSX, we have the contract ID here.
00:24:13.112 - 00:25:24.750, Speaker A: We have a wallet secret and we're connecting to our local node through the wallet and pulling in the abi from this generated contracts folder swiggame, abi matches. And here's how we can call each of these functions. So to create a new player, essentially we just can say awaitcontract functions, newplayer call and let's see if we can get this to work. All right, so we have, let's see, since we're console logging, I'll open up our console. We can see create a new player. Here's our new player. Level up, level two.
00:25:24.750 - 00:25:46.710, Speaker A: We're going to level it up again. All right, it's level three. All right, there we go. So there's our super simple contract. I know I went through it pretty fast, but that's how you do it. Are there any questions online or in the chat?
00:25:50.770 - 00:25:57.650, Speaker B: There's no questions in the chat, but yeah, if anybody wants to ask a question, feel free to take yourself off mute or type in the chat.
00:26:13.590 - 00:26:42.550, Speaker A: Okay, well, I'll just say really quickly, if you go to our Quickstart right now, we're using the Beta Two network and this contract I developed for Beta Three network, and it's not quite live yet, but it should be live very soon. So hopefully if you're in this hackathon, you'll be able to deploy to the Data Three testnet for your final project submission. And in the meantime, you can develop locally.
00:26:46.090 - 00:27:07.520, Speaker B: Cheers, thank you. And yeah, I just placed a link to the Fulsa Discord channel as well. So if you have any questions after this and please feel free to ping them in there. But yeah, thanks again for everybody for joining and great presentation, Sarah. And yeah, we'll see everybody on the other side.
00:27:08.610 - 00:27:09.530, Speaker A: Thanks, bye.
