00:00:00.330 - 00:00:20.612, Speaker A: You okay? Hello? Yes. Okay, I just stand. Yes. Hi everyone. So today, sorry about my voice. There's just been a lot going on. I've been kind of talking to a lot of folks, so my voice is kind of at its limit.
00:00:20.612 - 00:01:28.930, Speaker A: So I appreciate your patience that my voice has actually gotten worse rather than better. Yeah. So today we're going to be talking about Oracles and the solving of a very specific problem for smart contracts. The problem is that smart contracts on networks like Ethereum and all its different variants, including various private variants, public variants, they cannot speak with data. So if a smart contract can't talk to a data source, then it can't know that something happened out in the real world. And if smart contracts can't know that a contractual event occurred, then that smart contract can't be built. So if you want to make an insurance contract or some kind of financial product that relies on market data, or you want to make something for trade finance where you rely on shipment data, or you want to make any of the other very interesting various smart contracts that require an external proof of performance, that they need to know that something happened out in the real world in order to exist at all.
00:01:28.930 - 00:02:33.380, Speaker A: Until you solve what's called the Oracle problem, you can't get that data to the contract. What this effectively does is it makes it so that the contracts that can be built on Ethereum and private variance, or the public variance of Ethereum, the thing that this means is that the contracts you can build on Ethereum today are tokenization contracts. You can build tokenization contracts because those are the functions you have out of the box. You have the ability to make tokens move around private keys, and that's what you can do. But you cannot, until you solve this smart contract connectivity problem or Oracle problem, connect to sources of information that prove something has happened. And that's greatly limiting for what this technology can do, in our opinion. Now, just to put in context what could happen if this problem was properly solved, we can look at how the space has evolved and how it might evolve if this problem gets solved.
00:02:33.380 - 00:03:38.408, Speaker A: So the way smart contracts have evolved is they've gone through a few stages. One of the first stages was going from multi signature signing in something like Bitcoin that was considered the smart contract in something like 2013. And then you went to protocol opcode based smart contracts where you had to speak directly with a protocol developer in order to make any type of new contract. So this means you couldn't write your own contract code. You had to go to a developer that made the protocol. You had to tell them, I want a new smart contract in your protocol as part of your protocol, and then I need to engage in a three month cycle and then another three month testing cycle, another three month release cycle, and maybe I'll have the smart contract I need in anywhere from three to nine months. Now, what Ethereum did that is genuinely very impressive and has moved the space forward to a very substantial degree, is it took us from these protocol opcode based smart contracts to these scriptable contracts.
00:03:38.408 - 00:04:41.196, Speaker A: Now, that was a huge leap forward in features, it was a huge leap forward in what people could do, what developers could build. Essentially the roadblock of I want my core smart contract code to do X went from I need to talk to a protocol developer to I need to sit down and either copy paste somebody else's contract code or write my own in a week. And that has created this explosion of features and use cases and value mainly focused around tokens. So that was a huge leap forward, which Ethereum has done a great job at moving forward and initiating moving forward. And they deserve a lot of credit for that. The next stage, which logically makes sense to us, is a stage where you have these scriptable smart contracts where people can make whatever smart contract they want, they can code whatever core operations they want to represent their application. And now these scriptable smart contracts can also interface with relevant events.
00:04:41.196 - 00:06:01.530, Speaker A: Essentially, they can interface with relevant data input events that prove that something happened in the real world. They can interface with relevant payment events, such as payments to somebody's bank account or payments on another chain. And this ability for this scriptable contract, which anybody can write to do whatever they want it to do, and then the ability to get that scriptable contract beyond tokens and into the world of I'm reacting to market data. I'm reacting to an IoT device that tells me something happened relative to insurance, something happened relative to shipment, and then being able to also affect things in the real world opens up once again an entire huge, massive collection of capabilities for developers to build more. And we already know they're doing this. And what our project focuses on is solving this problem. So the entire goal of chainlink is to solve the problem of how do we go from scriptable contracts focused on tokens to scriptable contracts that can do everything else, that can do things in the securities industry and trade, finance and insurance, and whatever you want them to do, they can now do.
00:06:01.530 - 00:06:54.380, Speaker A: So this is what we're focused on. Essentially, the solution to this is a blockchain middleware. So it's something that sits between the off chain world and the on chain world for both the transmission of data into the contract, the transmission of commands from the contract to payment systems to various various other services that it wants to make an effect on, and the ability for the contract to affect changes in other chains. Essentially, all of this is enabled by what's called technically called a blockchain middleware. Also known as an Oracle, and we call it a chain link. And that's what we work on. Now, I think the key point when considering at a very high level, when considering yeah, excuse me about my voice, sorry, I don't mean to make this this painful.
00:06:54.380 - 00:07:37.764, Speaker A: Yes, maybe that's better. Excuse me. The key point is reliability. The reason that reliability is the key point when it comes to Oracles and Blockchain middleware reliability security is that this is the key feature of a smart contract. So the key feature of a smart contract is its ability to provide the guarantee that a state change will happen if a smart contract gets an input, such as a signature, let's say it's a bitcoin multi SIG. The bitcoin will be transferred in the UTXO model out to the relevant addresses. Right? That's unique.
00:07:37.764 - 00:09:18.280, Speaker A: There's no other form of digital agreement that does that. And then if you move that on down to more complex contracts like the Ethereum smart contract, they supposedly provide the same guarantee of, I have extremely reliable digital agreement. Now, if we want extremely reliable digital agreement that has this expanded set of connectivity features, in order for us to build more interesting, more useful, decentralized applications, smart contract applications, whatever you want to call them, if we want this, and we want it to actually be something people put value into, we also need to provide the similar guarantee. Right? So now the guarantee expands beyond the contract, and it expands to the systems that are included in generating this externally connected, externally triggered contract. Right? So this is a fundamental core idea where it's based on the simple fact that I've tested in practice, or a lot of other people that build these more connected contracts have tested in practice in that nobody cares and nobody wants to put value into a contract that's partially secure. Nobody will put value into a contract that's secure in, like, the middle stage, but it isn't secure at some other stage. If somebody's going to put hundreds of millions, eventually billions of dollars into this deterministic, highly, very difficult to roll back form of digital agreement, it needs to be secure and reliable.
00:09:18.280 - 00:10:05.116, Speaker A: And that's just the simple fact of what these contracts need to deliver in order to be useful, in order for people to put value. So the end to end reliability is very important. And that's essentially the place where Chainlink seeks to excel. Chainlink is a collection of approaches that seeks to provide contracts with this reliability through a community of Oracles that people can select multiple Oracles or one Oracle, however many they want to select. But we'll get into that essentially. This is a very important idea. And if you're building your smart contract, you should ask yourself, I know that my contract is reliable because I believe that the Ethereum network is reliable.
00:10:05.116 - 00:11:11.336, Speaker A: How do I know that my contract is reliably triggered? How do I know this isn't a point of failure. You as developers and the people that are building something that's going to get value put into it in this space should take that point of view, because if you build something that's not secure, it could create a problem. So this is kind of you looking ahead to see that there won't be a problem. One way not to do this. In our opinion, the most logical, intuitive initial idea would be, okay, I'll just have an oracle, and there'll be a single oracle somewhere, and it'll be run by somebody, and it'll be closed source, and I'll just hope for the best, and I'll just send it into some oracle somewhere run by, I don't know, five people, right? And then they'll trigger my contract and it'll all be great. This approach in and of itself is very flawed because it goes against the security model and the logic of our space, right? The logic of our space is, I trust the contract state change because it's computed on multiple nodes. It's computed on a network of nodes.
00:11:11.336 - 00:11:42.996, Speaker A: And this decentralization or essentially high level of redundancy provides me this guarantee. And then when I expand the features of the function of the contract out to how do we trigger it reliably, I suddenly forget this idea. Forgetting this idea isn't a good idea. You should really just stick with this decentralization high redundancy equal is the security model idea. So that's why centralized Oracle without any additional guarantees is highly problematic. In our opinion. We've run a centralized Oracle for years.
00:11:42.996 - 00:12:41.496, Speaker A: It's not something we think can provide the guarantees that people would look at an end to end smart contract setup and say, yes, I'll put $100 million into that. Doesn't seem so likely. The more likely, the more useful security model that isn't in line with the model of our space is one where you have decentralized computation doing the state change, and then you have a decentralized Oracle network, which essentially means that you've applied decentralization to this Oracle mechanism. You have the capacity as a developer to select a multitude of Oracles and to pay for decentralization on the level of this mechanism. So now you pay for decentralization for the state change because you believe in the security model of decentralization. You pay for decentralization at the level of the Oracle because you believe in the security model of decentralization. That's the basic foundation that chainlink is more or less built on.
00:12:41.496 - 00:13:30.376, Speaker A: And then after you've decentralized the Oracle network level, or decentralized the Oracle level or the middleware level, you can then move on to decentralizing subsequent layers. So that means data feeds. So once you have multiple Oracles, you can then talk to multiple discrete data feeds if you want to decentralize that layer. That's a separate question. But the first step is essentially in terms of security, you continue to move out from the contract to determine what you can make secure. As a quick example, just to put this into a clearer perspective, let's say you had a contract where something was shipped and you wanted to make sure it arrived because your contract is highly deterministic and highly efficient, and it's very hard to roll it back. And it doesn't have a rollback and nobody is going to want to roll it back.
00:13:30.376 - 00:14:22.360, Speaker A: It's going to be very difficult. You don't have like a three day period waiting to do something. It's this super efficient, super deterministic, super great contract, right? So if it's so super great and efficient and deterministic and immutable, you might want to make sure that what it relies on actually happened. In this example, there's two sources of data about a shipment and now your contract knows as an initial key source and then maybe as a backup piece of proof about something happening in terms of a delivery. And then let's say your contract wants to pay let's say your contract wants to pay $100 for this delivery or a million dollars or a billion dollars. And now it needs to know market data. So now the payment is determined by this market data that's delivered to the contract, in our case, through multiple sources and multiple individual nodes.
00:14:22.360 - 00:15:25.848, Speaker A: This costs more, but this creates more reliability. And it's an important point around if I want my contract to then pay out in bitcoin or Zcash or something else, how do I know how much bitcoin it sends? How much is $100 of bitcoin? $1,000 of bitcoin, a billion dollars of Bitcoin? I need to know this and I need to know it reliably. So at the core, this is the approach that chainlink seeks to provide to the public chain kind of open source community. The second piece of chainlink. Well, not the second piece. Another very important thing that chainlink does and that we're always eager to hear feedback on and think about how we can be more helpful is the ability to have is the ability to have premade inputs. So what a premade or premade oracles premade inputs and outputs.
00:15:25.848 - 00:16:29.984, Speaker A: What a premade input and output is, is the ability is essentially an API that's had a specific chain link wrapped around it and now has a specific contract on chain that represents that resource, right? So what we have is we have these collections of now we have tens working on hundreds and eventually probably thousands we'll have of these discrete contracts on chain. And each discrete contract represents a specific off chain resource. So each discrete contract can represent market data. You can have a discrete contract for weather data. And now what you can have is you can have contracts, you can have a collection of building blocks. You can essentially have a collection of inputs and outputs that are pre made inputs and outputs. So now a smart contract developer can build at the velocity of a web developer, right? The velocity at which a web developer builds is I write my core code.
00:16:29.984 - 00:17:28.896, Speaker A: Let's say I'm making the Uber application. I write my core Uber code in a week or two for the MVP, and then I go out and I get a GPS API, I get an SMS API, and I get a payments API, and I have my Uber MVP, I have it working right, and I have it doing what it needs to do. In smart contract world right now, the velocity of a developer to build such an externally connected application, something like that, is extremely low. It's probably orders of magnitudes lower than that. And the way to get to the same velocity, the way to get to the same speed of creating interesting, useful things, and then even more importantly, probably, iterating on adding more inputs, removing inputs, changing inputs, is if there's pre made on chain contracts that represent specific resources. So now you can have a requesting contract, you take code snippets from that represent four or five other contracts. Those contracts, code snippets go into the requesting contract.
00:17:28.896 - 00:18:08.956, Speaker A: And that's it. Just like APIs. Now, literally in a matter of minutes, a smart contract developer has connectivity to all the inputs that he needs, and he's able to get his application working. He doesn't need to figure out the and in chainlink's case, he has a substantial amount of information about why a specific Oracle is a good Oracle. So the question of why am I relying on this Oracle is answered, and the question of what input I'm using is answered. And so now the velocity of development has rapidly increased from months to days or weeks. So, yeah, that's another big piece.
00:18:08.956 - 00:19:15.528, Speaker A: Chainlink also has other pieces to it. But I think the most useful piece for the hackathon is probably these questions of how do I use a decentralized Oracle to make a highly reliable input? How do I make a highly reliable end to end contract? And then the second question is, what specific inputs or outputs do I really want as a developer? What specific inputs and outputs should there be a premade chain link for so that I can reliably use that input and output? And I can even show other people very clearly, here's my core code, here's the contract responsible for delivering this data, here's another contract responsible for doing payments somewhere, and here's my application. Yeah, so I think those are the core, two key core ideas. I think we'll just stop with for the hackathon that's chainlink. We make it for developers. Our entire company exists to help developers build more interesting contracts, more valuable, more useful contracts. We do that.
00:19:15.528 - 00:19:51.270, Speaker A: My voice is this way because I want that to happen because, yeah, that's why we fly around the world and we talk to all these people, and our company exists to do that. That's the goal of our company. If we wake up one day and you guys have built really cool stuff because we enabled you to connect to the right inputs and outputs. We're very happy people. Or as happy as you can be in modern life, probably, yeah. Okay, so that's generally speaking the gist of it. I'm glad to answer any questions, that is, if I have time and if there's questions.
00:19:51.270 - 00:21:13.174, Speaker A: Yep, sorry, I've been told I really should do this. Your question is what is an oracle? Kind of what is the components? Anybody can be an oracle. So we focused. I'm sorry. Well, just to be clear, an oracle is a smart contract, is always a smart contract and a piece of off chain software that fulfills requests which were sent to that contract. So in our network, every oracle is a contract and an off chain piece of software. Now, I think your question is who can become an operator, a node operator within the chainlink network? No, you seem to have a multi layered question, so one of your questions so there's a piece of your question that asks if an oracle can be a smart contract.
00:21:13.174 - 00:22:28.046, Speaker A: The answer to that is an oracle is always a smart contract. There's another part of your question that seems to be who can be a node oracle as an entity or as a person, which in the language of our network is a node operator? What can be a data provider? Anybody can be a data provider. So there's two ways people can be data providers. One way is a node operator that's not the data provider can connect to the data provider and sell their data to contracts. Another way is that the data provider can run their own chainlink and provide data directly. Does that answer your question? Yes, it can be both. So chainlink is just like a flexible piece of software that can include multiple data providers and it has multiple ways that contracts can interact with that data.
00:22:28.046 - 00:23:07.274, Speaker A: So what that means is you as a contract can say on chain, you can say, I want this schedule of data and I want a wallet somewhere to send me the data to my contract. Another way is you could do some other function on chain to get the data that way. So there's a lot of flexibility in how contracts can consume data through Chainlink. There isn't one way. It usually depends on the use case, how people want to consume the data. Yeah, I'm glad to get into the details offline, if that's helpful. I don't know if I have to add.
00:23:07.274 - 00:23:48.694, Speaker A: There's one more question, looks like no, I think we have some more. Yeah, we have some that we've written. We have a number that community members have written. Oh yeah, absolutely. Our entire model is that we have a set of core features that's worked on by an open source community and their security research community and the academic community, and we do multiple audits on that. And then the adapter level code is the integration code with specific data sources and we can now turn those around in, like a number of hours. So, yeah, we've made it very easy for somebody to choose.
00:23:48.694 - 00:24:39.798, Speaker A: I want that API, and I want a chain link. And then either I can run it or somebody else in the community, a node operator with a good history of running Oracles can run it. Or multiple node operators with good history can run it. Yeah, but the goal for us is not that we make the adapters. The goal is that we will initially make a lot of the adapters, but if we have to. But essentially, the framework is one that allows data providers, allows third parties that want to monetize certain APIs to, in a matter of hours, generate exactly what they need in a very clean, limited, more secure way. Okay, I think I've hit my time anyway.
00:24:39.798 - 00:25:02.760, Speaker A: It sounds like so it sounds like it looks like we're good and great. Thank you all for coming. And we have a table, and we have a booth. We have engineers there. We're glad to help get you guys where you need to be with Oracles here. And after the hackathon, if we can help make something cool together, we're totally into it. Thank you.
