00:00:00.810 - 00:00:41.306, Speaker A: Hello, everybody. I'm Andrew with Textile. You can find us at textile. IO. I'm really excited to be here today with Carson Farmer to share with you some work that we've been doing to make it easy for application developers on Ethereum or Polygon or near make use of permissionless storage on the filecoin blockchain directly with their native application. So that means that you can build native DAP or NFT or Smart contract that can store data on filecoin and access that data over the IPFS network with nothing more than your native wallet. This system is currently running free for you to use, and we think a lot of cool things will be built on it.
00:00:41.306 - 00:00:43.450, Speaker A: So with that, let me kick it over to Carson.
00:00:44.830 - 00:01:34.310, Speaker B: Cool. Thanks, Andrew. So what are we talking about here? Bridges are shaping up to be a really powerful open protocol and concept for providing permissionless filecoin storage to blockchain users and applications in their native token. And so what I mean by that is you and your users can actually start storing data on filecoin from any blockchain that we support without any conversions, sign ups, developer tokens or secrets or anything like that. And so I want to go through a little bit of what these bridges look like and how we're building them. So we're building a filecoin bridge for just about every blockchain that we can get our hands on. And so right now, that includes Ethereum, Polygon, Mir, and insert your favorite blockchain here soon, hopefully.
00:01:34.310 - 00:02:40.874, Speaker B: So, for those who aren't familiar, filecoin itself brings a lot of the best parts of the IPFS stack, including verifiable data, peer to peer data exchange, deduplication, and a lot more. And so essentially, we can create a lot more secure data storage layer for decentralized applications and their users and their developers by bridging Filecoin with other blockchains. So when using the bridge, your users or your app or your smart contract, they actually still reference data and retrieve data over IPFS like normal. But the raw data itself is available in storage contracts created with filecoin miners on the filecoin network. And so the metadata for that storage and that storage deal can actually be reported back to the native blockchain as open reusable building blocks for other DAP and App interactions. And so I want to just go through kind of what the structure of this filecoin storage bridge system looks like. So the bridge revolves around kind of two key concepts deposits and storage.
00:02:40.874 - 00:03:55.830, Speaker B: And the deposits API that all happens on chain and whatever native chain we're talking about. So that's Ethereum, Polygon, near, whatever, and then the storage APIs, these actually interact off chain with a storage validator that will actually interact with or interface with Filecoin. And so the validators, they handle things like compiling batching and deal making with the filecoin network, and then they can report deal success back to the native chain. So we have our validators down here, which are connected to filecoin storage. Along the way, data is actually cached in a highly available IPFS layer, while the deal sealing and proving stages which can be computationally expensive and slow are underway. So this means that app users and developers, they have the sort of fast off chain content addressable data available right away thanks to IPFS caching, while the slower provable and incentivized storage is making its way to the filecoin chain. And then additionally validators can provide things like indexing mapping from a CID, a content ID to the actual deal on filecoin network and a bunch of other things for on chain apps and DApps.
00:03:55.830 - 00:05:23.022, Speaker B: And so the way that this whole system works is basically DApps or users have to provide a deposit with the on chain component of a validator and leaving a deposit, this provides sort of degree of civil resistance. So users looking to store data on filecoin via a validator, they deposit some funds with the validator's contract proportional to the length of time that they'd like to keep storing data. So by default this is about 100 Gy per second or a very small fraction of Maddox per hour or about quarter near for ten minutes. These are the defaults and they're configurable by the actual validator. Then after funds are expired so the session is over, then they can be released by the user themselves, by the smart contract that initiated the session or the validator. And this is a nice feature because this leaves a way for a user or a provider to release funds after a storage session is completed without locking funds permanently in the contract during filecoin proof process, which again can be a bit slow. So then once a valid deposit is available in the contract, the app or user can actually then push data to the validator using the validator's stated API endpoint.
00:05:23.022 - 00:06:34.058, Speaker B: And this is available via just a simple get request to the smart contract. And this off chain rest API simply takes files for upload and sends their bytes via the validator off to filecoin for storage in preparation with the validator. The status of each storage request can be queried using its ID. And the storage process ranges from batching files together to preparing the storage deal, to auctioning the actual storage deals, to filecoin miners, to actual deal making and success of the final storage on filecoin. And so you can get status of this process along the way and you can provide this back to the user, you can interact with the storage deal along the way, et cetera. The other on chain component is the registry and this is a logically centralized contract that actually stores a reference to all of the off chain validators and their on chain component or their on chain contract. And to get into the registry, we are working on some new governance procedures for how that might look.
00:06:34.058 - 00:07:20.082, Speaker B: At the moment there is very few validators running, so it's a pretty simple process. But eventually if you're interested in that sort of thing, I recommend you get involved in some of our governance meetings and interact with us that way. And links can be provided at the end of the session here. Okay, so what do these contracts look like? They're pretty simple and that's done on purpose to make it pretty easy to implement these interfaces if you want to provide a validator. So the registry is very simple. It's just a way to add and remove providers to the registry. So the registry is a pretty simple implementation.
00:07:20.082 - 00:08:10.054, Speaker B: It really only needs to expose the registry to add and delete and list broker or list validators. And only the current owner of this contract can actually mutate the registry, but any external caller can actually then query it. And as I mentioned, in the next phase of development we'll actually be adding and removing some components for governance. The next important piece is the validator contracts and these are similarly simple interfaces and they can be implemented by anyone who wants to run a filecoin validator node. So this is what the core interface looks like. And unlike the registry interface, the validator interface can be even simpler than this. It doesn't require that the contract is upgradable or that it's ownable because these contracts were really under the control of the entity behind the validator.
00:08:10.054 - 00:09:07.530, Speaker B: So it's pretty lightweight interface. Some details do need to be considered when implementing the add deposit and has deposit methods. So ideally deposits should have a linear relationship with session time, but ultimately it's up to the validator to decide what that looks like. And the key piece here is that all of these contracts have events in the ethereum or EVM context and logging in the near context so that other contracts can listen to these events or other off chain components can listen to these events and kick off new actions in response to those. So you can imagine all sorts of workflows in which when a new deposit is added to a validator, some action gets kicked off. When a deposit is released, some action is kicked off or monitors updates and these types of things. So this is designed to really make for building blocks of filecoin storage updates.
00:09:07.530 - 00:09:53.546, Speaker B: So how do you leverage this sort of magical bridge to the exciting world of decentralized off chain storage? That was a mouthful. If you're a contract developer you could easily just interact with these contracts on chain via cross contract calls. You could deposit some funds directly from your app or service on behalf of your users or have your users interact. You can listen to deposit events and start reading on chain activity. We've even started integration with the graph for doing things like indexing of the contracts. So you can start to really build expressive DApps that monitor file coin storage in real time and interact with that. But if smart contracts aren't your thing.
00:09:53.546 - 00:11:03.454, Speaker B: We also have storage bridge zero config TypeScript and JavaScript SDKs that make it pretty easy to interact with data that's coming from these on chain components off to the filecoin network in any blockchain based app or service. So we have libraries for ETH storage, we have libraries for near storage and these all should feel pretty comfortable to developers already familiar with pretty common ETH, polygon and Near JavaScript libraries. So to show you kind of what that might look like, you can check out ETH storage and you can check out the docs there. And it has all sorts of information about how you can interact with these libraries. If you scroll down to the bottom, there is a section on ease of use and there's a live demo that you can interact with. And so if you click on that live demo, you get an option to check out the ETH and polygon demo or the near demo. So I'm going to go ahead and click on the Ethan polygon one and that pops up the MetaMask to get me to sign and interact with this on chain component.
00:11:03.454 - 00:11:47.242, Speaker B: So here I'm working with the ethereum rinkabee testnet. The same contracts are all live and working on polygon, mainnet testnet and near. And if you've got any specific chains you want to interact with, just let us know. And the way this works is basically we've just exposed a lot of those on chain components for you to play around with. So you can deposit some funds. And I'm using a test MetaMask account here and I'll just confirm that. And then I can choose a file to upload and I'm going to pick my favorite meme here and then I can upload that file to the filecoin network and it takes a second to send it off to a validator.
00:11:47.242 - 00:12:31.470, Speaker B: And here I get back right away the IPFS CID. And so I can do whatever I would normally do with an IPFS CID in my app. I can display it via a gateway, I can store that off in my smart contract. I can do whatever I want in this demo. It saves it down here to interact with, I can check the status of that filecoin deal. So right now the validator is batching that data with other CIDs, I can copy the CID there and I can even open up a new tab oops and I can view it over an IPFS gateway. And it's all very magical and exciting.
00:12:31.470 - 00:13:27.598, Speaker B: And so I can give you a quick overview of essentially what we're doing and how we're interacting with the SDKs in order to actually produce that simple react app. So again, if you want to check out how to do this via our SDKs East storage, near storage and the demo example I just showed you is available in this GitHub repo here. Now I do want to mention that support and keeping the storage fees free for the time being is actually provided by the filecoin polygon and near organizations. So big thanks to those folks. If you want to get started, there's zero cost to you as a developer to get going on that. And storage deals on FalcoIn are free for the time being. So what does that look like? Here are the main pieces of code or snippets of code that you would need in order to interact with the on chain and off chain components of the bridge system.
00:13:27.598 - 00:14:20.602, Speaker B: So if you're familiar with Ethers JS Development, we import the provider and then really you're just importing a few extra things from Textile's ETH Storage Library. So the initialization function, and this is a helper function to request sign in or activate MetaMask. So you might just request sign in and await that. Get a reference to a Web Three provider and grab a signer. If you're familiar at all with Ethersjs Development, these are pretty much standard interactions. Then we simply initialize our storage session and we get back a storage object. This storage object has a bunch of methods on it that allows us to add deposit, release deposit, get a list of validators, and then store files and get status.
00:14:20.602 - 00:14:51.046, Speaker B: And that's pretty much it. We have a very lightweight API that we can interact with, and we can take file objects like native web file objects. So in this case, I create a simple Blob, hello world, and make a reference to a file and I'm ready to go. I add deposit in this case using the default deposit of about one hour's worth of session time, and I store the file. What I get back is the ID for the storage request and the actual CID. Now I've got that CID. It's on IPFS.
00:14:51.046 - 00:15:39.634, Speaker B: I can do whatever it is that I normally want to do, add this to as an asset for an NFT, display data via the gateway, whatever I want, and then get the status of that later on, maybe when my user logs back in. The near interactions are very similar. So just a sort of best practice wallet setup like you'd normally do. If you're developing an app for near, you get a reference to the storage object and the rest is pretty much exactly the same. And that's done to make it very easy to do cross chain interactions and build very similar experiences for your users. So that's pretty much what we have to share with you today. Thanks very much for watching to the end of this presentation.
00:15:39.634 - 00:15:51.180, Speaker B: If you have any questions, don't hesitate to reach out on Slack, Twitter by email. And of course, we're always hiring, so get in touch if you think some of that stuff looks fun. Thank.
