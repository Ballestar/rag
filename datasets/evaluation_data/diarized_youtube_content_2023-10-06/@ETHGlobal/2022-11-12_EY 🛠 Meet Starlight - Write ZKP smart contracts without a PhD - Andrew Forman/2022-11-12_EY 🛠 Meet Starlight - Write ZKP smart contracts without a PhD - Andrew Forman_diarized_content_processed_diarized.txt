00:00:06.410 - 00:00:50.518, Speaker A: So hi, my name is Andrew Foreman, I'm part of EY. I lead our product and development teams at EY and we worked on this, we're currently working on this open source compiler called Starlight. So that's kind of what I wanted to talk with this group about and maybe just share a bit like how we got here. The problem that we ran into at EY, why we built this thing, why we open source to why we're going to be here at the hackathon talking about it this weekend. So one thing to maybe know about EY two as a background before getting the problem here is that EY loves privacy. We're really committed to zero knowledge proofs. We believe that businesses are going to want to operate privately on public blockchains, mostly ethereum, other public EVMs.
00:00:50.518 - 00:01:50.400, Speaker A: And so we were doing all these projects where I would bring my team of engineers, developers, product managers, and we'd work with our R and D team that's very committed to zero knowledge proof research, cryptography research. And for each of these projects, what we'd have to do is then kind of work out the requirements, build these custom circuits, work with the team to then implement those custom circuits and deliver the project. And so we just found that model wasn't scalable. So we tried a couple other approaches. We tried teaching some of our developers how to use Socrates with some mixed success on that. And so really our response to kind of solving this issue of scale for developers to write privacy and zero knowledge proof enabled DApps was to build this compiler transpiler, but now it'll be open source and so we're making it available for everybody to use. We've got a grant or a prize this weekend, so come by, stop by the table and we'll walk you through some of the details as well.
00:01:50.400 - 00:02:38.000, Speaker A: But yeah, that's why we built it up here, right? So the zero knowledge proof is hard. We believe that a lot more people know Solidity and we want to make it easier for those Solidity developers to then write privacy features into their app directly. So how does this thing work? What we do is we take a solidity smart contract and you mark it up with these function, these decorators, which I'll walk through in a minute, how those decorators work, what they look like. Then we use that to create this Zalidity smart contract. Or a solidity file type is what we call it, which is a zero knowledge smart contract. And that is then what gets run through our Zapify command or zero knowledge appify command into our transpiler. So it turns out this fully private working application.
00:02:38.000 - 00:03:18.506, Speaker A: So to go in a little bit more detail of how that works, so you get the kind of the front end here once you get through the Zapify side, really, from your perspective as a developer, you really don't need to know the details of how the back end works. But I think people like to know, and it's important. What you have here is you have contracts so that holds the private business logic that you would use for proof verifications. Then you have the circuits which is just like a bunch of statements that you would use to generate the proof with. Then in the backend containers you have a couple of core components here that become important. One is timber. Timber is another EY product that we worked on.
00:03:18.506 - 00:03:59.782, Speaker A: It's essentially it's a merkel tree that holds the commitments of the values that you would want to keep private. So all you store on chain is the kind of the root of that merkel tree and then there's kind of this whole idea of frontier nodes which are kind of like nodes along the different various heights of that tree. So we're using that to compute the merkel route very efficiently. So just something that we've worked on is kind of like a backend infrastructure component. We also have the blockchain client obviously to send transactions and then Zocrates is what we use to create the trusted setup. So we're connected to Zocrites that way. And then we also create the end to end test because once you get through the execution flow this will make more sense.
00:03:59.782 - 00:04:57.900, Speaker A: But you couldn't actually write tests for Starlight if you wanted to because once you deploy that contract we're going to actually generate the zero knowledge proof circuit in the background for you. So you wouldn't be able to recreate that logic without us writing the test. All right, so this is where I kind of want to spend most of the time is on these function decorators because this is what you'll want to use and think through properly as you go to kind of design and build your applications this weekend. So there's three function decorators to know. The first one is secret and so what secret is used for state variables that are meant to kept private. So obviously we couldn't use the word private because that has a definition in solidity but you could think about it that way, private or confidential secret. And so right now what that takes is any kind of state variable function parameters on our roadmap is to then add function themselves.
00:04:57.900 - 00:06:17.330, Speaker A: But what you can't add and you can't add local stack variables inside of functions because they don't have a state component and we need something a state to actually make private. The other important thing here, and I think it's listed here in the how it works bullet is that this commitment is now something we call hiding and binding or the requirements that we've set around that. Which means that when you create a commitment nobody else outside of that commitment owner can now see the commitment. It's not available to anybody else on chain and it's binding meaning that that commitment is always matched to the state variable that you wanted to be applied to. Okay, so kind of with all that definition, you look at our example here on the right, we have this state variable called X and X has to be kind of hidden from the outside world. And so then we have a function add and we're going to have another secret decorator for Y. So now if X is a secret on chain and I want to add Y to it, both X and Y are secret, right? So you're maintaining the privacy domain or the privacy set that you want in your application by marking both of these as secret.
00:06:17.330 - 00:06:46.480, Speaker A: The way that you actually do that execution is through something called known. So let's move to that one next. Known. So known and unknown are going to be then how you kind of update these state variables. Right? Now we've created a state variable that's private on chain. That's really cool, but we want to be able to update it. So for known, you're going to use known in times when you are the owner of the commitment and you want to update your own state.
00:06:46.480 - 00:07:33.334, Speaker A: So in this case, it takes a state variable and like you might want to increment your own balance of something, right? I'm the owner of my commitment. I know my balance. I want to increment it. I'll use known. So the way that works is what you need to do is as the owner of commitment, you would need to show the proof of knowledge that you can open that commitment. So we're kind of getting to this language of privacy and zero knowledge proof development that I think is new for myself and a lot of solidity developers is like we're creating commitments. We're saying who can now open that commitment, who can nullify that commitment and who can create a replacement commitment? Right? And this is kind of the pattern you'll see followed through in a couple of these examples.
00:07:33.334 - 00:08:47.590, Speaker A: But to walk through it here, as the owner of the commitment, now I show proof of knowledge that I can open that commitment and then using the secret values of that commit that only I know. And what our team did was develop some kind of merkel tree magic that lets us say we use that commitment without revealing which commitment we used in the merkel tree, which is also part of kind of maintaining strong privacy. So then you'd be able to nullify the old commitment using a nullifier and create a new commitment in its place. And I guess the public key up there too is also the owner's public key, if that wasn't clear. Okay, so then unknown will be kind of the exact opposite of known. Unknown is we want to increment the balance or contribute value to somebody else's balance that we don't own or we don't control their commitment. And so the way you do that is we do something called a part commitment because they're part of the entire state of the secret variable.
00:08:47.590 - 00:09:41.240, Speaker A: So if I want to access the value of a variable you wouldn't be able to do that in a part comment, right? What you have to do is you'd have to sum up all the parts to know what the full value of that variable is. This is more like the UTXO model and actually I think someone was just referencing the last the mental model that I kind of use for it is like a bunch of notes that you would pass around as like IOUs or something in your trade, right? So what is the full value that some person is owed? You'd have to count up all the IOUs. It's kind of how I've thought about it. So that's what unknown does. So let's walk through our example here. It's a little small for me. So we've got our mapping here, which is a mapping of addresses to the balance amount for each address.
00:09:41.240 - 00:10:20.210, Speaker A: And we've got two functions. One is to deposit. So whoever calls deposit increments the balance by that set amount and we have transfers. So whoever calls transfer then will transfer their balance to somebody else. So if you focus here on the yellow parts of the code, what you can see is you can declare some of these balances to be secret which means that no one would be able to see who are the addresses and how much do each of them own or control in this contract. Then you have these function parameters here at the bottom. So in our transfer function we have amount and recipient are also sent to secret.
00:10:20.210 - 00:11:07.554, Speaker A: So that means that the amount that I'm sending in and who I'm sending it to is also going to stay secret. Okay? So those are the secret variables we've covered. Now we're covering Unknown here at the bottom as we get the balances. And the way that we works here is we create this part commitment. So in this particular statement you'll notice that I'm incrementing the balance of someone else, not your own, right? The recipient. Here we create this essentially like an individual note or part commitment that we then pass through the transpiler and that's how we essentially create the circuit for it in the back end. If there's some questions around Known and Unknown later this weekend, stop by.
00:11:07.554 - 00:11:42.754, Speaker A: We can talk through that as well. Okay? So I've been kind of talking about commitments, wanted to kind of flash what they look like. So for our basic normal state variable commitment here, it holds four things. It's going to hold the state variable ID. So right here we're kind of using the existing solidity compiler the way that each contract has a list of state variables and each of them has an ID. So we're going to use that ID in our commitment structure. The second thing we're going to use is the value of that state variable.
00:11:42.754 - 00:12:29.850, Speaker A: So it could be a number address string mapping like you saw in the previous example. The third thing is the public key of the owner of that commitment. So again, this is like something that was new for me to think about when I'm writing my Sleigh is like each time you create a commitment, you have to think about who the owner of that commitment is, who could see it any time. And if I want to update that commitment, who do I need to ask about permission to update it? Or if I'm the owner, then I don't have to ask anybody. And then a random salt, which is used for the hashes the mapping state variable is pretty much the same with one important nuance. In that first part of the hash, we also bring in the mapping key. So we have the state variable ID along with a hash of the mapping key that we created.
00:12:29.850 - 00:13:26.310, Speaker A: Okay, so here's our quick example. So in the invoice smart contract, we have a mapping and address of how much the invoice is owed to that address. And we've got two different functions here add invoice and pay invoice. Add invoice works by having we have party A who wants to pay party B, and so we have this pending invoice amount and how much they should be invoiced by. So then when I go to actually pay the invoice, what I need to be able to do is I need to be able to reduce the amount of pay invoice by the amount that I paid and make the update to that commitment structure. So what the user has to do here is called the add invoice API. And I'll kind of walk through the architecture of that in a second and I'm adding commitment from somebody else with their public key as the owner.
00:13:26.310 - 00:14:31.290, Speaker A: And then once that's done, then we're using the orchestrator here in the bottom and the orchestrator will have to speak to Socrates and ask them to generate the proof with all the private inputs and the public inputs that are required for that function. And then once we get that, we get the proven key back from the orchestrator, which is not to call it a verifier contract, upon successful verification, we'll have to add the state variable to the merkel tree. I think a lot of that stuff is like what's important from the zero knowledge and the privacy assumptions part of kind of using Starlight. The important part, I think, for like if you're just going to focus on the solidity part of this, about how to write a private smart contract to start to set balances and mark them as private is really knowing. When to use secret, when to use known and unknown and what your contract is going to look like as you start to add more and more of these into a given contract because you can start to have very heavy weight contracts. You can start to add different logic complexity to the back end. The compiler essentially, as you start to combine, bind them.
00:14:31.290 - 00:15:13.154, Speaker A: But this is just a simple example that I wanted to walk through is that all you got to do is here is come in, add the keywords and you've got your private account on chain. So then I guess kind of just to close and some key takeaways. Here one I think it's really important to think about privacy. I think that this is going to be a big thing for Ethereum, the developer ecospace in general. It becomes very important now for us to think our users want privacy and have demands and needs for their privacy features. So I think it becomes important for us to think about that. I think it'll help us build more sophisticated applications.
00:15:13.154 - 00:16:08.086, Speaker A: I think right now it's pretty easy for us where you go and you write your solidity smart contract and you just assume a lot of these variables are public and things are available on chain. And as we start to think about what a privacy set in an application could look like and when different information will be revealed, I think it will allow us to build more sophisticated applications going forward. And so just one of these big changes that has come up in the last couple of hackathons that we're going to see more this weekend. So just to call out here, it's important to think about privacy both for your users from a system perspective, kind of what some downstream consequences could be as you start to hide and reveal information. I think that there's some important product design decisions that go into that also. It's just very cool. We've got a lot of privacy and circuit stuff work going on in the background and a lot of that's abstracted from you as a developer.
00:16:08.086 - 00:16:38.946, Speaker A: And for me that's like the ideal developer experience. The second key point here is that this is open source. We've open sourced the code, the repo, everything is available. The next slide I've got a link, it's EY blockchain.com or GitHub. We're going to be working on the transpiler a little bit more to get it out. I mean, I would consider this probably still more like in its alpha stages, but this is not something that we expect to license or sell or right now.
00:16:38.946 - 00:16:59.482, Speaker A: This is open source technology. So that's why we're here this weekend. We want you to use it. We want to talk about what some cool use cases for it might be. We want to see people hack on it and give us feedback. So here's the link to the GitHub for it. I think this weekend too, we're going to create a developer support channel which we don't have yet.
00:16:59.482 - 00:17:27.170, Speaker A: So I put my telegram up there, but if so if you want to hack on it, just shoot me a message and I'll add you to that chat. We have a few minutes for questions. I could take some questions. Also, I've got a PO app that they had given me so I can flip it over to that. Yeah. Decorators were there. Yeah.
00:17:27.170 - 00:17:46.548, Speaker A: So you have to go set up the transpiler. This is the first step. There's a transpiler setup step, and then once you have the transpiler, then you just write your decorators correct. Yeah. But then you're right. Probably. Probably that's, you know, I don't know.
00:17:46.548 - 00:18:03.880, Speaker A: I mean, Nikhil, you run through it. It wasn't it wasn't too bad. Yeah. Which basically yeah.
00:18:10.670 - 00:18:41.380, Speaker B: So I think we have a public documentation on the repo, which basically yeah. So it has exe file on that, which you download, and it just create the node set up on your environment and just run the Zapify command. Zapify. And it will.
00:18:43.190 - 00:19:23.940, Speaker A: Yeah, and maybe just to repeat that on the mic, basically what you're doing is you're going to run the execution file, then you execute the Zapify command, and then you have a local deployment that you can use. Yeah. So I put up a different schematic or a different version of the architecture here, just to show you kind of how that looks. In the example that I gave with the add invoice and the pay invoice and the different numbers here, what they're calling out is how I would update and change the commitment structure. It's not an update. It's really nullify and create a new one. But yeah, still learning the solidity part of it.
00:19:23.940 - 00:20:07.134, Speaker A: Any other questions? Does anybody want the poop? Does anybody care? Cool. Yeah. Guidelines. Privacy. I think there are probably two levels to think about that. So anytime we work on these kind of zero knowledge proof and privacy features, we write up the trust assumptions that we assume the user has to take on using the application. So that's what I referred to in the talk was trust assumptions from using Starlight.
00:20:07.134 - 00:20:40.720, Speaker A: Like, where are the off chain on chain components? I think if you were to build your own application using Starlight, you really wouldn't have to consider the way that our system works in your own trust assumptions. But probably good practice as you start to go build privacy features, make a couple of bullet points to make that clear to the user here's where information is stored, who can access it. That's all I mean by trust assumptions. Cool. All right. Right at time. Thanks, everyone.
