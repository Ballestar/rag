00:00:13.130 - 00:00:39.986, Speaker A: Great. Thanks for joining us. We're really excited to tell you about Mina ZK apps built on the MENA Protocol, which is a layer one blockchain focused on zero knowledge, with ZK app, smart contracts, and a ZK Bridge to interact with Ethereum and other blockchains. Today we have a few presenters. Myself, I work at Owen Labs. I'm a PM for zkapps. We have Evan Shapiro, the CEO of Mina Foundation, who will talk about the ZK Bridge.
00:00:39.986 - 00:01:17.382, Speaker A: And then we have Brandon Case, an architect engineer at Owen Labs, who's going to talk about Snarky JS, walk through a Hello World and give some more info to help people get going. Okay, let's talk about architecture. As mentioned, Mina is a layer one blockchain. Our main net was launched March 2021. The big difference with Mina is whereas other blockchains are large and increasing in size as new blocks are mined. For instance, Bitcoin is 402gb in size and Ethereum is over 1 TB. Mina remains a fixed 22 KB in size.
00:01:17.382 - 00:02:15.400, Speaker A: All you need is this 10 knowledge proof to verify the entire history of the chain. We call this a succinct blockchain. Using recursive ZK Snarks, the current state of the blockchain can be compressed into a single ZK Snark, letting anyone instantly sync the blockchain with the security of a full node. An enormous amount of research has gone into ZK Snarks lately, both inside our company and across the industry. And our cryptography team at Owen Labs has created a ZK Snark we call Kimchi, which is setupless, efficient and extensible. And it's based on plug 15. And you might be wondering, if we have a 22 kilobyte blockchain, how do Block Explorers query this historic transaction data? We have a type of node as one of the many nodes in our network, called an archive node, and Block Explorers can query the historic data through that, but you don't need any of that data to verify the actual chain and the consensus of it.
00:02:15.400 - 00:02:52.082, Speaker A: And so, with Mina, based on ZK Snarks, we had an opportunity to re envision the design of a smart contracting platform. So let's talk about how Zkaps work. As a point of reference, let's look at Ethereum. DApps so at Ethereum, I'm sure most people are familiar with this. On Ethereum, smart contracts execute on chain users send a transaction, specifying a method and data arguments, and every node across the network executes these same instructions. It solves a real problem, but it's very inefficient. In contrast, Mina ZK apps use a different model.
00:02:52.082 - 00:03:34.330, Speaker A: We have off chain execution, and the smart contract runs in a web browser. Using WASM, a user will execute one of the methods on the smart contract, and private data that a user inputs into a method will end up. The smart contract will generate a zero knowledge proof, which gets sent to the blockchain, along with a list of state updates. If that blockchain is proven to be correct for that particular ZCAP account. So this gives us a few advantages. We achieve blockchain scalability through succinctness. We have that 22 kilobyte proof to that proof's consensus.
00:03:34.330 - 00:04:38.610, Speaker A: So that source of truth always remains very small, which of course is the key aspect of a blockchain. We also get user privacy through zero knowledge because the smart contracts are running off chain in a user's web browser, any data that the developer wants to keep private, they can specify private data arguments that will be input into the smart contract that the blockchain will never see. And then we also have the opportunity to have unlimited off chain execution. So zero knowledge proofs have a unique characteristic where no matter how large your computation is, whether it's very quick or very long, doesn't matter because that zero knowledge proof that results from running that function will always be quick to verify. So we send that zero knowledge proof to the chain, and the chain can always verify that very quickly. So how does this work? A Zkap consists of two things. So just as a matter of terminology, we use the term Zkapp to talk about the UI, the user interface, and a smart contract.
00:04:38.610 - 00:05:32.626, Speaker A: And the smart contract is written with Snarky JS. So Brandon and his portion about Snarky JS, that's what he's going to help people get started with. So how does this work? When a developer writes a smart contract and they run their build in their application, it generates a prover function and a verification key. The prover function runs locally and generates a zero knowledge proof. So this is what's going to run in the user's web browser when they're interacting with the CK app. And then it also generates a verification key that they deploy to the network. So if you're a developer and you update your application logic, you will build again and generate a new verification key that you deploy to the blockchain, and then you have a new deployment.
00:05:32.626 - 00:06:26.150, Speaker A: So any transactions will then have to pass the verification key at that point in time. So again, deploying a verification to the chain creates what we call a Zkap account. This is exactly identical to a Mina account. However, when the verification key exists on it, we call this a Zkap account. And transactions, they have to be valid, as mentioned, for the verification function. And they will only be accepted by the network if they are in fact appropriate for that ZCAP account. And that's how we can ensure that even with off chain execution, that we know that zero knowledge proof that the user has run the expected computation.
00:06:26.150 - 00:07:10.630, Speaker A: And if they haven't, the transaction will simply be rejected by the network. Okay, so in a little more detail, let's talk about how a smart contract works. A smart contract, keep in mind we're running in the user's web browser, accepts a few different things. We have method arguments which can be private data, and then we also have some smart contract states, which is public data that lives on the blockchain. And this generates a couple of outputs. So updates to the state of the smart contract, that public state that lives on chain, and updates to the state of the world. So maybe you sent Mina and you changed somebody else's balance.
00:07:10.630 - 00:08:18.090, Speaker A: And one really important thing to mention is we have what are called preconditions. So as a developer, if you want an action to only occur, such as sending funds from account A to account B after a certain black height, you can specify certain preconditions and you can specify those based on either something that's account state related or network related that way too. Okay? And smart contracts, the really cool thing about smart contracts on Mina protocol is they're written in typescripts, so you have the opportunity to use Vs code, NPM, prettier, whole bunch of technology that you're already familiar, you can download if you want to get started today, you can download our ZCAP CLI. So for Brandon's presentation, just keep in mind that you can run two commands and have a project set up and be ready to go with your projects. And I want to pass to Evan to talk about the bridge.
00:08:21.470 - 00:09:19.930, Speaker B: Awesome, thank you. Yeah, I'm going to talk about a part of Mina, a really cool component called the ZK Bridge. So what this is, is this question of, okay, we have this cool Zkap functionality, how can we make this useful and available on all these other platforms? Because we have very efficient zero knowledge proofs. Maybe there's some way we can get that to other chains, which seems like it would be pretty cool thing and valuable to everyone else on those other platforms. So the answer to this we have is this DK bridge, which leverages Mina's succinctness for a cryptographically secure bridge to Ethereum and other chains. The idea here is that we have for Mina this recursive zero knowledge proof that updates every single block and says the current merkel root of the Mina ledger, the current state of the miniledger is correct and has valid consensus information backing it since the beginning of time. And you can check that zero knowledge proof and know that you're looking at the correct state of Mina.
00:09:19.930 - 00:10:04.880, Speaker B: And what's cool is this is lightweight enough that we can run that itself inside of an EVM contract. So that's as if we have a full node of Mina, in a sense running inside of a smart contract. And what's cool then is that anybody can then update that smart contract because the smart contract itself can run Mina's consensus and strongest chain rule. So it's like this decentralized way of having a contract that contains the strongest state of Mina at any time. And then what's cool is that with one bridge update, so one verification of a recursive zero knowledge proof, you can move over all the state that has changed on Mina since the last time, you updated the recursive zero knowledge proof on Ethereum. So if that made sense, great. If not, we're going to run through an example so you'll see how it works in detail.
00:10:04.880 - 00:10:42.140, Speaker B: The example we're going to go with is let's say we wanted like a private proof of attendance. I think there is actually proof attendance is super cool. This is like a private version of that. And we want to make that work between Mina and Ethereum. So the way this can work is first, what happens is a developer is going to write this program called Was at Ethereum that runs on mina. And a user can create a new zero CK app account on mina with the verification key for the app the developer wrote. Great so far, and the data field on this is all zeros because we haven't filled it in yet, but we'll fill it in in a second.
00:10:42.140 - 00:11:25.960, Speaker B: Next that happens is user submits a zero knowledge proof that says, okay, in this example, I have an identity. That identity has been verified by a third party. Like, I went to the DMV website and looked at that page and it was good, as well as an actual valid ETH Amsterdam pass and they matched. And then what I can do is I can make a zero knowledge proof of that and submit it to Mina. And then that allows me to update the data fields on Mina on this DK app, in this example, to my Ethereum public key. So note that if I didn't have a valid zero knowledge proof that contained this private information about my attendance, I would not be able to update this DK app with that public key and it would just be all zeros still. But because I was, I was able to add my Ethereum public key into the Mina account.
00:11:25.960 - 00:12:16.054, Speaker B: Great. So what's next is that we have to get that mina state account onto Ethereum itself. And for that, we're going to look at what I've called here like the Mina Bridge account on Ethereum, which contains as its data, not the whole tree, actually, but just the merkel root of the tree for Mina's ledger. And then an operator, someone who wants to update that account in a decentralized way, can send over that merkel route and consensus information back to Ethereum. And if the consensus information in that new proof is actually stronger than the proof that was already on Ethereum, it updates to that latest proof and latest merkel route. So after this, our Merko route that happens to contain the ZK app, which happens to contain my Ethereum address, is now on Ethereum. Great.
00:12:16.054 - 00:12:20.214, Speaker B: So after that so in this example, it's like a dao for people that happen to attend.
00:12:20.262 - 00:12:20.860, Speaker A: Here.
00:12:21.470 - 00:13:15.660, Speaker B: What we can do is someone can attempt to register. And the registration process includes a merkel path from the Mina merkel route in the Ethereum smart contract down to that account that contains that Ethereum public key. And the user can prove that that was included, that that corresponded to the verification key that actually corresponded to the ZK app that was written, and that they actually have the private key that can make signatures which correspond to that public key. In any case, So with this they can register themselves into a Dao using a ZK proof that they have the rights to do that. So I hope I didn't go to that too quickly. But that's basically the flow that one can imagine for how you can write something on Mina that takes advantage of zero knowledge proofs. And then from Ethereum or other chains you can then access that as part of your application.
00:13:15.660 - 00:13:43.246, Speaker B: So there's a bunch of possibilities one could imagine with this. You could build a private Dao if you wanted to. You could pull real data in to bootstrap more DeFi things. You could build NFTs that have some cool ZK properties. One in particular I think could be cool is like a collection where each person can own at most one NFT. So if you have a bunch of capital, you're still limited in how much you can take from the collection. You can put anonymized proof of on chain information for Ethereum or other chains.
00:13:43.246 - 00:14:18.510, Speaker B: You could build ZK powered games like Battleship is like a good one. There's a privacy element. I think another thing that potentially will be cool, well, at least interesting is making it possible to actually move private enterprise data onto public chains for that interoperability without losing the privacy aspect for those as well. As one thing I think is also very cool, it's very easy to spin up a ZK roll up in this framework because the cryptography is done. You just kind of have to write the recursive step for your ZK roll up and then do that off chain and then submit a big proof back to but that's all I have for this part. Thanks. Yeah, I'll hand it off to Brandon.
00:14:25.990 - 00:14:56.166, Speaker C: Hello. Cool. Okay, I'm going to talk about snarky JS. So Snarky JS is a toolkit SDK that lets you build ZK apps and you use TypeScript. And so because it's TypeScript as Jason mentioned, we can use open technologies. The actual execution happens in the browser or node JS typical runtime environment. You can use existing JavaScript and TypeScript libraries and tools.
00:14:56.166 - 00:15:28.854, Speaker C: That means you can also use like Vs code and you get all the benefits that you get from Vs code. All the ID support of just JavaScript and TypeScript that thousands or millions of person hours have been poured into. You get to use that. So cool. Snarky JS. I know maybe some of this stuff seems really scary after we saw the details of the architecture and the bridge example, but the code is really not scary. I will prove it in a moment.
00:15:28.854 - 00:16:23.110, Speaker C: First, so I want to talk about the base sort of unit of data in zero knowledge programming field element. So a field element, it can store a number that's almost 256 bits in size for the field that Mina uses. You can think of it like a UN 256 in solidity, but it's just slightly smaller for those that are like ZK crazy people. The field type in Snarkyjs, this is the base field of the pious curve and the scalar field of the Vesta curve in Mina's pasta curve system. Unless someone on my team corrects me and I got those mixed up. But if you don't know what I just said, it really doesn't matter. Just think of it like a 256 bit unsigned integer.
00:16:23.110 - 00:17:26.410, Speaker C: In typical programming of TypeScript, you might sum two numbers by creating a local variable and then writing the integer literal one, the symbol plus, and then an integer literal three. I guess, I don't know a numeric literal, I don't know what you call them in JavaScript, but those are JavaScript numbers. In TypeScript we can't override numeric literals. So we have a little bit of wrapper glue to sort of tell the Snarky JS engine that we're using field elements. So this is how you would add one and three. And this is a little cumbersome, so there's some syntactic sugar anywhere that it's unambiguous what you mean the methods accept a numeric literal, a string literal that corresponds to a number or another field element. So it's just like a little bit slightly more characters than one plus three.
00:17:26.410 - 00:18:03.014, Speaker C: Cool. So there's other built in types besides fields. Here's a few of them. So besides field, Bool is one and this is just a field that's constrained to be zero or one. But it has a bunch of helpful methods on it for things that you might want to do. With Bools, we have unsigned integers of sizes that are normal for computational machines like this laptop and then public key, private key signature. For Mina's system we have a Schnorr signature and then some other cryptography things.
00:18:03.014 - 00:18:33.678, Speaker C: Group scalers. The scalar is the other field in the recursive pasta system. Again, it doesn't matter if you don't know what I'm talking about. All of these have built in methods on them. And because it's TypeScript and because we have Vs code and other IDs like that, you can just import one of these things, create an instance of it and then write your variable name dot. And then Autocomplete will just help you explore the SDK. You can just write functions.
00:18:33.678 - 00:19:16.798, Speaker C: So in TypeScript you write a function like this, you can give your parameters types and you can return a type. And here we are adding one to x and then doubling it or multiplying it by two. Just like in TypeScript. I mean it is TypeScript, but just to really show you, we can take a part of that expression and assign it to a local variable. So it's really normal programming. I'm harping on this because if you attempt to program using any other zero knowledge proof framework, you will miss normal programming, I think. So let's go through a simple Hello World.
00:19:16.798 - 00:19:47.174, Speaker C: Okay. A hello. World smart contract. So we're going to write a smart contract that has a single piece of state, a field element that we call X. And we're going to constrain the well, we're going to have one method called update, and we're going to only allow update to replace X with its square. So just to give you a sense of what I'm talking about, if we start at three, the only update that's valid is nine. And if we're at nine, the only update that's valid is 81.
00:19:47.174 - 00:20:16.580, Speaker C: So if we start with three, update it to nine, and then we try and update it to 75. Actually, the proof won't even be created, but if you try and send something messy, or if you try and spoof the chain, it'll also reject your transaction. Cool. So let's write it. First, we extend smart contract. You just write a class extend smart contract. We make the state by adding a member variable with some decorator stuff.
00:20:16.580 - 00:21:05.940, Speaker C: And this line of code is a bit confusing, I suppose, but it's doing so much for you that it's amazing. What this says is X is a piece of state that lives on chain and its type is field. And you can actually use any type that's built out of field elements here, which I'm not going to show in this slide deck, but you can see in our examples and this is public and on chain. So we're going to say what happens when we deploy. Okay. By default there's some things that happen, but we want to override the default by setting it to three. So we call super deploy with the input and we set X to three.
00:21:05.940 - 00:21:45.078, Speaker C: Okay, so now the actual update method, let's just speak about methods. I guess smart contracts have multiple methods or they can this one only has one and these are the things that you can do to a smart contract. So this is like the functions you can invoke on it. And Jason was mentioning this, but I'll say it again with the code. The state the member variable there, that's public. That's on chain. Anything you store there is publicly know.
00:21:45.078 - 00:22:09.410, Speaker C: If you store a hash, then only the hash is publicly readable. But it's public. The arguments to the methods are private and they're only visible on the user's machine. And if you don't put them in some public state, they will just remain private. In this case, we are putting it into public state. So you can see that on line. The third line of that method.
00:22:09.410 - 00:23:15.770, Speaker C: The other thing that's happening here is on the first line of the method, we're calling this X Get, which fetches the current state of the ZK app from the chain. And there's some magic that happens that Gregor can tell you later where this isn't actually Asynchronous because we sort of get it before this runs. But the point is, I mean, there were a couple of reasons we did that, but a nice benefit is you don't have to even worry about like async await. You can just write normal, plain, sequential programs so that gets the state. And then we do this thing on the, on the second line where we add an assert, we assert that the square of X is equal to the thing that we passed in. And this isn't just something that, I guess typically when you have assertions, you put them in there for sort of your sanity as a developer. But this is actually something that is sort of part of our smart contract.
00:23:15.770 - 00:23:49.558, Speaker C: The thing that actually happens when we run this again, Jason talked about this in the abstract, I'm going to talk about it in the concrete. What we do when this executes is we produce a transaction. It has a proof in it that says we ran the code in this update method with some private arguments. And the result of that were the following instructions that get sent to the chain. In this case, set X to be nine. That's the instruction. And it assumes a precondition that X is three.
00:23:49.558 - 00:24:29.906, Speaker C: So that gets baked into the smart contract. If the transaction is sent when the state is not three, then this will fail. Which is what we want because we only want to update it to its square. Okay, so this is kind of what smart contracts look like. I mean, this is a very simple one, but there's member variables which you can use for state, public state. You can override the deploy method and you can add methods with this at method decorator that correspond to the specific updates that you want to perform to the network, I guess. Cool.
00:24:29.906 - 00:25:14.450, Speaker C: So now to test this, there's, I guess, a lot of things you can do. The thing that we recommend that you do for this hackathon, because it is the most easy to use at the moment is testing locally. Here's an example, what we're doing here. At the top, we're grabbing an instance of this local blockchain. You can kind of think of this like a Sandbox VM, literally. It's like part of Mina that's compiled to JavaScript so it is accurately emulating the real blockchain. And then we send a transaction using account.
00:25:14.450 - 00:25:57.150, Speaker C: One is the one who pays the fees for the transaction. So you have a private key there. And then in there we're only deploying the smart contract in this example and then sending that's, that dot send at the end. And then we can also at the top here, we can send an update, we can update it to nine. And then afterwards we can get account states and then print them out or check them against something else in like Jest. In a Jest test, if you're a web programmer. You'll know what that means? Or you could just put that in another executable for your testing purposes.
00:25:57.150 - 00:26:32.410, Speaker C: Yeah. So I also want to just show Evan touched on this but roll ups. Here's a roll up and it's like ten lines. It's probably like going to be 50 lines if you actually get unwind the dot dot dots, but it's 50 lines. A ZK roll up. This API we have not fully wired in, but I just thought it would be really cool to show. So at Proof system you extend proof to make a custom proof that's not this proof isn't actually on chain.
00:26:32.410 - 00:27:23.530, Speaker C: We create the proof and then send the proof through a smart contract on chain. So we extend something different and then maybe you deposit money into the roll up. You can send transactions between accounts within this roll up environment and then you can merge proofs together. So, yeah, this is pretty cool. The one thing I also want to just touch on this for people who have tried to use recursive zero knowledge proof programming before, it's probably not a large number of people, but if this is one of you, you have to flip between the two different fields every time you recurse. And this is actually really complicated and annoying to write code for. And the pickles recursion execution engine in Mina.
00:27:23.530 - 00:28:30.074, Speaker C: Double flips for you. So all this means is you really only have to think in one field, which is really something that makes your life easier. So that's that. How do you learn more? Well, you can go to these places. So the docs, the discord you should also look for people with these hoodies, most of which are members of either the Mina Foundation or O of One Labs and we can help you understand things. Oh, and the other thing I want to mention, we are in real time getting like we have, we have successfully deployed Zkap transaction like Zkap smart contracts to a live test network and interacted with them in a live network environment in constrained conditions. And we are actively at this second, working on making those constrained conditions less constrained.
00:28:30.074 - 00:28:57.270, Speaker C: So if you are at a point in your hackathon project where you are like, I'm done, I'm tested it's. Great. And I want to hook this up to a live network, then you should look for well, look for people in these hoodies, and we'll point you to the person in the hoodie that you should talk to. And yeah, so that's that we have time for questions.
00:28:57.340 - 00:28:58.120, Speaker B: I think.
00:29:03.930 - 00:30:01.974, Speaker C: It yeah. Do we want to mic the question answerers? I can just talk really loud. I'll repeat your question. Okay. Given the constrained size of the chain, how do you infer the state of any particular context at a given time? Yeah, so the question was given the constrained size of the chain, how do we get the state of anything that we care about? Okay, so there's a lot of nuance and a lot of different answers. So I will answer the question that I think that you're asking, which is and you tell me if I'm answering the wrong question. So this 22 kilobyte number actually on our homepage, there's like a SuperScript and you can click on it and it's a blog post that I contributed to that explains in detail exactly what we mean by these 22 KB.
00:30:01.974 - 00:30:47.994, Speaker C: If you read those details, you'll see there's a proof that's like 1 KB ish and then there's like a bit of metadata and a merkel path to an account that you care about. How do you get the state that you care about? You ask a node that has some state and I just want to highlight the nodes that are participating in consensus and mining blocks. They have the current state of the world. You need that to produce blocks. You do not need that to be like a full node in the security sense, but you need that to produce blocks. So there are a lot of nodes in the network that have the current state of all the accounts. There is no node that's needed for consensus that has ancient archive state, as Jason was saying.
00:30:47.994 - 00:31:49.870, Speaker C: There are some that do because sometimes people want it, but it's not needed for consensus, but it is needed for consensus to produce blocks to have that state. So, sorry, this is a long winded answer, but you just go and ask those nodes for the state in the same way that you go and ask an arbitrary ethereum node for your account and it gives it to you. It's the same thing. Do you think there's any limitations with doing all this proof? Because I've seen this there's a verification key as well. Yes. Also, there's constraints that need to be met for the proof when it comes in as well that goes into it. Do you think if I had like a really big program that I was running, do you think that maybe I might be the question was, are there constraints on how big the program is, given that there's this fixed verification key? And naively, the answer is yes, there is a fixed maximum size that your computation can be per verification key.
00:31:49.870 - 00:32:14.760, Speaker C: And this is true. However, because we have recursion, we can just recurse and loop a bunch of times and do very complex things that don't fit without recursion into one proof. I guess I'm realizing that might not make sense to people, but it is true. So that's the answer. Yeah.
00:32:16.010 - 00:32:26.114, Speaker D: So do you use some Snark team algorithm that doesn't require a setup for each and every new service?
00:32:26.172 - 00:32:45.454, Speaker C: Yes, very good question, and I wish that we had mentioned it in the talk. I'll mention it now. The Mina ZK snark does not have a trusted setup. It is a false god that I don't know what the term is. It is untrue. That snarks imply trusted setups. Some people have this meme.
00:32:45.454 - 00:33:24.190, Speaker C: It's not a real thing. Our Snark does not have a trusted setup, and it's universal. And one of our cryptographers can correct me if I say this wrong, but that means that we can basically change what the circuit is at runtime and change. And in Mina's case, we can recurse arbitrary new circuits into the main Mina circuit. So all this means, like, when you are writing a ZK app, when you're writing a smart contract, you can deploy an arbitrary new circuit and it gets folded into Mina. And there's no trusted setup. There's no setup.
00:33:25.570 - 00:33:27.840, Speaker D: But is there no trust?
00:33:28.210 - 00:33:38.062, Speaker C: There is full trust. Sorry. You trust no one because the cryptography works without trusting a setup.
00:33:38.206 - 00:33:43.726, Speaker D: I mean, you said that your setup is not trust. Did you have, like, a ceremony?
00:33:43.918 - 00:33:47.940, Speaker C: No, Mina did not have a ceremony because Mina's Snark does not require a.
00:33:49.190 - 00:33:51.146, Speaker D: So it is safe.
00:33:51.278 - 00:34:21.182, Speaker C: It is safe. And the cryptography is even safer than I think. Ceremonies aren't that untrustworthy personally, but Mina didn't have any ceremony, and so it's even more safe than if you did. So, yes, it's safe. Good cryptography. I mean, it's newer cryptography, so sometimes that scares people. But we have very smart researchers and research papers and audits and people reviewing stuff.
00:34:21.182 - 00:34:54.086, Speaker C: So I think it's fine. Okay. When you said strongest chain, I guess that relates to some mechanism, like proof of stake. Yes. So actually the recursive zero knowledge proof way that Mina compresses the blockchain is sort of orthogonal to the consensus mechanism and actually an early test version of Mina. We implemented proof of work because it was easier, but we didn't want to release that. So it's proof of stake because we chose that we wanted proof of stake.
00:34:54.086 - 00:35:19.220, Speaker C: And specifically, the consensus mechanism is a variant of Oroboros, which is called Oroboros Samasika. And you can look online and read about it. There's a bunch of talks and papers and things. Oroboros was originally created by the IOHK cardano folks and Mina tweaked some things to make it work in a succinct environment. Yes.
00:35:20.710 - 00:35:23.620, Speaker D: How do I connect an ERC seven to one?
00:35:25.530 - 00:36:10.146, Speaker C: Say that again. How do you connect like, an think? So one thing I'm really excited about is bringing Mina proofs to Ethereum through the bridge as non transferable NFTs. I think that's an awesome cool thing. That framework for building that has not been written. It would be a really good hackathon project. I'm going to contribute to judging on one of the projects, and if someone implements that and it works, I will vote for that project. The answer is you should build that.
00:36:10.146 - 00:36:32.940, Speaker C: I don't know. The ZK bridge isn't deployed yet, right? So you can't actually run it yet on Ethereum. Ethereum. But you can still build the infrastructure. So that right, when the bridge is deployed, we can do that sort of thing. So I hope that sort of answers your question.
00:36:34.030 - 00:36:36.140, Speaker D: Sorry, could you repeat the question?
00:36:36.510 - 00:37:22.380, Speaker C: Sorry, the question was, how do we interact with ERC 721 NFTs in Mina? And I guess with Mina, I answered one half of that, which was how do you output them, and then the other half is how do you input them? And that is also part of a bridge that doesn't yet fully exist. But also, if you build part of that, it would be a good hackathon project. And you can talk to if you feel like you have enough in your brain to understand how to build something like that. One of us in the hoodies can help you understand how to do that as a project.
00:37:23.870 - 00:37:45.540, Speaker D: Another question, do I understand correctly that the bridge basically you could use it to reduce fees from instead of verifying the proof on the ethereum chain, you have to just verify the miracle password. Right. So that's the gas optimization that you could do, right?
00:37:50.230 - 00:37:58.530, Speaker C: Yes. Well, someone is verifying the Mina proof on chain, like whoever is updating the bridge. But yes, once it's already there, it's just a merkle lookup.
00:37:58.610 - 00:37:58.902, Speaker A: Okay.
00:37:58.956 - 00:37:59.270, Speaker C: Right?
00:37:59.340 - 00:38:09.450, Speaker D: Yeah. Are you supposed to update the bridge? Who runs the bridge?
00:38:09.870 - 00:38:23.194, Speaker C: Yeah, there are a lot of entities that could run that post those updates. I bet Evan has. Thoughts on the plan is it'll be.
00:38:23.232 - 00:38:28.574, Speaker B: Decentralized, anyone can be an operator, and if you want to help us test being an operator, then you should also.
00:38:28.612 - 00:39:16.750, Speaker C: Reach out to us. I'll repeat on the microphone the plan is that, well, it's decentralized, anyone can be an operator. And Mina Foundation, as represented by Evan, says that they want I'm part of OVone Labs separate company. They want to help people be operators. If you want to be one of those operators, you should talk to someone in a hoodie and we'll help you learn about that. The question is, how does the fee system work? So, yeah, I think Jason mentioned this, but because all transactions in Mina and actually even before Zkapps, this is how it works. They all correspond to verifying a proof.
00:39:16.750 - 00:40:11.748, Speaker C: They're all the same price. So they're all the same price. I guess there's some nuance where there is a way to build ZK apps such that a single method that you write in Snarky JS actually compiles to several transactions, and then you pay per extra transaction. But it's a fixed gas cost per transaction. And that means you can do some crazy computation which the user will pay for, because when they're using your application, they'll perform that computation, but you don't pay for it with gas. I'm curious if I have, let's say, ten pending transaction and every one of the transaction wants to interact with one smart contract, does it mean just one transaction will go through and the nine are invalid because the one will change? Good question. Yeah.
00:40:11.748 - 00:40:53.270, Speaker C: If you build your state machine in such a way, like this example where there's like a sequential ordering of updates that needs to happen. Then there's a race and whoever gets their first wins and the rest are invalid. But you can design your state machine, and there are a lot of ways to do this in Zkapps and conceptually. You can design your state machine such that updates can be reordered, and that is what you should do if you want that property. But it means that you have to think a little bit harder about how you design your smart contract. Please.
00:40:55.640 - 00:41:35.570, Speaker A: So that's a really great question because with the off chain execution model and off chain storage, which is in progress, as far as making it elegant, there are a couple of different approaches to that. Also, the preconditions we mentioned, the network preconditions and account preconditions, I believe that we can work on that to create very elegant preconditions that might be tailored to a specific app that could really help address that. And then when we have rollouts as well, and actually one of our Ckap builders in our recent program has started a roll up that would have another opportunity to provide sequencing as well for a particular app and use case.
00:41:41.580 - 00:42:37.098, Speaker C: Cool. Any more questions? Oh, go ahead. I think we need to store more complex data on off chain because this is not a primitive type. What if we lost off chain data for everything? Yeah, so the question was, sometimes we need to store things off chain because they might be more complex. I should just mention, because we didn't mention this in the current testnet, I guess this isn't set in stone. We're thinking that each account has eight field elements worth of storage on chain, which is a very small so a lot of times you'll have data that isn't on chain. And the question was, what happens if that data gets lost? And the answer is your application won't work, but Mina will still up.
00:42:37.098 - 00:43:35.306, Speaker C: It's up to you as an application developer, I guess. Sorry, there's a couple answers to this. The current answer is it's up to you as an application developer to solve this problem in the way that you think is important for your application. So the easiest thing to do is just have a file that has the state in it and you can think of this as like a single sequencer. And this is from my understanding how basically all the L two S work right now that people have a lot of capital on and people seem to be okay with that. You can do something that's more safe and decentralized by having a tendermint chain that keeps track of the state, or you can have the merkel tree in, I don't know, some flash drive that you make a copy of and hand to your friend. So you can do anything for the state as a Snarky.
00:43:35.306 - 00:44:20.858, Speaker C: JS toolkit, developer, person, architect, whatever, I'm called myself and Jason and a bunch of other people. We will be working on ways to solve this problem in sort of more cookie cutter ways, so it's easier for application developers to make that decision and they can just kind of take something off the shelf. But right now, it's a little bit more manual. Yeah, hopefully that makes sense. Cool. I think we're out of time, actually, so thank you. Remember anyone wearing these colored hoodies or these links, you can come and ask other questions or whatever.
00:44:20.858 - 00:44:33.820, Speaker C: And please build stuff. There's prizes. I think someone's going to announce that, so yeah. Thank you.
00:44:37.470 - 00:44:38.730, Speaker A: What's our prize?
00:44:40.350 - 00:44:53.870, Speaker C: We have prizes. Okay, you it's.
