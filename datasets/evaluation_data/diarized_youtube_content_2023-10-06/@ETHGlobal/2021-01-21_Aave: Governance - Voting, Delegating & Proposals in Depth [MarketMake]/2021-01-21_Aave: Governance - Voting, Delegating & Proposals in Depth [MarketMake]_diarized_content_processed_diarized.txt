00:00:12.230 - 00:00:16.380, Speaker A: Everybody. Good morning. Thank you for running this for us.
00:00:18.110 - 00:00:38.110, Speaker B: Hi. Yes, great. Thanks. Yeah. So hello and welcome everyone to the Ave workshop governance, voting, delegating and proposals in depth. Joining us today is O'Ne Nesto, who will be taking us through this session. One quick reminder just to complete your check in ones in your cohort.
00:00:38.110 - 00:00:48.040, Speaker B: If you are struggling at all, feel free to reach out to me or anyone else on the East Global team. And with that, I will pass it over to Ernesto to introduce himself and get the session started.
00:00:50.970 - 00:02:03.354, Speaker A: Okay? Thanks Emily. Hello everybody. Like Emily said, I'm Ernesto. I'm like an engineer, a developer in Abbe, working in abbey, mainly developing the avalanche protocol, but also a bit of everything within the and today, the objective of this kind of presentation workshop is to give a bit of an introduction of what is the app governance, how does it work? A bit of thoughts about also my own thoughts about governance systems. And if we have some time, at the end I will try to do some really small coding session, live coding of those that usually go wrong, to showcase a bit of what can be done with the governance. And at the end I think we will have also times for some questions. I prefer to have this kind of presentation workshops really interactive.
00:02:03.354 - 00:02:43.410, Speaker A: So if you need to do any question in the middle, feel free to stop me and we can solve the doubts. Let me share the screen. Now I have some small presentation. Okay. Am I showing the PPT?
00:02:44.630 - 00:02:47.338, Speaker B: Yeah, you're showing the Ave introduction to governance.
00:02:47.374 - 00:03:26.020, Speaker A: Okay, perfect. Yeah. So, yeah, I already said a bit about the introduction, but yeah, first, I'm going to start with some quick thoughts about governance. A bit of explanation of how the ave governance works in general, and with including the features. The components, and especially at the end for builders and hackers in general, how they can integrate the governance or using it in a different way. About Me I think we can skip this. Ready, explain.
00:03:26.020 - 00:04:51.660, Speaker A: Core developer in Abe. I participated actively in the developing of the governance itself and all the delegation of the tokens and so on that is associated to the governance. So yeah, I have decent knowledge of how does it work? Well, first question of all is that for a lot of people that may be entering in this hackathon, attracted by DeFi, decentralized finance, and mainly about the economic part of Fabi is why a governance is needed, why we need this system of coordination, social coordination, voting, create proposals. It looks like a bit not so related with decentralized finance. Well, there are multiple reasons. I will go now through them. But first of all, I want to show another slide that I did for a different kind of presentation that was more related of the economic part, the defy part, and not the governance of Abbey to see that is not like they say the panacea, the governance, it can be used only for certain things.
00:04:51.660 - 00:06:04.146, Speaker A: It's not the solution for everything. The governance first of all, the first reason is that well, social coordination and action via a voting system is good. It kind of represents the spirit of decentralized finance, of DeFi. But a lot of times people tend to put a governance system everywhere and it's not always the solution, it depends on the use case usually. But this is a bit biased point of view is that I believe that in a lot of times that if you can solve a problem that is algorithmically so with for example just logic on the smart contracts it tends to be a bit better or at least it generates a bit less complications especially if you are like creating a new project. Bootstrapping a new project. Sometimes if the project doesn't need a certain type of coordination it's better to avoid then a good governance is decently complex system.
00:06:04.146 - 00:07:36.720, Speaker A: This going a bit against what I'm going to say later, but yeah, if you have another system on top of your other system, there is another point of failure at that point and it looks when you have financial applications and complex social dependencies, I refer to processes of voting processing, also meet proposals and so on. It can be a bit dangerous sometimes because this complexity can lead to unexpected outcomes. This is some point of view about governance that is not the solution for everything. But well, sometimes it is dangerous, but we are here to talk about governance, so let's forget about this thing and it has good things. So it's a good solution a lot of times. Why it's a good solution? Well, first of all, DeFi is like the main principles are like innovation and disruption and it's pretty natural that this innovation needs to include innovation at all layers, not only on the technical layer, not only on the economical layer, but also on the social coordination layer. So governance is just an onchain, governance is just another tool to apply this innovation on.
00:07:36.720 - 00:09:30.370, Speaker A: Then sometimes when you try to solve all the problems, let's say algorithmically via software and with no human interacting with the system, it leads to really big complexity. You can see basically with blockchain in general, that what it looks that it should be the best way, it always boils down to groups of influencers and so on and so on. So it's quite difficult to make a system that is completely automatic and based on software rules. It's not so good to have a system built on top of another and both being complex, but it's not necessarily like a requirement that the governance is a really complex system. It's possible to write governance that are simple to understand and that they have a simple mechanism of work and that is part of what I hope it is the upper governance and well, partially it's not true that financial application plus the complex social independencies or interactions are not always dangerous. Sometimes the outcome is like a really positive for society, for innovation and so on. I hope in our case is that the best example of why a governance system is so necessary is because especially on DeFi is because we have a lot of different fields already within DeFi and all of them are interconnected.
00:09:30.370 - 00:11:32.398, Speaker A: So when you have completely automatic rules like based on smart contracts and no human interaction between them, it leads to really good characteristics of doing experiments. But at certain part is pretty clear at certain part it's pretty clear that you need a bit of human interaction and human intervention on the systems. And when you have a governance that is also built on top of, for example, tokens and those tokens have certain utilities, it creates, let's say, an ecosystem of incentives that makes that the votings, for example, are meaningful always. And the combination of all these protocols, each one having their own governance, it creates a good equilibrium of, let's say, human machine between them and protects the ecosystem of crazy failures and no way of fixing them. So I talk a bit about the governance, but why they have a governance in particular, which are the characteristics, which are the particular features compared with some other systems that are out there? About the features. Well, first of all, I suppose people here have some entering contact a bit with other kinds of governance. And one common limitation between all them and sometimes it's not a limitation, it's simply that the design was that way, is that the voting is done and the submission of proposals are done by one token only.
00:11:32.398 - 00:12:27.706, Speaker A: So participants in the governance have token X. If you have more than, let's say, 5% of token X, you are able to submit proposals. If you want to vote, you can use your balance or delegation on that token to vote. But this sometimes can be quite limiting because for example, if you want to involve multiple communities at the same time, usually each community is represented by one token. So you cannot do it with one governance. You will need to have two governances, then maybe do another in the middle and combine those somehow. So in our case it was like that even more for technical reasons, because we have the abbe token, that is the main token of the abbey governance.
00:12:27.706 - 00:13:04.486, Speaker A: And then we have some other flavors of the abbe token. That is for example, the stake abe. That is when people deposit their abbey token on the safety model, that is kind of insurance for the protocol. So when they deposit their abbey there, they receive the stake abbey representing that. But they should be able to vote also with the state cave, even if it's not abbey pure abbey anymore. So for that, our governance has what is called the voting strategy. That basically allows us to put more complex rules on the governance.
00:13:04.486 - 00:13:45.110, Speaker A: In our case, I will show you later. But it's as simple as it accepts as voting power and proposition power. It accepts both Abbey and the stake. Abbey token. So if you have both on your wallet you will have the aggregated voting power or proposition power. Then like I was talking right now about the voting and proposition power. This is an important distinction with other governors because usually in other governors there is only one token and if you have balance or delegation of that token, you are able to submit proposals and vote both at the same time.
00:13:45.110 - 00:14:57.390, Speaker A: In our case we thought that is not completely, let's say, fair of doing it that way because the entities behind the creation of proposals and the entities behind voting usually are different. If you make a comparison with the real world, it will be like lawmakers are the entities that propose that create proposals and then you have, let's say, politicians that are the voters on the governance system. So we try to keep that same analogy here. So the token, for example, Dabbit token has proposition power in one side and voting power in another. So to interact with the governance you need certain amount of proposition power to create a proposal. But then to vote you need voting power and you can delegate one or another to different entities. Then something that we also have, but this is already a bit more common with other systems is the off chain voting.
00:14:57.390 - 00:16:22.934, Speaker A: Especially right now that the gas cost of using ethereum is quite high. It's really good that you can actually vote by signing a message and then potentially a relayer can submit your vote to the governance contract and vote there. It can be used for other cases, like for example if you have a cold wallet and a hot wallet and like the cold wallet, you have it isolated so you just sign the messages there and then somehow you just transfer the sign already message to your hot wallet that actually submits to the blockchain the vote. Then we also notice that sometimes it's not optimal to have all the permissions on the same governance contract on multiple systems. For example, our governance has control over the Abbotoken and the Stake habit tokens, but also has control on the lending protocol and those entities separately are not so similar. And the updates on one or the other should have different requirements. For example in terms of time or in terms of percentage of the token needed to pass a proposal.
00:16:22.934 - 00:17:23.814, Speaker A: So what we did is to split the execution of the proposals in the governance in what we call executors. So in our case we have two executors, I will show you after and one has more relaxed conditions of how the proposal needs to pass to get executed and the other is more strict in the conditions. And this is quite useful basically. And then we also have different mechanics of execution. And this is a bit more technical, I can show a bit after, but one of the ways is you can create a proposal in pure solidity, like writing a smart contract, which if you know solidity is really handy. And the other way, it will be that you don't need to actually know solidity. You can just identify the steps that you need to execute on the proposal, encode those steps somehow and submit it to both.
00:17:23.814 - 00:18:56.534, Speaker A: So yeah, this is also quite interesting and well, in general our design, what was pursuing was to be simple still as other governance from which we took inspiration but add a bit more customization, especially for our use case, but thinking on other projects that could use the same governance framework to create their own governance. Here we have a diagram that is basically how it works. The Abbey governance and more or less what I already explained, we have this governance contract in the middle, that is the core is where all the interactions of voting, submitting proposals and executing proposals happen. So it's the core smart contract. Then the governance strategy is what I mentioned, where we encode the rules of voting and proposing in our case that the ave and the stake ave are taking into account the balance of abe, stake ave or the delegation. And what else? Yeah, we have the executors that also mentioned the short time lock. The executors are also timelock in our case because we want certain delay between when a proposal pass and when it actually gets executed.
00:18:56.534 - 00:19:56.510, Speaker A: But there is no limitation to put any other kind of contract. It should be a time locked contract, but it could be reduced, for example the time or increase the time. There is no limitation in that sense. But yeah, we have the short time lock that is more relaxed and then the long timelock that is a bit more strict and affects mainly the upgradability of the avid token and the staked avenue that are quite critical parts of the system. Also this governance can be, let's say out updated in the sense that the governance strategy could change in the future or even the time the executors could change. And for that a proposal needs to be submitted that goes through the long time lock and changes something on the governance itself that is a bit more or less how the components are. Then, yeah, we have the voters and the proposers that are two separate entities.
00:19:56.510 - 00:21:39.338, Speaker A: And then just like additional protection, we have an entity that is called the Guardian, that is a multi SIG composed by well known members of the ecosystem. And basically the only power that it has is that if some malicious proposal will be submitted and we like clearly malicious proposal, this guardian can cancel the proposal at any point, which, especially during the early times of a system like this one, like the other, governance is quite useful. Okay, next will be how to use the above governance. Because the theory is nice, but I am building something, what do I do with the other governance? So, there are three main ways of using it. One will be like if you are building a new project, for example, and you want to have certain governance on top, just fork the repo that is open source of the Abbey governance and plug it into your project. For example, if you have already a token that is compatible with the governance and some other platform, you could control it and be forking the governance and using it. Then another mode will be just building actually an application, which goal is to interact directly with the other governance.
00:21:39.338 - 00:23:13.230, Speaker A: This can be multiple things, but mainly what is called an integration of the governance could be with the Tokens, even in terms of delegation or submission of proposals or voting or whatever. And then the third that is not directly with the technical part of the system, but a bit is that anybody can create proposals, anybody can get proposition power being this one, like getting other Tokens or asking for delegation for somebody else to delegate a proposition or voting power. And of course, like voting itself on the governance or even participating in the discussions in the forum. For the first option, just to put some simple steps, well, it's about going to the repo on the GitHub, forking it and downloading in local, then creating a governance strategy adapted to the Token. If it's like a simple governance that only needs one Token, I can show it after. But it will be just deploy this contract that reads the voting and proposition power from the balances of the Token. Then deploy the Abbey governance itself, the contract that is the core.
00:23:13.230 - 00:24:14.574, Speaker A: It has some configuration, but it's nothing really complex. And then deploy the executors that are the entities, as I say, time locked that execute. Actually proposals can be one at the beginning usually is enough, but if further requirements are needed, it can be whatever. Because the 0.5 is that transfer the ownership to one of those executors. So you can have one executor that is the one that owns the governance and that has the biggest powers, but then you can create others for secondary executions. MMM option two should be but is the participate in the governance itself and I think this is the most important that is going to the forum.
00:24:14.574 - 00:25:49.070, Speaker A: There are a lot of discussions I can open afterwards and just participate on those because it's completely open and that is the objective of being like an open ecosystem. Second step is that if you feel that you have some strong opinion about certain proposal or about something that you want to propose, ask the community of the other holders to give delegation of proposition and voting power depending if you want to create a proposal or if you just want to vote on behalf of other guys. If you go for the first route of creation of create the proposal, we have some repos that also help with that and documentation that give resources or how a proposal needs to be written. It's really simple, there are good examples that makes things easier. And of course, if you have a strong opinion on how the AV ecosystem should progress, I encourage to just ask for both in delegation and just vote on the proposals that appear on the platform. I will show some of them now. But in terms of is on the GitHub, mainly related with this is the governance repo and the abbe token.
00:25:49.070 - 00:26:25.000, Speaker A: Then we have the discord, the documentation that is common with the protocol, our medium twitter and then probably most important one is the governance forum and that's it for the presentation part. Now I think that I will show a bit more of the code. But first of all, maybe if somebody has some questions maybe about the general stuff we can answer.
00:26:27.710 - 00:26:35.758, Speaker B: Yeah, there's a couple of questions that have been dropped into the chat. I'm not sure if you can open it or if you'd like me to read them out.
00:26:35.844 - 00:27:49.492, Speaker A: Yeah. No, I can open. Okay, well, one of them is what are the most promising use case of credit delegation? This is not so related with governance. I can give my opinion. But credit delegation if somebody doesn't know is more on the lending protocol. And it's like when somebody has collateral and gives borrowing power to another person that doesn't have collateral. So promising use cases, the main use case is to do off chain agreements, legal agreements for example, with a person that doesn't have like vital asset as collateral in abe and that person could borrow using your collateral that you have something deposited in that both in power and proposal power delegation.
00:27:49.492 - 00:29:07.228, Speaker A: Okay, dice different the most promising use cases I'm not sure if I understand about the most promising use cases. For me the most important part is like what I explained that the separation between both because conceptually it's not the same profile of entity. Let's say that creates a proposal that has the knowledge to propose a change in a system compared with the ones that just vote like giving the opinion. I think that is the key aspect of the proposition power and voting power. And for example, going a bit more technical is also interesting that you could create a smart contract that receives the proposition power and I think I can do something a bit after it receives the proposition power. But it already has encoded inside it. The proposal is going to submit afterwards.
00:29:07.228 - 00:30:01.380, Speaker A: So the contract will receive. People will start giving proposition power to that contract knowing what exactly is going to be submitted without any trust of a person that is saying I'm going to submit this proposal. But at the end when I get the proposition power, I just change my mind. But no, it will be with the contract and the contract after certain blocks or whatever. It could submit this proposal to the governance but will not vote. Like then the votes will be of every individual or of people that has the voting power. I think that answers and then is granular conditions on execution of proposals similar to the implicit majority and explicit majority conditions for execution that Cardano governors voting specifies.
00:30:01.380 - 00:30:24.700, Speaker A: How is the governor chosen elected? I'm not fully sure if it's the same. I don't think it's the same because probably in Cardano is about consensus. I don't know if Bharat Malapur can comment on that. Emily?
00:30:26.400 - 00:30:34.620, Speaker B: Yeah. Anyone's? Welcome to unmute themselves and ask questions. Or if you don't feel comfortable, you can just elaborate in the chat.
00:30:34.960 - 00:31:38.310, Speaker A: Yeah, if you can explain a bit more about the Cardano system. For what I understand, governance in Cardano is more related with the operation of the network itself, not at the application layer. Like the other governance, we don't deal with the consensus of ethereum. In the case of ethereum, it's different already because it's proof of work. But I don't think it's exactly the same with the granular conditions on execution of proposals. What I mean is that imagine that you want to have control over uniswap and over Sushi swap, and it happens that you don't want to have proposals. You want to have the minimal time of proposals on uniswap between ten days.
00:31:38.310 - 00:32:28.310, Speaker A: But to do anything on switches of you want 20 days. If you only have one executor, you are only able to say you put the ten or you put 20. You cannot program both, or at least it's quite difficult. In this case, what you could do is you create two executors and each one has encoded 110 days the other 20 days. So when you want to do any change on uniswap, you just submit a proposal that interacts with the first executor. If you want to interact with SushiSwap with the second executor, that is like a raw example of how it works. Okay, next one user must call Abbey tokens to vote.
00:32:28.310 - 00:33:31.034, Speaker A: Not necessarily. That is the concept of delegation. If you have tokens, you can vote, but you can also delegate your voting power to a different address, and that address will be able to vote on your behalf at any point. You can just remove this delegation from that person and assign it to somebody else, or you can just vote by yourself. Something that is important to understand is that if I delegate my tokens to another person and this person votes in a current proposal, proposal that you submitted right now, I cannot affect on that vote. That vote was done by this person, and I cannot do any kind of bet on that vote or anything. The governance layer for proposals are related to bicents in Ghana.
00:33:31.034 - 00:34:05.942, Speaker A: For consensus, explicit means 51%. Implicit means 51. Okay. I suppose it's more related with the logic of quorum that we have. We don't have that concept of explicit like 51%. In our case, we have what is called the minimum quorum. That is a percentage of the supply, combined supply of all the voting tokens that needs to be passed for a proposal to be executed.
00:34:05.942 - 00:34:50.898, Speaker A: And we also have another concept that is called the bow differential. That is, depending on the executor, apart from passing the quorum, there needs to be a certain difference between for and against votes for the proposal to be valid. So imagine if the quorum is 10%, for sure more than 10% for votes need to be submitted. But if the differential is 2%, the maximum of against votes allowed for the proposal. If it's eleven, for example, the four votes, the maximum of against will be 9%. If it's 9.5%, you already need 11.5.
00:34:50.898 - 00:36:07.800, Speaker A: That is an important concept. Is it possible to adapt to a YearC 1114 token in other governance right now? I don't know from the top of my head which one is the year C 1114. I can do a quick search. One, one, four C, because this is from YouTube. If they could link to the RC 1114, I suppose that it should not be a problem. It's only a matter of having what is needed in the token is basically to have the characteristic of voting and proposition power. That what they are, is like snapshots.
00:36:07.800 - 00:37:27.326, Speaker A: Every time there is a transfer, this proposition and voting power are record in a new snapshot. So it should be possible, but I'm not fully sure how is the standard transferred to another person and the other person able to vote to even without any deposit with Ave, does the power delegation able to earn a fee or commission model? Yeah, basically, kind of if I understand well that when you give delegation you are not transferring your Abbott tokens to the other person. You are just saying that this person can use your tokens for a certain activity that is voting or proposing. So yeah, that is true. And if there is any fee, it's an interesting project to do. Right now there is no fee like you delegate to a person and nothing else. But potentially you can build a system of smart contracts that manages delegations and that incorporates some kind of fee on the process.
00:37:27.326 - 00:39:14.784, Speaker A: Why not? I think it's a good idea. Can we use seven to one in these cases to represent people? I'm not fully sure if I understand that. Seven to one, I suppose is CRC seven to one, but I don't really understand why you need DRC seven to one to represent people. Because end of the day you have tokens, you can vote and your representation is your wallet itself. So not sure if it's so useful. About L two solution on Abbey not an official one yet, but we are trying almost all of them that are in the market and we are still like experimenting, which are going to be the more suitable for the protocol. And how does prevent anyone or power delegation collude? If you if you refer to if you refer to giving power to some person and then that person doing something that goes completely against your will, if that is the point with the first proposal, if there is a proposal while he has the delegation power, there is no way of prevention because the concept is similar to an approval of ERC 20 tokens.
00:39:14.784 - 00:40:03.604, Speaker A: If you approve somebody to do something with the case of the approval is actually to take your tokens, but in the other is to vote on your behalf. The most natural thing is that you need to accept the result if they vote. This is a bit more conceptual, but if you are given permissions, you should know that they will be able to do something with that permission. If not, the permission is a bit nonsense if you can revert after seeing what they do. But this is a bit more like deep question on governance topics. But yeah, the answer is no. At least once you gave delegation, you need to accept the outcome of what he does.
00:40:03.604 - 00:40:47.810, Speaker A: Of course, after he votes or whenever actually the delegator wants, he can remove delegation from that person. So the typical case is like I give you my delegation power, but I see that after two or three votes or you are not participating or you are doing some kind of artificial voting or going just against the majority or something like that. And at that point I just cancel the delegation from you and I choose another person that has better criteria from my perspective. For example. Yeah, seems there are no more questions.
00:40:50.820 - 00:40:53.696, Speaker B: You can go on with your coding.
00:40:53.888 - 00:41:53.488, Speaker A: Okay. And yeah, what I'm going to do now, because I think that is decently explained already how it works. The Governance is showing a bit specific in the code, which are the parts that I described to make it more real and not so theoretical. So for that I will need to share the screen again. Okay, I suppose this is yeah, well, I'm opening here, but let's open actually on GitHub. That way we will give a bit better feeling that it's close. It's basically the same, but this is one of the resources I put.
00:41:53.488 - 00:42:48.896, Speaker A: There is the Governance version, two rep in the organization on GitHub. And here is all the code of the Governance, same diagram I used to describe the system. Here there is a bit of how the configuration of our governance is, but it's a good example if you want to deploy a new governance, for example. So it's the configuration of the governance, the executors and the strategy. You see it's like based on Abbey plus stake Abbey for both voting. And proposition and then some setup instructions here, but going a bit to the code, you go to the contracts folder governance and here we have all the pieces that I described. Basically this is the core the governance.
00:42:48.896 - 00:43:41.590, Speaker A: Then we have the executor, executor with timelock and the proposal validator that they are the three parts of an executor. Basically because an executor is a timelock, but at the same time it also validates the proposal. So for example, if you try to submit to the governance a proposal which executor needs 20 days of voting, but you are submitting the proposal with ten days, the executor will need to do the validation. So that is the validation part. And then the last part is the governance strategy. Governance strategy is what defines the voting and proposition power. We can start for example, solid smart contract like you see, it's quite simple, 100 lines with comments and everything.
00:43:41.590 - 00:44:48.872, Speaker A: And the only thing it does is that in this case, for example, there is no particular requirement of what you do inside it's, only that it needs to respect the interface. But what we do in this case is that we just store immutables the same as constants the addresses of app and the state gabe and then for example, if we want these two functions are the ones used by the governance to get the proposition power. This function will be used when submitting a proposal to validate if the person that is submitting has enough power and then the get voting power that is, every time you vote it will use this function. So if you see is really simple like we call in both, we call the get power by type. In one we use proposition, in the other we use voting. And this is this function. And this function it just calls the get power at block power type is proposition overboating as you say.
00:44:48.872 - 00:45:26.624, Speaker A: We call on the abbey token plus the power at block of a staked abbey. And basically this way we have like degradation of both powers. Really simple. And with this pattern you could use whatever token you want. Imagine if you want to just use one token, not two. It's simple, just put the address here instead of abid you put token x address and then it's even simpler because you don't need to do this. You can do directly on get proposition power or get voting power called the token get power at block.
00:45:26.624 - 00:46:21.300, Speaker A: For example, if it's exactly the same token, even if you have a different token that has different name for the functions for example, or a different way of calculating both the voting and proposition power. Let's say that for example, it's constant and doesn't depend on the balance you have or whatever. Having the strategy allows you to abstract to that. So you don't depend on how the token is actually you don't depend even on having a token. You could have a system where in this voting strategy, you have like five addresses, like kind of a multisig, and you give a balance of one for each of those addresses using these functions, but there is no talk. And it will be perfectly valid because then the governance will just call this strategy and if there is a return of certain value, it will use it. That is the power of this abstraction.
00:46:21.300 - 00:47:24.848, Speaker A: Then I can show you the executor for example and it the executor like I say, is like the composition of two parts. One is the timelock and the other is the validation part. So this executor is just like the inheritance between those two passing the parameters. So not much to comment about it. But then for example, if we go to the part of the validation we have multiple functions. Well, first we have some configurations, that is for example the proposition threshold that this is like the quorum that I was talking about. We have the voting duration, that is the one that is imposed as minimum from this executor.
00:47:24.848 - 00:48:03.228, Speaker A: The differential is what I explained of the 9.5 and 11.5 if you remember. And well then we have this just safe words like we pass this configuration creation and then this has functions that will be the ones called by the governance. So for example, validate creator of the proposal that is basically checking if the proposition power is enough for this, it will use the strategy that I commented before. We can validate also if the proposal can be canceled for the cancellation of the proposal. Basically there is some extra condition.
00:48:03.228 - 00:49:19.732, Speaker A: Doesn't make too much sense that I go in detail into it. But it's basically if for example, the proposer removed the tokens from his wallet during the lifetime of the proposal and that way it will make eligible to cancellation the vote and then yeah, we have other helpers like the proposition power enough that I described that calls the strategy. We have the get minimum proposition power needed if you just want to query how much you will need. So for example, if you are building a system that requests proposition power to submit a proposal, you should use this function like expose it somehow and see the difference between what I have and what I should. Then if the proposal passed, there are multiple help permittees in this validator if the quorum is valid. For example, also like you see it's 200 lines. It's quite simple the contract, the executor with the timelock is another part is just a timelock.
00:49:19.732 - 00:51:10.892, Speaker A: I will not talk too much on this one because it's just a timelock is basically inspired from other projects. The only difference is that what I mentioned that there are different mechanisms of execution. So mainly this field like for example when you queue a transaction to execute you can pass this bool that is with delegate call this quite more technical. But basically what it means is that you can execute the proposal in the context of this time lock or you can just call other contracts to execute the proposal for example, all the proposals that the abbey governance that were executing in the abbey governance were done with delegate call. I can for example show one example of this this is the application, this is one proposal so for example, this one, this is what is called the payload. The payload is like the code that is going to be executed with the proposal and if we open it make it a bit bigger for example, this proposal was to increase the emission of Abbotoken for the safety model so to make higher the rewards and this basically only needs to have an execute function. And then inside the execute function, like the code with everything that is done.
00:51:10.892 - 00:51:55.690, Speaker A: So in this case, for example, there is an upgrade. Of the stake token itself of the reserve that is holding the Abbey token then there is an approval for the new emission to be able to transfer more tokens to the safety module and then we do this configure assets on the stake token that is basically to update emission. But the main point here is that if you want to do a proposal, it's basically the same always it's about writing a smart contract. Like this one putting your logic inside an execute function. You can pass parameters or not pass parameters. That is completely open and nothing else. So really simple.
00:51:55.690 - 00:52:18.720, Speaker A: Yeah. That is what relates to the executors. And then on the well, this is the governance. Of course, the governance is a bit longer, but not terribly long. Contract. I think it's like 400 lines or something with all the comments. So yeah, 500 lines.
00:52:18.720 - 00:53:00.572, Speaker A: And basically here it defines all the logic, both the creation, the voting, the cancellation, the queuing of proposals, everything. So yeah, create proposal, cancel proposal. For example, I don't know, like you have here the create it does some validations, it checks, for example, that the executor that is passed is correct. That is whitelisted by the governance. It needs to be whitelisted. And then, if you see it calls the executor the validator part that I explained, and it does. A validate creator of proposal calls this function.
00:53:00.572 - 00:53:30.890, Speaker A: That will return if the person that is submitting the proposal has a proposition power or not, basically. And after that it creates the proposal itself. Like assigning to all the fields the parameters sent. This includes the payload. This includes the IPFS hash. That is description of the proposal. It includes the executor, of course, and everything.
00:53:30.890 - 00:53:56.960, Speaker A: Yeah, that's it. About the governance. What I explained that how to deploy it. For example, if we go here to the tasks. This repo is configured for Harahat. But if we go here actually, I think it's here. Migrations.
00:53:56.960 - 00:54:56.500, Speaker A: Basically, this script is the whole flow of deploying governance with a strategy, with executor, with everything. So, you see, it's quite simple. What we are doing, I can explain a bit better if somebody wants to try, then is that we deploy two mock tokens, you see? Deploy Mocked abbey deploy Mocked staked avid. Then we deploy the strategy that uses as tokens the two that we just deployed, we deploy the governance. Afterwards we use the same strategy that we deployed. And then as Guardian we just put an admin that is just a random wallet in this case and we just put a voting delay. The voting delay is how much time since you submit a proposal until the proposal is open to vote.
00:54:56.500 - 00:55:42.548, Speaker A: So it's simple. For example, in our governance it's zero blocks, but it could be like five blocks or ten blocks if you want a proposal to start a bit after, whatever. And then we just deploy the executor. And once we deploy the executor, we just change the ownership of the governance to the executor. Because that way if the governance wants to change something on itself needs to use the executor via a proposal to then do the change. That isn't like the circular dependency that is in the system. I think that's all.
00:55:42.548 - 00:56:40.910, Speaker A: I don't know if there is any other question. If not it if not, maybe there is some question. Okay, I think it okay. This is just an answer. Yeah, for the point of if I understood your statement of barat is exactly that you can build a smart contract that executes exactly what is programmed. In that case, I can do something quick. I think we have time, Emily, to make ten minutes or something.
00:56:42.080 - 00:56:49.970, Speaker B: Yeah, you can go ahead. And if anybody is wanting to stay on the call for just a little bit longer, they're more than welcome.
00:56:50.340 - 00:57:33.052, Speaker A: Yeah, I can do just mainly because there was a question about doing this. Well, basically the thing is doing like what is calling other system, like an autonomous proposal. So you submit code there and the code is already on chain and the Creator for example, just asks Proposition power to this content. And I think like a real basic contract can be done. Now let me share my screen. Okay. I hope you can see so yeah, I have here on Remix let's do something quick.
00:57:33.052 - 00:58:09.370, Speaker A: Let's call it autonomous proposal. So what do we need? We can do something really simple. We can have a function that is submit proposal that basically will submit the proposal that we will store in advance on this contract once it has proposition power. Of course, this turn what we'll need to do, we'll need to.
00:58:11.120 - 00:58:14.030, Speaker B: Would you mind zooming your screen in a little bit.
00:58:16.720 - 00:58:18.124, Speaker A: Better this way?
00:58:18.322 - 00:58:18.876, Speaker B: Great.
00:58:18.978 - 00:59:16.800, Speaker A: Yeah. Okay. So here we will call the Ave Governance to create a proposal. But we will need to have the data of the payload so we can do that in the constructor. For example constructor we will need a field to storage field to store the proposal content this is interesting let me check how we can store it this is the create function of the governance so basically what we'll need is that our contract to call this function. So we will need all these fields. All these fields.
00:59:16.800 - 01:00:00.480, Speaker A: But what do we do with these fields? Better is to create a struct. For example, let's say proposal date. So we can take these fields, we put it here. I will need to change a bit the format, I think. Yeah, need to change the format. I will not execute this proposal, of course, because it's a bit more not so fast. But what else we need? We need to import this interface, as you see, because I need to remove the memories.
01:00:00.480 - 01:00:36.718, Speaker A: We need to import this thing, but this will not be used. So what we can do like any function of this interface is just a requirement on compilation. So what I will do is just create an interface but I will not declare anything. It will be an empty interface. It's just for the compiler to not complain. You can see I'm compiling now and it's working. We will store in this country in the autonomous proposal then a field that is of this type.
01:00:36.718 - 01:01:33.126, Speaker A: So we call it Proposal Date public to have a function and then we do like Proposal Date. Okay. So the idea is that when the creator creates this contract, it will pass already in the constructor the proposal date. So after that, everybody will be able to call this public method to get the data of the proposal in advance before it was submitted to the governance. And in that case, it's like giving proposition power to this concept. So for that, we just proposal data and the constructor we put in memory of call data, memories, proposal date. And then here, proposal date.
01:01:33.126 - 01:02:47.762, Speaker A: That is the state variable. We make it equal to proposal date. At this point after construction we already have the proposal data here it can be queried with the public getter and what else do we need? Well, basically we can do something even more interesting that we can say okay, this proposal will be valid if it is before block X if it reached enough proposition power before block X if the block passed, it doesn't matter if you reach proposition power, this proposal is expired. To make things a bit more interesting so we can have it here. We take some block this is not so working theme, but to make it like the constant fastener so we can put into 56 public and we can say that it's like limit, a constant and can put limit block. We put this limit block, but I don't know, we change a bit more. Like put one k more blocks, 1000 more blocks.
01:02:47.762 - 01:03:40.182, Speaker A: So with this we can, for example, put here the condition the required that the block number when the submit proposal is called is less or equal. Let's say less than the limit block. And this here is like too late. This can be called by anybody. It doesn't matter because the proposal is already encoded here. If not, what we will do is we need another variable for the gap governance. Okay, let me go here, as we will need to call this function.
01:03:40.182 - 01:04:11.160, Speaker A: We need to introduce an interface that represents this. Yeah, we can just to make it quick, we take this function. This is the only one that we are going to call. We go here and we do phase that is E abbe governance. It represents just the construct of the abbey governance, but only including the create function. That is the point. So we have this interface.
01:04:11.160 - 01:04:44.700, Speaker A: Let me move this. I hate when it's not. And what we do here is like okay, we create another variable, a constant. We can have a constant that is E ave governance type public constant and will be the address. Basically for that we can go. I think I have it around here, probably here. Yeah, in the documentation.
01:04:44.700 - 01:06:28.808, Speaker A: I can go, I take the address of the other governance and here I will need to do the cast for the type and put it here. So here we have the other governance. What do we need to do now? The only thing left is here we take our variable, that is the governance and we call the create function, which with which parameters we have them here already in the proposal date. In this case, okay, this is a bit more painful, but we can do proposal data execute, proposal data value, this signature and that's it. Proposal data IPFS. And that's basically what we have right now is that a contract where on construction we pass the proposal that needs to be submitted in the future. And then we require and we also have hard coded it could be passed also in constructor.
01:06:28.808 - 01:07:13.392, Speaker A: This is not a big deal. It could be, for example, that I pass here that three days in blocks and I put them here, or if I don't want to use blocks, I use seconds. And then the only thing is that there is another function that requires that the current block is below the limit that is set up here. And if it's below the limit, it tries to create that is the point. It tries to create a proposal. If this contract doesn't have proposition power, when this function is called, it will just fail because the other governance will not accept the proposal. But if it has proposition power, it will be created by this contract, deployed for this.
01:07:13.392 - 01:07:38.570, Speaker A: Now we will need to write a proposal to put all these parameters and to pass them on construction. But that it takes a bit more time and I will not do it now, but yeah, I don't know if there is any question related with this quick hack. Only the yeah, and that's it.
01:07:42.000 - 01:08:04.624, Speaker B: Great. Thanks so much, Ernesto. That was a really great session. If anybody has any last questions, feel free to unmute yourself and ask or drop it quickly in the chat. Otherwise you can always reach Ernesto in the Sponsor Ave chat on okay, great. Okay, great. Yeah.
01:08:04.624 - 01:08:21.320, Speaker B: Well, thanks everybody for joining. Thanks, Ernesto. Oh, wait, there's a question there from Bharat you can answer quick. Considering that governance contracts can need to be updated, wouldn't it be better to create an upgradable contract?
01:08:22.140 - 01:09:18.156, Speaker A: Do you mean the one I created now? Or an upgradable contract of the governance itself? Barat the governance itself, it is updatable in the sense that you cannot change the whole code, but you can change certain parts. For example, if you want to change the strategy, you can change the strategy. You just need to submit a proposal that then change the governance itself. Or if you want to change the like put more executors and remove the previous ones. In some cases a bit more complex, but you can also do it. Why? It's not so good, from my perspective, to have a full upgradable governance. I mean, you can have full upgradable, but it's quite radical because there is the danger that you change completely the rules of how it works.
01:09:18.156 - 01:09:40.770, Speaker A: So from our perspective, when we design, we say that okay, better to change how the voting is calculated, how the proposition is calculated, which are the requirements to execute, but not changing the voting machine, because at the end, the governance is like a voting machine. So that better to keep. Yeah.
01:09:44.580 - 01:09:59.348, Speaker B: Cool. Thanks, I guess. Any more questions, you can direct to Ernesto in the Sponsor Ave chat on Discord. Thanks everyone for joining. Thanks Ernesto, and have a great morning, day or evening. Cheers.
01:09:59.524 - 01:09:59.990, Speaker A: Bye, guys.
