00:00:02.090 - 00:00:52.026, Speaker A: So I'm christopher, I just wanted to you know, when I was asked about the discussion today, I felt like the best way to talk about the topic that I wanted to bring up and not totally shell Zabo is through just good system architecture design and software development. Are any of you guys computer science students? Okay? Yeah. So this is kind of more of a high level lecture on just good software development. Real quick, just to introduce myself, I co founded Zabo with Will and Alex. Alex and I are based in Dallas Fort Worth, Texas. Will's actually in Toronto and then Davi's here also, and he resides down in Brazil. And then Fred is another core developer of ours and he's in New Hampshire.
00:00:52.026 - 00:02:10.310, Speaker A: So we're a little bit spread out, but we come together at events like this when we can and kind of discuss things face to face. So talking about walletless apps, really, to kind of get to that point where you have this idea of not worrying about wallet architecture itself is you really have to pay attention to these fundamental system design principles of abstraction. Encapsulation, and then ultimately, to get a product out there, it's basically draft build, and iterate because the bottom line is, if it doesn't operate, it doesn't matter. And really what this kind of the mental framework that you have to develop is you got to get something out the door and sooner than later to start getting that feedback. You cannot really anticipate all of the problems that you're going to have in an application for yourself in the development process and for the user until you've actually developed something that you plan on using and a user has actually used what you built. There's too many variables, edge cases to really kind of frame this in the way that it needs. And so, of course, the first thing I'm going to start with is abstraction.
00:02:10.310 - 00:02:50.878, Speaker A: And this is kind of textbook right here with software is when you think of a house, right, you don't really think of it in this context. There's a lot of detail here. And if you build a module in your software component where you're dealing with low level structures and custom building the whole thing, you're going to get bogged down and that product is not going to get out the door because there's too many details and variable. There is a matter. You need a whole team. And if you're a startup, you don't have a whole team. And so what we do with good kind of architecture and system design is we abstract a lot of the details.
00:02:50.878 - 00:03:22.646, Speaker A: So this is where we're using open source libraries when we can. And we don't have to know that the door is made of wood and then what grain and what kind of material is involved in that process. We just know that there's a house and it's got a door. And that door can have two states it can be open or closed. That's all we need to know, right. So we don't need to know all of these kind of details. And so to parlay that in our crypto ecosystem, this is the problem that we have with tokens, right.
00:03:22.646 - 00:04:14.154, Speaker A: So there's tokens and they all have different properties. Some of them are, ERC, 20, some of them reside in like an account state on the chain, like ether itself. You've got bitcoin and bitcoin cash, these UTXO coins, and then you've got different characteristics of coins, like zero knowledge coins, and just different bleeding edge kind of technologies that we're developing. Abstraction helps us ignore all the details. Unless you are particularly developing, like, a privacy application that needs the properties of a specific token, your application really needs to be able to abstract as much of this as it can. And the way that we think of this in Zabo itself is this is just crypto and we categorize the crypto in different ways. We've got four categories.
00:04:14.154 - 00:05:08.906, Speaker A: For instance, you got UTXO, you've got account based, and you've got, ERC, 20. And I forget the fourth. But the idea is we go from this scenario where we have to pay attention and mentally comprehend all of these details to where we can abstract it enough in a module that we just need to know what the states are of the higher class. Right. And so it reduces complexity and abstraction helps us bring something that's generally unmanageable into a manageable place, I guess. Have you guys experienced this yourselves in a development process with an application of not really kind of abstracting enough? Yeah. And it really holds back development.
00:05:08.906 - 00:05:43.690, Speaker A: Right. It's tough until you can abstract what you need and then move on to the piece that uses it. And then one last point on this is there's different levels of abstraction, right. So, like, on the door here, we've abstracted the doorknob at a level and then the doorknob is part of the door. And so we've got a door abstraction, a doorknob abstraction, and then that itself is part of the house, right. So it's making sure that we can put these layers in a comprehensible manner. Which brings me into encapsulation.
00:05:43.690 - 00:06:09.554, Speaker A: So encapsulation is the ability to where abstraction tells us what level of detail we define at a certain layer. Encapsulation tells us the level of detail that we cannot define at a certain layer. Come on in. Yeah. What's your name? Arthur. What is Arthur? Yeah. All right, cool.
00:06:09.554 - 00:06:43.370, Speaker A: Nice to meet you. So encapsulation is that process where we draw boundaries around that abstraction. So we say this is a house and this is a door. And the abstraction says, this is a door and you don't need to pay attention to anything else. Encapsulation says you're not allowed to pay attention to anything else. So even if you wanted to know what it was made of, we're not going to let you know that if you want to know that you need to go into the module itself and find out and build within the module. Because outside of this module, nothing else cares what that door is made of.
00:06:43.370 - 00:07:45.440, Speaker A: Up here in the public interface, all we care about is whether that door is open or closed. And so once we properly abstract at a layer and we expose that layer that we need to up top, then we can use it without having to worry about introducing new bugs, having a domino effect. Because this kind of all leads into the idea that if you don't abstract correctly at a layer and you don't encapsulate it, then your software really becomes a house of cars very quickly. Because a single change over here, if it's got four or five contact points over here and then those each have four or five contact points over here, there's 25 potential contact points that your software will fall apart that you need to go now, bug hunt. And so again, to kind of bring that into the crypto space is the number of wallets that we have in the ecosystem. So right now your choice as an application developer is you can just basically build your own wallet and then back your app with it. And that gives you the one interface into the crypto ecosystem that you need.
00:07:45.440 - 00:08:49.798, Speaker A: But we know that there's a lot of external wallets that users are holding their crypto in. Those are things like coinbase binance, bitfinex, and then you got ledger, trezor, MetaMask. So if you want to encourage those users to come into your app in a friction free way without asking them to adopt another brand new wallet, then you're left with a challenge of having an interface with all these. And as a sub module, that doesn't really help us encapsulate the crypto wallet ecosystem that we need to encapsulate, because now we've got to build an interface for each one of these and then add that to our app. And if our app is user facing and it's not a business development facing or a programmer facing system, then this is very difficult to do because one, if you're developing your own wallet, wallet development is non trivial. MetaMask has been under development since the beginning and they're still iterating, on it and building it. And there's a team dedicated to that one piece.
00:08:49.798 - 00:09:54.140, Speaker A: And so you either have to build a team internally to handle that one piece or you have to build a team internally to handle all these pieces. And so that really drives up the entropy inside of your application. But with all that said, here's the most important part as a developer, especially developing an application from scratch with a startup team, is this idea of just drafting an application, building it and iterating. And this is done in a very brute force way. There's one quote, one fact that I was going to introduce. Hey, how's it going? It so we were just talking about kind of like system software design. Kind of talked about abstracting at certain layers and then encapsulation in those layers and then just kind of the process of building an application itself.
00:09:54.140 - 00:10:48.042, Speaker A: You have to cross the finish line no matter how ugly it is, because if it doesn't operate, then the work doesn't matter. That's a hard lesson that you learn at a hackathon. If you're staying up all night Friday and all night Saturday and it doesn't get submitted by the deadline on Sunday, then your all nighters didn't matter because judges aren't going to see it. You might get a look or two on def posts afterwards if you go ahead and post it anyway. But overall you just got across the finish line with a feature, just something that operates from start to finish. And so it's really important that the abstraction and encapsulation is important as you get down the line, but up front, just getting something finished. A fun fact is the first description of a binary search algorithm was published in 1946.
00:10:48.042 - 00:11:27.814, Speaker A: But it took 16 years for someone to actually publish an algorithm that correctly searched lists of all sizes after that. So even though there was this binary search, it was a sexy algorithm that was kind of like drafted in 46 for 16 years after that, you still just had to make do with just a sequential search. And most of the time a sequential search is fine. And then we can also see this in development of like ETH 1.0 versus E 2.0. We hear about all the complaints of ethereum and it's not scalable and all these problems. But the fact is, Ethereum 1.0
00:11:27.814 - 00:12:15.814, Speaker A: is exactly this. It's getting something done and putting something out there. Now, if you decided you were going to invest a nontrivial amount of money into the system expecting DApps to take off with the scaling that ETH one has potential for, then that was on you to make that decision. Right? As developers, I think we want to make sure we have an end goal for a good product, which is what ETH Two is. But before that, we just have to accept this system is not going to work the greatest, but it gets out the door and it gives you something to hang your hat on and it's better than nothing. And again, the idea is you can't understand all of the problems until you've experienced a proposed solution. So you can't go from zero to one and handle those problems on zero.
00:12:15.814 - 00:12:50.798, Speaker A: You have to have something so that a user can actually touch it and help you figure out the problems. And same thing for developing. So I'll give my speech on Zabo. So what we do with Zabo is this whole abstraction encapsulation of like crypto and crypto wallets. We make it so that you have a single interface to get into any wallet. So we've got three functions that are basically of paramount importance. We've got a get transactions, Get balances and a Send transaction.
00:12:50.798 - 00:13:31.758, Speaker A: And each one of those functions, like in the Send transaction, you define the currency and the amount. And behind the scenes in our system, we translate it to wherever it needs to go. So you don't have to have an opinion on what kind of wallet or currency your user is trying to connect. I thought I had another slide on that. Maybe not. I'll leave this up here though, for viewing purposes. But your user could hook up a ledger with Bitcoin in it and our functions will transfer that Bitcoin if you request just the same as if they connected a Coinbase account with Bitcoin cash.
00:13:31.758 - 00:13:56.834, Speaker A: It's the same function to operate on those currencies. Your user could also connect a MetaMask with Ether or an ERC 20 Token. And we can do the same things. Your function calls don't change at all. It's the same interface and everything is translated under the hood. So if it's going to a Bitcoin node, we find the UTXO chain and we translate it and we send it to the Bitcoin node. If it's going to Coinbase, we have the Coinbase API integrated.
00:13:56.834 - 00:14:44.598, Speaker A: We translate it to fit their API and send it to them. We have an entire team dedicated around this piece of wallet and currency integration and that whole piece that I said, and again, it's up to you as far as determining your stack. But without something like that you really have to either a accept a very limited scope of crypto users, such as MetaMask, for instance, or you can develop for the wider crypto ecosystem. 80% of crypto holders are holding Bitcoin right now. Right? So we cross chains, we cross wallets, custodial noncustodial, we operate decentralized and centralized. So the same API that I just said. If you call send transaction and somebody's connected to Coinbase API, your user could show up with an Ethereum node running.
00:14:44.598 - 00:15:22.686, Speaker A: And the API will connect to that node in a decentralized fashion and it will operate sending transactions to getting information from that node just as if you had connected directly via RPC. We handle that under the hood. And so, yeah, so these are the rewards that we have. These are some of the use cases that we have determined that we think Zabo would be really good for. And we're offering rewards, not asking for any freebies here. This is our information. We're in the ETH Waterloo discord.
00:15:22.686 - 00:16:01.626, Speaker A: We also have our own discord channel too. There's my information. And just to kind of summarize for the guys that came in, basically what this discussion was overall about was abstraction, encapsulation and then draft build. Iterate being able to build abstractions at proper layers because this is unmanageable and too complex, right? We usually want to know if there's a door. We want to know if it's open or closed. We don't need to know what the door is. Made of and what kind of doorknob it has encapsulation is putting boundaries around that abstraction.
00:16:01.626 - 00:16:43.760, Speaker A: So being able to encapsulate these so they don't affect every other part of the system and only exposing what needs to be exposed. And this is the problem that we have now. If you're going to develop an app that's going to properly bring in every single thing in the ecosystem, you've got to build approximately 83 interfaces, or you can build something that can expose a single interface that gets into those. And that's what we do at Zabo. And then the idea behind this is just getting something out the door. So that's one of the key concepts with a hackathon is, like, brute force attacking an application development and finishing it from start to finish. And then if you have time to clean it up, clean it up.
00:16:43.760 - 00:17:32.910, Speaker A: And that's all I got. Do you guys have any questions or comments? I'm sure you guys have experienced mistakes in all of those areas at some point, even outside of crypto. Yeah. So let me show you real quick how the user experience looks on this. We've got a fairly basic demo that's actually a little bit outdated just because of recent updates on our server, but this should work. So the idea is, in your app, you have an interactive element. So in this case, it's a button, and so your user connects that, and then they figure out which wallet they want to connect, and then we can connect any one of these wallets.
00:17:32.910 - 00:18:05.110, Speaker A: And so, like, for instance, Gemini is one where once they hit that, we give them the scopes. This is decided inside of your dashboard as an app developer. So as an app developer, you can say, when a user connects, I only want to do these. I don't want to do that. Or I guess this is only read, but we have, like, sending crypto and depositing crypto scopes. And so the user approves those. And then Gemini, we've got username password they submit.
00:18:05.110 - 00:18:55.798, Speaker A: And then once that works, it gets sent back to your application. And then your application receives a JSON like this. So in that account, we give you, like, the wallet provider information, what scopes you have in that, and then the currencies and the balances of those that's that's know cool. We can connect Gemini, but with no change in the code in the application, you can go and interface with any one of these other wallets. So I can connect made a mask, and I'll go through I think I've already connected mine. Yeah. And it'll send back with so I've got status in there.
00:18:55.798 - 00:19:25.666, Speaker A: Spank. Okay, so this is not my Spank token. This is Rink B. So we've got about 75 ERC, 20 tokens that we've created on Rinkby for Zabo specifically for development and testing. And that's all those currencies. And as you saw. So I connected to Gemini and gave you the account information the same code, just connected my metamass and got that information, and then I can connect any of those wallets and do the same thing.
00:19:25.666 - 00:20:00.890, Speaker A: So we normalize the data structure in and out on level you show which exchanges allow, right? Yeah. So we had two primary objectives in that respect. One, we wanted to make sure that the developer could do that programmatically so that you don't have to manually determine when a wallet is connected, what scopes you have. So that's why we give you this scopes array in the application. Right. So with the MetaMask connection, I have all these scopes available to me. If a wallet gets connected and that wallet won't allow you to send crypto, for instance, that will be missing.
00:20:00.890 - 00:21:05.518, Speaker A: So you can programmatically detect that and then adjust your app accordingly. When a user has provided a wallet that doesn't have that scope. But for manual review, we do offer this list, and then you can click, like on Coinbase, and then we give you the information so you can manually review each wallet. But again, to manually kind of micromanage every connection and all that is really difficult. So Coinbase is one that we can't transfer out of, we can transfer into, but like Binance, if you're allowed to have a Binance account, can send cryptocurrency for Binance. Yeah, we do have the API key method. We're trying to expand our scope on the Login method like we have with Gemini.
00:21:05.518 - 00:21:46.704, Speaker A: So coinbase is OAuth. Gemini is Login. And then the rest of them, I think we might have one more that's Login, but the rest of them are API key. But as a company gains leverage, we're hoping to establish some partnerships so that we can just expand the login method as much as possible. Great. Anything else? Questions? Cool. Are you all building a hack here and submitting it on Dev post and everything? Yeah.
00:21:46.704 - 00:22:44.064, Speaker A: Are you on a team or maybe not submitted? Are you on a team or anything, or just solo? Yeah, I did a solo in East Berlin. The hack was successful, but I fell. So the Truffle team and the Viper team were both working on Ethpm package management, and I worked with Truffle. Nick was doing the JS ethpm for Truffle and then Viper. Nick was doing the Ethpm for Viper. And then I was doing the Golang implementation, and I finished it at like, 07:00 Sunday morning. And then I decided I was going to go take a nap, and then I slept through judging and yeah, so but ETH Berlin is my favorite venue.
00:22:44.064 - 00:23:32.870, Speaker A: I think they got a nice venue. Denver's got to be the biggest one, I guess. This one is actually pretty nice. What new features are you planning to add in the next six months? So features kind of the login method is one thing that we want to expand. And then yeah, getting the transaction sending was a big one, and we got that implemented just recently. So I would say over the next six months, our major push is really kind of so a lot of our development has gone into the sandbox side of things. And we've got the Live available, but it's like manual coordination with the company and the product.
00:23:32.870 - 00:24:30.248, Speaker A: We don't have an automated switch over into the Live server. So automating that process so that anybody can go from Sandbox to Live with a few clicks of a button and just hardening that whole system. And then our ultimate objective is to get as much of the cryptocurrency ecosystem as possible integrated. So just expanding the wallets and then expanding the currencies because we feel like our moat, our hedge is really going to be around capturing that long tail because anybody can do like a coinbase API integration and anybody can do a MetaMask integration. So we think it's like kind of those difficult chains. For instance, hashgraph asked us to put Hedera in Zabo. And when they do that, they get access to any developer that's working on Zabo at that point.
00:24:30.248 - 00:25:40.632, Speaker A: And the developers get the benefit of they immediately just extended their application. So if you had Zabo before that, you got like Bitcoin and Ether and all that. And then when we stacked Hedera underneath, then you automatically extended your app to accept Hbars. And so being able to do that with those chains is really the feature set I think we're going after. Where are the API keys stored? What's the best practice for storing those? Yeah, so when doing the API key stuff, we've got a provisioned encrypted database in a private VPC that's got a single entry point from the server service that has access to it that proxies the request from the main server through to that. Yeah. So we're working with a few security partners to work with us over time to ensure the security because that's probably the most hot button issue for anybody is know what's the security like for API keys.
00:25:40.632 - 00:26:23.590, Speaker A: So for self custody wallets, of course, we don't extract any kind of actual wallet keys or anything for the account. Like OAuth goes to Coinbase directly, so we don't touch that. Gemini also goes to Gemini login. And we don't retain passwords or emails. It's just the API key. When somebody's got to put in the API keys that those go into a provisioned database that sits off to the side and that really we just have to QA and keep security partners helping us pen test and all that kind of stuff. Cool.
00:26:23.590 - 00:27:17.588, Speaker A: Can you select the wallet? Yeah. So the wallets is this for mobile too? Yeah, so we've got a Wallet Connect on our pipeline to get to the mobile wallets, basically, because Wallet Connect does the and so we're just going to lay over that protocol. So if I basically create a native app and then I integrate the APIs, it'll call whatever wallet is in my yeah. Yeah, because it's like a push server implementation that goes into the mobile wallet. The only mobile wallet, of course, that isn't on Wallet Connect is Coinbase. They've got wallet link. These are kind of like protocols to get into the mobile wallets, and so we just kind of use those protocols to get to them.
00:27:17.588 - 00:27:34.250, Speaker A: So they're not available here yet, but maybe we could do a hack this weekend and get it done, at least in the sandbox or something. But, yeah, I definitely want to get the mobile wallets on there. Do you mind if I start?
