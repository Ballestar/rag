00:00:00.250 - 00:00:25.874, Speaker A: Cool. Yeah. Hello, everyone. My name is Elena, and I work in a project called ironfish. Ironfish is a layer one privacy coin. We just launched our testnet, actually earlier this month, and my entire journey actually began with an ETH global event. The way I even got into crypto is because I went to one of the first hackathons at ETH Waterloo and actually jumped start my entire interest in crypto.
00:00:25.874 - 00:01:04.106, Speaker A: So I'm so glad to be still part of this community and to give back. Thank you so much. Cool. So I'm going to post all these slides on my Twitter afterwards. And this is kind of meant to give you an overview of what zero knowledge proofs are, but I also added a bunch of links, so if you're interested, you can actually go through them later at your own time. So what is a zero knowledge proof? Or what is a ZKP? And really it's the ability to prove honest computation without revealing inputs. So the example that I like to use is a where is Waldo? Example for people who are totally needs to genealogic proofs.
00:01:04.106 - 00:01:40.874, Speaker A: So the story goes that there was a math professor who was trying to figure out a way to explain what genealogy proofs are in a very simplistic way. And he was reading where is Waldo? With his five year old son. And they're looking at where is Waldo? Page where you're supposed to find Waldo. And the father goes, I know where Waldo is. And the son goes, prove it. So it's kind of a perfect setting for how does the father prove to the son in technically zero knowledge that he knows the answer. And so what the father does is he takes a huge newspaper, he covers the entire book with this newspaper with a small little hole that reveals where Waldo is.
00:01:40.874 - 00:02:25.002, Speaker A: And the paper is much larger than the book. So it actually gives the son known information about where Waldo is, but it does give the son the proof that the father does know where Waldo is. So this is a very simplistic kind of explanation of what xeonological proofs are. But yeah, at the core, xeonological proofs are honest computation and they are used for scalability and privacy, like Anna mentioned. And there's a ton of projects that kind of demonstrate that. I'll go over so many variants of geologist proofs, but there's three main properties that they must satisfy it's completeness. So meaning that an honest verifier will be convinced by an honest prover soundness, meaning that the reverse is true.
00:02:25.002 - 00:03:15.660, Speaker A: So if someone's trying to cheat, an honest verifier can figure that out and zero knowledge. So if the statement is true, then other than the fact that the statement is true, there's no other information that's being leaked. Okay, so brief history, because zealot proofs come from such a rich background. So zealotch proofs were first coined as a term by this paper in 1985 by Shafi Goldbausser, Sylvia McCauley and Charles Rakoff. And Shafi Goldwater and Sylvia McAuley, I believe, both got the Turing Award in 2000. Something for their work in zero knowledge proofs, which is kind of like one of the highest awards you can get in cryptography and mathematics. So this particular protocol was interactive protocol, meaning that two parties kind of have to go back and forth to make the proof actually work.
00:03:15.660 - 00:04:18.714, Speaker A: And ZK snarks are kind of the first widely used form of a non interactive protocol. And right now if we talk about ZKPs, most of the time people still refer to ZKPs as ZK snarks and obviously there are a ton of different zelange proofs. But ZK snarks are, I think, still at this point probably the most popular form of ZKP. And the term of ZK snarks was first coined in 2011. Some of these names and authors you might actually recognize today. In 2013 there was a famous paper that came out called the Pinocchio Paper from researchers from Microsoft and IBM and that was like the first kind of general computing application for Ziki snarks and only in 2016 with the paper Groff 16 by Jan's Groff, was it made fairly efficient for us to actually use today. So I'm not going to go over exactly how ZK snarks work because that's kind of a large topic.
00:04:18.714 - 00:04:48.598, Speaker A: However, a ton of people have explained it extremely well. So to break up Ezksnarc, there's fairly five steps. So first is computation. So how do we break down the computation to arithmetic circuit? There's something called rank one constraint system. Then we transfer that to something called a quadratic arithmetic program. And finally, last step is a snark. So if you are interested in learning more, there is a great tutorial that actually explains the first four steps fairly well.
00:04:48.598 - 00:06:01.150, Speaker A: And the last step is explained by Maxime Petkis in his tutorial that goes very deeply and very thoroughly into how a snark is constructed. So if you're interested, this tutorial is actually amazing and probably the most readable thing I've ever read on Ziki. Sarks and there's another article for BLS twelve three one curve, if you ever heard of that one and wondered what is this curve, why is it such a big deal? There's actually a great article that explains why it's such a big deal and why it's being used in graph 16. Starks so, kind of long story short, there is statement that gets transferred into a language of polynomials and there's a prover and a verifier and a challenge such that there's a kind of a hard coded common reference stream or structured reference stream that is used as part of the challenge. And together all these things kind of create this proof system such that approver can create the zero knowledge proof that a verifier can then verify. So this is a very kind of high level of what ZK snarks are. So I kind of mentioned this proof system called Gross 16 or a type of ZK snark.
00:06:01.150 - 00:06:56.400, Speaker A: And why is it so great? Because it's actually still used today and it's I think still probably considered the standard today. And zoolaunch proofs are typically graded on three things prover time, so how long it takes to actually generate the proof, proof size, how physically large the proof is going to be, and verification time. And for graph 16 in particular, the proverb time is pretty good. The proof size is constant and it's super small and the verification time is also constant really fast. There's a lot going for graph 16 and by a lot of metrics it's still actually relatively unbeatable. There are different proof systems for different metrics that have beaten gross 16 in the past, but I think overall it's actually a very good system. There's also a couple of other kind of criteria that ZKPs are graded on that I kind of skipped over.
00:06:56.400 - 00:08:24.000, Speaker A: So Ezekiel snrfs are great except for one big downside that a lot of people talk about very frequently, which is that they require this thing called trusted setup. So if you kind of learn more about Hezekiah's next work, they do require that common reference strain or structured reference strain that I mentioned earlier. And to get that to be as part of the challenge, there has to be a trusted setup, meaning that some people have to come together and provide their randomness and if all of them collude, then potentially the system could be flawed. Now I think practically the chance of that happening is actually pretty small, but people have been kind of questioning whether or not we can have a better proof system that doesn't require this step to be better for a decentralized technology. So in 2017 onward, there's been an explosion of academic research in the Xerology proof space to figure out, okay, can we use something else to kind of get rid of the trusted setup or at least replace it with something better? And a lot of these new proof systems that I'm going to kind of mention really quickly actually came out due to this paper of cote polynomial schemes. And I found this amazing tutorial that actually explains them, if you guys want to kind of dive deep into exactly how that works. So 2017, we had a ton of research.
00:08:24.000 - 00:09:04.698, Speaker A: 2018 is when Starks came out. 2019 was an explosive year for New Zealand launch proof systems. This is where Sonic came out, halo came out to kind of name some of the more famous ones. Plonk obviously 2020 was a great year as well. 2021, there's only one that I kind of paid attention to, there are others, please link me, I can update the slides. So there is a ton of these new kind of replacements for graph 16 that either have no trusted setup or universal setup or some other alternative. And in terms of all these, I guess the question is, well, which one should I pay attention to.
00:09:04.698 - 00:09:40.040, Speaker A: There's so many. And so I would say probably these are the ones that I would pay attention to. So Bulletproofs, I believe they're used in Monero to prove the range proof Starks. There's an entire company behind it called Starkware. I think they're going to be actually talking next plonk, astec is the company behind that, and they're going to be talking next as well. Halo Two was developed by Zcash, and I believe their next version of Sapling that they want to do is going to be based on Halo Two. So these are kind of like the four that I would say out of all of these, if you're curious, I would kind of pay attention to these the most.
00:09:40.040 - 00:10:38.022, Speaker A: So, still coming back to Graph 16, it probably has the biggest tool set currently, and I'll kind of brush on this tool set a little bit later on as well. But there are a lot of what's called DSLs or domain specific languages that are written for Gras 16 that make it extremely easy for you today to actually write circuits in a fairly easy way. So it's kind of like the huge power of Rot 16 is this tool set and this community around it, of all these people that are doing so much research, plank is another one they want to highlight. And once again, I think Astec is going to be talking next. I don't want to steal their fire, but they're working on something called Moir, which is domain specific language for Plonk. So this is an entire kind of ecosystem that's still kind of earlier than Graph 16. And so you're probably not going to have as rich of a tool set, but there's a ton of research happening here as well.
00:10:38.022 - 00:11:39.350, Speaker A: The thing about Plunk is that for the first time there is a proof system that even though for some metrics it's still slower than cross 16, there's a ton of promise that with this research, it's going to be seen a lot of improvements. And then Halo is the other one that I mentioned, or Halo Two in particular. This is the proof system that's being developed by CCASH team currently and I think it's still like a work in progress. I'm not entirely sure how much you can do today with it, but if you want to learn how Plonk works, which is the thing that's actually related to how Halo Two works, there's a great tutorial that I linked by Vitalik if you want to kind of dig more into it. Okay, so this entire talk so far has been kind of theoretical about all these different proof systems. And I do want to highlight some examples of where xenolsh proofs are used in Ethereum today to kind of give you inspiration of how achievable it is to actually use them today for different applications or smart contracts. So first category is gaming.
00:11:39.350 - 00:12:02.894, Speaker A: So for Ethereum, everything's out in the open, the state is public. There are so many games out there where you might not want that. You might want some privacy. There's certain games where a player's state should be hidden for whatever reason. And currently it's really hard to do because everything's out in the open now with zero knowledge proofs. There are ways they can do that. So one obvious example is Dark Forest.
00:12:02.894 - 00:12:39.390, Speaker A: And Brian is going to be talking next about this as well. But what's amazing about this game is that a player has some hidden state, primarily the coordinates of their planets, and they're able to do this with zero knowledge proofs. If you haven't tried it, I highly, highly recommend it. Everything is in the browser. And so it kind of shows you the power of zero knowledge proofs. I think there's a misconception that the computation is super expensive, which to be fair, depending on the computation, it is. But there's a lot of these applications don't require really complex operations and so there's a lot you can do with a very good user experience.
00:12:39.390 - 00:13:19.514, Speaker A: So Dark Forest happens entirely in the browser. Every time you make a move, you actually make a zero knowledge proof, and it's a very good user experience. So the other category obviously, is private transactions, which kind of Anna mentioned as well. So again, same question. Ethereum has everything out in the public. So if you did want to do a privacy layer, how would you do it? Obviously zero and all proofs to the rescue. So another notable example is Tornado Cash, and it's a privacy layer on top Ethereum, where you can in zero knowledge proof, sort of like mix your coins with somebody else and then obviously Scalability, which is kind of like the theme for today.
00:13:19.514 - 00:13:50.230, Speaker A: And there's a ton of Zkrulla projects, some of which are actually going to be speaking after me. There's StarkWare's. StarkNet, which uses starks, not starks. There's matterlab Zksync, and I believe they're going to be talking today. There's Loop ring, I believe Anna mentioned a lot more others. So this is once again of how you do scalability with your knowledge. So in terms of like, okay, you were Ethereum developer trying to figure out a project you're inspired.
00:13:50.230 - 00:14:40.200, Speaker A: What can I use today? So Zocrates is probably one of the earlier projects for how to do a DSL with domain specific language for ZK, Snarks. So Zocrates is great because provides really good documentation and kind of handles everything for you. So it's a kind of pseudo language that does certain construction for you in the background and then it actually auto generates this. Let's verify a smart contract for you that you can very easily deploy so that you can verify your proofs on Ethereum and then create them somewhere else, like, let's say, in your browser application. The one that I think is probably most used today is Circum and Snarkjs. So the two previous projects that I mentioned, dark Forest and Tornado cache actually use Circum. And Circum is kind of amazing.
00:14:40.200 - 00:15:22.290, Speaker A: They've done everything in JavaScript and wasam in fact, most of their implementation is in JavaScript, which I remember when they first came out, there was kind of doubt of whether or not it could work or it could work efficiently. And so it's really cool to see that it's actually becoming like a very dominant choice for DSLs, for ZK Snarks. On top of Ethereum, they have a great tutorial that I linked there and it's really easy to get started. They also help you with the trusted setup as well. Amazing project. Highly recommend if you're inspired to do something with your launch per stay. Other notable languages that I kind of mentioned earlier, there is something called Zinc from Matterlabs, and this is kind of a custom language that's a bit more similar to Rust.
00:15:22.290 - 00:15:47.930, Speaker A: And this was designed by them primarily for Zksync. Then there's another language called Dwar. Once again, I think Aztec is going to be giving a talk after me, and it's a domain specific language for Plonk. So this is not ZK Snark, it's a different genealogy proof system. Cool. And that's it. Hopefully the goal of this talk was to get you guys inspired.
00:15:47.930 - 00:15:55.278, Speaker A: So I hope you have questions. I don't know if we have time for questions or if that's a thing that's allowed here.
00:15:55.444 - 00:16:07.294, Speaker B: I think we have a little bit of time, actually. I know there's at least one question and I'm waiting for a few others, but one of the questions was actually about your project, Ironfish.
00:16:07.422 - 00:16:08.260, Speaker A: Oh, cool.
00:16:11.190 - 00:16:16.754, Speaker B: Ironfish is focused primarily on Snarks, correct? That's what you've decided to use?
00:16:16.872 - 00:16:18.180, Speaker A: That's correct, yes.
00:16:19.190 - 00:16:27.954, Speaker B: Is that sort of something you'd consider switching out if some of the other tech gets better? Like even some of that tech we talked about that doesn't need trusted setups?
00:16:28.082 - 00:17:00.878, Speaker A: Yeah, totally. I mean, the reason why we went with it is because it has such a rich tooling and because of the metrics for a lot of use cases, it's still fairly unbeatable. If you're going to be using something that's going to be saved on a blockchain proof size of under 200 bytes is like a great metric to have. Because whenever you're saving something on the blockchain, space is definitely something that is a huge concern. So kind of that combined with all the other metrics make it, at least for us, it made it a pretty clear choice.
00:17:01.054 - 00:17:22.060, Speaker B: Nice. Why do you think you mentioned that there was this like you kind of listed all of these. The research that had come out year by year, 2019 is boom. And I know what you showed was like the non trusted setup kinds, but the general research was huge. So do you have any sense for why that happened in that year?
00:17:23.390 - 00:17:48.046, Speaker A: I'm not sure. I think that year in particular was kind of experimental for different polynomial schemes. And I kind of mentioned Kate, but I believe Kate came out in 2010. And so the question is, like, well, why hadn't all this happened earlier? And I'm not entirely sure. I think the ecosystem was kind of like what you were saying during your intro was kind of, like, ripe for the taking. A lot of people care about privacy. A lot of people care about scalability.
00:17:48.046 - 00:17:56.366, Speaker A: And all of a sudden, gene launch proofs, which used to be, like, kind of a niche topic from the 80s, was kind of gaining more and more traction.
00:17:56.558 - 00:18:05.942, Speaker B: Totally. Yeah, I think that, too. I actually think it might be the scaling. The fact that scaling became such a clear need that just sort of pushed this a little faster, I'm not sure.
00:18:05.996 - 00:18:47.618, Speaker A: Because ZK roll up is using graph 16, or at least like the very first example by Barry WhiteHat, I believe was using graph 16 on a different curve, on the ethereum curve, but it actually relatively worked pretty well. And I think in terms of metrics, I believe it's still probably the fastest one, despite all this research. So I don't know. I think academia might have gotten excited that for the first time ever, their research has a much shorter lifecycle. Usually it takes, like, 30 years for you to write a paper and then see it live in action, and here it's a matter of months for that lifecycle to actually happen.
00:18:47.784 - 00:19:02.682, Speaker B: Yeah. One other thought is that maybe there had been some proof that it could exist in Blockchain, too. Like that connection point had been made a few years earlier by Zcash. At this point, it was clearly like it was there to stay. I don't know. These are just some ideas. Okay.
00:19:02.682 - 00:19:10.890, Speaker B: Another question. How can someone get up to speed if they want to understand the tech and math behind Snarks? That's a great question.
00:19:11.040 - 00:19:37.080, Speaker A: Yeah. So I'll post these slides. The other link that I'll add onto these slides somewhere is a GitHub link I believe actually was started by Matterlabs or somebody at Matter Labs, and it's called awesome ZK Snark Links, I believe, and it's a compilation of a ton of tutorials and a ton of reading material for people who really want to dive in. So I'll add that to my slides before posting them on Twitter for those who are interested. Cool.
00:19:38.170 - 00:19:43.800, Speaker B: So I'm just going to hold off a SEC to see if there's any other are.
00:19:44.330 - 00:19:45.720, Speaker A: I think we're good.
00:19:46.490 - 00:19:59.250, Speaker B: Okay. So I'm going to invite Alex Osdemir up. And thank you so much, Elena, for the to. I'm excited you shared this with this audience.
