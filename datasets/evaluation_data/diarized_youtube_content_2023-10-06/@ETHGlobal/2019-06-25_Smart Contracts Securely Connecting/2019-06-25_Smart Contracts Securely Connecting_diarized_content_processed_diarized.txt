00:00:00.170 - 00:01:05.022, Speaker A: I'm going to be speaking to you folks about chainlink and how it can help get rid of that horrible sound before doing that sound. But okay, so essentially, I'm going to be speaking to you folks about Oracles and the value of oracles in terms of smart contracts and what it expands their capabilities to of fundamentally, I think the useful thing to just understand. Just so we have common ground to think through. This problem is what? Fundamentally speaking, the problem the problem is that you can't get access to data feeds. So if you can't get access to data feeds, you can't write contracts around the data feeds that have contractual outcomes. Right? So what this basically means is that the only contracts that you can write today are the ones that no information that's already in the smart contract network they're running in like Ethereum. This means you can only write contracts about tokenization, about Token movement.
00:01:05.022 - 00:02:11.942, Speaker A: You can't really write contracts about anything else because you can't ask an Ethereum smart contract or smart contracts on any other platform to talk to a data source. And since it can't talk to a data source, it can't know what the data source knows and the data source knows that a market event happened, that an IoT event happened, that a shipment event happened, and the knowing of all these different events and actually the events themselves are what many contracts are written about. Right? So like the multi trillion dollar derivatives industry is written about market events. The multi trillion dollar insurance industry is essentially written about various insurance related events, many of which are shown through IoT. So the fundamental problem is that if you want to go beyond tokenization, you need this connectivity, but you don't have this connectivity out of the box. This seems like a relatively technical group. So fundamentally the reason you don't have that connectivity is that you don't have a capacity for the miners that secure the smart contract state to go out and get data.
00:02:11.942 - 00:03:54.680, Speaker A: And you probably won't ever have them to have that capacity because it introduces all kinds of security concerns. So if we look at this question in a historical context, how would solving this problem help the space evolve? So realistically the way the space has evolved is we went from Bitcoin multi signature as programmable money and then we went to protocol smart contracts, which were these smart contracts that were built basically by interacting with smart contract, not with smart contract developers, but with protocol developers. So you had to get the protocol to add a new smart contract type that took anywhere from three months to a year between testing and deployment and everything else. This is us going from the only smart contract type as multisignature to protocol smart contracts was the very big leap forward in 2012 and 13. This is something that got me very excited about the space and where we built some of the first decentralized applications, then what Ethereum did is it took us from this protocol smart contracts world and it brought us to this scriptable smart contracts world. And that world is much more exciting because the capabilities of the types of contracts you can build are greatly expanded. So instead of creating a new smart contract and taking three months to a year and you having to interact with a protocol developer to do that, you can now sit down in a week, script up your own contract, get it running with certain set of conditions, right? So this created a huge explosion in what people were able to do, created a huge explosion in the useful capabilities that basically smart contract infrastructure was able to allow people to build.
00:03:54.680 - 00:05:28.978, Speaker A: We think fundamentally solving this Oracle problem or smart contract connectivity problem, will take us from just scriptable smart contracts that can be written about tokenization, and the movement of tokens to fully integrated smart contracts that can interact with all the relevant data feeds. And by interacting with all the relevant data feeds, that means now you can build all of the necessary derivatives, insurance, trade, finance, all these other types of contracts, probably 90% of the decentralized finance stuff that people are excited about, all those types of things, they need reliable inputs in order to get built, right? And so fundamentally, we think there's going to be another big shift from just scriptable smart contracts that can only move tokens to scriptable smart contracts that can do everything else. Now, fundamentally, this is what we offer as a body of work and a project. We seek to make a very reliable, secure middleware that provides inputs to data outputs to payment systems, and eventually connections to other chains. Fundamentally, in the process of building such a system, we've come to the conclusion that what you really need from what's essentially a blockchain middleware is a highly reliable middleware. So you need something that maintains the reliability of the smart contract as you expand what it does. So we're fundamentally expanding what smart contracts can do from tokenization station to these many other classes of smart contracts.
00:05:28.978 - 00:07:05.390, Speaker A: But as we expand what they're capable of doing, we want to retain the unique property of a smart contract, which is its reliability, right? So if you build a smart contract that's reliable in its state changes, but then it's triggered by an insecure system that's easily breached or manipulated or stopped, then the entire smart contract isn't really reliable and nobody's really going to put substantial value into it. This is probably why we don't see a lot of these more complex smart contracts housing a lot of value, because what's really needed is both smart contract state change layer like Ethereum, and a reliable Oracle reliable blockchain middleware that allows you to make a reliable contract end to end. Now, in the process of building this type of system, we've arrived at certain ideas about what you should and shouldn't do. I'm just going to walk through one or two approaches how you can approach this problem, how you may not want to approach this problem, and then a few examples to illustrate how those work. So fundamentally the approach that doesn't really make sense to us is the approach where you have a single centralized oracle because fundamentally that centralized oracle can be taken down very easily and at that point the reliability and the value of the system is very low, right? So the value of the system is only as good as the weakest part that people can kind of stop or tamper with or make not work. And fundamentally you have decentralized computation layer running on thousands of nodes. You have the data sources which have been many of them around for decades and they have hardened reliable systems.
00:07:05.390 - 00:08:03.000, Speaker A: And realistically you probably would want to probably select multiple data sources if you were able to. But the real point of failure is this one centralized oracle. In certain cases it's written with closed source code. In other cases, one of the counterparties might even be one of the people involved in the transaction, might even be running the oracle. And in that sense, the reliability of the system is completely compromised because one of the interested parties in the tamper proof peer to peer transaction can now completely influence it. So fundamentally, having a single centralized oracle creates a multitude of problems and basically, I think, precludes people from having highly reliable, smart contracts that do more advanced types of computations around derivatives or insurance or these very valuable kind. Of smart contract types, which, as I said earlier, is probably 90% plus of the decentralized finance stuff that we are even starting to see today.
00:08:03.000 - 00:09:27.038, Speaker A: So the fundamental solution that we recommend to this problem is the same solution that smart contracts themselves benefit from. So smart contract state is considered secure primarily because it's run on a multitude of independent node operators that do the same computation and secure that smart contract state. So that's called decentralization in some circles, it's called other things in other circles, but fundamentally it's a few independent node operators doing the same computation and securing an agreed upon outcome to the computation and then the state of that computation. So fundamentally, if that is the new security model that our space has created, then logically speaking, if we can apply that security model to the Oracle mechanism, to creating reliability at the smart contract state level and then creating reliability at the Oracle mechanism level, that's what fundamentally makes sense to us. And I think things like this will get proven out more and more as for example, a centralized oracle fails and somebody loses a lot of money or something else happens where a single oracle doesn't properly fulfill its obligations. And basically what I think the way it's going to look is there's going to be more and more complex smart contracts. Some of them are going to fail because they didn't have a reliable Oracle setup.
00:09:27.038 - 00:10:37.030, Speaker A: And it's going to look something like the Dow, right? People are going to before the Dow happened, there wasn't really an audit industry before the Dao hack happened and people were really worried about smart contract security. Auditing your smart contract or paying people a lot of money to do that wasn't like a huge it was an industry, it wasn't a huge concern for a lot of people. And so realistically, the real security risk in all these scenarios is the Oracle. And the fundamental logic of our space is quite simply, let's make a bunch of independent node operators verify the same computation. So fundamentally, this approach should, if the logic of what secures the smart contract state is valid, then that logic should apply to securing this part of the architecture of the contract as well. And then once you've decentralized out the Oracle mechanism, then you can begin decentralizing the multiple data providers. Then at that point you can have multiple data providers, you can come to averages or you can verify multiple temperature readings or any collection of reliable inputs that you want to generate once you kind of move outward from the contract in terms of the reliability you need to guarantee.
00:10:37.030 - 00:11:11.940, Speaker A: This is what we've built at Chainlink. We have a booth right there. We have integration engineers here. We have a lot of folks that can answer all your questions. So if you're interested in applying this decentralized approach of I've made my smart contract able to access external inputs and I've made it more reliable through the application of decentralization, then we can definitely help you. We do that all day long. I'm going to walk through a few examples and then just dive into some other ideas about how a system like this could guarantee a greater degree of security.
00:11:11.940 - 00:11:51.626, Speaker A: So the first example is a very simple one. It's for something called the futures contract. So a futures contract is a very simple derivative. It basically needs to be settled every day. In fact, a lot of the DeFi stuff that's named very exciting things is fundamentally a lot of it is futures contracts and various other derivatives just kind of renamed. And fundamentally what you need to settle a derivative like a futures contract is you need a price. You need a market price to settle it at the end of the day or on a certain timeline, or when a user wants to settle or however you want that to work in its settlement specifics.
00:11:51.626 - 00:12:57.750, Speaker A: And so in this example, we fundamentally have three data providers feeding in relevant market price data into three Oracles. And those three Oracles provide a more reliable source of market price data to the contract. So now you have a large degree of decentralization at the contract level, you have a certain amount of decentralization at the Oracle mechanism level, and you have a certain amount of decentralization even at the data origin level, right? And this from the perspective of getting a contract that is externally aware and reliably triggered end to end, this seems relatively more secure than some piece of closed source code in a centralized Oracle or some other thing. So this is the fundamental idea. And all of this that you see here, we actually have all these data providers already set up and we already have a system of Oracles that you could make exactly this work in a matter of minutes. So the next question that people commonly run into when they make some kind of financial contract is, okay, my financial contract has learned about a contractual outcome. It's assessed the contractual outcome that's triggered a state change.
00:12:57.750 - 00:14:00.182, Speaker A: Now that state change results in payment. So fundamentally, the other piece of value that chainlinks provide is they allow smart contracts to pay in various formats. We don't have huge preferences about what formats. It's really not our place to tell specific use cases what formats they want their users to be paid in. I think the thing that's important is that firstly, smart contracts can be reliable in their assessment of outcomes and secondly, that they can pay in the places that people that users want to receive payment, right? If a user can't be paid or a settlement can't happen in a manner that a counterparty another participant in the contract wants, that's a big hurdle. Right? We've had this problem for years when good luck. Four years ago or even today, convincing somebody to pay an invoice automatically pay an invoice for the shipment of frozen goods and bitcoin nobody wants to pay to have like the $8 million pizza thing, right, where they paid a lot of money and the price went up and they got it in exchange fees and everything else.
00:14:00.182 - 00:14:58.774, Speaker A: So one other way to look at it is how do we get reliable inputs and how do we provide the type of outputs that contracts want and need to become useful, right? So fundamentally, what we seek to do is we seek to accelerate the usefulness of smart contracts by enabling them to know about more events that they can be written about. We think the majority of smart contracts that will be written over the next couple of years will not be about tokens. They will be about other events other than token movement. And then it's how do you pay the appropriate party the appropriate way? Another example that shows maybe not one data source being highly decentralized and made more reliable, but a multitude of data sources in a more multistep contract is something like frozen goods shipment insurance. So let's say you're shipping frozen goods from somewhere and they need to remain frozen in order for them to be sellable. And then you have an insurance policy ensuring that if they don't remain frozen, you are made whole. Right? This is a very real industry.
00:14:58.774 - 00:15:56.222, Speaker A: This is how a lot of frozen goods actually arrive where they get consumed, basically. So in this example, you need the GPS data of the ship, you need the IoT temperature data of the container, the IoT security data. The container hasn't been breached as a condition of the policy. There's customs API data to show that, okay, it's left, it's traveled frozen, it's remained secure, it's cleared the customs of the relevant country, and then it's also been delivered to my warehouse. So in this case, to build such a contract, the focus here really isn't on decentralization. Even though each of these could have a degree of decentralization applied to them. It's really more to illustrate that there's also a need for a multitude of inputs, multitude of different inputs, such as GPS data, IoT data, governmental data about the state of a contract, other data about receipt or sending of goods, things like that.
00:15:56.222 - 00:16:50.442, Speaker A: And then likewise, the same situation appears where, okay, we've had all of this happen, but now we need to pay the relevant people, we need to pay the supplier, maybe we need to pay the policyholder, depending on if the goods didn't remain frozen, if the container's refrigeration system failed. So all of these contractual outcomes then need to be resolved in some form of payment. So fundamentally, this kind of just illustrates there's a multitude of different inputs. And this is realistically a contract you could also build today with a chain link and without some kind of oracle or blockchain middleware, you simply wouldn't be able to build this contract, which to me is relatively interesting because something is assessing the state of the world. There's a lot of data proving the state of the world, and then somebody's getting paid, and everybody's looking at a system and saying, this system is reliably doing right by me as a counterparty. Right. That's, I think, in my opinion.
00:16:50.442 - 00:17:30.602, Speaker A: What was the value that I was hoping to see from this space from kind of the beginning? Yeah. So fundamentally, what we seek to do is to generate a large multitude of these inputs and outputs. We seek to provide basically a large marketplace, a huge collection of these premade inputs. So the examples I just showed and many others built as individual chain links, we already have many of them built. We're building more of them. And fundamentally, we prioritize the ones that people tell us that they need. So if you have specific chain links or specific data sources that you want for a use case you're hacking on here or a use case you're building elsewhere, you should let us know.
00:17:30.602 - 00:18:21.174, Speaker A: And we can literally, in something like 24 hours, probably turn around something that works for you, depending on the complexity of the API and the system we need to integrate with. Have you made a PayPal one already? Yes, apparently we do have a PayPal one. We have a multitude of them, and we have more and more appearing every day. We're going to systematize this and we're going to have a system to encourage people to submit their requests and get back a chain link in a relatively short time span, even faster than they themselves could build it, and so on. There's an example, we actually do have that one. The next goal that we have is that we want to then extend all these inputs to various smart contract chains. Those could be Sharded chains and ethereum, those could be any other collection of environments.
00:18:21.174 - 00:19:07.786, Speaker A: And fundamentally we think Oracles extend in the value they provide to every environment where you're writing a contract. And then the other important thing that we seek to do as a project is to make a very secure Oracle mechanism. And for that we use a defense in depth approach. The use of a defense in depth approach means that even though we're fans of decentralization and we believe in it and we think it is the fundamental new security model being proven out by our space and practice which is very exciting because it has various changes to the security of systems. It has changes to the economics of how society works and how contracts function. There is still a lot of space to layer on other security approaches on top of decentralization. And fundamentally, yeah.
00:19:07.786 - 00:20:05.530, Speaker A: So we believe that layering on multiple other security approaches allows us to build a more secure Oracle on an individual basis that can then be decentralized. To reap the benefits of this decentralization security model. How we do that in the most immediate version of a defense in depth approach is we use something called trusted execution environments. Trusted execution environments like Intel SGX are supposed to harden individual node operators and run code in an environment that even the node operator themselves can't know what they're running. All the node operator could, for example, do is stop acting as an Oracle, stop returning results, at which point it becomes immediately obvious that they're a very bad Oracle and they won't get future usage and they'll be kind of not used very often. So fundamentally, trusted execution environments provide smaller trusted computing base. And what that basically means is that the attack vectors are much smaller.
00:20:05.530 - 00:21:07.138, Speaker A: So it's not a perfect technology and it doesn't solve all the problems on Earth, but it certainly allows you to isolate yourself from the majority of existing exploits that rely on getting in through the hypervisor, some kind of virtual machine technology or the operating system. And fundamentally it isolates those exploits away from the code that you're running while providing confidentiality and other things. I mean, if you're interested in learning about it, you're welcome to read up on it. It's something we're implementing on top of decentralization. There's certain ideas that these things are mutually exclusive, like you can't have decentralization in trusted execution environments and that doesn't really add up for us. We think that basically that's the core idea of this first approach in our defense in depth security strategy for the use of trusted execution environments, we use something called Town Crier. Town Crier has been on production for now, I think, approaching two years on the Ethereum network without any security issues.
00:21:07.138 - 00:22:02.660, Speaker A: And I think it was the first successful use of trusted execution environments on production, maybe for anything, but definitely for Oracles. It's made by a great group of people from Cornell and IC Three, and we were lucky enough to join the two projects to kind of acquire Town Crier and bring it into chain link as our approach to trusted execution environments. Now, fundamentally, what the environments provide is protection of computation from node operators. So this means a node operator himself doesn't even know what he's computing. It provides confidentiality. So that's another version of them not knowing and that we can send them requests to get data and they might not know exactly what data they're getting or what it's being used for or how it's being used. So you can have an Oracle mechanism that preserves certain levels of confidentiality and even probably greater levels of confidentiality than the contract itself.
00:22:02.660 - 00:22:53.874, Speaker A: And then if you're going to manage credentials to pay people credentials like passwords that control money, you would ideally want them in a more hardened environment if you could have it. And so, in that sense, Intel SGX is also useful. Now, I'm just going to walk through a simple example of how combining decentralization trusted execution environments can fundamentally benefit a relatively simple use case. So, for example sorry, just 1 second. Yeah. So fundamentally what I think is useful is that to look at is that lottery contracts, that a lottery contract needs randomness. It needs highly reliable randomness to be considered reliable.
00:22:53.874 - 00:23:37.090, Speaker A: Right? So the contract is just a resolution of who wins based on randomness. So the contract fundamentally has two parts. It has the contract itself that the state change on chain is guaranteed to be reliable, because state changes on chain are considered reliable, basically. And then you have the input which triggers the state change. So literally, you could say 50% or even more of the contract relies on the generation of a reliable input, like randomness. So in our case, what you can do is you can actually run an existing library for randomness in a trusted execution environment that can return the necessary randomness and then that randomness can be returned back to the contract. Right? So this is already an improvement in how another system that generates randomness might provide that randomness to a contract.
00:23:37.090 - 00:24:45.834, Speaker A: But realistically, I think the main idea is that even if you have a great system that generates randomness in a more secure, hardened environment that's isolated from the majority of exploits, then it is better within the security model of our space to have multiple such environments run by independent node operators providing that input. So if you had a lottery contract that had increasingly large amounts of value and you wanted to have a guarantee that that value was secure. It does make sense that even if you were using a hardened environment, you then would benefit from the decentralization as well. And then likewise, there's the multitude of inputs and outputs. So now the smart contract in the case of a lottery probably needs to pay somebody something, and expanding how it can pay and where it can pay is a great improvement. So, yeah, once again, we're generating a multitude of these inputs and outputs. We come to these hackathons to work with folks like you to see how we can help build more useful applications quicker together with you.
00:24:45.834 - 00:25:27.590, Speaker A: And so if there's some category of chain links or inputs or outputs that you would find useful here or in your daily work, we definitely want to hear about it. We're very open to feedback. We have a booth right there at the entrance, and we definitely would want to hear how you're hoping to what inputs you would find useful and outputs. Fundamentally, we then hope to secure those inputs and outputs the right way. So there's just two sides of really what we provide. It's securing the inputs at a high level of reliability and then providing a multitude of inputs and outputs. For the security side, we welcome a lot of feedback from the security research community for the generation of inputs and outputs.
00:25:27.590 - 00:26:04.674, Speaker A: We really need your feedback for what inputs and outputs you find. Great, that's it for me. Yeah, great, great. Yeah, we have a booth right there. We have integration engineer folks. Thomas actually right here is one of our integration engineers. He can definitely answer any technical questions there here, unless you guys have any questions now, anything we can answer? Are those servers held by chainlink? No, the whole point is they're not.
00:26:04.674 - 00:26:37.980, Speaker A: Yeah, the whole point is they're not. The whole point is that eventually chainlink the chainlink, the entity will ideally be not needing to run any servers at all. Just like the Ethereum Foundation doesn't need to run nodes. Yeah, there is people pay for requests and then the node operators provide deposits to guarantee outcomes. Is the request it depends on the request. There's really a lot of variation in terms of how requests actually end up working, but that's the fundamental idea in many requests. Yeah.
00:26:37.980 - 00:26:42.500, Speaker A: Okay, cool, great. Thank you very much, everyone. One. Thank you.
