00:00:06.250 - 00:00:40.354, Speaker A: Super excited to have Dan here. From Table End team. Table End is building really one of the most useful primitives you could probably have in your hack if you want to ever want to use a database in it. So Dan's going to walk you through kind of having up and running with it. But yeah, I mean, really psyched to have Table End as a sponsor for I think including Textile, the third hack FS in a row. So really thankful to have them be a part of these events over the last couple of years. And yeah, I mean, really excited to see the kind of next development of what they've been working on with Table End.
00:00:40.354 - 00:00:46.460, Speaker A: So maybe I'll just turn it over to Dan right away. And Dan, if you want to get started, we'd love to hear.
00:00:47.070 - 00:01:19.650, Speaker B: Awesome, thank you. So appreciate everyone joining. We're going to walk through a couple things here today. So we're going to start off with just some basic overview of Table and breeze through those real quick, a couple of slides. Then we're going to touch on just a very basic example of minting an NFT with metadata on Tableland. So if you're familiar with IPFS, we're going to walk through some of the benefits of using Tableland in a scenario like that. And then we're also going to end with what we're calling more like a SQL powered NFT.
00:01:19.650 - 00:02:15.062, Speaker B: So making things dynamic and do actually a live demonstration of that here today. So excited to kick things off. So what is tablent? So tablent is a network for relational data, making things naturally mutable, dynamic composable and really allowing sort of mutable data to live with immutable rules. So let's just dive into what that means because that's obviously a mouthful. So just talking about the current state of things, where are people storing data? So it might be in smart contracts, might be in private or centralized databases, it might be in decentralized file storage solutions. Like in these examples, you could say storing in a smart contract, maybe that's on ethereum, maybe it's on optimism, polygon, et cetera. But there's limited things that you can do with that because of just the complexity of composability with that.
00:02:15.062 - 00:03:31.706, Speaker B: The cost implications depending on the chain that you're minting on. If we look at a private database, for example, AWS or Google Cloud, there are a lot of limitations with that if you're storing something like NFT metadata on those solutions because it kind of takes away the whole point of decentralization and enabling composability in a straightforward fashion. So not the best solutions available in smart contracts, not the best solutions available for storing things like metadata in private databases and then even decentralized storage. Like if you look at how NFT metadata is stored today, a lot of it is on things like IPFS, which is file coin IPFS, great solutions for file storage. But a byproduct of that persistence is this immutable CID so if you're trying to make something like metadata dynamic, how do you do that? It gets really complex if you're trying to do that with something like a file storage solution. So that's where TABLEAN has come into play, really augments something like IPFS or Filecoin and allows you to actually create tables, insert data into those tables, all using just native SQL. So you can sort of touched on that a moment ago, but you can sort of think of Table N basically turning any blockchain into an application database.
00:03:31.706 - 00:04:23.802, Speaker B: So we take that if you just use a SQL lite database as an example, traditional web two, you're going to have ACLs and actual tables that exist within that. And we're just saying, hey, let's break that apart. Relational tables live in Table and the ACLs live on chain using smart contracts and actual accounts to basically dictate who can write to a table, who can do perform surface and actions on the table as well. And then just generally speaking, all data is open and readable to enable that true composability across even different chains. So you can have cross chain queries going on with just native SQL. So as far as the stack, you'll see this throughout the demo, the couple demos that we'll talk through, but there are a few different ways to think about Table land. So we have smart contracts on chain which are basically this registry contract.
00:04:23.802 - 00:05:04.190, Speaker B: That's where every Table is actually minted as an ERC 721. So every Table that you create is actually an NFT. But then off chain, what's happening is that Tableland is a network of Validators that are listening for these events. And then basically what happens is that we run the SQL that those events are telling us to do. So if someone tries to create a table, someone tries to mutate a table, we're listening for those events, making sure the proper access control is also met with a separate smart contract. And then within our network of validators, performing and processing that SQL as a whole. So it's really powerful.
00:05:04.190 - 00:05:56.314, Speaker B: And I think the final example that we'll walk through with actual smart contracts, creating tables and running SQL is pretty interesting. So on the left hand side, this is what we'll start with, just some basic usage of Table and our JavaScript SDK. So importing connecting to Table and creating a Table, actually inserting data what that looks like, we're going to do that in hard hat. And then on the right hand side go into some detail with actually using SQL on the blockchain. And that will end in a demo that actually you can even test out yourself on something like Gurley. So just kicking things off, simple NFT with metadata. The way we're going to do this is mint a table, a single table.
00:05:56.314 - 00:06:47.946, Speaker B: So if you're used to that traditional IPFS workflow, you have all your metadata, like name, description, attributes, et cetera. We're going to mint that in a table on Table land. But as a best practice, we actually recommend even separating something like this. So if you have an attributes table and a metadata table, you can join those together and it really just shows just a simple example of how powerful that SQL based relational data metadata can be. But just for simplicity's sake, we'll just start off with that single metadata table. Now as far as contract setup or project setup, we can kind of skip over this aspect and dive into the structure. So we're going to have some local assets, some images that are just going to be deployed to IPFS.
00:06:47.946 - 00:07:37.806, Speaker B: We have some metadata files that you don't know what the image is yet, so we're going to write those to the metadata data files and actually take those files. So like your classic ERC 21 721 metadata, we're going to take that and then import it into a SQL statement essentially, and then write that to the blockchain upon deploying our smart contract. So let's dive into things cool. So if we look at just our general project structure again, you can see that we're starting here with just a general ERC 21. So we have some basic code set up. We are going to share these repositories after the call. So just a heads up if you want to see what exactly I'm doing here.
00:07:37.806 - 00:08:29.294, Speaker B: Not only this, but the final smart contract and game that we're going to show will also be shared. So just walking through the code, okay, we have a basic NFT, we've all done this. We have our public base Uri, we have our table name which we'll come back to, we have our token IDs that we're incrementing as we mint a table. And then again just some really basic ERC 721. So the goal of this first demonstration is really just to show you, okay, you have a basic NFT, we've all done this. How do you take that typical use case and put it onto Table land? So in doing so, there is going to be one interesting aspect that will come to at the end around actually querying or placing like SQL query on the end of your token Uri. So we'll hit on that in a second as well.
00:08:29.294 - 00:09:20.990, Speaker B: But to also show you some of the data that we'll be using in this upload in this minting process. We have our assets, so a couple of cool rigs NFTs which is a huge component of the table and ecosystem. So if you haven't checked those out, head over to our website Tableand XYZ. But then we also have some metadata which is going to be initialized with an empty string here in the image actual field. So what we're going to be doing is start off with just uploading data to IPFS. We're going to sort of skip over this because there's a lot of different ways to do this, but the general thing that you should understand is that we have a few different scripts here. We have upload metadata to IPFS, we have Prepare SQL, and then we have Deploy, which is where we're actually going to connect to Tableand and create and insert this metadata.
00:09:20.990 - 00:10:10.478, Speaker B: In here, we're basically just reading files, parsing it, converting it to JSON, and then we're going to use that in this Prepare SQL statement. So we're loading files, uploading those images to IPFS, parsing the metadata, returning it, and also preparing it. So then Table End in this Prepare SQL script has all the data that we need, all the JSON for our NFTs, and then we're going to use that to prepare an SQL statement. So now let's start talking a little bit more about Table End. So if we look at this example, if you're familiar with SQL, there are common SQL statements that people are going to be using. And anytime that you're going to be using Table and there's really three or four steps that you're going to take it's. One.
00:10:10.478 - 00:10:43.794, Speaker B: Let's connect to tableland. We have that all built into our JavaScript SDK to make it super simple. Two, you're going to create a Table, and then three, you're going to insert metadata into that table. And the way that you do it, depending on how you want to set up your scripts and how you want to do everything, it's going to differ based on your use case. We're going through the most simplistic use case here, so just keep that in mind. But as part of that deploy script, and we're going to take a step back and walk through that connect and create workflow. But as part of that deploy script, we're going to be inserting metadata.
00:10:43.794 - 00:11:13.806, Speaker B: And here just gives you an example of what that metadata might look like. So you'll see again, if you know SQL, you know Sable Land essentially. So you have insert into name. We'll come back to this. This is going to be the Table name based on the Table and registry smart contract, which is going to be minting tables. You also have the schema that you see here which will match our Create Table schema that we'll show you in a minute. And then you actually have the values here that are getting inserted into the table.
00:11:13.806 - 00:11:59.346, Speaker B: So that came from that initial step I walked through where data is uploaded to IPFS and actually inserted, returned as JSON and inserted into this SQL insert statement. Okay, cool. So prepare SQL for one table. Just, we have a one table example, but as noted, a best practice is actually creating two tables where instead of having something like ID name description attributes, you would actually only include this first subset and then have some join with an attributes table. So again, I've said this a lot, but if you know SQL, you know Table Land. So diving into the deploy script, some helper functions up at the top, but focusing in on what Tableland offers. You start with that connect.
00:11:59.346 - 00:12:33.354, Speaker B: So you're going to import this connect statement or this connect function from the Table and SDK. So you start there, import it up at the top. And note that in terms of installing we're on NPM you can install with yarn as well. So NPM install Table and SDK and you're good to go. And then simply just import it. As you see here, this is common JS if you're using Es six or above or something like that, you can also just do a standard import. Here I'm using a little bit different set up there.
00:12:33.354 - 00:13:04.054, Speaker B: So just the rationale behind that. Now diving into our main function, a few different things that we've set up. So we have just some classic hard hat. If you're familiar with hard hat, some classic hard hat setup where we have a signer for who's going to be actually deploying this table. But then when we look at the next step okay, now let's get into Table end. So first up, let's connect to the Table and Network connect to. In the background I have some providers set up.
00:13:04.054 - 00:13:34.238, Speaker B: So making sure that we have connection established with the actual blockchains. Here I'm going to be deploying something on polygon. So it starts with this connect step. Next you'll see the schema. So we've actually made it really simple to create a table in TABLEAN. It's like basically give us the schema, give us an optional prefix which is going to let you have like a human readable name on your table itself. And then you simply just pass this table and create function.
00:13:34.238 - 00:14:28.234, Speaker B: So connect, create, pass the schema, pass the optional prefix. And then what you're going to get back is a unique name that's actually unique not just only to the chain, but across anything in Table table every table is unique. So if you want to have some cross chain query for example, you can do that all with SQL joins and just passing the proper information and we'll show you what one of those SQL statements look like here in a second. Okay, cool. So we're going to connect, we're going to create, we're going to verify the table is created just a helper function to make sure that when you call this table create function, what's actually happening is that on our registry. Smart contract. We're creating a table which is emitting an event and then the Table and Network of Validators is listening for that event and they're processing the SQL.
00:14:28.234 - 00:15:05.550, Speaker B: So we verify everything's been created. Once we're good to go there. We call that Prepare SQL statement that we showed there a minute ago. And then what that's going to do is actually as a pre deploy script for the Smart contract, insert the metadata itself into these tables using just the standard SQL insert statement. So that is in particular using this table and writes so you can call Table and create. You can call Table and write if you're actually trying to read something, you can call Table and read. So just select all from Table, et cetera.
00:15:05.550 - 00:15:53.954, Speaker B: And then lastly is this base Uri. So if we just take a step back, okay, what have we done? We connected, we created, we wrote metadata into a table. And then here we have our base Uri which has this query s at the end. So this actually allows you to have just a pure select all from Table, select these particular columns from Table where ID, et cetera. So you can append just a strictly SQL query onto this base Uri, which is pointing to the table and network. And as a response, what this will give you is as an example like your JSON metadata for an NFT. So these last few steps are just classic deploying smart contracts to a blockchain.
00:15:53.954 - 00:16:26.274, Speaker B: So we're getting that Table and NFT smart contract that we walk through. We're actually deploying it with this base Uri and the name of the table that is unique to each and every table across any network and table. Cool. So let's run it and see what happens. You can see I have Hard Hat set up there's some example scripts that you can see if you check this out later. Hard hat run script deploy polygon Mumbai. There were some issues today with Mumbai, so we'll see how it's working TBD.
00:16:26.274 - 00:17:09.590, Speaker B: So let's just walk through this deploy script and as that's going, so what we're going to walk through next is actually a SQL powered NFT and it's a pretty cool use case. I'll show you a slide there in a second. But I think what's cool here is just to actually show you what's happening in the script. So you can see that we have these SQL insert statements that are occurring. We have some hashes that are returned from the actual blockchain that says, hey, this is the transaction hash of the actual write statement. And then we can actually even go to the source. We can see the actual contract.
00:17:09.590 - 00:17:52.034, Speaker B: We have that select statement that is embedded into our token Uri query. This is going to be pretty important for just allowing you to append those strictly select all from type of statements. And note that we have some helpers to get rid of some of this encoding formatting. But this allows you to mint a table, allows you to call that if you look up in the URL bar, you can see the select statement. So there's a lot of different ways that you can actually just write a query in this section. So, interest of time, let's drop over to the last part. We got about 10 minutes left here.
00:17:52.034 - 00:18:31.310, Speaker B: So let's create a SQL powered NFT game. This is a pretty cool idea. So really what we're proposing is like, okay, let's kind of change, flip the script with NFTs and allow Mutability and Dynamism to happen in this on chain capacity. So we're going to walk through creating a SQL powered NFT. Picture it as like a canvas game where you have different pixels and every owner of a pixel is actually an owner of an NFT. So you can mint an NFT. It's going to mint back this pixel initialized at a address.
00:18:31.310 - 00:19:04.066, Speaker B: I'll show you what this looks like in a second. But then you can actually write SQL to the blockchain, update the metadata. So in real time you can see what's happening across all users playing this game. So you can have like a global state of a metadata table and then individual users are minting their own pixel, which are inserted into the table as their own NFT. So that's what I just talked through right there. Sort of an overview of step one. And then step two is what we're going to release at a different point.
00:19:04.066 - 00:19:51.014, Speaker B: Don't have enough time to really walk through it in detail, but basically adding an interface layer on top of this smart contract layer that I'm going to walk through. And then just to give you sort of an architecture overview, this is really what's happening. So on the right hand side you can see some of the game rules that we have to give you some additional context. If you look at the architecture diagram that was describing that two step approach. So we have potentially like this NFT HTML front end, it's going to be calling a smart contract, which is going to be updating the metadata within the table and network. And that can all be read and wrote continuously just with pure SQL. Now, diving into what we call just the canvas game, I'm going to walk through some cool things here.
00:19:51.014 - 00:20:32.274, Speaker B: So classic NFT, we have that base Uri string from the previous example if we look at the constructor method. So when we're actually deploying this smart contract, we're going to start with creating a table. And this is calling the table and registry smart contract. And basically this table is going to be holding the global game state and it's actually minted as an NFT on chain. So you can actually have this global state of all these players moves as they're inserting data into the table and it's actually an NFT itself. Create table schema. Okay, good to go.
00:20:32.274 - 00:21:01.294, Speaker B: When you deploy a contract, you're creating a table. It's all happening on the blockchain. It's not like that last example where it's a pre deploy step. You're actually creating a table upon calling this constructor function or upon deploying your NFT. The next step is actually Safe Minting or minting your NFT as well. And this is another super cool feature. Okay, last up, we did everything as a pre deploy script here.
00:21:01.294 - 00:21:44.750, Speaker B: We're going to actually do it in real time. And every time a user mints a table, it's calling this run SQL function. So that was actually that tableand write method in the pure JavaScript SDK. And what this is doing is inserting data into our global state and is minting an NFT in the process. So inserting the data into that global NFT state, we're going to have an ID, we're going to have an external link to some potential image and then we have these XY coordinates which are initialized to zero. And then lastly, make moves. So if I want to overwrite and update mutate my current position.
00:21:44.750 - 00:22:58.930, Speaker B: So instead of just initializing and staying at forever, which is what happens if you use something like persisted file storage in a decentralized capacity, like if you deploy this metadata file on IPFS, okay, how do you actually overwrite and change these XY coordinates? It's pretty complicated and it's pretty complex. And if you've ever tried to do this, just try out Table Land because it's a way, easier way to do everything. Just try it out. It's awesome. Okay, so if we go to Make Move, what exactly is happening? It allows players to insert and update their actual position within the game itself. So you see this SQL statement here we have an update set and where so based on the owner of that NFT there's proper sort of another thing to keep in mind is that we also have what we call a controller smart contract for ACLs, making sure only the owner of that NFT can write and call this make move function. But basically what it's going to do is update the metadata so that the X and Y coordinates reflect what that owner wants upon writing.
00:22:58.930 - 00:23:36.030, Speaker B: Upon calling that write. So cool. Let's dive into a live demo of what this looks like. So just to keep things, I'll share this in the chat for anyone that is curious. Check out Gurley. It's live right now. But basically what happens is that and I just did this real quick to make sure that it was straightforward to demonstrate, but ahead of time I had minted an NFT and we can even do this again if we'd like, but simply copy and paste your wallet address here.
00:23:36.030 - 00:24:07.862, Speaker B: We're going to call Mint or Write, which is going to call Safe Mint. We're going to confirm the transaction and then we can view our transaction. And while that's loading, let's look at one that I already minted. So you can see that I'm the owner of Token ID number two. If we go back to the canvas game, let's actually change the metadata. Let's make this dynamic immutable. So Token ID two, it was initialized when I minted to a address as shown in the smart contract.
00:24:07.862 - 00:24:32.194, Speaker B: But let's change it up. Let's say I want to go to number two. So let's write that to the smart contract. Let's write that and update some metadata. Cool. And just for demonstration purposes, we'll show you what that initial state looks like. So I also have Token number four.
00:24:32.194 - 00:24:52.460, Speaker B: So I'm a multi pixel NFT owner. Awesome. I have some trouble. Okay, cool. So up at the top, you'll see that SQL statement. You'll see the metadata returned at that location. And let's insert right here.
00:24:52.460 - 00:25:18.690, Speaker B: This is the one that I just minted. So address. And then if we go back and recall that I had also been the owner of Token ID number two, and then I had just said make move. Let's overwrite the metadata. Let's make it mutable, see what that looks like. Cool. XY is now at a different location.
00:25:18.690 - 00:26:14.460, Speaker B: Let's even do it again. We have a minute here, so let's make this five five. So it goes from two two to two two to five five, right? Confirm. And it looks like I closed up my bam four. While that's loading, we're running close up here on time. So I know we breeze through a lot. We talked about what is table end, what can you do with it? How do you change really everything from being this static state of metadata to making NFTs live and empowering them with SQL, using joins, mutates, inserts, et cetera, to really make everything composable and even have some cross chain capabilities.
00:26:14.460 - 00:26:56.040, Speaker B: We walk through the basics of just using the table on JS SDK, deploying something on hard hat, creating a very straightforward NFT and then also this unique use case with actually doing things in real time, doing things upon creating your smart contract in general, creating tables, minting tables upon just user calls directly to a smart contract. Such as this example that you see here with Safe Mint with making the move. And it really opens the door for really anything. You can imagine. So many different use cases for leveraging cableland and doing it all with the beloved SQL that we've known for decades. So I'll pause there. We have a minute.
00:26:56.040 - 00:27:16.070, Speaker B: I know there are some questions, I don't know if we want to answer any of those right now, but appreciate the time and everyone for hopping on the call to talk about table and learn a little bit more. Also note that we're obviously have a channel, so hop in there. I'm Dan. If you have any questions, shout out and I'm happy to help you guys build some cool.
00:27:19.850 - 00:27:40.990, Speaker C: Awesome see. Thanks Dan. Like super informative workshop. I hope everyone enjoyed. See you since we're running up close on time, if you do have any questions or just want to chat about all the cool stuff you can do with table land, hit up their discord and yeah, happy hacking everyone. Thanks again, Dan.
00:27:41.810 - 00:27:43.518, Speaker B: Thank you, appreciate it.
00:27:43.684 - 00:27:44.140, Speaker C: Bye everyone.
