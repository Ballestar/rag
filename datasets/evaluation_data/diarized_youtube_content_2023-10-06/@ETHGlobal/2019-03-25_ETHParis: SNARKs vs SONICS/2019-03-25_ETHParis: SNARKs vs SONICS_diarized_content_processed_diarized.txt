00:00:00.570 - 00:01:15.010, Speaker A: Drinker. You will need to know about Snarks upfront at least a little bit and how they work. And especially for graph 16 proof system because well but first, before we go further, I think everyone knows the main problem of Snarks at least it's the current integration of the technology of the Snarks and sense of the cross 16 gras 17 proof system. And what Zkesh guys use is an for a trusted setup. So this slide is a little bit hyping but why sonics are important and why it's the next step? I think because sonics are the same way it's general proof system which is the synth anyway with updatable which is not that important practice but the most important part is universal common reference string for any circuit up to the given size. So you can do the trusted setup once, run it together with Vitalik, Justin Rake, Vlad Zamfer, Joe Lubin and any other parties who just don't care about what will be in your common reference string and they don't have any incentive to break it. Make it once, make it for a very large size up to like the largest circuit you can imagine to be practically usable and then just use it for any circuit.
00:01:15.010 - 00:01:53.360, Speaker A: The best example is like shuffling the deck of card. Let's say for previous proof systems, if you wanted to play some game, you needed to take a deck. To take a fresh deck, shuffle it under the table, pass it to someone who also shuffles under the table. Then you put this deck on the table and you play the game. And you need to do it every time, for every particular game or every particular round, if you want to make it with Sonics, you take the deck of cards, you shuffle it, you give it to someone who shuffles it under the table, and then you put it on a table. Then you magically clone it and use it for a game. And someone else can magically clone it and use it for their game too.
00:01:53.360 - 00:02:59.154, Speaker A: I think it's like the simplest parallel yeah, but this has been practiced the comparison between graph 16 and sonic proof systems and for people who already know I hope people know arcs at least a little bit otherwise too difficult to explain everything from scratch. So graph 16 starts with rank one constraint system which people already know how to work with. There are toolings how to can make what's called the Gadgets and circuits. In this paradigm, the main parameter, the main practical parameter is number of constraints because the larger number of constraints the more approving time and there is a practical limit on the number of constraints which you can use, for example, for ethereum's current curve, which will be on the next slide. And also because this proof system is there for three years already, there are implementations. So you can just take the code, make your own circuit and run the software which was written for you, which can do the proving. And the proving is time consuming, so it has to be made highly efficient.
00:02:59.154 - 00:03:50.614, Speaker A: So there are practical implementations which are highly efficient and the verification cost is also very low. In specific batched mode you can make it down to 200,000 gas, which is very low compared to sonics. I jump more than one okay, for some reason. So for sonics you can also start with rank one constraint system. So this part is good because sonics work in some other paradigm, which is called the multiplication gates and linear constraints. But you can convert from one to another without many problems like 100 lines of code will do everything for you. The main parameter in this paradigm is the number of multiplication gates and it's related to the number of constraints in the rank one constraint system.
00:03:50.614 - 00:04:29.410, Speaker A: I will later show how it's actually related. And the largest problem is unfortunately the implementation and the verification guest. First of all, there is no full implementation and I would emphasize full efficient implementation and even emphasize more full implementation which can do succinct proofs. We will go to this part. So you need succinct proofs so your verifier can run on the public blockchain. You want as little communication complexity and verification complexity, ideally constant complexity to be actually able to run it in a public blockchain. The verification will be still more expensive.
00:04:29.410 - 00:05:44.570, Speaker A: So now we talk about the efficient implementation. This is just completely different story as the original paper which introduced zero knowledge proofs in principle as how snarks work. There is no hard limit for a circuit size, but there is a hard limit for efficiently provable circuit size. And this limit depends on the number of roots of unity, because you need to do LaGrange interpolation, which requires roots of unity if you want to do it in linear time. And because we work in a large circuit, in practice, for most of the application you will want to work in a large circuits and it literally means that any operation you run should be linear in the size of the input parameters, otherwise you will never finish your work. So for gross 16 it's known that all expensive operations are also efficiently parallelizable by using FFT, which is efficiently parallelizable, or operations like multi exponentiations, which are also efficiently parallelizable. But the prover for gross 16 runs in both g one and g two groups on elliptic curve g two operations multiplications, for example, can be taken roughly at four times more expensive.
00:05:44.570 - 00:06:55.220, Speaker A: It's not the largest contribution to the proverb complexity and proverb running time, but still it's not negligible for sonics. Yeah, now we get to the funny part. In principle, as the original paper states that the number of constraints well, not constraint multiplication gates, which you can do with a sonic, is roughly the prime order of the curves group, which is inserior. There you get good soundness in practice, you need to do multiplication of the polynomials of the size, roughly seven by number of multiplication gates and how to do multiplication of polynomials efficiently. Yes, you need to do an FFT and this also means you need root of unity. So this factor of seven gives you a hard limit. So your practical circuit size will be like eight times smaller than for a current implementation, current gross six improve system so it can still fit well, you can still find applications where the circuit size is more than sufficient, but we talk about efficient implementation and hard limits in here.
00:06:55.220 - 00:07:52.610, Speaker A: The second one, yes, implementation as itself, every operation also is at least for me, looks parallelizable, one with less effort, another one with much more effort. But still you can do it, but you just need to sit and write it. And the proverb actually does only multiplications in G one, which is Lcgate. And there, because it's just one operation which you run very often, you can go GPU sync, you can go FPGAs, you can go Asics, all other kinds of special processors if you really want it. So for a concrete example, how you can transform circuit from rank one constraint system to Sonics, and this will hold for most of the circuits. Just take the basic MIMC circuit which has 644 constraints, and at the end of the day you will get 968 multiplication gates. And well, this 1.5
00:07:52.610 - 00:08:50.950, Speaker A: multiplier is very close to reality if you just divide one over another, because the conversion procedure works to convert every rank one constraint to one multiplication gate, plus you more or less align can make two allocate two variables per one multiplication gate. So this is like the final number. We will get always very close to it. So the original paper, this part is more about the original paper and how to read it. A problem is it was a little bit hard to understand and I would name some parts of it a little bit different, but let's stick to the original naming and what was there. There was a procedure with just plain protocol how you make the proofs. There was so called health procedure and unhelp procedure.
00:08:50.950 - 00:09:58.890, Speaker A: So let's start with the basic part, which is just Prover, which does three polynomial commitments which are verifiable in constant time, just one operation and can be efficiently batched together, plus what's called the signature of correct computation. The signature of correct computation is just evaluation of one polynomial over one multivariate polynomial at two values for each variable. And this part at the original protocol, this part is not succinct in verification in the original protocol, like the simplest protocol given on the fifth page, requires verifier to do this verification of signature of computation just, but by brute force. The verifier also takes the S polynomial and S polynomial just encodes every constraint in the system so it doesn't depend on any witnesses, which Prover takes like witness which you want to actually hide. It just depends on the public parameters. If everyone knows the circuit, they can always derive the S polynomial and they will always get the same result. And Verifier had to do this all by himself.
00:09:58.890 - 00:11:19.110, Speaker A: This rayfire will never work in a public chain. The second part, what was called the help procedure, I would just call it Batching really the same way proverb makes now not one but few proofs over the same statement or just over the same circuit. Each of those consists of three polynomial commitments plus a signature of correct computations. Also for each of those, what the helper can do, as the helper can take this M proofs of M signatures of correct computation, which are signatures of evaluation of the polynomial, and just make one and just transform them to one subproof, which will require, for a verification, just one evaluation of this S polynomial. Just but over the different points. S just reduces the very firing complexity from linear in number of proofs to some component which is to synth, and another component which is still linear in the number of multiplication gates. So this will also not work in a public blockchains, but why it's called helped, I think it should be just rephrased.
00:11:19.110 - 00:12:15.298, Speaker A: There was succinct procedure which was called unhelp, but really doesn't have anything with help or not. Here the prover does the same way the proverb makes three polynomial commitments plus a signature of correct computation, but spends more time by making the proof of correct computation to make the verification susy. So basically now the verifier can actually run in a constant time and this is how it can be run in a public blockchain. What the paper doesn't say is you don't need to stop here. You can maybe try to make what I try to call maybe the most optimal approach is you can make M proofs because most of the application proof will make a lot of proofs anyway, and you can save on verification this way, so you can make amp proofs. Each of those is just polynomial commitments and the signature of credit computation, each as in a helper procedure. And your helper doesn't just aggregate those signatures of credit computation.
00:12:15.298 - 00:13:08.930, Speaker A: Helper spends now more time to make a succinct proof for this aggregated signature of computation. And this procedure will be actually constant time. It will be constant because constant time to verify the signature of current computation plus well, linear time is number of proofs, but still your number of proof is not huge, let's say ten. So most likely this procedure is optimal also not implemented. Original implementation, which was public and made on a GitHub only implemented this procedure, for example, and not efficiently. So this is the difficult part. The benchmarks will be in Berlin because I want to compare apples to apples, and I cannot compare highly efficient implementation of Graph 16 without first making the highly efficient implementation of Sonics.
00:13:08.930 - 00:13:47.040, Speaker A: And the highly efficient means the most efficient, which I can make up right now. So if you want go to the Key Summit, I think tickets are still available, but speaker slots I think taken or contact Anna. You should know Anna from Zero knowledge podcast. Yeah. Thank you for your patience and it's quite high level of complexity and I can now try to answer questions to just try to lower this level of complexity. Yeah. Anyone? I mean, yes, it's highly involved, but if you have a question, I hope I can answer it.
00:13:49.520 - 00:13:52.830, Speaker B: So Grot has seen some scrutiny by the.
00:13:57.200 - 00:13:57.950, Speaker A: Hello.
00:14:00.580 - 00:14:15.300, Speaker B: Okay, so Grot 16 has seen some years of scrutiny by the community and still like some awkwardness was being found recently in Zcash. How long does it take, in your opinion, for Sonic to be ready for production?
00:14:16.600 - 00:14:57.488, Speaker A: Well, first of all, regarding the Gross 16, the recent PR message from Zcash wasn't about Gross 16. We will not discuss this story. It wasn't about graph 16 in the first place. So the time between Gross releasing his paper and Zitcash actually using it in fact, and some security analysis done with taken two years. So I think now because more and more people are getting interested and security analysis is academical. Well, it's in interest of academia and very limited set of guys who actually want to do this. I think it will take at least a year.
00:14:57.488 - 00:15:48.832, Speaker A: But due to all the limitations which I mentioned before, it will take at least a year to be able to efficiently use it on Ethereum. Just due to the current choose of the curve which is available and the current pricing which well, some of you know that for last year there is a serum improvement protocol which reduces some of the elliptic curve operations from 15 to five times. And it was implemented like the optimized implementation was made for guests and parity and was actually accepted in the baseline repository. But this improvement proposal was never accepted. Even also, now every client already runs efficient implementation. So it could be in principle reduced and no one will be hurt. You will not sponsor the price, you will not sponsor the processor time.
00:15:48.832 - 00:16:00.950, Speaker A: But yes, it will take at least a year. First wait for some security analysis, make efficient implementations and wait for Ethereum to adopt a new curve so we can efficiently run on top of it.
00:16:09.020 - 00:16:59.350, Speaker C: So let's suppose that we have the perfect implementation of Sony called Zksnarc for our blockchain. We looked into different applications of zkSNARKs and it's always like yeah, it works, but we never found anything which would be like a killer application. There's definitely like Zcash, but on our site we never were able to find anything where we would use ZK snarks and that would be super great thing. So let's suppose that all of this like ZK snarks business, Sonic, ZK, Starks people invent the perfect thing, what's the killer application of this in addition to privacy and zcash what are the things? Where are the most important economic things?
00:16:59.720 - 00:17:45.520, Speaker A: Well, first of all, no one has found a killer feature for public blockchain's application yet. So this is like connected story you can reason about whether is a problem, why it wasn't found yet either because it's not necessary or just it doesn't scale or just because no one just yet has found it. But for example, neglecting the scaling and privacy and some fancy things like recursiveness, which you can do. What you can do. As a previous speaker has mentioned in each each Berlin we did the game. It just allows you to play interactive game with Snarks without consuming the gas, without consuming the storage, without well, verification of the Snark may be important, but you can get away with it. Actually, with some tricks.
00:17:45.520 - 00:18:52.900, Speaker A: So what you can do is you can make a trustless poker there is no dealer, there is no shuffling on a deck with some unknown entropy. Everyone comes into the room, they supply some entropy and then you can prove that you shuffled your deck properly, for example and then everyone knows that their entropy was actually included in a deck shuffle and they can play after it. And even game itself can be made as another Snark which will highly efficiently transform this from interactive part with like everyone submits a transaction to the public blockchain to the part where everyone suggest either as a form of state channel or as a form of consecutive proving of their turns. They can make a game. Yes, the technology well, the Cross 16 I would say mature everything else and not yet especially with the Starks which will be closed source for quite some time. Yes, killer features are great. Yes, it's why their public implementations are necessary.
00:18:52.900 - 00:19:42.530, Speaker A: So can someone, even if all of us are mistaken about the killer feature for snacks someone just finds it. It should be a way for him to implement it at the first place and just at least as a technology should be available and ideally have better toolings. You are biased. Thank you everyone for your time.
