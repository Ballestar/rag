00:00:00.170 - 00:00:29.400, Speaker A: You. All right, so it's 1130, think it's time to get started. So I'm Hernando and this is Sean. We're both developers at Parity, and today we're going to be giving you a nice walkthrough of how to get started on building with Substrate. If you want to follow along, you can just go to this tiny URL. Everything you need to get started is on there. This is going to be pretty jampacked, so we're just going to fly through, so try and bear with us.
00:00:29.400 - 00:00:48.598, Speaker A: So why are we even showing you this? So we've got two hackathon prizes tonight, or I guess for the weekend. We've got a 2000 euro grand prize for the best hack on Substrate, and then we've got another 1000 Euro for the best runner up. Now I'm going to pass it to Sean for substrate.
00:00:48.614 - 00:01:33.500, Speaker B: So first let me tell you about Substrate. So, Substrate is an open source, modular and accessible framework for building blockchains. Basically, Substrate gives you all the tools you need to spin up your own blockchain in a modular way, enabling you to be able to get your ideas out there working kind of as fast as possible. When we talk about again, Substrate provides all the core components, things like a database layer, networking, consensus engine, transaction queue and a library of Runtime modules. And it's this last point that's actually really exciting. All of these different components are built so that they can be extended or customized. So if you are someone who just wants to test different networking layer, or if you want to test different functionality or logic to your chain, you can make those modifications without having to touch the entire stack or kind of scramble within kind of like interconnected code.
00:01:33.500 - 00:02:30.010, Speaker B: Let's talk about the runtime. I think one of the most common things people do when they hack on or trying to build off an existing blockchain is they try to change some of the logic or some of the core way that the state transition function for that blockchain changes. And that's what we call the Runtime in Substrate. The Runtime in Substrate again is build modularly and it's composed of what we call Substrate Runtime modules. We provide in Substrate package of modules in the Substrate runtime module library, something called the SRML, which has things like balances accounts, fees, timestamp, upgrading, but even things like on chain governance within things like democracy and council. We even have a smart contract layer on the contracts and you can go and pick and choose from these modules what you want and add it to your Runtime. In addition, of course, you can create your own modules and that's kind of what we're going to be talking about mostly in this talk, how you can go take Substrate, build a module and basically add custom functionality to your blockchain.
00:02:30.010 - 00:03:21.014, Speaker B: So first you can easily set up the Substrate development environment. And this is kind of a really powerful tool for you this hackathon at this tiny CC link. We have a GitHub repo here which has some instructions and some kind of starting spots. We call the substrate package and it contains a script that will install all substrate dependencies on your operating system, give you a substrate node template and a substrate UI. I'll talk a little about those other two packages. So what is the substrate node template? Well, it is a working substrate node which already includes basically all of the kind of core components to get a working node running, so things like accounts, balances fees, runtime upgrades and more. So basically we packaged a bunch of SRML elements and got it in a way that it works, the node works as is, and then what is really nice about the substrate node template is that you can actually just really quickly add and remove modules as needed and create your own module to customize your chain functionality.
00:03:21.014 - 00:04:13.958, Speaker B: So if you're thinking about hacking a new functionality on a blockchain using substrate, starting with this node template and then just plugging in your own logic is actually really fast, really easy and will work. And you can find the node template kind of at this link. Again, all of these links are found on this slide, which we had at the beginning, we'll also show you at the end. So feel free, you don't have to go over here right now, but we can go back later and click these links. And we also provide in the substrate package a substrate UI which is basically a React project with a pre built UI elements for kind of some of the basic functionalities you might want to do to interact with your blockchain. Things like creating and looking up accounts, making transfers, doing runtime upgrades. It uses a custom bonds library which is built to work well with React and it's a very reactive library and you can actually using this subject UI really quickly extend and add new functionality to your own UI which may interact with the functions that you introduced to your runtime the new modules.
00:04:13.958 - 00:04:59.254, Speaker B: There's an alternative if you're more interested in using like a promise based API, something more classic, which is the polka dot JS API, and we have links to all those here and I'm going to skip over this because it's all found on the slides. So I want to talk to you about the basics of runtime development. We're going to walk through kind of the pieces of a module and kind of explain what is needed to make a new module and kind of how it works and then kind of what you'll expect to see when you're trying to build your own. So first let's get a skeleton of a module. So I'll go through each of these individual components, but you can see at the top we're importing some libraries or things that we need throughout the module. We have something called a public trait. We have a way to declare storage, declare functions, declare events, and of course, at the bottom we actually have a way to do internal functions.
00:04:59.254 - 00:05:23.178, Speaker B: These are things that might be familiar to you if you've built smart contracts before, like declaring functions, declaring events, having storage. These are all things that we also provide in substrate. So start at the top, importing defining generic types. So every module is going to have a trait called trait. And by the way, this is all written in Rust. And we'll talk about Rust a little bit more later. But if anyone this looks kind of a little funny to you, we're using the Rust programming language for all of Substrate.
00:05:23.178 - 00:05:56.682, Speaker B: But we start with a trait called Trait and this is where it's going to define kind of the custom types that your module exposes. Most commonly you'll just expose an event type. This is again, if you want to use Events, you need to have this event type there. But you can see actually our trait inherits from the system trait. And the system trait has things like origin, block number, hash, accounting, things that you might commonly expect to find in a blockchain. And so the idea of this kind of every module exposing their own trait. You have the system module which exposes its own traits.
00:05:56.682 - 00:06:25.602, Speaker B: You can inherit into your module and you can use it. And again, this is all about the modularity of substrate modules and basically allowing you to create and import and use modules within one another and do so in a generic way. Next, we have storage. So this is kind of a working code for how you might declare storage. So you can see here we have basically some simple definition for some value. This gets some value. This is a getter function we can generate that allow us to access that value within our module.
00:06:25.602 - 00:06:55.154, Speaker B: And you can see this sum value is just basically a U 32. Additionally, that's just a single value storage. We can also do a storage map, for example, from an account ID to a value. And so in order to do that, we basically just define map and we have the two types that we want to link in a key value pair. We're going to keep moving forward. You might want to declare an event within your module and that can also be done really easily. This code at the top, you're basically defining an enum type event.
00:06:55.154 - 00:07:33.782, Speaker B: We're defining basically that our event is going to emit some value stored event which has an account ID and a U 32. And we can call this in our function whenever something happens we want to tell to the outside world. And again, this I guess just works just like this. And then finally we have module functions. And this is really the core piece of your module. This is where we define all the public functions that users can call and that could be used to basically expose functionality from your runtime. You can see here that we've used the event, the value stored event and the storage item, both the value and the map.
00:07:33.782 - 00:08:20.266, Speaker B: And basically we create a simple function that says like store some value. What we've done here is every function has an origin. Origin basically defines where the call is coming from. So you can have thing like a transaction where it's a signed message from the outside world. You could also have again, substrate is built to be very generic so you can even have origins from within your own runtime which has the property root or you can have things that are not signed, things that are just general messages coming from the outside world which you might need to verify yourself, things like inherents. But for now we're just looking at something making sure that is signed, therefore it is a transaction from a user. We can from the signed message find out who the user is, we can then put the value into the single value storage or we can insert the value into a map using the sender as the key and the input as the value.
00:08:20.266 - 00:09:07.222, Speaker B: And then at the very end we can deposit an event saying hey, everything went okay, the value was stored and these are the sender and the input and then at the very end we always return okay. Finally, one other thing you might find common practice within building a module is doing internal functions. So it doesn't make sense to continually repeat the same functions over and over. Things like if you might want to do a Mint or a transfer, things like that are familiar. In tokens you might call Mint in different places within your module functions. This implement of module allows you to define basically internal functions that can be called from other modules if you make them public or can be called within your own module multiple times. So if you don't want to expose it publicly as something that can be called but you still want to introduce some new functions into your code, you can do that there.
00:09:07.222 - 00:10:18.894, Speaker B: And actually I just want to go real quick back to the and so you can see that these are all the skeleton and each individual piece kind of builds towards the larger runtime module. Yeah. So then let's talk one more thing about defining custom structs. So again, if you're building a runtime module, you might need to introduce custom types or custom structs which have your own, I guess, data format and you can do that pretty easily. One thing you will need to include is this parity codec, the encoding decode types, this derive line up the top is a macro which basically adds a bunch of traits to this struct. For example, the default trait here means that you can create this struct with some default values and basically this macro implements that default function which allows you to have that encode and decode are needed to be used to serialize and deserialize the struct data between our Runtime and other libraries like the JavaScript and even within the Runtime modules. One thing that's really important when you're building Runtime modules is to make sure that you're conscious of this verify first write last pattern.
00:10:18.894 - 00:11:12.034, Speaker B: So if you're an Ethereum contract developer, you will actually have to think about designing your module a little bit differently than if you were building a smart contract. For example, in Ethereum, if a bad transaction occurs, the state is reverted and storage untouched. So you can go, you can modify your storage whenever you want, and if at any point something gets reverted, all of those changes are undone. But in substrate, because again, you're building a Runtime module, you're much closer to the actual blockchain logic. Those state changes will persist if you return error. So I guess you might ask, why do we persist those state changes even if there is some kind of error in the transaction? Well, things like increasing the account nonce even with failed transactions, things like charging transaction fees when you're out of gas, these are things that need to be modified in the blockchain even if a transaction fails. So when you're building your modules, you make sure that you always in your code verify everything first.
00:11:12.034 - 00:11:46.574, Speaker B: Make sure that the transaction or the rest of the code underneath the verifications will not fail. And then only write the storage once you know everything will be verified. And this is particularly important when you're creating sub functions. For example, if you want to have a function which has some check and writes us some storage and you want to put that function within another function, and you need to make sure that that function that is being called which has a verification is not being called after any storage writes before it, if that makes sense. So you might have an internal function which writes a storage. You have to make sure that that cannot fail if you're calling it with another function. Yeah.
00:11:46.574 - 00:11:56.690, Speaker B: So now we're going to talk about again, I showed you a lot of Rust code there and there's maybe some interesting unique things. So we're going to talk about Rust in substrate and kind of what you might expect to see when you're doing module development.
00:11:58.150 - 00:12:24.474, Speaker A: Yes, let's get to it. So one of the first things that we saw there at the code was result. So in Rust, a result is how we do error handling. So our result contains two types. It can either be okay, which means everything went as expected, or there was an error and we need to return that to the user. So there are two ways to get access to that data within the result. The more of her both ways, what you see at the top.
00:12:24.474 - 00:13:00.754, Speaker A: So you can see that the insure signed function, which we saw earlier returned a result, so we need to be able to get the value within. So if it was okay, we'll just return S, which is sender, and if not we can return error and anybody upstream can handle that accordingly. But on the slide you might have seen a curious little piece of syntax, which is the question mark operator. So the question mark operator is essentially just shorthand for that big block of code you see up top. If you need more reading, here it is. Another thing, options. So in Rust there's no such thing as null, everything is typed.
00:13:00.754 - 00:14:04.074, Speaker A: So we have this type called an option which either contains some value, so some with a generic value t or it contains nothing, so a none. So as Sean was talking about, it's really important to not mess with state and if we have like a function overflow or an underflow, for instance, that can really mess up your chain. So we want to check this before we do anything and this function does return an option. Once again, when working with options, we can either do this whole verbose match thing up top or we've got this cool shorthand called an okay or which will take the result from the functions or the option and then transform it into a result. So you can see that we get either some good value, like an okay, or we return an error like before, but we've got cool shorthand to do it. And then we also have some hack ideas for you. So if you don't really know where to start, we've got a list here.
00:14:04.074 - 00:14:31.730, Speaker A: So if you want to do anything with non fungibles, that'd be totally cool. Governance modules, something interesting. IPFS integration would also be cool. Oracles, we don't really have anything like that on substrate just yet. Hardware wallet integration also a good idea. Burner wallets seem to be a hot topic nowadays, so if you could build something like that, that would also be much appreciated. And we've also got a couple more ideas in there if you need more inspiration.
00:14:34.470 - 00:15:30.840, Speaker B: So we want to talk about collective's workshop that we built. Basically we have a full in this URL over here we have a full kind of four to six hour complete workshop where you from end to end will build a CryptoKitties equivalent on substrate. It has all the basic kind of things of creating a non fungible, token, making transfers, doing, breeding, and basically we'll walk you through kind of all the things we touched in here with a little bit more detail and kind of handholding. You making sure that you understand how development works and really will prepare you to build new modules. Now the one thing, the caveat here is that it takes about four to 6 hours to complete this, depending on how familiar you are with Rust or substrate. But it's definitely a good reference material that you can go and use as you're developing and you might have a question like, okay, how do I do a struct definition again? Or how do I declare events? And this tutorial does go through that and explains it in a very clear way. This very much takes off of the Crypto Zombie tutorial if you guys have done that before, so it should feel similar to that.
00:15:30.840 - 00:15:59.566, Speaker B: So next steps for you is to clone and follow the instructions from the substrate package. Again, this is probably the fastest way you can get started hacking on substrate. Then of course, you want to join our Riot Channel. So the Substrate Technical channel is basically for all developers building on substrate. This has been pretty active for people who have been building outside the hackathon. We encourage you to join Ask Questions there. You'll find myself and hernando there and also a bunch of devs from parody and people who are building on substrate already and maybe will help you.
00:15:59.566 - 00:16:41.238, Speaker B: Again, this is a great way to join the community. Ask Questions, don't be afraid to ask pretty much anything, and people are here looking to answer questions at all times. And finally, with the knowledge you have here, kind of like how the modules are built and kind of the components of them, you should go and explore our Substrate runtime module library. As I mentioned, there are things like balances module, account module, governance modules. Now, having kind of understand how it breaks down and what it should look like, you can go and read these runtime module libraries and that might actually inform you and teach you how to write things correctly. And if you maybe think, oh, this is a pattern that must be used before you can look at the runtime module library and try to copy and modify the patterns you see there for your own code. And finally you should build them substrate.
00:16:41.238 - 00:17:13.842, Speaker B: This is going to be a really awesome platform and a really, I think, really interesting place to hack this weekend. So we have some helpful links. Again. This entire presentation is at tiny CC. Substrategettingstarted So you'll find this entire presentation with all the links there that we've shown you and we kind of glazed over again. Substrate package is, I think, the fastest way you can get started building on substrate. We have documentation that's a little bit sparse right now, but it's being continually worked on but has good things like recipes for these are like common code patterns.
00:17:13.842 - 00:17:41.840, Speaker B: It has things like smaller tutorials and even some reference information. If you're unfamiliar with some words or terminology we use in Substrate, you can find some of that information in the Substrate docs. We have a Substrate workshop, which I mentioned, and then Substrate Technical, which is the Chat, and these are all Tiny CC Substrate Technical Workshop docs, et cetera. Yeah, and if you have any questions, we have a few minutes and we'll be very happy to answer them. Any questions in the room.
00:17:46.040 - 00:17:48.240, Speaker A: Is anybody convinced to build on substrate?
00:17:48.320 - 00:17:48.950, Speaker B: Yeah.
00:17:51.160 - 00:17:51.908, Speaker A: No?
00:17:52.074 - 00:18:03.320, Speaker B: All right. Well, again, you can find us. We'll stick around, and if you want to talk to us, we'll be here, and we'll be happy to answer any questions and make sure that we can get you started building on substrate right away. Thanks.
00:18:03.470 - 00:18:26.740, Speaker A: Thank you. To stay on schedule. We'll take another break till midnight. Next up.
