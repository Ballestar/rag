00:00:07.340 - 00:00:30.200, Speaker A: Awesome. We're ready to start. Thank you so much for joining. We have Eric and Gawain here from Wearable who are going to do the workshop on Wearable Protocol. I'm super excited to have them here. And also thank you so much for the rest of you for tuning into this workshop. With that being said, I'll pass over the mic to Eric and Goain.
00:00:30.780 - 00:01:31.930, Speaker B: Hey guys, nice to see you here. Yeah, I'm just going to do a quick intro about Rarible Dow and then going is going to jump into the SDK and get into the more technical side of things. So my name is Eric. I've been in the Dow space since like 2018, 2019, long time right now, leading the efforts at Rarible Dow, so stewarding those efforts and helping grow the ecosystem there. We have a really great community of builders doing all sorts of different things. We have a variety of products in the NFT space, the main one being Wearable Protocol, which is an indexer, an exchange, and some minting contracts for literally any application that wants to build in the NFT space, that's the main one. And then we have some other products that we're working on, product called Hypervives, which is really cool, that allows you to infuse NFTs with ERC, twenty s and then release those tokens to the owners of the NFTs over time.
00:01:31.930 - 00:01:58.870, Speaker B: And then some other really cool things that are going to be released over the next month. So if you're interested in building in the NFT space, definitely come check out Rarible Dow. We have a really great gang of people and there's a lot of really cool things happening. So that's a little bit about my spiel about Rarible dao. So come check us out. On the Rarible protocol side. I'm going to do a really quick I'm just going to share my screen really quickly.
00:01:58.870 - 00:02:41.708, Speaker B: You can get most of the info on Rarible.org, so that's kind of the homepage for the Rarible Protocol. I'm going to share with you just this overview from our docs. So Rarible Protocol is a set of smart contracts and an indexer that's released on ethereum flow and tezos polygon. We're hoping to get up before the hackathon. I think it's in the final stages of getting up, should be up maybe this weekend, maybe on Monday, but possibly today, depending on how things go. So the goal with the protocol is to deploy it on all the chains.
00:02:41.708 - 00:03:20.216, Speaker B: So if you build on the protocol, it's a really good strategy if you want to eventually go to different chains because we're going to be supporting them all. The idea with the protocol is that it allows all these different blockchains to interact with it. So there's an indexer that indexes all the NFTs on the different chains. In your application, you can bubble up any of those NFTs from those different chains. And then using the SDK, you can interact with the NFTs, place bids and asks on the different NFTs. You can mint NFTs through the protocol using the SDK. And there's a common SDK for all the different protocols.
00:03:20.216 - 00:03:45.110, Speaker B: So it's pretty nice. So it's kind of high level architecture overview. Allows you to mint trade, transfer, burn, and also obviously query all the information about the protocol about the NFTs. So I'll stop there. Gwaine's going to jump into more of the technical side of things and yeah, I'm sure you'll have questions for him. Gwain, take it away.
00:03:46.200 - 00:04:32.752, Speaker C: Hi, guys. I'm Gwain and I'm here to introduce the wearable SDK. Kind of give you more of a deep dive understanding as to what it is, what it does. So basically, Wearable Protocol is a let me just open it up. Yeah. So Railbow SDK is a protocol with a set of Smart Contracts and indexing and Iken to allow you to interact with an existing shared order book. And it has a lot of liquidity, and all the Wearable users are at your fingertips, which we have over 500,000 users monthly.
00:04:32.752 - 00:05:26.660, Speaker C: And Wearable.com uses Wearable Protocol under the hood as the main way to communicate with the blockchain. So Wearable Protocol does all the heavy lifting concerning Minting sales, bidding and options where you can actually use your own custom ERC 721 Smart Contracts or ERC 1155 Smart Contracts. And these are compatible with our trading Smart Contracts. And in addition to that, we've also created a set of special Smart Contracts where we call them Wearable Token Contracts. And these contracts allow you to use Lazy Minting, which Lazy Minting it basically removes the need to have things like ETH to pay for gas, where the user would only need to sign a message in order to create an item. We call these items signature items.
00:05:26.660 - 00:06:23.320, Speaker C: We also have baked in royalties, so you can specify the arbitrary set of royalties that will be by the exchange contract for every secondary sale. And you can also specify multiple creators to instantly enable NFT collaborations. A little overview as to what the SDK looks. So, our SDK interface consists of two parts a Rest API and an SDK that's built on top of the API. The API basically provides endpoints for following controllers. Main controllers are assets that uses either ERC 720 Ones or ERC 1155 Tokens Collections orders. Our Lazy Mint feature ownership activities and second events.
00:06:23.320 - 00:07:18.644, Speaker C: Our Lazy Mint API also allows the item to be created and stored off chain until someone purchases or transfers this item. Only at this point does the item get created on chain. Prior to that, it's considered off chain. And then you can actually direct call. We actually avoid the Minting function that you would normally call on an NFT contract, and we use a function called Mint and Transfer. We also have different endpoints that are available for the API that are available for Ethereum mainnet testnet, Tezos flow, and we have the respective test. We also have a list of some API references for those different chains.
00:07:18.644 - 00:08:16.796, Speaker C: And we also have a reference for the SDK which at the end of the okay, so I'm going to start with a little bit of a deep dive here into what our indexer looks like. So we have this repository for our indexer in the Wearable repository. And basically what this indexer does is it provides all of the NFT metadata that's available on the Wearable.com Marketplace. And you can basically query that data using this indexer. You can query who owns what NFT. You can query how many ERC 1155 an address has or ERC 21s.
00:08:16.796 - 00:09:37.440, Speaker C: You can also query data about events, transfers, any Mints or burns, also create lazy Minted NFTs from this indexer and also post information about the way this indexer basically works is it has this listener function where this module listens for the events and updates and there is a log Listener that accrues all of these different events and deliver set up. The data model that's available within this indexer is the item which represents the NFT, which would be seen as the NFT item. And this can be owned by only one address if it's an ERC 721. And the ERC 1155 can contain multiple owners. We also have the ownership model which represents the item that's owned by an address. And this is a relationship between the owner and the actual NFT item. We also have the item history where all events from these items and ownerships such as the transfer, the Minting, the burning, et cetera.
00:09:37.440 - 00:10:44.536, Speaker C: This listener listens to these different events from the blockchain and saves this and recreates the state of the items and ownership. And we have the token which represents smart contract, also known as the collection. And this is actually on the blockchain and the items live inside of these individual smart contracts. So this is our Ethereum index. So if you're looking to display NFTs in any way, you would want to query this data, you would want to use this indexer that we have available. For now I'm going to step into the SDK and kind of what that looks like. So our SDK also want to point out that one of the most difficult parts about utilizing the SDK is it's really just setting it up.
00:10:44.536 - 00:11:40.520, Speaker C: That's probably the most difficult part. Once you get past that, everything else is super easy. You have about for a lot of the functions, they're about three lines of code. So what we've done is we created this quick start application where you can easily just get in really quick and you can set up your interaction with the protocol. So what I would suggest is probably starting with we'll share this slide as well so you can get access to these links, but this link will give you that starter application where you can get started really quickly. And then I'll just get into some of the functions that you can do with. So one of the functions that are available in the SDK are obviously being able to get items by a creator.
00:11:40.520 - 00:12:15.770, Speaker C: This function basically basically just queries the information that's available to the creator where you can actually this is what the function looks like here where you can actually get that particular item using this Await function that gets that information based on whatever blockchain you may be using. In this case, Ethereum and the contract address associated with that.
00:12:17.260 - 00:12:25.930, Speaker B: Yes, the screen you're sharing right now, I don't know if this is what you want to share, but I see like some purple buttons and it's kind of cut off.
00:12:26.940 - 00:12:29.928, Speaker C: Interesting. Okay. Yes.
00:12:30.094 - 00:12:33.320, Speaker B: I'm not sure if that's what you actually want to share, but what happened.
00:12:33.390 - 00:12:50.816, Speaker C: Is it okay, think something. Okay, let me know if this yeah.
00:12:50.838 - 00:12:53.616, Speaker B: It'S still those purple. Okay, now I see some cut.
00:12:53.638 - 00:13:11.880, Speaker C: It's good. Thank you. I appreciate it. Great. So once again, I'm just going to run back. So this is the initial items function. So you have this Await function that gets whatever items have been created by a specific creator.
00:13:11.880 - 00:14:08.700, Speaker C: In this case, we're using Ethereum blockchain, and this is the contract address associated with that particular collection by the. So we utilize that in order to get those different items. Then we have a Mint item where you can actually mint your NFT, whether that's through Lazy Minting or whether that's through the Lazy Mint functionality. So what that looks like is this function. Here is an example. So we have a Mint item that does an asynchronous and we grab the union address. So we have the blockchain name, and that's followed up by the hex address associated with the collection.
00:14:08.700 - 00:14:57.580, Speaker C: There is a token ID that's required. There's two ways that you can actually generate this token ID. We have a helper function that's available within the API. When you get a chance to go through the docs and you access the Open API address, you will be able to see these different functions. One of those functions is generate token NFT token. And you can either do it that way through the API or through the Open API, or you can actually do it within the code itself. An example of what that would look like would be here, where you would just basically generate your token ID request.
00:14:57.580 - 00:16:12.420, Speaker C: You have your collection and you would just pass in the respective parameters the blockchain name and the hex address. And then you have your mentor, which also correlates to the union address of the actual interact with the SK. And then you can just call a token ID response where you can generate that token ID request. So you can do one or two ways to obtain ID. After you get that token ID, then you can actually prepare your Mint request. And preparing that Mint request basically sends a request through the blockchain to prepare that Minting process. And then that Minting process expects a response where you would do an await and you would request use that Mint request variable in order to respond.
00:16:12.420 - 00:17:30.300, Speaker C: That response then returns and you have submit where you have where it expects the Uri, the supply. You have the Lazy Minting feature where you can at true or you cannot choose to do Lazy Minting. This is the creators array where you can assign multiple creators to an NFT based on the account. And this value here basically is a number that is right now this number basically represents the value of the contribution that that creator may have put into this NFT. So basically if let's say for instance, they put 3.84% value into this NFT, there's actually a little bit of math there. So if you were to say 3.84
00:17:30.300 - 00:18:33.200, Speaker C: divided by 100 divided by 0.1, it would give you this number what that value is the same is for the royalties well, where you would just pass that value equivalent to how many royalties creator is respected, whatever is agreed upon. So basically those royalties would serve continuous payment to these different creators throughout the secondary market. Another function that's really a main function here is being able to sell. And there's two ways that you can go about doing that. We have two functions for that. We have the spurts one where it's just a quick Mint and sell immediate.
00:18:33.200 - 00:19:43.450, Speaker C: So what this does is it gets that initial mix and it just immediately fixes it on sale where you would provide the number of supply is according to that Minting or collection. And then your usual Lazy Mint, whether that's true or false, you can set the price again the creators, what currency you would expect. In this example, it's ethereum. This would be respective whatever chain you may be on. So for instance, if you were using Bezos, we also have where you can just create a sell order where this is a different step from actually Minting and selling it in one bow. You would be able to call this sell order and you would again set your price. Obviously we're on Ethereum in this example.
00:19:43.450 - 00:20:32.520, Speaker C: And I also want to point out something here too before I'm there, but obviously we're calling the blockchain. Obviously we're getting our address associated with the NFT. But this number here it also expects is the Token ID. So we're passing in this Token ID that's been populated from our API. So we have our Ethereum, obviously Ethereum currency that we're expecting. And then we're setting our price amount and then we're setting the item ID which is our token union address, which is here up top. And then we're creating a response where we're passing in our sell order from this order request.
00:20:32.520 - 00:21:15.700, Speaker C: So, pretty simple. You can also extract different information from these properties from the order response, a base fee or a maximum amount that you would accept. So you have a threshold that you can your NFT sell for and you didn't have your response where you submit your price and your currency, you can update the sale orders as well. You can build sell orders. You can create multiple bid offers going to touch on these level. You can obviously update that information. You can cancel the order.
00:21:15.700 - 00:22:32.620, Speaker C: So if you are to Lazy Mint an NFT, let's say for instance, you want to update your base Uri in some way, then you would actually need to cancel any orders prior to creating that new Lazy Minted NFT. Also, if you have a sale order and you want to lower your price, one thing to point out, you can raise the price when you update your sale order. You can't lower the price within the sell order function. So in order to lower the price, if you needed to, you would have to do a cancel order first and then you would be able to lower the price. Then we have token transfer and you can obviously burn your NFT token. And then we also have this really cool function here that pre processes token meta as well. This is pretty much high level as to some of the functions and pointing out some of the main features that are commonly used within our SDK.
00:22:32.620 - 00:22:41.040, Speaker C: And with that, I think that pretty much sums up most of the explanation around our SDK.
00:22:51.490 - 00:23:01.540, Speaker B: I guess we can open it up to questions. Anyone has any?
00:23:10.010 - 00:23:29.530, Speaker D: That was super informative guys. It's so dense. I need to have a nap now. After this, after this session, I need to process it. I will have my questions after a nap.
00:23:31.950 - 00:23:40.510, Speaker C: Yeah, we do a lot of heavy lifting there, so it doesn't make it as difficult to interact with the SDK.
00:23:41.810 - 00:23:45.194, Speaker D: When you show like that. I just want to grab some library.
00:23:45.242 - 00:23:46.960, Speaker C: And start testing it.
00:23:47.270 - 00:23:54.014, Speaker D: There's no questions. You have to start typing something. Then you get all the answers.
00:23:54.142 - 00:23:54.818, Speaker C: Absolutely.
00:23:54.984 - 00:23:59.300, Speaker D: It's very practical. Thank you very much. It's like really no problem.
00:24:00.090 - 00:24:00.840, Speaker C: Absolutely.
00:24:01.770 - 00:24:07.318, Speaker D: I'm going to start using it for sure, but after hackathon I don't want to start now.
00:24:07.484 - 00:24:08.630, Speaker B: After nap?
00:24:08.970 - 00:24:10.310, Speaker D: Yeah, after nap.
00:24:13.390 - 00:25:05.850, Speaker B: There's a question by Dimitri in the chat there. So to put into perspective, variable is a NFT marketplace. Rarible is an NFT marketplace and has all the API to query and mint. So the way to think about it is Rarible.com is a marketplace and under the hood they use the Rarible protocol, which is what Gawain talked about here and what I showed at the beginning. Rareable protocol is the infrastructure layer. And anybody else building an NFT project can just leverage that infrastructure to build a marketplace or a wallet can integrate with the protocol or any other app can tap into that infrastructure.
00:25:05.850 - 00:25:54.940, Speaker B: What is the main difference between wearable and openc? On the front end interface, there are differences. I'm not going to go into all the differences of the front end, but on the back end, the Rarible protocol is the infrastructure layer. It's open source. Anybody can use it. I think the Rarible Protocol is kind of one of the big differentiators, is that we have this tool available, and OpenSea has an API, but nothing's open source, and it's closed source. So if you're interested in building kind of the future of the NFT space and you want to build an app that is a bit more resilient, then relying on openc API might not be a great idea.
00:25:56.510 - 00:26:39.190, Speaker C: If I can point on something too. I think one of the really big differences are actually the fees. When you're looking at gas, when you're looking at protocol fees, there's a big difference there from the wearable side. It's much lower from that end. And also another big feature is the ability to set royalties really at wherever you want them to be. There's really no guidelines as to where those may want to sit when it comes to collaborative NFTs.
00:26:54.720 - 00:26:58.690, Speaker B: All right, I guess that's all the questions, unless there's any more.
00:27:02.420 - 00:27:03.650, Speaker A: There's one more.
00:27:04.100 - 00:27:29.610, Speaker C: Does wearable also feature a property? Yes, we do. So like attributes? Yes, we do respect attributes. We actually use the same metadata standard as OpenSeas. So as long as you're familiar with that, then you're good. No problem. Yes, they do show up on.
00:27:32.300 - 00:27:46.848, Speaker B: Awesome. Thanks a lot, guys. Appreciate this. Thanks, Gwain. And yeah, hopefully we'll see you guys around. Let us know if you're building on our protocol. Are you guys on Rinkabee testnet? Yes.
00:27:46.848 - 00:28:20.810, Speaker B: Answer is yes. So we also have a grant program in addition. So for any teams building on the protocol, we have grants available through the Dao. One success story that I just wanted to mention, coco NFT last year, they hacked in this hackathon. They then got a grant from our Dow, subsequently raised their seed, and now they're onto their second round of you know, it's pretty exciting. We're there to help you guys out, and we have funding available as grants post hackathon. Thanks, guys.
00:28:22.300 - 00:28:50.590, Speaker A: Awesome. Thank you so much, Eric and Gluaine, for taking time out of your Friday oh, it's actually Friday afternoon for you right now, but to present this workshop to our hackers and thank you to the rest of you for tuning into the Rarible Workshop. We do have another workshop starting right now hosted by Austin from the Ethereum Foundation. So definitely go tune into that right now. And otherwise, I hope you all have a great rest of your day or evening or morning, wherever you are.
