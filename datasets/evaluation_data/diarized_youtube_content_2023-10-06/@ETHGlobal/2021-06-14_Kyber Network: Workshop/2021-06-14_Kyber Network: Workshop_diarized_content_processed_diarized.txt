00:00:00.090 - 00:00:29.986, Speaker A: Kyber's DMM or the dynamic market maker. So before we start off, I'd just like to say that I'm really glad to be part of this DeFi hack fund, the hack money. So I'm really looking forward to all the different DApps that everyone will be building. So to get kickstarted just a little bit. Background of Kyber so Kyber is an on chain liquidity protocol or the dynamic contribute and access. Before we start off, I'd just like to see that in Kyber 3.0 our next major milestone.
00:00:29.986 - 00:01:17.474, Speaker A: This vision has been expanded further to represent the protocol as a liquidity hub that aggregates liquidity from a wide range of sources to power instant and secure exchange for any application. So as you can see in this slide over here, we're already undergoing our 3.0 upgrade. Kyber 3.0 will transition Kyber from a single protocol into a liquidity hub of purpose driven protocols that are catered to different DFI use cases. This is the biggest change to Kyber's architecture and token model since its inception and will be implemented over two phases which we call Katana and Kaizen. So the first release Katana has already been released out there and it includes the new KNC token.
00:01:17.474 - 00:02:05.670, Speaker A: We have done a token migration quite recently and an upgraded KyberDAO as well. And included in that is of course the DMM. So in this diagram over here, you can see that the DMM is one of the liquidity protocols to be developed and be part of this liquidity hub. And alongside that there could be a professional liquidity protocol, a derivatives protocol and other unique protocols that can be part of this hub. And the great thing about this is that makers and takers have the flexibility to be able to interact directly with these different protocols or to be able to use a single endpoint to interact with all these protocols in aggregate. Right? Yeah. Now I'm here to talk about more about the DMM.
00:02:05.670 - 00:03:15.734, Speaker A: So the DMM is DeFi's first dynamic market maker, a next generation AMM designed to maximize the use of capital by enabling extreme high capital efficiency and reacting to market conditions to optimize returns for liquidity providers. It has two main features which we call the amplified liquidity pools. Here in this amplified liquidity pool or a programmable price curve, we introduce a m factor which significantly amplifies the pool's reserves. The curves are still a constant product, so if you're familiar with the x times y equals a k constant product function but of virtual balances instead of real balances. So thanks to the virtual balances which are amplified significantly from real balances, the DMM pools can achieve moderate spread and slippage rates compared to an AMM using the simple constant product function given the same capital. And the other major feature is the dynamic fees. Trading fees are basically adjusted dynamically according to on chain market conditions.
00:03:15.734 - 00:04:39.058, Speaker A: This is measured by moving averages over a period of time. So in a volatile market which means that it's a higher than usual volume fees are automatically increased to an optimal level, reducing the impact of improvement loss for the liquidity providers. Now for periods of low volatility, fees decrease to encourage more trading for takers. So TLDR, for amplified liquidity pools, less inventory, you are still able to provide high liquidity and for dynamic fees you are able to achieve a higher earning potential and reducing the impact of impermanent loss. So the core idea of token swaps has been with Kyber since the beginning and is reflected in the design of the DMM where you can swap from one crypto asset to any crypto asset. So this idea where you can swap or have this token swap functionality that can be embedded into any application enabling the value exchange to be performed seamlessly between all parties in the ecosystem, end users can swap tokens conveniently across many different interfaces while developers can build innovative applications helping to build a world where any token can be used anywhere. So now with the DMM, which is completely open and fully permissionless, anyone can contribute liquidity, anyone can create pools with different N factors.
00:04:39.058 - 00:05:57.470, Speaker A: It is fully on chain which simplifies integration, especially with if you have your own smart contracts, as talking to smart contracts like the DMM is straightforward and there are no external Oracle risks because the DMM or has no use of Oracles. So, talking more about the first major feature of the DMM, which is the amplified liquidity pool, here in this slide we have an example of a $100,000 trade on a pool with a 1 million of liquidity, right? So with a typical AMM, which is the normal x times y is equal to K AMM, you would be experiencing a 11% slippage with that 100K trade in that 1 million pool. But in the DMM and using a amp factor of five, which means you're amplifying the liquidity from 1 million to 5 million, then you would be experiencing instead a 2% slippage. And for a higher amp factor, let's say 100, then instead of a million, you would have 100 million. You would then be experiencing a 0.1% slippage instead. And this is with a worth of a trade, right? So with this, most pairs then can enjoy like 15% to 30% better capital efficiency.
00:05:57.470 - 00:07:11.042, Speaker A: Most pairs, especially like stable coins or pairs with very strong correlation, can have amp factors from 100 to 200 x that will provide way better slippage compared to typical AMMS. And for pairs like Wpdc and ETH, which has some correlation, then you can still achieve a higher capital efficiency of five to ten x by providing a let's say five to ten m factor value. So the key determinant of the potential capital efficiency and risk of impermanent loss is the relative price stability between the pool's assets. There is room for improvement in capital efficiency and negations of impermanent loss by using different amplification factors which will result to different price curves and fee models for different pairs. So, in this table over here, we try to quantify the price stability between a pair of token x and y, as you can see here on the left side. So in this table over here, we have amplitude and sigma mean. So amplitude means that the max ratio divided by the mean ratio across a given period.
00:07:11.042 - 00:07:58.738, Speaker A: A high amplitude means that it represents a bigger shift in the max price ratio between the two assets. And for the sigma mean, it is the standard deviation of the mean of the ratios. So a higher deviation, the greater the volatility between the ratios. So you can take the first example over here, which is ampleforth, and ETH it has a very high amplitude and sigma mean, which means that there is weak to no correlation. And therefore, if you create a pool using this assets, you need to use a m factor that is not so large, maybe one to, let's say 1.3 to be able to cover the price swings due to the volatility. So the price swings could be quite large, but for assets like WBTC and ETH, where there is some correlation.
00:07:58.738 - 00:09:15.194, Speaker A: So let's just say in theory that when BTC price increases or decreases, the price of ETH follows as well, then you can use a moderate amp factor of, let's say five or so, since they have some correlation, and therefore you can expect the swings of price not to be as volta or as large. Now, for stablecoins, which have very strong correlation or similar assets such as the stablecoin USD pegged assets like USDT and USDC, you can definitely use a very high amp factor, like up to 100 or 200, because the volatility or the price difference from $1 does not deviate so much. Therefore, you can definitely use a very high amp factor for these types of assets. So in essence, the lower the amplitude invariance the higher potential there is for high levels of capital efficiency and low impermanent loss. Which means that pools of a given token pair, the stronger the correlation between the assets, the higher the amp factor we can use when creating a pool. And here we just want to visualize how the DMM's price curve looks like, or how the constant product function looks like. So the first formula over here is something that's quite familiar.
00:09:15.194 - 00:10:19.678, Speaker A: If you aware of, like a uniswap or sushi swap or the other typical AMMS for DML, we can define it in the same way. Except that X Prime Times y prime is equal to x k prime, and we define the variables as such, where you multiply x times y against A, which A represents the amplification factor, and K prime, we can represent it as K, the constant product times amplification squared. And therefore, using this formula, we can construct the diagram on the left. The purple line over here is the constant product function and the black line over here is the real balances. So again, the purple line is the virtual balances and the black line is the real balances. So in this graph, since the total reserves are amplified, price is bounded, which means that it does not scale to infinity like a typical AMM with an amplified curve, there is a max and min price. So once the price hits the upper or lower boundary, then one side of the reserves are depleted.
00:10:19.678 - 00:10:50.522, Speaker A: Meaning that, let's say you have an amplified pool and the price of the token increases so much. Then once it reaches that upper price boundary, then you can expect the token inventory of the pool to be completely depleted. And users can then trade only in the other side. Which means selling tokens back into the pool. Here we have a more concrete example. So on the left we have the DMM pool and on the right we have curve finance. So on the left on the DMM pool, we have a TVL of 10 million.
00:10:50.522 - 00:11:36.586, Speaker A: But we're using a amp factor of 100, which means that the amplified liquidity or the effective liquidity is actually 1 billion. And on the right, on curve finance, we're comparing it against three pool which is comprised of three different stablecoin assets, DA, USDC and USDT. And this comprises of a total TVL of 1.9 billion. And here we're trying to trade against two stablecoins USDT and USDC using the same amounts. So 30,000 USDT and seeing how much USDC we'll be getting back. So you can see that the rates or the values that are being returned are quite similar, right, despite the fact that the amount of TVL in the DMM is significantly lesser than the curve pool over here.
00:11:36.586 - 00:12:27.930, Speaker A: And this is due to the amplification mechanism that we have for the DMM. So, going back again to dynamic fees, right, we described earlier where trading fees are adjusted dynamically according to on chain market conditions. So again, in a volatile market, which means higher than usual volume, fees automatically increase to an optimal level, reducing the impact of impermanent loss. And for low volatility, fees decrease to encourage more trading, which results to more fees being collected from the optic in volume. And we believe that this offers better flexibility compared to fixed fee tiers on other platforms. Here's another example, and this is taken from the analytics page of our DMM and you can find this in info DMM exchange. We're seeing information about an ETH KNC pool over here.
00:12:27.930 - 00:13:10.470, Speaker A: So I'm trying to add liquidity into this pool with an amp factor of 1.9, which again means that whatever liquidity that is in this pool, we are amplifying it by times 1.9, right? And because of this amplification, the price again is bounded. So we have a min and max price both in KNC and ETH. So you can see here, like in ETH, it would be four as the max price and the min price would be 24. Once it hits any of these boundaries, then one side of the liquidity is completely depleted. And based on this M factor, the UI as well will give you a range of the fees or the dynamic fees that will be used in this pool.
00:13:10.470 - 00:13:33.870, Speaker A: So it ranges from zero point 15 to 0.6%, meaning that 0.6% is charged during high volatility trading periods. And the total liquidity for this pool is 3.7 million. And for the past 24 hours, it's about 200,000 in volume. And from that 24 hours, about $530 has been collected in fees.
00:13:33.870 - 00:14:17.066, Speaker A: And this represents an annualized return of $5.17 of fee over liquidity, or basically like what you would say like the Apr, right, for this type of pair with this amplification factor. And just also to note is that for any pair, you can actually have many pools with different amplification configurations. So this is just one pool that has an amplification factor of 1.9. You can have another that has five, another with an amp factor of ten, et cetera. So it depends on the liquidity provider's strategy. So now we get into the more interesting part of how you can actually integrate with the DMM through Smart Contracts.
00:14:17.066 - 00:15:09.306, Speaker A: We have a JavaScript SDK as well, and I'll cover that briefly later. Yeah, so how can you integrate with the DMM? Right? And one way is, again, through Smart Contracts. You can write your own Smart Contract and directly interact with the DMM from there. If you've ever interacted with Smart Contracts of Kyber, Uniswap, SushiSwap and other exchange contracts before then, this should be quite familiar to you. To keep things simple and brief, we'll cover functions that fetch pool and rates information and functions that execute orders or trades. So the first example over here is how you're able to fetch pools from the DMM. We have a function called Get Pools, which you can call from the factory and get an amplified pool as well, so as there can be multiple pools for a given token pair.
00:15:09.306 - 00:16:23.270, Speaker A: Again, like, for example, a pair of ETH KNC, you can have several pools that represent different factor configurations, and you can fetch all of this pool addresses and determine which pool would be most suitable for you to query rates, do trade execution, or do liquidity provision. Yeah, so just call this Get Pools method and just input the token addresses of the pair that you'd like to query. Like, let's say in this example, we have USDC and USDT, and it should return all the pools that is available. And if none exists so far, then an empty array is returned. For each token pair, there should be at most one unamplified pool, meaning only one unampplified pool can exist for a token pair. And this pool basically exists as some kind of like it's a type of like a typical AMM where the X times Y is equal to K, constant product function and supports the infinite price range. And in theory, because prices are infinite in this an amplified pool, then there should always be liquidity in this pool.
00:16:23.270 - 00:17:25.686, Speaker A: Here's an example contract where I'm trying to fetch rates from the DMM. So in this example, I've already imported the contracts of the router and the factory because I need those different contracts to be able to call different methods from them to be able to fetch information. And I'm doing this between two stablecoins USDT and USDC. So I'm going to demonstrate three different methods of how you can fetch rates. The implementation will be in the next slides, but yes, three different methods over here. So the first method over here, which is our recommended method, is to query for the best pool off chain and pass it as an input into this function. So basically, using the get pools function, you can get a list or an array of different pools and then from there you can determine which pool has the most liquidity or whatever your criteria is and pass this instead as an argument into fetching rates.
00:17:25.686 - 00:18:12.650, Speaker A: So, one of the functions for fetching rates is called get amounts in. The other counterpart is get amounts out. Get amounts in means that I want to get the equivalent amount of a destination token given an exact amount in. So in my case, it would be 100 USDT, whereas for the function get amounts out, I want to get exactly this amount out given a, let's say some minimum in. Yeah, so the only inputs that you'd need is the pool addresses. Again, something that you will be able to determine off chain. And then the token path which is constructed from the previous slide from the source token USDT, and then the destination token USDC and it should return an array of amounts.
00:18:12.650 - 00:19:19.866, Speaker A: The second method is to use the Anamplified pool and while it is convenient, it may be suboptimal. And the reason why again, is because an amplified pools, even though it represents a typical constant product function curve, it might not be giving you the best liquidity, but at least you'll be assured that there will be liquidity there because prices scale to infinity. And it's as simple as just getting the single address because only one token pair can have one amplified pool and passing this as the pool path into the gets amount in function. Now, the third method is to use a pool found in the first index of the pool array. And if there's no pool found, then it just returns an empty array and therefore you return like zero rates. So instead of sorting through the different pools returned by the factory, you will just get the first index and use that as a means for fetching rates or doing trades. But again, this could be suboptimal because the pools in get pools, the pools returned are unsorted.
00:19:19.866 - 00:20:42.502, Speaker A: Therefore you might not be using the pool with the best liquidity or it could be even a pool that has no liquidity left. So instead there could be a combination of using the first method and another method that we describe here, which is logic where you can have in a function on chain or you can have this kind of logic off chain. And basically you are getting all the pools using get pools from the factory to fetch all the pools for a token pair and then you're sorting it by liquidity. This can be done by fetching each pool's KLAS method which is basically whatever pool returns the highest KLS value has the highest liquidity. So the best is to do this off chain where you sort the different pools returned and get the pools with the highest KLS and pass it as an argument into the first method of fetching rates which is this one over here. That would be the most gas efficient way but if you are needing to do this fully on chain then you can do a combination of the recommendation over here, this one and then passing it to a function as the list of pool addresses to use in your fetching of rates or trades. This examples over here, you can find them in the Docs site in Docs DMM Exchange.
00:20:42.502 - 00:21:56.180, Speaker A: The full list of examples are there as I've demonstrated here as well in the previous slides. So here's an example of swap execution where I'm trying to trade from one E to die. We have many different swap functions and it depends on what you're swapping. So in this case since I'm swapping from ETH tokens then I'm calling the swap exact ETH for Tokens but if I'm swapping tokens to ETH then I'm calling swap exact tokens for ETH and if I'm swapping tokens to tokens then I'm calling swap exact Tokens for Tokens. So for the arguments over here, so I don't have to go into them in detail, you can just find them in our documentation in our site. Yeah, this can be said as well for any token where you would want to utilize different pool paths so for example I would want to trade from USDC to WBTC pool and then lastly to ETH. So I would just need to find all the different pools and pass that as the path into this function over here and the rest would be typical like for any swap function that you've seen previously and for a description of the other arguments you can find them in our site as well.
00:21:56.180 - 00:22:50.226, Speaker A: Yeah, but again if you ever interacted with SushiSwap or Uniswap then this kind of argument should be quite familiar to you as well. Now for tokens that have fees built in, we call them fee on transfer tokens. So tokens for example, that could be like a gold or some stablecoin where when you transfer them some fees is taken out of the balance from your transfer. This is supported in the DMM as well. We just have a very long function name for this which we call Swap exact Tokens for Tokens or Swap Exact ETH for Tokens supporting Fee on transfer tokens. I know it's a very long function name but it's quite descriptive and it has the typical arguments except that it supports this Fot or Fee on transfer tokens. Of course for the DMM you are able to call functions to add liquidity directly as well.
00:22:50.226 - 00:23:37.230, Speaker A: So you can create a pool using the third argument as the amp factor. So we define them in basis points over here. So in this example, I'm creating a pool for dying USDC with an M factor of 50. And if I want to create the pool and add liquidity at the same time in a single transaction, then I can specify this argument as well, where I specify the two different tokens, the M factor to use and then the liquidity to be provided. More description again about this function can be seen in our docs website. So one thing to add is that like other AMMS, once you add liquidity you will be receiving an LP token back or what we call a receipt token that represents your share of the pool. And for each different pool, again, each different pool can have different factors.
00:23:37.230 - 00:24:34.942, Speaker A: You will be receiving a different LP token. So you can have an LP token for an ETH KNC pair that represent an N factor of five and an LP token that represents an M factor of ten for the same token pair. For removing liquidity we use the ERC 2612 pattern, the permit pattern where you can just approve or sign a message that allows the contracts to spend your LP tokens to burn them and retrieve your liquidity back. Yeah, and the usual arguments that you just need to supply into this function which you can find more in our docs website. And for the JavaScript SDK, just to go through it briefly, it has the typical functions where you can query rates and information and for you to be able to construct a trade as well. So we have an NPM package called at dynamic. SDK.
00:24:34.942 - 00:25:30.630, Speaker A: If you just install this you will be able to make use of the libraries to for example fetch token data and pool data for example, like this example over here where I'm fetching pair data and from there I can get the mid price of the two tokens in that pair so that I don't elaborate more. You can just find more information about this in our docs website but yeah, you can use this in your hack as well. Now to wrap up, the DMM is committed to security, so we are audited by chain security and is insured up to 20 million. We have an ongoing bug bounty as well. So if you find any bugs in our DMM contracts please let us know and you'll be rewarded accordingly for that. And some brief statistics since its inception. We deployed it last April 5 and it's been a bit of around two months.
00:25:30.630 - 00:26:22.790, Speaker A: There has been a total volume of 100 million, with about 18 million in TVL. But with the different amp factors in the different pools, we have a total amplified liquidity of over 1 billion in the DMM. We have an ongoing proposal as well to deploy the DMM on Polygon Network and this covers the liquidity mining as well on that network. So this proposal should be concluding in the next few hours. So if you have some KNC staked in the Kyber dow and you haven't voted yet, please vote on this proposal and you can look forward to be able to interact with the DMM both on ETH and on Polygon Network as well. So for our bounties, we have over 8000 worth of prizes in KNC to be distributed to the different hacks. First prize is $3,000, et cetera, et cetera.
00:26:22.790 - 00:27:17.990, Speaker A: If you're not one of the top three projects that have won a prize, as long as you've hacked something on the DMM, then you could be eligible for at least $500 with your project, right? But of course, prizes are to be awarded at Kyrie's discretion. And just to give you some ideas about your hack using the DMM, you can for example, create a yield farming or yield vault integration using the DMM itself. Or maybe it's LP. Tokens. You can utilize the LP tokens in some interesting way. One great thing is to build a better visualizer of the different N factors and price ranges of the different pools such that you can visualize them, have a graph and see what are the price boundaries, for example, just throwing out ideas over there. And hopefully you can build something quite interesting in this hackathon.
00:27:17.990 - 00:27:53.380, Speaker A: So here are some final references like to the exchange documentation, et cetera. We have an intro video about the DMM as well to describe whatever I've talked in this presentation. You can find it in Kyber's YouTube channel and if you want to read about it, you can just visit our blog at blog kyber network and find more details about that there. So that's it, that's it for my talk. And yeah, I hope that I'm really looking forward to all the different hacks that you guys will be building. If there are any questions, then I would gladly look into them right now.
00:27:53.750 - 00:28:00.806, Speaker B: Yeah, I think we can maybe handle the three questions that are in the Zoom chat now.
00:28:00.988 - 00:28:56.866, Speaker A: Right? So the first question is how does the DMM compare to unisoft B three? So the concept of the DMM and unisoft V three uses a concentrated liquidity concept and for us we use an amplification concept. The concepts are actually quite similar, right? We're basically being able to amplify balances from real balances, right? But the implementation is completely different. So one significant difference in implementation is that for the DMs case, each configuration is a different pool, whereas for uniswap they have a single pool. But your position is represented as an NFT. So I think that's like a brief summary of it, but yeah, concept wise I believe that it's quite similar. Yes. So the second question is so amp factor is an extra parameter that is based on perceived expected stability of the current price from swappers.
00:28:56.866 - 00:29:36.118, Speaker A: Yes. So you basically can configure this yourself. It really depends on your strategy. So, for example, if you believe that certain assets have strong correlation, like for example, maybe ETH and something that is very closely to ETH, let's say like wrap, etc. For example, then you can have a large amount of amp value over there because again, by having a large amp value, then it means that you are having a more concentrated price swing. Right? It doesn't deviate between that price range. Okay, here's another question.
00:29:36.118 - 00:30:29.542, Speaker A: All exchanges are showing different USDT rates. Can you explain why it was okay, so the reason why there are different rates from across the different DEXs or decentralized exchanges is because there's this kind of like inefficiency when it comes to on chain, right, where in order to update rates, you need to do a on chain transaction. So let's just say you have a difference of price between uniswap and Kyber. If, let's say the price of uniswap is much higher than Kyber, then somebody will be able to take advantage of that by selling on uniswap and then buying on Kyber. But in order for the rates to normalize or like to be as close as possible, then people would need to do on chain transactions for this. And as you know, transactions are only mined like every 15 seconds on average on ethereum. And it really depends on the market activity as well.
00:30:29.542 - 00:30:52.640, Speaker A: If the market is quite volatile, then you can see price differences to be quite large between the different DEXes. And this is where that's why there's a lot of Arbitragers and Bots that are taking advantage of this different price rates because it's a very profitable situation for them. Basically. I guess that's all the questions.
00:30:53.090 - 00:31:31.538, Speaker B: Yeah, that's all the questions. And if anybody has any more questions for Anton, you can find him in the sponsor Kyber network channel in Discord. And I want to give a very big thanks to Anton for taking such a jampacked session. There was a lot of content in just 30 minutes. It and yeah, it would also be great if you could share these slides in the sponsor channel so that everybody can go through these slides again in their own time. But yeah, big thanks for joining us today, Anton, and thanks everybody else for joining.
00:31:31.634 - 00:31:34.500, Speaker A: Thank you. My pleasure as well. Thank you everyone. Great.
