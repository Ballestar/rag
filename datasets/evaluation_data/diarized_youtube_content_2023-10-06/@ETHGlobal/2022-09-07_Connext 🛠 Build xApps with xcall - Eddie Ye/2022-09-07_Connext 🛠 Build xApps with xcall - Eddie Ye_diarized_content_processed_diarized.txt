00:00:07.690 - 00:01:11.550, Speaker A: All right, thanks for tuning into this workshop, everybody. I'm Eddie, an integration engineer at Kinext, and I'll be running us through some context around Kinext and also jumping into some code to show you some examples and get you on your way to building your own cross chain application. So, first of all, I just want to make it clear that this workshop is relevant to the Amaroc network upgrade, which is, like, connects V two of our protocol. And some of you may have already been aware of the V One. You may have already used the bridge here, which was originally called X Pollinate. This is a bridge UI that's built on top of the V One protocol that allows users to transfer funds from one chain to another. This V One was built on this system of locally verified mechanism where there are two counterparties involved that kind of verify each other, so there's no third party validators that are introduced into the system, and so no additional trust assumptions.
00:01:11.550 - 00:02:13.590, Speaker A: So this kind of mechanism is very secure. But there are some drawbacks. And one of the major ones is that local verification doesn't support fully generalized data passing between chains. And in a nutshell, that means that you can't conduct authenticated cross chain calls, but you can do unauthenticated cross chain calls like swaps on uniswap, since that function is not protected and anybody is allowed to call that function. So what we really wanted to do for the last couple of months was to solve for this generalizability issue with our system and solve for other pain points that this affects, like UX and basically pull the potential for cross chain operations forward a bit. And we actually found a way to do this through two major evolutions of the system. The first part was how to figure out a way to enable the generalized data passing, but also retaining trust minimization.
00:02:13.590 - 00:03:11.814, Speaker A: And so optimistic verification gave us a pathway here. In this kind of construction, which is used by optimistic bridges and roll ups, some arbitrary data is relayed from the origin chain, and a window of opportunity is given to off chain actors to call out fraud. So after that window passes, and let's say no fraud is called out, the data is considered finalized on the destination chain. So the beauty of this system is that it only relies on the uptime of any single honest actor at any point in time to prove fraud. And that's a pretty reasonable assumption at scale, but it also allows us the ability to check for authenticated data, which is what's needed for fully generalized crosschain calls. But like with everything, there are trade offs. And for optimistic verification, it's latency because you need to allow watchers some challenge period to prove fraud.
00:03:11.814 - 00:04:03.530, Speaker A: It necessarily increases the latency of transactions. So there's no way for this to be instant or even immediate. Okay, so step two to this evolution was to figure out how to beat this trade off space. And the way we can do it in a decentralized system is to introduce modularity, since we never want to give up trust minimization. But at the same time we want to have as many nice properties as possible. We can actually separate the monolithic bridging stack into different layers that specialize toward different use cases. So for transactions that require authentication, like they need to check the origin of the transaction, those go through the fully optimistic fraud window and then afterwards any arbitrary call data can be executed.
00:04:03.530 - 00:05:17.470, Speaker A: For transactions like a simple transfer of an ERC, for example, a network of off chain actors can actually determine that it's non fraudulent, it doesn't require authentication, and then actually short circuit the fraud window to provide fast liquidity without waiting for the full fraud window to pass. So these two things combined is actually the basis of Connects to V two, it's a modular interoperability stack that supports fast and slow liquidity based on the use case. So how do we build on this? Well, first it's probably important to introduce the main interaction point with Connect as a developer Xcall. Xcall is a primitive that we created to sort of mimic the low level call method of solidity. The call method of solidity passes data to another contract for execution and Xcall basically just does that but for crosschain. So you can pass call data from one origin chain to another destination chain and have any kind of call data be executed on that chain. Okay, so let's see this all in practice.
00:05:17.470 - 00:06:02.426, Speaker A: And the best way to actually do this is to start at our Doc site. So this is docs connects network. We're going to be diving into the developer Quickstart, but if you want to explore the site a little bit, basics will give you an overview of the system in general, a couple of nice diagrams and a little bit of a deeper dive into what's actually happening under the hood. But for the purpose of this workshop, we're going to go right into the developer Quickstart and immediately you can see that we have two Quick starts here. One for a TypeScript SDK, which you can use if you're trying to build like a front end or some kind of node application. And there's also a contracts Quickstart which is fully solidity. And this is what we're going to dive into mostly today.
00:06:02.426 - 00:07:00.542, Speaker A: Since the SDK is generally just like a nice wrapper around some of these functions, we can explore most, if not all of the considerations around X calling through the contracts only. So with the contracts Quickstart we have a couple of sections here with different kinds of X calls and different features like callbacks. But you can go through this in your own time. It basically covers what we're going to talk about during this workshop. But it's always nice to see this stuff in practice. So we're actually going to run through the code here, and I'll do some explaining about what's happening with the code. So we're going to look at the Zap starter kit here, and after you've cloned this and you've taken a read through the README, the best thing to do is actually well, actually, let's start with the README.
00:07:00.542 - 00:08:00.470, Speaker A: So this is a starter kit for crosschain Zaps, and we're describing three different kinds of transactions that you can do, but there's only really like two different categories. One is without call data and one is with call data. So without call data, it's like simple transfers, like transferring ERC 20s from chain to chain. You're not supplying any encoded call data to be executed on the other chain, so this can be easily pushed through fast liquidity. The other category is with call data. And so the other two examples in this repo are the unauthenticated and the authenticated cases, which we already kind of touched upon why there are differences there. So we're going to jump into the simple transfer first because it's a really easy way to see what's going on with all of the Xcall parameters and how you actually do an Xcall in solidity.
00:08:00.470 - 00:09:11.722, Speaker A: It'd be nice to kind of talk about this too, if I can make it legible, but this is basically what the high level flow of an Xcall is doing. So you as a developer, you're building, in most cases, two contracts, a source contract on the origin chain and a target contract on the destination chain. The source contract is what your users are going to interact with or your Zap is going to interact with. And then the target contract is going to host the function that you're actually trying to execute on the other chain. What happens is the source contract is going to Call Xcall, which is a function in the Connects contracts. And then Connect is going to route that transaction through its network of relayers and routers and things that are happening under the hood, and finally push that over to the destination chain to execute the Call data that you supplied it with. So in the case of this simple contrived transfer example, we're actually only messing with a source contract.
00:09:11.722 - 00:10:05.950, Speaker A: And the reason is because as I mentioned, this transfer is a call to X call that doesn't contain call data. So if you don't have call data, it's because you don't actually have a target contract on the other side to call. And this is actually a really simple use case, but it's actually one of the most used ways that you'll probably use Xcall, because sending ERC 20s from chain to chain is a really foundational sort of operation. So diving into this transfer will be very useful for us. So let's go ahead and do that. I've already cloned the Zap starter kit here locally, and I've done some setup already that will save us some time. But I'm going to run through everything as if I hadn't.
00:10:05.950 - 00:10:34.230, Speaker A: So we're on main branch here. And the way this is structured is let's look at the blueprint here. There's a source file that contains all the contract interactions. This maps to the contract Quickstart in the Docs. And then there's an SDK interactions. Which maps to the SDK quickstart. So we're going to be looking at this right now under Transfer, the single transfer sole contract.
00:10:34.230 - 00:10:56.906, Speaker A: So let's open that up. Yeah. Contract to contract interactions transfer. And there's our contract. So before we do anything, let's actually make sure we set everything up. So we run the make install. Before we do that, we actually need to make sure that we have Foundry installed.
00:10:56.906 - 00:11:35.960, Speaker A: So Foundry is like a smart contract testing and deploying toolkit. It's really fast and really nice. A lot of people have been starting to use this. And so even on our team, we're starting to use Foundry quite a bit to test our contracts and do a lot of the things around deploying and verification. So if you don't have Foundry installed already, I'm not going to walk you through it because there are some nice instructions already in their repository for you to do that. And we'll also download make, which is a build tool if you don't already have that. So back to setup, we're going to do a make install.
00:11:35.960 - 00:12:31.930, Speaker A: So make has a make file, which basically is sort of like a scripting tool where you can write different kinds of commands that you want to shortcut with make. And so make install here is just actually going to run Forge install and install all the modules that we've defined that we needed. So the way that Forge works is you can install different repositories and it will actually pull them in as sub modules. So in your Git Modules folder file, you'll be able to see that there's a bunch of these sub modules that are pulled in. And NXTP is the one that we're working with Connect. And that is the main one that we're going to be working with today. So when you run the make install, it's going to do a Forge install, it's going to pull in all those sub modules.
00:12:31.930 - 00:13:05.650, Speaker A: And we'll also want to run Yarn to install some dependencies that we'll use since we're also using a little bit of hard hat for its tasking. Now the first step after that that you'll want to make sure to do is to actually copy the env example into a local env. So I've already done that here. The env looks like this. You have an origin RPC. You have a destination RPC. And these are URLs that you can grab after signing up with an RPC provider.
00:13:05.650 - 00:13:55.158, Speaker A: So this can be like Alchemy or Infura. And you'll also want to supply your private key of a wallet that you have some testnet ETH to work with. And then Ether scan key here is pulled from Etherscan IO. It's just a way for us to easily verify the contracts and be able to kind of read and write from a nice UI that Etherscan provides. So after I filled out my env, it looks like this. Obviously my RPC keys and my private key are, you know, you can feel free to hack me, but the only thing that will happen is I'll be a little sad that I lost some testnet ETH. And once we have this filled out, we can basically just run these unit tests and make sure that everything works right off the bat.
00:13:55.158 - 00:14:54.054, Speaker A: So these unit tests are using Forge and they're going to be in this test folder here. So everything that has to do with the transfer smart contract is going to be in test transfer. The test contract is going to be here and we're not really going to walk through a lot of the Forge testing, like syntax and stuff like that because it's probably better for you to do that on your own and also do a little bit of a deep dive on how to write good tests. But this will be a nice start to look at and we can see that all of these tests actually ran successfully, so we're pretty good to start with here. Okay, so another thing to consider is running integration tests. So we can run this as well, but just as an explainer of what this is doing. It's using forge's forked mode.
00:14:54.054 - 00:16:15.460, Speaker A: So the forked mode is basically creating a local copy of a blockchain based on the RPC that you're providing. So in this case, we're going to provide the testnet origin RPC URL defined in our N file. So what it's going to do is it's going to create a local version of the optimism Gorely blockchain and we're assuming that this blockchain already has the connect contracts deployed to it, which is true. And so when you fork this blockchain, it has the Kinex contracts and all of your tests that point to the address of the connects contract are actually running against a fully emulated version of that contract. So we have a couple of forked integration tests that can be run using this command and it's actually the unit tests and integration tests are all in the same file. So if we scroll up here, the transfer test unit is a contract that contains all the unit tests and then transfer test forked is a contract that contains all the forked tests. So in our make file, when we're running these test commands, it's just matching this string and then running the test contracts against the match.
00:16:15.460 - 00:17:26.394, Speaker A: So that's the difference between running the unit tests and running the fork tests. Okay, so before we get the deployment, I'm actually going to want to dive into the transfer contract code here. So as I said before, this is like a really simple and contrived example, but it shows you how to actually do a cross chain call and it's actually relatively nice because you can see the flow of an ERC 20 from an origin chain to a destination chain. So what's happening here is we've defined this transfer contract. We've also defined this event here, which we'll emit later just for tracking and for testing purposes. And we also have a variable here called connect and it is a type interface, connects handler. So we pulled in this iconnect handler from the NXTP repo and we also pulled in call params and Xcall ARGs, which are crucial structs that we need to build in order to make the X call later on.
00:17:26.394 - 00:18:19.018, Speaker A: We also pulled in an ERC 20 from Soulmate just so that we have a token that we can work with. And in the constructor here, we're going to pass in the address of the connect handler on the chain where this source contract is going to be deployed to. So basically, this transfer contract is going to Xcall into the connect contract. Xcall is a function of the connects contract. So we need to pull that in here. So the only actual function that exists here is this transfer function and it's going to take in the destination address, which is like the wallet address that you want to send the funds to. On the destination side, it's going to take an asset, which is the ERC 20 that we're trying to send.
00:18:19.018 - 00:19:21.998, Speaker A: And then it's going to need a reference to the origin domain ID and the destination domain IDs that we're working with. So these are similar to chain IDs, but they're different in the sense that every bridge kind of has their own mapping of domain ID to chain ID. And for connects, that's no different. We have this number that maps to the Gorely chain and then this number that maps to the optimism gorli chain. So these are values that you just have to look up and we have a reference to that in our documentation that you can easily reference. So back to the docs page, we have a testnet reference we will recommend for everybody to build on the production testnet contracts, since staging is mostly there's no guarantees that it's stable and it's mostly for internal team testing purposes. So if you open up the production testnet contracts, you'll see that we have Gorely and we have the optimism Goreli here and the chain ID and the domain ID.
00:19:21.998 - 00:20:51.130, Speaker A: So for most of the Xcall stuff, we're going to be caring about the domain ID because these are connect specific IDs. So these are what we would be passing in to the function calls here. So origin domain, we're actually going to use optimism Gorely as the origin here and we'll use Gorely as the destination for running the stuff today. All right, so in this function, we're instantiating the ERC 20 token with the address that we passed in of an already deployed token and we're immediately checking that the user has already approved some allowance of the amount that we're sending over. So this is assuming that the user has gone to the token contract in some way and basically said, hey, I'm going to allow the transfer contract to use my funds and send it to Connect because the flow of the funds here is that the user sends it to the transfer contract. The transfer contract which is happening here with this transfer from and then the transfer contract approves the transfer to Connect contract and then the Connect contract is going to take those funds and send it across to the other chain. So there's like two approvals that have to happen and this contract is assuming that the user has already approved.
00:20:51.130 - 00:21:25.094, Speaker A: So that's what that requires doing and this function will reverse if that's not the case. And then the token will be transferred over to this transfer contract and then this transfer contract will approve. It will approve the transfer to Connect. And here's where basically all the exciting stuff happens. So we've pulled in the Call Params already. The structure that I mentioned before, we can kind of click into it to see what are the fields in the struct. So we can kind of ignore most of these.
00:21:25.094 - 00:22:12.440, Speaker A: For now, we're going to swing back to these and kind of deep dive into what all of them mean. But for now, the important ones are the two field, which is what we already passed in like the destination wallet that is to receive the funds. And this could be the same address as the user that's interacting with the contract, which is usually the case actually. So if you're trying to send funds and you're interacting with a contract to do so, you're usually trying to send it to yourself on the other side. So that's why we're passing two in here. Call data is empty because again, we're not messing with call data here, we're just sending funds and then origin and destination domain are passed through. The rest of these will swing back to in a moment here.
00:22:12.440 - 00:23:10.490, Speaker A: So Xcall ARGs is the other struct that is actually the only argument that's passed into Xcall later on. So Xcall ARGs just kind of wraps Call Params and it also has a field for the actual transacting asset. So the address that we passed in and the amount that is to be sent. So also the amount that we sent in over there and we'll also dive into this origin mint out a little bit later. But essentially once you've put all these fields together and if you're sending funds, you do this like approval dance, all you have to do is say connects Xcall and pass those parameters in. Okay, so let's actually deploy this contract and see it in action. So to do this, we're going to consult the README again and you can see that there's a deployment command for this.
00:23:10.490 - 00:23:48.658, Speaker A: So we'll copy that. Pull up a terminal here and we will just fill in the placeholders that we have. So this one is nice and easy. It's only asking for the address of the origin connect handler. So remember that this is a constructor argument we are passing in. Where is that? We're passing in the address of the connect handler and that's why we need to supply it here. So again, we will go back to the docs here and remember, I said that we're going to be using Optimism Gorely as the origin chain.
00:23:48.658 - 00:24:31.330, Speaker A: So we're going to go under Optimism Gorely and look for the connect's handler address, which is this, paste that in, send it off and Forge will do its thing. Okay? So you can see that it's doing some stuff to actually deploy it. And at the end here, it'll give you a transaction hash of the deployment transaction as well as the contract address itself. So we can take a look at this on the Optimism Gorely explorer. So here's the contract. It is deployed. We see contract creation success.
00:24:31.330 - 00:25:23.644, Speaker A: It's all good. So this is our transfer sol on the actual Optimism Gorely testnet blockchain. And what we really want to do now is we want to hit this transfer function with all the right parameters, which should send off an X call. And we want to be able to see that this token flow is going from my wallet to my wallet on the other chain. So, consulting the README again, we have actually a way to do this sort of live testnet testing with some hard hat tasks. So we'll copy this, paste that in and then okay, so my recording cut off, but we'll continue from exactly where we were. Basically, I just filled in these values.
00:25:23.644 - 00:26:11.440, Speaker A: So origin domain, we got that from the testnet reference, origin being Optimism Gorely. So we took this origin domain, we pasted in here, same thing for destination domain. We scrolled up here and pasted that in and then for the contract address, this is the transfer contract that we just deployed. So the one here and then the token address is the token on the origin side. So back to optimus and gorli the test token, six ad. We pull that in here and then private key from the M and then amount. This is exactly one test token.
00:26:11.440 - 00:26:53.052, Speaker A: So hopefully when we run this, I'm going to take a note of how I have one test in my Optimism Gorely account. And then in my Gorely account I have 99.9. So I should see one test basically flow from Optimism Gorely to Gorely. And we'll send this off and twiddle our thumbs for a little bit while we wait and we can see that it's going to mint again to my origin account. So I should still have one test at the end of this. It's doing the approval again. And you can actually approve like a max amount.
00:26:53.052 - 00:27:58.304, Speaker A: So it doesn't have to always do this approval, but this task is handling it anyway, so it doesn't matter the transaction hash is in and we got a successful transfer. So, before we take a look at the wallet, I want to show you how to actually track the status of this X call. So it's in flight right now, technically, right? So if we go to tracking an X call, we have these subgraphs. So we deploy a subgraph for every domain and these are basically like off chain indexes that keep track of events that are emitted from contracts and these are not stored on chain. These can always be queried off chain and stored in an efficient manner. So these subgraphs allow us to kind of query for events and we have some example queries here and links to the subgraphs for each chain. So we're going to look at the origin chain first, this subgraph, and we're going to take the query and we'll paste it into the query tool here and it's going to want that transaction hash.
00:27:58.304 - 00:28:32.364, Speaker A: So copy that over, paste it in, send it off. Okay, awesome. So this subgraph captured the event from the origin chain. So we can see that the chain ID was 420, which maps optimism. We have a Transfer ID which is very important for us in a second here. And you can see that it has a bunch of other fields that might be interesting to you. You might want to sanity check that the transacting amount you sent was correct, that this was the right, ERC, 20.
00:28:32.364 - 00:29:25.324, Speaker A: But this Transfer ID is really what we were looking for. So this is a unique ID tracked across the connect system and it's a unique ID for each X call. So with this you can key into any of the events that are emitted with the Transfer ID and basically track the flow of that X call. So if we go to the origin subgraph now and we copy this query that's already available and we paste that in and then you'll notice that this one wants a Transfer ID. So we'll copy the Transfer ID and paste that in. And because this is Fast Liquidity, the transfer has already shown up on the other side. So this status here it says executed.
00:29:25.324 - 00:29:51.880, Speaker A: This means that the execution of this X call was completed on the destination chain. And so my wallet now should have on Gorely one more test than it did. So it was at 99.9, now it's at 100.9. Cool. So if you look through some of the fields here, you might notice that the transacting amount this time on the destination side is actually 0.5% less.
00:29:51.880 - 00:30:47.652, Speaker A: Exactly. And that's because routers, the liquidity providers in our network take a small cut for their troubles of helping to relay your transaction across. So what happens with Fast Liquidity is that we're not exactly circumventing the fraud window completely. Somebody has to take that lock up and the routers end up doing that. So what the routers do is they have liquidity on the destination side that matches what a user wants and they say hey, okay, I can provide you this liquidity up front and basically just front that capital for you. So the user ends up getting their funds immediately or almost immediately on the other side, which was evidenced by this execution. While the routers they take up the fraud proof lockup.
00:30:47.652 - 00:31:32.324, Speaker A: So for their troubles they will eventually get reimbursed, but for their troubles they do take a 0.5% fee of that X call. And I wanted to run through the subgraph because the subgraph is really nice, you can build things on top of the events that the subgraph saves. And so now I will make your life a little bit easier by showing you the testnet MROC. Connect scan UI where you can actually provide a transfer ID in the scanner site. And we have like a little UI that shows you the transaction status. So it was X called, it was executed, it has yet to be reconciled.
00:31:32.324 - 00:32:12.308, Speaker A: The router is still in the lockup window and they haven't been reconciled yet. But the user is done, their involvement here is complete at Execute and they've sent their funds and they've received their funds across the chain and it took all but 3 minutes. Cool. So that basically sums up the transfer contract. Before we go into the with call data examples, I just wanted to dive into some of those other X call params. So I skimmed over these because most of them were, they didn't really matter for this case. Sort of like safe defaults that we have.
00:32:12.308 - 00:33:34.220, Speaker A: But I do want to dive into them. So for agent here we're passing in message sender because this is the address that's allowed to execute the transaction. On the destination side, what happens normally is we actually have another network of off chain agents called relayers that are they're basically the ones that are helping to do the execution of the call data on the destination side because somebody has to do that, somebody has to initiate the transaction. So when you send a transaction to the other side, a decentralized network of relayers, we're using Gelato for this purpose will actually do the execution and normally the relayers will want to take a fee for that as well because they're going to have to pay gas and whatnot. But you as the user who is sending the X call, you can also supply an agent and in this case we supplied the message sender so the user themselves in case the relayers don't execute. So you can always execute this yourself, pay the gas fee yourself, potentially pay a little bit less gas fee because you're paying for the relayers to do this on your behalf. So it's something that they have to do and you pay them a little bit to do that.
00:33:34.220 - 00:34:04.340, Speaker A: And so that relayer fee comes into play here. But on. Testnet. Our relayer gelato is not taking any fees just to make experimenting a little bit easier and building a little bit easier. But on mainnet and beyond, when we launch, relayers will expect this to be enough to cover their costs. So not only cover their costs in terms of gas, but also to give them a little bit bump, a little bit of a bump for their troubles. So that's agent and that's relayer fee.
00:34:04.340 - 00:34:43.960, Speaker A: And then for recovery. This is a fallback address. So in case the execution fails on the other side. So let's say the contract that you're calling was not implemented correctly, or the call data you're passing in is not correct, then it might fail on execution. And if you send funds along with that X call, if you don't have a recovery address, then those funds could potentially just be in limbo forever. So you have a recovery address which connect will automatically send the funds to in case of reverts on the destination side. So for slow here is related to this fastpath.
00:34:43.960 - 00:36:01.230, Speaker A: So this is an option for the user to say hey, actually I don't really care about getting this quickly so I don't want to pay routers the 0.5% fee, I'd rather keep all of the funds and just wait out the optimistic fraud proof window and they can totally do that. You set this to true and instead of this transaction having taken 3 minutes and executing almost immediately we would still be waiting for it to happen. But it's up to the user's discretion how fast they want those funds and whether they care about saving on that fee. Receive local is a pretty complicated one so this kind of involves diving into the different types of assets that are in a bridge's ecosystem. Why don't we go ahead and do that? Because we have a diagram in the documentation here, it's in the FAQ and basically I'm not sure if this is big enough but here we go. So we have a couple of different asset terminologies here canonical representation, adopted and local.
00:36:01.230 - 00:36:43.550, Speaker A: What do they all mean? Well the parameter here is receive local. Okay, so keep that in mind. So basically what bridges do when they send tokens is they're not actually giving you the exact ERC, 20 token that was deployed on one chain and then giving you the exact one on the other chain. So there's always this concept of a canonical domain for the asset. So the canonical asset is always the one that was originally deployed. So in token one's case in this example the canonical asset is in domain B so this is the canonical asset. In token two's case, the canonical asset is in domain A.
00:36:43.550 - 00:37:45.976, Speaker A: So when you bridge this token over so let's go from domain B to domain C. With token one, the bridge is actually locking this token up and minting a representation of it on domain C. So what the user gets or what the user is going to be delivered by the bridge is a representation asset. And sometimes this asset is actually different than the asset that is used often on that chain. So if connect bridges, let's say connect bridges like USDC over and there's like a next flavor of USDC, it might not be the case that next USDC is the exact ERC 20 that's used in most DFI applications on that chain or that users want to use. So there might be another flavored version of USDC on that chain that's mostly adopted by users. So that's what we mean by an adopted asset.
00:37:45.976 - 00:38:49.910, Speaker A: And in this case, we want to deliver to the user the token that they actually want to use and it's usually going to be the adopted one. So what happens is under the hood, connect also has a AMM that is basically a stable swap between the different bridge flavors, the connect flavored asset and the adopted asset. So at the end of the X call, before the token is delivered to the user, it'll actually be sent through an AMM which can incur some slippage and then the user will be delivered the adopted asset. And in some cases, let's say in token two case here, from A to B, the next flavor version of this token on domain B is actually the adopted version. So maybe everybody is using the next token two on all their DApps. And so in this case, there is no need for an AMM and there's no need to incur that slippage. So the user gets exactly the token that they want and they're cool with that.
00:38:49.910 - 00:40:09.644, Speaker A: But in these cases where the token is actually not the adopted one, they can say, hey, I actually either don't want to incur this AMM slippage or I actually prefer to have this next flavored version. That's where this parameter comes in. That's where this receive local can be set to true and then the user will actually receive the bridge flavored asset instead of the adopted. So this is a way for them to kind of manage their own swapping across an AMM. If maybe the AMM that we would use under the hood with connects is not one that they want to use or they want to wait for the slippage conditions to be favorable for them, they can always select to receive this local bridge flavored version rather than the adopted. Okay, I think the last one here or the last two here are related to the callbacks. So callbacks are another really cool feature that we've introduced very similar to Asynchronous programming, where you have a function call, it goes off to fetch a remote resource and you don't want to halt everything that you're doing to wait for it.
00:40:09.644 - 00:40:58.504, Speaker A: So in Asynchronous programming, the callback is a function that will be called once that resource is fetched is completed. So in this case, the callback is the latter part of that sort of flow. It's the function that can be called if you choose to supply one after the destination side has been executed. So this can be really useful if you want to confirm on the origin chain that something happened on the destination chain. And we'll dive into an example of this later. But essentially this is a way for you to respond to results of the execution on the destination chain. And the callback fee is basically the same thing as a relayer fee but for the backward direction.
00:40:58.504 - 00:41:51.950, Speaker A: So whereas the relayer fee you're paying for the execution on the destination chain, the callback fee you're paying for execution of the callback. Awesome. So let's take a look at the with call data examples. And actually if we look at the README you'll see that we have the unauthenticated and the authenticated versions and they're both using the source and target contracts in the repo. So these ones get a little bit more complicated but it's also really nice to dive into and see what we're talking about. So with these examples we are going to be using call data. So again, it's going to be a very contrived example and there are some example use cases for why you want to use call data.
00:41:51.950 - 00:42:20.436, Speaker A: It's pretty obvious honestly and why you would want to use authenticated calls. But for this we're just going to look at the code directly. So we'll go into the with call data. We'll actually start from the target contract. So let's do this. Let's pull up the target contract. And basically the goal here is now very similar to this diagram where we are going to be deploying a source contract and a target contract.
00:42:20.436 - 00:42:50.144, Speaker A: The target contract has the function that we want to call from source. So in this case, the target contract has a function that we want to call. So let's start with the unauthenticated. There's an update value unauthenticated function that takes in an integer and basically updates this state variable in the contract with the new value. That's all it does. For the authenticated version it does the same exact thing. But we'll get into that why that's a little bit different.
00:42:50.144 - 00:43:24.952, Speaker A: So for unauthenticated that's basically it. For the target contract, the constructor is going to take in, well actually let's pause on this. Let's look at the source now. Now knowing what the target function is. So the source contract is going to pull in the same things as the transfer example. We're going to ignore this callback stuff until we get into the callback stuff later and we're also going to ignore promise router things because that's also callback related. But essentially now it's like the same thing as the transfer contract.
00:43:24.952 - 00:44:08.072, Speaker A: You pull in the connects address. You give that as the constructor argument and then the function that we're calling here is now an x chain update instead of a transfer. We're still taking the same things. We're taking a two address, the origin domain, destination domain and now a new value and whether this call should be authenticated or not. But since we're looking at unauthenticated, we're going to assume that we're passing false here. So now the differences are we are no longer going to pass any, we're not going to send any funds in this so we don't have to send any amount and we don't have to do that whole approval dance with the funds. So we're only sending call data.
00:44:08.072 - 00:45:03.224, Speaker A: In these examples, what happens is you have to encode the call data and you have to know what the selector is on the target function. So there's a nice way to kind of do this using the catchack function. You pass in the name with the function signature of the target and that's basically like your selector. And then this abi is able to encode that selector with the new value that you pass in. So at the end of all of this, the call data here is encoded call data that is going to be executed on the target chain and what's going to be executed is this selector that you selected and the value that should be passed in. So the X call, the Xcall arg, the call params, all this is basically the same. Just the arguments change a little bit.
00:45:03.224 - 00:45:55.464, Speaker A: So the two here is now still going to be passed in. But when we call this function, the two has to be the address of the target contract, not the wallet address for example of the last thing that we just walked through. And then the call data is what we're just passing in through here. Encoded call data, same for origin domain, destination domain, same things for the agent and recovery force flow now has to be well actually force flow for the unauthenticated example is very similar to the transfer. So we can choose whether we want to take the slow path or not. But in this case we're just going to pass in false for the unauthenticated example. So it will go through the fast path and then for receive local we're not even messing with funds here.
00:45:55.464 - 00:47:23.056, Speaker A: We're not even messing with tokens here, sorry. So we're going to keep that as false and then callback will ignore that for now and then callback fee, relayer fee, all zeros for testnet and I actually realized that I didn't touch on the destination min and origin min out but in this case they're zero because we're not messing with funds. However, for the transfer case, these were amount divided by 100 times 97. So essentially we were saying that the user would be okay with a 3% slippage here if that were the case. So 3% or more then the transaction would revert on the other side and then this would basically be the slippage for the AMM on the other side, on the destination side and then this would be the slippage for the AMM on the origin side because recall that there are actually two potential AMMS. One from the token going out and then one from the token going in on the destination side. This diagram doesn't show it, but if you imagine sending from domain A to domain C, the user could be sending the adopted token here, going through the AMM, which is the origin Min out, and then having that also have to pass through the AMM again on the other side, which is the destination Min out.
00:47:23.056 - 00:47:45.410, Speaker A: So there's two kind of like slippage numbers here that could potentially apply. Sorry. So back to this. We are done with these call params. The only differences were really these call params. The only differences really were the call data and the two address has to be the contract. And then we pass all this in.
00:47:45.410 - 00:48:31.100, Speaker A: We're not sending assets, so we can just use the zero address here, zero for the amount, zero for the slippage, and then we call Xcall again. So now this contract, we have to deploy the source and we also have to deploy the target. I'm not going to run through those now because it's basically the same flow and the commands are essentially the same here. So if you scroll down to deployment again, you'll see that now instead of deploying one contract, we deploy two. And for testing, we're also just going to use this hard hat task. So it's going to call that update function. We're passing mostly the same things, but now a new value to update.
00:48:31.100 - 00:49:29.616, Speaker A: And after you've deployed these contracts and you call this function, it should basically do all this stuff of encoding the call data and sending it through Xcall. And for the unauthenticated example, it's basically going to have the same sort of timing since we didn't pass force flow equals true there. And if we were to look at the subgraphs again, we would see that it's executed. But now we would be able to look at the target contract and see that this value is updated. So we might record some more videos that actually show this one in action, but already this one's getting a little bit long. So you can try this out yourself. You can look at the deployed target contract on Etherscan and check that the value is actually updated to whatever you wanted to update it with.
00:49:29.616 - 00:50:23.010, Speaker A: And remember that variables in solidity are instantiated with zero. So this value is originally going to be zero and you should pass in anything but that to check the difference. Yeah, and that'll be really cool to kind of run on your own. And then the other one that I wanted to run through is the authenticated example. So for this case, after you've deployed source and target, it's actually really nice. All you have to do is call this what am I looking at? All you have to do is call this updated value authenticated function instead of the other one and what it'll do is to do that is to call x chain update but pass in true for authenticated. So you'll see that with this if statement, if it's true it's actually going to call the authenticated version rather than the unauthenticated version and everything else is the same.
00:50:23.010 - 00:51:50.728, Speaker A: However, with the authenticated version a couple extra things come into play. So for target, in order to uphold this authentication and make sure that the origin sender was actually the sender that you're expecting and that it came from the right place, you should write a modifier such as an only. Executor modifier here that checks for the origin sender and the origin domain and checks against what the contract knows is the origin contract and the origin domain. So when you deploy this Target contract you're actually going to pass in the address of source and the origin domain of the source so that you can always check those values. And the difference here is that you're also going to pull in this library that we have which has a origin sender and a origin after you pass in the message data to these functions it will tell you who the origin sender was and what the origin was. So after running these checks in a modifier you can be pretty certain that these were from the right place. And then the last check is to make sure that the message sender of this target functions execution was actually the connect executor.
00:51:50.728 - 00:52:39.928, Speaker A: So the connect executor is just another contract. It's just another part of this flow that we kind of didn't really touch on. But it's like the end part of this flow that does the actual execution. And we want to make sure that it's only the connect executor that does that, because if you don't check this, anybody else could send a transaction to this function and kind of, like, spoof these values. So you need all three of these to uphold the authentication if you have any on the Target function. And for us that authentication is in the form of this only executor. We're only allowing the origin sender as the source contract.
00:52:39.928 - 00:53:47.408, Speaker A: So what this does effectively is say nobody else can update this value through this authenticated function except for the source sole contract on the origin domain that we expect it to be in. And yeah, that is pretty much it. I know that last part was a little bit hand wavy, but I think that going through this example yourself and actually reading through the starter here, you'll get to a very good understanding of what's happening there. And the authenticated calls are where things get exciting, because then you're able to do things like changing Dow ownership contracts, cross chain and many other exciting functionalities that aren't enabled by just public functions. Right? So that's going to be in the contract quick start and you'll want to go to authenticated here. This should be able to run you through the full examples and you should be able to run that on your own. Actually, I realized the last part that I did not touch upon is the callbacks and I think this might be an important thing to not miss.
00:53:47.408 - 00:54:54.456, Speaker A: So the callbacks here are basically you'll notice that in the transfer contract we said that address zero was the callback because we don't expect to use the callback function. But here we're actually passing this address, the source address as the contract that implements the callback. And you'll see if you scroll down a little bit that there is a callback function which is part of the I callback interface. So any contract that is going to implement the callback has to implement it with this I callback interface. And callback is one of the abstract functions defined there. So what we're saying here is the source contract is also going to be the implementer of the callback. So when the value is updated on target, it's going to return this new value and that new value is actually going to be sent back to the origin domain, to the source contract and handled by its callback function here.
00:54:54.456 - 00:55:45.592, Speaker A: So data is going to include that return data. So what we can see is that new value. Now we just have to decode that data and we get the value that was updated over here. So this is what I mean by you can confirm that things happen or you can pass State back from the destination domain after something has happened. So this is a really neat piece of functionality that will require basically understanding everything else in addition to the callback stuff because you'll need to use everything including the callback fees. But it's really an interesting way to basically have State and data passed backwards through the call as well as forwards. And again, we're not going to run through that today because we're kind of low on time now.
00:55:45.592 - 00:56:47.260, Speaker A: But the callbacks example here will run you through how that works, what the differences are between the code of using a callback and not and you'll be able to track the status of those X calls as well and it'll be really cool. Cool. So I think that basically covers what we wanted to talk about today. The last, last part of this is just to shill the Connect ETH online hackathon prizes that we're sponsoring. And so basically if you want to build anything cross chain, please consider using these X calls and you can win some fat stacks. I believe the prize categories are one category is just for any generic use of Crosschain. So build a unique application and make sure it's using cross chain functionalities that we expose through Connect.
00:56:47.260 - 00:57:37.580, Speaker A: And then the other category is if you see a protocol that's only on a single chain at the moment that could benefit from being crosschain, go ahead and fork it and add in an Xcall and see if you can augment that protocol to be crosschain compatible. And then the third prize pool is actually a shared pool between all hackers that even attempt to run an Xcall. So fork this repository, read through the starter examples and run the Xcall. And if you are a hacker with a registered wallet with ETH Global and you do a successful Xcall, everybody that does so will basically split that pot. Awesome. So that's basically it. Hope you guys learned a few things, and I wish you the best of luck.
00:57:37.580 - 00:57:38.200, Speaker A: Bye.
