00:00:00.250 - 00:00:45.802, Speaker A: So yeah, thanks for having me in here. And I think this talk is now the proof that I should really sit together more with the Cornell guys because we are pretty much going in the same direction here. So I'm talking about Wendy, which is another fair ordering approach. It came out of a slightly different use case. So in Vega we are building a derivative trading system on a dedicated chain which is tendermint. And our main goal is we need to convince traders from a centralized exchange that decentralized is an alternative. And that especially means if any flash traders steal more money or get more money out of them than they do on a centralized exchange, they're not coming.
00:00:45.802 - 00:01:55.410, Speaker A: So we need to pretty much minimize mev as much as possible. And in this use case, democratizing isn't really an option because if we democratize rewards the traders still stay at a centralized exchange because they make money and more money there. And the problem we are having here is that the price of decentralization is that we have a much larger attack surface. So currently if we don't put in protection then flash traders have actually an easier game on a DFI system than they have against a centralized exchange. And we have spent 30 years plus work in doing consistency, but much, much less work on what's a good order in the last time and only now has the problem big enough that people really care about that other thing we want to do is we want to have minimal latency impact. So we need a practical protocol and if we waste a lot of time then we are too slow compared to a centralized exchange and again the traders will go away. There's another issue which is sort of turning around the economic arguments.
00:01:55.410 - 00:02:46.366, Speaker A: So for other reasons we want economic control over our validators. So we want to set economic encouragement for things like diversity and performance. If they make most of their money by mev and not by validator fees that the network can control, then trying to do this is a little bit like trying to control smugglers by tax breaks, it just doesn't work because this is not where they make the money. So that's another reason why mev minimization is important for us because we want network control on what validators get and we want them to get the fair share. So there's no doubt there. But we want to link policies to economy. Our goal is a little bit different than from what Avi described.
00:02:46.366 - 00:03:15.994, Speaker A: We want to integrate the protocol into the consensus layer as a modular add on. So we don't want to mess with the consensus code, but we also don't want to run an oracle. We want this to be part of the consensus code. A little bit like cusper is for ethereum to add finality. We want an add on that adds fairness. And our original chain is a BFT style protocol so we built on tendermint. I have one slide on how this would hold for ethereum in the end.
00:03:15.994 - 00:03:59.670, Speaker A: And our goal is a tool set for kind of everyone. So we heard this argument before, there's no point in being selfish and trying to have one chain that handles front running because we all suffer if this is a real or perceived problem. So as many solutions as possible, as many tools as possible is helpful. State of the defense. So there is a little bit of protocol archaeology. There argue already mentioned causality. There also are leaderless protocols which solve a lot of the problems by just not having one validator or miner setting the whole order, but having a group already baked into the protocol.
00:03:59.670 - 00:04:34.930, Speaker A: That's also the work I did back then in my PhD thesis. Honey Badger is doing that now, but they never really took off. So the BFT style got more into fashion. So now most implementations are stuck with leaders and we need to handle yeah, and then we have the block order fairnesses. And what I'm talking about now is the evolution of Wendy, which is the fairness framework, which also includes causality in there. And I have a couple of links to most of the papers I mentioned. So for further reading you can see that on that slide.
00:04:34.930 - 00:05:23.026, Speaker A: So we already saw some fairness definitions. So I have the luxury of being able to go over this very fast. The one thing to add here is we have a bunch of impossibility results. So the standard thing, if everybody saw or if all honest validators saw A before B, then A has to come before B isn't always decidable because there's loops. So that led to block order fairness. So if you have a loop, put the whole loop into one block and let the application sort it out. But that too runs into a problem that we need potentially unlimited block size since these loops can be arbitrary size even in a synchronous system.
00:05:23.026 - 00:06:04.770, Speaker A: And then we have a backup definition that is timing based on local clocks. So it doesn't add as much fairness, but it doesn't lead to a paradox. And our first approach in Wendy was we go for the block order fairness when we can and if we see we are now growing too big block, we are running into trouble. We switch back to the weaker definition of fairness, resolve a deadlock and then move back to the original protocol. Once we had that, the next idea was ECTA was to expand this to an actual framework. But first set up and model. So we need a known set of validators.
00:06:04.770 - 00:06:57.042, Speaker A: So I wouldn't call this a permission network, but we are not registrationless. Validators need to say here I am and they need to know of each other. We assume an existing consensus layer and we're trying to be as flexible as possible where we fit in and we assume a multi use chain. So we assume that we have a blockchain that does different things, in our case different markets, if it's ethereum, different smart contracts. And not all transactions need fairness and some transactions may need a different kind of fairness. So if you have different definitions of fairness, different markets, different smart contracts may actually have a different perception of what fairness they want. So we have a framework protocol that then can encompass different definitions of fairness both between different applications and switch for one application.
00:06:57.042 - 00:07:41.438, Speaker A: Like I said, for the block order, if things go wrong, we can switch the definition. First phase is a dissemination phase, that's a one round protocol that just makes sure that every potential block creator gets all the information they need to make an order. There can be timestamps, if you have trusted time, we would throw trusted time in there. For block order, everybody just throws in the order in which they source things and sends this to the potential block creators. Then we compute blocking sets. So this is the transactions that need to be delayed because it cannot be fairly used right now. And the new thing is we also now have a reveal thing.
00:07:41.438 - 00:08:25.790, Speaker A: So the nice thing, if we have an ordering protocol, if we link the ordering with the commit and reveal, we can actually reveal at an earlier point than we could for normal commit and reveal protocol. So normally I can only reveal once the order is set. So once a transaction cannot be reordered anymore. Now I can reveal as soon as I know by the fairness rules I cannot be front run anymore. And one of the problems of commit and reveal, especially in non finalizing chains, is that it can take some time until I'm allowed to reveal. This combination makes it actually very nice that it can start revealing earlier. So the two techniques are not competing, they're actually working very nicely together.
00:08:25.790 - 00:09:08.566, Speaker A: And then the more practical things, blockchain interaction and post processing, that's getting the whole thing actually to run on an actual blockchain, which is then the less exciting but very important and very tedious work. So the blocking and revealing rules, and this is where the whole fairness definition comes in. So everybody can, every market or every smart contract can have their own fairness definition through these rules. And there's essentially three and a half important rules. So a transaction is blocked. If given what I know now, there can be a transaction that I haven't seen yet that may have been scheduled earlier. If this happens, I cannot put this transaction into the next block.
00:09:08.566 - 00:09:47.606, Speaker A: It needs to wait. Then we have transaction dependencies. So given what I currently know, a transaction I know about but haven't executed yet, has to come before my transaction. I can then either put them in the same block or if one of them is blocked, both of them need to wait. And then we have revealability given the current knowledge I have, a transaction now has precedence over all newly generated transactions. So this is where I can open the commit and reveal. And weekly revealable is not as strong and I haven't found a very nice definition of it.
00:09:47.606 - 00:10:20.162, Speaker A: It just means now you need an insane amount of network control to still front ren me. And for all practical purposes, this is just not going to happen. Now, policies, examples. Fair block order was mentioned already. So if all honest parties see T one before T two, then T one must be in the same on earlier block. And then the post processing will sort this out. And this is then the rules for when it's blocked, what the dependencies is, and I'm not reading the rules for you can look at the slide maybe later.
00:10:20.162 - 00:10:49.206, Speaker A: So this implements fair block ordering by just defining those four rules. Okay, slide. I forgot policy requirements. So there's a couple of things I need to think about. If I build a policy, what I want to do has to be measurable. So we heard it also before. If I need a trusted signed clock, or if I want to have sender time, then I need a trusted signed clock.
00:10:49.206 - 00:11:18.182, Speaker A: If I cannot measure sender time, I cannot put this into a policy requirement. Ideally, loop free. Ideally we should be efficiently terminating so that no transaction blocks forever. And ideally, once a transaction is unblocked, it should stay unblocked and not go back. Now, as in all requirements in the Byzantine world, there's usually workarounds. So the fair block order already violates two of them. So we have a couple of things.
00:11:18.182 - 00:12:05.410, Speaker A: Measurability is sort of unavoidable. Loop freeness is solved by putting stuff in the same block and then let the application settle things efficient terminating can be solved by detecting if you're not terminating and then switching the policy and monotony. We can tolerate a non monotonous protocol if we don't want to do commit and reveal. If we want to do commit and reveal, then this is getting difficult. Timed fairness. The other one I mentioned, it's just a different set of rules. And just to show that we can get completely different capitalistic plus Social Security, that's essentially the ethereum model with an add on that if you wait long enough, you didn't need to pay that much.
00:12:05.410 - 00:13:14.714, Speaker A: So the transactions your blockbare transaction that either paid more or is already waiting for a very long time. So we can actually be relatively creative on what examples we want, as long as we can formulate them in these three properties and then the protocol will support them. Now, performance measurements. We did two implementations, one to be the real implementation, which is still being integrated since Mempool integration here is a bit complicated and a simulator to see how the performance are. So in terms of latency add, which is our biggest worry, the protocol runs completely parallel to the host blockchain so it doesn't delay anything in that sense. But some transactions are blocked and then end up in a block that would be later than they otherwise would be. In our experiments, number of this transaction depends on this ratio of block time versus message delivery time.
00:13:14.714 - 00:14:11.520, Speaker A: So if I have a very fast protocol so if I use tendermint, that's sort of 10% of all transactions. If I use a slower protocol like Ethereum, you won't even notice that this is happening. Transactions that don't need fairness are passed through right away and suffer no delay. And the waiting I mentioned above is actually the dominant factor. Transactions blocking each other was in our experience pretty much negligible the assumptions we have and that's where integration gets interesting is so we assume that the blockchain does not change the order of events that we propose. We can work against the blockchain here, but having a mempool where we can give the mempool an order or priority makes things much more efficient. If the blockchain needs ability to drop messages due to overload, we need to coordinate this.
00:14:11.520 - 00:15:04.346, Speaker A: And if we have another ordering mechanism, that's of course a conflict. So since most people here care mostly about Ethereum and this is where the whole mev problem was biggest. So we can implement or use Wendy with Ethereum so it would be an add on like cusper also having its own sort of validator set like cusper that know of each other and can run a protocol where everybody needs to talk to each other efficiently. So the good things we can make commit and reveal much more efficient as we solve the nonfinability issue. Every smart contract can choose their own fairness definition and just use it and there's a lower performance impact. What we need is to or what we would need is a defined set of fairness validators. We need a hook into block and transaction validity verification.
00:15:04.346 - 00:15:45.240, Speaker A: So when you can say this transactions is now invalid. And the biggest issue, but there's certainly solutions to this that can be discussed is we need a mechanism to resolve a conflict between the native ordering mechanism which is gas fees and the Wendy policy. So we want to avoid a setting where I have a transaction that by Wendy fairness rule need to be executed next. But it didn't pay any gas. So everybody else is blocked by a transaction that just refused to pay gas and needs to pay for them or find something else. And with this I'm at my end. So I guess we don't have time for questions anymore, right?
00:15:47.370 - 00:15:59.020, Speaker B: Yes, unfortunately. However, I think we should continue the discussion offline and we'll continue to collect these questions. Next up, we have.
