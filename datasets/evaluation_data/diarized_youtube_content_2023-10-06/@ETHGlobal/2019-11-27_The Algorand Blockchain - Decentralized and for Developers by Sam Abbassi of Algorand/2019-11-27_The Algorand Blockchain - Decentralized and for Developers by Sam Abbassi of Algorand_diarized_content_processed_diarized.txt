00:00:08.680 - 00:00:29.048, Speaker A: So my name is Sama Bassey. I am a technical evangelist for Algorand. And today my talk will be on using IoT blockchains, in this case specifically using algorithm. So here's just some members of the team. Amy is based in Boston. She's one of our community organizers. Russ is another tech evangelist myself, Sylvio, he's our co founder.
00:00:29.048 - 00:00:48.596, Speaker A: Liz is one of our product managers. Evan's in the back, one of our engineers. Hi, everyone. Okay, this is our safe harbor statement. Not sure if you guys actually have to read that. Okay, so by the way, we have a competition for Ubge. Well, not a competition for lottery.
00:00:48.596 - 00:01:33.028, Speaker A: So if you just scan this QR code, put in your email and or fill out a survey, I'll give you that at the end, by the way, just like full disclosure and I'll go into this later. We're trying to figure out what our developer market fit is. This is all in that effort in the sense that we can go after more standard crypto developers or the ethereum mindshare, or we can go after non blockchain developers, given that we have suite of SDKs in pretty much every modern programming language. So this is part of our effort coming conferences, talking to everyone, going through these surveys. So these are devdocs and devdocs are at developer, developer algorithm.org, actually. And our SDK can be found@github.com
00:01:33.028 - 00:02:03.400, Speaker A: algorithm. I don't know if anyone here is participating in our Hackathon API challenge, but first place is $1,000 a CoDrone and a tool backpack. It's one of my personal favorite types of backpacks. Evan's got one on. And then second place is a Go tenna matrix crater and a Raspberry pi. Matrix crater is like an IoT device, community sensor, temperature sensor, accelerometer gyroscope. These are actually this is a matrix crater.
00:02:03.400 - 00:02:47.992, Speaker A: Go tenders are Permesh networks, which are great. I don't know if you guys know how that works, but basically a go tenant communicates with another go antenna, your radio frequency. So this type of product is designed for emergency situations, more of the fringes with respect to Internet access. And you have an app on your phone that talks to it via Bluetooth, so you don't need any cellular connection, any WiFi, anything, actually. Are most people here familiar with blockchain? Is anyone new? Okay, great. So this is kind of redundant, but paper proof, transparent, and there should be some sort of trustless trusted environment. This is kind of a term, like a lot of terms in the blockchain space that's quite ambiguous, right? So it's a very nascent industry.
00:02:47.992 - 00:03:42.620, Speaker A: So things like decentralization things like Immutability, even things like trust ebb and flow in terms of what people mean when they use it. So trust is a really important one, or trust is trust. Again, this is more of the general blockchain high level, but our centralized economies are clearly broken for a multitude of reasons, and we're here to try and fix that as best as possible. So what is algorand? So Algorand is a pure proof of stake blockchain. I'll go into that in a second. We are permissionless, we have very fast transaction throughput and finality it's pegged at about 1000 TPS less than 5 seconds to create a block. And there is no forking in the sense that the network itself, consensus wise, can't split mathematically and with this type of design and type of architecture theoretically can scale to billions of users at a much quicker pace.
00:03:42.620 - 00:04:05.464, Speaker A: Adoption is also part of that whole process. So the way our consensus generally works is through a process called VRFs. So is everyone here familiar with DK. Snarks was zero knowledge proof? You probably heard of it. Sure. So Sylvio, our founder, was actually one of the authors of Zero Knowledge Proofs, one of the pioneers of cryptography actually. So VRFs are kind of a derivative of DK snarks in a way.
00:04:05.464 - 00:04:51.812, Speaker A: And that gives us our very fast transaction throughput. What's basically happening is that every account that has Algos in it I'll actually read this just to make sure the VRF output, when executed for an account, is used to sample from a binomial distribution point. So to emulate a call for every algo in a user's account, the more algos in an account, the greater chance the account has it being selected. It says that every algo in an account participates in its own lottery. With respect to decentralization. What I mentioned earlier, the Bitcoin space for instance, talks about decentralization with respect to validating all transactions in the network. If you are a participant, then you should be fully validating every single transaction that's ever happened in the network.
00:04:51.812 - 00:05:38.104, Speaker A: That's happening now and that will continue to happen when we mean decentralization. In this case, you're incentivized to run a node because if you're participating in the economy for integrity reasons, you want to make sure that your property is as maintained as integrity as best as possible. But what we mean in this case is more of economic decentralization. Whereas even if you have more algos or more wealth from someone else in the network, you have as much of a fair chance to be able to not only get rewards and write to the blockchain, but also vote on who is the person who gets the rewards and who gets to write the blockchain. So consensus in that case is decentralized. This is more of our consensus. So generally one account is chosen to post blocks and then a committee is chosen to vote on that person of around 1000 people, give or take.
00:05:38.104 - 00:06:09.040, Speaker A: Sometimes it's more, sometimes it's less. And once that committee votes, then it's really blockchain. So it's practically very hard to break this consensus and break this model mathematically, which is why we say that it's unforgettable. So we have the algorithm foundation as well. The Algorand Foundation runs the monetary policy, does the token offerings, the options, and sets up the whole reward policy. Algorand Inc. Who I work for, Evan, works for, is contracted by the Algorand Foundation to build and maintain the infrastructure of the blockchain.
00:06:09.040 - 00:06:34.744, Speaker A: We have testnet. Testnet is awesome. It's quite distributed. So obviously recommended you first build in DevNet, then testnet. So we have our own DevNet kind of private net that you can build, testnet and then do mainnet, but testnet's fantastic. testnet's been up for about Evan year and a yeah, a year and a half or so. By the way, our maintenance only been live for two months.
00:06:34.744 - 00:07:08.448, Speaker A: So part of this is prototype so APIs and command line tools. So we have two main processes there's Algod and KMD. Algod maintains the integrity or runs the protocol, rather, and KMD is more of the wallet process. So there's no consensus process happening in KMD that's more meant for, like, air gap wallet development for wallet developers. Goal is our command line tool. IO keys are standalone command line and we have a bunch of SDKs that I'll go into in a second. So that's just a bigger overview.
00:07:08.448 - 00:07:37.820, Speaker A: We have things like clerk and ledger, clerk, cloud, multi signal, Raw, send. Here's some of your functionality. So SDKs and swagger. So we use Swagger to describe the structure of APIs. This is on Swagger hub and sample code is generated for your language of choice as well. So our SDKs are written in go JavaScript, java and python. Now, again, this was designed to make it as easy as possible for a non blockchain developer to get into this.
00:07:37.820 - 00:08:25.416, Speaker A: I know when I was getting into blockchain, ethereum was obviously the lowest barrier to entry because it's so similar to JavaScript, how it reads. But at the same time there's still barrier to entry because they have to learn a new scripting language. Now, that's a very strange thing in the space because I think for Ethereum developers, solidity is like a central tenant. It's a unifying factor in who they are and what they know as a community. We're taking kind of a different approach currently where we have SDKs in the most modern languages. But yeah, you have your candy wrapper, your Algo, errapper and again, candy is meant more for air gap applications. When you say air gap applications, yeah, in that sense we run offline entirely.
00:08:25.416 - 00:08:58.580, Speaker A: So more for wall development longer. Actually, I'll show an example, and I'm going to go into my IoT example in a second, just to show you what it looks like. So we don't have smart contracts as of now, the objective is to have smart contracts in a year. We're actively working on it now, opto development, just general strategy and planning. So it's not just a roadmap item. We're actually working on it now. But the way it works currently is that inside of a transaction, an algorithm inside of a transaction object, you have a field.
00:08:58.580 - 00:09:25.036, Speaker A: One of your fields is called a no field. Inside that field you can write about kilobytes of data and then commit that to the chain so you can run all your logic off chain. And then almost like a timestamp if you're going to use that as your on chain record. So this is what this looks like in the SDK. These are the different fields you can have in the transaction object. This is a Python SDK by the way. So sender fee, first valid round, last valid round.
00:09:25.036 - 00:09:47.628, Speaker A: This is the note field that I was talking about. Genesis ID and Genesis hash. I just want to show you what that looks like. I'm big on visuals, I think it helps. Here's an example. So writing a transaction to a file so you can do a couple of things. You can get suggested params here to make easy, but you see here you don't even need every single parameter that I just showed you to write a transaction.
00:09:47.628 - 00:10:29.408, Speaker A: For instance, in this case they're just writing a simple transaction so they don't need any note field or any kind of data to the note field. So that's just not included. But it's quite straightforward and transactions rent a file is this one is actually working with the note field. So this is what that looks like. You can define it here. In this case we're doing an option, but in notefield bytes that's passed in. You have to encode it with Pack and then you can add it into your transaction object here and then sign in and then near term projects.
00:10:29.408 - 00:11:01.890, Speaker A: So these are our near term projects that are coming up. Vault is meant for almost like validating block headers in Bitcoin. It should make it easier to host your record of the blockchain and validate incentivize more people to run nodes. That's what we want. These are atomic squared swaps. So this should allow you or it should make atomic swaps a lot easier in the sense that you wouldn't have to do these small steps to prove that you to basically mitigate your counterparty risk. In this case, you should be able to do atomic swaps in one go.
00:11:01.890 - 00:11:27.600, Speaker A: And then smart contracts are what we talked about earlier. So you can become an algorithm ambassador. We also have Nate here from PureStake. PureStake is kind of like our Pure service. You can basically make API calls for the remote instances. They have plans here. And so let me then plug this in and show you how the Raspy works.
00:11:27.600 - 00:12:16.146, Speaker A: So I just made it very, very simple and I'm not a hardware engineer, so it may look impressive, but it's not necessarily it's very easy to do. I made a simple IoT device using our Python SDK. While that's booting up, has anyone worked with a Raspberry Pi before? Yeah. So what's great about Raspberry Pi's is that well, they're incredibly versatile, obviously. So this is an RFID reader RFID scanner. So the Pi itself is a single board computer, but they have GPIO pins which are general purpose input output pins. So you can pretty much plug anything you want into it.
00:12:16.146 - 00:12:38.966, Speaker A: In this case, I have what are called two breadboards. There's just pins at the bottom of it. It allows you to set up circuitry properly. I just have all these pins attached to this one. These have a bunch of labels, so it's easier for me to plug things in and out. And then I have these plugged into the wires on this breadboard that's attached to my RFID scanner. And these have different functions here.
00:12:38.966 - 00:13:02.850, Speaker A: So you do have to plug in the right function to the right corresponding pin. This was an awesome project, honestly, because I've never actually had to what's called solder melt pins into a board, which is awesome. I've never done that before. So let me show you. First we can find all this. So this is Raspberry, by the way. This is Raspberry OS.
00:13:02.850 - 00:14:19.230, Speaker A: In Raspberry Pi's you can mount different operating systems on different micro SD cards and swap them in and out of your Raspberry Pi, making it again incredibly versatile. I'm going to publish my code today, but you can find the Arimi at least here, and I'll walk through that with you in a second. Get this set up. Bear with me, my keyboard is a bit bullshit. It's really good travel with the design exactly best. Okay, cool. So let's go to project.
00:14:19.230 - 00:15:06.212, Speaker A: Okay, so let's just actually get started. I'll run it once and we can talk about it. Cool. So I have some RFID tags, and so these have barcoded IDs, and you can match that up to your application or you can write data to it. So right now I have a hard coded account that it's going to read from. So this one, I believe, is going to read my balance. Yeah.
00:15:06.212 - 00:15:31.412, Speaker A: So my account, that's how much I have in my account right now. This one should read my pending awards, I think. Pending awards currently zero. And then this one should be my total rewards. Yeah, it is my total. So all this is doing is taking requests by the Python SDK to a remote instance I have running. You can also run a algorithm node using Raspberry Pi.
00:15:31.412 - 00:16:15.470, Speaker A: Already have this, very simple, but in this case, I wanted to show how you do it. So now we can grab this account, go to the algae dispenser, make the audacious claim that I'm not a robot. Here's our confirmation. I jump back in here. This should now read nine fast. That's the change. Now we had a patch in test set, so there's a bit of a glitch in the rewards.
00:16:15.470 - 00:16:31.222, Speaker A: So it wasn't working earlier. I have a feeling it's not going to work now. Probably going to read zero. That typically should change. It's just a patch of testnet that we're going through right now. Our total rewards again should change as well. But because of our pass, it's not going to.
00:16:31.222 - 00:17:17.126, Speaker A: But that's basically how this works. Very simple. What I wanted to do with this, or what I might do ultimately, is put it on some sort of moving object, like a toy train, right? So you could basically protec the idea that different tags on the track will represent different stations. You can run the R, I can taste the R by the reader under the train, and then it can read each tag as long. But with our really fast transaction, finality things like this are possible. So let me show you the code, see how that works. Okay, so what's important really, is this transaction mnemonic account.
00:17:17.126 - 00:17:57.910, Speaker A: You need your algo client. This was me sort of tinkering around offender disc. Here's where you declare URL, your token for Algodith. And then the next relevant line with respect to algorithm is down here. So this is where you're defining what you're calling from, the SDK accounting pool. You want your address, your pending rewards, your amount, and this gets your total words. So really just in 12345 or something, nine, maybe ten lines of code or it you can make some basic functionality.
00:17:57.910 - 00:18:16.830, Speaker A: The next thing, obviously, is the post transaction using this, using yard buddy tech. But yeah, this is a very simple prototype how you can build an IoT device. Are there any questions? All good. Okay, thank you.
