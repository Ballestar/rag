00:00:00.170 - 00:00:44.710, Speaker A: You. Hello everyone, I'm Evo Georgiev and I'm going to tell you a bit about our payment channels which are called Outpace. I'm from Addix. So who are we? We are a small distributed team. We started in late 2016 and we are coming from previous product which was doing and still is doing video streaming called Streamio. We launched on the Ethereum main net in 2017 and we've been improving ever since. We went through a few complete rewrites, complete redesigns.
00:00:44.710 - 00:01:59.330, Speaker A: And what we are building is an open and trust minimized protocol and stack for digital advertising that aims to reduce fraud, ad fraud, and the so called malvertising which is advertising malware and of course to protect user privacy. So everything we do is open source. This is an important thing to say. And what we are building is many things, including softbox cars, it's actually blue. So another thing that we are building, which is the main topic of the stock, is Outpace, which is kind of an acronym for off chain unidirectional trustless payment channels with a bit of cheating and it's kind of similar to the Lightning Network and Connect and Raiden, but different and you will see how. So the main characteristics are that it's unidirectional and one too many. So one party can pay many parties with the same channel and it's built on Ethereum.
00:01:59.330 - 00:02:47.810, Speaker A: So the use case of outpace and the use case of payment channels for us is providing transparent reporting by enabling micro payments per impression. And this means that we are ensuring publishers always know how much they've earned and how from where. And that advertisers always know how they're spending their money. So those two points that both advertisers and publishers know what's happening with their money means leads to transparent reporting. And another thing that payment channels help us with is something that we like to call pseudoatomic impression payments. And this works in the following way. Let's say that Alice is the advertiser and that the publisher is Pete.
00:02:47.810 - 00:03:25.786, Speaker A: So Pete serves an impression and reports it. So at that point Pete wants to get paid for the impression and because we're working on payment channels, then micropayments are possible. So Alice pays Pete for that impression. At this point, Pete knows that they're in good standing, in a good relationship, so they can repeat this process. What this essentially means is that if at any point Alice stops paying, then Pete can stop serving impressions. So the worst that Pete can lose is only one impression, which is worse fractions of ascent. So that's why we call it pseudoatomic.
00:03:25.786 - 00:04:45.746, Speaker A: It's not really atomic, but the worst that you can lose is only fractions of ascent. But in reality the threshold is more than one impression and it's configurable. And this is a concept that we call campaign Health or Channel health. Basically the worst you can lose is not even 1% less than that. So what's out of scope of this talk and what's out of scope for addicts in general is CBU attacks, fake clicks essentially and protecting user data is not out of scope for Addix but it's achieved in different ways and outpace just facilitates payments so it leads to the transparent reporting bit. So what's the problem with Lightning? Why can't we use Lightning, Crayden or Connect? The reason is that multiparty payment channel networks require hubs and deposits and so that's a huge user experience overhead, especially with having to open payment channels and to rebalance payment channels. And additionally you have a huge user experience overhead from routing payments.
00:04:45.746 - 00:05:55.034, Speaker A: And what that means is usually with the Lightning network when you pay a certain party the payment may fail. There is no guarantee that this payment will succeed and it will fail if there is no route from you to the party that you're paying that has a sufficiently high capacity. So when it fails you just have to open channels but you don't necessarily know where to open the channels with whom or et cetera. So that's a huge user experience overhead. Basically the user isn't really always aware of how to pay someone and additionally hubs have to be funded. So this means that hubs have to have a certain portion of their funds just locked on channels and those funds are unusable while they're locked. So there is also the bi directionality assumption which basically means that even publishers who are usually just getting paid and not paying for anything, they also have to open channels because channels are bi directional by default.
00:05:55.034 - 00:07:09.318, Speaker A: So if you want to get paid, you basically have to open a channel. So this is not good enough for our use case and what we came up with is called outpace, as I already mentioned and it's kind of a new interpretation, a new read on payment channels and it's unidirectional which is really good for our use case where the funds always flow from advertisers to publishers. It's also one to many, meaning that in one channel many publishers can be paid and the channels are actually open between advertiser platforms which is similar to in traditional ad take the demand side platforms, so DSPs and publisher platforms which is again similar to SSPs. So we use the term channel validators as an umbrella term for these two. And one advertising campaign always gets mapped to one channel. So individual parties, publishers can be paid from this one channel and it's trust minimized. And what that means is that you have to either trust the advertisers platform or the publisher's platform.
00:07:09.318 - 00:08:31.920, Speaker A: But this is really easy if you are running one and in most cases if you are for example a large advertiser, you would be expected to run your own platform. So is that general purpose and can you actually use it in your own project? Yes, any use case where you need unidirectional one to many streaming micro payments you can use outpace essentially any use case where two parties mutually agree to send micropayments to multiple parties. So an example use case would be Bounties. Like for example imagine Bounties network and imagine a company for example Addix wants to give away Bounties and they will open a channel together with a service provider for example Bounties Network so that's two parties who are opening the channel and then this channel can distribute funds to whoever earns Bounties in off chain way. So if you earn from, let's say a commit on GitHub, then you don't need to do anything on chain. You can continue earning from commits on GitHub and then withdraw your funds at once. So let's say a bit about the user experience.
00:08:31.920 - 00:09:24.990, Speaker A: The main point here is that sometimes good user experience starts with the smart contracts. Sometimes you cannot design a DAP with the good UX without starting with the smart contract design. So let's look at a minimal viable interaction where the advertiser opens a campaign and the campaign is always one channel, so that's one on chain transaction and the publisher can withdraw whenever they want. But let's say they are withdrawing once per month. That's the usual standard in the ad tech world. Of course they can withdraw more frequently and each withdrawal is one on chain transaction. So essentially for the entire flow of funds we only have two on chain transactions, one for deposit and one for withdraw.
00:09:24.990 - 00:10:23.678, Speaker A: We also have something called Identity So, which is a solidity smart contract which allows you to delegate blockchain interactions to every layer. We've seen this pattern a lot with the universal login SDK for example, and with many others. But the point of this pattern is that the user is represented. So the user in this case is the publisher or the advertiser, and they are represented by a smart contract which allows them to schedule transactions. So you can just allow the relayer to withdraw on your behalf once per week or once per month, which is valuable because channels have an expiration date and if you forget to withdraw before that expiration date, then you lose what you've gained from this channel. So that's a really nice pattern. At the beginning of your usage of the DAP, you authorize the relayer and then the relayer would automatically withdraw on your behalf.
00:10:23.678 - 00:11:35.850, Speaker A: And this also solves the problem of token approvals. We've seen some DApps require you to approve the maximum possible amount beforehand, which is kind of a security anti pattern, but they do it in order to minimize on chain transactions. And in our case, because the user is a smart contract represented as a smart contract in one on chain transaction, you can both approve a certain token and do something else, for example, deposit into a channel. So essentially this means that the user interactions are even more minimal. The advertisers only ever need to interact with the chain once and the publishers can just authorize the relayer to withdraw on their behalf and the scalability implications because in our opinion scalability is really related to user experience. The scalability implications are obvious. It's pretty much infinitely scalable in terms of transactions per second or like not infinitely, but it's CPU bound to the two validators in the channel which is like extremely scalable.
00:11:35.850 - 00:12:58.870, Speaker A: And then you do have the on chain bottleneck if you want to withdraw every minute or something. But if you withdraw sensibly like once per week it's fine. So we mentioned earlier that there are trust assumptions and you can fully trust a channel 100%. Like you can rely on a channel if one of the validators is under your control, which is pretty much as in any other payment channel network, you are usually one of the signers of a channel which means that you can trust it. So if you're a large publisher or advertiser, you can just run your own validator so essentially spawn your own publisher platform or advertiser platform which also has other benefits like you're essentially enhancing the network, enhancing the ecosystem and you can also earn money from validator fees. But if you're a small participant and you don't want to invest time doing that, there is always a shortcut and you can delegate both of the validators in the channel and that's fine as long as you think that they are representing opposing interests. So it's fine as long as you don't think that they will collaborate between each other to steal your money, which is acceptable for small sums.
00:12:58.870 - 00:14:00.620, Speaker A: So we talked about delegation and we have a component which is called the Addix Registry and it's a mechanism for validators to gain exposure by staking ADX and it holds them responsible for going offline by slashing them. So this means that the more value staked then the more trustworthy this validator is. And if they go offline, then a challenge can be started. And the challenged entity, the challenged validator needs to replicate all of the state transitions that they are doing off chain. They need to replicate them on chain so like counterfactual state channels in order to prove that they are still online and operational. And proving unavailability is pretty hard because you can usually fake your actions on chain without doing them off chain. But using a few pieces of knowledge about the environment and a few pieces of knowledge about the game theory, we can solve that.
00:14:00.620 - 00:14:52.300, Speaker A: This is essentially solved at the moment. And this particular component because it requires really high on chain throughput or at least really high potential on chain throughput. It's built on substrate and it will eventually be a Polk parachain. So a quick crash course into how the outpace channels actually work. And they're a lot like regular payment channels where you have two parties, we call them Alice and Pete to associate with advertiser and publisher. They sign new states and the funds are locked up in two out of two multi SIG on chain. And Alice acts as the leader because she deposited the funds into the channel and therefore gets to propose the new states.
00:14:52.300 - 00:15:45.610, Speaker A: And Pete's job is only to validate the new states and approve them. So sign on them. But Pete has to ensure that the channel rules are upheld. And because outpace is unidirectional, this just means that you have to maintain the rule that the new balance is always larger or equal to the previous balance. But unlike regular payment channels, the balances are actually a merkle tree where anyone can be paid and that's where the one to many comes from. And this works when Alice and Pete want to distribute funds to some parties together, as we already mentioned. And this just means that the row new balance, larger or equal to old balance is applied for each account in the balance tree and also to the sum of all of the account balances in the tree.
00:15:45.610 - 00:16:52.800, Speaker A: And this is the nice bit is that the unidirectionality means that there are no challenge periods or watchtowers in regular payment channels. You need every sign to have a number and then you start a challenge period on chain where if someone has a newer state they can submit it. But in our case it's not needed because any signed state is valid at any point in time and can be used at any point in time. And we do that by keeping an on chain record of how much an account has withdrawn, basically how much is withdrawn per account, per channel. And at any point we allow you to withdraw no more than the current balance in the tree minus this particular record for the particular channel, for the particular account. So this essentially means that if you try to withdraw from an old state there is nothing malicious that you can do. The worst thing that can happen is that you would have withdrawn less and then in order to get the rest of your funds, you will have to withdraw from a newer state.
00:16:52.800 - 00:17:49.630, Speaker A: So, a few words about the implementation. There is a specification and documentation at the Addix protocol repo and everything is under our GitHub that's Addix network nodes and there is an ethereum implementation Addix protocol ETH and there is a proof of concept on substrate Addix protocol substrate. I also did a workshop on how to build payment channels on substrate. And there is also a repo with the workshop code. It's just payment channels, the name of the repo. There is also an off chain implementation. This is arguably the most important component because this is what has to detect misbehavior between the channel validators and basically has the responsibility of signing new channel states.
00:17:49.630 - 00:18:27.060, Speaker A: And you can use this to spawn your own validator. So essentially spawn your own advertiser platform or publisher platform. It's currently done in JavaScript because it's only a reference implementation. The main purpose of this repo is to show how to build a validator stack, but it's going to get rewritten in Rust anytime soon, maybe in the next couple of months. So the features it has are obviously misbehavior detection. It would not sign new states if they are not valid state transitions. It applies validator fees.
00:18:27.060 - 00:19:20.120, Speaker A: So at one point validators can actually earn from maintaining channels and it's very highly scalable because of the architecture and because of patched processing. So in most payment channels implementations, each payment would be a new state. And because we are dealing with impressions here, which may be thousands per second, we have an architecture where we just count the impressions in batches and then apply the payment in the channel. So a few words about adoption. The updated Addix DAP launches by the end of March. And the most exciting thing to mention is that we are currently implementing integration with Streamio, which is a media center with over 6 million sign ups. So potentially this could be the biggest exposure of payment channels to date.
00:19:20.120 - 00:20:15.400, Speaker A: And the integration is going to happen in a completely frictionless way and invisible to end users. So it's just going to get rolled out to 6 million people. And we are hoping to see other projects using outpace as well. Many use cases are possible and I think the biggest one, as I mentioned earlier, is the Bounties use case where you have two parties which are distributing bounty micro payments to various other parties and there is plenty of technical material that you can grab from GitHub and start applying Outpace to your project. So we have further reading. We have a blog post which goes through a basic explanation of what Outpace is. Basically the first half of the presentation in a blog post.
00:20:15.400 - 00:20:43.064, Speaker A: And whoever wants the slides can just scan this QR code. I'm going to give you 30 seconds to scan the QR code if you want, or I guess S Paris is going to have the slides uploaded somewhere. All right. Okay. So that's pretty much it. You can go to our GitHub. That's my main suggestion.
00:20:43.064 - 00:21:20.574, Speaker A: If you're interested in the technology, follow us on Twitter. Follow me on Twitter. And I guess it's time for questions. Yes. So that's the job of the validators. So essentially how it works is you're asking in a more general way or in our particular use case. Yeah.
00:21:20.574 - 00:22:05.280, Speaker A: Okay. So in our particular use case, the end users would actually, when they see an ad, the code that's running in their browser would send an event both to the advertiser platform and the publisher platform and they will update. Like a dictionary of balances would find the publisher increment the balance for that publisher. And then the advertiser platform, which is in our example. Alice proposes the new state, saying, okay, this publisher has more funds. This is the entire dictionary of balances and this is the Merco root of this dictionary. Then at this point, before sending that, they would take this dictionary and merklize it, convert it to a Merko tree, send it over to the publisher platform.
00:22:05.280 - 00:22:50.672, Speaker A: They are applying the same and seeing if this current state makes sense. And if it makes sense, then they sign the state. And now you end up with two signed states which represent the same Merko tree, where the publisher's balance is higher. No, everyone is in the same tree. The dictionary of balances just gets mercurized to one tree. So there's one tree per channel, but it gets updated all the time. So it really depends if the ads are for the same campaign or not.
00:22:50.672 - 00:23:28.012, Speaker A: As I said, one campaign is one channel. Meaning that if there is ten people seeing ten ads, if all of the ten ads are for the same campaign, this means that they are for the same channel. So this is one Merco three that would get updated. It would just get updated ten times without batching, but maybe one time with batching if all of the impressions are at the same second. Is that a question? Okay, no other questions. All right, so I guess we're going to wrap up. You can always find me.
00:23:28.012 - 00:23:50.770, Speaker A: Ask me whatever you like, and we have a table upstairs. You can always come talk. We have our CMO Vanina, who is also there, and you can get some swag T shirts, et cetera. And also, if there's anyone particularly interested in tech or payment channels, you should definitely come work. Thank you.
