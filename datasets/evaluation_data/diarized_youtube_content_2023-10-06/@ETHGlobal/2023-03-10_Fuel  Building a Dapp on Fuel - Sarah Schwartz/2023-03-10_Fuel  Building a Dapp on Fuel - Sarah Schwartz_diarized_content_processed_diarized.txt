00:00:23.260 - 00:00:23.472, Speaker A: Hey.
00:00:23.526 - 00:00:36.290, Speaker B: Hello and welcome everyone, to the Fuel Workshop building a DAP on Fuel. Joining us today is Sarah Schwartz, who will be talking us through this session. And with that, I'll pass it over to Sarah to introduce herself and get the session started.
00:00:36.900 - 00:01:04.056, Speaker C: Hi. Thanks. Yeah. So my name is Sarah Schwartz. I'm a developer relations engineer at Fuel Labs and I'm going to be walking you dive through the basics for how to build a full stack DAP on Fuel or Fuel stack DAP. So first of all, really quickly, what is Fuel? Fuel is a modular execution layer. So that means you can execute on Fuel and settle on another L, one like Ethereum.
00:01:04.056 - 00:01:48.568, Speaker C: And what makes it really different from other roll ups you might have heard of is that it uses the Fuel VM instead of the EVM, which uses the UTXO model that allows for parallel transaction execution. So it's much faster than EVM. So the basic Fuel terminology you're going to want to know as we're going through this is when I say Fuel, I'm referring to the fuel blockchain. Sway is our domain specific language. It's a Rest based language, so we don't use Solidity at all. Fork is short for Fuel Orchestrator, and it's the equivalent of Cargo for Rest or NPM for Node. And we're going to be using that to create a new project and build it.
00:01:48.568 - 00:02:30.884, Speaker C: And Fuel Up is our tool chain manager. So you can use this to install and manage versions of Fork and Fuel Core. And then Fields is our SDKs. So we have Rest and TypeScript SDKs, and the name comes from like Ethersjs. So this is sort of what I talked about earlier, but it's just sort of comparing what you might be familiar with in terms of depth architecture with the EVM versus Fuel. So instead of solidity, we use sway. When you're developing and deploying contracts for the EVM, you might use Hard Hat or Foundry.
00:02:30.884 - 00:03:14.592, Speaker C: But for fuelvm we use fork and FUELUP. Our SDKs are called fuels. And again, it's for a rest and type script and we have our own indexer service as well. So in general, when you're developing with Fuel, you're using tools that are all developed by the Fuel Labs team instead of a bunch of independent tools. So Solidity, as you probably know, is the OG language for the EVM. And it's been there for us for a lot. There's a lot of cool projects that have come out of that, but it can sometimes feel like a minefield for vulnerabilities and really hard to get up to that level of pro.
00:03:14.592 - 00:03:53.752, Speaker C: Solidity developer. With Sway, it's based on Rest, it's for the Field VM and it's really built with lessons learned from Solidity in mind and designed for a really good developer experience. In general, Solidity, you can really only write contracts with Sway. There are four different program types. You can write contracts, libraries, scripts and predicates. And I believe we have a bounty out that is just for predicates for the sackathon. So here's your typical hello world contract in solidity.
00:03:53.752 - 00:04:35.376, Speaker C: It just has this public greeting. This is string called hello, world. And if you're familiar with Solidity, you'll know that there's a getter function that's automatically generated for this. And here's what that contract looks like in Sway. So there are no hidden functions in Sway, sort of like what you see is exactly what's in the contract and what's available. So we have to write our own getter function here called Get greeting. And instead of just declaring this persistent storage variable anywhere in the contract that's outside a function, you have to declare all persistently stored variables in Sway in this storage block right here.
00:04:35.376 - 00:05:19.020, Speaker C: So we're saying we have a variable called Greeting that's going to be persistently stored. It's a string with twelve characters and it's Hello World. And when we access this greeting variable, we do it through the storage object. And so this is really handy for preventing namespace collisions, so you don't have to worry about if you wanted to name a variable inside this function greeting, because this persistent greeting storage variable is stored under storage greeting. So a little recap of what we just saw. A solidity is based on C plus plus python JavaScript. Sway is based on Rest syntactically.
00:05:19.020 - 00:06:07.580, Speaker C: And Solidity functions are not pure by default. You add the pure keyword if it's pure and view if it's view only in Sway, they're pure by default. And you have to use this like storage read or storage write annotations if you want to access persistent storage. And like I said earlier, Solidity, there are hidden functions generated. Sway, the contract tells the whole story. You can put in state variables and solidity sort of anywhere in a contract except for inside a function. And in Sway they are all neatly organized in the storage block and again, they are namespace, so you have to access them through the storage keyword.
00:06:07.580 - 00:07:02.952, Speaker C: Another huge difference of Solidity and Sway is that Sway tries to reduce the number of global variables there are. So keywords that you can't touch. And we provide a lot of stuff through our standard library and I'll show you an example of what that looks like. So when you're creating fungible tokens in Sway, so this would be something like the equivalent of ERC 20. You can actually use a function from the standard library that mints native tokens, which means that you can send them in a call, just like you would send ETH in a call for Ethereum or Maddox in a call for Polygon. So here's what that ERC 20 contract might look like. In Solidity and in Sway, we have this standard library that just comes out of the box.
00:07:02.952 - 00:07:58.640, Speaker C: So if you're familiar with React, it's like how you can pull in use state or use effect from React. You can pull in any function from the standard library or any constant from the standard library out of the box. So we're pulling in this Mint to address function and we can mint native tokens out of the box to an address. And for receiving tokens in Solidity, you'd probably check this message value variable. And again, if this is for Ethereum, you know that this would be ETH because it's the only asset you can send with Sway, you can send any asset. So we actually have these two standard library functions, message Asset ID and Message Amount. And you can check for the amount sent in a function call and what kind of asset.
00:07:58.640 - 00:08:58.180, Speaker C: All right, so now you have just like sort of a general background of things you can do sway and developing on Fuel. We're going to start writing a really short contract and really brief front end. It's going to be a really simple game. So to get started, you're going to have to install Fuel Up, which is our tooltune manager. So if you go to scroll down and find the installation command and this is one really simple command to get Fuel Up installed and started with developing. So again, here's this command. And then I'm going to open a terminal and I'll show you what that looks like once that's installed.
00:08:58.180 - 00:09:58.490, Speaker C: Okay, so once Fuel Up is installed, you can use this command Fuel Up Show to show the installed tool chains and the latest tool chains. And so right now I'm working on beta three. And if you want to install that, you can use command Fuel Up install tool chain beta three. And this is one of our testnets. It's our third testnet and the testnet is not actually completely live yet, so you can't quite deploy this contract, but we're going to develop one anyways and deploy it locally. So it's actually, let's see, Fuel Up toolchain install beta three. And I already have it installed and we're going to set it as our default with Fuel Up default beta three.
00:09:58.490 - 00:10:46.548, Speaker C: Okay, so now that we have that installed, we have access to Fork and FuelCore. So I'm going to create a new project. Let's see, let's make a new folder called Game. Go into Game and we're going to use Fork New and then we'll call our contract Sway Game. And this will create a new Fork project for us. So I'm going to open this folder up in Vs code here and here's our template game or contract. And so we just have this test function right now, but we're going to update this.
00:10:46.548 - 00:11:25.650, Speaker C: So the first thing we're going to do is we're going to make a player struct. It's going to be really simple. We're just going to have a player that has a level. And the level is going to be a number which is going to be a U 64, which is the default number type in Sway. And we also want to be able to update the level for this player. So we can add a method to the struct with the Impl or implement keyword. And we can implement the player struct and add a function called level up.
00:11:25.650 - 00:12:30.736, Speaker C: And we can pass in the struct itself here to update itself. So can use this keyword ref mute self, which means it's a reference that's mutable to this player so it allows us to update it and then we can say self level equals self level plus one. And now we have this player struct and a way to automatically update it. So let's add it into our contract. So we have this abi right here and the abi is essentially just an outline of all the functions in your contract, the types that are used for the inputs and the types used for the outputs. And so we're going to get rid of this test function here and add a new function. And the function is going to be called new player, so function, new player and it's going to return a player struct.
00:12:30.736 - 00:13:24.810, Speaker C: So we use this skinny error right here to return a player and we're going to want to copy that into our contract here so it looks identical, except we're going to actually implement the logic here. And so we're going to make a new player, but we're going to want to store it somewhere, right? So we're going to add that storage block that I mentioned earlier and we can store this in a mapping so we can call this variable players. And it's going to be a storage map, which is a special type used to store mappings. So this map, to define the types in this map, key and value use this sort of like generic syntax right here. So we're going to save an address.
00:13:25.420 - 00:13:31.112, Speaker A: To a player and initialize it as.
00:13:31.166 - 00:13:33.130, Speaker C: An empty storage map like this.
00:13:35.420 - 00:13:36.268, Speaker A: Okay, cool.
00:13:36.354 - 00:13:53.504, Speaker C: So we have our storage set up and now in our function we're going to want to add a player to storage. So we're going to need to add this storage annotation here and we're going.
00:13:53.542 - 00:13:58.096, Speaker A: To read and write and whatever is.
00:13:58.118 - 00:14:50.684, Speaker C: In the API also has to match in here. So for the sake of time, I'm going to paste logic in this function here and we're actually going to be using the standard library, something from the standard library. So we want to get the message sender. And like I was saying earlier, in Solidity, you'd probably use this global variable to get the message sender. But in Sway we can pull in a function from the Standard Library to get this and the message sender in Sway is an enum type of an identity. And identities can be either an address or a contract ID. So you can actually tell if a contract is calling your contract or someone's wallet.
00:14:50.684 - 00:15:44.420, Speaker C: So in our case, we wanted to make sure that only wallets can call our contract and play the game and a contract can't. So we can check here if the sender is an address. And if so, then we'll set the address to this variable and if not, then we can revert and we can use a require statement to read from our storage and we use this get method to read it. And when you use a get method in storage, at least for the beta three toolchain, it returns an option that could be either some value or none. So essentially it's initialized as everything is none. And then once you set it, then the value is some. There is some value there so we can check if there is none with this built in method here.
00:15:44.420 - 00:16:10.860, Speaker C: So we're making sure that there is no player that already exists and if there is one, we have this error message. And then finally we can create a new player with this struct and we'll split the first level as one. And then we can add that player into our storage mapping here with this insert method. So we're inserting the address and the player.
00:16:11.840 - 00:16:12.588, Speaker A: Okay.
00:16:12.754 - 00:16:18.400, Speaker C: And let's add one more function to level up the player.
00:16:21.640 - 00:16:25.924, Speaker A: So this function will also have the.
00:16:25.962 - 00:16:27.620, Speaker C: Read and write annotation.
00:16:34.420 - 00:16:36.464, Speaker A: And you can.
00:16:36.502 - 00:17:22.560, Speaker C: Just paste that same thing into the contract implementation. Place the semicolon with curly brackets and then to get the player, we're going to use the same code right here of getting the sender or sorry, getting to level up. And then we can get the player, level it up and then reinsert the new player into storage. And so we can do that like this. So let this Mutable current player variable equals storage. Players get the address from the message sender. So we're getting the existing player from whoever called this contract.
00:17:22.560 - 00:17:44.950, Speaker C: We're calling it Mutable because we're going to level up, call our level up function that just takes the level and adds one and then reinsert it into our storage mapping. And we can return the final level here.
00:17:48.430 - 00:17:52.460, Speaker A: Like this currentplayer level.
00:17:53.150 - 00:18:56.770, Speaker C: So you can actually optionally use the return keyword here and use a semicolon, but as a shortcut in sway and rest you can emit this and it will return this value. Okay, so let's add one more function here to read the as like a read only function to get the player. So here's our get player function. It takes an address and returns the player. And then to implement that function down here, we can use just this one line storage players get address unwrap and this unwrap just unwraps the option type value to return the actual player. So without this unwrap, this would return an option wrapped or a player wrapped in an option essentially.
00:18:57.510 - 00:19:00.020, Speaker A: Okay, so.
00:19:04.230 - 00:19:43.810, Speaker C: I was hoping to write a test for this. It doesn't seem like we have time. So let's see if we can create a front end for this really quickly. So to make sure it builds, we can use this fork build command. Okay, so first go into the swiggy folder, fork build and okay, actually accidentally have a semicolon here. It should be comma. And that's the nice thing about this compiler is it will tell you straight up, like, all the errors that are happening in your contract and won't let you deploy unless they're all fixed.
00:19:43.810 - 00:20:44.410, Speaker C: So, okay, we have our contract built and let's create a front end. So I'm going to go back into the game folder here and use NPX create react app to create a template front end with TypeScript. And while that takes a second, we're also going to add this file called chainconfig JSON and that's going to allow us to run a local node with a pre funded wallet. And if you go to our.
00:20:47.820 - 00:20:48.228, Speaker A: Let'S.
00:20:48.244 - 00:22:24.530, Speaker C: See, our doc site here, fuelbook Fuel networkmaster. And then scroll down to running a local node, you can find a copy of what the chain config looks like. So I'm just going to copy this into here. And essentially the only thing you need to change is this wallet address right here. So this chain config, when we launch our local node, it will fund this wallet. And one more thing we have to do, or actually a couple more things we have to do is in our front end it, we have to install Fuels, which is our TypeScript SDK and that will allow us to interact with our contract. And one more thing we have to do is use this typegen command and you can find this in our TypeScript SDK docs or in our Quickstart.
00:22:24.530 - 00:22:32.760, Speaker C: So it's NPX fuels typegen and essentially just generates all the types from the contract folder into our front end.
00:22:35.790 - 00:22:38.810, Speaker A: And Sway game.
00:22:38.960 - 00:23:01.526, Speaker C: I see. Okay, update the folder here. Okay, awesome. So we don't have a ton of.
00:23:01.548 - 00:23:05.786, Speaker A: Time left, but I can go into.
00:23:05.808 - 00:23:28.640, Speaker C: Our app TSX file and going to replace everything here. So now that we have our chain config up, we can start a local field node and everything should be installed already. Through Fuel up.
00:23:30.610 - 00:23:31.474, Speaker A: We can do this.
00:23:31.512 - 00:24:11.560, Speaker C: Fuel core run and it will use this chain config JSON dodged. Oops, I didn't name this. Right, here we go. Chain config. All right, so we have that running in our contract folder. So it's sway game. We can deploy to the local node with deploy unsigned.
00:24:11.560 - 00:25:13.140, Speaker C: Oh, sorry, fork deploy unsigned. And here's our contract ID. Back in app TSX, we have the contract ID here. We have a wallet secret and we're connecting to our local node through the wallet and pulling in the API from this generated contracts folder, swigame API, matches. And here's how we can call each of these functions. So to create a new player, essentially we just can say await contract functions, newplayer call and let's see if we can get this to work.
00:25:23.350 - 00:25:24.502, Speaker A: It all right.
00:25:24.556 - 00:25:26.866, Speaker C: So we have let's see, since we're.
00:25:26.898 - 00:25:31.270, Speaker A: Console logging, I'll open up our console.
00:25:32.250 - 00:25:42.540, Speaker C: So you can see create a new player. Here's our new player. Level up. Level two. We're going to level it up again.
00:25:42.990 - 00:25:43.514, Speaker A: All right.
00:25:43.552 - 00:26:02.850, Speaker C: It's level three. All right, there we go. So there's our super simple contract. I know I went through it pretty fast, but that's how you do it. Are there any questions online or in the chat?
00:26:06.950 - 00:26:13.910, Speaker B: There's no questions in the chat, but yeah, if anybody wants to ask a question, feel free to take yourself off mute or type in the chat.
00:26:29.790 - 00:26:56.350, Speaker C: Okay, well, I'll just say really quickly, if you go to our Quickstart right now, we are using the Beta Two network and this contract I developed for Beta Three network, and it's not quite live yet, but it should be live very soon. So hopefully, if you're in this hackathon, you'll be able to deploy to the Data Three test net for your final project submission. And in the meantime.
