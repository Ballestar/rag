00:00:18.280 - 00:00:38.230, Speaker A: Awesome. Let's get started. Hey, everyone. Thanks for joining the first day of Hack Money workshop. We have Tim from Teller doing a workshop on using Teller how to bring any data on chain. Question go into the zoom chat and Tim will answer them as they come in. And with that being said, I'll pass the mic off to Tim.
00:00:39.320 - 00:00:39.892, Speaker B: All right.
00:00:39.946 - 00:01:28.710, Speaker C: Thanks, Anna. Like Anna said, my name is Tim and I'm on the Teller dev team, and I'm here to talk about the Teller Oracle. So, just an overview of this workshop. I'll start by talking about Oracles in general and the Oracle problem. Then I'll give a quick introduction to Teller, and then we'll get a little bit more into detail on how Teller works. I'll show how to integrate Teller, and then we'll actually do a live code walkthrough. Then we will talk about using a custom data type, and finally we'll talk about actually paying for your data.
00:01:28.710 - 00:02:36.580, Speaker C: So what is the Oracle problem? Smart contracts don't have any way to access information about the outside world. They can't read APIs or know what the weather is. So you need some way to get data on chain. If your protocol depends on external data, and if the security of your protocol depends on the security of your data, you have to find some secure solution to get that data on chain. So there are many ways that people solve the Oracle problem. You could take the simplest route, which is pretty centralized, of just having a single address that is allowed to submit the data, and the contract just takes that information as is. So that's very simple.
00:02:36.580 - 00:02:45.032, Speaker C: But you have to trust that one individual. You can add a little more decentralization.
00:02:45.176 - 00:02:50.736, Speaker B: By using a multi SIG, which you.
00:02:50.758 - 00:03:23.050, Speaker C: Can have a whitelist of five addresses, for example. And maybe one address can submit some data, and then another two addresses are required to sign off on that data to accept it. Maybe that's a little better than the one address solution, but you're still depending on a select few individuals, and you have to trust them and trust that they will continue to provide the data.
00:03:25.660 - 00:03:30.956, Speaker B: There's also a common Oracle solution in.
00:03:30.978 - 00:04:21.100, Speaker C: The wild using AMMS. Like Uniswap. Uniswap has automatic trading between crypto assets, and so it automates a price, and people take advantage of arbitrage opportunities, which should, in theory, move the price towards the market price. But that also has its downsides. Using an AMM as an Oracle depends on a lot of liquidity. There's low liquidity, it's very cheap to manipulate prices. And then at the other end of the spectrum, you have decentralized Oracles.
00:04:21.100 - 00:04:29.676, Speaker C: And that leads us into an intro to Teller, which Teller is a decentralized.
00:04:29.788 - 00:04:35.820, Speaker B: Permissionless, flexible and crypto economically secure Oracle protocol.
00:04:35.980 - 00:05:09.230, Speaker C: Which sounds like a lot of buzwords, but let's break those down decentralization. Why does that matter? You don't want to depend on a select few individuals. You don't want to depend on the honesty of a few individuals, especially if you're trying to build a decentralized protocol. And that protocol depends on some data.
00:05:09.600 - 00:05:17.660, Speaker B: If you have a centralized Oracle, now you're centralizing a big part of your protocol.
00:05:19.940 - 00:05:21.840, Speaker C: There's also permissionlessness.
00:05:24.900 - 00:05:28.930, Speaker B: Do you have to go through some.
00:05:29.380 - 00:05:33.460, Speaker C: Company to ask permission to use a protocol?
00:05:34.280 - 00:05:35.364, Speaker B: Do you have to go through that.
00:05:35.402 - 00:05:56.824, Speaker C: Company to participate in that protocol? If you do, again, that is a risk. What if that company disappears one day or just decides to shut off your service one day? When you're building a protocol and you're.
00:05:56.872 - 00:06:00.444, Speaker B: Integrating some other protocol, you don't want.
00:06:00.482 - 00:06:10.320, Speaker C: To run the risk of one of your dependencies just being shut off one day and shutting down your project. There's also transparency.
00:06:10.900 - 00:06:15.840, Speaker B: Oracles are a tool, a service provider.
00:06:17.540 - 00:06:25.312, Speaker C: That provide a utility to other protocols. And so that other protocol has users.
00:06:25.456 - 00:06:28.932, Speaker B: And those users would probably want to.
00:06:28.986 - 00:06:46.570, Speaker C: Be able to verify the integrity of the data that they're using. So having a way of actually checking the mechanics, the goings on in the Oracle is probably an important thing.
00:06:46.960 - 00:06:53.144, Speaker B: There's also flexibility, the ability to cater.
00:06:53.192 - 00:06:56.812, Speaker C: To lots of different data types, different.
00:06:56.866 - 00:07:10.960, Speaker B: Use cases, and then crypto. Economic security, as in is good behavior, good data and equilibrium outcome.
00:07:11.880 - 00:08:05.924, Speaker C: And I would argue that Teller checks all of these boxes. So just an overview of how Teller works. Teller has data providers that we call reporters. These reporters deposit a stake of the TRB token and then they have the ability to submit data. So then users are able to request a particular piece of data and any of those staked reporters can then retrieve the data and submit it on chain. Once that data is on chain, then anyone can come in and dispute the bad data. And then once some data is on.
00:08:05.962 - 00:08:09.604, Speaker B: Chain and a little bit of time.
00:08:09.642 - 00:08:37.790, Speaker C: Has passed to allow for a dispute, then a user can retrieve the data. And I guess I should note that as soon as the data is on chain, a user can retrieve the data immediately. But it's best practice that they do wait on that dispute period to allow for some finality of that data. I'll talk a little bit about more about the dispute process.
00:08:40.260 - 00:08:43.808, Speaker B: So as soon as some data is.
00:08:43.814 - 00:08:54.052, Speaker C: On chain, again, it can be disputed. And anyone can pay a dispute fee in order to dispute that data.
00:08:54.186 - 00:08:58.304, Speaker B: And once it's disputed, it gets removed.
00:08:58.352 - 00:10:05.720, Speaker C: From the set of available Oracle values. And so then for a two day period, teller stakeholders can vote on whether that data was good or bad. And then at the end of that two day dispute period, there's another waiting period. And again someone can pay another dispute fee to challenge the outcome of that dispute. But eventually after that one day waiting period goes by, then the outcome of this dispute is determined. And then whoever won the outcome of the dispute, the reporter or the disputer, they get the dispute fee plus the reporter's stake. So because of that, people are incentivized to monitor the Oracle values and find a bad value so they can earn a reward.
00:10:05.720 - 00:11:51.820, Speaker C: And disputers are also disincentivized from disputing good values because they have to pay a dispute fee and they don't get that back if they lose the dispute. And I see a question in the chat here. Yeah, how long is the dispute period? And yeah, like I said, that was two days. So integrating Teller is pretty simple. We provide a helper library called using Teller which can be easily installed just NVM install using Teller and that is just using Teller is a single contract that you'll import into your own contract and it provides a number of Gitter functions to easily retrieve Oracle values. Also included in the Using Teller library is a contract called the Teller Playground and that is a sandbox environment and that's useful for testing. So you can simulate interacting with the Teller Oracle, but you don't have to go through the hurdles of staking and everything, but you can still write your test files and submit data and retrieve values similar to how you would in production.
00:11:51.820 - 00:12:10.460, Speaker C: And here you can see just an example of a simple function just retrieving a value. This get current value function is included in using Teller.
00:12:10.620 - 00:12:14.188, Speaker B: So you can see for example, you.
00:12:14.214 - 00:13:25.512, Speaker C: Would just input what we call a query ID, which is a unique identifier for a piece of data and we'll see a little bit more about what that means and how that's generated. So this get current value function is included in using Teller. It will return the most recent submission for that query ID along with the timestamp and a boolean value of whether the value is actually retrieved. And again, we'll see this a little bit in more depth in the code walkthrough. Jesse in the chat says what incentivizes reporters? Reporters are incentivized by tips from users and I will also talk about that a little bit more at the end of the presentation. But users, in order to request some.
00:13:25.566 - 00:13:29.740, Speaker B: Data, they do two things.
00:13:29.890 - 00:14:32.430, Speaker C: They provide a unique identifier to specify what data they want, which is called the query ID, and then they also pay for the data. Those are the two pieces of requesting some data. You would just want to pay enough to incentivize reporters to voluntarily fetch and submit a piece of data. So you would just have to cover gas and a little bit of profit. So let's move to a code walkthrough. Although I see another few questions. True equals uncontested value or 50% successful attack.
00:14:32.430 - 00:14:47.240, Speaker C: Oh, is that for get current value? Yeah, the get current value returns.
00:14:51.580 - 00:14:51.896, Speaker B: A.
00:14:51.918 - 00:16:20.430, Speaker C: Boolean value did get a value and a timestamp that did get boolean value refers to just whether any value exists for that query ID. So that just allows you to easily check whether if nothing exists at that query ID, you'll get a bitcoin price, for example, of zero. So this did get Boolean value tells you whether the bitcoin price is actually zero or we just didn't actually have any value for the bitcoin query ID. So let's do a live code walkthrough. So here we have a simple hard hat project set up already. And let's say you just set up an NPM project. In order to install Teller, all you would have to do is PM install using Teller and that will get using Teller installed in your project.
00:16:22.320 - 00:16:26.124, Speaker B: And then once you've done that, you.
00:16:26.162 - 00:17:29.276, Speaker C: Can import using Teller into your contract. And then you just pass the using Teller contract, inherit it into your contract. And then you also include using Teller in your constructor and you'll just input the address of the Teller Oracle. And so that will allow the getter functions to access the Teller contract. And then so in this example, we have a get bitcoin price function. So we just first set up the return values. Here again, the Boolean value if retrieve the timestamp of the value that was retrieved and then the actual value that was retrieved.
00:17:29.276 - 00:18:18.384, Speaker C: And so all Teller Oracle values are in bytes form. So that allows a lot of flexibility because you can encode just all sorts of different data types into bytes and then decode them back to your intended data type. So then once we have those variables set up, we use this get data before function. So that's different from that function we saw a couple of minutes ago. Get current value because remember, get current value returns the most recent value. This get data before is a more.
00:18:18.422 - 00:18:23.764, Speaker B: Preferred way of retrieving data where you.
00:18:23.802 - 00:18:33.384, Speaker C: Input the query ID again and also you input a timestamp. So you're retrieving the most recent piece.
00:18:33.422 - 00:18:46.060, Speaker B: Of data before this time that you input here's.
00:18:49.300 - 00:19:08.100, Speaker C: And in this example I use 30 minutes. Choosing that time is a bit of an art, but it's just good to the more time the better. But it's good to allow some time.
00:19:08.250 - 00:19:14.472, Speaker B: For people to monitor reported values, check.
00:19:14.526 - 00:20:21.190, Speaker C: Whether they're good and dispute them if they are bad values. So that's just a tip of best practices. And then and then here we just decode our our Bytes value into a UN 256 value. Parse B asks so a statement is true if whales do not coordinate to contest it, whales can mine staked value of honest agents. Um, yeah, so this if retrieve value as long as there is one.
00:20:24.920 - 00:20:25.524, Speaker B: Yeah.
00:20:25.642 - 00:21:25.370, Speaker C: As long as there's one value on chain for this query ID, then this if retrieve will return true. And so another point I should make is so where did we get this query idea here for this bitcoin price? We formed that up here. First we make some query data. In this case we're using what's called the spot price query type. And then we input arguments, in this case the Bitcoin and USD. So this query data and query ID, these are the way that we specify exactly what data we want.
00:21:25.820 - 00:21:31.176, Speaker B: We use that in conjunction with a.
00:21:31.198 - 00:21:41.676, Speaker C: Repo on our GitHub called Data Specs where we really lay out in more detail exactly what data is expected, how.
00:21:41.698 - 00:21:46.210, Speaker B: It'S formatted, what sources should be used.
00:21:47.620 - 00:22:19.770, Speaker C: What should be considered when disputing values. For example, let's actually get another price in here. Let's get the price of Ether as well. So we have this variable which will hold the price that we retrieve. We'll also make a variable for the ETH price query data.
00:22:34.980 - 00:22:35.730, Speaker B: It.
00:23:00.300 - 00:24:49.790, Speaker C: Now we've formed a unique identifier, a query ID for the Ether price. And so you can substitute anything else in there, you can specify any token or asset you want and we would retrieve that in a similar way, in pretty much the exact same way that we retrieve the Bitcoin price. So that is a simple example of retrieving some price data from the Telara Oracle. And remember, we formed a query data and a query ID to specify a unique identifier for the data we want. Do this get data before function from the using Teller library and by doing this, our contract in the chat. Let's move on from the code walkthrough. So what if you need some other custom data other than a spot price? You can define a new query type is what we call it, the proposal ID.
00:24:49.790 - 00:25:49.490, Speaker C: So yeah, if your hackathon project has some need for a custom data type, you can feel free to reach out to us for help. You can try to form it yourself and yeah, you'd probably be fine forming it yourself for the hackathon. And if you want to move to production we can definitely help you nail that down and get it exactly how it should be. But if you really want to make an official query type, you can make an issue in the Data Specs repo and there you'll find templates for how that should be done. And finally, talk about paying for data. In order to get data on chain you do need to incentivize the reporters to submit that data.
00:25:50.740 - 00:25:54.972, Speaker B: So again, you'd need that unique identifier.
00:25:55.036 - 00:26:31.340, Speaker C: That query ID to say exactly what you want. And then the second thing you need is an incentive. So we actually provide a contract called Auto Pay which allows you to put in a one time tip for just a single piece of data right now you can also set up a data feed at consistent intervals. So say you need the price of Ether at midnight every day. You could set that up in the Auto Pay contract.
00:26:32.000 - 00:26:36.512, Speaker B: And paying for data really just means.
00:26:36.646 - 00:27:29.650, Speaker C: Paying for gas plus a little bit of profit. So it's highly dependent on the expense of the chain you're using. On Polygon, for example, it can be very cheap. And on ethereum mainnet, it'll be a bit more expensive. So in review, Oracles provide external information about the world to smart contracts. And so if your protocol depends on data to be secure, then you are going to depend on a secure Oracle. And so Teller is a permissionless decentralized Oracle protocol and it incentivizes people to behave well.
00:27:29.650 - 00:27:59.288, Speaker C: You can easily integrate Teller using the using Teller library. It provides lots of gitter functions for retrieving the data you need and it also includes the sandbox, the Teller playground. So you can easily test things out and simulate using the Teller Oracle and you can really use any custom data.
00:27:59.374 - 00:28:02.316, Speaker B: Teller is very flexible and so you.
00:28:02.338 - 00:28:14.416, Speaker C: Can just define a new query type and that's how you specify exactly what data is expected, what you need. And finally, just in production, not for.
00:28:14.438 - 00:28:17.312, Speaker B: This hackathon, you would need to pay.
00:28:17.366 - 00:28:20.690, Speaker C: For data to incentivize the reporters to provide the data.
00:28:24.020 - 00:28:26.836, Speaker B: And if you need any help, the.
00:28:26.858 - 00:28:33.750, Speaker C: Teller team is always very active on Discord. You can find us there. My handle is there on the screen.
00:28:34.120 - 00:28:37.910, Speaker B: Heavy chain number nine, eight, eight.
00:28:39.740 - 00:28:43.540, Speaker C: And also there's lots of information on Teller IO.
00:28:43.700 - 00:28:47.128, Speaker B: You can find our docs there and.
00:28:47.214 - 00:29:21.700, Speaker C: Also our different social platforms. And finally there are a couple relevant resources there. The query Builder will help you form your query data and query ID. The data specs is also where you specify exactly, you specify a new data type. You can also see all the existing data types there. And also you can look into that using Teller library on our GitHub.
00:29:26.520 - 00:29:33.210, Speaker B: And that is it right on the 30 minutes mark.
00:29:33.900 - 00:30:10.710, Speaker A: Nice, thank you so much Tim, that was super interesting and definitely thank you for taking the time of your day to do this workshop. For the hack money hackers, Tim is reachable on the sponsor Teller Discord channel if you have any further questions either today or throughout the course of the hackathon. That being said, we have one more workshop today with Badger Dow tonight at 06:30 P.m. Eastern. Hope to see you all there and other than that, have great rest of your evening or morning, afternoon, depending on where you are.
00:30:12.520 - 00:30:15.460, Speaker C: Thanks Anna, and thanks everyone for listening.
00:30:16.840 - 00:30:18.690, Speaker A: See ya, take care.
