00:00:00.250 - 00:00:25.360, Speaker A: So we're going to do something different right now. We're going to have a special guest co hosting this thing with me. And I'd like to welcome Frenzy from the Ethereum Foundation, who's working on the Solidity Team, to co host the next few talks with us. And she'll be the one taking over for me. And I hope that you enjoy the rest of the day. So frenzy welcome. I'm super excited to have you back.
00:00:26.330 - 00:00:29.094, Speaker B: Hi, yeah, thank you for having me.
00:00:29.292 - 00:00:51.290, Speaker A: And it's awesome to see you here. Join us from a different part of the world. It's always awesome to get really nice members from our community and kind of make this event possible. And we're seeing so much excitement. We have a few hundred people joining us on YouTube and our TV chat, so it just gives me even more joy to have a lot more people excited about the merch.
00:00:52.590 - 00:01:20.498, Speaker B: Absolutely, yeah. Thanks so much, first of all, for having me as a co host for the second time now. I love those events. I think they are really the best way in the current state of the world to stay connected with everybody and to keep on exchanging on the current state of Ethereum and what's in store for the future of Ethereum. And yeah, I've been following the talk so far. I really like them. They were incredibly interesting and insightful.
00:01:20.498 - 00:01:59.710, Speaker B: And I think without further ado, I will do my job as a co host and introduce the first speaker that is up next. That's Jim McDonald. Jim is CTO of attestant. That's a company that specializes in building tools that improve the staking experience. And today, Jim is going to talk about Vouch client diversity without the downsides. Vouch is an open source, validator client designed to operate with multiple beacon nodes. And Jim today will talk about why client diversity is a good thing and how Vouch can provide client diversity without the downsides.
00:01:59.710 - 00:02:04.290, Speaker B: I am really excited to have you, Jim, and the stage is yours.
00:02:09.030 - 00:03:07.446, Speaker C: Thank you. Okay, so I'm going to mainly run to a set of slides that makes life easy for everyone, so hopefully people can see the slide deck. And what we're going to talk today, as Ranzi said, is really looking at some of the information around client diversity, what it is, why it matters, how we can achieve it most easily with the current configuration, and where we'd expect to go with it after the merge. So obviously, the first point is to understand what client diversity actually is. We hear a lot about it, but the question is, what does it really mean? So, from our point of view, client diversity means securing the Ethereum Two beacon chain with multiple implementations of the specification. So Ethereum Two is primarily a specification of which each beacon node carries out an implementation. Why do we want to do this? Why don't we just have a single implementation and everyone's happy? Well, first off.
00:03:07.446 - 00:03:56.360, Speaker C: Is it hardens the specification? If there is an assumption made in someone building a beacon node and there's just one beacon node out there, then that's the end of the story. However, if there are two or three beacon nodes out there then there can be questions about well, what does this really mean? I made an assumption here I thought that this corner case wasn't relevant, whatever it might be. As a result of that, you end up with a specification with a single implementation being relatively loose. So this hardens specification up. Everything in a specification has to be very clearly defined. It also hardens up implementations. So again, if we have just one or two implementations out there then they can make assumptions, they can read a certain piece of text in a certain way.
00:03:56.360 - 00:04:39.794, Speaker C: Unfortunately, English as the language that most specifications is written in is not as precise as it could be and is indeed very ambiguous in places. As a result of that, you can take a single read of the specification and create an implementation. You can create a second read of the specification and create a different implementation. If those implementations have to talk to each other as beacon nodes do, that however then means that they have to finally agree on something. So you cannot leave things open to your own interpretation once there's consensus involved. Because of that, having client diversity hardens each individual implementation. Finally it separates specification and implementation.
00:04:39.794 - 00:05:27.650, Speaker C: Now this is a really important point. The ideal world you can take a specification and create a full beacon node implementation from it. Equally, you could take a single beacon node implementation and rework backwards to create the full specification from that. The reason why you want that is because it means that each one is well defined. If your specification requires some kind of hidden knowledge inside the implementation then that means the specification isn't well formed, it requires information from elsewhere. So this means that client diversity helps everyone and everything in the infrastructure and ultimately it gives us a much more stable and stronger base on which we build the protocol. So great if we've decided that client diversity is a good thing, let's go pick a client.
00:05:27.650 - 00:05:51.850, Speaker C: There are lots of clients out there though, so here's five of them. These aren't the only clients out there that carry out the ethereum. Two spec, but a good example, there are lots of them out there. So if we want to pick a client, how do we do it? What do we choose? So let's have a look at some strategies. One of them is let's go and pick the least popular. Well, if we want to have client diversity, we don't want to pick the most popular or the second most popular. We want the least popular.
00:05:51.850 - 00:06:24.674, Speaker C: However, maybe it's least popular for a reason. Maybe it's not quite there yet. Maybe some of the features aren't fully working. Maybe it has security issues, who knows? The problem is that without any additional information, just picking the least popular to increase client diversity could put you and your validating at risk. So maybe you go for a primary that's a little bit more popular or well known and then you pick a backup. Trouble with that of course, is that you don't use the backup very often. So the backup might be sitting around waiting for the primary to fail.
00:06:24.674 - 00:06:51.200, Speaker C: And the primary never fails or fails three years from now. Because of that. It's a very tricky situation just to say, hey, we'll have a primary, no backup and we know the backup will be there. Unless you're continually testing it. That's a lot of work, a lot of effort, makes life quite tricky. Maybe what you can do is you can measure the beacon chain beacon nodes. You can have a look at each of them, you can measure them according to certain metrics and find out which one you're happiest with.
00:06:51.200 - 00:07:35.674, Speaker C: Problem with that of course, is choosing the right metrics. You might pick something like CPU footprint, but then again, a beacon node that doesn't carry out any proper work will have a much lower CPU footprint. Even though it doesn't succeed necessarily in creating the best blocks or the best attestations. You might have one has the lowest disk usage or network throughput. You might look for some metric that allows you to compare on chain performance. The problem is that you don't know which metric to use and the metrics will change as well. Over the last three to four months since the beacon chain went live, we have seen multiple revisions of all of the major clients as they go through their own testing internally, their own performance metrics.
00:07:35.674 - 00:08:39.220, Speaker C: They find bugs, they find optimizations, they will change. So even if you do find a perfect measurement and you measure it exactly and you pick a winner, the chances are your information is out of date two weeks later. So although there are lots of strategies for helping you to achieve client diversity, none of them really come without downsides. There are always issues to think about, there are always concerns, and as we've said, it's very, very much a moving target. So what if, what if you could run multiple clients at the same time? You could take the best information from each of them and use them to help secure the network while also gaining superior performance and great reliability. That's the type of thing that would be great because that way you take the best of every client, you work with them well, the rougher edges are smoothed out by other clients, you also get great performance and you get great reliability. So that would be a really nice thing to have.
00:08:39.220 - 00:09:12.342, Speaker C: And that is basically why we attestant Built Vouch. So Vouch is an open source validator client. We have designed it from the ground up to work against multiple beacon nodes. We don't twin it with any single beacon node. In fact, we most of the time actually have no knowledge of which beacon node we're talking to. We have a heavily beacon agnostic view. What we want it to do is give us the information we need so we can do our work equally.
00:09:12.342 - 00:09:57.414, Speaker C: Having just spent the last few minutes talking about client diversity, the last thing we want to do is make Vouch a new single point of failure. Make it a system that everything else funnels through. Because if we do that then we're back to where we started, where we have an ultimate client diversity of one. So because we want to avoid that, what we do is we offload as much work as we possibly can to the beacon nodes. We let the beacon nodes individually do all of the things that beacon nodes do. They gather state, they run state transition, they store historical data, they transfer data between beacon nodes, they do all of the things that you should do. And what we do in Vouch is we look at the information that they give us and we act as a decision maker.
00:09:57.414 - 00:10:35.894, Speaker C: So we will look at the information provided to us and we will decide which information is good or which information is best. And then finally we want to be resilient in the face of nodes that are unresponsive, maybe unsynchronized due to network errors or just internal problems or ones that are just slow. The reality is that beacon nodes all have different performance profiles. And one beacon node might be fantastic at generating proposals but doesn't do very well generating aggregate attestations. One might have a fantastic network stack but uses an awful lot of CPU. When we ask it to do work. There's all sorts of different pros and cons with each of them.
00:10:35.894 - 00:11:14.462, Speaker C: As mentioned, they're all getting way, way better and they're all stepping up. But the simple reality is they cannot all be best at everything. It's just not the way the world works. So we want to be able to talk to all of them and then be resilient if one of them suddenly stops responding, if we hit a bug or one of them has a problem with its network stack. Or we have a system where suddenly there's been some kind of packet flood attack and as a result one of the nodes goes offline. We need to continue to be resilient in all of these situations. So to give a more concrete example of what we're talking about, we'll think about the idea of block proposals.
00:11:14.462 - 00:11:49.870, Speaker C: So in Ethereum Two, when it becomes time to propose a block, each individual beacon node has its own view of state. It has its own view of all of the attestations that have yet to be included. It does its own work in creating aggregate attestations that will go into the blocks. So this is great for us. What we do is we say, okay, that's brilliant. What we want is we want a block proposal from each of you. So for every beacon node we're talking to, and again, it can be any number of beacon nodes we can run with any beacon node that works against the standard Ethereum Two API.
00:11:49.870 - 00:12:22.990, Speaker C: We can talk to the beacon nodes in parallel. We can have multiple instances of the same beacon node. So we could have two Prism nodes or three Prism nodes scattered around the planet. So maybe they're getting different views that way we could have a TECO and a lighthouse node wherever we want. We can sort of mix and match as we choose. And again, as mentioned, Vouch doesn't really know or care what client software each beacon node is running physically, where it's located or anything like that. When it comes to propose a block, Vouch will just ask for a proposal from every client of which it knows.
00:12:22.990 - 00:13:22.662, Speaker C: It will do it in parallel, it won't wait on one for the next one to come along and it will do this with a timeout. As mentioned, we need to be resilient in the face of a beacon node being unresponsive. Perhaps Vouch is sitting in Europe and a beacon node over in Asia we can't contact because of some kind of network glitch. We're not going to hang around and wait as a result. So we contact all of the nodes we can, we get it in parallel, we bring the data back to us as each beacon node generates a block and returns it to us, we have to decide which one we want to sign. The way we do that is by carrying out a scoring mechanism. So we'll start to dig into the contents of the block and we'll basically run the internal Ethereum Two scoring mechanism or similar based on the information that we have, but also very importantly, the information from the wider network.
00:13:22.662 - 00:14:31.314, Speaker C: So for example, if one beacon node is running for some reason, say it has a clock issue, we might end up getting a block that's earlier than actually the one that we asked for or one that doesn't have information about the correct parent block because it's had a network issue. There are lots of reasons and as we run this in a live environment we see lots of these reasons where for some issue or another we end up with a block that is non optimal. Maybe it doesn't have that many attestations and it may be the attestations it has in it haven't been heavily aggregated, whatever it might be. The idea is that we will boil all of this down into a simple score. So we will look at all of the attributes of the block we have received, we will score each of them and we will assign that score to that block. As more and more blocks come in, we can compare one against the other and we will end up with after all of the beacon nodes have returned their data, or after we've had timeouts from the ones that aren't going to respond to us, we will have a block proposal with the highest score as far as we have ranked it. Once we've got that, that's great.
00:14:31.314 - 00:15:06.622, Speaker C: We're now happy that we've done pretty well. We've got a block we're happy with. We will go through the standard signing process as you would expect, then we submit the block. Now again, we can just send the block out back to a single instance, but that doesn't necessarily guarantee that it will get the widest reach. If you send it to a beacon node that potentially again has network issues, so has very few peers. That block may not reach much of the network. So what you want to do is again in parallel and again with a timeout, obviously if a beacon node is unresponsive or similar we give up in the end.
00:15:06.622 - 00:16:12.638, Speaker C: But we want to submit that signed beacon block to every client we can reach by getting it to as many beacon nodes as possible. What that means is we end up in a situation where we have the greatest chance of getting that information out there, making it part of the chain. And obviously ultimately what we're trying to do here is secure the chain in the best way possible. And by doing this we are giving our block and the attestations in it the best chance possible to get out there be available. And as a result of that we can ensure that we have the best chances, we say, of that block being included in the network. Okay, so one of the questions that has been flying around is well, what kind of impact do we think the merge is going to have on what we're doing at the moment? Well first off, the merge will give us more data. We're going to have more data on the beacon chain, we're going to have more data flowing between nodes.
00:16:12.638 - 00:16:48.186, Speaker C: That is going to start showing up potential weaknesses in some network environments, it's going to show potential weaknesses in network stacks. So again, we won't expect all beacon nodes to be able to handle the new load as well as each other. There are going to be areas where one node might start to get even overloaded or similar. And it's not just down to the software. This involves potentially the hardware that our peers are running on. It doesn't really matter how powerful our hardware is. If all of our peers are running on low powered hardware and they're getting overwhelmed, that's going to slow down movement of data around the network.
00:16:48.186 - 00:18:05.400, Speaker C: So having more data will make the world that little bit harder in terms of ensuring that we can communicate individually with all the rest of the nodes in the network. And because of that obviously again, the more nodes we talk to the better that we have in terms of a chance of getting that information out there. Secondly, subjective data. One of the interesting points about the beacon node is that at any point in time, if we take state and then we say what should the next block look like in terms of who's its parent, how many attestations should it have, how should they be aggregated? There is an objective ideal block that could be created because of that. It makes life frankly relatively easily in terms of block creation and attestation selection. There are a few corners in there but ultimately it's a pretty simple thing to do. When we get to including application layer blocks, that changes because now we're including transactions and the world of transactions is large and wild and there are any number of ways you can slice and dice the information out there.
00:18:05.400 - 00:18:45.380, Speaker C: This means that then we have a situation coming down the line where suddenly the subjective selection of one piece of data over another into the application block will start to matter a lot more. This is a whole new area for Ethereum Two clients. Now potentially we hand a lot of this off back to the Ethereum One client to build. But equally there are other alternatives out there. There are people like Flashbots who are building their own systems. We need to start spending more time looking at this. But the fact that there is going to be subjective data makes things like scoring blocks, makes providing optimal blocks and similar a lot more difficult.
00:18:45.380 - 00:19:37.650, Speaker C: So it's something that as it comes down the line, it's really, really important to understand that the merge actually will make this kind of thing a lot more important in terms of being able to look at multiple feeds, multiple options for blocks and being able to score and select the best one. And then of course, more operational diversity. We're going to have ETH One clients and ETH Two clients working with each other because they're now talking to each other in more than just the trivial fashion that they did with the current beacon chain. It's going to become a lot more complicated. So we're going to see a big step change in terms of the complexity of the individual beacon nodes and their interactions. So just sort of summarize and look at what this means. Well, first off, and very, very important to understand, client diversity is important.
00:19:37.650 - 00:20:11.082, Speaker C: It's not just important to the network, it is important to you. It is important to you as someone who wants to send transactions on the Ethereum network. It is important to you as the validator. It matters because without client diversity we'll end up with non permanent specification. We'll have specifications that have ill defined areas that are never caught because there's only a small number of implementations and they never find them. As we've said though, client diversity comes at a cost and the cost is your own ability to validate. If you want to run a minority client.
00:20:11.082 - 00:20:55.600, Speaker C: Fantastic. But there are less resources out on the net to help you with them. Potentially it's not as secure in terms of some of the features and systems that are running in it simple example is some of the clients weren't actually active at the time that Madasha had its rough time. Incident. As a result of that, there are situations that the less used clients have yet to be in. So there's always a concern that if you start to run these, you're going to end up in a situation where you are somehow disadvantaged. And client diversity is great and network diversity is fantastic, but very few people want to do it if it involves a direct cost to them compared to everyone else around them.
00:20:55.600 - 00:21:32.490, Speaker C: So Vouch is one way that we've provided that will allow you to support client diversity. It doesn't give you any sacrifice in performance or reliability and in fact can increase both. There might be a minority client out there that isn't brilliant on the networking, it struggles a bit on CPU, but you know what it's brilliant at? Creating aggregate attestations. If that's what it does, if that's the best piece of it, that's fantastic. Voucher will basically use that when you bring a block in. It will score it very highly, it will use that. So not every client will be best at everything.
00:21:32.490 - 00:22:18.150, Speaker C: Not every client can be best at everything, but you can still run them and get the benefits of each of them without experiencing the downsides. That is it for the talk. We'll do some Q and A in a second, but just wanted to say, as we mentioned, this is an open source project. There is a URL there where you can download Vouch. It's used already in a number of areas, obviously internally inside our own infrastructure, but also elsewhere there are other areas where obviously if you go on there, you can file issues, you can contact us on our discord. There's a lot of areas where you can get the information about Vouch and obviously take a look to see if it's something that you would be interested in running to help provide that client diversity for the network.
00:22:20.270 - 00:22:54.510, Speaker B: Amazing. Thank you so much Jim, that was truly fascinating. So far I've only received a few comments here, two attestations that you are indeed a rock star and people were asking if Vouch is open source. You already responded to that. Yes, it is open source and here in the GitHub link you can have a look and probably also contribute. Are there any other questions for Jim? Let me check. Other than that I also believe he will be available in the chat.
00:22:54.510 - 00:22:55.042, Speaker B: Right?
00:22:55.096 - 00:23:49.842, Speaker C: Absolutely. And it's worth saying, obviously, yes, it is an open source project and there's a lot of stuff that can be done and added to it. So we have our own focus on what we think needs to be in there. But we definitely have other people's ideas that are coming in and it's something that and again, I strongly believe that with projects like this, the idea is to give people as much flexibility so they can create their own systems. For example, some people actually use Vouch not to validate, but actually to pull a bunch of additional metrics out so that you can provide comparative information across different beacon nodes in terms of how well they create blocks or attestations or aggregates or similar. So you can start to do that type of thing too. So, yeah, absolutely, it's primarily a validator client, but we have had other people actually manage to play with a few different variants on a theme.
00:23:49.842 - 00:23:54.710, Speaker C: And yes, as always, pull requests are gratefully received.
00:23:55.930 - 00:24:04.570, Speaker B: Yeah, amazing. Interesting. So now the questions are flowing in. The first question is, with regards to your roadmap, what's next for Vouch?
00:24:06.190 - 00:24:28.078, Speaker C: So there are two streams for Vouch. One, obviously, is keeping track of the new changes. So we're starting to work on Altair. Altair, I'm sure you're all aware, is the first hard fork for Ethereum two that's meant to be going, we're not sure yet. June, July, August, whenever it may be. So we're starting to build out some additional work there to support that. The biggest piece for us will be sync committees.
00:24:28.078 - 00:25:00.006, Speaker C: So sync committees are a new feature that Validators will have to support. So that's going in there. So obviously we're keeping track of that. And a little bit further out, we're also looking at the changes the merge provide separately. We're always looking at enhancing some of the strategies that Vouch uses. We mentioned about scoring of blocks and attestations and similar. There are always ways in which they can be improved, where the efficiency can be increased, or equally, people can have different inputs on what they find valuable and what they want to score highly.
00:25:00.006 - 00:25:03.840, Speaker C: So, absolutely, they're kind of the two rough streams that we're working with.
00:25:04.770 - 00:25:13.490, Speaker B: Okay, cool. Then the next question would be, do you see Vouch implementing other social ranking mechanisms like they are used in evolutionary computing?
00:25:15.030 - 00:26:17.160, Speaker C: So one of the things that we played around with in Vouch was actually what we called synthetics. The idea that we don't take any of the information from any of the existing beacon nodes as gospel and we don't take them whole, but we use them all as advisory and then we break them apart and use that information to create our own synthetic proposals or attestations. Now, part of that would obviously be trusting the information that's coming to us and there's a lot more of that coming down the line. So yes, up to a point equally, at this moment in time, we let the beacon nodes guide us very heavily in terms of what comes through. So again, we want to be a little bit careful about taking doing too much ourselves. As mentioned, we want to be a relatively small piece in the puzzle that AIDS client diversity, increases reliability and performance without attempting to kind of take over the world. So we have to be a little bit careful about adding things like social ranking and similar into the system.
00:26:18.570 - 00:26:27.590, Speaker B: Okay. And then last but not least, do you see Vouch also for e one nodes asked by a guest developer?
00:26:30.810 - 00:27:14.514, Speaker C: Vouch will integrate in some way with ETH one node. So obviously, when we get to the point of the merge, if you think about the merge, at some stage an e two validator will have to propose a block, and the question then is where that block comes from. If ethereum two nodes themselves talk to ethereum one nodes and generate that, that's fine. Alternatively, and quite possibly, Vouch would talk directly to ethereum one nodes separately to, again gain the best application block it can find. That could also incidentally apply, as we said, to other areas like Flashbots and similar. So, yes, we certainly want to and I think we will add that, as we say as part of the merge. But yeah, totally.
00:27:14.514 - 00:27:25.910, Speaker C: Because the benefits, again, for client diversity in ethereum one, the application layer are as strong, if not stronger than the benefits in the beacon node.
00:27:27.450 - 00:27:32.700, Speaker B: Fascinating. All right. Thank you so much, Jim, for sharing all these insights with us.
