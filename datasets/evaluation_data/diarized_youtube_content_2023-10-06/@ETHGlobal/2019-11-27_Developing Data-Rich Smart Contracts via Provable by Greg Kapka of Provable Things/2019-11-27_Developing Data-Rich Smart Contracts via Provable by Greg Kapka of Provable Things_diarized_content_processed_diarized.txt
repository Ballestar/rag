00:00:10.600 - 00:00:46.536, Speaker A: Who here knows who proven all things are anyone who's heard of Oracle. We are Oracle. We used to be Oracle, but now proven all things. But they're still the same. And we're here to show you how to develop data rich smart contracts on Ethereum. Who needs like external data for this market? Because that is what we do. I'm going to read it out and you can all read as well.
00:00:46.536 - 00:01:16.416, Speaker A: But we are a security oriented data transport layer for decentralized applications to connect with web APIs. We're a reliable bridge between smart contracts and the Internet. Cool diagram to describe pretty much exactly that. And the technologies we use are obviously blockchain and trusted computing. You can see our repo at the bottom there if you want to have a glance. It comes on there. Probably better at the example, but we'll get to this in a bit.
00:01:16.416 - 00:01:41.960, Speaker A: So, some facts about us. I'm going to go quite quick so we can get to the code because that's the bit that you're hearing about. But we've been live on the main net since 2015, so that was back when we were authorified. We have been here for a while doing our thing. We've done over a million quick. I mean that's actually all way more than that now. Probably 2 million now on the main net.
00:01:41.960 - 00:02:16.310, Speaker A: We've been adopted by thousands of projects and are available currently on five different blockchains. We are blockchain agnostic in terms of the service. We try and work on all sorts of places, basically anywhere where there is demand for us, we go. So if you are working on a different blockchain and you need an Oracle service, send us an email and say, hey, let's see if we can deploy on it. We are in books as well. If you haven't read this book, you should we're in it, but that's not why you should read it. So, yeah, we've been in the space, we know a few things.
00:02:16.310 - 00:02:57.856, Speaker A: We use a single API to allow your contract to use external data and this is pretty much all you need to know in order to use this. So obviously there's a very important ellipsis there which is hiding a little bit of stuff, but not much. So other than the ellipsis, this is all you need. You need our API, which if you're using Remix who uses Remix here? Anyone uses truffle. Good, we've got you all covered. We're on both. I prefer Truffle only because it's this laptop making noises, but I've been lent it.
00:02:57.856 - 00:03:15.668, Speaker A: Wonderful. I wouldn't have a foot out, I've never used my text, but it's very old. Thank you so much. Here we go. So that bottom line. Import GitHub.com rflies oops.
00:03:15.668 - 00:03:59.076, Speaker A: That should say provable things. I should have paid more attention. The API bit is correct, but it should be API. Stop with that imported into the top of your contract, you'll get access to our entire API who's method you can use to call any URL you like via the construction, which is a bit higher up to where it says Provable underscore query. So first we inherited use Provable and then we can call that query to make our query, as I've already spoiled ahead of time. We are on all sorts of different development environments. We've got the Zeppelin kits that they are running there with Truffle, with Remix plugin there.
00:03:59.076 - 00:04:42.180, Speaker A: We try and get everywhere because like most of these places, like the developers who are important and we need to make it as easy as possible for us. I was going to say, you guys, we need to be easy so that we can actually build cool things instead of being mired down into lots of docs. So that's what we go for. So I'm going to show you this, which is our simple way of using it with Truffle. So I haven't got an example showing Remix, but it is as easy as copy and paste code in. In fact, in our examples repo, any of those examples can be dropped straight into Remix. Just copy and paste it and you can go straight from so it does that with Truffle.
00:04:42.180 - 00:05:09.064, Speaker A: We provide the Truffle box, which is a great way to get familiar with the service. If you just have a look at that thing there Truffle boxes before. Yeah, they're super easy, right? It's so our Truffle box does all those same things for you. You pull it down, it pulls down a smart contract. That's an example. It pulls down our API. It has everything imported.
00:05:09.064 - 00:05:55.144, Speaker A: And more importantly, it includes one extra special bit, which and the extra special bit is what we call the Ethereum Bridge. And the reason this is extra special is this means that you can leverage our service on any blockchain of your choosing, whether it's private or not. So when you're developing in Truffle, you're going to be using the Truffle framework and you want to spin up a local chain. You don't want to have to keep using ring or whatever. You want to use a local Gnash chain via trouble. So everything's into the miner, which means you can iterate over your tests faster and you should be testing all the time, especially when it's mining. So the Ethereum Bridge allows that to happen.
00:05:55.144 - 00:06:33.328, Speaker A: So you can use our service in your completely local dev environment and still get the same Provable Oracle service. Which is great, I wouldn't say that. But I also can get a look at the triple box in as simple as that. This is the only slide I have on it. So if you want to do it, feel free. But it's going to be on your own after these three commands. But it is to show you how the open Vetwin Primable Tiger Kit suspensions.
00:06:33.328 - 00:07:15.540, Speaker A: How did you how did the travel box and that compare? Okay, half my mind practice. Oh, yes. So the Zep kit has actually got a full front end stack on it as well. Okay, so I think it's a different example, but the actual back end smart contract is exactly the same as any of our approval ones. It uses the exact same API, the exact same query style. It just has a front end bolted on. So if you're interested in developing a smart contract specifically, and you're just going to do any old front end quick and easy, probably quick to go with Trufflebox if you want a more polished stack, but it's probably a bit harder to hack into because it's a bit more finished.
00:07:15.540 - 00:07:52.640, Speaker A: I don't have any slides on the deck. It's really cool. So when you downloaded the trouble box, you can just run the test like this. The reason we've set it, so you can run tests straight away, is because if you do that, you'll get to see that it is making a Provable query whilst you watch it. And that's in your local Ganache chain, that it spins up all the tests and it's super fast. Iterating over your smartphone, even when they need to get external data. Now, this is the important, this is what we care about.
00:07:52.640 - 00:08:42.240, Speaker A: So race through the things. Any questions first before I show sweet, let's see it. Right, this is a complete smart contract that works and is using our API in order to get external data. So you can make this available on, but you can just copy and paste it and it's a very important contract because as you can see, we're actually trying to find out the temperature here at East Boston. So, granted, you can just go outside, but we do it this way. So what you are looking at here is the basic framework of making approval for queer. And you can see right at the top you have an import statement.
00:08:42.240 - 00:09:17.488, Speaker A: Once that's imported, all you need to do is inherit it, which is what's happening on the contract temperature. It's using provable. We called it using Provable because it reads way nicer. And then you have a bunch of stuff. The jacket required cooling the temperature at the bottom, which is what we don't know yet. What we do know, and the temperature under which a jacket is required, which I have put 18 because I am from the UK. And that is 18 degrees.
00:09:17.488 - 00:09:52.852, Speaker A: I have no idea what it is fahrenheit, it's probably really cold, but 18 degrees is my temperature. More importantly, in order to use the API, you need to make approval queries, which if you look at the function, get temperature you can see. And it is as simple as passing in two parameters. In this case, the first one is URL capitalized and that is what we are calling this data for. So we're saying, hey, Provable, please make me a URL query. And the next parameter is unsurprisingly the URL that you want. All right, ignore the JSON wrapping around it for 1 second.
00:09:52.852 - 00:10:35.616, Speaker A: But all you can see is we've got a generic URL to a weather API that glitch me with a last few longitudes that I put in that happen to coincide with where we are tapped right now. And with those two bit of info I-E-A URL and a request for a URL, we have our approval query. Now the JSON bit around it simply is an extra bit that you don't have to do, but it's a useful tool where it allows you to pass the response from a URL. Because if you're going to call random URL APIs, you might get giant responses. And the way they are returned to your contract is via a string. And if it's giant, it won't fit. You can't get one in a block in a single transaction.
00:10:35.616 - 00:11:12.976, Speaker A: So if it's a JSON, we can actually pass down the bits we want. So that what you get in your contract is only what you're after. So this is what the JSON brackets and then main temp is just saying hey, I want to read JSON and I want the main value temperature. So once you have that function set up, you have approval period ready to go. What needs is a callback. Our standard way of doing a callback is by the double underscore and the callback takes three. Having two parameters can't read in this case and they are the query ID and a string which will be the result.
00:11:12.976 - 00:11:53.192, Speaker A: So this callback function is actually what the approval service calls, which is why the next line has a requirement on it to check whether the method sender calling. This function is indeed approval address because you don't want this to be fault by anybody. Otherwise anyone can send whatever data they like to your contract. You want us to send you the data that you requested provably and that's what the requirement. At that point we're going to actually look at our result, which here I've actually just passed it as an int. It's actually a uint, so that's but the pass int, if any of you are familiar with solidity, is not a solidity function. It is one of the helper functions we provide in the API.
00:11:53.192 - 00:12:39.868, Speaker A: So when you inherited it at the top, it comes with a whole bunch of helper functions which don't get compiled unless you actually call them in your contract. So it's nice and light. In this case it will compile passing function because we've used it where we set in a boolean to whether the temperature under which jacket required is greater than or equal to the actual temperature that is the result. And finally we actually just log the result so people can see it when you run code. So if I could have shown you this on remix, but what I'm going to do is trust you all can click buttons the same as I can into Remix and run it straight away. The point being this is the entire thing. This is all you need to be able to call any API, along with there is an API that you have access to from the proof or service.
00:12:39.868 - 00:13:40.652, Speaker A: It is that easy. If you're making a smart contract today and tomorrow, maybe in the morning and need external data, this is the quickest, easiest and provable way to do it. Incidentally, why we call provable things, it's because we're actually using Provably, which this example isn't showing you. This is just a very simple basic way to get up and run. But by provable we mean that we supply with our API called authenticity Proof, which are cryptographic guarantees to prove that no time for passenger, I just read that slide. We use various ways to provide these guarantees, all of them backed by Tees, which if you've been told folks today, you're kind of familiar with Tees. Now, who is familiar with Te? Exc a Te is a trusted executing environment which is some form of hardware or chip that provides cryptographic encryption of stuff happening.
00:13:40.652 - 00:14:22.732, Speaker A: So SGX, Intel SGX is one of them, amazon and Tlsn notary provides a cryptographic proof in the Te Android has its own sandboxing, which you can use as a Tee. The ledger, if you're using ledgers and all the various hardware wallets, they are execution environments and we use all of them to do things and say hey look, you asked us to read this API and we did it via this trusted execution environment and provide a proof to do it, that we did it. So you get the result back and approve and you can verify that yourself. So you don't have to trust us anymore. We don't want you to trust us. We're very trustworthy. Of course we don't trust in this space.
00:14:22.732 - 00:15:02.196, Speaker A: We verify and so we provide proofs so that you can verify we have done, or rather the thing you have asked to be done was done, not us doing it. It's our execution environment. So I've highlighted it in orange yellow to show you how you would use a proof in a query. So here is another complete example. This time we're doing something that everybody wants to know, which is getting the price of ethereum in this one's in Bitcoin, I thought it was in USD, but it's not. But again, this is a common thing on the ethereum chain. There's no concept of a US dollar power use of ethereum.
00:15:02.196 - 00:15:37.380, Speaker A: It doesn't know what it's worth. But we can find out via an external API. The key from this one is that we have the two functions. One calling approval query, again using URL, again using JSON password, so that we can get the particular value we want out of the URL. Again we're using the callback, but this time the callback has three parameters. Third one being the proof. So we return the ID, which is a hash which is unique to your ID, which means you can use to track your IDs in example, all of which we have on our GitHub.
00:15:37.380 - 00:16:14.016, Speaker A: You got the string result again and now we have the bytes, which are the proof here. We're not actually using the proof, it was just put in here to show you that we do provide the proof. And the key on this one is that you can see where the constructor is, how we actually tell the service which proof type we want. So in this one we're saying proof will set proof and we want android proof, please. Which means it's going to use the android pee to perform your query and then it will return to you your result plus a proof that it was done in that way. And you can take that proof and you can go and validate yourself and say, hey, that is correct. And then you can trust us.
00:16:14.016 - 00:17:10.732, Speaker A: You just have to trust Android. So that's cool. It was pastry instruction that was like a really interesting, very charged here's another example, this one is super important which is diesel prices. When was the last time you needed a diesel price? I don't even have a car so I've never diesel price. But if you did, here's how you would do it using approval again look at that bottom function it is simply approvable underscore query calling the URL data source. And a URL itself this time, whatever that is fuelfundy gov. This time the parsing wrapper around it uses an XML parser.
00:17:10.732 - 00:17:41.896, Speaker A: So we're passing like a Roy XML given by the website, so that's a different way from parser. Integrated guidance JSON. And the other bit that's important about this example is the constructor and the proof type. This time we're asking for a Tlsm, notary proof. So this is the Amazon backed one. And more importantly, we're asking for proof storage this time. So what does that mean? What it means when you ask is the Tlsn proof is massive.
00:17:41.896 - 00:18:29.912, Speaker A: So it's the same problem I mentioned earlier, where if you just query a URL, you might get a lot of data. That string won't fit inside the fork. It won't fit inside a fork. Too much data. The Tlsn proof is the same. It's a very big cryptographic proof and is a variable size. So instead of trying to feed that all to go and you can validate it that way, there's a different proof type which is storage.
00:18:29.912 - 00:18:58.980, Speaker A: So that's cool about that one. This is the last one, so this is hard to follow. All the code will be available, don't worry. This is another key feature of whenever you're doing anything cool on blockchain, and that is randomness. And it's like the first lesson you learn is noticing as randomness on a determined blockchain. So randomness is difficult. And here is a way you can get randomness that is provably random.
00:18:58.980 - 00:19:43.120, Speaker A: So again, we import our API of Doc and this is the random data source we're going to use. But the key on this one is we're using a ledger proof. Now, the reason we're using ledger proof is that the random bytes are created on two ways. Thank you. One way is to actually use the random number generator on the ledger itself to create the random bytes. And the next is to use the PE of the ledger to say, hey, I created those bytes. So this is why for our random data stuff, we use the ledger group type.
00:19:43.120 - 00:20:06.340, Speaker A: And again, this means you have to trust ledger people that manufacture the device. You don't have to trust us anymore because you can verify that. Oh yes, a ledger made this randomness and it proved it. So once we've set that up, this is how you get your randomness. So this time we're using what we got. We call it the Get Provable random bytes function. We're going to ask for seven bytes delay.
00:20:06.340 - 00:20:37.264, Speaker A: That's a new thing. Here's a parameter you can add if you like. And it's a delay, which is to say provable, give me a query result, but do it later. So if any of you have written smart contracts where you want something to call it after a day that's kind of hard to do, it can't be called itself and you can't delay anything on chain, but if you make a provable query, you can. So in this case I didn't, I made the delay zero. So I'm not sure why, but there it is. But you can have that and it's up to 60 days, whatever that is, in a Unix sorry, in testimony.
00:20:37.264 - 00:21:25.972, Speaker A: So if it delays and the callback gas is 200K, which is another thing, which is that when you make a proofable query, it is the provable service that calls the callback function. And in order to do that, it has to have gas to do it. And of course we want the contract who makes that call to be the one to pay that gas. So you define how much gas you want to be taking out of your contract at the time of your call in order to power that callback. Now in this case we've asked you 200,000, but what you would do in practice is run your callback itself to find out how much gas it costs and then ask for that amount so that you're not wasting. You can also burden the caller with that gas cost if you want the caller to be the one paying for the query. Which is a common use case.
00:21:25.972 - 00:22:40.392, Speaker A: So common in fact, that I wrote an example in the ethereum example on our GitHub to show you how to burden the callback. But in this case we are asking for 200,000 callback gas to power our callback. So this time we're not calling brutal underscore query, we're calling Brutal new random DS query DS, standing for data source. Probably should have just written data source and passing it our delay our number of bytes on our callback gas, and that's it. Here we get our callback the same format as all the rest of them underscore callback three params query ID, the string of the result and the bytes that are the proof. In this case, though, the reason this example is here is because of the ledger proof and because of the way it's set up, we can verify the ledger proof on chain, which means that you can switch in your contract on whether or not your proof was valid or not. So the other proofs and the different ways they work with Amazon and Co who are various different ways to do it, you can validate them off chain because of the size of the proofs and the way that you have to ask certain services that they did think that it's impossible on chain ledger proof because it's both small and the code we wrote means that you can validate that on chain.
00:22:40.392 - 00:23:18.010, Speaker A: Which is great, because now, especially with randomness, it means you can trust the randomness in a completely decentralized fashion. You can just rely on the contractor switch on whether or not it passes. So it's a bit of a mouthful. The function, the approval underscore random, DS underscore proof verify underscore return code. But all we're doing is calling a function that's in the API, passing it the pieces of data we got back and saying does equal zero. So if it does, we're saying, hey, our fruit passed, now we can do what we want with our randomness. And the else, of course, you would handle that however you like.
00:23:18.010 - 00:23:54.992, Speaker A: So I won't go through the last bit of code there, which is about how we're actually turning our bytes into a random number. That's just some math. You can have a quick look in our repo for that. I think there's a more descriptive version annotation for that. But basically all we're saying is, hey, I got some random bytes from a ledger. How do I turn that into a number so I can use it for so that one is the last and probably most advanced example I'm showing you today by how to get a randomness. So that just tells you pretty much everything I did about it, except for the bottom bit, which is to say all I've shown you today are the URL data source and the random data sources.
00:23:54.992 - 00:24:26.188, Speaker A: But we also have a Wolfram alpha data source. If you want a Wolfram alpha query, we could do nested queries. Nested queries are cool, which is if you want to say, hey, I want some randomness, but then I want to use that randomness to make the URL query, that would be a Nested data source. You just chain them up, chain away, encrypted queries, they're great. What if you're calling a URL that has a password or it has some form of credentials? You don't want those credentials publicly on the blockchain. Well, we have an encrypted query so that you can encrypt it so it's on the blockchain but nobody can read it. Even better.
00:24:26.188 - 00:25:05.496, Speaker A: And then the last one is the real powerhouse. I'll just give you the taster in the computation data source which is where you say hey, make me a query. And that query can be anything you want. And how it works is that we spin up a AWS instance and run a docker file of your providing, and inside that docker, you can run whatever code you like. So that we can basically query your docker file, have it run its code, and whatever it returns is what the provable service returns to you. Which means you can now do arbitrary computation that fits in a five minute window is the only caveat with a smart contract. So you can basically do anything you like.
00:25:05.496 - 00:25:45.312, Speaker A: Now you no longer can bind to validity to block sizes, gas amounts or anything. So super cool. Oh, there was another example but I don't have time for it, so I'm going to skip it. This is proof verification tool down here for verifying the other proofs I mentioned. Although the ledger and the random data source proof will form the onchain so you don't need this tool if you need it for the other one. And finally, these two little extra tools are ways for you to the Tech query tool, especially the top one will be of use to you if you're using this for this hackathon because it's a very good way for you to throw a URL at it and then see what the service will give you back. So you don't have to do it via a smart contract.
00:25:45.312 - 00:26:17.552, Speaker A: You can just run that tool and say, hey, what does that give me back? And you'll see exactly what proofable will return to your smart contract. They're super quick for figuring stuff out. Finally, congratulations, you're approval expert after that whirlwind talk. But more importantly, get using our API in your hacks. We've got $5,000 worth of API credits for your for whomever does it the most awesome, which will be all of you. There you go. Any questions after that? Rapid fire maybe? Go ahead.
00:26:17.552 - 00:26:59.150, Speaker A: So it seems like generally you would have one smart contract per query. It doesn't seem flexible to have multiple. Why not? Well, you have the underscore underscore callback when you make a query. I didn't mention this, but when you make a query when you actually call Provable query, it returns to you the query ID. So all of those I just called it so it looks super simple but you can actually get a return from that which is a query ID. And that query ID is what is the first parameter in the callback which means you can switch off that query ID. So you can make multiple query types and just store the ID and then do whatever you need depending on cool.
00:26:59.150 - 00:27:42.540, Speaker A: Anyone else? Yes, amazon. AWS. So you can prove it run. Prove when it ran, it's all provable. Yeah. Enemy, are you able to also use yeah. So we have an integration coming on Loom and others, but basically at the minute with the Ethereum bridge, which I briefly touched on, if you have anything that is ethereum and EVM based, it will work out of the box.
00:27:42.540 - 00:27:49.720, Speaker A: So it's that simple. For the ones that aren't quite the same as EVM, like the OA system, it's.
