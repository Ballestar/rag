00:00:00.490 - 00:00:27.382, Speaker A: So hello everyone. Well said. Hello everyone. And thanks, Anna, for introducing me. And today I'm going to talk about some of the limitations of privacy. Basically, what I want to talk about here is that when we want to make private applications, we start out thinking that, oh, well, we can just take Ethereum and make everything in Ethereum private, or take a random blockchain and make everything inside it of it. But it's actually more complicated than that.
00:00:27.382 - 00:00:57.630, Speaker A: It turns out that making private things is this kind of complicated and private paradigm. And that's what I'm going to try and explore today. So let's dig in. So let's take an example of some things that we want to make private. For example, we want to be able to make private transfers so you can just send private money to people. We want to be able to make private trades on an exchange so other people can see what you're trading. And we would like to be able to make private smart contracts and more general things.
00:00:57.630 - 00:01:40.742, Speaker A: But in this talk, we're going to discuss why that's not really possible without some major cryptographic breakthroughs with the same kind of trust assumptions that we're comfortable with or we currently have. So let's start a bit slowly, and let's take an example of some of the applications that you can use to make private transfers. So, for example, we can use Tornado Cash. Tornado Cash is a mixer on ethereum. So basically, you can deposit in this picture, it's 0.1 Ether, and you get added to a group of people who've also deposited 0.1 Ether.
00:01:40.742 - 00:02:18.358, Speaker A: And then you're able to make a zero knowledge proof to prove that you were one of the people who performed a deposit and also prove that you haven't performed a withdrawal. And if you can make those two proofs, then the smart contract will let you withdraw 0.1 Ether. So that's how tornado cash works. And Aztec and ZK Opera are similar to this, but they have like, a higher scaling benefit. So Aztec is a ZK roll up. It's a ZkZk roll up, which means it uses zero knowledge proofs for privacy, but it also uses zero knowledge proofs for scalability.
00:02:18.358 - 00:02:50.402, Speaker A: ZK Optimistic Rollup is a little bit different. ZK Optimistic Rollup uses ZK technology for privacy, and it uses optimistic rollup techniques like what optimism and Arbitrum use for scalability. And all of these support private transfers. And ZK Opera also supports private atomic swaps. So you could theoretically build a private exchange using ZK Optimistic Roll up. Okay, so we can do transfers. So let's talk about private trades a little bit more.
00:02:50.402 - 00:03:33.834, Speaker A: So we have this idea of maybe people are familiar with dark pools. Dark pool is basically a way to prove it's. Like this idea from the financial world where you have an exchange where all of the orders that you place are private. The traditional markets that they have, all trades are published while they're searching for someone to match with them. And basically the way that it works now is that there's just some kind of central party that will promise not to share your orders with anyone else unless it can execute it, and then it'll just execute your order and give that to you. So we would like to be able to do that with ethereum as well. But the problem is that you need to find someone to make your trade.
00:03:33.834 - 00:04:50.554, Speaker A: And we're not really comfortable having a centralized party that says, oh yeah, it's okay, you can trust us. We're going to make this trade for you, and we're not going to tell anyone what trade you want to make until we're just going to settle it for you. We're just not really comfortable making that assumption because who would we even pick to do that? Who would we pick such that everyone would say, oh yeah, I'm okay to trust that person to do this? So instead we want to do this in a private way, and we know that we're able to settle the trade with ZK optimistic roll up, for example, or with some other roll up that ZK ZK roll up or something else that we could build. But we're not able to find our trading partner, which is a problem. So one of the ways that we have to do this is to use a multiparty computation methods to try and find the person we're trading with. And I'll talk about that a little bit later. Basically what we have here is what we've done so far is we've talked about the VK applications where there's like a private state that users are able to kind of okay, so imagine I'm in tornado cash when I deposit my 0.1
00:04:50.554 - 00:05:36.840, Speaker A: ether. I go into this kind of group and I have some secret information that only I know that lets me prove that I'm part of this group. That's my private state. But there's also this idea of global state that we have this kind of global state, which is the list of all of the people who have performed a deposit until now. That's like our global state. But the problem comes when we want to have global private state, right? When we want to have state that nobody knows, but also everyone needs to know it in order to be able to withdraw. So this becomes a problem when we want to make private generic smart contracts because in ethereum or in Cryptocurrency in general, all of our smart contracts need to have this kind of global state.
00:05:36.840 - 00:06:33.654, Speaker A: Global state is any public variable in your smart contract. Anything that everyone needs to know. The example that I like to use is Uniswap, where we have like a global state which everyone needs to know in order to make a trade because you need to be able to make a proof about that state in order to prove you're not kind of cheating anyone. Yeah, so that's what global state is. And when we have global state that we want to hide, it becomes really difficult for us to do that because okay, let's imagine again, let's say we have a global state that we don't want anyone to know, and every user in the system needs to know that global state in order to withdraw their coins from uniswap, for example. That just is impossible, right? It's not possible to have both at the same time. So let's take an example and dig a little bit deeper.
00:06:33.654 - 00:07:27.034, Speaker A: So I don't know if everyone knows uniswap, but basically uniswap is an exchange where you have a token pool of pool A, token A and token B. And these tokens have been gathered together in a pool in the smart contract. And you're able to withdraw token B by depositing token A and you're able to withdraw token A by depositing token B. But you need to know the ratio between token A and token B. You need to know the ratio of the amount of token A and the amount of token B in the pool in order to find out how much of token B you're able to withdraw when you deposit a certain amount of token A. This is an example of global state, right? This is a global state that's constant. Everyone needs to know.
00:07:27.034 - 00:08:30.526, Speaker A: You need to know the ratio of the pool in order to be able to make a trade. So if you want to make a private version of this, we can make pool A and pool B private, but we can't make the ratio between pool A and pool B private because we need to be able to prove that ratio is correct when we're withdrawing the amount of money that we want. So if you made it private, you can say that, okay, but yeah, we can make it private, though. No, you can't really do that. So you can say that, yeah, you can make it private, but then as soon as someone makes an update to the makes a single trade on Uniswap, no one else will be able to because they won't know the new state. You need to know the state in order to be able to make a like. So at the start of the call, anna was kind of alluded to this a little bit, and this is kind of something that we maybe have a bit of a disagreement about that Anna said that, oh, yeah.
00:08:30.526 - 00:09:21.760, Speaker A: So there's starting to be AMMS automatic marker makers, which is basically what Uniswap is, that are private. But the way that those have been built is using multiparty computation. And multiparty computation has a trust model that's a lot different than the trust model that we're used to. So, for example, zero knowledge proofs. In order to maintain privacy, you need to trust only yourself. You are the only person you need to trust yourself or one of everyone else, because there's an attack where imagine you're in a private system and everybody else decides to reveal hey, this wasn't me. Or everyone else decides to reveal their private information, then you by fact of by just being there as well, being the only person who didn't do that, anyone can look and say, oh, this must have been this person because it couldn't have been anyone else.
00:09:21.760 - 00:10:29.926, Speaker A: So for zero knowledge proofs, you need to trust you, yourself and the general rest of the group, they can give up their privacy in order to kind of take your privacy away with multiparty computation, it's much different with multiparty computation, you need to trust M of N trusted parties in this model. So basically a multiparty computation is where you take a secret and you split it up into N pieces. Yeah, you trust N people to hold a piece of this secret. And every time an execution happens, m of these people needs to come together to perform the computation. So, for example, in the multiparty computation uniswap, m of the parties would come together to perform every trade. So there's just a difficult trade off here where we have M parties and we want M to be really big, right? Because we want the number of people who need to come forward to break privacy to be a lot. But at the same time, if M people aren't available at one time, then we're not able to make a trade, right.
00:10:29.926 - 00:11:10.802, Speaker A: The liveness disappears. So we have this difficult trade off where we're choosing between liveness and privacy. So that's why I'm a little bit worried about multiparty computation. For this use case, I will talk a little bit more about how we use multiparty computation for other things. But that is in a one of N trust models where just you need to have a single honest party in order to keep your privacy. Yeah, so that's the second method that's kind of used that we're not really talking about here. Mostly what I'm talking about here is zero launch groups, actually a little bit of NPC later and then there's a trusted hardware model which is basically, I don't know, it's something I'm very skeptical about.
00:11:10.802 - 00:12:02.994, Speaker A: It's basically saying that, oh, listen, let's just trust intel to do this. Intel produced this special chip that they say you're not able to inspect exactly what the CPU is doing, so you're not able to tell what's going on inside it. So you can make some code, you can load it into the chip, and then you're able to execute that code, but you're not able to find out the new state. But I am just very skeptical about this because it just involves trusting some hardware manufacturer and that's just very difficult to validate that that is done correctly. Actually, it's probably impossible. I mean, how can you check a piece of hardware has been built according to specifications. You would need to analyze it on like a nanometer level.
00:12:02.994 - 00:12:39.482, Speaker A: I'm not even sure we're able to resolve that layer, that level of detail. But anyway, that's my kind of side round about trusted hardware. So let's continue. So that's kind of the end of part one. I've kind of talked about the different trust models that we have, and I also talked about the different techniques that we have to do things. And I also talked about this kind of global state, private state paradigm where you can't have both. And if you have both, you start to lose some of your you just basically lose privacy.
00:12:39.482 - 00:13:21.178, Speaker A: And for this reason we can't there was talk before that, okay, let's make everything in ethereum private. Let's just spend all of our time to make everything in cryptocurrency private. Private transfers, private smart contracts. And it's just not possible to do that right, because if you make things private, you lose this very important feature, which is private global state. No, you lose this feature of global state. You can still have private global state, but you can still have private global state, but you lose no, you can still have private global state, but that's not really global, though. If something is private, it needs more people to kind of you can have global state, but you can't have privacy and global state.
00:13:21.178 - 00:14:08.650, Speaker A: Those two things just don't really go together. And this is something that Zach is going to talk about later because I think that Zach from Aztec, I think that his talk is going to go into more detail about the type of things that he does or that they do to try and get around this limitation. And I'm going to talk about that a little bit too. Let's go. So the first thing I want to talk about is uni rep. So this is like a reputation system that uses smirks in order to have this ability to both risk and win and lose reputation. So what we wanted to do is, okay, what we're doing is we're building a reddit style social network where you're able to upvote people and you're able to downvote people.
00:14:08.650 - 00:14:45.990, Speaker A: And we have this concept of Carmel. And the way that it works is that every week you make a post and you have a certain address. And during this week, people are able to kind of send you attestations they're able to send you kind of upfolds and they're able to send you down folds. And when I make a post, I attach my epoch address and at the end of every epoch, I make a zero knowledge proof that gathers together all of these attestations all of my upvotes and down votes. I add them together and I add them to my profile. But this is a private profile. It's not public.
00:14:45.990 - 00:15:30.600, Speaker A: Every time I make a post, I need to so at the end of every week, we have an epoch transition where we move from the old state to the new state. Everyone applies their kind of upvotes and downvotes and we start again with a new week. And basically what happens is that you have to have a certain number, a certain amount of karma or upvotes in order to be able to make posts. So this is a kind of a private reputation system that's kind of justing to people's upvotes and downvotes. We're able to have this kind of reputation system. So this is a project I'm pretty excited about and we're working on it now and there is a lot of room here to do further work. There's more things that we can build with this.
00:15:30.600 - 00:16:27.720, Speaker A: It's a private reputation system so there's a lot of possible applications. For example, we could make like a private COVID tracker. That was one project we were thinking about doing where every time you go out you would give your epoch address to the restaurant you were going to, for example. And if they had some COVID case, they'll get airdrops, they will send you some negative reputation to your profile and then you won't be able to go out for a certain amount of time until you've done a quarantine. We're using this in this example to kind of quarantine people privately because the way that it works right now is if you go to a restaurant or something, you give them your phone number and they'll phone you if there is some problem. It's a little bit less private. But anyway, I feel like I shouldn't have used that example.
00:16:27.720 - 00:16:45.340, Speaker A: But anyway, that's uni rep. So there's a whole bunch of other things we could use unirap for. This is just the kind of beginning, the first step. It's an experiment. I'm excited to see how it progresses. Yeah. So I'm going to talk about the NPC stuff now, basically.
00:16:45.340 - 00:17:33.258, Speaker A: So there's two kinds of of there's and it's defined by the trust model. There's an M of N trust model where you have to trust M of the parties in the multiparty computation and there's an M minus one multiparty computation where you have to just trust one party. And what we're doing here is we have like a simple NPC protocol where you say where we make a check that A equals B. And in this example we can say that A and B are exchanges that are trades that we want to make. So basically what we'll do is we'll go to some smart contracts. We'll advertise that, hey, I want to make a trade on token pair X. Yeah, I want to trade fees for dai or something.
00:17:33.258 - 00:18:17.034, Speaker A: And you make a post there and you put your IP address and then what happens is people will contact you and say, hey, I'm also interested in making a trade on that pair. Would you like to perform this multiparty computation to see if our orders are compatible? So basically you agree to that and then you both do this NPC where you do some crypto stuff and you send some information back and forth. And then at the end of it, you see you get two numbers and you say, does number one equal number two? And if number one equals number two, that means your orders are the same. If number one doesn't equal number two, that means your orders are different. So if your orders are the same, you can see like, okay, yeah, it's time to trade. We have a trade, a match on our trade. It's time to execute this.
00:18:17.034 - 00:19:01.686, Speaker A: So this is a nice project that's kind of coming along. We've been sort of waiting for a way to privately settle the orders, but now we're at the point where we hope that soon we'll have some kind of ZK private way to do atomic swaps. Once we have that, then we will be able to implement. Yeah, so that's fun. It's a nice kind of private way to do order matching. But some of the limitations here are that you have to do this with a lot of people, right? Let's say you want to make a trade on some token pair and you're basically going out and just doing this thing with everyone to try and find someone who happens to match with you. And there's some attacks that people can do.
00:19:01.686 - 00:19:50.620, Speaker A: Like, someone can make like thousands and thousands and thousands of orders that are fake and they can use that to kind of grind to try and find the order that you want that you have. So they can just set up like a million orders from zero to a million and they can just repeatedly do NPC with you until they find the price that you want to sell at. So that's one problem. Another problem is that someone can do the NPC with you. It can turn out that, yeah, the orders match and then it's not possible to actually execute the order. That's another problem that they're able to kind of back out of this. But, yeah, I feel like starting where we are now, it's a good first step and we can sort of try and tackle these other problems later.
00:19:50.620 - 00:20:58.574, Speaker A: Another example of some so this is a fun one where, okay, so let's say that we want to build a reputation system that's basically like a friend of a friend thing, right? That if someone's a friend of a friend, you can trust them a little bit because you know that friend and you trust that friend. So you can kind of transfer some of your trust in that friend to this other friend. So it's a reputation system that people kind of use in their daily life, but it's also hard to do it in a private way. So basically what we have is that we have a network of users that have connections to different people. And this is kind of our global state, but we want to keep it private for the users, right? We want everyone to just know who their friends are and not know who their friends or friends are. So imagine that someone is like, okay, I want to find this friend X. So what they do is they reach out to all of their friends and say, hey, I'm looking for a friend, but I don't want to tell you who I'm looking for.
00:20:58.574 - 00:21:40.410, Speaker A: Can you perform this NPC with me to see if they're one of your friends? And the friend says okay of yeah. So let's say we're looking for Bob and I ask Alice, alice, I'm looking for a friend, but I don't want to tell you who I'm looking for. Can you help me? And Alice says, sure, sure. So Alice takes a list of all of her friends and I take the friend I'm looking for Bob, and we together perform this NPC together whereby we'll get a single boolean results. We'll either get this Alice is friends with this person or not based upon just checking each of her friends. And if one of them works out, that means we found a connection. So then we can use DKPs on top of this to kind of find the connect, to kind of make proofs of these connections.
00:21:40.410 - 00:22:29.580, Speaker A: Yeah, so you can make a DKP and prove that this connection exists. But this is just really complicated because you have to ask everyone, I have to go to Alice and I have to ask her to check every one of her friends against this person I'm searching for, which takes a long time. It doesn't take a long time, but it's annoying. And then if you don't find a connection, you have a choice between going one layer deeper in the tree and you can say to Alex, hey Alex, will you connect me with each of your friends so I can ask them if they're friends with this friend that I'm searching? Like once you start doing that, it just blows up because you can start searching many times for the same person. So it can be really difficult to track. Yeah. So that's my talk.
00:22:29.580 - 00:23:26.480, Speaker A: Yeah, I have a little bit of time for questions now, but let me just wrap things up. So like at the start we talked about how some of the private stuff that we've been doing, we then explored why global state is really important to smart contracts and why privacy and global state don't really go together. We talked about some of the other methods that we can use to overcome this multiparty computation and trusted hardware and I kind of complained about both of them a little bit. And then we talked about, okay, what are some other ways that we can approach this problem? So we discussed that and here we are. We really jumped through a lot of hoops in order to do the kind of global search in the lab project Blindfind. But anyway, that was a talk and I'm happy to answer any questions.
00:23:28.210 - 00:23:56.738, Speaker B: Sounds good. Okay. You challenged something I said, and so I need to talk to you about that. That's the first question. You did publish a really kind of well known post about how you cannot make private AMMS. This is going back to the AMM question. Private AMMS using ZKPs, and I don't know if you're aware, but there are some projects that are exploring doing that, but there are trade offs.
00:23:56.738 - 00:24:15.280, Speaker B: So they may be able to use ZKPs to shield the identity, but not the amounts. I guess when I put it in the list of potential privacy use cases, it does reference what you talked about, but it may not be the complete privacy that one would hope.
00:24:15.650 - 00:24:43.590, Speaker A: Yeah, I understand. Yeah. So, okay, so there's kind of two directions here. There's one is the NPC, which we've seen some interesting stuff published from Andrew Miller, I think, recently. The other approach is, yeah, that's totally possible too. I guess that I would argue that it's not covering that. It's just hiding the it's not it's not hiding what you're yeah.
00:24:43.660 - 00:24:51.914, Speaker B: Is it a private AMM? That's maybe the question maybe the word private AMM doesn't exactly capture that in that case.
00:24:52.112 - 00:25:26.706, Speaker A: Yeah, possibly. I'd also like to refer those people to a paper by Mary Mallor a couple of years ago about how so this was a really fun paper. So what they did was they tried to find they did an analysis of the Zcash private pool. And you see, the way Zcash works is you can deposit, you can withdraw, and you can transfer. So what happened was a lot of people would deposit, transfer once and then withdraw. So it was easy to track because you could see the amount that got deposited and you see ten minutes later, it gets withdrawn. So they use this to kind of track a lot of what was going on.
00:25:26.706 - 00:25:38.306, Speaker A: So I would be concerned that would also be possible with this kind of private unit swap. But I think it's for sure a useful experiment. And I would support people doing that. And if I can help them in any way, I would be happy to help.
00:25:38.428 - 00:26:13.220, Speaker B: Yeah. I also am really curious to hear more about as Aztec and Zach does his talk because I know that there's some techniques that they're using to try to solve for these problems while still using zero knowledge proofs. It's almost like, I think, what you described, like these MPC type models, like, mixing it in a way, like having both of those things acting at the same time. Or I know that there's this idea of adding kind of pooling trades in order to sort of hide it through that. Like creating little mini, I guess, mixers as you do it.
00:26:14.310 - 00:26:14.770, Speaker A: Okay.
00:26:14.840 - 00:26:36.380, Speaker B: Anyway, I'm excited to find out more. I learned about this pretty recently. So I don't know, maybe is there anything? Like what's the future? I mean, you've described a few projects that you're working on right now, but are there any long shot projects that you're thinking about and maybe even you could give ideas to the people in the audience to start working on tinkering with?
00:26:37.070 - 00:27:09.798, Speaker A: I don't know. I normally try and be a little bit more conservative on long shot projects. I think that it's kind of cool to yeah, so okay, so one of the things that a big area to explore is to use the tooling that Azteca use to make their ZkZk roll up to make some other recursive proofs, some other ZK app that's based upon recursive proofs. And I think there's a lot of room there to build some pretty exciting stuff.
00:27:09.964 - 00:27:23.290, Speaker B: Nice. All right, well, I think that wraps up this block. We're going to be taking a short break, but thank you so much, Barry, for your chat.
00:27:23.710 - 00:27:27.580, Speaker A: No problem. Yeah, happy to. Thank you for your talk.
00:27:29.630 - 00:27:34.880, Speaker B: We had a chat. There was a talk. Sorry it's late here in.
00:27:37.570 - 00:27:39.280, Speaker A: Yeah. Thanks so much.
00:27:42.770 - 00:28:04.210, Speaker C: Thanks so much, Perry. And I think this is also where I get to thank Anna for being an amazing co host for today. And you did an amazing job highlighting how this ecosystem has evolved and kind of kick us off with the rest of the day. So thank you so much for giving us your time and can't wait to see you all in person for the next real ZK Summit. Totally.
