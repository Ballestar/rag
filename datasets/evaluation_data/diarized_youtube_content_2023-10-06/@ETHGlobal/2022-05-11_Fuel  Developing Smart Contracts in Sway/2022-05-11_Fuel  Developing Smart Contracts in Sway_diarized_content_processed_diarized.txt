00:00:10.430 - 00:00:26.420, Speaker A: Great. Welcome, everyone. We will be starting now. Emily will be giving a talk on developing smart contracts in Sway. If you have comments, please leave them in the chat and then we'll get to them at the end. Without further ado, you can go ahead.
00:00:28.390 - 00:00:32.100, Speaker B: Thanks for the intro. Let me share my screen.
00:00:37.600 - 00:00:38.350, Speaker C: Okay.
00:00:38.880 - 00:00:49.008, Speaker B: Hi, everybody. My name is Emily Herbert. I'm a contributor at Fuel Labs and today I'll be introducing you to Fuel and introducing you to how Fuel is.
00:00:49.014 - 00:00:51.040, Speaker C: The fastest modular execution layer.
00:00:52.340 - 00:01:02.428, Speaker B: What is a modular execution layer? Well, currently in the space we're seeing that traditional blockchain infrastructures are limited by.
00:01:02.614 - 00:01:05.460, Speaker C: The amount that they can scale throughput.
00:01:05.800 - 00:01:42.720, Speaker B: In particular, we're seeing that l Two s, while they do offer a margin of cost reduction for access to the Ethereum ecosystem we're seeing that the throughput increase that they provide is modest at best. And then what this manifests as is that when there's high traffic to the Ethereum ecosystem l Two struggle to keep costs low and a cost for a single transaction may rise to several dollars. And I think ultimately what we can say is that if we want to spread the global access to blockchain we need to solve the scalability problem at its core.
00:01:44.580 - 00:01:46.544, Speaker C: At Fuel, we believe that the fix.
00:01:46.582 - 00:02:19.870, Speaker B: To the scalability problem lies within the modular blockchain. What is the modular blockchain? Well, in L One blockchain infrastructures there's an ongoing colossal shift from monolithic designs to modular designs. A monolithic design might see the different layers of the blockchain infrastructure being data availability, execution layer and others all being coupled together by the same technology. But a modular design would see each of those layers being handled by a different technology.
00:02:20.640 - 00:02:23.772, Speaker C: What this comes out to is that.
00:02:23.906 - 00:03:12.140, Speaker B: When you have a modular design and each of these layers is handled by its own technology each of these layers can be specialized to increase throughput and to achieve better performance with a modular infrastructure. To make this more concrete, here's just a little example of what this might look like. So here on the left we have four layers that would be present. In a blockchain infrastructure, we have data availability, consensus, settlement and execution. And then here on the right we have an example of a monolithic and a modular blockchain infrastructure. In the monolithic blockchain infrastructure we see that each of these layers is handled by the same technology which in this example is the gear emoji. But you can think of this like Ethereum.
00:03:12.140 - 00:03:44.836, Speaker B: Ethereum would handle the data availability all the way down to the execution. But in a modular blockchain infrastructure these different layers are handled by different technologies allowing each layer to be specialized. So in this example, the data availability is handled by the rocket emoji. But you can think of this being a technology like Celestia. The consensus and settlement layers are again handled by the gear emoji in this example. So this would be ethereum. And then in this modular blockchain stack, the execution layer is handled by Fuel.
00:03:44.836 - 00:04:23.872, Speaker B: We can see here that Fuel at a high level is an execution layer for the modular blockchain. But at the beginning I claimed that it was the fastest. So what makes it the fastest? Well, this is derived from the three core Fuel pillars. These would be number one, parallel transaction execution. Number two, the Fuel virtual machine and number three, a superior developer experience. And I'll talk about what each of these means. Pillar number one is that at its core, fuel uses the UTXO based parallel transaction execution scheme under the hood.
00:04:23.872 - 00:04:43.908, Speaker B: What this means is that Fuel can take advantage of parallelizing over CPUs and threads, cores and threads on your CPU and is no longer limited by single threaded predecessors that we've seen in the past. And ultimately, this design decision allows Fuel.
00:04:43.924 - 00:04:46.140, Speaker C: To be the fastest module execution layer.
00:04:47.600 - 00:05:41.790, Speaker B: Pillar number two is the Fuel virtual machine, otherwise known as the Fuel VM. The Fuel VM is the executing component that interacts with Fuel. The Fuel VM is designed to learn from its predecessors and learn from the mistakes of the past and learn from modern blockchain paradigms that you and I know today. And ultimately, the design of the Fuel VM allows it to strip away needless computation and wasted resources and offer a very specific blockchain optimized virtual machine. Pillar number three is the superior developer experience that Fuel provides with Sway and with Fork. Sway is the smart contract language that runs inside of the Fuel VM. And Fork is the tooling around Sway that offers the elevated developer experience.
00:05:41.790 - 00:06:23.800, Speaker B: Both Sway and Fork are in active development right now. So now I'm going to talk more about Sway and Fork. And then at the end I'm going to show an example of how you can get started using Sway and using Fork as your entry point to the Fuel ecosystem. The best way to introduce Sway is to talk about the existing technologies that we've seen in the past. So currently, if you want to write a smart contract, one of the more prominent languages is Solidity. Solidity was written for the early Ethereum virtual machine.
00:06:24.380 - 00:06:27.148, Speaker C: It feels kind of like JavaScript and.
00:06:27.234 - 00:07:13.850, Speaker B: It has a lot of domain specific elements that allow you to do blockchain specific development. So this would be allowing you to write first class contracts, allowing you to use contract storage as a language construct, and more. But Solidity has some issues. So for one, the Solidity docs don't necessarily tell you how to do a contract end to end. There's a fragmented ecosystem and tooling around Solidity. And Solidity lacks many critical safety guarantees. For example, if you write a smart contract in Solidity, that could be subject to reintrancy bugs and you can also get a stack too, deep error and more.
00:07:13.850 - 00:07:59.288, Speaker B: So I think that ultimately, at a high level, what we can say about Solidity is that it works, but because it was developed for the early EVM, it wasn't developed with the knowledge of the blockchain paradigms that you and I know today. Fortunately, this type of problem is not unprecedented. And what we've seen in the past is the transition from C Plus Plus to Rest. So C Plus Plus is a systems language that provides the user with a lot of power in manipulating memory itself. But in doing this, it opens up the domain of bugs to include memory management bugs. In response to this, a language was developed called Rust.
00:07:59.464 - 00:08:04.270, Speaker C: Rust offers much of the same.
00:08:07.840 - 00:08:11.100, Speaker B: Systems level contributions that C offers.
00:08:11.180 - 00:08:13.504, Speaker C: But one of the features is that.
00:08:13.542 - 00:09:10.150, Speaker B: At a language level it manipulates the system memory itself to prevent a lot of the domain specific systems bugs that were present in C Plus Plus. So this includes use after free indexing, outside of an array bounds, et cetera. And what we're finding is that people really like this about Rust, but there's lots of other things that people like about Rust. This includes the superior developer experience, the unified tooling, the team organization and much more. So that brings us to Sway. At a high level, Sway learns from both Solidity and from Rust and combines both of these languages in its own approach to develop or to provide a superior development experience. In particular, Sway takes from Solidity several different things.
00:09:10.150 - 00:09:13.540, Speaker B: So sway is domain specific.
00:09:13.690 - 00:09:17.156, Speaker C: This means that Sway allows you as.
00:09:17.178 - 00:10:03.706, Speaker B: A user to write first class smart contracts, it has first class blockchain support, it has contract storage as a language construct and it has shareable contract interfaces. Sway learns from rust. In that sway feels like rust. It has static types with trait based inheritance, it has a verbose and friendly compiler, it has unified tooling and developer experience and team organization. Sway is also written in Rust under the hood, meaning that it's fast and efficient and easily audible. So what do I mean by sway? Feels like rust. Well, inside of Sway you can do a lot of Rust like things.
00:10:03.706 - 00:10:33.330, Speaker B: So what we're looking at here is all Sway code and we're going to go through some examples. In Sway, you can create variables with the Let keyword, you can create mutable variables with the mute keyword and you can add type descriptions with this type description syntax. In Sway, you can also have functions. So here we have our function equals. That takes two arguments a and B. It compares A and B and returns a boolean if A and B are equal. In sway you can have if expressions.
00:10:33.330 - 00:10:47.720, Speaker B: And by expressions we really do mean expressions. And what this means is that if expressions can be both in a statement location syntactically as well as an expression location syntactically. So here on the left.
00:10:49.450 - 00:10:49.926, Speaker C: We have.
00:10:49.948 - 00:11:29.858, Speaker B: An if expression that returns a different number depending on the value of foo. But then on the right we have an if expression that does a variable, a conditional variable assignment depending on the value of food. Sway has match expressions and match expressions are similar to if expressions in that they can be in multiple places. Syntactically, you can think of match expressions like a switch statement or if you were in solidity this would be a chained if else statement. But in Sway we actually have match expressions. So here on the left we have.
00:11:30.024 - 00:11:32.374, Speaker C: A match expression that returns a different.
00:11:32.412 - 00:11:52.134, Speaker B: Number depending on the value of foo. And then on the right we have a conditional variable assignment where depending on the value of foo, bar is either zero or one. Sway has structs with accompanying methods. So here we have our struct foo that has two elements bar and Baz.
00:11:52.262 - 00:11:54.906, Speaker C: And then inside of the input block.
00:11:54.938 - 00:12:44.778, Speaker B: On the lower part of the example we have an accompanying method is badge True that just returns if the bass element from foo is true. Sway has enums which are actually proper sum types. So here we have our enum sale which has two variants product of the product type and service of the service type. The product type has two elements SKU and price and the service type has two elements name and hourly rate. We can see that the enum sale is the sum type of both the product type and the service type. Soy has generic types and type imprints. So here is another struct like we saw in the struct slide but this struct is different in that it has two generic elements.
00:12:44.778 - 00:13:53.410, Speaker B: So X and Y can contain any type that they want to, and this is manifested by them syntactically showing that they're containing the type T. So we have our struct point that has a generic type T where X and Y are both of that generic type T. So you can think of this like, oh, if I want my point struct to contain U 64s or I want my point struct to contain U 32 or really anything because it's a generic type, you can also have associated methods with those generic types. So here we have an associated method, new that takes two elements A and B and returns a point with x as A and Y as B. Sway has elevated error handling. So we can see here in this example that we have this enum result. The result enum is a type in Sway that's used to represent either a.
00:13:53.480 - 00:13:55.310, Speaker C: Success or an error.
00:13:55.470 - 00:15:23.002, Speaker B: So the result enum has two variants okay and error. The okay would be used in a success case and the error would be used in an error case. Then in this function Withdrawal, we see that the control flow either returns this success case which is okay, or returns the error case depending on what the control flow what happens with control flow. So we can see in this example that we're trying to withdraw an amount from our account and if we have that amount in our account or in our balance, we're going to be okay and the transaction will succeed and we'll return an okay, but if we don't, then the transaction will fail and we'll return an error. What this ends up manifesting as is when you, as the developer, are using errors inside of Sway, the compiler, the Sway compiler will force you to handle the errors appropriately and successfully before you can deploy your contract. This eliminates any of the issues that you might encounter with unhidled control flow and allows you to be confident that your code handles all error cases appropriately and all success cases appropriately. What do I mean by Sway is domain specific? Well, in Sway there are specific primitive types that allow you to do blockchain specific applications.
00:15:23.002 - 00:16:15.950, Speaker B: So this includes unsigned integers, booleans, static length arrays, 32 byte values, single byte values, and the unit type suite also has tuple types for you to assemble. These primitive types and user defined structs and enums that we saw previously, as well as generic types across structs, enums and functions. Sway has first class contracts and when you write a contract in Sway, it'll look like this. So there's two main components here, and the first is this Abi definition. So to create a contract, you'll define an Abi. Here we have Abi Simple Auction, which has one function bid. Then in the second half of the example, we're implementing this Abi for a contract in Sway.
00:16:15.950 - 00:16:26.834, Speaker B: And then when we do that, we're going to implement the function bid. So when you're defining a contract in Sway, it's these two components. It's the Abi definition, then implementing the.
00:16:26.872 - 00:16:30.374, Speaker C: Contract with that Abi definition where you.
00:16:30.412 - 00:16:33.830, Speaker B: Actually implement the functions that are present in the Abi.
00:16:35.850 - 00:16:38.802, Speaker C: In Sway, you can call contracts.
00:16:38.866 - 00:17:21.826, Speaker B: So if you remember on the previous slide, we have our Abi definition which has the function bid. And then in this lower example, we're going to be calling this function bid using the Abi. So here we have our contract address that we're defining to be a B 256 value. And then we're using the Abi keyword to say, I have an Abi called Simple Auction at this contract address, I'm going to create an instance of this in Sway and then I can actually call those associated functions inside of Sway from that contract address. What this means for you as the developers is that because these Abi definitions.
00:17:21.858 - 00:17:25.058, Speaker C: Are defined separately, they can be exported.
00:17:25.074 - 00:17:51.200, Speaker B: And imported like libraries and they're shareable. So you can share these Abis across different contract implementations like libraries. Soy has contract storage and it looks like this. So to use contract storage, you will use the storage keyword. So here we have the storage keyword where we're defining that the contract has.
00:17:51.730 - 00:17:56.560, Speaker C: One data element called data in its storage, which is 64.
00:17:57.090 - 00:18:23.562, Speaker B: Then in this function is where we're actually going to be accessing the storage. So in the simple storage function. We're taking an amount, we're setting storage data to that amount and then we're returning storage data. We can see here that simple storage is decorated with this annotation. Storage read, write and in Sway. These annotations let the Sway compiler know.
00:18:23.616 - 00:18:26.998, Speaker C: That you'll be accessing storage by reading.
00:18:27.014 - 00:18:45.230, Speaker B: To it and by writing to it. So you can use these annotations to let the compiler know that storage will be accessed. And this means that the compiler can offer you specific guarantees about how storage will be handled and can perform underlying optimizations on your behalf.
00:18:47.910 - 00:18:49.806, Speaker C: There's a lot more features with Sway.
00:18:49.918 - 00:18:53.842, Speaker B: But I don't have time to discuss them all. So if you're interested in learning more.
00:18:53.896 - 00:18:57.826, Speaker C: About the language definition, you can go.
00:18:57.848 - 00:19:19.034, Speaker B: To our website, Field networks, and then navigate to the Sway book. But at this point I will be going through a quick example of what it's like to write your first smart contract with Sway. And what we're going to be doing is we're going to be writing a smart contract that counts the number of apples that we have and allows us.
00:19:19.072 - 00:19:22.026, Speaker C: To increase that number of apples and.
00:19:22.048 - 00:19:36.434, Speaker B: Then retrieve that number of apples. To get started, we're going to install everything. So we're going to install with Cargo, install Fork, fuel core. This is going to install two different.
00:19:36.472 - 00:19:38.770, Speaker C: Things, the first of which is Fork.
00:19:39.190 - 00:20:22.350, Speaker B: Fork I mentioned at the beginning of the presentation is the tooling system that allows you to gain an entry point into Sway and to the Fuel ecosystem. So Fork will do your project. Independent management for Sway will allow you to build, debug and deploy your Sway code to the Fuel ecosystem and more. You can think of Fork as the Fuel orchestrator. And if you're familiar with Cargo, fork is very similar to Cargo, and in fact Fork uses Cargo under the hood. The second thing that this command will install is Fuel Core. And Fuel Core is an additional entry point into the Fuel ecosystem.
00:20:22.350 - 00:21:03.110, Speaker B: To create our project, we're going to use Fork. We're going to call for knit with the name of our project which is Counterexample. Then inside of the Counterexample, this will create a directory called Counterexample with our templated suite project. And then inside of that directory there will be several files that are pre populated for us for a successful Sway project. These are four files. There's the Cargo TOML file. If you remember, Fork uses Cargo under the hood, so this allows Fork to operate successfully.
00:21:03.110 - 00:21:42.906, Speaker B: Then there's the Fork TOML file, which you'll use to define high level information about the project. Then there's the main Sway file which will contain the code for the smart contract. And then there's the test harness file, which we'll use to test the contract before we deploy. And I'm going to go through what some of these look like in the code. Our Fork TOML file is going to contain the information for our sway project that will allow fork to build it successfully with the information that we've given it. So this includes the author's list, the license that we want to use and.
00:21:42.928 - 00:21:47.434, Speaker C: The name of the project inside of.
00:21:47.472 - 00:22:22.280, Speaker B: Our main sway file. This is where we're going to be defining the contract that we want to test and deploy. There's four different subcomponents to this contract. So I'll walk through what each of these means. At the top we have the contract keyword. This allows the sway compiler to this tells the sway compiler that this code contains a contract. Then we have our contract storage definition with the storage keyword and in this example, with the contract storage, we're going to be storing one value which is apples, which is e 64.
00:22:22.280 - 00:23:06.980, Speaker B: Next we're going to define our Abi. So we have our Abi counter contract which has three functions. Our initialized function which is going to initialize the number of apples. Our increment function which is going to increment the number of apples, and our Get function which is going to return the number of apples currently that we have to us. Lastly, we're going to actually implement these functions and implement the Abi. So we have our implementing Abi for contracts and we're going to implement each of these functions. So initialize will set the number of apples to zero, increment will increment the number of apples by N and Get will retrieve the number of apples and return that number to us.
00:23:06.980 - 00:24:02.870, Speaker B: Once we've written our contract, we're ready to test it. One of the developer experience components that Fuel provides is it provides extensive rust and TypeScript SDKs. These SDKs are modeled after Ether, Rs and Etherjs and allow you to interact with sway and fork from inside of rust and TypeScript. So they allow you to build, debug, test and deploy your contracts. They allow you to start fuel nodes, interact with the Fuel ecosystem and a lot more. So what we're looking at here is the test harness file that is actually rust code using the Rust SDK for Sway. There's a lot of code on screen, but I'll walk you through what it means.
00:24:02.870 - 00:24:30.314, Speaker B: So at the top we have our SDK imports. Then below that we are loading the Abi from JSON. So under the hood, what's going to be happening is the rust SDK that we're using in this slide will be compiling the contract that we wrote on the previous slide and exporting that shareable API to JSON so that we can do the sharing. And then it will import that JSON.
00:24:30.362 - 00:24:32.990, Speaker C: To this file using the Rest SDK.
00:24:33.330 - 00:25:40.834, Speaker B: So we're importing that JSON using the Abigen keyword and then the name of our shareable Abi which is countercontract. And then we're going to run the test inside of the test, we're going to build the contract. Then we're going to launch a local fuel node and deploy that contract. Then we're going to retrieve the contract instance. And then after that we're going to call the functions that we defined in the Abi and retrieve the number of apples and check to see that number of apples is what we expect it to be. Looking at the lower half of this, we can see that in this particular test case we are initializing the number of apples so setting it to zero incrementing by 99, incrementing it by one and then retrieving the number of apples which we should expect to be 100. When we're ready to run the test, we can use fork test, this will compile the contract and then we'll run the test that we defined and we can see here that our test succeeds and we're done.
00:25:40.834 - 00:26:39.414, Speaker B: We have just written our first project with Sway that interacts with the Fuel VM and the Fuel ecosystem. Well, what if we make a mistake? What if we have a bug or we have a typo? What if something goes wrong? Well, the Sway compiler learns from Rust in that the Sway compiler is both friendly and verbose. What this means is that the Sway compiler can detect many programming errors as well as blockchain specific errors and will automatically analyze those for you before you deploy your contract during compilation. For instance, the Sway compiler can detect if you have a match expression that's not exhaustive. So if you are using a match expression and you're matching on a tuple, for instance, if you don't consider all.
00:26:39.452 - 00:26:42.266, Speaker C: The cases for that tuple and you.
00:26:42.288 - 00:26:50.634, Speaker B: Haven'T considered all cases of control flow for that match expression, the Sway compiler will fail to compile and will let you know which cases you need to.
00:26:50.672 - 00:26:54.670, Speaker C: Implement for blockchain specific errors.
00:26:55.250 - 00:27:10.646, Speaker B: One example is that right now in Sway we have the ability to, there's an experimental branch which allows you to analyze your code to see if your smart contract will be susceptible to reintroduce ebooks.
00:27:10.778 - 00:27:13.346, Speaker C: So the Sway compiler will do this.
00:27:13.368 - 00:27:31.782, Speaker B: For you and then if it's found that your smart contract is susceptible to reintrancy bugs, the Sway compiler will give you a warning that it feels that you've created a contract that might be susceptible to this. Wrapping it up at a high level.
00:27:31.836 - 00:27:34.230, Speaker C: Today we've talked about Sway and fork.
00:27:34.310 - 00:27:44.206, Speaker B: The Fuel VM and Fuel, but there's a lot of stuff that we didn't get to cover. So in addition to providing a superior developer experience with the elements that we.
00:27:44.228 - 00:27:48.286, Speaker C: Saw today, fuel also provides fork, which.
00:27:48.308 - 00:29:01.670, Speaker B: Is the Sway tool chain friendly compiler, built in testing infrastructure, those extensive SDKs that I mentioned an extensive? Standard library, a Vs code plugin with automatic save, automatic format, hover go to abilities, a language server that we've had since May of 2021, and a built in debugger gas profiling and code coverage, which are all a work in progress. So wrapping it up, I want to let everybody know that we're very excited to introduce the Fuel online hackathon. So we would like to introduce the Beyond Monolithic Fuel online hackathon that's happening at the end of this month, May 27 through May 30, and you can win up to $100,000 in prizes during this hackathon. We encourage you and invite you to use Sway and Fork to build an exciting product where you can win money. I would like to thank all the Fuel contributors. Without all the Fuel contributors, we would not be here where we are today. I think now, at this point, we have upwards of 40 Fuel contributors, which is very exciting.
00:29:01.670 - 00:29:13.720, Speaker B: Thanks, everybody. If you are interested in learning more, you can go to our website, fuel Network. If you would like to connect with us on Twitter, you can connect with Fuel, with Sway or with Myself. So, thanks.
00:29:16.410 - 00:29:37.806, Speaker A: Great. Thank you. That was great. Thank you for joining as well. There are the social links right there, but you could also find Fuel on the ETHGlobal Discord channel. It's under the sponsor link Fuel. We do have two workshops going on today still with Wallet Connect Nave, but this will be available on YouTube, so if there's any questions, bring them over Discord, Twitter or anywhere else.
00:29:37.806 - 00:29:39.050, Speaker A: Thanks, everyone. Thank you, Emily.
