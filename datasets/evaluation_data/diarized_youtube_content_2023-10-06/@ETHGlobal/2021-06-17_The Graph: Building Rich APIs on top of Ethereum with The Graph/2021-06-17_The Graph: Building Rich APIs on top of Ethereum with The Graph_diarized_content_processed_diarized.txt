00:00:00.490 - 00:00:23.310, Speaker A: Before we kick off. All right, we have Natter from the Graph who's going to give a workshop titled building Rich APIs on Top of Ethereum with the Graph. If you have questions for Natter, let's hold those to the end. I know we've got a lot of stuff to cover, so without further ado, I will hand it over to you, Natter.
00:00:24.290 - 00:00:56.702, Speaker B: Thank you so much. Happy to be here. And we're going to be covering quite a bit today, so I guess we'll go ahead and get started. So to do that, I guess I will share my screen and it's going to be kind of broken up into two main parts today. First, I'm going to be presenting a presentation here. So I'm hoping everyone can kind of see this. And we're going to be doing a kind of overview of what the graph is.
00:00:56.702 - 00:01:45.758, Speaker B: And then we're going to go through actually building our own subgraph from scratch and looking at how to kind of query data from ethereum and indexing data from a smart contract. So, like mentioned, my name is Nader Dabbitt. I am a developer relations engineer, developer advocate working at Edge and Node. And one of the protocols that we work closely with is the Graph Protocol and the Graph Protocol. The founders of the Graph Protocol actually also founded Edge and Node and the Graph Protocol is now managed by the Graph Foundation. So what is the Graph protocol? It's an indexing protocol for querying networks like Ethereum and IPFS. So essentially it's kind of like you could think of it as any public data source in the future.
00:01:45.758 - 00:03:05.926, Speaker B: And for right now, we're kind of focused on blockchain data and different networks that are EVM compatible. For now, we're working on additional blockchains as well, and in the future want to basically be able to index pretty much any public data and have a completely open API layer for any public data. And developers can essentially kind of deploy their own APIs to this decentralized network using the subgraph that we're going to be looking at in just a moment. So with the graph, you can basically take a data set that in the past was really not easy to query from a front end or really any type of application and kind of make that data a lot more. Efficiently retrievable and a lot more performant in a front end application in a type of way that most users, I guess, are used to with modern apps. So with blockchain data, because the data is kind of aggregated over time in these different transactions that are written to the chain in these blocks, you can't actually hit a blockchain and kind of get a nice data set like you would from a traditional database in the Web two world. Now you can kind of make a single read, so you can say, okay, I want to get this individual piece of data.
00:03:05.926 - 00:04:08.202, Speaker B: But you can't go through and say, I want to query this data set. I want to pass in these arguments, and I want to kind of get this nice selection set that might be some type of aggregation of data across time or using some type of, I guess, computation logic that typically would be handled in a server. So in the past, a lot of developers got around this by building out their own indexing servers and deploying them to something like AWS or Google or maybe even dealing with that infrastructure themselves. But the big drawback here was if you did that, it was not only a heavy lift, because any type of data that you wanted to index, any type of application you wanted to build, you had to basically build a new indexing server every time. And this was resource intensive. But most importantly, it actually broke the idea behind decentralization in the first place. So if you have all of this data centralized in a single point of failure, then it's truly not a decentralized application and it's not Web Three.
00:04:08.202 - 00:04:55.942, Speaker B: So the Graph solves both of those problems. And the Graph provides a really easy way for developers to deploy open APIs on top of public data like blockchains. And it kind of sits in between the blockchain and the smart contracts and the user interface. And it allows you to basically define what data you want served, what data you want stored. And you can also create additional, I would say, kind of data access patterns on top of that data by defining that in the subgraph. So a lot of applications are already using the Graph. You might have used applications like the Foundation NFT app, maybe uniswap synthetics.
00:04:55.942 - 00:05:37.078, Speaker B: You can go and check out the Graph website to see a bunch of different apps that are already using it. And we have tens, I think, of thousands now of subgraphs that have been deployed. When I wrote this slide deck, originally, it was over 10,000 lifetime subgraphs, and I believe now we're over 20,000 developers. So quite a few developers are building on the Graph. And I think in the lifetime, we're at over 125,000,000,000 queries. And I believe last month we had over 25 billion queries alone. So, like I mentioned, a lot of different applications are using it, a lot of DFI apps are using it.
00:05:37.078 - 00:06:34.410, Speaker B: One of the ones that I mentioned is Uniswap, but I think this image here kind of gives you an idea around the interface that you get after you deploy an API. So once your API is deployed, how do you know what data is there and how to interact with it? Well, in the Graph Explorer and in the actual interface for the individual subgraph itself, you can actually go in and see an Explorer view that kind of shows you the current state of the Graph, as well as a way to query data from the Graph and understand what types of data are available for you. To use in your app. Now the graph is a decentralized network. Well actually it has two different ways to deploy today. Actually we have the decentralized network and we have the hosted network. The decentralized network is a fully decentralized protocol with different, I would say, participants that you can different ways in which you can participate.
00:06:34.410 - 00:07:07.954, Speaker B: I'm going to go over those in just a moment. And then we also have the hosted service which is kind of what we're going to be using today. Because with the hosted service we don't have to kind of stake any tokens and we don't have to do any of that stuff. And it's kind of a great way to kind of, I would say, just get started understanding how to build. But with the actual network itself, you can be a participant in a few different ways. So you can be an indexer running a node on the network. And if you're running an indexer node, then you can allow other developers to build subgraphs on your indexer.
00:07:07.954 - 00:07:58.760, Speaker B: And then you make query fees based on the usage of those subgraphs that you're indexing. You can also participate in the form of a curator. So if you are someone that sees an API that someone's created and you think that it's going to do well, you can basically stake GRT which are graph tokens to signal that this subgraph is a very good API or that you think it's high quality. And then you can share receive amount of the actual query fees that are gained from that subgraph. And if you're a subgraph developer, you can also signal on your own subgraph and earn a portion of those query fees as well. So you can earn money in a few different ways by participating in the network itself. And we have some really interesting stuff coming in the next few weeks, so keep an eye out there.
00:07:58.760 - 00:08:32.714, Speaker B: So how do you actually create one of these subgraphs? Well, this is what the workshop is all about. I'm going to actually have an entire end to end code base that I'm going to share with you along with steps that we're going to take. So this way if you want to follow along, you can or you can kind of follow along at another time maybe. So you can kind of watch me and then maybe do this yourself at a later time if you would like. So you initialize a subgraph, that's kind of the first step. And this is done from your local development environment using the Graph CLI. You can then decide which data sources that you want to index.
00:08:32.714 - 00:09:19.114, Speaker B: So like, which smart contracts are you wanting to save information from? Again, these could be DeFi smart contracts, these could be NFTs, these could be marketplaces, whatever. Once you've decided which data you want to store, you define your entities. And this is done in two different places. One, place it's in the GraphQL schema, which is kind of the definition of all of the different data that you might want to save. And then the other place it's done in the subgraph configuration file, which is the subgraph YAML. And then you define the actual, I would say business logic of kind of like how this information is going to be saved in something called assembly script mappings. And the assembly script mappings are really very similar to kind of writing JavaScript or TypeScript.
00:09:19.114 - 00:10:04.270, Speaker B: So have you written either one of those languages? That should be fairly easy. And we're going to see that we're going to be able to kind of like deploy this entire subgraph with something like around less than 100 lines of code, including all of these steps here. And then when you're done, you deploy from your CLI and from there you can go into the graph dashboard and check it out. So with that being said, let's go ahead and build something. So what I want to do is build a subgraph using an existing smart contract. And I think for tutorials and getting started and I would say workshops like what we're doing, a really good place to start is something that's visual. So what I'm going to be doing is indexing data from the Zora smart contract.
00:10:04.270 - 00:10:45.180, Speaker B: So Zora has deployed their smart contract and of course it's available on Etherscan. And if you go, they have some documentation that kind of shows you that. But I actually have all the steps for the workshop here on this GitHub repo. So it's GitHub.com Dabbit three buildingsubgraphworkshop and maybe I'll go ahead and share that in the comments and maybe we can kind of have that shared with everyone here. And here I kind of have a link to the NFT smart contract here. Actually, maybe it's oh no, that's not the link.
00:10:45.180 - 00:11:33.750, Speaker B: There is a link to it somewhere, but actually here it is. So that's the contract itself on Ether scan. So the way that this is going to work is essentially I kind of went through the steps, but the idea here is whenever a transaction is written to a smart contract, you typically have events that are emitted. And in these events you can basically look and see which data is being emitted. And that's where you can event source the data for your subgraph. There's a couple of ways to source data other than events, but the events is kind of, I would say, the easiest way to get started and that's what we're going to be looking at. You can also source data from just regular functions.
00:11:33.750 - 00:12:06.260, Speaker B: All right, so we're going to be building a subgraph on top of the Zora smart contract. So we basically want to kind of have an API that we can basically say, let's want to build like an interface like this. How could we do that and how can we get that data? That's what we're going to be building. So to get started, what we first want to do is go into the graph console and create a new subgraph. So to do that we can go to thegraph.com and I will go ahead and start here. So we're at the graph.com
00:12:06.260 - 00:12:54.770, Speaker B: and I'm going to go to sign in and sign up and if you have already done that, you should see kind of your profile here with the Dashboard. So we're going to click on Dashboard and then there's a big button right here where you can click to create a new subgraph. Add subgraph. So I'm going to give this a name like we could say David Three. Well, we already have Davit Three, so let's say Zora NFT or something like that. All right, so this doesn't matter a whole lot, but this will be discoverable if you would like it to be. So maybe it is important if you're kind of building out a production subgraph to kind of come up with a name that you want to stick anyway.
00:12:54.770 - 00:13:12.698, Speaker B: So we have the subgraph name. We can give like a subgraph title here. We'll just call this sort of subgraph and that's kind of it. We can add additional metadata if we want. We can make it visible or hidden, doesn't really matter. I'll make this visible. So if anyone wants to go here and check it out later, they can.
00:13:12.698 - 00:14:06.250, Speaker B: And we're going to click Create subgraph. So we've created our subgraph. I kind of walked through those steps here too, just to kind of make sure that you know that all this stuff is covered in this workshop materials. The next thing we want to do is install the graph CLI and I've already done that. But to do that, if you haven't already, you would run NPM, install G at Graph protocol CLI or you can do that using yarn and then from there you'll have the graph CLI binary and from there you can just use the graph to do whatever you want. So to initialize a new subgraph, you can just run graph init and you can either pass in arguments that will kind of define a few of the different things that we want to do, or you can just run graph init and it will walk you through all these steps. But for me, I want to go down here where we kind of have a few different arguments that we're going to be working with because we know the smart contract address.
00:14:06.250 - 00:15:05.486, Speaker B: We also know that we want to deploy this querying data from Ethereum Mainnet so we can define the network. And if this was a different blockchain, you could also define that here as well. We also want to give the name of the contract that we're going to be storing the data. I would say the entities as so in our case, we're going to say all these NFTs are we're going to call them Tokens? And then we also want to pass in this flag, which is kind of interesting, which says Index events, because this will go into the abis of the Smart Contract and it will go ahead and create some boilerplate code for us based on the events that are programmed into the Smart Contract. So all I need to do is go ahead and copy this and paste it here. And this will go ahead and get us started. So for the subgraph name, what we need to do here is set up the name that we gave in our Explorer here.
00:15:05.486 - 00:15:38.694, Speaker B: So for me, that was David three Zoraneftworkshop. So I can go ahead and use that and I can define the directory where I want this to go. I've already selected mainnet, so that's being chosen first. Also know the Smart Contract address because I passed it in here. So I can accept all these defaults, the contract name as well. So kind of we accepted all these defaults and this should go ahead and scaffold out our subgraph. And I can go ahead and change into our new directory here.
00:15:38.694 - 00:16:35.662, Speaker B: And I'm just going to actually run NPM install because I think because I have Yarn chosen as the default installer, there seems to be some issue with Yarn installing dependencies. All right, so we've done all that. Now let's take a look at some of the boilerplate code that was created for us by the CLI. So to do that, I'll go ahead and open up this subgraph in my text editor. And here we have our folder structure on the left where you can kind of see the different files that were created for us. So the three main things that you're going to need to work with are going to be the GraphQL schema at schema GraphQL. And here we're kind of given a few pieces of boilerplate, I would say, code that we could work with.
00:16:35.662 - 00:17:14.726, Speaker B: We also need to open the subgraph YAML. This YAML configuration defines the entire configuration for our subgraph. And then we also have our mappings which are in the source directory. So kind of putting these three things together, we're going to be able to create our subgraph. So what I want to do is we're going to go back to our workshop and what we want to first do is define our entities. So which data do we want to store from this smart contract, from these events, from this smart contract? Now, if we look at the actual UI of Zora, we might get a good idea of kind of what data we want. We might want to say, okay, this is a piece of data right here and this is one as well.
00:17:14.726 - 00:18:12.810, Speaker B: So each NFT is its own data, piece of data. We might want to kind of say, okay, for each item, we want to store the metadata, we might want to store the reserve price and so on and so forth. So kind of like thinking of that as a starting point, like where would we start with that? I think the most logical place would just be for the NFT itself and then we would also need to think past that maybe like for this entire marketplace because I'm assuming that there are multiple contracts put together for this. It's not just maybe an NFT, but it's also the marketplace allowing the buying and selling. So let's just talk about the NFT itself. So for that you can look into the contract itself and maybe look at one of the structs there. But in our case we know that we're going to be having a token and a few of the pieces of metadata that we want to store are going to be the token ID, the Content Uri, the metadata Uri, the creator and the owner.
00:18:12.810 - 00:19:16.698, Speaker B: So the token ID, the Content Uri and the metadata Uri are coming directly from the event. So we're able to source these events using the ERC 721 standard and maybe also going into their contract and kind of making sure that this all looks like it works. And then we also have these two entities which are interesting because these are relationships, right? Because we have a creator which is not a typical just type like of integer or string or whatever. This is an actual additional parent type. So we're kind of like saying creator is another type itself that we're referencing here. So we can do that and the graph node knows how to deal with those types of data and we know how to do and we're going to be dealing with those types of data in our mappings so we're able to kind of make this one to one relationship. And another interesting thing is that we're also able to make one to many relationships.
00:19:16.698 - 00:20:17.380, Speaker B: So for the user we can also say, okay, we want to index all the tokens but we also want to index users and the tokens that they've bought and that they've created. So doing that we can make that happen using a combination of some code that we're going to write in the mappings as well as this at Derived from Directive. And then the Derived from Directive lets us define a field where we're going to be deriving this data. So for the token array, we're deriving this data from the owner and for the created, we're deriving this field from the creator. And these are going to be smart contract addresses. I'm sorry, these are going to be Ethereum wallet essentially addresses and then using these addresses we can go and fetch that metadata itself or that data itself. So we have these two different types and I'm going to go ahead and copy those and we're going to go to Schema GraphQL and we're just going to save this.
00:20:17.380 - 00:21:29.990, Speaker B: So we have our token type, we have our user type and we're pretty much done there. I have a little bit more information on the Derived from directive here, but we have 9 minutes left and our ultimate goal is to kind of finish this in time. So let's keep going. Another interesting thing that the CLI offers is code generation because when we're working in our mappings we're going to need helpers that are going to interact with the different data sources that we're going to start having available as this contract is being deployed. I'm sorry, when this subgraph is being deployed because when we deploy this subgraph we're going to basically be taking these events that are being read off of the chain and we're going to be looking and seeing that okay, we're going to have the token address, the token metadata, Uri, so on and so forth. But let's say that we wanted to actually read data from the function itself back maybe into the node that data we've already stored or maybe we want to actually read back into that smart contract and make other calls as well. We can do that using the graph TypeScript library.
00:21:29.990 - 00:22:22.770, Speaker B: And in order to do that, we actually can get some helper functions and helper code that is kind of like created for us. And we can actually create that code. Or generate that code by running graph code gen. And this uses a combination of our GraphQL schema as well as our abis to generate the code that we're going to need. So if I run Graph code gen, this should check in our Abis as well as our GraphQL schema and generate the code that we need. So give that a second, let me try running it here. There we go.
00:22:22.770 - 00:23:05.728, Speaker B: So we ran Graph code gen and now we see we have this generated folder with some code. So we have our schema here and we should see that we have a token type and a user type actually. Yeah, token and user entity actually. We also have our Token folder here with additional metadata and code that we can work with. And then we also have our Abis and I haven't gone over these yet but the Abis were automatically extracted from the smart contract when we ran Graph in it. So this is pretty cool. We have the Abi of course you could go into Ether Scan and copy that yourself if you wanted to.
00:23:05.728 - 00:23:57.264, Speaker B: So keeping going. We now also want to go into our subgraph YAML, and we want to update our fields that we're going to be working with. So first of all we have our entities so the entities that we want to work with are only going to be user and token. So I can just copy these and we're going to paste those here and these entities map directly to the types that we created here. So we have type, token type, user subgraph YAML, we have entity token and Entity User. The next thing we might want to do is define our start block because if we deploy it as is, it will actually start from the very beginning of whatever network we're working on. So we'll kind of go to the genesis block but we kind of know we don't want to have to do that.
00:23:57.264 - 00:24:40.492, Speaker B: We can actually just start right here because this is where the contract was deployed. So you can just start there and of course, you could deploy from the very beginning. It just takes a long time. And then the last thing we want to do is we want to make sure we have our event handlers defined. And we've already actually had these event handlers generated for us because we use the index events flag and we know that the smart contract emits an approval event, an approved for all event, a token metadata Uri updated, a token Uri updated and a handle transfer sorry, transfer event. So all those have been generated for us. So all we can really need to do is just kind of delete whatever events we don't want to handle.
00:24:40.492 - 00:25:20.716, Speaker B: So the two events that we do want to handle are token Uri updated and transfer. And transfer is an event that's triggered when a token is minted or transferred and then a token Uri event is invoked when of course, someone changes the Uri of a token itself. So with these two handlers we can kind of create a pretty decent basic API with the data that we want. Of course, we wanted to kind of make this more robust in the future. We might handle additional events that do a lot more than this, but getting started, that's it. So we're good here. Our subgraph YAML configuration is good to go.
00:25:20.716 - 00:26:01.528, Speaker B: All we need to do now is define the functions here for handle token Uri updated and handle Transfer. So we are running pretty close on time. So I'm just going to kind of like copy this code and paste it because I'm hoping we can finish in time. So in source mappings, I'm going to go ahead and paste this code here. And here we're importing some of the code that was generated for us by the CLI. We have our generated token. These are classes, I guess you could say, that we're going to be dealing with.
00:26:01.528 - 00:26:47.716, Speaker B: And then we also have the token and the user class itself that was kind of created for us to be able to kind of load instances of these items as they're created. And let's go over just one of these functions real quick to kind of give you an idea what's going on. So for handle transfer, this will receive the event that's passed in here. So we have transfer. So in this event we're going to have these arguments. We're going to have an address, an address and an integer. So here we're kind of handling that in the event and we're going to first check to see if this token already exists because if it does exist, that means we're just transferring it to someone else.
00:26:47.716 - 00:27:16.604, Speaker B: If it doesn't exist. That means we're creating a new one. So we're going to say if there is no token, we're going to go ahead and take that token. And you could think of this almost as like an object or a map where we're kind of like having a token instance and we're adding different fields to it. So we're adding the creator field, the token ID field, the content Uri and the metadata Uri. Now all of these fields should map directly to what you've defined in your schema. So you can kind of see that these things are already kind of like mapping directly.
00:27:16.604 - 00:27:52.270, Speaker B: We then save the item and then we also do the same thing for user. So we're kind of like taking all these pieces of metadata, all these different fields and saving them. So that's it, we should be ready to deploy. So the first thing we might want to do after finishing writing our subgraph is run a build to make sure everything's working good. So we run Graph build and it looks like our build was completed successfully. So we should be able to deploy. So I can go ahead and run Yarn deploy and this is going to run a script that's already been defined by the CLI for us.
00:27:52.270 - 00:28:56.154, Speaker B: And this should take maybe 15 to 30 seconds maybe. So our subgraph is deployed, we see that we have like a deployment ID. We also see where we can find this subgraph. So I can copy this and go there, but I really don't have to do that because we're already there. If I just go back here and refresh, we should see that our new subgraph has been deployed and we see that's already been synced and we've already indexed 6000 entities. That means we've run over and gone through 6000 different actual transfers, I guess in our case. And we've indexed items from each of those and we can go ahead and hit this to go ahead and start querying some data and we see that we're now getting back data and we can even pass in different arguments here.
00:28:56.154 - 00:29:36.262, Speaker B: So I want to change the sort direction, so I might say order direction descending, and then I want to say order by token ID. And then we can get maybe some of the later tokens. And then if I want to actually see some content, I can copy this content Uri, go into our browser, check it out, and hopefully it's safe for work. There we go. So that's it. We've deployed our subgraph. Everything in this workshop that we went over is in that GitHub repo as well as the code itself.
00:29:36.262 - 00:29:55.674, Speaker B: So you should see that the code's there. So thanks for checking this out, I hope you learned a lot. If you want to join in the conversation with the Graph, check us out on Twitter at Graph Protocol, check out our discord, check out our docs, keep an eye out for what we're. Doing the next couple of weeks and I'm going to go ahead and stop sharing my screen.
00:29:55.792 - 00:29:58.300, Speaker A: Thank you so much, Natter. This is great.
00:30:00.310 - 00:30:02.740, Speaker B: I'm trying to turn that music off.
00:30:03.110 - 00:30:03.682, Speaker A: All good.
00:30:03.736 - 00:30:05.010, Speaker B: There we go. Cool.
00:30:05.160 - 00:30:13.330, Speaker A: Thanks again. And, yeah, if you have any questions for Natter, head to the channels he mentioned and we will see you all on Discord.
00:30:14.470 - 00:30:14.880, Speaker B: Thank you.
