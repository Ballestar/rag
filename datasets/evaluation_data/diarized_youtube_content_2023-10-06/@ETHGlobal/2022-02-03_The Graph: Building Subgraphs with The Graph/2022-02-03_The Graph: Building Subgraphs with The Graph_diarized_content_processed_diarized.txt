00:00:17.990 - 00:00:41.320, Speaker A: Hi everyone from Spain. Okay, stream is good. Great.
00:00:42.810 - 00:01:03.040, Speaker B: So welcome everybody, to our workshop. You're going to learn how to build a subgraph with the Graft. And here I have with me Vish, who will be leading the workshop. Feel free to pop your questions here, but they will be answered in the Graphs channel disc on the discord. And Vish, I'll let you take the lead.
00:01:05.010 - 00:01:32.460, Speaker A: Awesome. Thank you so much. Hey everyone, thank you so much for tuning in today. Today we are going to actually let me just minimize this so that I can get a good sense of what I'm sharing and what you folks can see right now. All right? Yeah. Hey everyone, thank you so much for tuning in. I am super excited to be here today.
00:01:32.460 - 00:02:33.840, Speaker A: We are going to be learning how to build subgraphs with the Graph, as you can see in the title. And just wanted to take a minute by giving a huge shout out to the organizers and for having me here. And without further ado, let me get started with giving a bit of brief about what we'll be building today. So I thought it would be a really cool use case to share with you folks. And so many of you will be new to subgraph development with the graph or just the graph in general. So wanted to showcase how we can use the Zora Smart contract to build an NFT API. And this we'll be able to do by building a subgraph on top of the Zora NFT Marketplace Smart contract using the yeah, let me tell you a bit about myself.
00:02:33.840 - 00:03:08.294, Speaker A: Hi. I'm vish. I'm a Developer Relations Engineer at the Graph and my passion is building deeply engaged developer communities and I invest a lot of my time to help developers become successful with the frameworks and tools that they're using. Some quick session notes before we dive right into today's workshop. Moving on with our session. It is assumed that you have node JS installed on your machine and you have a MetaMask wallet set up to get the most out of this. And also that you know the fundamentals of GraphQL.
00:03:08.294 - 00:03:41.794, Speaker A: But if you don't, then that's totally fine. Just ping me on discord on our discord channel. The Graph discord channel. And I'd love to share a few resources with you, specifically around GraphQL, if that is something that you're interested in. Since it was in the scope of this workshop, I've left them out for now. Also, this is a hands on workshop and so the pace and the content of this workshop is designed to be best suited for a full stack audience. But if you don't see yourself fit into any of these boxes, please don't worry.
00:03:41.794 - 00:04:13.214, Speaker A: I will try my best to give as much context as possible in each step. Now, let's talk about what the graph is and where we come from. The Graph is an indexing and querying layer for blockchain networks like Ethereum and IPFS. But that is in theory, let's talk about layman terms. Let me give you an analogy. As an analogy. The Graph does for an open data on the blockchain what Google does for the Web.
00:04:13.214 - 00:05:01.630, Speaker A: That's how we like to describe what the Graph does. Using the Graph, anyone can build and publish open APIs known as subgraphs, that make data on the blockchain accessible. Now, it has two primary products, one of which we will dive deep into. So the first one is Graph Explorer and the second one is Subgraph Studio. The Graph Explorer is the place where you can interact with the network and explore existing subgraphs. Whereas the Subgraph Studio is something that we'll be using today that developers like you and I can use to build and publish subgraphs. Now, I have used the word subgraphs a lot of the times in the last 5 minutes.
00:05:01.630 - 00:06:28.406, Speaker A: So let me explain what subgraphs are and let's talk about the what, why and how to's of subgraphs. So first of all, just to get started, subgraphs are open APIs built on top of blockchain data. Now, we get asked often, why do we need subgraphs the data? In this data driven world, all of our data is mostly stored across huge storage networks and blockchains. And when we talk about blockchains, the blockchain gets a large number of transactions per day. And when we say large, we're talking about dealing with hundreds and thousands and millions of transactions per day. When we're building applications for the future of the Web, these applications need index data for high performance and better UI and UX so that the users can interact with the applications efficiently. Now, the main trouble developers have with building these applications, especially if they're building decentralized applications, is that it's becoming increasingly difficult to index and query blockchain data because of the high amounts of data and also not a lot of solutions available out there for efficiently indexing this data as a solution.
00:06:28.406 - 00:07:22.730, Speaker A: A lot of the companies, a lot of protocols were developed, a lot of developers, even individual developers, started building solutions which were proprietary indexing servers. Now, the question still remains what is the problem with proprietary indexing servers? If we can still build out a solution? It's not a problem, right? Wrong. Proprietary indexing servers would mean that there will be a single point of failure. People were still building out solutions, or more specifically, to say, proprietary indexing servers and deploying these servers to AWS. And which meant that it would need more engineering and hardware resources. But in the end, it also disrupts the core idea of decentralization. Enter the graph.
00:07:22.730 - 00:08:29.490, Speaker A: Now, when we talk about the benefits of the Graph, it's the easiest way to index and query blockchain data efficiently. It's also a transparent and open network. The Graph launched the Decentralized network last year. And the Graph Foundation, which is my team, oversees the health and the healthy functioning of this network with various network participants. Apart from that, it's also decentralized and robust. So the Graph is aiming to make decentralized APIs and enabling developers to access data, especially open and public data, which is stored on decentralized networks. And since the Graph and its core technology is built on GraphQL, the benefits become multifold because GraphQL on its own comes with a lot of good developer experience and a lot of benefits over traditional Rest services and Rest APIs.
00:08:29.490 - 00:09:02.090, Speaker A: So that's mostly what I had to share about the Graph and what subgraphs are. So let's take a quick look at a quick demo of how to build a subgraph. I actually realized that I'm sharing just one screen, so I'm going to switch. If I stop sharing, does that affect us in any way, the live stream?
00:09:07.950 - 00:09:09.230, Speaker B: No, it shouldn't.
00:09:10.370 - 00:10:04.564, Speaker A: Awesome. Let me quickly share the right, actually share the entire desktop and we should be good to go. Awesome. So I'll also hide the video panel here. We're looking at the Subgraph studio on the Graph website. The first thing that you can do by going to the Subgraph studio is connect your wallet, which will be your Ethereum wallet, could be MetaMask. And this is how you authenticate on the Subgraph studio.
00:10:04.564 - 00:10:41.750, Speaker A: Authenticate yourself on the Subgraph studio. I have already done it. So that's another prerequisite that you can set up. Now, we can quickly start by going to create a subgraph and we will click on Ethereum Mainnet. Ethereum Mainnet. Basically what this means is that we will be deploying our subgraph to the decentralized network and we will give it a name. Let's just call it NFT Demo and click on continue.
00:10:41.750 - 00:11:41.000, Speaker A: So this will also take us to the NFT demo dashboard, which is my subgraph dashboard, and show us a few things like status, subgraph slug and deploy Key. I'll explain what deploy key is and why it is needed. But basically it is a key that will help us authenticate our subgraph after we've built it and before we deploy it. I like how we have a bunch of documentation here so it comes in handy when we're setting it up. But basically I will be referring to this blog post that I will also share on Discord. Yeah, first of all, the first thing that you should do is install the Graph CLI. It gives you a bunch of commands to scaffold your subgraph and define it, et cetera, et cetera.
00:11:41.000 - 00:12:26.820, Speaker A: So I have already done that and let me go ahead and start my Visual Studio code. I will initialize my subgraph first. Yeah. PD desktop. Awesome. So I will go ahead and copy this command right here. And while it executes, I will explain what it does.
00:12:26.820 - 00:13:38.220, Speaker A: So what the Graph CLI gives us in this command is a few flags like Contract, name index, Events, and From Contract. So basically what the From Contract flag lets us do is it lets us contact the smart contract address, which is the Zora smart contract address that we will be dealing with here is the Zora NFT marketplace. So we'll basically be able to use the Zora NFT smart contract as a building block to build a subgraph on top of it. And we already have the smart contract address so we are going to pass it using the from contract flag. There's another very important flag here which is the Index Events Studio flag, the index events flag. What this basically lets us do is any of the events that the smart contract is going to emit. This gives us some configuration and some boilerplate code that we can use to interact with these events in the files that you will see later on.
00:13:38.220 - 00:15:00.202, Speaker A: So I'll go ahead and add the slug and accept all defaults, accept main net again, accept defaults. And this is going to scaffold my subgraph. Yeah, so this as I said, is going to give us some boilerplate code that is basically our subgraph YAML file which describes the subgraph. There's also a GraphQL schema file where we use that file to define our data model, which is our GraphQL schema that I will show you in a second when this is all set up. Yeah, our NFT demo has been created and it is now adding all the boilerplate code to the directory. And the next step that we can do here is once that is set up. I'm going to skip over some of this since we are tight on time, but we will be making some changes to some of the files as I said, which is the schema GraphQL file, which is our data model and there is also a subgraph.
00:15:00.202 - 00:16:06.748, Speaker A: Yet we'll make some changes to. This is taking a bit of time, just give it a minute and we can start exploring our subgraph folder. Oh, and I am going to take this time to also mention that you can go ahead and use our Discord channel where some of my team is hanging out and if you have any questions we'd love to answer them on Discord. And if you want any additional resources, if you've joined the hackathon, if you're building something, we'd love to guide you through it. So now as you can see, our NFT demo subgraph folder has been created. So I'm going to go ahead and open it and we can start exploring the subgraph folder structure. So the first thing that you can see here is the subgraph YAML file.
00:16:06.748 - 00:17:08.292, Speaker A: Since we are a little bit tight on time, I'm going to go and talk about a few edits that they're going to make here. So in the subgraph YAML file, this is a basic description or definition of our subgraph. The schema GraphQL file, which is the other file that we will be mainly editing today, is the GraphQL schema that we have which basically defines what kind of entities or what kind of data are we going to make available or indexable using this subgraph API that we're building. And there's also going to be a mapping file in the source folder. And this mapping is something that uses assembly script, which is something that I will explain in just a second. So let's go ahead and get started by making some changes to the subgraph YAML file. As I said, in the entities, there are some entities that we can define here.
00:17:08.292 - 00:17:59.400, Speaker A: So I'm going to enter Token and User and these are going to be the entities that we define here in the Schema GraphQL file. What this basically means is that our subgraph will be able to query this data that we define in these two entities. For the sake of this workshop, I'm also going to go ahead and remove these events. But as you can see, there are some event handlers that have been made available to us by the Smart contract itself. As an example, I'm going to take just two of these, which is the transfer event and the Token Uri updated event. The Token Uri updated event basically is an event that is emitted by the Smart contract when you index it. When the Uri of the Token has been updated.
00:17:59.400 - 00:19:13.310, Speaker A: There are two scenarios here that can happen sorry, when the Token Uri has been updated and in the transfer event, there are two scenarios that can happen in this event. The first is if an NFT or a Token is being minted and the second one is if the ownership of the token is being transferred, which is why the transfer event is then emitted. So these are the changes that we've made. I'll also make one more simple change here which is adding a start block. And basically what this adding a start block does is that instead of starting to index the Smart contract right from the genesis, we are going to use a start block so that it starts indexing the Zora NFT smart contract from a particular desired start block. And yeah, looks like these are all the changes that we wanted to make in the subgraph YAML file. So I'm going to go ahead and hit save.
00:19:13.310 - 00:20:04.028, Speaker A: Next, let's take a look at the Schema GraphQL file. Now this is the file where we're going to define the types which are the entities. So any type that you want to define it is going to be annotated using a directive which is at entity directive. So here we are defining two types which is Token and User. So in our subgraph we want to be able to query two types of data. First one is all the tokens that a user holds and the second one is the user metadata itself. So which is why we are defining these two types.
00:20:04.028 - 00:21:17.316, Speaker A: Now as you can see, each type has some fields that are also going to be queryable when you query the GraphQL API. So the Smart contract gives a few of the metadata regarding the token and similarly some metadata regarding the user. But since we want to query both of these types, but also not just tokens or just users, but both of them combined. Sometimes in a case where we want to query all the tokens that are held by a particular user, in that case we are using the at derived from directive to create a one to many relationship, from tokens to users, from users to tokens so that a particular user can hold n number of tokens. And this is going to define that relationship. I'm going to go ahead and hit save. The next thing that we want to do after defining our schema GraphQL file is go ahead and use the command graph code gen.
00:21:17.316 - 00:22:39.440, Speaker A: Now, what this command is going to do is that it gives us some headers and some functions and some boilerplate code that is for example, TypeScript and assembly script functions that will let us map our local function to the event that is being emitted by the Smart Contract. Now since this has been done, let's take a look at what has been generated here. So as you can see in generated we have two files which is in the token folder we have token and then we also have schema. So using the graph CLI gives us a TypeScript library and that TypeScript library will give us some boilerplate code which is generated using the graph code gen command. And what this code lets us do is in token TS we have some functions that let us interact with the smart contract itself and by interaction I mean reading data from the smart contract because of course we can't write to it directly. And then using the schema TS functions that we get from the generated code we are able to interact with the graph node itself. And by interaction I mean reading data from and writing data to writing new data to the graph node.
00:22:39.440 - 00:23:49.764, Speaker A: So I'm going to go ahead and we are not going to touch the generated code. It's just something that we will be using in our mapping TS file. So I'm going to go ahead and remove this and for the sake of simplicity and to take care of the time, I'm going to use the functions that we have defined here. So I'm importing, as you can see, I'm importing token and schema from the token and schema files in the generated folder which has been generated by the graph code gen, the graph code gen command. Now I am also going to use this function which is the handle transfer function and I will explain it in just a SEC. And also the handle tokenuri function. Now what this does is as I mentioned earlier from the subgraph YAML file we have two events which is token uri updated and transfer.
00:23:49.764 - 00:25:05.600, Speaker A: So in our mappings TS file what we're basically going to do is write some assembly script code if you've used TypeScript before, assembly script is basically similar to it. So we're going to write some assembly script code which will let us map the events that you saw here in the subgraph YAML file to the local events, sorry, local functions that we are writing here. So you can see the mappings TS file as our business logic of the subgraph. Any logic that you define here as functions is going to be mapped to the smart contract events. So whenever a smart contract is being indexed and the event is emitted, that mapping is going to take care of the event by calling the function that we have defined and mapped to it and the logic that we've written in the function is going to be executed. So here we have some logic that that is used by the handle transfer function and the handle token Uri updated function. The Handle Token Uri updated function is pretty straightforward because this function will only be called when the event happens.
00:25:05.600 - 00:26:02.860, Speaker A: We know that the token Uri will be updated. So what we are basically doing is that we are getting the token information from the smart contract and we're also updating the content Uri and saving it to the graph node. So that's pretty straightforward of a function. Another function that we're using is the handle transfer function. Now what this function does is it handles the transfer event happening on the smart contract and it will check two things. The first thing is if there is an existing token it will execute the function and if the token does not exist it will create a new token as you can see here, and then save the owner of the token. It does the same for the user.
00:26:02.860 - 00:26:33.950, Speaker A: If the user exists, it's going to save the user, the new user if the ownership has been transferred. But if the user does not exist first it's going to create a user. So these are basically all the edits that we wanted to make. We are going to go ahead and we are going to build our subgraph. So graph build. Hopefully this builds in time. We're running out of time.
00:26:33.950 - 00:27:48.464, Speaker A: Yes. And the next step that you can see here once that is done is that we will be deploying and testing our subgraph. I'm going to close this off. So once our subgraph has been built we will be authenticating our subgraph and that is something where we will be using our deploy key. So I'm just going to go ahead and copy the deploy key and to deploy sorry, to authenticate, we're using the command graph auth studio graph using the studio flag because we're using the subgraph studio and it's going to ask for the key. Yes, going to enter the deploy key that is ready to go and we will also use this command which is the graph deploy studio command and then enter our subgraph name which is NFT demo and when you do that, your subgraph is going to be deployed. Awesome.
00:27:48.464 - 00:29:02.750, Speaker A: Let's go ahead and add a version label, which could be anything. I'm just going to write 0.1 and this is going to deploy our subgraph. As you can, if you can see here, currently the status says unepployed, but once it's deployed, it's going to turn to deployed and then in just a second, when the subgraph is deployed, we should be able to test it out using the GraphQL playground, which is the beauty of GraphQL, actually. Awesome. So our subgraph has been deployed and you can use this link to use this link to test out the subgraph. It should take a SEC, no more than a SEC.
00:29:02.750 - 00:29:57.452, Speaker A: And yeah, we can go to the playground and there's an example query here. And to test out the subgraph, if you hit play, it's going to give us the first five tokens and the users and their data. As you can see here, this is the data that we asked for. And here you can see the schema, token and user. All right, folks, so this is what the demo was all about and if you want to get involved, want to join the Web Three movement, here are a few resources and a few places where you can get involved. Sorry for rushing, everyone, but if you have any questions, I would love to support you along with my team and answer answer any or all the questions that you have. Awesome.
00:29:57.452 - 00:30:00.716, Speaker A: Thank you so much for being an amazing audience. Thank you.
00:30:00.898 - 00:30:04.280, Speaker B: Thanks, everyone. See you at the next one. Bye.
