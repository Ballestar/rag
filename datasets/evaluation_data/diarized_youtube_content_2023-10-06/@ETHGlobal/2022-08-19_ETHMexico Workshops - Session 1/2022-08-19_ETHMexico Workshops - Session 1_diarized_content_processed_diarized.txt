00:00:53.890 - 00:00:56.022, Speaker A: In the prayer beast right there, you.
00:00:56.076 - 00:00:56.680, Speaker B: Say.
00:01:01.450 - 00:01:07.600, Speaker A: In the prayer beast right there, you say canva when they find us.
00:05:28.230 - 00:05:40.210, Speaker C: Super excited to be kicking this off a little bit. About me. My name is Kevin Jones. You might see me running around here. I'm actually the photographer for the event as well. Do a lot of fun stuff. But I'm also a developer.
00:05:40.210 - 00:05:57.978, Speaker C: You can follow me pretty much with this QR code. It'll bring up my contact and all my socials. I full time job. I work for Web 2.0 company called NGINX. You guys may have heard of it before, but I'm also a developer advocate for Scaffold ETH. And that's what I'm here to talk to you guys about.
00:05:57.978 - 00:06:23.774, Speaker C: It's basically a toolkit for prototyping and building on Ethereum quickly. I started a nonprofit for blockchain education. I also teach kind of a solidity course through a company called Growic. And yeah, again, I'm a photographer and filmmaker. So if you want your picture taping, come find me later, pretty much. Scaffold ETH is an open source toolkit. It's available on GitHub.
00:06:23.774 - 00:07:29.618, Speaker C: If you do a search for Google for Scaffold ETH, first thing that's going to come up is the GitHub link. It's basically a collection of different tools that you're going to utilize to essentially get up and running with a development environment to build on Ethereum, right? Hard hat, react, some hooks, pretty much all the plumbing you need to be able to quickly deploy, quickly test your smart contracts, and quickly kind of build in prototype applications. So it's perfect for hackathons or basically trying to create prototypes really quickly. There's been tons of other projects that have actually utilized Scaffoldeth. Even the actual build guild, which is what I'm a member of, is using Scaffold ETH as well. There's also what's called Speedrun Ethereum, which is kind of like this way to do challenges and go through and learn about how to program and how to build smart contracts and how to build DApps. But there's been lots of other successful applications that are built on Scaffoldeth, so it's definitely worth checking out eventually.
00:07:29.618 - 00:08:12.066, Speaker C: Once you start messing around with Scaffold, you'll check it out, you build some DApps, you'll start messing around and toying around with things like solidity by example, right? So you might go to solidity by example and start kind of like pasting stuff from solidity by example into your smart contract. Deploy those changes. You can do things like define primitive data types, define variables, start to learn solidity, right? Like deep dive into Solidity and how it works. But eventually if you want to get deeper and you kind of want to test your skills, you'll go to Speedrun Ethereum. Speedrun Ethereum is this again, it's this kind of experience that you go through and you go through these challenges. So like, the first one is you actually build an NFT. It's a simple NFT example.
00:08:12.066 - 00:08:34.586, Speaker C: Then you build a Dex, a decentralized staking application. You build a token vendor, a dice game, and then eventually you actually become a part of the Build Guild. And the Build Guild is just basically, like I said, a collection of developers that want to build and build on Ethereum. So definitely check that out. That's my quick show about speedrun. Ethereum. Everything you need to know about Scaffold ETH is pretty much available here.
00:08:34.586 - 00:09:03.380, Speaker C: So if you guys scan this, it'll give you the link to the GitHub. It'll give you the link to Build Guild, the Speedrun Ethereum, the Twitter that you can follow. Pretty much everything is available here. And if you guys have any questions or anything like that, I'm just going to throw my info again. If anyone wants to connect with me, I'll be running around happy to help you guys. But anyone that's at home wants to connect on my socials, please do. So what does the architecture look like? So this is kind of like a real rough look at how it's set up.
00:09:03.380 - 00:09:50.162, Speaker C: Scaffold ETH uses Yarn, so the only dependencies really on your machine is going to have git to be able to check out the repository, yarn to orchestrate and run some commands to get up and running, and to kind of do things like deploy. If you're not familiar with Yarn, it's basically like a package manager, but it also has this cool scripting functionality where you can write special Yarn commands to execute commands from other different applications. So it's really great for Toolkits because you can just make all these Yarn commands to do everything you need. And the developer like yourself don't really need to understand what's going on in the background. You just need to know like, okay, Yarn Start is going to spin up my React app. Yarn Chain is going to spin up my hard Hat node. Yarn Deploy is going to deploy my changes.
00:09:50.162 - 00:10:18.014, Speaker C: So to get up and running, it's super easy. Go to the GitHub, check out the repository, right? Do a yarn install. The Yarn install is kind of like going to install the dependencies, right? Everything you need to get up and running. After that's done, then you're going to do Yarn Chain to spin up your hard Hat node. Then you're going to do a Yarn Start to spin up React because we use React. And then do a Yarn Deploy to deploy your smart contract. So what does that look like? Let's just go right into demo mode here.
00:10:18.014 - 00:10:42.062, Speaker C: So I've basically gone ahead and I've already kind of checked out the repository. So hopefully you guys can see this out there. I've gone ahead, checked it out, and I've already also done the Yarn install. But in case you need to install any dependencies, you'll need to make sure that you do that. Make sure you're using the newest version of Yarn Package Manager. There's like an old version of Yarn. Make sure you're using the newest version of Yarn Package manager.
00:10:42.062 - 00:11:08.702, Speaker C: Make sure that you have Node JS installed on your machine. I think it's 16 or above. Do the yarn install, you're good to go. All you got to do next is just do a yarn chain. So Yarn Chain is going to essentially spin up a copy of Hard Hat running on localhost available and that's it, you're ready to go. You have a blockchain set up, right? So everything you do in Scaffold basically revolves around like kind of a couple of windows open. You keep the Hard Hat chain open and that just is always running.
00:11:08.702 - 00:11:40.754, Speaker C: That's kind of doing your EVM kind of simulation, right? And then you open up a new window, go to the same directory and do a yarn start that's going to spin up, react, react. Takes a little while to first get up and running. So that's going to take about a minute. So we'll come back to that. And then what you're going to do is just open a third window and the third one is really the one you're mainly going to be utilizing to do your deploys. So all you got to do is do a yarn deploy. So what that's going to do is there's an existing smart contract.
00:11:40.754 - 00:12:18.178, Speaker C: It's kind of like a hell to world smart contract that has everything you need to kind of just understand how basics of a smart contract works. So we can see that it deployed successfully after I did the deploy. And we can also see that where it was deployed to. We can see how much gas was used, which is useful if you're trying to optimize for gas during your deployment. And then you can also see that it published a subgraph. So if you're into the graph or you're familiar with GraphQL APIs, subgraph is basically a GraphQL API for all of your events, so you can actually use that. And that also comes with Scaffold ETH as well.
00:12:18.178 - 00:12:40.970, Speaker C: You have to do some docker stuff but it's available for you there. So during the deploy, that's taken care of. So now we have Scaffold ETH up and running. We've done the deploy, we've got our UI here. So real basic kind of run through real quickly. You'll see there's some tabs basically in the UI. The first tab is where you're going to build out your app, like your app.
00:12:40.970 - 00:13:24.790, Speaker C: So imagine it's like an app within Scaffold ETH, which is an app, right? So you're going to start building. There's a special directory structure. I'll show you where you go there and edit that home JSX file and that's where you can start building your app. But all the other stuff for connecting your wallet and getting up and running with Scaffold ETH as far as developing and testing is already set up so you don't have to worry about like it uses Ethers JS so that's already piped up. It's got this burner wallet in the top right corner you'll notice. So you could connect to like MetaMask, but if you don't want to mess with MetaMask, you can just use the burner wallets that come with scaffoldeth and it's just basically an in browser wallet. So what happens is you get this kind of random generated mnemonic inside the browser and then you're able to start transacting right away.
00:13:24.790 - 00:14:00.754, Speaker C: So I can just come over here to debug Contracts and I can see the functions of my smart contract. So before we get into that, let's open up text editor with the directory structure so I can just give you guys a real kind of overlook on what it looks like. So this might be hard to see for you guys and I'm not sure if I can zoom it in, but I can just walk you guys through it. So there's a packages folder. Inside the Packages folder there's really two places you'll be working, mostly Hard Hat folder and in the React app folder. Okay, react app, obviously is everything with the front end. Hard Hat is everything with the back end.
00:14:00.792 - 00:14:01.042, Speaker A: Right.
00:14:01.096 - 00:14:37.610, Speaker C: So inside this Contracts folder, inside Hard Hat is that hello world smart contract. It's just a real basic smart contract. What it does is sets the version of Solidity we're going to use with the Pragma. We import what's called Hard Hat console, which is so we can print out logs to the Hard Hat console if we need to see what's going on during the deploy or during a transaction. And then the smart contract is called your contract. And we can see that there's a set purpose event and we can see that there's a string defined like a variable named purpose. And we can also see that the constructor is empty so we're not doing anything fancy during the deploy.
00:14:37.610 - 00:15:37.602, Speaker C: And then we just have this basic function and the function just is allowing us to change that variable that we've set there so we can test it just we've already deployed our changes so we can actually test that and see what that looks like. So you'll notice if I try to come over here and I say like ETH Mexico, like that, try to hit send, it's going to tell me, I don't have any money, I don't have any funds, my account's at zero. So all I got to do is click this little thing, grab funds from the faucet, and then instantly it's going to take money, basically Ether from the Hard Hat instance, put it into my browser wallet so now I can operate, now I can send a transaction and we can see that I updated the purpose. So what's cool about Scaffold ETH is it's giving you your contract in this UI so you can start testing kind of your assumptions and your ability to transact in the application. So we can see the contract's there. We can see that it doesn't have any value. We can see its address, we can see that purpose but now we can kind of start toying around and changing some things.
00:15:37.602 - 00:16:26.978, Speaker C: So first let me minimize this and let me go back over here and actually let's change some things. First of all, let's just do something silly like set an owner variable so we could say like address public owner equals. And then we can grab our address from the browser, which is this one, right? And then we can set that in there, save that and then we could come over here and just do a redeploy. Now, if you've made a change to your smart contract, you can just do deploy. If you didn't make a change to your smart contract and you want to force a new contract to be deployed, you can do a yarn deploy, s reset and it will just give you a brand new version of the contract. So you can keep doing that over and over and over again. But we just made that simple change.
00:16:26.978 - 00:17:14.338, Speaker C: And we can see now we have a new variable. We have an owner variable called address, right? So what could we do with that? Well, we could do something like a require statement, right? We could say like require that the message, sorry, message sender, which is the global variable, is equal to owner, otherwise you are not the owner. Like this. Boom, right? And that and let's do another deploy. So what we can do now is we can open up a new incognito window, right? We can go to our app again, which is on localhost port 3000. And we can see now that we have a copy of the app on both ones and we have two different accounts. We got the account that is the owner, which is right here.
00:17:14.338 - 00:17:41.770, Speaker C: And then we got this kind of like purple blocky dude right here. So they've got to grab some funds to this kind of like another account. And then I can come over here and say, all right, well, let's make a change like this is so cool and hit send. And it's going to tell me I'm not the owner. Even though I had some money, I want to interact with that contract. I've done some kind of level of access control using that require statement and defining the variable. That's not the proper way to do access control.
00:17:41.770 - 00:18:02.462, Speaker C: So let's change that. Let's actually do it like this. Let's say let's get rid of this variable and let's do what's called inheritance instead. So you can kind of see what I'm doing. I'm toying, I'm messing around, setting some variables, testing to make sure that my functions are working. Now I'm going to do what's called inheritance. I'm going to inherit open Zeppelin's copy of what's called Ownable.
00:18:02.462 - 00:18:28.614, Speaker C: Ownable is kind of like a set way to do access control. It's a smart contract that was designed or created, I should say, by OpenZeppelin. It's kind of like the standard de facto way that you do access control. So I'm importing that. Then I can do your contract is ownable like this, inherit from that other smart contract. And then what I can do is I can require instead something like this only owner. So that's a function, that's a modifier.
00:18:28.614 - 00:19:08.546, Speaker C: It's called a modifier. I'm grabbing the modifier from the ownable smart contract and I'm inheriting the smart contract. So that way I don't have to set that hard coded, right? But if we do that, let's go ahead and try to do that deploy, do another deploy. So what's different here? Well, if you look closely, the owner does not match my burner wallet. The reason why is because Scaffold ETH utilizes hard hat. Hard hat, by default, uses the very first account of Toy Ether that it has for it to deploy. It's called the deployer.
00:19:08.546 - 00:19:56.306, Speaker C: So it's the first account. So right now we have a smart contract that we have no control over. So the next part that you get into as you start building around Scaffold ETH is you'll find this deploy folder and inside that deploy folder, what's really important in here is you get an instance of the contract, right? And you do the deploy here. So you can do things like pass arguments, like, let's say you wanted to pass like a supply or a variable or something like that. You could do that and pass those across in the constructor. But most importantly, we can do what's called like a transfer. So it's already here, we can just paste it in and what we can do is grab the address again and then we can paste it in, which I think this time you have to actually put it in quotes.
00:19:56.306 - 00:20:27.614, Speaker C: Let's see if that works. So one additional function that you get when you inherit ownable is called the transfer ownership function. So all we're doing is getting a copy of the smart contract as we're deploying it. And then when we do that, the copy of the contract is your contract. Then we're calling that transfer ownership function and transferring it to this address so we can say save that and then redeploy again. And let's see if that worked. The deploy worked.
00:20:27.614 - 00:20:56.074, Speaker C: It transferred it, hopefully, and it did. So you can see now that we deployed the smart contract with hard hat, but then we took control of it with our because we have this kind of like, identity right in our browser. If you were deploying to like a testnet or a main net, you wouldn't probably use the burner wallet. You'd use like MetaMask or some other kind of wallet to kind of take ownership. But you get the idea. So we're kind of going through and we're doing these tests. Let's do some more stuff.
00:20:56.074 - 00:21:20.334, Speaker C: Let's have some fun here. So we've already transferred the ownership. We can do the access control, but it's not a very interesting this isn't a very interesting smart contract. Like just for one person to change a purpose. It's kind of centralized, right? So let's remove that and let's just let anyone call that function. But what we can do instead is we can do a require statement. So Solidity has these global variables.
00:21:20.334 - 00:21:38.038, Speaker C: One of them is message sender, which is the person that's calling the transaction. But you also have message value, right? So we could say that the message value needs to equal some new variable that we're going to create called price and say not enough money. Otherwise if they don't send the value, then we'll say not enough value.
00:21:38.124 - 00:21:38.470, Speaker A: Okay?
00:21:38.540 - 00:22:20.280, Speaker C: So then we could come up here, create a new variable, we could do UN public price equal and then we'll do zero one Ether like that. So if you start deploying and building smart contracts, you'll learn that everything you do is in Ether or it's in way. And most of the time, everything that you do in your application, you have to kind of like calculate how much way is how much ether. But you can hard code the Ether here or you could hard code it as just way. We're just going to make it easy on us and we're just going to say ether. So zero, zero, one ether. So we'll save that and let's deploy it and let's see if it works.
00:22:20.280 - 00:22:53.518, Speaker C: So we also have to make this payable as well, I believe. See if that works. There we go. So I always do that. I always forget to make the function payable. So we've made this function now able to accept value, right? We've required that someone that wants to interact with this particular function, they can come in here and they can change it if they want, but they'll have to pay a price. So this is the way that I told you about.
00:22:53.518 - 00:23:33.738, Speaker C: So zero, zero one Ether is equal to this much way, right? So if I want to come down here and I want to change it to ETH Mexico again, you'll see that the front end is automatically adapted and now it knows that, hey, we got to send the value with the actual purpose so we can say like ETH Mexico. Now there's this cool thing. I could just copy paste the thing because I know what it is here like this. Or you could type it in zero zero one Ether with this little green button. It's kind of a cool tool and it will just do it for you. So if you're just kind of thinking about Ether, you can just boom. Obviously in your UI, you wouldn't want the user to have to type in 10 zero, right? But let's do it.
00:23:33.824 - 00:23:34.442, Speaker D: Did it work?
00:23:34.496 - 00:24:05.894, Speaker C: It did. If we wanted to change it again and we didn't put enough, let's say, just say we, let's say we sent nine nine nine and test send not enough value, right? So now we've created this kind of like cool functionality. And what's happened? Well, our smart contract has some value right now, we're able to actually use the smart contract as a bank. We haven't created any way to withdraw the money. So it's a little bit of a black hole right now because there's no withdraw function. But you guys get the idea. But we could do something else cool.
00:24:05.894 - 00:24:53.702, Speaker C: We could say, well, let's require the value, but then let's change the value after someone submits it. So we could do something like price just with one change price equal price times 101 divided by 100. See if that works. I think that should work. So basically we're going to increment it by 1% every time someone goes through and calls the function successfully. So now if I come in here and say, well, let's change it to Scaffold E, whatever, Scaffold ETH, and let's call the right amount that we need, paste it in there, send boom. So what's happened? Well, we've got a new price.
00:24:53.702 - 00:26:16.314, Speaker C: We can see that it's incremented. So with just one little small change, we're able to completely change the behavior of the Smart contract. But you can see what we're doing here is we're going through and we're doing things and testing out. So if you're getting started with Scaffold ETH, well, first of all, it's going to be easy to just get all your teammates set up because you can just be like, go check out this version, check out this branch and you're going to be up and running, right? Then it's really easy to kind of start testing and maybe one person's in charge of certain functions and then you guys could just share your code and distribute and drop it into the branch as you need it. So if you want to learn more, I would suggest going through solidity by example coming through here and kind of learn how the variables work, right? Learn what the different kind of variables are local versus state versus global, and actually come over here and put them in here and copy paste them into your smart contract and test from there. Another cool thing is, well, first of all, the base version of Scaffold ETH is just the start. Actually, after you kind of get up and running with the basic version and you want to kind of venture out into doing more advanced things like you've started building and learn how solidity works, you might want to do something like an NFT, right? You might want to build an NFT.
00:26:16.314 - 00:26:53.260, Speaker C: So if you go to the base version of Scaffold ETH, I should say the base path for the GitHub, you'll notice there's this challenges directory. I talked about it earlier. It's the speedrun ethereum challenges. All of the challenges have their own repository that you can basically build off of. And a good example is the very first one, which is the simple NFT example. It's basically just an ERC 721 Smart contract and it already has a lot of functionality to create NFTs. So let's spin that up real quick and show how easy it is.
00:26:53.260 - 00:27:23.462, Speaker C: So I shut down my other instance and I've already gone ahead and checked out this version for you guys. So you guys don't have to wait for the yarn install because it takes a while, especially if you're on bad Internet connection. But let's just make sure, boom, everything's good. So we can also do Git branch just to make sure that we're in the right branch. So I'm in the challenge zero simple NFT branch. Same thing goes for just real quick. Let me show you real quick.
00:27:23.462 - 00:27:59.794, Speaker C: If you're in the basic scaffold eat directory and you go here, you can do a search for all the different branches here, right? So like if you say NFT, there's a simple NFT with next JS, there's a ticket NFT there's also like if we just do ERC 720, 1155, there's an 1155 there. So my point is, if you're going to get started on a project that's going to use a certain starting point, just build off of that branch and you don't have to waste all your time like importing whatever version of Open Zeppelin and testing, it's going to be ready to go and you can build from there. That's why Scaffold ETH is here for you.
00:27:59.832 - 00:28:00.418, Speaker A: Right?
00:28:00.584 - 00:28:32.806, Speaker C: So I've already done the checkout. We did the yarn install, let's do the yarn chain and we'll do the yarn start and we'll do yarn deploy. And we're going to have to give it a second, but that's okay, let it deploy. So it's going to let us deploy even though react is not up. And then now let's open up this version of the code. And then I do want to show a couple of other things. So first of all, let's look at the contract.
00:28:32.806 - 00:28:55.570, Speaker C: The contract is sorry, let me close all these other ones. I was obviously in there earlier. So the contract is a lot different. It's not just the hello world purpose. It's an ERC 721, pretty much Turing complete, ready to go to build your smart contract off. It has all the functionality to mint an item. It has the functionality for the Uri.
00:28:55.570 - 00:29:34.480, Speaker C: It also has some cool stuff where it just automatically allow you to upload metadata to in the UI. I'll show you in a second. But the whole point is it's ready to go. So if you're building an NFT project, you would start here. And then I want to show real quickly before the app comes up is the react app. So inside the source directory, there's the appgsx folder, which is like that main application. It's called the scaffold app, right? But inside of views is where you'll edit others things like the well, actually, you won't go into the example UI, you'll go into index JS, I believe.
00:29:34.480 - 00:30:01.718, Speaker C: Well, this version doesn't have like a home directory, but on the other version there will be a home directory for you. I can just show it real quick. Yeah, here. So if we go to react source views home. So this is where you'll kind of build out your app, right? And these are all those examples that we saw in the UI. So anyways, React is whole nother beast, but we're not going to go too much into that. But let's see if the UI showed up and it did.
00:30:01.718 - 00:30:35.202, Speaker C: Let's close this. We can keep that open, actually. So now we'll notice that we have this year collectibles tab, right? So I got three minutes. So what's cool is we can just grab some funds, mint an NFT, and just like that, we got an NFT, and it's this cool little buffalo that Austin Griffith colored at home. So, yeah, basically, then I can come over here, grab this address, transfer it. Transfer, come over here, refresh. And now I got the buffalo on the other account.
00:30:35.202 - 00:30:55.734, Speaker C: So you can see you automatically have this ability to create NFTs, mint them around, move them around. The metadata for all of this is editable. So you can change the image, you can change the Uri, doesn't have to be a bison. There's a bunch of different ones. We can actually mint some more, see what else is cool. It's going to see what other cool NFTs I'm going to create. Oh, zebra.
00:30:55.734 - 00:31:19.458, Speaker C: Cool. What's next? So, yeah, you get the idea. This is all coming from like, I think a JSON file that's kind of in there. So you can edit that and build as many kind of layers to that NFT as you want to. But yeah, start with this branch and then you'll be good to go. So that's pretty much my demo pretty much here. Does anyone have any questions? I got enough time for like two minutes for a question.
00:31:19.458 - 00:31:48.276, Speaker C: That'd be cool. If you have questions, someone know which one Rinkabee? Oh, yeah. So everything we're doing here is localhost. That's a good question. So you could totally ship this to a testnet. It's just a matter of changing a few variables inside of the source files. So one is inside of the App JSX file.
00:31:48.276 - 00:32:16.736, Speaker C: You just have to change the network to whatever network you want. So it'll be like network localhost. We can actually look at it real quick. So if we go to Views, let me grab the other one because this one's so we can go to Home and then we can go to App JSX and we can see here that we have the network localhost. So we could just change that to Rinkabee if we want. Right? And then that app is pointing at Rinkabee. Same thing goes for the deployment.
00:32:16.736 - 00:32:52.906, Speaker C: You can change it in the deploy as well. So, like, if you come up here and we say in the deployment, I'm trying to remember where it is, but it's inside the hard hat config. So you can do it either by specifying. A network flag when you deploy. Or you can just come in here and change this to Rinkabee like that, and then that'll deploy to browse not speedrun, ethereum, but the burner wallet. So the question was, we didn't have to use MetaMask.
00:32:52.938 - 00:32:53.502, Speaker D: Why is that?
00:32:53.556 - 00:33:20.200, Speaker C: That's because Scaffold ETH uses a burner wallet functionality that's also available as a separate source code inside of those repositories folder. And it's just a burner wallet. Trying to think where it is. That's the punk wallet. I know it's in here somewhere. But, yeah, it's basically a burner wallet functionality that comes with Scaffold. So that way you don't have to use, like, worry about nonces or anything like that or transaction problems.
00:33:20.200 - 00:33:45.910, Speaker C: Yeah, all the dependencies are going to automatically be deployed, but they're available in the package JSON. You can see what needs to be installed, but it'll do it for you. But you just need to have GitHub react sorry. Node, JS git and yarn. And then you'll be good. Thank you, guys. Good luck hacking.
00:34:01.980 - 00:34:03.720, Speaker D: No need for sock.
00:35:07.360 - 00:35:08.110, Speaker C: Sorry.
00:35:08.560 - 00:35:16.460, Speaker D: Yeah, but it's good. I think we can just go this side.
00:35:17.950 - 00:35:19.260, Speaker C: Yeah, here we go.
00:35:19.710 - 00:35:20.700, Speaker D: And then.
00:35:35.050 - 00:35:37.802, Speaker A: Okay. At the end, when people are asking.
00:35:37.856 - 00:35:40.298, Speaker C: Questions, can you ask me can you repeat the question?
00:35:40.384 - 00:35:40.874, Speaker D: Oh, of course.
00:35:40.912 - 00:35:41.500, Speaker C: Yeah.
00:35:42.110 - 00:35:44.540, Speaker D: No, yeah, that's good.
00:35:45.230 - 00:35:45.706, Speaker A: All right.
00:35:45.728 - 00:35:47.274, Speaker C: Do I start? Cool.
00:35:47.392 - 00:36:18.470, Speaker D: All right. Hi, everybody. I'm Jack, and I work at O of One Labs. We're the company that incubated the Mina Protocol. And in this presentation, we'll kind of talk a little bit about what Mina is, what makes it special, and how you can get started building ZK apps using Snarky JS. So our agenda for today is first we'll be looking at Mina, then we'll take a look at ZK apps and run through some simple example code in Snarky JS. And then finally we can kind of talk about where you can learn more and go and open up questions and answers.
00:36:18.470 - 00:36:26.586, Speaker D: So, amino works quite a bit differently than other layer one blockchains you're probably familiar with. Let me see if I can make.
00:36:26.608 - 00:36:27.642, Speaker E: This a little bit bigger, actually.
00:36:27.696 - 00:37:23.330, Speaker D: Sorry, this is not might just all right, I'm just going to read off the screen. So, probably the kind of easiest thing to grasp about Mina straight away is just that the actually, I'm sorry, I'm going to switch this really quick. I'm just going to have it mirror my screen. Okay, sorry. Here we go. So Mina stays 22 KB. Whereas other blockchains increase in size, the current finalized state of Mina and all of the information required in order to validate that stays a fixed 22 KB.
00:37:23.330 - 00:38:04.718, Speaker D: This is possible because we use these things called recursive zero knowledge snarks, which are it's a type of zero knowledge proof where we can actually take the last state of the blockchain, which is itself a zero knowledge proof. And we can take transactions which are also zero knowledge proofs. And we can prove all of these zero knowledge proofs inside of another zero knowledge proof that's the same size as each of the constituent proofs. So, yeah, this is made possible by our proof system called Kimchi, which is really just an implementation detail from the perspective of developers. But it's something we spent a lot of time making really, really good and well suited to this use case. And it has some properties that are just really cool. So it's succinct.
00:38:04.718 - 00:38:29.030, Speaker D: That means that the proofs stay the same size. It's recursive. That means that we can verify proofs inside of other proofs. It's efficient and extensible. So it can do the kind of math that you probably need to do in order to build applications. Things like hash functions work efficiently, or I guess one hash function works particularly efficiently. Yeah, so the Mina blockchain stays 22 KB.
00:38:29.030 - 00:39:10.514, Speaker D: But applications also work quite differently. On, on a blockchain like Ethereum, you are sending some sort of request basically to the Ethereum nodes which store and run your code. And then they all have to do this at once in order to be able to kind of ensure that we're doing it correctly. And if you want to verify that the current state is true, you take all of these signed transactions and sum up the effects of them. With Mina, the smart contracts actually run off chain. They live in the user's browser and they're written in TypeScript. And you can kind of think of it as the user just runs the smart contract or just runs the TypeScript code and proves that they've done it correctly.
00:39:10.514 - 00:39:49.486, Speaker D: And they actually send this proof to Mina. This is useful for a couple of different reasons. The most interesting, I think, is that you have privacy by default. So anything that you do, you're doing on your local machine. It doesn't leave your local machine unless you deliberately send it away. And so this opens the door to a whole bunch of different kinds of applications that I don't think people have been able to think seriously about building on blockchains like Ethereum. Yet it also opens the door to decentralization, because the blockchain can stay 22 KB, as we've said, or the current finalized state can stay 22 KB.
00:39:49.486 - 00:40:40.146, Speaker D: So you can have wallets that verify the chain state themselves, not in the way that light clients work, but in a way that's as small as light clients and actually even smaller than light clients, but as secure as a full node. And then you also have this kind of interesting idea of interoperability because you can verify the entire Mina state in a single proof. If you can write, let's say, an Ethereum contract that verifies this proof, you can actually bridge the entire Mina state to Ethereum in one single non interactive transaction. You just send the proof to this smart contract on Ethereum if the proof is valid. So the smart contract checks if the proof is valid. And if it is valid, then the whole state is bridged over to Ethereum. And so Ethereum Foundation and Mina Foundation have actually funded a project that's doing this.
00:40:40.146 - 00:41:54.170, Speaker D: Right now, nil foundation is working on a bridge and there's a demo that works on one of the Ethereum testnets, so that's pretty cool too. The other thing that you have is there's no gas model because the smart contracts execute on the user's machine and the Mina blockchain is only verifying proofs. You can do as little or as much computation as you want and it will always cost the same amount. The proof is, well, network demand will affect the price that you have to pay in order to get the transaction included, but no matter how much computation you do, it'll cost the same amount on a given day. And so yeah, this opens the door to building applications that require dramatically more computation than are possible on Ethereum right now. And this idea of being able to do a lot of execution off chain goes kind of even further because you can actually build applications that fit a really different model than is possible on blockchains right now. The user flow is kind of different and so I'll actually talk about this at the very end as kind of like a bonus.
00:41:54.170 - 00:42:51.766, Speaker D: So yeah. What does an example of this look like? Well, if we want to prove that we have more than 1000 pesos in our bank account, but we don't want to reveal the exact amount or any identifiable information about ourselves, and then we want to bridge this to a chain like ethereum. This is something that's possible with Mina. That all of these bullet points would be hard to do with anything that came before Mina. So proving that we have a thousand pesos in our bank account, we're actually working on something called ZK Oracles right now, which is a process where we prove a TLS handshake inside of a zero knowledge proof. So that we get the ability to basically take any information on any website and pull it onto the MENA blockchain without having to worry about a quorum of Oracle operators cooperating or incentivizing them or paying them or anything like that. We rely on cryptography instead of game theory.
00:42:51.766 - 00:43:41.418, Speaker D: And so it's pretty much if you go to the website, the website proves to you that it's who it says it is and it proves to you that nobody has tampered with the information in transit. And then we create a zero knowledge proof of this so that this proof is non interactive and you can just put it on chain. So let's say, yeah, I want to prove that I have more than 1000 pesos in my bank account. First, I can prove that I went to my bank account's website and that it said that it sent me this page. And so this page has all my information, and so we don't want to reveal that because it would make it really easy to steal our identity. And so then what we can do is we can take this proof and we can prove about it that just that our account balance is greater than 1000 pesos. And so now we've augmented the data so that it's still useful for what we want it for, but it's not going to cause problems from a privacy standpoint.
00:43:41.418 - 00:44:21.690, Speaker D: And then that attestation which lives on Mina can be bridged over to Ethereum. And so all of these properties come from just the fact that we're doing things a lot differently. We've kind of rethought how blockchain should work in the context of efficient zero knowledge proofs. So Zkapp consists of two parts. We have the Smart Contract itself, which is written in TypeScript using our library snarky JS and then we also have the UI, which you can also write in TypeScript. And you can pretty much write your Smart Contract as something in one repository, put it on NPM, and import it into your UI. And yeah, it's a very straightforward workflow.
00:44:21.690 - 00:45:29.674, Speaker D: So Snarky JS contract, it's written in TypeScript and it eventually compiles into two things. One of these is a prover function which is what the users will actually run when they interact with your application this is what runs in their browser. So it will do what you tell it to do but then it'll also generate a proof that it did what you told it to do correctly and then that's what will get sent to Mina. It'll also generate a verification key which is the thing that actually gets stored on Mina and commits to the business logic that's in your smart contract. And so this verification key is a small sort of random looking number that is computed by really complicated means but ultimately can be used to verify that any interaction you have with your smart contract is a valid interaction for the code that you use to generate it. So when we deploy a verification key to the Mina blockchain we create something called a Zkap account. There's not as well defined of a difference between, I don't know, an externally owned account and a contract account as there is on a blockchain like Ethereum with Mina.
00:45:29.674 - 00:46:31.726, Speaker D: Zkap account is basically an account that has one of these verification keys associated with it and it will only accept transactions if they have a valid proof associated with that verification key. And so this is how you can constrain these accounts to be usable only in some specific way that's defined by your smart contract logic. And so when we deploy one of these accounts then we can interact with this account doing whatever we want to as long as our transaction is also accompanied by a valid zero knowledge proof. But if it's not accompanied by a valid zero knowledge proof, then the transaction just fails. The blockchain won't mine it and so yeah, this is how we can constrain, you can constrain the functionality of this account in whatever way you want by this means. So inside of a ZK app we have a bunch of methods and these are the things that users can call the methods take. So we take in some sort of arguments that the user can generate.
00:46:31.726 - 00:47:06.922, Speaker D: We take in smart contract state. So this is the state of the smart contract before our method runs. And then we also take in state of the world which would be something like block height or, I don't know, verifiable randomness. What we spit out is a zero knowledge proof that proves that what we did, we did correctly and also updates to the state of the world and updates to the state of our smart contract. And so as long as the zero knowledge proof is valid, then these updates are committed. So yeah, we use Snarky JS to write these smart contracts. Snarky JS is a TypeScript library and we chose TypeScript for kind of a couple of different reasons.
00:47:06.922 - 00:47:49.280, Speaker D: But really the reason why is because the JavaScript ecosystem is really strong and we're really ecosystem focused. We want to make something that people can use to build cryptographers, can build some fancy cryptography library and then people who are not cryptographers can use this fancy cryptography library to build some really great idea. So, yeah, you can use Vs. Code, NPM, prettier, ESLint, whatever. The Vs code support is great. The IntelliSense really makes it pretty easy to figure out Snarky JS. Even if you don't ever look at the docs, you can just kind of look at the IntelliSense and get started.
00:47:49.280 - 00:48:35.446, Speaker D: But yeah, we also have things like NPM and ESLint. And so the idea is just that we have minimal developer tooling. We didn't want to reinvent the wheel, we wanted to let people use the things that they're familiar with and the things that are mature to that end. The developer tooling that we do have is called the Zkapp CLI and it's really easy to use and really powerful despite being simple and elegant. It's just a node package. You can install it as it shows here and then it can deploy your contracts to the mina blockchain. It can scaffold these contracts so that you have Linters set up that will help you prettier and it'll set up a project that has an ad contract by default.
00:48:35.446 - 00:48:47.840, Speaker D: And this is probably a good place if anybody's thinking about maybe building something. Just install the Zkapp CLI, look at the ad contract and see what you think of it. I think it will be pretty intuitive just looking at it with no context even.
00:48:48.690 - 00:48:49.102, Speaker C: Yeah.
00:48:49.156 - 00:49:13.478, Speaker D: Moving on to Snarky JS Zkaps are written in TypeScript. Using Snarky JS we use existing open technologies. It runs in the browser and in node JS you can use existing JavaScript and TypeScript libraries and tools. Excellent vs. Code support. Yeah. So, okay, why do we have to use snarky JS like, what is a zero Knowledge proof? A zero knowledge proof is basically a math problem.
00:49:13.478 - 00:49:54.206, Speaker D: Well, a zero knowledge proof system is basically a math problem and a zero knowledge proof is a solution to one of these math problems. And so this gets complicated because you have to be able to configure our math problem to represent some kind of smart contract logic that we want to allow people to prove that they're doing correctly. And so this is what Snarky JS does. It handles most of this hard work of turning a program into a math problem. But at the end of the day, the math problem is the thing that's used to check that people are executing code correctly. And it's also well, it's a math problem. So it's not defined over like strings or booleans.
00:49:54.206 - 00:50:20.460, Speaker D: It's defined over numbers. And in fact, a specific kind of number called an element of a finite field. It's not really important to dive into what that means. If you're curious, you can just Google it. But from a developer perspective, it really works very similarly to like a UN two five six. In solidity. You have natural numbers from zero to a number that's almost the same as the max for UN two five six.
00:50:20.460 - 00:50:54.694, Speaker D: Sorry. This type is represented as something called field in Snarky JS, and you can work with it directly. There are some reasons why you might want to. It's very efficient to work with it directly because ultimately this is what everything turns into in the math problem. But you don't have to if that seems pretty confusing. We've built types on top of the field type like Bull and UN 64 and other types so that if you want to use the things you're more familiar with, you can. And then this will do the work of figuring out how to turn these into field elements under the hood for you.
00:50:54.694 - 00:51:33.134, Speaker D: The downside is that they're a bit a little bit less efficient than working with field elements directly. But you can start with something that's easy to implement and then optimize where you need. Functions are just normal TypeScript. Functions and data are normal TypeScript classes. So if we look here, we have a function, add one and double we pass in something called X, which is a field, and we return a field. And so what we're returning is X, add one, multiply two. Kind of a common question is why can't we use the JavaScript infix operator here? Why can't we do X space plus space one? Well, the reason why is because JavaScript doesn't know how to make sense of field elements and it certainly doesn't know how to turn them into an equation.
00:51:33.134 - 00:52:09.950, Speaker D: And so this is what Snarky JS does. It lets you define addition over these field elements and it figures out how to turn this addition into something that's a part of the math problem, so that it's constrained by the proof. When we pass in a one here, you can see so this is just a normal JavaScript one and it gets promoted into being a field element of value one. This looks a little bit weird and in practice it actually ends up just being very elegant. This kind of chaining API is something that lots of people have told us they like. And I've also kind of grown to like it. So yeah, here we've got another example.
00:52:09.950 - 00:52:43.686, Speaker D: We're taking a field passing in a number one. It gets promoted into a field of value one, and then we're adding to it a field of value three to get a field of value four. So Sum here will equal a field element of value four. So yeah, let's look at a Hello World example. We're going to write a smart contract with a single state variable called X and it will have an update method that will let us replace X with its square. And we can only update it if we control a secret admin private key. So this is kind of the requirements for our contract.
00:52:43.686 - 00:53:15.826, Speaker D: And now I'll get into how you build it. Okay, so yeah, here's what we have. We have this idea of X is equal to three. We want to be able to call update with nine and a secret key. And as long as the secret key corresponds to the secret admin key, and as long as nine is the square of three, then we'll be able to update. And then we can call the same thing again with 81 and we'll be able to update again because 81 is a square of nine. But if, when X is equal to nine, we call update with 75, it will simply fail.
00:53:15.826 - 00:53:52.158, Speaker D: We won't be able to generate a valid proof because 75 is not the square of nine. So to write a Snarky JS smart contract, we just extend this smart contract class in Snarky JS, you just import it and extend. So here we have a smart contract called Hello World. It's that simple. And then if we want to define state that's going to be stored on the mina blockchain, we have a variable here called X. And we use this state decorator in order to say we want to take this variable x, we want to store it on the mina blockchain. We want to make sure that anytime it's updated, it's being updated in a legal way.
00:53:52.158 - 00:54:36.026, Speaker D: And we also want it to have the type of field. So we could change this field type to like public key or UN 64, any kind of type that's comprised of fields in order to make them easier to work with. But in this case we're just using field. This is a part of on chain state. Now the other thing that we're going to do here is we're going to look at this deploy method. So this is sort of used as like the constructor this figures out how the contract should be before users interact with it, but at the time that it's deployed to the network. So don't worry about these Deploy ARGs or these first two lines are just here so that the Zkapp CLI can hook in and figure out how to put it on chain.
00:54:36.026 - 00:55:01.826, Speaker D: It's really straightforward from a user perspective. This will get scaffolded in when you ZK project. But then we have this X set to three. And so this is going to take our on chain state variable here, x, and it's going to set it to a value of three. Three is going to get promoted into a field element and the onchain state is going to be equal to a field element of value three. And then we have this party set value, this self update delegate admin private key. Don't worry too much about party.
00:55:01.826 - 00:55:29.840, Speaker D: Either party is basically something that, well, okay, don't worry about this very much at all. What this is doing is it's basically taking a property of the Zkapp account and it's changing it to something different. So in this case, we're setting this property to the admin public key so that then we can verify that the private key corresponds to this public key and only allow people who possess the private key to interact with this smart contract. And so I should also say.
00:55:32.690 - 00:55:33.006, Speaker C: This.
00:55:33.028 - 00:56:19.870, Speaker D: Whole Deploy method is something that will default to something that makes sense. You will not have to think about this. In most cases you'll just sort of not touch Deploy and work forward however you want to or you'll just use Deploy to set the initial values. But the idea is that this is here so that you can when you need to change things, but you don't have to worry about this kind of level of complexity straight away. So, yeah, then inside of the smart contract, underneath our state declarations and our Deploy method, we have methods that users can call. And so we specify these using this method decorator. And the method decorator basically says, hey, this is something that users are going to call and when they do call it, you need to remember what you're doing and then you need to prove that you did it correctly.
00:56:19.870 - 00:56:52.362, Speaker D: And so this update method gets passed in a squared, which is a field element, and an admin, which is a private key which is comprised of field elements. But you can see, you can work with the private key type here directly. And so what we do is we have this constant x which we're going to set equal to this X get. So we're going to get the value of X, which is going to be a field element equal to three. I think if we look at the last slide, yeah, it's going to be equal to three. And so x is going to be equal to the on chain state value of x. And then we're going to assert that it's equal to X.
00:56:52.362 - 00:57:17.518, Speaker D: So this is kind of a confusing line. What is this doing? Well, this assert equals, it doesn't return like a true or a false. It's just something that it has to be true, otherwise the proof can't be generated. You can't generate a valid proof unless X is equal to X. And so this seems kind of superfluous here. It's just like a best practice. But what it means is that if X doesn't equal X, you can't generate a valid proof.
00:57:17.518 - 00:58:09.470, Speaker D: Or I guess if this X, which is the X from the state variable, isn't equal to the X in this scope, you can't generate a proof. And so then we take X and we call the square method, which is built into the field type. And then we assert that it's equal to squared, and squared is the thing we pass in. And so if we don't pass in the square of X, we just can't generate a proof and you won't be able to send a transaction to Mina. And then what we do is we take X and we set it equal to squared. So we set this state variable X equal to the squared value that we passed in. And so again, you don't have to worry about this code running unless all of these assert equals are true, the code will run on the user's computer, but they just won't be able to generate a proof.
00:58:09.470 - 00:58:40.950, Speaker D: And so if they can't generate a proof, none of this stuff can be committed to the blockchain. So yeah, it's pretty straightforward in that way. So the state of the Zkap is public unless it's stored as a commitment. But that's pretty easy. We have a hash function called poseidon, which is really efficient. So you can just hash anything that you would want to store as private state and then pass it in and verify that the hash is correct in the middle of your method. Then any arguments to a method are private unless they're stored as arguments directly.
00:58:40.950 - 00:59:28.250, Speaker D: And so what this means is that even though we're passing in a private key to admin, we're passing in a private key to update. It actually does not matter because this private key never leaves the machine. It's used to generate the zero knowledge proof and then it's not used again. So the update method in this case calls git, which fetches the state from the Mina blockchain. And then we also assert that X let's see, we assert that X oh yeah, sorry. We assert that X is equal to its square and then we set that equal to the new value of X on chain. Then we have sort of one more thing to do, which is that we want to make sure that this can only be called by the person who has the private key associated with admin.
00:59:28.250 - 01:00:05.046, Speaker D: I'm sorry. Yeah, the person who has the private key associated with admin. So what we do is we can take in the admin public key and we take in the admin private key, which we pass in. Okay, I'm sorry. We create a variable called admin public key and we set it equal to this result of this two public key method on admin, which is the private key that we pass in. So we pass in a private key, we compute the public key from it, and then we set it to admin public key. And then we ensure, we assert that this is equal to the admin public key property in our ZK app account.
01:00:05.046 - 01:00:48.920, Speaker D: And if it's not equal, then we can't generate a proof and we just can't interact with the smart contract. So this way only somebody who has the private key for the admin account can use this method. And when they do, they won't be revealing their private key. So when we run update nine with our secret key, what we're proving is that we ran some code in the updates method with some arguments and the result was so this is all we're proving. We're just proving that we ran some code with some arguments and the right thing happened. The result is that we'll set X equal to nine. And what we assume what we're proving with the zero knowledge proof in this is that X did or in order for the zero knowledge proof to work, x has to be equal to three.
01:00:48.920 - 01:01:42.360, Speaker D: Admin secret key has to correspond to Admin public key, and then the delegate property on the account has to be equal to Admin public key. So yeah, this is pretty much the anatomy of one of these smart contracts. We have state defined. At the top, we have a deploy method which sort of sets the contract up as we want, and then we have methods that users can call. And as a bonus really quickly, one of the interesting things that you can do with Mina that you can't do with other blockchains that I kind of hinted at earlier is you can actually take some of this execution in a totally different direction. So in the case of something like a game, you might want to let users play a game without needing to submit a transaction to the chain every time that they make a move and pay gas fees and wait for a block to be mined. And so this isn't possible on other blockchains because the smart contracts have to run.
01:01:42.360 - 01:02:13.418, Speaker D: So on. Mina you can actually build smart contracts that run asynchronously. And this would look like I could make a move, prove that I made the move correctly, send it to another player. They would verify that I made the move correctly, prove that they made their move correctly, and we would go back and forth until eventually we have one proof that represents the entire game that it was played correctly, and everybody's move. And then that proof could be submitted. To Mina at the end in order to settle the game and get like an NFT for the winner or something. So this is a totally different approach.
01:02:13.418 - 01:02:35.014, Speaker D: The users wouldn't have to pay gas and they also wouldn't have to wait for blocks. And this is just sort of one thing you can do. You can do so many things so differently with Mina. And so if you're curious about it, come talk to me after. Where you can get involved is we have build ZK apps, make educational content, and help mentor people. You should join the ZK app developers channel on discord. It's cool.
01:02:35.014 - 01:03:05.106, Speaker D: It's full of people who are building ZK apps. And we have backward looking grants quarterly. So if you do good stuff, we might just give you money, but not until you've done good stuff. You can learn more in the yeah, the Zkapp Developer Discord is the best place and the docs, these are the two places to go to. But we also have Twitters for Mina Protocol and O of One Labs, which you should definitely follow because there's cool stuff on them and that's it. No time for questions and answers, but we have a booth right in the middle. Come talk to me if you have any questions.
01:03:05.106 - 01:03:08.740, Speaker D: I would love to answer them. All right, bye guys. Thanks so much.
01:05:26.560 - 01:05:51.010, Speaker F: To the organizer of the event. This is really cool. Thanks for having me here. This is a real pleasure. I'm Miguel Martinez, solidity developer at Abbey Companies. Yeah, I've been involved in the development of the third iteration of the Abbey Protocol that was released a half a year ago. And this is why I'm here today for.
01:05:51.010 - 01:06:54.520, Speaker F: I'm going to give a great overview of the new features of the version three of the protocol, as well as giving you some really cool ideas to build on top of them. Also, I'm going to go through some of the developer resources that are all available for you guys to create stunning things as soon as possible for the hackathon. So, yeah, let's start. For those that don't know what ave is or how abe works, this is a quick 101 about the protocol. The users can come to the protocol with some crypto assets and supply them in order to earn some interest on it. They can also use them as collateral to borrow crypto assets so they will take out over collateralized loans. Since these positions are over collateralized, the value of the collateral should be always higher than the value of the assets that they borrow.
01:06:54.520 - 01:08:15.450, Speaker F: So users need to keep and maintain their positions and if they don't do it, there is a third actor in place called Liquidator that has the ability to pay someone's debt and claim some of the collateral at a discounted price. The interest that the suppliers are earning is based on the interest that the borrowers are paying for the loans and the interest rate of the loans are calculated algorithmically. So this is why the average protocol is called an algorithmic lending market. There is around $12 billion of total value lock in all the net all the markets of the above protocol. In the protocol we have the concept of market which is each deployment of the protocol on a specific network. So the previous iteration of the Ari protocol, the version two was deployed on multiple networks like Ethereum, Polygon and Avalanche. But the third version was deployed on some other networks like Optimism, Arbitrum, Harmony and also Phantom.
01:08:15.450 - 01:09:22.350, Speaker F: There is also some other, let's say peculiar markets like for example the real world assets one powered by Centrifuge and also the Permissioned market Abe Arc which is also powered by Fireblocks, Shiba, bank and Securitize among others. A little bit of alpha here. There is more markets coming soon so you want to get into know just take a look to the Governance forum, there is a lot of discussion there. So yeah, the AB three brings groundbreaking new features on top of the fundamental elements of the Abi protocol like for example eight tokens, stable rate, instant liquidity, credit, delegation and so on and so forth. And there is three main areas of innovation capital efficiency, risk and security and also decentralization. So let's dig it into the capital efficiency. The first one, the big one is Portals.
01:09:22.350 - 01:10:56.970, Speaker F: Portals is in my opinion one of the most interesting ones in terms of UX and also multichinature since it gives the opportunity to the users to bridge assets from between chains in a simplest way. So while the previous iterations of the protocol were deployed on multiple networks with minimum TBL, the users had no way to move assets from one network to another in an easy way. They had to withdraw the assets from the market on the origin chain and then bridge these assets and finally supply the assets again in the destination market. With Portals, users don't have to bridge their assets in their own, they don't need to unwind their positions and they can bridge the A tokens with a tokens is what is called the assets that are provided to the protocol. They can bridge the a tokens from one network to another in a seamless way without losing a penny of a dollar on interest all in one transaction. So Portals is not a breach solution. To be clear, Portals is a set of contracts that contains all the logic needed for supplying assets in a deferred manner by special entities which are called ports.
01:10:56.970 - 01:12:23.222, Speaker F: A port is just any kind of entity that is whitelisted by the community, by the governance as an authorized bridge that is able to move assets between chains. So let's say that a user wants to bridge eight tokens from Ethereum to Arbitrum. This port will take the A tokens from the user on Ethereum and will mint in an instant way freshly new a tokens on behalf of the user in the destination chain, in this case Arbitrum. Now the port should withdraw the a tokens from the origin chain, bridge the underlying from Ethereum to Arbitrum, and finally backed the underlying tokens that backed the eight tokens that were minted previously in Arbitra. In this way the protocol is completely solvent and backed at the end of the process. As you can see, this feature will bring a brand new wave of use cases on top of the protocol because it allows to breach assets in a seamless way and we will see for sure protocols for cross chain borrowing or things like that. This is efficiency mode.
01:12:23.222 - 01:13:28.778, Speaker F: This allows to increase the collateral efficiency of the protocol, providing higher collateral factors to the users. This is possible when the user is supplying or borrowing assets that belongs to the same group of assets, also known as categories. What is a category? That's the question. A category is just a group of assets that shares the same nature or characteristics. We need to categorize the assets in groups because there is a variety of assets listed in the protocol that has different characteristics, nature or even price volatility. So grouping the assets that have the same price correlation allows the protocol to minimize the risk as well as provide higher collateral factors to the users. So in this example, in this diagram you will see three categories.
01:13:28.778 - 01:14:33.566, Speaker F: We have the stablecoin category, also one for east derivatives and also another one for BTC. This is just an example. We could have different categories in the future and needs to be decided by the community for sure. Talking about the stablecoins category here we have USDT, Dai, USDC in some markets, there is even the Euro pairs here. And in this case Dai is giving 75% of collateral factor while USDC is giving 80% of collateral factor. So that means that the user when they use die or USDC as collateral, they can take out 75 or 80 die out of their 100 die or USDC. But if the user joins the stablecoin emote category, he can enjoy a maximized borrowing power and he will be able to get up to 97% of collateral factors.
01:14:33.566 - 01:15:32.434, Speaker F: So the user can borrow up to 97 die from using their 100 die as collateral in this case. So this particularly interesting for use cases like high leverage tokenized position or even high leverage farming positions. And this also allows to have a diversified risk management position since now the user can choose in which category want to play in terms of risk on security. There is a bunch of new things that the governance can enact to keep the protocol a lot safer. The first two is supply and borrow caps. These two are pretty easy to understand. They are limits that can be placed on individual tokens on the supply or the borrowing side.
01:15:32.434 - 01:16:22.420, Speaker F: So the user can only supply or borrow up to a certain amount. This is very useful for mitigating attacks like Oracle Manipulation or Infinite Minting. In these cases, the attacker tries to trick the system in some way, supply an alert amount of collateral in order to drain the liquidity. So with these caps, the Protocol can now limit this kind of attacks. These two measures come hand by hand together with the isolation mode. But the isolation mode is more interested when assets are getting listed in the Protocol. When an asset is listed as isolated, you can only use these assets as collateral by itself, you will only be able to borrow stablecoins against it.
01:16:22.420 - 01:17:47.120, Speaker F: Also, the isolated asset has a debt ceiling, so the user can only borrow up to a certain amount of stable coins using this isolated asset. As you can see, assets in isolated mode, in isolation mode, allows the Protocol to isolate their risk and exposure to a certain asset. And this is pretty powerful because it allows the community to list assets in a more secure way. So network assets can get listed in the Protocol with maybe more conservative risk parameters to start out with and basically prove themselves as a viable candidate to get completely listed as collateral in the future. So I can imagine assets being listed as in isolation mode first, then going with some supply and borrow caps, and at the end, none of these measures at all. Yeah, the centralization, the third version of the Protocol comes with more fine grained permissioning and role system that gives more flexibility to the Protocol. So first we have the risk admins.
01:17:47.120 - 01:18:55.048, Speaker F: These are entities that are listed by the Protocol and the governance that has the ability to update the risk parameters of the listed tokens or assets of the Protocol without the need of an onchain vote. So things like collateral factors, liquidation thresholds or even interest rates are the things that can be updated by this role. These entities could be maybe contributors of the Avidao, like for example Gauntlet, which is a contributor that has been pushing risk updates regularly for a long time. Or even some kind of automated agent that pushes updates on the risk parameters. Given some metrics of the assets, this is maybe the case of the chainlink's proof of reserve technology. This is something that has been discussed in the community forum. The chainlink proofs of reserves technology allows to monitor and keep track of the reserves of those assets.
01:18:55.048 - 01:20:01.920, Speaker F: That requires some level of over collateralization or things like that. So things like stable coins or bridge assets. So if the invariant doesn't hold, if these assets are not overcloudalized anymore, there could be an automated agent that keeps track of this event and updates their risk parameters accordingly, or even post the reserve of the Protocol also listing admins. This is just another entity of the system that has the ability to list new assets in the Protocol, a part of the, let's say, canonical or regular way of listing new assets. And also the isolation mode. We could have new innovative ways of listing new assets. For example, we could have permission listing or listing new assets based on a certain amount of tokens that are staked in the protocol.
01:20:01.920 - 01:21:15.762, Speaker F: Just a way to backstop in case of a short fall event for example. So this will bring new interesting strategies to list new assets in the protocol. Of course there is a bunch of more new features that came together with the version three of the protocol. There is the introduction of the permit on all the functions of all the main functions and user facing functions of the protocol. This is a way to save gas basically so the users don't need to approve before the actual action they want to perform. Also the repayment with a token is pretty useful in the case the user supply and borrow the same asset so they don't need to flash loan and swap or swap with collateral and things like that. This is also pretty relevant these days because it allows to mitigate the risk of having assets or underlying being blocked in the contracts.
01:21:15.762 - 01:21:59.950, Speaker F: Because now with this feature of repayment with a tokens there is no need to retrieve the underlying assets from the pool. We could have secondary markets around the a tokens. So if some entity locks the underlying tokens that the pool is holding nowadays, it's not going to be an issue anymore. There is also a Simplify Floss loan function. This comes with a 20% gas reduction. Pretty useful in case you want to take a flash loan of only one single asset. Also another entity called Flash borrowers.
01:21:59.950 - 01:22:52.302, Speaker F: Pretty relevant for those protocols that are using abe flash loans in a day to day basis. And also a new set of smart contracts that allows having multiple rewards at the same time for the users. So now everything can provide incentives so the users can get more rewards using some kind of assets in the protocol. And yeah, let's dig it now into the resources that you have available in case you're going to build stunning things on top of it. So just a bit of context. The pool contract is the main point of interaction in the Abbey protocol. It contains all the crucial and key functions.
01:22:52.302 - 01:23:48.954, Speaker F: There is some pretty simple functions like supply, borrow, withdraw, repay and things like that. And there is also secondary functions like for example liquidate plus loan enabling, emote, enabling an asset as collateral among others. So if you want to interact with the average protocol, you should take a look to this contract and start talking with it. Basically, if you are writing smart contracts, I encourage you to take a look to these two NPM packages, the Ave core V three and also the Ave periphery V three. If you want to talk with the pool contract, you should use the core package. And if you want to interact with the rewards with the treasury contracts, with UI adapters, you should use the periphery one. There is also this QR code that links to the registry of NPM packets.
01:23:48.954 - 01:24:39.534, Speaker F: There is a lot of interesting packages there, just take a look. There is one for the Abbey Token, also another one for the crosschain governance adapters. And yeah, there is also a very helpful and powerful package which is a JavaScript SDK. So it contains a lot of contract helpers that allows you to interact with the protocol without the need of loading the contract bi and all that work. There is also a really powerful tool which is called Ave Sandbox. With this tool you can take any production market v two or v three and create a fork of it inside of a hardhat node. You can also faucet all the listed assets.
01:24:39.534 - 01:25:41.122, Speaker F: So you can create complex positions and you can even connect the interface of the Ave protocol with this environment and just try yourself. How does it feel from the UI perspective? So please take a look if you want to create something really quick during these days. Now if you are more interested in the data, in the data and you want to fetch the live data. So what is currently going on in the Ave protocol right now? You can use these couple of contracts. These are contracts that can be used as data providers. They aggregate all the relevant information. In this case, we have the Uipool data provider that contains all the relevant information for the pool and also for getting to know what is the state of a user position inside the pool.
01:25:41.122 - 01:26:42.014, Speaker F: And also the UI incentives data provider that provides all the information regarding the incentives. So what's the distribution of the incentives, what are their addresses, the APY and things like that. There is also another package that allows you to format all data so you can apply the correct decimals to each thing. And I think it's also pretty useful and helpful. And yeah, if you want to take and retrieve the historical data, you should use the subgraphs that are available. And yeah, you can just fetch the user transaction history or historical rates or even the balances of a user of the pool at a specific block height. And yeah, that's pretty much all guys.
01:26:42.014 - 01:27:24.058, Speaker F: These are the prices for the hackathon. Please be creative. There's a ton of things that you can create. I already gave some ideas of cool things that you can create. Like for example, high leverage positions, diversified risk management, also automated agents for listing new assets or for updating risk parameters. Also protocols for cross chain borrowing for sure. So let's make your imagination fly a part of the things that you can build on top of B three.
01:27:24.058 - 01:28:46.110, Speaker F: There is always a lot of things that you can create. For example, on the governance side or just as an integrator in the governance side, there is a real need of tools, applications and even dashboards not only to enhance the governance process, but also to increase the participation of the governance, which is also always a really good thing for the protocol. And of course there is a lot of room to innovate in the case you are an integrator because you can create fixed term lending protocol or also under collateralized lending protocol or everything that came to your mind in terms of supplying or borrowing crypto assets. If these ideas are not enough, you can take a look to these pages. There is a call for hackers here. Also there is some interesting rockers for proposal on the Ave GrantSdao side and for sure the developer docs are pretty helpful for all of this. And that's pretty much all guys, it's a real pleasure.
01:28:46.110 - 01:29:04.760, Speaker F: Thanks for coming and if you have any question or you want to talk with us, what's going on in the crypto ecosystem or what's going on on the Abbey companies or the Abbey protocol, just reach us out. I will be around next to the Lens booth and the Abbey booth. Thanks a lot.
01:30:27.280 - 01:31:04.122, Speaker B: So we'll be super inclusive here. Alan Smart, contract developer on Lens Protocol.
01:31:04.266 - 01:31:15.010, Speaker E: And we're going to give a quick overview of how Lens works as well as kind of a bit about how we think about apps that are built on top of Lens. So Alan, you can start us off.
01:31:15.080 - 01:31:16.994, Speaker A: Yeah. Okay.
01:31:17.192 - 01:32:21.490, Speaker B: Primar Candace Asindo Lens basic OMD applicationes sociales tinm prolemas principal mente sensora notin portavillia composite interoperable. Totally accessible. As in the Lens is USAR Samo Camierto blockchain komovas paracriarum social Graph ah Aviato de Santralisado permissionless permita, rochellore applications and like Spreencia deusuario in non suadino Lamabaso permit.
01:32:43.790 - 01:33:08.706, Speaker E: And Lens kind of offers something different. Lens is a decentralized social graph protocol that developers can use to build social experiences. You can build apps and tools on top of a composable and decentralized social graph. This allows you to focus on the user experience instead of user acquisition. The user of one's Lens app is also the user of another. Fundamentally, all of the data belongs to the user and they choose how to share it. The Lens Protocol.
01:33:08.706 - 01:33:40.670, Speaker E: Additionally, empowers creators. You can post from a singular front end and it will go to your audience, regardless of what app they are using. They own the links between themselves and their community and it forms a fully composable social graph. So how do we do this? The lens social graph is built on NFTs standard ERC 721. It all centered around the profile NFT. This is your profile. It has your profile image, your name, all kinds of different metadata you can define as well as all of your posts and publications.
01:33:40.670 - 01:34:17.020, Speaker E: When you post, you're posting to this profile, people can follow you. So if I wanted to go follow Alan on Lens, I would call follow on his profile NFT and a follow NFT will be issued. So again, following is directly on chain and lastly there's posts, comments and mirrors. The ways you actually post to the graph. These are not NFTs, they actually live inside of your profile. But you can add logic to monetize them and turn them into an NFT. So instead of just tweeting randomly I can make a publication and I can sell or of a photo and I can sell that five times, ten times for five matic, five e you pick the price.
01:34:19.390 - 01:35:05.290, Speaker B: Okay? Una puerto r social graph el permisso para actuar so perfilque basic follow so room perfil.
01:35:07.650 - 01:35:08.510, Speaker D: NFT.
01:35:11.170 - 01:36:55.550, Speaker B: Relation de follow e portimoto public asian NFTs poor default pero puerto collection case collection r or collect tolos NFTs CNL standard ERC. 721 protocol case acceptance standard ilas Ramentas or marketplaces as you get tangle al qilado vendor superfield as who follows depending on antimensionala publicaciones el post el comment or commentario calmiro repost, basic comment enthusiasm. El commentario is unpost basic el mirror simply not in a continuum as a continuo lenses agnostico de le storage de la mace lost metadatos de contino enthusiasm IPFS AWS on chain, off chain, publico priado depending.
01:36:58.690 - 01:37:27.846, Speaker E: So, as Alan was saying, when you post to your profile, there's three different types of publications. There is the simple post, the comment and the mirror. The post itself is just content. This can be of any content type, text, image, video, anything. The comment has content as well, but it also has a reference to another publication. Again, the content can be anything. And lastly there's the mirror.
01:37:27.846 - 01:38:07.686, Speaker E: The mirror is simply a reference. A mirror is a repost similar to like a retweet. The key thing about Lens is Lens is fully agnostic to where the data is stored. So all that is asked for in the contract is the content URL or the link. So you can decide to say hey, the content lives on IPFS or the content lives on AR Weave or the content lives over on Amazon s three. Fundamentally we have left that open to you as the developer to decide and it is fully flexible to whatever use case you have. Additionally, for smart contract developers there's ways to extend Lens with modules.
01:38:07.686 - 01:38:45.426, Speaker E: There are three different hooks where Lens will call out to an external module. The first is the follow module. So the follow module is executed when somebody tries to follow the profile. So if Alan were to try to follow me, all of the data about how he's trying to follow gets forwarded to another contract and that can be any logic. For example, I can say Alan, in order for you to follow me you have to pay me five matic or you have to hold a board ape or you have to already be following Lens protocol. The logic is fully configurable for you as the developer. Posts and Comments have two other types of modules a reference module.
01:38:45.426 - 01:39:17.358, Speaker E: This determines whether or not something can be referenced that's called on comments and on mirrors. So an example of that is only my followers are allowed to comment on my posts or mirror them. I could also say that only people who hold more than five FWB tokens are able to comment on my post or mirror them. And they allow you to restrict access to certain communities. And the last type of module is the Collect module. This is how you monetize publications. And again, it is fully configurable to how the developer wants.
01:39:17.358 - 01:39:41.110, Speaker E: So if I were to post a really great image here in my time in Mexico City, I can say, hey, I want to create an NFT out of this. I am issuing ten of them and they are five matic each. I could also say these are ten of them, one matic each. But you can also only collect it if you follow me already, again, all of the logic is fully configurable. And this is a really awesome place if you're a smart contract developer.
01:39:44.250 - 01:42:30.800, Speaker B: Selling protocol of Molos molos primero module module basica kondo aliena sena operacion the follow so perfill enthusiasm usarlo para desidir sila peracion the follows multiple module IPone fee follow module don the shokomo del per del perfil elijah indices permit DSI para mintierum follow NFT demi perfilo uno assume post on commentario keson el collect module yell reference module el collect module collection itaminola Contando Lantia collect so post and don't says limita collection DFSS reference module lomi Mattel alohica comment on mirrors limiter commentarun public asones Lamashella Kendall says jesus and me follow module. Show me sigan pero sandoisa ave interest.
01:42:34.770 - 01:42:35.550, Speaker A: Token.
01:42:40.610 - 01:42:41.790, Speaker B: Creativity.
01:42:47.750 - 01:43:28.858, Speaker E: So in addition to the Lens contracts, we also have the Lens API, which is an API service that ave companies is currently offering. And part of the benefits we recommend using it for hackathons is because it allows you to build Lens apps really quickly. There's no need to worry about indexing querying data dealing with blockchain reorgs speed of fetching the data. You don't have to worry about prefilling contract data. It exposes a web two style interface for you to interact directly with the protocol. If you know how to use GraphQL, you're going to feel right at home with the Lens API. Additionally, we have a Gasless API that allows applications to pay for gas on behalf of their users.
01:43:28.858 - 01:44:04.570, Speaker E: And in addition, today we turned on a signature free API that allows users who opt in to allow apps to sign on their behalf, allowing for one click access. Incredibly smooth experiences. Definitely recommend you try them out on some of the Lens apps out today. Additionally, the Lens API integrates more protocols than just Lens. Currently, it allows you to pull data from ENS proof of humanity poop sybil.org. And today we also added Worldcoin's world ID verification. It allows developers to add data from all of these protocols to make holistic experiences.
01:44:04.570 - 01:44:13.730, Speaker E: Support for more protocols is coming. So if you're a protocol and want to work with the Lens API, please come by the booth and chat. We want to make sure we can get everything that causes great experiences to be LinkedIn.
01:44:15.910 - 01:46:14.730, Speaker B: Antistamos avalano de comos extender lens animal protocolo pero application isona API basic procoart index datos la appiotolos exponent graphqla informac contratos nina API de lens oikonotros serviceios webdos la forma traditional tamin oi lancemos una feature lens Shamadi patcher. Basic post commentarios sin Lancia Usariofinal agona firma Ela vitamin supporta gasless meta transaction solomon transaction la abitamin integra otro Protocolos guandono asiona consultant information the lens sinoka minister trashendo ensno proof of humanity kepops DNA systemcivil.org work integr integrando massimas Protocolos.
01:46:18.560 - 01:46:50.432, Speaker E: So one thing we think about is that lens allows for the building of this thing we call the experience layer. All of these amazing front ends that integrate multiple different protocols to create holistic experiences. And we've seen this a bit today. So for example, Ave, you can access the Aave protocol through a variety of different experiences app aave.com zapper rainbow instadap or even the coinbase DApp browser. And for Lens, we're seeing the same come about. There's Lens friends Lenster iris faver Lens Tube these are all different experiences built with Lens and other protocols.
01:46:50.432 - 01:47:15.308, Speaker E: And each is a unique experience. And it's something that we really hope to see when people build front ends with Lens. This is kind of how we think apps are structured when we build Lens apps. There's the blockchain. The base that you're built on Lens is on polygon, but there's a ton of other applications over on mainnet ethereum or gnosis chain avalanche optimism. We all know the various chains. There's applications that live on top.
01:47:15.308 - 01:47:55.150, Speaker E: There's Lens on all of its modules, there's live peer poop proof of humanity ENS all of DeFi like Ave and Yearn. There's this middleware layer that helps developers build apps. The graph bigbyconomy as well as the Lens API and Lens JS and other open source package to help people build Lens applications. And then there's the Experience Layer, the actual place where you go to experience the application, where your users are. So that is things like Lenster XYZ, Lens friends Lens Tube each of those providing entirely different experiences made by combining applications beneath them, potentially across different chains. And so we think Lens apps use a slightly different structure than most normal ones.
01:47:59.600 - 01:48:20.740, Speaker B: La CAPA. Experience front ends. Yes. Experience features composer. Front endofficial.com user. Supper.
01:48:20.740 - 01:48:42.656, Speaker B: Colence pasalvos. Similar Los data lens. Tantos on chains. Compartment Lavace. Usual social graph e lost peroka app. Bring down an experiential. Textual or in continuo vaso.
01:48:42.656 - 01:50:28.920, Speaker B: And bideos any Mahanes tube YouTube aria de lens pero perhaps Lenster tin el FOCO and texto micro login pero I want to see moisturize. Video catalan Lens tube don the la description el video pasa Lester el Continuo principal el video pasacer common media asconta posts, the lens blockchain o India lens time polygon intermediate bridges or Oracles composite chain link or layer zero contrary ENS proof of humanity ave Protocolos tooling. Sepana permitted filter lens. The graphio indexer's applications are the lens eto.
01:50:32.540 - 01:50:38.490, Speaker C: Good job. Yeah.
01:50:40.460 - 01:50:57.760, Speaker E: We have time for questions, so if people have any questions, you can raise your hand. We'll try to answer as many as we can. In addition, after this talk, we'll be at our booth and also in the back. If people have more technical questions, we're happy to go into in depth in both English and Spanish.
01:51:22.940 - 01:51:24.800, Speaker A: Token or NFT.
01:51:26.180 - 01:51:27.570, Speaker B: I'll follow the.
01:51:31.380 - 01:51:34.320, Speaker F: Token FTS poseido portal.
01:51:35.060 - 01:51:40.880, Speaker B: Portal. Daniel del Perfil or El Castaco?
01:51:45.940 - 01:52:11.790, Speaker C: So, the beginning, you told that every profile is an NFT, right? And every follow it's an NFT too. So as NFT is standard 721 and it's tradable. So imagine I can sell my profile, is that correct? And what about the cycle? About that?
01:52:13.280 - 01:52:20.652, Speaker B: If you sell your profile, you are selling all your follows to because the follow NFT points to a profile.
01:52:20.716 - 01:52:35.910, Speaker C: So you are selling all my profile, so I am selling to another guy or another woman what I am and what I'm built through my behavior, through my social behavior. So what about that?
01:52:36.440 - 01:52:45.290, Speaker E: It's the same as if you were to sell your Twitter account today. They have access to you're selling your posts, your reputation. It's just another asset transfer.
01:52:46.940 - 01:52:48.650, Speaker C: Do you think that is good?
01:52:50.380 - 01:52:51.370, Speaker D: Why not?
01:52:53.260 - 01:53:15.184, Speaker E: I think there's reasons why you would want to transfer. Maybe I want to move from a ledger to a multi SIG. Or if I'm a company, I want to move it around between different accounts. I think there's many reasons why you would want transfer and why you would want a marketplace. I don't want to pass judgment on what developers want to build. Like a profile can represent many other things than just my identity. It could represent like a community or a group.
01:53:15.184 - 01:53:17.520, Speaker E: And in which case you want that to be transferable.
01:53:17.680 - 01:53:33.850, Speaker C: Yeah, I just wanted to know but you already answered it if there was some security locks or something like that preventing that, but I think that there is not, right?
01:53:35.100 - 01:53:49.212, Speaker B: No, I think as you own your profile, that allows you to sell it too. So it's up to you. And I don't know, I don't see any special issue with that, but we can discuss.
01:53:49.346 - 01:53:59.760, Speaker C: Yeah, but we are not talking like selling a car or selling a computer. We are talking like selling a profile. But that's all I think. Thank you. Thank you.
01:53:59.910 - 01:54:30.970, Speaker E: I would highlight that Lens has a lot of different ways for you to keep your profile and your NFTs in a secure wallet while still letting you post and have access from a hot wallet. So the dispatcher functionality as well as metatransaction, you can read a lot about this in our documentation at docs. Lens XYZ allow you to give access to your account without allowing it to be transferred around. So there is security measures in place, but fundamentally, just like in DeFi, you control your assets with lens. You control your content, you control your reputation, you control your yeah.
01:54:34.570 - 01:54:35.606, Speaker A: Hello. Yeah.
01:54:35.708 - 01:54:37.430, Speaker D: Okay. My name is Felipe.
01:54:38.330 - 01:54:42.242, Speaker A: I have a question about identity and verified identity.
01:54:42.306 - 01:54:50.506, Speaker D: How do you handle fake accounts? Considering brands are going to start creating profiles and also celebrities about it, how.
01:54:50.528 - 01:54:51.898, Speaker C: Do you handle someone is not going.
01:54:51.904 - 01:54:54.940, Speaker D: To try to fake someone else?
01:54:55.550 - 01:55:33.510, Speaker E: So part of it is Lens is meant to be an unapinionated agnostic base layer that who is real, who is fake, who is spam is not. Those are application level decisions, and we defer to each application to make their own determination. That is part of why in the Lens API, we provide information that may be useful. Maybe we can tell you that this profile has been verified by World ID, or this other profile has been verified with proof of humanity, and you can use that as a verification system. Alternatively, you can use your own part of Lens. Being agnostic means we put the control in you, the developer, to determine what you want to show in the experience. And the Lens API is going to give you helper data.
01:55:33.510 - 01:55:38.330, Speaker E: But we think it's important that the decision is with the developer, with the front end to make their own decisions.
01:55:39.470 - 01:55:46.380, Speaker B: I would personally love to see social verification tools built on this hackathon, so feel free to do that.
01:55:49.950 - 01:55:53.214, Speaker C: Al. Hello.
01:55:53.412 - 01:55:57.726, Speaker D: I have a question regarding how do.
01:55:57.748 - 01:56:02.290, Speaker B: You manage this algorithm to choose which.
01:56:02.360 - 01:56:09.380, Speaker C: Content you show to which one? So I would like to know more about that.
01:56:09.990 - 01:56:10.402, Speaker F: Yeah.
01:56:10.456 - 01:56:43.758, Speaker E: So Lens itself has no concept of algorithms or of how to display them. Lens, all it is is a way of having social relationships and content represented on the blockchain. Applications decide how they want to present data. They can use whatever their own algorithm is to determine what to show to what users. That is for each application determined. When we say that it is the experience layer and you're competing with the best UX, that includes having the best algorithms, having the best filtering, and the best recommendations. That's really what the different applications compete on.
01:56:43.758 - 01:57:10.566, Speaker E: The API will provide certain basic functions, like you can call for a timeline or you can call for recommendations. And those algorithms have been documented and they're in the docs. I believe the timeline is just reverse chronological order based on people you follow. It's very basic. We encourage you. Another great thing to build during this hackathon would be an API that does a more sophisticated timeline query. So again, Lens, as a protocol on the base layer, doesn't even know what a timeline is.
01:57:10.566 - 01:57:12.870, Speaker E: That is for you as, like an application to implement.
01:57:13.370 - 01:57:14.280, Speaker C: Thank you.
01:57:21.210 - 01:57:23.302, Speaker A: Hello? Yeah, very quick.
01:57:23.436 - 01:57:25.398, Speaker F: When or how is one going to.
01:57:25.404 - 01:57:27.430, Speaker A: Be able to claim their own handle?
01:57:29.050 - 01:57:29.414, Speaker D: Soon.
01:57:29.452 - 01:57:41.130, Speaker E: TM. No. So, everyone, if you staked ETH to have your ticket here for ETH, Mexico, you've now been whitelisted, so you can go to claim Lens XYZ with that wallet if you're having any issues.
01:57:41.200 - 01:57:43.180, Speaker A: Yeah, awesome, thanks.
01:57:45.470 - 01:58:01.700, Speaker E: Additionally, if you stop by the booth and you get a Poop, or you get a Poop from one of the team members, you'll be whitelisted shortly. We intend to go full permissionless as soon as we can. The team is working very hard on it. When Alan is not giving speeches, that's like his number one smart contract task. So we're hoping very soon.
01:58:15.370 - 01:58:18.262, Speaker D: Hello. I'm considering to create a VR application.
01:58:18.396 - 01:58:25.130, Speaker F: That works on relentless protocol. So, like SNS application on the VR, but I'm wondering how we can access the data.
01:58:25.200 - 01:58:28.586, Speaker D: Actually, when I see several implementation right.
01:58:28.608 - 01:58:32.138, Speaker F: Now they are calling API lens Dev.
01:58:32.304 - 01:58:39.886, Speaker D: So is the data available via smart contract or we need to use a Rest API for no, no, you can.
01:58:39.908 - 01:58:44.000, Speaker B: Use the API or you can build your own index if you want.
01:58:45.970 - 01:58:51.214, Speaker F: So describe data is not available via smart contract, but it's available via Rest API.
01:58:51.262 - 01:59:17.478, Speaker E: So the data is of it. Fundamentally, when you think of what a lens publication is, it's a transaction on chain that just says in this place of state, on this index, this is what a publication is. And it has a content Uri. So there needs to be some software that will run through all of the various transactions and kind of assemble a relational structure. We offer an API, there's also the graph, there is Lens JS. There's a bunch of different solutions. Alternatively, you can run your own indexer.
01:59:17.478 - 01:59:21.158, Speaker E: The data is available on chain. You just have to know how to query it properly.
01:59:21.254 - 01:59:23.430, Speaker F: Is it on polygon chain or polygon?
01:59:23.510 - 01:59:44.770, Speaker B: Yeah. Basically the smart contracts are not good for complex queries, so good for random access. But it's just that so the contracts are emitting events of every meaningful operation and then you can build your own indexer to index those events and reconstruct the data, which is basically what our API is doing.
01:59:44.840 - 01:59:47.430, Speaker F: So it's like you're providing something similar.
01:59:47.500 - 01:59:49.494, Speaker D: To the graph is doing as well, right?
01:59:49.532 - 01:59:49.878, Speaker B: Yeah.
01:59:49.964 - 01:59:50.262, Speaker D: Okay.
01:59:50.316 - 01:59:51.080, Speaker F: Thank you.
01:59:53.850 - 01:59:54.870, Speaker B: Gracias.
02:02:11.270 - 02:02:49.066, Speaker A: It's very nice to be here as always. ETH Global did an amazing job with this venue and things, so props to them. But yeah, we will be talking through Superfluid today. So, my name is Sam. I help lead developer experience at Superfluid and I'm going to show you how a Superfluid works and how you can use it to build money streaming applications. So what is superfluid? Well, Superfluid is a protocol which enables something we like to call real time finance. So real time finance enables you to, amongst other things, stream money with no capital lockups in a way that's 100% programmable and on chain.
02:02:49.066 - 02:03:54.420, Speaker A: So what does this mean? Well, money streaming is this idea of taking any recurring transaction and instead of setting it in discrete lump sum intervals, I can define what's called a flow rate and send you a certain amount of tokens per second, and that money just trickles into your account in real time, right? So it's a really cool opportunity to bring recurring payments into Web Three Natively. And what it does is it creates this really cool link between the value you provide and the value you get in return for that, right? So if I'm an employee and I go into my job and I clock in at work, in a lot of cases what I'm doing is I am working and then I'm waiting two weeks to a month to actually get my paycheck. What if I could clock in? And every single second that I'm providing value, I got value in exchange via something like a money stream, right? And what this kind of thing does is it enables you to send money with no delays. There's no unpayment risk. For every second you work, you get paid. And there's also no intermediaries because it's all done on chain. And we live in a world with at least less intermediaries here in Web Three.
02:03:54.420 - 02:04:48.206, Speaker A: So the protocol is not a layer one, it's not anything like that. It's not a roll up. This is a smart contract framework that is made for the EVM, although eventually it will be probably chain agnostic and environment agnostic. And what it does is it allows you to create these open ended agreements between two accounts. So what you do when you create a money stream is you engage in a kind of agreement, right? So I can opt to send you one token per second. And as soon as I've done that, I've sent an on chain transaction which says that now my balance is going to be decremented by one token per second and yours is going to go up by one token per second. Right? So this is really cool for a lot of reasons, but what's really interesting about it is that these tokens that enable this can have really interesting ways that their balances can be changed in accordance with those agreements, right? So in order to actually make this happen, right, this is pretty innovative.
02:04:48.206 - 02:05:05.958, Speaker A: Like, in order for you to actually send money on a per second basis, normally a lot of you are probably thinking, all right, am I going to have to call it something calling transfer every single second to make this happen? And that's not the case, right? We built this additional token type which is plugged directly into the superfluid protocol and is compatible with many of the other features you used to with tokens.
02:05:05.974 - 02:05:06.154, Speaker D: Right?
02:05:06.192 - 02:05:59.978, Speaker A: So we inherit all of the standard ERC, 20 methods and you can use them anywhere in Web Three, right? So we have two types. One type of super token is one that's just deployed out of the box as a super token. This is one that maybe you deploy it tomorrow and, you know, sorry, a super token exists, so you don't want to deploy a wrapper around an existing token, we also have wrappers, right? Because we know that composability is so important. So you can wrap Die, you can wrap ETH, you can wrap USDC as a super token and be able to use it anywhere else in Web three. So these agreements that I mentioned, right, these are these connections between two accounts. And what they do is they allow you to calculate something called a real time balance on that super token. So on the super token itself, what you can get is based on how many money streams you have outgoing at this given point in time, we can calculate what your net flow rate is.
02:05:59.978 - 02:06:45.686, Speaker A: So I use the example earlier where I am sending out one token per second and someone else in the audience is receiving one token per second. We can calculate your net flow as whatever that is when you combine all the different money streams you're sending receiving at once. So if we have that, we also have the block timestamp value, which is changing for us every single new block. So what we can do is anytime you want to create a new money stream or do something else with your super tokens, we just calculate, all right, how many tokens you have in this moment before we perform that next state changing operation and everything shakes out properly, given the accounting that happens on the token. If you have any questions about how that works, specifically, I'll be standing right over there. After the talk, we can get into the details. But the thing you need to understand is we're doing this by hacking the block timestamp value to move money effectively for us.
02:06:45.708 - 02:06:46.038, Speaker C: Right?
02:06:46.124 - 02:07:43.226, Speaker A: It's pretty cool. The other cool thing about this is that because it's a smart contract framework, there are a lot of things we've built into it to make it programmable. So you can provide like an access control layer so that there's something that's very similar to ERC 20 approved methods, so I can grant you the ability to open streams on my behalf. And we also have these things called super apps, which you see here down in the middle that are these cash flow where smart contracts that can react to specific events. So if I send a stream into a contract, it can react and then do something for me, right? One example we'll go through later on, we'll actually get into some code will be one that can take in a stream, and the second that it starts receiving those tokens, can redirect those tokens to whoever the owner of that contract is. So these superfluid apps are, again, very important in terms of painting the picture of the potential of what superfluid can offer. You can put anything you want inside those callbacks, not just like, open a stream for me, you can do anything else.
02:07:43.226 - 02:08:48.270, Speaker A: And what this does is it allows you to chain all of these different operations together and form a crazy network of cash flows. So this is Superfluid right now as it's deployed on Polygon with each individual node representing an account and all the connections between nodes representing cash flows. So all of the teams that are building products on top of Superfluid are participating in this giant network of cash flows. I'm actually impressed that it rendered properly because this is a lot of information, but it's really cool. And what you can do if you build on Superfluid this weekend is build an application that plugs into this giant network of cash flows, right? So you can grow this network and you can also tap into it right in terms of your user base. So with that being said, let's talk through prizes at ETH, Mexico, and then we'll get into some actual tactical building stuff, right? So again, if you want to go take advantage of the network I just showed you, there are some opportunities here. We have ten K worth of prizes in USD, one for the best overall project, one around DFI, and then some other general prizes here as well.
02:08:48.270 - 02:09:21.354, Speaker A: If you have any questions on them, please feel free to come up booth and we can clarify them for you. And yeah, so in terms of building on us, there's a couple of things you want to know about. One of those things will be our developer console. We'll use this in a little bit to just see the effect of creating money streams and deploying cash flow where smart contracts. We also have a dashboard that's really cool. If you come up to our booth, you'll see we have this huge TV monitor that will show balance taking up in real time. So if you want to see how that works and even get a stream yourself, you can come up to our booth and we can show you.
02:09:21.354 - 02:10:07.740, Speaker A: And then we also have an SDK that I'll make use of here in a demo in just a second. But this is really useful because it allows you to interact with the protocol without using any solidity at all, right? As long as you know TypeScript or JavaScript. And most of you devs here, you probably heavily dabbled in it. If you're here, you can open streams just a few lines of code using that SDK. So let's build. What I'll do here is I'll share my screen in just a second, but I want to give an overview of one of the applications I want to walk through briefly to give you an idea of how simple this can be to create smart contracts that interact with our protocol. So we're going to create this thing called a money router, right? So it's going to allow you to manually send a money stream into a contract and then manually call a function on the contract to send a stream out of that contract to an address you choose.
02:10:07.740 - 02:10:33.058, Speaker A: It's going to look a little bit like this. One of those super apps I showed you earlier, which can take streams and automatically send them out. It's just going to be a little bit less fun because it's not going to be automatic. I'll show you in a little bit an example of a contract that can automatically, the second it takes in a money stream, send it out. But we'll get into some of the more advanced class stuff in just a second. So you can find all of these examples if you want. Inside of our repository here.
02:10:33.058 - 02:11:03.500, Speaker A: Make sure you guys can see this, but inside of our repo, we have a super examples folder. And what you can do is you can actually just plug in and fork some of these things this weekend if you want to build a superfluid related project. All of these, we try to make them so that they have really, really good documentation, good comments. If you have any questions about them, we'll be here. But the example we'll be using first is just this money streaming intro example. So you're welcome to come back here. You can fork this repo if you want and follow along if you'd like or just try it later.
02:11:03.500 - 02:11:43.650, Speaker A: But if I pull it up here, I'll go to the contract itself and make sure you guys can see it. Zoom in just a little bit. Zoom in just a little bit more. We have some boilerplate here up top where I'm importing a bunch of contracts. And what I'm doing is I'm using this library called the CFA V One Library to allow me to open a stream and solidity in one to three lines of code a piece, right? So it's fairly simple. So once I have this all set up in the constructor, I have some state variables that I declare up here. But in the constructor, what I'm doing is I just deploy or I guess I instantiate this library here, and from there we can actually get into this contract and use it to start opening up streams.
02:11:43.650 - 02:12:17.902, Speaker A: So there are a few key functions we'll use. There's some access control stuff here up top that I won't really go into today. But the key functions that matter here are, one, sending a lump sum into a contract. You might want to just send like a lump amount of a token into the contract. So we have a function that's going to let you do that. On the contract itself, we have a function that's going to let you create a flow into the contract, and then we have another function that's going to update that flow into the contract or delete that flow into the contract. And now that we have streams going into the contract, we need to also send streams from the contract, right? So I have the same exact three functions, but coming from the contract.
02:12:17.902 - 02:13:19.026, Speaker A: So what I'll do is I'll fill in some of these functions just to give you an idea of the simplicity here inside the let's go to the create flow into contract example. Inside this, all I have to do is call CFAV One, create flowBy operator and pass in the sender the receiver, the token, meaning the super token I want to use and the flow rate, right? So, very simple. Literally one line of code and I can create a stream into the contract. In terms of creating a stream out of the contract, it looks almost exactly the same, but there's no by operator thing here, right? And the reason why we have to use this by operator bit in the create flow into contract function is that once I create a stream into the contract if I were to pass in the message sender being like the contract itself. That's not going to work. Because even though I'm calling this contract, I'm calling this function on the contract, the actual message sender on that function call is going to be the contract itself. This is just tracing the value of message sender within your individual calls.
02:13:19.026 - 02:14:14.958, Speaker A: But here what we can do before we actually make this call is use our ACL features, which allow us to provide access to a different account to open a stream on my behalf. So this is just like an ERC 20 approve where I can allow somebody else to create a stream for me, right? It's fairly simple and we'll go through a script that shows you how to do that as well. Okay, so we have that function. I'm just going to copy this over to the update example and it'll be almost the same exact thing, except I'm just going to change it from create to update. So it's pretty simple there and I will do the same thing for this example, right? So instead of just create, I'm going to change this to update. And it's pretty simple. I just have to make sure that the flow actually exists, right? If I try to update a flow that doesn't exist, that'd be kind of nonsensical and it's going to revert.
02:14:14.958 - 02:14:46.030, Speaker A: But if I update the flow with a new flow rate itself, it'll work. Okay? So I'm going to leave it there for now. There's going to be some functions here we're not going to implement just for the sake of time. I don't want to be too redundant for you guys, but what I'll do is I'll just deploy this contract using our little deploy script here. We'll do this live, which is always fun because it means I might have to debug live, but hopefully not. This is deploying. And while this deploys, I want to show you a couple of other useful tools, right? So I mentioned this thing called the superfluid console.
02:14:46.030 - 02:15:14.522, Speaker A: This allows you to just search an address and see everything that's going on with that address. So if I copy and paste in an address that I'm going to use quite often here, which is just this one it'll pop up on every network it's being used on, and I can track everything that's happening with it, right? So I can see all of the dai that's flowing on testnet. This is all fake money, guys. Don't worry. This is fake, but you can see all the money streams that I've created. You can see the tokens that I hold. It's a really useful tool.
02:15:14.522 - 02:15:32.420, Speaker A: So if you're building something on Superflu this weekend, I highly recommend you check it out. We also have dark mode. We know everybody likes dark mode, so that's another plus. But if I go back into Vs code here looks like we had a little compilation fail bit here. See, I told you. We got a debug live. This is what we love.
02:15:32.420 - 02:15:49.702, Speaker A: Let's go back in here. Yeah, I think I just forgot to save let's redo that. So as soon as this deploys, we'll be able to create a stream into this contract itself. Same thing here. Let's figure this one out. New flow rate. There we go.
02:15:49.702 - 02:16:09.440, Speaker A: See, we make mistakes too, guys. All right, so I have this. This is deploying for us. All right. We have another one, which is always also fun. Looks like I did the same thing here. Just for the other example.
02:16:09.440 - 02:16:36.840, Speaker A: All right, same thing. Just pass in new flow rate. And we're running a little bit ahead of schedule on time, so we should be okay. There we go. All right, so this is compiled, and then the second this deploys, what we'll be able to do is send funds into the contract itself and then open a stream from that contract to a different address. Okay. This is just loading for me.
02:16:36.840 - 02:16:57.130, Speaker A: All right. Got to love Alchemy with the RPC. All right. I do have a backup example here, which is something I'm glad I prepped. But the goal here will be as soon as this is deployed. All right. It looks like it did just deploy.
02:16:57.130 - 02:17:36.854, Speaker A: As soon as this is deployed, we'll be able to create a flow into this contract and then ultimately create a flow out of the contract, right? So first, I'm going to approve a token send into the contract. Okay. So we'll go here into this token approval function. I'll send this transaction here. So instead of deploy, I'm just going to approve this token approval just like that. So I've just passed in this address of the contract. And then here what I'm doing for the approval is I'm just calling approve on the DIAX contract.
02:17:36.854 - 02:18:05.540, Speaker A: So this is just going to approve this DIAX token, right? Which is successful. This is going to give the approval on the DIAX Token such that I can then send money using this function call here. So do the same thing where I'm just going to pass in the contract address to this one. So we'll send a lump sum into the contract. All right. And then I can run this script here. Okay.
02:18:05.540 - 02:18:35.390, Speaker A: Paste that. So now we're going to send some money into the contract and in just a second, we'll be able to see this money also inside of the console. So as soon as it receives funds, I'll be able to search it just like I was able to search this address. And we'll be able to see that this now has some super fake Dai tokens. Okay? So let's make sure that approved. All right, we just successfully sent funds to the money router contract and that's not what we want to do. We want to paste in the address of this contract.
02:18:35.390 - 02:19:21.100, Speaker A: Okay? So I'll paste this in, cut this off, and in just a second, this should show up for me. But now that we've done that, what we can do is now create our stream into the contract as soon as we use this ACL approval bit. So remember, this ACL feature allows me to approve someone else to open a stream on my behalf, okay? So in this case, I'm just going to approve the money router contract itself to open a stream on my behalf. Okay? So we're going to create a flow into the contract using this script. I'll paste it in just right here as the address. And then what we do is we use the superfluid SDK. I guess we got to go into the ACL feature first.
02:19:21.100 - 02:20:02.806, Speaker A: So what we'll do is we'll use the superfluid SDK to approve the money router contract to spend some tokens for us, right? So this is just called update flow operator permissions. We pass in the address of the money router, we specify the super token we want to use, and then we give it a flow rate allowance, right? So this is just the amount of tokens we can create in terms of flows sending out per month. So this is what this amount correlates to. This looks like a very big number when in reality it's just the number of way we're going to send per second. Okay? And this permissions value will just grant all permissions. There's like a bit map value here you can look up in our docs. If you give it a one, it's just going to give you the create permissions.
02:20:02.806 - 02:20:45.766, Speaker A: In the case of a seven, you get all the permissions, right? So you can do anything you want. All right, so let's load this again so it can show up when we're back here. But let's call this ACL feature, grant that access and then create the stream from the contract or into the contract from us. Okay? So let's call this function here using this script. All right? So we'll run this ACL approval. This is just going to offer our approval. And then the second we're done with this, we're just going to call the create flow into contract function on the contract itself.
02:20:45.766 - 02:21:21.260, Speaker A: And then because the only two values it takes if I search create flow into contract, it's just. Going to take a token and a flow rate and then it's going to handle the rest for me. In here, I can just pass the token. I want to use the flow rate and I'm good to go. I'll be streaming money. All right, so this is all set up properly and then I'll run this one. So the second this loads, we'll be able to see money being sent in real time into the contract.
02:21:21.260 - 02:21:50.360, Speaker A: All right, so this is the contract itself. See, there we go. It's popped up on Guerreli. We can see it has a balance of 500 tokens, right? So we've been able to send that lump sum amount. So it's sitting on 500 tokens. And then the moment this one actually finishes, we'll be able to see that money being sent in real time. Okay, just a second here.
02:21:50.360 - 02:22:35.690, Speaker A: Some other features here that might be relevant in terms of checking out like protocol level stuff are the subgraph, right? So what you can do is write custom subgraph queries in line, which is pretty awesome. We use this quite often for just like, looking up internal data ourselves and playing around with the subgraph. People ask us how they can get specific types of data within their applications. And usually the best place to go for this is this subgraph Explorer console, right? You can just use this to pretty easily just sleuth different data you want to get, look up specific things. You can use events. So I highly recommend using this as a place to get data within your applications. All right, so it looks like this transaction is hanging for me, which is no fun.
02:22:35.690 - 02:23:22.410, Speaker A: But in the end, the goal of what we're trying to do here and this is what will happen as soon as we have this propagate, is to get something that looks a lot like this, right? So this is an example I prepped beforehand just in case we had transactions not processed fast enough for us on stage. And what we can see here is we originally had a balance of 500, but then we sent streams from the contract or sent streams into the contract. I'm sorry. And when we did that, we created a flow that is going to send the equivalent of 33 tokens per day, or about 1000 tokens per month. And we have about six tokens that have been streamed from the time that I open this to right now. So money is flowing real time in this example. And this is the end result of what this function will do as soon as it actually goes through.
02:23:22.410 - 02:24:19.476, Speaker A: Okay, so that's the manual example that's manually sending a stream into the contract. And if we wanted to, we could just call the Create flow from contract function to send streams from the contract in a manual way, right? This is something you guys can all do very easily, but what we also want to show you how to do is create these programmable applications where you can do things automatically. Let's say that I want to send a stream into a contract and have it automatically, the second it gets funds, send a stream out of the contract. And where this becomes really interesting, I'll go back to my slides here is in the case of like tokenized cash flows or revenue based financing. So there's a contract that we use for the base of a lot of our examples called the Tradable Cash Flow that can receive streams and send them out. But the other cool thing is that it's also an NFT. So you can imagine, let's say I'm a business, let's say I'm a subscription based business and I have one of you in the audience paying me for a SaaS subscription.
02:24:19.476 - 02:24:59.136, Speaker A: What happens in the Web Two world is a lot of people that run SaaS businesses will raise new rounds of financing all based on existing revenue, right? It's just revenue based financing. Instead of having to dilute themselves and sell a portion of their company to raise more money, what they'll do is they'll say, okay, financial markets, I'm having somebody pay me $1,000 a month for my SaaS subscription. Instead of me taking this money and waiting to get an additional $1,000 every single month, why don't you pay me $11,000 now and I'll redirect the entire subscription value to you. So you make $12,000 throughout the year and gain a $1,000 profit.
02:24:59.168 - 02:24:59.316, Speaker D: Right?
02:24:59.338 - 02:25:47.110, Speaker A: That's a simplified example. There's obviously going to be other things that underwrite that transaction. But what if we could bring that exact same model into Web Three? And that's what the tradable cash flow does. It lets us tokenize these cash flows and plugs them directly into DFI. So again, sending streams into the contract, the streams are automatically routed to the owner of the contract and each time the contract is traded, all of those cash flows go to the new owner, right? So you guys could do really creative things with this where maybe you split a small portion off as a fee to somebody else or add additional crazy features into it as well. But I'll show you how we actually can build this in just a few minutes. So again, back in this Super Examples folder, if you go to the Tradable Cash Flow example, you can fork this yourself and start playing around.
02:25:47.110 - 02:26:26.672, Speaker A: But this one is pretty simple to set up. And I won't go as in detail as I did with the last contract because transactions seem to be taking a little while to actually go through. But what I'll do is I'll walk you through the key functions on it so you guys can go in and take a look yourself. So if we go to the Tradable Cash Flow contract here, we can see that it's really simple. All it's doing is it's deploying an NFT. So this contract is inheriting from an NFT contract and it's inheriting from this Redirect All contract too, which this Redirect All contract has all the cool functionality in it. And I'll go through that in just a second.
02:26:26.672 - 02:27:20.752, Speaker A: But it deploys an NFT here with a name and a symbol and mints one of them to the owner of this contract, right? That's it really simple. The NFT stuff is all the stuff you guys are used to, but the new stuff is all in this Redirect All contract. So the only interesting thing we have here on the NFT contract is we use this before token transfer hook. This is a hook you can use that you can actually see in the open Zeppelin interface for the ERC 721 standard. But you guys can just call this change receiver function inside of the before token transfer bit to make sure that before the token itself is actually transferred, if it's ever sent, that all the streams are deleted to the existing owner and sent to the new owner. So if we go into the Redirect All contract, which is again where all the cool logic takes place, we're doing all this superfluid stuff here. Up top, we're importing all this boilerplate.
02:27:20.752 - 02:27:55.560, Speaker A: We've got some events we declare you guys can use. We're using the CFA library to make it really simple to open streams. We add some stuff in the constructor. We also initialize the library here, just like I showed in the last example. But then what we do is we do something called registering the app with the superfluid protocol. So what this register app bit does is it will allow the superfluid host contract, which is like the brain of the superfluid protocol, to call these specific functions each time one of these operations takes place. So all you have to do is deploy this contract and send a stream into it.
02:27:55.560 - 02:28:43.836, Speaker A: And one of these functions, one of these callbacks will run for you instantly. So it's called the after. In the case of a stream being created into the contract, it's called the after agreement created contract function. And this logic inside of here will run automatically for you, right? So it's being called by the superfluid protocol, and inside of this, you can do whatever you want. So in the case of the update outflow function, let's go to it here. What we're doing. The simplified way to explain what's happening here is we're just checking the current state of the contract itself, right? If no stream yet exists into the contract, what we're going to do is look at how much money is coming into the contract, and then we're going to create a stream of equal amount to the owner that happens down here.
02:28:43.836 - 02:29:26.012, Speaker A: In this create flow example, if there's a stream already existing into the contract and the stream was updated, what we can do is just make sure that it's updated so that it mirrors the amount coming in. And we need to make sure that amount equals the amount going out. And in the case of a deletion, all we need to do is delete all the streams going out of the contract, right? So pretty simple, right? Simple like if then statements to get this really cool functionality. And then in the case of the changing of receiver, again, this is just going to be called each time that the token itself is actually transferred. What we do is we check who is the current receiver. All right? That receiver should no longer be receiving these streams. So we delete them right here.
02:29:26.012 - 02:30:02.020, Speaker A: And then we need to create streams to the new receiver so we can see who the new receiver is and we can create a stream to them equal to the exact same amount that was being sent to the old owner, right? So it just matches up. And again, this is all here. You guys can fork this use in your own applications, make it better. I'm sure there's gas golfing opportunities in here. If you're so inclined, feel free to go crazy. But that's the idea there, right? So in the case of this contract, it's going to receive tokens and send them out automatically so that the balance of the contract is always zero. But the owner has this asset that is now a tokenized cash flow.
02:30:02.020 - 02:30:46.356, Speaker A: So again, highly recommend you check that out. But to wrap up here today, there's a couple other things I want to mention, right? The first of them is this thing called Superfluid Reactor. So there are quite a few teams, including some of the logos I've shown here, that have built pretty good traction or raised money building a project on top of Superfluid, right? And the Superfluid Reactor program, who is also kind of spearheaded by Yao here in the back, she'll have a soleil tag. You'll see her as soleil in Discord. She's helped lead this. But what we've done with the reactor is formalized some of the help we provided to projects like yours that might build this weekend. And if you guys want to raise money, we'll provide coaching on how to raise money.
02:30:46.356 - 02:31:18.420, Speaker A: If you guys want help shaping your idea, we do that as well. If you guys want technical review, technical help, we can do that too. So again, it's something I just want to plug briefly because we do really value our developer community and our ecosystem. And I think that you should know that if you are considering building on Superfluid, you have resources. The final thing I'll leave you with is something kind of fun that I'll plug really briefly. It's a podcast we just launched yesterday called Devs Do Something. So our first episode was with Rahul Sitharam from Connect, the CTO of Kinext.
02:31:18.420 - 02:31:54.764, Speaker A: And the methodology behind this was again, we really value developers. We looked around at all the podcasts out there and there aren't that many really highly technical web, three podcasts. There's a lot of really great content out there, but we want to go super deep. So with Rahul, for example, we went deep into how they do design and actually launch new features. At Connect, we went behind the scenes on how they approach security and testing. We walked through, literally their GitHub actions and stuff. So if you're interested in some tech Alpha, I highly recommend you check out the Devs Do Something podcast and give it a listen, and also recommend people you'd like to have on it.
02:31:54.764 - 02:32:08.010, Speaker A: So that's it for me today. Sorry, we had some of those transactions not work live on stage, but I hope you guys consider doing something with Superfluid. And if you have any questions, please feel free to find me in the hallway over there. Thank you.
