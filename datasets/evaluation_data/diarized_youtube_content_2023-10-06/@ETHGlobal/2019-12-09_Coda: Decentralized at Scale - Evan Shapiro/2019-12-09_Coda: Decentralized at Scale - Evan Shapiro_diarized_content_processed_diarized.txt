00:00:02.490 - 00:00:04.590, Speaker A: Okay, cool. Right?
00:00:04.660 - 00:00:22.778, Speaker B: So yeah. So I'll be presenting on coda today. I know that two of you know about Coda. Do you guys have you heard of Coda put before? No? Okay. Someone told you about it once. Okay, so I'll tell you more about it. So Coda is a new cryptocurrency, a new layer one protocol.
00:00:22.778 - 00:00:51.946, Speaker B: And what it does that's special is it swaps out the usual blockchain that gets bigger and bigger for like, a zero knowledge proof. It puts the whole state transition function of the protocol in a zero knowledge proof. So I'll tell you about that today. And also we will be running a node and doing some live coding with it. So let's get started. So first thing I want to do is I want to spin up a node. And this is something that if we were to do it on a regular cryptocurrency, you know, would take a very long time.
00:00:51.946 - 00:01:17.138, Speaker B: But because Koda can really quickly sync with the zero knowledge proof, it'll happen pretty quickly. If the live demo gods or whatever are on our sides, we'll be able to live code against it. So I just have to pull in the command to run. I've already app get installed the node. We just switched to lib P to P, which is why there's these fantastic long strings. Actually, let's start a screen up and then I can do things with that. So let's start that up that's running.
00:01:17.138 - 00:01:31.894, Speaker B: And then over here, let's start up a thing that will listen to the node once the node is running. So, yeah, when the node starts up, we'll be able to see on the side here all of the status of the node. Let me zoom in a little bit for you also.
00:01:32.012 - 00:01:32.886, Speaker A: Okay, there we go.
00:01:32.908 - 00:01:39.878, Speaker B: Okay, so right now the node is connecting to the network, and very soon it will have been connected and we'll be able to start working with it. But in the meantime, let me tell.
00:01:39.884 - 00:01:41.310, Speaker A: You little bit more about Coda.
00:01:42.370 - 00:02:09.334, Speaker B: So maybe I should have said earlier on. I'm Evan. I'm one of the co founders of O, of One Labs building Coda, doing it for around two years now. So I'm excited. We're actually able to have something running now, and it's very exciting. So it's a new layer one protocol, and we're replacing the blockchain, like I said, with a recursively updating, a zero knowledge proof. So everyone can download the blockchain with this for maximal full node security, even on a phone or a browser really quickly with just a kilobyte of data.
00:02:09.334 - 00:02:38.880, Speaker B: And the snark is actually just a constant 1. This is independent of throughput, so that's great. It also has pretty easy to develop things with it because the node is so small. You can actually just import a library that pulls in a full full node. You don't have to worry about infura or MetaMask or any of that stuff. You can just pull in a library that does all the work for you. You can also build things with privacy because of Zknarks, we have really good native support for those and at some point you'll be able to build cool things with them.
00:02:38.880 - 00:03:09.126, Speaker B: So to talk a little bit about why you might care about blockchain size, we have to talk about blockchain decentralization. So we would like it to be that in the optimal case that everyone has equal access to cryptocurrency. Everyone can download a full node, they have equal trustless access to the network. And this is true when a blockchain is new and small, but blockchains grow really quickly, oversized, they get really, really huge. And when that happens, individuals can't really download blockchains easily anymore. They're just like too big. It's like 500GB a terabyte or whatever.
00:03:09.126 - 00:03:41.038, Speaker B: It's just not going to happen. And this centralizes control in the hands of the shrinking set of entities that can afford to run nodes. And this is bad for both individuals and for cryptocurrency in general. You can imagine that even the players that would probably end up running the infrastructure to control these nodes, they don't want the regulatory burden of having to deal with this. They would rather it was really properly decentralized. So it's really important we get to a state where everyone can just use cryptocurrency as an individual. And you can see this actually impacting Bitcoin and Ethereum a lot.
00:03:41.038 - 00:04:03.686, Speaker B: For Bitcoin, you can see the node count has stayed basically constant since like mid 2017. And you would have expected this to grow. We want this chart to go up and to the right, of course, but that's not the case. And for Ethereum, it's even worse. Like, it's actually been going down a lot since mid 2017. Ethereum has actually gotten a lot harder to run than Bitcoin. And now it's at the point where it takes weeks at least to sync an Ethereum node.
00:04:03.686 - 00:04:28.866, Speaker B: It's not a great state to be if we want people to actually be using this stuff in a trustless way. So why is this the case? Well, we already kind of hinted at it's because this blockchain has a bunch of transactions in it. You have to download all those transactions. That kind of sucks. It means that as time goes on, more users and devices just get excluded. The last time you could actually download a Bitcoin node to your phone was in 2014. Not that anyone was going to do that back then.
00:04:28.866 - 00:04:50.166, Speaker B: It still would suck. Like it sucks today. But at least back then it was kind of possible and now it's just simply not possible. And that's just Bitcoin, Ethereum and others are at least as bad, if significantly worse. So we already talked about what this problem is. So the question now is we have this transaction thing with the blockchain. We have this decentralization thing that we care a lot about.
00:04:50.166 - 00:05:25.330, Speaker B: How can we decouple them so we can still put all these transactions on the chain, but it doesn't challenge decentralization. How can we do this? And you know from the beginning that something about Snarks is the answer. Let me tell you a little bit about Snarks so that I can properly explain how that connects back here. So what is a snark? It's a succinct, non interactive argument of knowledge. So really what it is, is a small succinct proof for statements of the form there exists. And moreover, I know some data, such as some property on the data holds. This is a very general statement and we'll see later how it actually connects back to Coda.
00:05:25.330 - 00:06:07.326, Speaker B: What you should know about Snarks is they've only really recently reached practical performance. They've existed theoretically for a very long time now, but now they're actually practical and we've been writing some tools to make them even more practical. So that you can write Snark code like a regular program, so you can write large programs and you can actually check and know they're going to work. And we have a library for that Snarky, that's all open source, check it out. You can write Snark programs just like writing functions. How does this apply? So we have these Snarks and what we do is instead of a big blockchain that you have to download, we have the network recursively update a recursive, zero knowledge proof of the blockchain. And so that's a 1 KB proof.
00:06:07.326 - 00:06:43.862, Speaker B: That's really fast to share and check. And really when you have the Snark, it's an equivalent computation to downloading and checking the whole blockchain. It's the same computation just now. Instead of doing it all yourself, you can look at the Snark and know that if you had done it, you'll get the same result, which is great. And connecting that back to that statement before you can imagine that the data now is the whole blockchain and the statement we want to the property one will have to hold on it is that the predecessor is valid or it's the genesis. This is where the recursion comes in. It's basically saying that if you were to look at all the history back to the genesis block, it's all valid and if you had downloaded the blockchain it would be all valid.
00:06:43.862 - 00:07:17.000, Speaker B: So you don't have to actually do that now. You can just look at the ZK scenario, which is great. The recursion also means it's really efficient to update the new proof can be like recursively built off of the predecessor. So you can take the predecessor chain that has a proof already for it and the transition function and the new proof and you can say that the new proof is the existing proof of the predecessor being correct, since the genesis and the state transition function being valid to the new state. So because of that you have to do one step every time you add a block. It's very efficient to do that or at least efficient enough. We can do so with Snarks, which is great.
00:07:17.000 - 00:07:54.318, Speaker B: So great. So we're in this world now where you can get the ZK Snark with the protocol state trustlessly in about a kilobyte and you can get the account states and their merkel paths with an additional about 3 account. Which means that if you want to use Coda you need about a kilobyte for the protocol state and 3 account you need, you can get a bunch of accounts that's still extremely cheap and bandwidth efficient. So you can get access from phones and browsers trustlessly no inferior MetaMask. This also means that everyone can have easy equal access and this is true even at scale. So because it's always 1 KB, you can increase the throughput a lot. They just kind of fold into the little ZK smart.
00:07:54.318 - 00:07:58.310, Speaker B: So you can have high throughput and you can have easy accessibility.
00:07:59.450 - 00:08:00.200, Speaker A: Right?
00:08:00.890 - 00:08:47.486, Speaker B: So what does this mean for developer experience? Well, it means that now you can import a full node directly into your program, including on websites without a third party or a browser extension. In the middle, the library can connect directly to a gossamet over something like WebRTC and then the program is really connecting to the device from the user's device itself. It's not like going through any middleman, which is awesome. It's also cool because you can actually leverage Snarks with this thing. So you can build privacy using leveraging applications that actually connect back to real users, which is cool. So today's testnet we have is like a working succinct blockchain. We have like a GraphQL API with this and you can easily install it with Brew on macOS and on Linux with AppGet.
00:08:47.486 - 00:08:58.898, Speaker B: Really easy to get started. And we have a community I'll be talking about later that's using this stuff. And so yeah, let's talk now about the network. And I'm going to live code something using the GraphQL API.
00:08:59.074 - 00:09:00.214, Speaker A: So let's see.
00:09:00.252 - 00:09:25.022, Speaker B: So we are in a state called catch up right now. So we were in bootstrap before, now we're in catch up and soon we'll be synced. Hopefully catch up is when if you have a node right now, you still have to download the full current state of the ledger. So you don't need any of the history that's accounted for by the Snark. But to do consensus you still need to have the full current ledger. That's what's happening right now is it is downloading that. So that will be done soon.
00:09:25.022 - 00:10:03.710, Speaker B: So I'm pretty sure we can just get started coding stuff and we will be good for that to be ready by the time we actually want to run something. Let me just pull something up here so that I know what I am doing and let's get started writing some code. So I have another terminal over here where I'm going to make a new file called Getbalance JS. And over here we'll check back in this in a second. You can see like I have these tabs out at the bottom. We're going to make a new tab. And what I'm going to do is I am going to run node over here so we can run node on this side and we can write our code on this side and hopefully it all works.
00:10:03.710 - 00:10:34.470, Speaker B: So let's console log something just to make sure that everything is kind of sane. It is great. Okay, let's get started. So like I mentioned, we're going to use GraphQL to talk to a coder node. And what we're going to do is we're going to get the most recent block. And then what we're going to do is get the balance of whoever created that. So what's cool about GraphQL is it gives you a lot more structure to work with than just like a basic rest API.
00:10:34.470 - 00:11:16.018, Speaker B: And to show you just a little bit of that online before we just jump into the code, you can see some of those features working. If I go to developers here and click GraphQL API, you can see some schema docs that shows all the different data structures because in GraphQL you're downloading actual data structures that are structured instead of just like random strings. And the first thing we do is get a block. We'll get the most recent block. And I also want to show you this is not public yet, but we have also a really cool test suite for playing with GraphQL that just comes out of the box with GraphQL and you can just kind of click. Oh yeah, I kind of want the first block and then I want to see the state hash of that block or something. And you can see what the query would look like.
00:11:16.018 - 00:11:31.580, Speaker B: And you can also over here see what it would look like. To actually put that into code. We're going to be using React Apollo. It's basically going to look like this, which is pretty cool. I realize this is way too small. I'm going to make this bigger. But you can see basically this is a cool tool for playing with queries and building things.
00:11:31.580 - 00:11:37.066, Speaker B: Let's go back here. Let me see how big I have to make this for it to make sense. Maybe that works.
00:11:37.088 - 00:11:40.378, Speaker A: Is this good for people? Okay, great.
00:11:40.544 - 00:12:15.830, Speaker B: So let's begin. So the first thing I have to do is we're using a node program. So I have to import a whole bunch of things. So GQL equals require GraphQL tag. This is going to be a way of writing GraphQL queries really succinctly in a really clean way. We're going to use something called Apollo, which is a library for building with GraphQL apollo boost Apollo client. And then we also are going to need this fetch thing which is just going to let our Apollo client know how to talk to the server because the server is going to work over HTP.
00:12:15.830 - 00:12:23.254, Speaker B: And then we need to I have another thing so we can actually tell Apollo where to look for this http.
00:12:23.302 - 00:12:23.900, Speaker A: Link.
00:12:25.710 - 00:12:51.058, Speaker B: Http create HTP link and then we also need an in memory cache so that Apollo has a place to cache things. Apollo demands that we provide this in memory cache. And now let's do the thing part. We check to see if I made any typos. I did not. Excellent. Or at least none that crashed anything.
00:12:51.058 - 00:13:15.078, Speaker B: So now we need the address of the Coda server. So this just lives on each end localhost on a port. By default it lives on 30 85 GraphQL. So it just lives there, which is nice. And now we can actually make our client that will be used to make the queries. So there is a little bit of setup. But after this you're in a really great world where you can just use this magic query thing that has awesome syntax.
00:13:15.078 - 00:13:58.220, Speaker B: So we need to create that HTP link we talked about a second ago and we need to tell it of those two things I mentioned earlier. The Uri, where to find the server and also the fetch command, which is how it's actually going to get from this address. And then we need that last thing I mentioned, the in memory cache. Welcome, feel free to feel free to join. We're just in the middle of live coding on Coda, like a short demo of using GraphQL with a node, right? So I was just checking to see if I had made any typos when I was writing this and of course I did. This is also like interactive sessions. So if anyone can find the bug faster than me, please point it out.
00:13:58.220 - 00:14:25.760, Speaker B: And yes, let's see. Cannot read property bind. Oh, that's a fun one. The heck is that about? Let's see, I was missing a new that would do it. And if anyone knows, bind is how JavaScript makes the word this work. So there was clearly some this magic going on inside Apollo that didn't like that. I didn't put the word new.
00:14:26.370 - 00:14:27.986, Speaker A: Okay, so let's do it.
00:14:28.008 - 00:14:29.054, Speaker B: Let's get the most recent block.
00:14:29.102 - 00:14:29.666, Speaker A: It's time.
00:14:29.768 - 00:14:56.710, Speaker B: So first we need to run a query. And the way that this works is we get to use that query tag thing I mentioned earlier for GraphQL. So use GQL. And now that we put the backtick, we're in like this magical query land where everything is going to be really clean syntax. So we wanted a query, we want some blocks, we want the data about those blocks. In fact, we want the first block. So this is really cool in GraphQL you can just tell it I want the first of something if it's an array.
00:14:56.710 - 00:15:14.542, Speaker B: So that's really nice. And we only care about the create. Like I said, we're going to try to get the balance of created the block. There's a bunch of other fields we could access, but the only one we care about right now is the creator. We don't have to ask for more data if we don't need it, which is nice. And now this is a promise. So we need to do the promise syntax stuff.
00:15:14.542 - 00:15:27.170, Speaker B: So let's just get the results and we'll do something with that in a second. And we also need to do something if there is an error, which is catch. So if there's an error, we will console log the error.
00:15:27.990 - 00:15:28.740, Speaker A: Great.
00:15:29.990 - 00:15:36.694, Speaker B: So what do we want to do with the results? What we want to do is we're just going to print out who that creator was and then we're going to move on to the next step.
00:15:36.812 - 00:15:37.622, Speaker A: So let's do it.
00:15:37.676 - 00:15:56.910, Speaker B: Console log, block producers. I probably need to do this, don't I? Public key is a public key and let's get the public key. The public key equals res data blocks nodes of zero creator.
00:15:57.570 - 00:15:58.270, Speaker A: Cool.
00:15:58.420 - 00:16:03.310, Speaker B: So if we run this, things should work. But let's sanity check that our node actually started up before this.
00:16:03.380 - 00:16:03.822, Speaker A: It did.
00:16:03.876 - 00:16:16.258, Speaker B: Excellent. Okay, so it says synced now means everything is running and we're connected to the network again. This would take a very long time if you wanted to sync a full node on Bitcoin or Ethereum. It only took a few minutes because Coda has a zero knowledge proof, which backs up all the history.
00:16:16.424 - 00:16:20.280, Speaker C: If I want to do this on theorem, how would I do it?
00:16:20.650 - 00:16:41.020, Speaker B: You mean connect to the network as a full node? Would I ping infura, get this data? Or why is this? If you want to access Ethereum in a trustless way, then you have to download a full node to your computer, which is what Infuria is really doing behind the scenes. And this is something that's going to be a few hundred gigabytes. It's going to take like a few weeks.
00:16:41.550 - 00:16:46.682, Speaker C: And you guys have built the ability to query the Coda network with GraphQL.
00:16:46.826 - 00:17:20.482, Speaker B: Yes, but query a local node that is like a full node connected to Coda that can sync quickly because of the zero knowledge proof support. And then we're running another program that's going to talk to that local node someday when you don't have to download the full database anymore. You'll just be able to do like if we're in Python now, instead of drop import Coda or whatever, and you just be like, Coda, start. And that would do the whole full node connecting process for you. We're not quite there yet, but you can see the parts are coming together to make that happen. Yes. Okay, so we synced.
00:17:20.482 - 00:17:32.574, Speaker B: We wrote some code. Now we get to see if the code is bug free and everything actually works. So I'm going to run the program. And as expected, it did not work because it's not const. Right. It's client. We should have figured that.
00:17:32.612 - 00:17:33.758, Speaker A: Okay, great.
00:17:33.844 - 00:17:48.354, Speaker B: So now we try it and it worked. Okay, great. So we have this long public key. Awesome. So this is the public key of whoever created the most recent block. Now we can move to the next step and I can show you some more GraphQL magic when we have to actually get how much balance they have on the ledger. So, next step.
00:17:48.354 - 00:18:11.122, Speaker B: So we have this creator person and what do we want to do? We want to do a new query, right? We do a new query. We want that query to get the balance of this person's account. So how do we do this? So we have to inject somehow into our query the public key of whoever created the blocks from the creator from the last time.
00:18:11.196 - 00:18:12.138, Speaker A: So let's do it.
00:18:12.224 - 00:18:20.570, Speaker B: So there's a thing called variables and we can just create a variable. We can tell it that pub key now has the value of creator.
00:18:22.110 - 00:18:22.570, Speaker A: Okay.
00:18:22.640 - 00:18:50.950, Speaker B: And we can refer to this later. So now we do the query thing again. Again we type GQL and that gives us that magical tag syntax we saw earlier that we imported above. And then we can do a query. So what will our query be? Well, we want a wallet, and in particular we want a wallet whose public key is pubkey. So again, this is kind of a magic GraphQL thing you would imagine that usually would drop this in a different way. But there's these filters on GraphQL just like how we could do like just getting the first block like we did up there.
00:18:50.950 - 00:18:53.558, Speaker B: We can also just get just the wallet that has this public key.
00:18:53.644 - 00:18:54.486, Speaker A: So that's great.
00:18:54.588 - 00:19:12.700, Speaker B: And we just want the balance. And there's some other things around the balance we have. So we just want the total balance. Keep just simple that. So now we have another result to process and let's console log it. So lock producers balance and it's res data wallet balance, total.
00:19:13.390 - 00:19:14.140, Speaker A: Cool.
00:19:14.770 - 00:19:21.834, Speaker B: So now if we try this, we'll see what happens again. But we should see their balance. If I hadn't made a typo what's the typo?
00:19:21.882 - 00:19:23.570, Speaker A: This is the typo. Okay, great.
00:19:23.720 - 00:19:39.320, Speaker B: So now let's try it. And this should work. Did not work because something terrible happened. What happened? We did not return. We needed to return something somewhere, I think. Right, okay. Yeah.
00:19:40.490 - 00:19:41.542, Speaker A: Is that right?
00:19:41.676 - 00:20:04.542, Speaker B: Where do we console log? The block producer's balance or their public key? I realized also the order of these is just completely wrong. Okay, so what did we do? We queried for their public key. This should go up here, right? Because this is where we actually wanted to print that out.
00:20:04.676 - 00:20:05.166, Speaker A: Okay.
00:20:05.268 - 00:20:21.490, Speaker B: And then we need to return the public key so it's available in the next block. And then this should all work now. It was all wrong. Sorry if I missed what you said, but I just realized what it was and I was like, shit, the whole thing is out of order. I can just try that. We'll see if it works.
00:20:21.560 - 00:20:22.066, Speaker A: Yeah. Okay, cool.
00:20:22.088 - 00:20:22.980, Speaker B: It works now.
00:20:23.990 - 00:20:24.706, Speaker A: Yeah. So cool.
00:20:24.728 - 00:20:35.078, Speaker B: We know that their balance now is 1683. That was their public key. And you can see there's some neat stuff we can do with GraphQL. It's like a little better than just having to query a rest API or something. It makes it really easy to use.
00:20:35.244 - 00:20:36.006, Speaker A: Cool.
00:20:36.188 - 00:21:08.580, Speaker B: So what have we done so far? We wrote some code, we looked at Coda, we synchronized really quickly to the blockchain. Let me just tell you a little bit more about where we're at as a community and what we're building now and stuff. So you know what we're up to. We're a team of like 27 at Oval Labs building Coda. We have weekly competitions to stake and snark and build on the network. We've got 100 people so far that are contributing technically that are actually running nodes and stuff properly and getting points on these weekly challenges. So if you're interested, you can join on our website.
00:21:08.580 - 00:21:31.674, Speaker B: It's just like Codapprotocol.com and there's like a banner up here where you can go here. And we have like a leaderboard and there's like a really lively community on Discord and there's weekly challenges. It could be fun. So, yeah, I have a link to that on the next page, a link to our Discord. You can follow progress on Twitter website if you want to see more about GraphQL. One of our community members built a block explorer using this.
00:21:31.674 - 00:21:44.926, Speaker B: So pretty easy to build big things. You can check that out here. And we also have an Echobot we've written internally with OCaml and Reason, which is like a cool combination of GraphQL and really nice functional syntax, if you want to check that out.
00:21:44.948 - 00:21:46.750, Speaker A: Also. Yes.
00:21:46.820 - 00:21:49.210, Speaker B: So that's my talk on Coda.
00:21:49.370 - 00:21:49.806, Speaker A: That's it.
00:21:49.828 - 00:21:51.440, Speaker B: Thank you. Let me know if you have any questions.
00:21:52.370 - 00:21:59.822, Speaker C: You guys had a hackathon. What was the project? There was, I guess, a winner.
00:21:59.966 - 00:22:30.714, Speaker B: Yeah, there were a couple cool projects. As you can see, we're still pretty early in the testnet phase. So the project was like, create a cool visualization on Coda. So one group made like a peer map that showed all the peers over the world and indicated for each peer whether they were being nefarious or not on the network. So you could see, I think there was someone in Oregon or something when they did it, that was a node that was big and red on it because they were trying to do an attack. They probably just had their network misconfigured or something.
00:22:30.752 - 00:22:31.340, Speaker A: Really.
00:22:31.870 - 00:22:49.620, Speaker B: And then there was another group that started making like a staking explorer for Coda. So this would be a way of seeing as a staker, like, who is controlling the network? What would my impact be if I did this or that? Maybe moving towards a calculator for here's, kind of what my profitability is like in the network, as well as.
00:22:51.430 - 00:22:51.746, Speaker A: Just.
00:22:51.768 - 00:23:41.902, Speaker B: A general display of statically which transactions are going on in the network and stuff so early on that, but some cool initial stuff. What kind of programs do you think you will write in Snarky? I think that it'll be a combination of people writing things that are for privacy, which would be really exciting. Hopefully people building applications which can prove to the user, like guarantees about how they're interacting with the user's data. And performing computations on behalf of the user, which I think will be really exciting. For we live in a world where things are pretty adversarial right now, with tech companies trying to get whatever they can. It'd be nice if there's actually guarantees about the programs you're using. The other thing with Snarks is just kind of writing code that everyone in the network doesn't have to rerun all the time.
00:23:41.902 - 00:23:50.386, Speaker B: Once you write code with Coda, once we have that support, um, you know, it'll just kind of run once, which is cool. You won't have to everyone to rerun.
00:23:50.418 - 00:23:51.400, Speaker A: It all the time.
