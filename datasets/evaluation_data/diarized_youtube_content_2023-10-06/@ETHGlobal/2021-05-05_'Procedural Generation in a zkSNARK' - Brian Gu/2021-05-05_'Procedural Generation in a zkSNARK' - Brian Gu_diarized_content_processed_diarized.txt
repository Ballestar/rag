00:00:00.330 - 00:00:17.646, Speaker A: We are at the final stages of this summit. This is our last talk of the day and also a talk I'm super excited about. So without further ado, I'd like to welcome Brian to talk about procedural generation using Snarks, and he's going to talk about that from the context of Dark Forest. So, Brian, feel free to kick us off.
00:00:17.828 - 00:00:27.320, Speaker B: Hey, folks, I'm going to share my screen here and thanks for having me, you Global team and Karthik, it's great to be here.
00:00:27.770 - 00:00:29.480, Speaker A: We're excited to have you.
00:00:29.930 - 00:01:29.660, Speaker B: All right, sweet. So, everyone, my name is Brian. I work on Dark Forest and I also do some work on applied zero knowledge research and development with the Ethereum Foundation. Today, I'm going to be talking about procedural generation in ZK Snarks, and in particular, some of the challenges we've run into while experimenting with this technique. Cool. So to motivate everything that I'm going to be talking about in today's presentation, I want to start off with this question how could we build Minecraft on Ethereum? So I think a lot of people are very excited about the idea of decentralized worlds that are very rich and expressive and that a lot of people can participate in and build on. And one of the best examples, and most familiar examples to many people, is the game Minecraft, which is a three dimensional sandbox game with a rich and varied landscape, a ton of different items and blocks and things that you can build with.
00:01:29.660 - 00:02:26.170, Speaker B: One of the key features of Minecraft is its very rich procedural generation base. So when you spawn into a world in Minecraft, you're going to spawn into this world that has forests and oceans and deserts and all sorts of both local and global scale structures. And with Ethereum and a lot of decentralized computing platforms, we don't quite have the same amount. Like, we have very strong constraints on things like storage. How much can you actually fit into the EVM? We have constraints on things like transaction throughput. So it seems like today we're very far from being able to build out a complete and rich sandbox game like Minecraft on Ethereum. But our theory from the Dark Forest team is that using some techniques, combining them with ZK Snarks, we might be able to get closer to realizing something like this vision.
00:02:26.170 - 00:03:39.010, Speaker B: So to dig into a little bit of context for what we're talking about today, we're going to specifically be talking about some of the challenges we've encountered trying to implement Purlin Noise inside a ZK Snark. This is a technique we use in Dark Forest and it's something that we're exploring more complex variations of over the last couple of months and throughout the rest of this year. So Purlin noise is a procedural generation algorithm for generating rich and varied game world terrain. So you can think of it as a function that can map an arbitrary coordinate pair x comma y to say, like, a height on a terrain. ZK snarks allow for constant time contract side verification of the execution of Arbitrarily complex functions. So, in other words, if I have a function that would cost a lot of gas to execute in solidity, like, let's say, like, hundreds of thousands or millions of gas, if I can wrap that up inside a ZK snark then the cost that I pay for execution of this function essentially is just the verification cost which is going to be a few hundred thousand gas on chain. So putting these two things together, if you want rich procedurally generated worlds on the blockchain, one idea is to put perlin noise inside of a ZK snark.
00:03:39.010 - 00:04:47.350, Speaker B: So just a quick refresher for folks who might not be as familiar. A zksnarc is a tool that basically allows you to prove knowledge of inputs of a function that correspond to some known output. So for example, in this slide here, we have some very simple function f of x equals x one plus x two times x three minus x four. A ZK snark for this function would allow a prover to prove that, let's say I'm a prover, I will give you a claimed output to this function f of x that I claim I have the four inputs x one, x two, x three, x four for this output. And then I'm also going to send you over a proof which you can check, that will convince you that I do know four inputs, which when the function is correctly computed on those four inputs, does result in out. The zero knowledge property of ZK snarks ensures that I can actually do so without telling you anything about these four inputs. All you're convinced of is that I do have the four inputs and that I've executed them correctly.
00:04:47.350 - 00:05:50.218, Speaker B: But it turns out that for the procedural generation stuff we're interested in, this part is actually not as relevant. The important thing is that the verification of the signature takes constant time. So more specifically, what ZK snarks are doing is that they're proving constraints on what you can think of as kind of like the computation graph associated with this function. So in this previous example, we have this function f of x equals x one plus x two times x three minus x four. This can basically be thought of as if I want to perform this computation in steps, I can create an intermediate value y one that I set equal to the sum of x one plus x two and then an intermediate value y two that's the product of y one and x three. And then out is simply just going to be that second intermediate value minus x four. So what the Snark sees, what I plug into a Snark is going to be the input values x one, x two, x three, x four, those intermediate values y one and y two, and that output value out.
00:05:50.218 - 00:06:57.742, Speaker B: And what the Snark is actually doing under the hood, is it's going to generate a signature that is valid if and only if constraints corresponding to those intermediate execution steps are satisfied? So when we're thinking about doing the computation, we're thinking about sort of traversing this computation graph forwards, starting with x one, x two, x three, x four, computing the intermediate values and then eventually getting to the output. What the Snark sees is it will sort of digest all seven of these values associated with the computation and produce a valid signature. If the constraints hold that the first intermediate value is equal to the sum of x one and x two, the second intermediate value is equal to the product of the first intermediate value times x three, and the output which I'm sharing with the world is equal to the second intermediate value minus x four. So the Snark is sort of basically doing this crunching on seven inputs. So just as an example, suppose that I take inputs two, four, eight and five. The result that I'm going to get if I plug all these into the function is 43. The Snark is basically going to see these seven numbers that are produced during the course of this computation.
00:06:57.742 - 00:08:19.180, Speaker B: And what the Snark is able to do is it will generate a valid signature of the computation if three constraints on these seven numbers are satisfied. And because these constraints exactly represent what's going on with the computation in this way, the Snark is essentially proving correct execution of the function. So one thing that's important to note is that Snarks can only generate these proofs for constraints involving addition and multiplication. So in the previous example with this function, this function is very simple and only involves additions, multiplications and subtractions, which are just reverse additions. But most functions that we find in the wild and that we might care about could involve other more complex operations like division or modulo. So this means that in general, if we're writing a ZK snark to a ZK snark scheme to allow people to prove correct execution of a function, what we're going to have to do is we're going to have to figure out how to express correct execution of that function in correspondence with a set of constraints that only involve addition and multiplication. So in this example, we have a function that looks very similar to that previous function, except this second intermediate value y two is y one divided by x three.
00:08:19.180 - 00:09:47.106, Speaker B: Because division is not a valid operation that we can have inside of a constraint for a ZK Snark, what we have to do is we have to express this step of the computation as a constraint that only involves multiplication. So here previously we had the constraint y two is equal to y one times x three. In this case, this expression is satisfied when this constraint y one equals y two times x three is satisfied. So this is sort of an example of a case where the execution of a function doesn't exactly line up with a constraint system that sort of proves its correct execution. But it is hopefully pretty clear to see that a snark that is digesting these seven values and verifying these three constraints is essentially verifying correct computation of someone who's gone through with these inputs and plugged them into these two intermediate values and ended up with this output. In other words, correct execution of this function corresponds exactly to these three constraints between these seven values being satisfied. Yeah, so I'm not going to go too deeply into this, but when we start getting to more complex operations like convert some integer X into its bitstring in an array representation, we're going to have to use this trick or tricks like these even more heavily.
00:09:47.106 - 00:10:57.180, Speaker B: So rather than there's not an easy way to go from an integer to its bit string using plus and times in sort of the ordinary computational way. But what we can do is we can set up a constraint system that is satisfied if and only if what we claim as the bit string of representation of an integer X is indeed the bitstring representation. And a final piece of nuance with all of this is that in the Snark schemes that we use, so we're using Circom and Snark JS, which were developed by iden three, all of these operations are happening modulo at 254 bit prime. So you can basically think about like, there's this problem that addition and multiplication will overflow if you go past the value p that is kind of hard coded into the protocol. This often means that if we are doing operations where we're sensitive to overflow, we're going to need to add constraints that ensure that every step of the computation is not, in fact, overflowing. All right, so that's just a quick refresher on DK snarks. Now I'm going to talk a little bit about Perlin Noise.
00:10:57.180 - 00:12:06.136, Speaker B: So, as we mentioned, perlin Noise is an algorithm that allows game developers to build rich and varied terrain that looks sort of random globally but has local structure. In other words, you can see that this terrain here basically is generated by some function, let's say F, that ingests a coordinate pair x comma y and outputs a height h. And the guarantee that this function gives is that points that are close to each other are similar heights. So we're not just like this isn't just a random scattering of points, but if you zoom way out, then you get sort of these global features, but also global randomness. So to dig into a little bit at a high level how this perlinoise algorithm works. The idea is essentially, in order to generate the height map of this terrain, the first thing that the perlinoi's algorithm does is it splits the terrain into grid squares, and then it's going to randomly pick a unit vector and assign it to each grid square sorry, grid square corner. So you can see here we have this little table of grid squares.
00:12:06.136 - 00:13:08.708, Speaker B: At every corner we've picked a random unit vector, so a random directional vector with length one pointing in a random direction. These gradient vectors are essentially going to correspond to these unit vectors are essentially going to correspond to the gradients of the terrain at each of these points. And so what we're going to do is once we've picked all of these essentially slopes of the terrain at every grid point, we're just going to interpolate to figure out what the value should be at all of the intermediate points. So in this example, we've got this heat map on top, superimposed on top of this grid. Green means higher and purple means lower. So you can kind of see like if you look in this grid square, the three vectors that were assigned to each of these three corners were all pointing inwards and correspondingly. What that means is that on the eventual terrain we're generating at those three points, the slope when you're moving towards the center of the grid square is generally going up.
00:13:08.708 - 00:13:43.120, Speaker B: So you can see that that corresponds to a darker green region over here. In this square, you see that the four vectors are pointing outwards. So what that means is that the gradient going inwards is going to be sloping down. And this sort of represents like a dip or like a valley in the terrain function. So Perlinoise basically says sample gradient vectors at every corner and then interpolate. And then you're going to get like a reasonable looking terrain function. And there's a couple more tricks, but this is sort of like the base foundation level one part of the algorithm.
00:13:43.120 - 00:14:39.380, Speaker B: So what does this actually look like mathematically? Essentially it means that we need to be able to pseudo randomly sample gradients unit vectors, which is hard to do with only plus and times. But we have some tricks that we'll discuss for doing that. And then the second part is that we're going to have to just perform a lot of dot products because we're doing all this interpolation. So we're basically just multiplying a bunch of vectors together. Unfortunately, this is actually really easy to do with plus and times, which is why this was the algorithm we picked to sort of start exploring snark implementations of. All right, so what I'm going to do now is I'm going to discuss some of the specific challenges of fitting all of this stuff inside of a snark. The first challenge is that you need to be able to pseudo randomly sample these gradient vectors at every grid corner.
00:14:39.380 - 00:15:43.450, Speaker B: So why is this hard? Well, essentially what we need to do is we need some function f that I can plug in the coordinates of a grid corner. And as output, I'm going to get a random unit vector. So I need something that's essentially going to say like, hey, for every grid corner here, for every pair of grid corners, regardless of if they're close to each other or far away from each other, the vectors associated with this grid corner are essentially going to be uncorrelated. So how am I going to do that? What I'm going to do is I'm going to use a Snark friendly hash function essentially as like a random oracle. So there exists Snark friendly hash functions like Mimsi and Poseidon. And what they're optimized for is they're optimized for basically creating these random looking outputs you can think of while being very cheap to verify inside of a Snark. So Mimsi, for example, just looks like a bunch of consecutive additions and exponentiations to a fixed power.
00:15:43.450 - 00:16:46.936, Speaker B: So by essentially plugging in these grid corner points into a Mimsi function and then doing some massaging, we can get a source of a function that essentially acts like a random oracle from which we can drive the random unit vector that's superimposed onto each grid corner. The second challenge that we encounter is that throughout the process of doing this perlin noise algorithm, oftentimes we find that we have to do divisions and Modulos and operations like this. For example, one thing that you're going to need to do to do this interpolation is you're going to need to determine which square are you actually inside. And this essentially amounts to doing something that looks like a quotient and modulo operation. Now the reason that this is hard is well there's a couple of reasons why this is hard. The first is because you're already implicitly working in this field. Like all of your operations are modulo p for the protocol, baby.
00:16:46.936 - 00:17:40.590, Speaker B: Jub jub prime p. And so that means that if you're not careful about things like overflow, then you can open up your modulo ZK proofs to certain attacks where attackers are basically able to or malicious provers are basically able to pretend that a certain value is the result of the modulo operation when it's actually not. So basically we have this modulo circuit that ends up being something like 100 lines in Circom where we're doing overflow checks at each step. The second thing that you have to be careful about is sine. Since we're working in mod p natively, there's not really the notion of negative numbers. So you have to enforce some sort of convention where, for example, we're going to consider all the residues between P over two and P to be negative and then the remaining residues between zero and P over two to be positive. And then you have to do like overflow checks associated with that.
00:17:40.590 - 00:19:06.484, Speaker B: So something even as simple as just like proving that three is congruent to eight mod five inside of a snark ends up being like more challenging than you might expect. The third challenge that we encounter is essentially taking the randomness that we are able to generate using or like the pseudo random values we're able to generate with Mimsi which we're using sort of as a random oracle and turning those into random unit vectors. So inside of the snark we basically have to be able to assign coordinate like a vector that has length one and some arbitrary direction sort of determined by the randomness to each grid point. This is hard because typically when you're sampling from if you're trying to sample a random direction, this is going to involve the use of trigonometric functions like sine and cosine. So the first approach that we tried to this was essentially using the value that we got from the random oracle as the input into a Taylor approximation of sine and cosine for various reasons that actually involved. The fourth challenge that I'll briefly touch on this is actually infeasible. So what we ended up going with was we ended up using a circuit written by some of the folks over at Semaphore that allows you to select from a list of values.
00:19:06.484 - 00:20:10.328, Speaker B: So we hard coded in 16 direction vectors and using this selector circuit we're basically able to index into this list and pick from the set of vectors. So for any given grid point that we're trying to sample a unit vector at, we're going to take that grid point, plug it into MIMC and get this randomness. We're going to take this random value modulo the length of the list and then we're going to use the selector circuit to basically pick out one of these unit vectors from this list of unit vectors. And the final difficulty that we ran into here that I'm going to discuss in this talk is that with perlin noise you're going to be dealing with non integer values. So for example, a unit vector is a vector whose both coordinates are not going to be integers unless you're at 10 negative 10010 negative one. So we tried a couple of approaches to dealing with this problem. The first thing that someone tried was implementing a series of fixed point arithmetic circuits in Circom.
00:20:10.328 - 00:21:08.704, Speaker B: These turned out to be like way too expensive to actually be feasible. So what we ended up settling on was we ended up deciding to do all of our arithmetic inside of our ZK circuits with fractions. And the way that we'd represent this is that we'd hold as a global constant in our circuits the maximum denominator d that any calculation would ever encounter. And we calculated this ahead of time by basically running the perlin function in JavaScript and sort of figuring out what the maximum denominator we would encounter was. So we'd hard code that in there and then all of the math inside of the circuit would be done on the numerators, implicitly knowing that these are numerators of fractions that are divided by the denominator. So we're tracking this global constant denominator D, and we're doing all this math with numerators. And so what this means is that whenever we add two values in our circuit, we sort of know that we're adding, like, A over D plus B over D, and we're getting the value A plus B over D.
00:21:08.704 - 00:22:25.652, Speaker B: And it also means that whenever we're multiplying two values, we have to multiply the values and then divide out the extra factor of D that we're getting due to the fact that A over D times B over D is AB over D squared. So that's how we got around the difficulty with these calculations not being integer calculations. Yeah, so the result of this, we have a very sort of basic version of the perlin noise function implemented in Dark Forest, which those of you who played in the last two rounds have probably seen. Basically, perlin noise allows us to add texture to the universe by making it so that some regions have richer areas with more resources than others. The goal here, though, would be to get to a point where perlin noise can be used to create very expressive and featureful landscapes, potentially something that could even look someday like the Minecraft world. Beyond these difficulties, one kind of meta difficulty with doing all of this is that the development environments and sort of like the Dev tooling for ZK application development is currently still quite rudimentary. So I'll just give a quick shout out to Jacob Rosenthal and Blaine Bubblets, who have been working on a lot of tools for ZK development workflows.
00:22:25.652 - 00:23:23.710, Speaker B: But all of these challenges are made more difficult by the fact that we're still very early in ZK application development and the sort of workflows that we have are not very developer friendly. So if anyone is interested in applied zero knowledge development, this is definitely an area that a lot of work can be done in and would be very useful for. Yeah, so that's pretty much it for my talk. If you want to learn more, we have a blog where we post a combination of Dark Forest game related content as well as some ZK development content at blog zkga me. You can also find us at twitter at darkforce and we will be releasing the next version of Dark Force in a few weeks, targeting around mid May. Finally, if you want to reach out, you can find me on Twitter as well at at BGU 33. Yeah, thanks for having me.
00:23:26.080 - 00:24:07.160, Speaker A: Amazing. Thank you so much, Brian, on such an interesting, and I would just say like a very technical but super detailed and important overview of how this is done. I think this is a key part of what makes Dark Forest a thing and adds the actual natural sort of appeal to really relying on the ZK piece here. So this is super cool. If anybody has any questions from the audience, please feel free to ask them on the chat and we'll relay them on this live. In the meantime, I think you've kind of pointed a handful of recurring themes that I noticed from the talk. I guess my high level question here is I would categorize this right now as cold golfing for lack of a better category.
00:24:07.160 - 00:24:33.890, Speaker A: And given how early we are in anywhere from the tooling to the development side to just the number of people who are aware of how these things work to get something in the application side, what do you think is sort of missing the most here? Is it the lack of like, we need a standard library for lack of a better way to think about it, or we just need more standards on somebody should just do this thing and we just all use the same library every time or kind of what does that repeatability or abstraction look like?
00:24:34.660 - 00:25:37.012, Speaker B: Yeah, so one thing that I think about is that ZK application development, I feel like, is pretty inaccessible unless you actually have some certain level of math background or a basic understanding of number theory, for example. So for example, the particular nuances around the modulo circuit and making that secure are only going to really make sense if you are very familiar with or have a good intuition. For the Chinese remainder theorem, it's like, why do I need to do these overflow checks here? What could a malicious prover actually do? Well, the thing that the malicious prover could do is because of the Chinese remainder theorem, you can do the Euclidean algorithm to sort of figure out what the malicious value would be for the modular thing. In short, I think what we need is there's a couple of things. One is a standard kind of library of circuits that people can kind of plug and play into. Another would be a higher level kind of DSL on top of, for example, Circom, which already does like a phenomenal job of making any of this possible at all. It still just blows my mind that it's possible to program ZK snarks at all.
00:25:37.012 - 00:26:41.444, Speaker B: But the next step is that it should be accessible to program them as well. You shouldn't need to be very familiar with number theory in order to build applications like this. Like an example that I've been thinking about a lot is that cryptography under the hood is very complicated. But we've sort of figured out collectively as a space how to correctly abstract away the mathematical operations underneath cryptography and provide an API, like a conceptual API for developers to know. Like, oh, encryption has these guarantees, decryption has these guarantees, message signing looks like this and this is manifested then in a bunch of the sort of standard libraries and whatever language you're using for these cryptographic operations. And then another thing that I think will be really big, I mean, that will take a while because I think it's definitely the case that the protocols even, it's not even clear what the protocol guarantees are going to be in the future. But the other thing that I think about that is always ongoing, is devtooling to allow for just faster iteration cycles, better feedback from better feedback loops for developers.
00:26:41.444 - 00:26:50.830, Speaker B: That's a lot of the stuff that Blaine and Jacob have been doing, which I'm really excited about. So it's a combination of a lot of things, but I do think we are very early.
00:26:51.600 - 00:27:04.076, Speaker A: No, I totally can 100% echo that and I think just kind of this is a natural evolution of new technologies in general. Like, this is the punch cart to Fortran era and then we want the Fortran to python jumping.
00:27:04.108 - 00:27:04.992, Speaker B: Exactly. Yeah.
00:27:05.126 - 00:27:11.010, Speaker A: Just like you don't have to think about how registers work. Somebody needs to abstract the number theory here.
00:27:11.320 - 00:27:12.070, Speaker B: Right.
00:27:13.320 - 00:27:30.600, Speaker A: Kind of having said that, super excited to see that you're announcing the new version of Dark Forest. And maybe just as a clarification, was what you talked about an analysis of what the last version of it was or how you're using these things to now make the next version of Dark Forest more generated?
00:27:31.020 - 00:28:08.336, Speaker B: Yeah, so these were some of the challenges that we've encountered trying to implement just like a very rudimentary version of Perlin Noise for the last couple of versions of Dark Forest, we're still using these and continually working on improving them for the upcoming versions. Specifically, though, what we're also interested in is we think that this technique could be a building block for a game beyond Dark Forest as well, or for games, plural beyond Dark Forest. And so what we're going to be exploring in the next couple of months is ways to bring this mechanic into other kind of prototypes or proofs of concept of simple blockchain games.
00:28:08.528 - 00:28:33.420, Speaker A: Awesome. Well, with that, I want to thank you so much for taking time on Friday and doing this amazing talk. And if you have any other questions that have not been answered, we'll relieve them to you directly. And for anybody who's going to watch this later or watching this now, we'll have a snipped video of this for just a 30 minutes talk available online on YouTube later. So you can all catch up and check out the slides and the math directly. So thanks again, Brian.
00:28:33.760 - 00:28:35.290, Speaker B: Thanks, Karthik. Thanks for having me.
