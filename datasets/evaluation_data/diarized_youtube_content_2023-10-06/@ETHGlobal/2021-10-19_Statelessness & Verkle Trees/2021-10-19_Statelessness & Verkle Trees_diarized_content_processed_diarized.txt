00:00:06.170 - 00:00:21.438, Speaker A: Next up, we have Guillaume, and he's going to be talking about statelessness and virtual trees, a really interesting and awesome topic. And without further ado, I'll let him introduce himself and take it from here. Welcome. Here we go.
00:00:21.604 - 00:00:41.494, Speaker B: Okay, perfect. Yeah. So cool. Thanks for having me. So I'm going to talk about statelessness and vertical trees. So I'm Guillaume from the guest team. Just like been like in the past six months, I've been working on what comes after the merge.
00:00:41.494 - 00:01:43.230, Speaker B: So we wanted to share a bit, let's say an overview of what to expect after the merge. Like, the merge is the big thing on the horizon, but there's more exciting things coming after that. So, yeah, I've been mostly working on vertical trees, but I've been asked to give a broad overview of statelessness in general, what's coming, so I'll cover a bit of that as well. And the first question is, why do we want to achieve statelessness? And it's pretty simple, in fact. Have you tried to synchronize a node recently? It's taking a long time. You need a lot of data, so that really prevents a lot of people from joining, like smaller devices, phones or Raspberry PiS. I mean, raspberry PiS technically can do it, but it's not very sustainable.
00:01:43.230 - 00:02:32.442, Speaker B: There's a lot of centralization associated to this, like a lot of people using Fiora. And there's also the problem that, for example, a DAP developer or anybody, there's a lot of data to download, but not everybody is interested in all the data. In fact, most people are not interested in the data. So it would be great to have just to be able to download the data that you care about and keep going on with the rest of the network. So these are the goals that we're trying to achieve. And so there's basically three components. Statelessness has three main components.
00:02:32.442 - 00:03:41.314, Speaker B: There's vertical trees. This is the technology we're going to use to basically make statelessness possible because it allows for very small proofs or much smaller than what we used to have until now. There's the state expiry, which is something that has been attempted many times in the past, but is coming back with a new technique called address space extension that I will cover. And the last component is state networks. So since syncing the state is so difficult, the question is, can you just avoid dealing with all that state? This is the question this answers. So let's get into the vertical trees. Currently we have a Merkel Patricia tree, so it's using hashes, each level hashes its children and so on until the top.
00:03:41.314 - 00:04:54.650, Speaker B: And hashes have been very useful in the past. But the problem with hashes is that if you get the whole commitment sorry, if you have a vector of values and you just want to prove that one value is in the vector and you don't want to reveal what's next to it. You can't really just take the hash you can't really just take the hash and take that value and somehow prove that this value is at this specific position in the source data. The only way you can prove that is by passing the entire vector. So you have other an alternative technique that has many similarities with the hash is a vector commitment. You have a vector, you commit to it, you provide a commitment, but they also have the ability to find an opening which is a smaller piece of data compared to the size of the vector that you can use. So if you have the commitment plus the data, plus the opening, you can prove that this data was indeed at this location in the vector.
00:04:54.650 - 00:05:59.660, Speaker B: And you can use this to hide some data if you don't want to reveal all the data. But the reason why we care about this is not because we want to hide data that is public, we just want to use it so that we don't have to pass all the data. And this is quite important because if you want to prove that something is in the current tree because you're using a hash, you have to pass all the siblings of a given node along the path so that's 15, like the, the Merkel Patricia tree has each node has 15 siblings or 16 children. And each time at each level you have to pass all 15 siblings. And the depth of the tree on average is seven, eight. So you have 15 times 832 bytes. It's a lot of data.
00:05:59.660 - 00:07:05.630, Speaker B: So because of what I explained about vector commitments, you could use vector commitments to just pass the data that you need, add some commitments and that's already, for each level, much less data. And on top of that, the average depth is four. And the reason for that is because since you only pass like, the, the number of siblings doesn't matter. You can have much larger like nodes with many more children. And because your tree becomes much larger, it becomes automatically less deep, so more shallow. So you move on from a structure that is really high and not that large. I mean, the MPT is quite large, but a vertical tree would be larger and it would be shallower, which means you also reduce the number of items in your proof, which contributes to making the proof smaller.
00:07:05.630 - 00:08:01.860, Speaker B: And there's also an interesting point that I'm not going to cover really today. It's the fact that currently you have a tree for all the accounts and then each account has its own tree for storage. We're no longer having that with vertical trees, everything gets merged into one giant tree. But yeah, I won't cover that. It's just interesting to know. One question that comes often is people say, okay, but if you have a commitment, if you don't have to pass the siblings, why not pass a single vector commitment with only the data you want? And that's a good idea, but calculating a commitment takes a lot of time. Just like calculating the hash of all the data takes time.
00:08:01.860 - 00:09:01.118, Speaker B: So what you do is you try to look for a sweet spot that makes smaller proofs but doesn't require a lot of time to compute. And so we chose 256 children. Initial implementation or initial proposal were 1024 children, but it made things more complicated to implement and 256 children seems to work. So this is what we went for. So, yeah, just a general comparison of proof sizes between Merkel and Veracle. In the first case you have the leaf data. Sorry, in both cases you need to include the leaf data, but in the case of Merkel, you have for each level, which is roughly seven, you have 15 siblings, each of which is 32 bytes.
00:09:01.118 - 00:09:45.486, Speaker B: So if you have 1000 leaves, that's roughly three megabytes. And we're getting in block size. So we want to have the proof integrated inside the block. And as a result, that makes a block that is bitcoin territory, basically, and in fact bigger than this. So instead of having a block every ten second, ten ish 15 ish seconds that gets propagated over the network. You need ten minutes, maybe more. So that's why the Merkel tree and that's why we want to switch the tree that we use to store the data, because that's impractical.
00:09:45.486 - 00:10:43.780, Speaker B: Whereas vertical trees so you index, you have the index that the child is in the node, you have the value, you have the commitment to it. So it's a slightly larger value, but you only have four levels and you don't have the siblings. So you end up even though you have a tiny overhead, it's not insignificant, but it's definitely not the biggest contribution. So you end up with a block size of roughly 150K. Sorry for the proof. So the block size, it basically doubles the block size and that's much more manageable. Right, so the next idea is state expiry.
00:10:43.780 - 00:11:32.100, Speaker B: And the idea is that because the state is getting too big in Ethereum, there's the state bloat problem. And because you end up when you store something on ethereum at the moment, you pay some gas. But the implicit promise is that this value you store will be kept forever. So that's effectively free. We want to go back on that promise a bit because it causes state bloat. So the idea is that after a while the data expires. Of course, it's not completely forgotten.
00:11:32.100 - 00:12:20.796, Speaker B: We start with a fresh tree. We delete the data from the previous tree, actually from two trees ago. But we keep the root so that if you have a proof of your data, that your data was present in the tree at that time, you can resurrect it. You can bring it back to the current epoch. So you pay an extra cost to bring it back. But if you don't need it, you can still just keep the proof and just let it wait for the time you need it to pay the resurrection cost. Right now we divide the time into periods.
00:12:20.796 - 00:13:07.778, Speaker B: The period zero is the one we're currently in. But when the state expiry scheme becomes active, you will have one period each year or each six months. And when that happens, you freeze the tree of the previous period, and you start with a fresh tree. So we had peer zero. What you do is you start adding values to it. And so far, you still have to keep the data of the previous period. And when the period one comes to an end, what happens is you start again from a fresh tree.
00:13:07.778 - 00:14:19.390, Speaker B: You are still obliged to keep the data of the previous period, but the period before that, you can delete the data and you just keep the root so you can start adding more data to it. And when you want for example, if someone wants to recover data from period zero, they pass a proof and that gets included. So the data gets brought from period zero into period two. One thing that is not specified on this diagram is that the data had to be absent from period one. So when that green data got recovered from period zero, there was a check that it was not present in period one. If you find yourself at period three and you want to resurrect something from period zero, you have to pass a proof of absence. You have to prove that the value you're trying to resurrect was not in period one.
00:14:19.390 - 00:15:02.826, Speaker B: Because otherwise what could happen is, for example, Alice has some funds in period zero. She transferred them to period one, then she transferred some funds to Bob. Period two happens, period three happens. And then Alice resurrects the funds she had in period zero, and that's a double spend. So to make sure this does not happen, you need to pass a proof of absence. Right? So this state expiry mechanism comes with what's called an address space extension. So we had addresses that were 20 to 32.
00:15:02.826 - 00:15:50.550, Speaker B: Sorry, currently in Ethereum, the address are 2020 bytes, and they are the first 20 bytes of the hash of your public key. So now we want to make those address 32 byte long, but we don't reserve those 32 bytes. Like this is not the whole hash. We only take 26 bytes of the hash. And then the remaining six bytes are used for well, half of them are used for versioning and future use, and the other three bytes are used to denote the epoch. Sorry, I keep saying epoch, but it's actually a period. It's used to denote the period that the address was first accessed.
00:15:50.550 - 00:16:57.486, Speaker B: And the reason for that is because there's a cost associated to resurrection. So, for example, if Bob wants to send Alice some tokens to Alice, but Alice hasn't resurrected the address either, bob pays for the resurrection cost to resurrect Alice's account. But if he doesn't want to, then he can send it to an address that is also controlled by Alice in the sense that, for example so I have this example here, for example, let's say Alice owns the public key, sorry, the private key that controls address. She has a balance here. And then let's say Bob has address one, for example. So both those addresses have the counter zero because they have been seen for the first time in period zero. Then period one happens.
00:16:57.486 - 00:17:50.306, Speaker B: So this is not in the period one tree, but Alice might receive some funds from Bob. And Bob's, instead of resurrecting this address from Alice, actually sends it to Alice, but with an address containing the current period. So it's seen for the first time at this address in period one. And Alice still has the private key that controls this hash. So she's still the owner of the fonts, but it's like she has two addresses with one private key. She has two addresses now, and in period two, Alice might want to get the value she had locked during period one. So she passes a proof to resurrect the address.
00:17:50.306 - 00:18:39.582, Speaker B: And we can see that the value that was in period zero is now available in period two. When Bob sent some funds to Alice in period one, this value was not overwritten. Alice now has 1234 ETH in one address and 9101 in another address. So that's an interesting scheme. It's also a fairly complicated one because I like to make this joke. Address state extension, like ASE can be pronounced assay, which is sweat in Japanese. I think implementing it is going to require a lot of sweat, but yeah, it's nice because it makes state expiry.
00:18:39.582 - 00:19:21.726, Speaker B: At least it proposes a concrete approach to state expiry, which is something we've been talking about for a few years already. The problem is that it's still quite complex. A lot of contracts on chain today expect a 20 byte address and they actually use the twelve remaining bytes for something else. So it would not work. Like if they are given a 32 byte address, it's going to break the contract. So there's a good idea by the Ipsilant team bridge contract. I'm not really going to talk about this today.
00:19:21.726 - 00:20:25.934, Speaker B: It's quite involved, but it's promising, but I don't want to make false promises. It's a very complex scheme and statelessness thankfully, does not entirely depend on it. So it's nice to have, but we can still launch without it. The last component is state networks. So the main proposal is by the Piper and the Python team, the portal network. And the idea is currently you have to get all your data, like when you want to participate in the network, you need to download the data from all of it, most of which you don't care about. So the idea is to provide a network alongside the block propagation, a propagation network where every machine on the network only stores a fraction of the data.
00:20:25.934 - 00:21:21.090, Speaker B: And if you need it on a per need basis, you can go and query that data to one machine or to a subset of all the machines as you need it. And that's quite nice because it has many applications. First of all, you don't have to store all the data, obviously, but even if you want to be, for example, a validator in East Two, you don't really have to store the data yourself. You could just send your request, ask someone else to store the data for you and request the data when you need to propose a block. Of course I didn't say that, but that data is validated. You have to pass a proof, which is where vertical proofs once again are interesting. Although I guess miracle proofs could work at this stage.
00:21:21.090 - 00:22:21.426, Speaker B: So the roadmap is, yeah, basically vertical tree is almost there. At least we have a prototype. We are going to build another prototype using rust veracle. So, yeah, there's guess that currently is able to produce blocks with vertical proofs. And Ethereum JS is interested in writing a stateless client that will just execute blocks without actually downloading the data. And then when vertical has been delivered, address space extension can be also delivered, but if it turns out to be way too complex, you could also skip it. And the portal network, like I said, doesn't really require vertical proofs per se, so it could be delivered independently.
00:22:21.426 - 00:23:37.734, Speaker B: And when you have at least two, but preferably three of these things, you achieve statelessness. So, yeah, I'm running out of time, so I'm just going to like I had this slide to explain a bit what stateless Ethereum would look like in the future. The biggest thing to know is that your data like to realize that your data won't be kept accessible forever. You have to keep your proof or you have to pay someone to give you a proof. But it allows for nice, more decentralization because ultimately you would not need to rely on infuria or on miners or validators. The data could be spread all over the network and you could just download what you need and you could also why not make a profit by hosting data for other people. So, yeah, overall it gives a more decentralized world, a more accessible world because there will be lighter clients will be able to join.
00:23:37.734 - 00:24:01.590, Speaker B: So, yeah, all those people that are currently priced out of the network because for whatever reason they don't have the space or the bandwidth or whatever to join ultimately, and we hope can also join the party. And yeah, that's it. I don't know if we have time for questions, but I think it's.
00:24:03.610 - 00:24:20.350, Speaker A: We are a little bit over, but I think we can do a couple of questions because hopefully I think they're a simple one. So there's three questions here. Some of them might be related to each other. So the first one is what kind of proof is used to bring back data after state expiry?
00:24:21.890 - 00:24:38.654, Speaker B: So that depends. The first tree is MPT, but it will be converted to vertical. At least that's the plan over time. So initially, let's say it's going to be a vertical proof.
00:24:38.702 - 00:24:47.430, Speaker A: Yes, got it. Would vertical trees help lower gas prices by letting us store more transactions for block?
00:24:48.730 - 00:25:01.100, Speaker B: That's a good question. I'm going to say no. Maybe Vitali can pitch in on this one. I think he's in the chat, but my understanding is no.
00:25:03.070 - 00:25:10.430, Speaker A: All right, well, maybe Vitali gets to come in when we promote in a minute what possible alternatives are there to ASV?
00:25:11.650 - 00:25:52.250, Speaker C: Okay. Yay, I got promoted. Okay. The question was if would vertical trees allow us to increase scalability? I guess prices, right? Increase the gas limit and lower gas prices. I guess maybe, right? Because right now state size is one of the big bottlenecks on increasing the gas limit. And if we add vertical trees and if we add proposer builder separation. So if we have both of those things, then we can move toward the world where the only actors that need to be stateful would be the builders, which would be a much smaller number of nodes.
00:25:52.250 - 00:26:01.710, Speaker C: So if we have that world, then the negative consequences of letting the state blow up to like a terabyte or would be lower.
00:26:01.780 - 00:26:02.014, Speaker B: Right.
00:26:02.052 - 00:26:10.690, Speaker C: So I think increasing the estimate would be safe there, but then adding state expiry as well would allow us to go even further.
00:26:13.350 - 00:26:20.290, Speaker A: We'll do one more quick one. Can users pay stakeholders trustlessly or will this happen out of the protocol?
00:26:21.130 - 00:26:22.678, Speaker B: Sorry, I didn't quite hear.
00:26:22.844 - 00:26:27.590, Speaker A: Can users pay stakeholders trustlessly or will this happen out of the protocol?
00:26:29.690 - 00:26:43.030, Speaker B: Yeah, okay. I'm not an expert in the protocol, but I know, like, if I compare to light clients, that's exactly what happens. So yeah, I'm going to say yes, it's going to happen in the protocol.
00:26:43.370 - 00:26:43.974, Speaker A: Cool.
00:26:44.092 - 00:26:46.714, Speaker B: It's easy to implement Trent.
00:26:46.762 - 00:26:57.340, Speaker A: Hopefully that's a satisfactory answer. If not, we'll ask him to put the answer in chat and follow the discussion there. Thank you so much. That was a really awesome overview. And yeah, appreciate your time.
