00:00:00.570 - 00:00:41.158, Speaker A: Okay, so I'm Will Morris. I'm a blockchain engineer at Choice Token. We have five tokenized currencies. The biggest by market cap is True USD at $175,000,000. The rest of these we're hoping to build up over time, but they work in the same way. These are tokenized currencies, which represent dollars you can send to your bank account, or in the case of the British, the pounds that you can send to your your pound account, I don't know. But the way that it works is that we have an app and we assign you an address and when you send it to that address, it burns it and you get it in your bank account usually within the same day.
00:00:41.158 - 00:01:17.634, Speaker A: But if you're outside of banking hours in your own country, then you will get it the next day. Basically, as soon as we can get it to your account, we get it to your account and we have sort of metrics to make sure that we don't regress in that category. Okay, so how do I do I have to click? There we go. All right, so we have hackathon prizes. We're giving out 6500 TCAD, which is worth about $5,000. That's the most amount they would let us give out. We would have loved to give out more money, but we love to incentivize people to build on our products.
00:01:17.634 - 00:02:11.030, Speaker A: And so it's 5000 TCAD for the best use of true currencies and 1500 TCAD for the runner up. And I'll be evaluating that based on utility, the use of true currency features and user experience. So you don't have to use true currency features, you can just use ERC 20. But if somebody else comes along and makes great use of them, then hello, then I'll have a preference for that. So these are substantial prizes but there's only two of them and I'll be judging. And I'll also need your ethereum address because these are cryptocurrency prizes and not like physical money prizes. That also helped me get past border security on my way in because if you came in with a bag full of cash, they're going to ask more questions than if you come in with a bag full of cryptocurrency.
00:02:11.030 - 00:02:58.870, Speaker A: So true currencies use very little gas. In fact, we're very confident that they use the least gas of any ERC 20 token on main net. We do this using a variety of techniques, but you can see the case breakdown here. There's really four major cases for ERC 20 tokens based on the preconditions for transfer. And in most of those cases we're less than everyone else. In particular, the worst case, which is called Reduce into New, which is when you reduce one account and create a new account, that's the case in which we beat everyone out of the water. It's also the case that's fairly relevant for withdrawals.
00:02:58.870 - 00:03:43.166, Speaker A: Okay? So the way that we got that good is by profiling. And I encourage everyone to profile for gas when developing smart contracts. The way that you do that is you create a test suite and Truffle or whatever framework they're using that evaluates the many different cases that you might have. We have 46 cases for our own contract and there's also preconditions to consider. You want to control as many variables as possible such as the timestamp, little things like the timestamp parameter and the call data. Having 10 byte can cause variance in your test. So you want to control that using techniques such as Truffle Time Machine developed by my friend Ethan Wessel who works at AirSwap.
00:03:43.166 - 00:04:43.494, Speaker A: You want to measure gas used as returned by the transaction receipts so that's when you do await transaction in Truffle, that returns a dictionary. And one of the fields in the dictionary is Gas used. And if you evaluate that, you can compare it to the previous time that you ran it by writing results to a file and see that if you got a regression or if you got an improvement, you want to see that and also include that in any pull requests you make. And we recommend measuring as many different possible cases so that you can see even edge cases that might be much more expensive than the regular cases and controlling for those. So first we're going to talk about high level guidelines. Don't use external storage contracts for data that you'll read often. That's because if you call into those contracts, there's overhead and that overhead is only going to increase with e two.
00:04:43.494 - 00:05:27.526, Speaker A: So just keep all your storage internal. Don't externalize it. There's no reason to like while good object oriented programming often says you should have a different class that has its own data, you don't really want to do that on chain. In the case of having a different contract that has the data because of the overhead, there's a contract called Gemini USD that has very bad behavior here that it stores its token balances on another contract. So first it reads the token balance, then it adds it, then it writes it. And each of these is a different call. They didn't even consolidate it.
00:05:27.526 - 00:06:07.218, Speaker A: It's pretty inefficient. So also if you use a custom storage layout using solidity assembly, then you have to be aware of existing storage that might be in your contract for Ketchack mappings or arrays. So there's also a thing called Upgradable Proxies that we use and that you may use. But our recommendations first is to not use Upgradable Proxies. Does everyone here know what an Upgradable proxy is? Do you know what an Upgradable proxy is? Okay, do you know what an Upgradable proxy is? Do you know what an Upgradable proxy is?
00:06:07.304 - 00:06:15.140, Speaker B: I think that's where you can sort of like a state pattern so that.
00:06:15.750 - 00:07:21.082, Speaker A: You can change the code state pattern basically implementation contract inside another yes, using delegate call. So the way that it works is that you have a proxy contract that tells you where the code is and it delegate calls into that code. So the data remains in the proxy contract, but the implementation is in the implementation contract. This allows you to, if the EVM changes how much gas things cost, you can do an upgrade. And if something breaks, you can actually fix it before the hard fork, but without actually changing your address. Now this is important for some things more than it is for others. If you're a major token and you don't want to break exchanges like ever, and you don't want to tell them to change their address, you don't want to have to do a community announcement and get everyone to use your new token or migrate using a redeemer, then you can use this instead.
00:07:21.082 - 00:07:59.158, Speaker A: But my first recommendation here is to not use that, only use it unless it's absolutely necessary. If you're developing DeFi, just allow people to move their money out. Like for example with Uniswap, you can pull your liquidity so that people have a way out. If things are going to break in an upgrade, that's slightly better than having a proxy. But if you do have a proxy, don't put many methods in the fallback proxy contract. That's because the delegate call happens in what's called the fallback function. Do you all know what fallback functions are in? Solidity? Okay, yeah.
00:07:59.158 - 00:08:28.970, Speaker A: So if you have many methods in your fallback proxy, then the proxy has to check for each of those methods before it delegate calls. And so the more methods you have, the higher the overhead of your proxy will be. So you don't want to have more methods, you want to have as few as possible. You should also consider writing your proxies in assembly. If you don't have methods, that's great. Certain factories use proxies. For example, the Uniswap factory creates proxies.
00:08:28.970 - 00:09:03.798, Speaker A: Those proxies are written in assembly, but they don't have any methods. So it's ideal matches all of these recommendations. But where storage conflicts. So if you have an implementation address in storage, make sure that it doesn't conflict with anything in your implementation because you don't want to override that. And over time, when you're developing with a proxy, if you have a storage proxy, you have your storage layout and then you change it. The variables don't move. All the storage is going to stay where it was at the time that you upgraded.
00:09:03.798 - 00:09:46.482, Speaker A: So you want to deprecate slots that you're not using so that you don't go back and reuse them. You wouldn't want to have any conflicts of that kind. Those are guidelines related to proxies. So now sharing data. So suppose you have a bunch of contracts that want to refer to the same data, and that data doesn't change very often. So suppose it's a blacklist, for example, of addresses that are not allowed to receive your token. Then you don't want to have to call into a contract because that would be overhead you don't want, like every time you do a transfer to call into another contract.
00:09:46.482 - 00:11:09.698, Speaker A: In an earlier implementation of True SD we did because of the object oriented paradigm, which is the one that we were raised on, that if you keep your data in one place, then it seems to be more efficient, but actually you want it to be in ten different places so that you don't have to call into those contracts. If you're not writing very often, like if writing is an admin functionality, for example, or something that only happens every five minutes or every hour, but people are going to do transfers much more often than that, then you wouldn't want to call into an external contract because there's considerable overhead to doing that. And so it's better to instead have a write through, like controller. So you control the writing, you write into one contract and then you have subscribers to that, so that when you write it, it writes through to those other contracts so that they get the data that they need and it's internal to them so that they don't have to external call into it. External call? I already said I expect the cost of it to increase over time. Currently it's 700, but there's also the call data and the overhead of figuring out what method you're calling and loading the data, of course, and returning it. All of this is not free.
00:11:09.698 - 00:11:38.234, Speaker A: It can add a few thousand gas to your transaction and that's not friendly. You can save several percent by keeping that internal. So that's our recommendation for if you write rarely. We adopted this and it saved considerable gas. We adopted it in February. So next, multilevel mappings. So between the left and the right, which one do you think is cheaper? Have a look at it.
00:11:38.234 - 00:12:12.870, Speaker A: There's a constant deposit address and there's a mapping. But the only thing that's different is that the keys for the mapping are flipped. So the first key is bytes, the constant, and the second key is the address, or vice versa on the right side, where the address comes first followed by the mapping. And what you're doing is you're calling attributes sub deposit address, which is a constant, and two, which is a variable. So the result is shown in the bullet point below. So which one is cheaper?
00:12:15.610 - 00:12:16.360, Speaker B: Right?
00:12:18.430 - 00:12:19.820, Speaker A: Say left or right.
00:12:24.510 - 00:12:25.500, Speaker B: With the address.
00:12:27.390 - 00:13:05.000, Speaker A: Yeah. So the left one is cheaper. That's correct. And that's because ketchack of constant can be simplified by the compiler. So if you have a registry of attributes per address, as we do, then if simply flipping the order of the keys saves gas because you don't have to compute the catch act twice, you only have to do it once. So that's a cool little trick I discovered in the bathtub one day. Cool.
00:13:05.690 - 00:13:08.194, Speaker B: The constant first is cheaper.
00:13:08.322 - 00:13:34.430, Speaker A: Yes, because of the order of the catchack. And if you ever forget this, you can look up the solidity. Read the docs in the miscellaneous section. It lays out how the storage works for multilevel arrays. And then you can rederrive this. But yes, the constant first. If you can get constants first in your mappings, multilevel mappings, then that will save gas cool arrays.
00:13:34.430 - 00:14:22.478, Speaker A: So if you wanted to clear an array, the one on the left might be a very naive solution. You set the thing to zero, then you decrease the size of the length until there's nothing left. But actually you can just do the thing on the right and it does exactly the same thing, but in substantially less gas. So you have a concept of how inefficient the first one is first it would set the value to zero and then it would set the value to zero and then it would so it would do it twice. The compiler does not know not to set it to zero twice, it just does it anyway. And then it doesn't optimize the fact that you're actually going to decrease the length each time. It doesn't optimize that.
00:14:22.478 - 00:14:30.702, Speaker A: So if you want it to clear a bunch of elements and then reduce the length of the array, you should just change the length of the array.
00:14:30.766 - 00:14:32.130, Speaker B: What do you mean by twice?
00:14:32.630 - 00:15:12.734, Speaker A: So here it says I equals zero, but the length minus minus also sets it to zero. Yeah, so that's not good. But that's what happens. It's not something you'd expect just looking at it, that changing the length of the array would set it to zero. You might do this to save gas. For example, when you change ones to zeros, it gives a gas refund to the people executing. So if you're done with space, you should clear it.
00:15:12.734 - 00:15:22.370, Speaker A: But be careful about how you do it, because if you did it the way on the left, it would actually not save gas because the overhead would be so substantial.
00:15:23.350 - 00:15:25.090, Speaker B: What do you mean by refine?
00:15:25.430 - 00:16:11.650, Speaker A: So at the end of execution, if you've cleared state, you get gas back based on how much state you cleared. If you clear an S store slot, which is a storage slot of 32 bytes, you get back 15,000 gas, which is a lot of gas. And if you delete a contract, if you call self destruct, that refunds 24,000 gas, which is a lot of gas. For reference, a transfer is 21,000 gas and S store creating a new slide is 20,000. So that's all for this slide. And now we're going to talk about true currency features. And if you use these features, you'll have an edge in the competition.
00:16:11.650 - 00:16:47.870, Speaker A: So first we have a feature called deposit addresses. So in one transaction you can create two to the 20, which is about a million deposit addresses. That all forward tokens to your central wallet. You can save gas on your deposits to your exchange or centralized service while tracking the originator. So a common paradigm in exchanges is that they want to accept an address. Hello? So they want to accept at an address. They knew who sent it.
00:16:47.870 - 00:17:23.130, Speaker A: They give everyone their own address, and if you send to that address, then they know that the money came from you. But then they have to sweep it, which is a separate transaction, and it costs them money. There's overhead to that. It's sometimes passed on to the customer in the form of a fee. But if you use deposit addresses, then you don't have to charge that fee at all. We called it Auto Sweep, and we tried to get that trademarked, but they said that it was too accurate of a name for what it did, that it was too close to the actual description of the thing, that it didn't qualify as a US trademark. So that was annoying.
00:17:23.130 - 00:18:27.818, Speaker A: But being able to create a million addresses in one transaction that all forward to your centralized wallet can be useful. If you're an OTC desk or if you are a centralized exchange, it emits two transfer events. When you do this, it emits the transfer to the deposit address and then the transfer to the centralized wallet. But it only does the Sdor once, so it's considerably cheaper than Sweeping, like more than 50% cheaper. We also have redemption addresses, which are the feature that lets you send to your bank account. If you send it to your redemption address, we burn the funds immediately in the same transaction, so we don't sweep. A few of our competitors do sweep, including Circle and PAX, and this costs them overhead, but we can do it and operate much cheaper because we do it automatically.
00:18:27.818 - 00:19:02.140, Speaker A: Here's an example of a redemption address. It has many, many zeros in it because we're issuing them upwards numerically. So if you create a new account, you can get a really short address. We're still in three digits right now, though. We're now out of the Ox nine. So I think we're currently in a if you get a new account, it'll start with an A. I'm going to actually open this URL if I can, but I'm going to oh, nice first try.
00:19:02.140 - 00:19:43.080, Speaker A: So here you can see this person's activity, all their redemptions. Here they redeemed a million dollars, $5 million. $2 million. $3 million down here, $16 million, which is our largest ever redemption. We gave them the money very quickly because they were on a network called Silvergate, which recently IPOed, by the way, you can invest in them now. Silvergate is a very cheap bank that charges nothing for internal transfers, and a lot of crypto traders use it, so it's very popular and that's why we're on it.
00:19:44.330 - 00:19:46.018, Speaker B: When you say internal transaction.
00:19:46.114 - 00:20:45.930, Speaker A: So, like transfers to another Silvergate account? Yeah, and they have a good API, and their internal transfers settle programmatically in less than a second. So when people redeem through Silvergate, they get their money in less than 15 seconds. We only wait because we want to make sure that that was the block. But currently none of our cut clients are miners, so we aren't super worried about 51% attacks on the Theater Theorem network. Okay, the next page is recipient callbacks. So if you all are familiar with ERC 223, there's a callback function so you're able to get a callback when you receive money. This could be useful in a variety of ways, but mostly for developers that want to know when they've received money in their contract.
00:20:45.930 - 00:21:37.914, Speaker A: So it's opt in. So you have to call into a registry to get this callback, and we evaluate that you are in fact a smart contract before you get this and you actually get it from ERC 20 transfers instead of from ERC 223. We're considering adopting 223. One difference between 223 and this is an additional parameter bytes, which would be useful if you wanted to provide more data. But we don't support that right now, mostly because ERC 223 is not standard yet, so it's actually EIP 223. But we find this is useful for contracts. We've gotten feedback from several DApps that they'd like something like this, and we're working with Uniswap right now to use this.
00:21:37.914 - 00:22:17.990, Speaker A: They're probably going to be the first customer of this feature. But it's also somewhat useful for if you are doing an ICO, then it changes the experience from first approving the contract and then transfer from. So it replaces approve transfer from for a lot of contexts to just transferring money to the contract, which is a considerably better user experience. We also do gas sponsorship. So far we have 25 billion gas, which is a lot of gas. For context, each block has 8 million gas. So this corresponds to about a month of blockchain activity.
00:22:17.990 - 00:23:12.406, Speaker A: It's very similar to gas token, if you know how that works. But without the overhead of calling into the gas token contract. We have a buy wall for gas during periods of low activity. True USD represents like 5% of all network activity because we buy gas when it's cheap, and it would be higher, but higher than 5% during low activity. But many miners do not mine below one gigaway. So you have to pander to the miners that will accept low gas prices, and when we have more gas in reserve, we use a lower gas price. So this means that we have a nice equilibrium that if we got low, we'd pay more and we pay less when we have more, which results in a long term equilibrium.
00:23:12.406 - 00:23:51.590, Speaker A: We wouldn't want to have super equilibrium because that would mean that we're paying too much. We want to pay precisely as much as we need for there to be a large reserve. There was for the entire month of September something called Fairwind. That was like eating up the ethereum network and causing gas prices to not fall below one gigaway for the entire month. In fact, for the most of September, they were at ten gigawatts. So we didn't buy anything and we were fine. Because we have such large reserves of gas, Fairwin would have had to have been an attack on true USD for us to run out of gas.
00:23:51.590 - 00:24:40.514, Speaker A: And because we buy at a lower gas price than when the gas is refunded, we get a really nice arbitrage because we buy gas at zero point 21 gigaway, but most transfers happen around ten gigaway. Finance's transfers, for example, happen at 40. So because of that difference, we get a net gain of about 50 x and we spend on average one dollars per day on this. So it's a very good investment from our founders perspective. I was actually able to actually convince them that this was a good idea. So last feature is blacklisted contracts. So we prevent certain contracts from receiving our currencies and it prevents a surprisingly common mistake.
00:24:40.514 - 00:25:25.640, Speaker A: So now for the giggle time, look at all these people losing their money by sending it to the token contract. So here's Dai, someone sending 500 die to the Dai contract. Here's. Tether. Someone sending 51,000 tether to the tether contract. There's USDC. Someone sending this.
00:25:26.490 - 00:25:30.806, Speaker B: Can you explain a bit more about the gas reserve? What does that mean exactly?
00:25:30.908 - 00:26:06.980, Speaker A: Okay, I'll pull up the code. It's open source trust token, true currencies and contracts, gas refund token. I'm going to try to make this bigger, but I don't know how. We have two kinds of gas sponsorship. We sponsor for S store and we sponsor for contracts. So the S store first, this is our contract sponsorship. So will we deploy what's called a sheep? A sheep kills itself when its master calls to it.
00:26:06.980 - 00:27:04.130, Speaker A: So the way that this works here's the assembly. When you deploy a contract, it invokes the constructor which returns the data in the contract. So the call data that we pass to the constructor first pushes 27, which is the length of the sheep. It duplicates it. So now 27 is there twice. And we push the number nine, which is the offset return data size, which is the which is the easiest way to push zero onto the stack. It's actually cheaper than push zero return data size and code copy, which copies the yeah, it takes the it takes the code that was passed to the constructor.
00:27:04.130 - 00:27:44.990, Speaker A: It copies it into memory at the parameters that were previously passed, nine and 27. So it offsets the sheep, which because it's offset nine and 27 is the length of the sheep and then it returns. So because the sheep is now in memory, it returns it. The rest of the code is the sheep, which pushes zero on the stack. The caller is the person that called the contract. Then we push ourselves. So this is the expected address then XOR to figure out if it's invalid.
00:27:44.990 - 00:28:51.000, Speaker A: Because if the caller differs from me, which is the issuer, then I don't want you to be able to destroy my sheep. Then I do jumpy, which is the conditional jump, so that if someone else tries to suicide our sheep, then it fails and then we do self destruct so that destroys the contract. So the other one is much simpler, it's the gas refund 40. Here's 15, for example, we load the length of the array, if it's greater than one, that is, then we're able to refund 15,000 gas, then we store zero in that location and then we change the length of the array. So there's an array that's full of gas and we refund it. There's an overhead to refunding gas. So gas refund 15 only nets about 4000 gas, but the larger ones are more efficient, such as 30.
00:28:51.000 - 00:29:38.680, Speaker A: The most common one we use, for example, for transfer from is gas refund 39, which does both suicide a contract and it also sets a one to a zero. So here's the other sponsor gas one. It just populates an array, we do nine at a time, so it creates nine slots, sets them to one and that's all. We did this in assembly because we weren't satisfied. It actually resulted in an improvement over not doing it in assembly and it affects our cost savings and if we had done this sheep in code instead of in assembly, the cost and overhead would have been substantially higher, something like nine times higher.
00:29:39.770 - 00:29:46.360, Speaker B: Is there a case where s store is more expensive than whether deciding to store gas or not?
00:29:47.390 - 00:30:35.554, Speaker A: So we decide whether or not to refund 15 or not conditionally. And so if your transfer creates a new account, then we're going to give you more gas back than if it doesn't. Because we know during execution how much gas we're going to use, we know how much we're going to refund and that's all open source in our trust token true currencies GitHub, which also contains the instructions for getting rinkobee tokens for this guy. I'm going to set up COVID during this hackathon. Yeah, it which is always a scary thing to do. Cool. I'm out of time.
00:30:35.554 - 00:30:37.520, Speaker A: Thank you. Thank.
