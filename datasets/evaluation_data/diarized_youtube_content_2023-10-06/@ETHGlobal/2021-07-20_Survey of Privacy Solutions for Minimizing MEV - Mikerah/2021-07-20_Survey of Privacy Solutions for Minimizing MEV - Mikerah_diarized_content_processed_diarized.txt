00:00:01.050 - 00:00:46.860, Speaker A: Hello, everyone. I'm Akira, and today I'll be going over a few solutions that are mainly like privacy focused or cryptography focused for minimizing mev. This is a current work in progress that we're doing as part of a flashbots grant. So if you have any feedback, any questions, you can always just reach out to us. And also, this kicks off the whole privacy part of the talks today, so we'll also have a panel afterwards, so you can ask your questions during that time as well. So I guess a quick recap of what was discussed over the day over the other talks. So mev is a very multifaceted problem, manifests itself in different ways.
00:00:46.860 - 00:01:40.254, Speaker A: As such, we have different ways to solve it. And keeping that in mind, we know that not all mev is bad. In fact, some of it is just going to be as part of building financial applications. And the goal of this talk is mainly to discuss how to use cryptography in order to solve mev. And we'll look at ways in which people can try to use these solutions today in their applications or whether or not make sense. Just have this as like, a layer one solution, and then later on in the panel, we'll dive more into that aspect as well. In addition, we'll briefly go over some directions that we're pursuing as part of this research as well.
00:01:40.254 - 00:03:01.430, Speaker A: That's way more experimental. I'm not sure if we'll have time for that. So in the context of mev, what exactly do we mean by privacy? So there's a few considerations that you might want to think about when thinking about privacy in this context. So this is a concept of pretrade privacy, which is, if you're sorry, which is the context of trade. So you send a trade to be spent, but oh, no precinct. Okay, so fill trade privacy is if you're sending a bid and it's a losing bid, then you don't want the mempool to see that. The concept of pre trade privacy, which is slightly subtle, is that you don't want a failed transaction to be seen in the mempool.
00:03:01.430 - 00:04:20.000, Speaker A: So the subtle between these two, the differences between these two are very subtle, which is why I kind of pose up there. And then the concept of complete privacy, which is the most desirable one, which is probably what most people think is when everything is hidden from the mempool until it's time to execute the transaction. And the focus of today's talk is effectively on complete privacy solutions. I guess a very short overview of the design space for just solving mev. In general, there is the side of using more like math and economics for solving these problems. And I think later on in the talk and earlier in the day, people discussed those kinds of solutions, and then today we'll be focused mainly on the cryptography side of things. So there's quite a few different solutions that people have come up with over the past years to solve front running and mev and Ethereum, we'll briefly go over each solution and I guess as part of this being an ongoing work, if you have any more suggestions or ways to combine these, just reach out.
00:04:20.000 - 00:05:21.410, Speaker A: So first we'll go into commitments. Cryptographic commitments are a really easy tool to use for trying to solve firm running for your application. So briefly you can commit to a message and then later on you reveal it whenever you want. And so in a specific context, what you do is you would commit to a transaction and then once it's added to a block, you can reveal the transaction later and then have it execute. The main issue with doing this is that you need an extra block delay because now you need to execute your transaction, which is not the best in terms of user experience for the users of the application implementing this. But a good side of using this is that there's typically libraries that allow you to just do this as a drop in replacement. However, due to this one block delay, it's really deployed in practice.
00:05:21.410 - 00:06:25.800, Speaker A: So from commitments you can use ZKPs. And I guess most people here are familiar with ZKPs. Very briefly, it allows you to prove statements without revealing important details about that statement. So in this case, you might want to prove something about a transaction such that the gas price is within a specific range and that it's a valid transaction but you don't want to reveal the transaction on chain because we're trying to make it such that people can't arbitrage kinds of transactions. And the nice thing about ZKPs is that they're quite flexible. So you can sort of aggregate many transactions together and prove them in a ZKP. And typically we've seen this applied at both the protocol layers in layer one blockchains and at application layers in the forms of different L two S.
00:06:25.800 - 00:07:34.560, Speaker A: And they tend to not have as significant of a delay as the commitments that we just looked at. And there's also a lot of tools for using CKPS as well. So the next one is timelock encryption, which is also just an application of using commitment schemes. So in vanilla commitment schemes, what you do is you commit to a message and then you refill it whenever you want. But with timelock encryption there's like a set date by which you have to reveal the message or a set time specifically. And using time lock encryption you can build these time capsules in such a way that you needed to solve a puzzle and the puzzle will reveal the commitments. And this allows you to effectively prevent front running in your application.
00:07:34.560 - 00:09:04.060, Speaker A: And this hasn't seen widespread deployments, but it does work at both layer one and at the protocol layers and it has the similar issues as commitments in terms of the delay provides to users. And the tooling for this isn't as ready compared to CKPS. Then there's Threshold Decryption which I think was brought up earlier today in a separate talk. So in Threshold Decryption you have quorums of miners or validators that each have a share of a private key for decrypting messages that users encrypt. And depending on whether you're an approval worker proof stake system, there is sort of delays on when you can decrypt these transactions. Most schemes I've seen usually have at least a one block delay on executing the transaction because you have to decrypt the transaction. And as such, usually this is done at L One, but as you'll see later, there's an attempt at doing this at the application layer so that it's a drop in replacement or drop in addition to your DAP while you're building.
00:09:04.060 - 00:10:37.138, Speaker A: So then there's SGX, which is also another way that's been proposed to solve mev. And SGX is technology by intel in which you can store data in these secure enclaves and the data can't leave these enclaves. So all the computation and accessing the data has to be done within these enclaves and it's isolated from the rest of the OS. So pretty much what you need to do is find a way to sort of split up the encryption key for accessing the enclaves and that's how you would do your computation. So practically how this is used for solving MEP is that you can verify all sorts of complex statements like the ability of transactions and blocks and stuff like that. So what you do is you would split up this primary key that we use to sign messages to the enclave and then the SGX can ascertain the validity of the transactions. And then depending on whether you're in a proof of work or proof of stake system, you either get the unencrypted transaction data or proof that your transactions are valid and then you can use that as part of consensus.
00:10:37.138 - 00:11:44.480, Speaker A: And depending on how it's instantiated, you might get just as good as latency as the current flashpots setup. One of the downsides though is that you do need to rely on intel for being an honest manufacturer, although there are some attempts at making some open source versions of this kind of tech. And lastly there's MPC, which is you can kind of consider as a software only version of SGX which allows you to compute arbitrary functions without knowing the inputs. In a sense, Threshold Decryption is an instance of MPC and more famously I guess, MPC is known for being inefficient. But depending on the constraints of the system it might not be as inefficient as one might think. However, it does introduce more trust assumptions on node behavior that might not be desirable depending on your use case. So I guess we're nearing the end of the talk.
00:11:44.480 - 00:13:05.810, Speaker A: Some current work that we're looking into in addition to those other solutions is the use of Malleable cryptography. So very briefly, Malleable cryptography lets you do transformations on encrypted data. So the idea here would be to use something like some homomorphic encryption that will allow you to morph encrypted transaction so that you can probably still do some execution on it if it's possible within an efficient amount of time. And then the other primitive we've been looking at is called Order revealing Encryption, which mainly has been applied in the database search domain for providing searching functions over encrypted databases. And we think this might be a promising way for providing similar functionality for encrypted transactions. It does kind of reduce so far from our work, it does kind of reduce to the threshold decryption case, so we're not sure if it's particularly useful, but we do have a write up that I can share more widely, if you're interested. And something else that we're working on is we're trying to look at using MPC for providing complete privacy and Flashpots.
00:13:05.810 - 00:13:24.890, Speaker A: So in the same way that Mev SGX provides complete privacy using SGX and Flashpots, we're looking at using some off the shelf MPC frameworks towards that goal as well. So I guess that's the end of the talk and so it's time for the panel.
