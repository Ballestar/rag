00:00:01.130 - 00:00:26.514, Speaker A: Hi, folks. Can you hear me okay? Yep. All right, great. So not going to really describe myself at all, but this is not my domain of expertise, mev. I mean, it's interesting. Me and Phil talked about it many years ago now, which is sad because we're all aging and dying. But yeah, this is not really my area of expertise.
00:00:26.514 - 00:00:46.490, Speaker A: A lot of the talks here have been really good, really interesting. So I don't want to pretend to be I'm an expert. All right. I'm already accidentally clicking things. All right, great. So transaction level hinting is considered helpful. Yeah, it'll be a while before I actually get to what that actually means.
00:00:46.490 - 00:01:31.162, Speaker A: So take some time, relax. We're going to go down memory lane a little bit here. Ethereum has an identity problem, and it's sort of come up in some of these discussions, and I'm glad I made a slide about it. A lot of people in this space make their living and make quite a good living because Ethereum is a casino. And then there are some of us who are foolish and believe that maybe we should be making a system for verifiable cryptographic attestations of simple and safe computations. Which doesn't sound much like a casino, right? I mean, it sounds like they're kind of opposites, but that is kind of like a lot of the people in the space is one or the other. And then, of course, there's people who think it's alien communication or whatever.
00:01:31.162 - 00:02:18.394, Speaker A: Right? Really? Why isn't it both? I mean, we can do both, so we probably should do both given where we are in the space. And so here's the thing about mev. If you think Ethereum is like the house of a casino, like it's like operating a set of casino games for people to gamble, then you may think that exploiting mev is breaking the rules. Like, you're the house and you're supposed to be fair and you're not really being fair. You're letting some people cheat, and that's not cool. But if you think Ethereum should be safe, then you must also want it to be predictable. And what I mean by predictable is just very briefly, a secure, in my definition means that other people can't tamper with it.
00:02:18.394 - 00:03:30.958, Speaker A: Safe means that it does what you expect it to do and that it has predictable behavior. And so the problem that we really have well, mev, is contentious because it forces us to recognize that Ethereum has problems on both of these axes. Right? So what we're going to get into here is some of these broken Zany models, with all due respect to Gavin Wood and the other people who were instrumental in the development of the system and the time crunch and the economic crunch and what have you, that being said, let's still go through some of the weirdness of the model. Right? So one of the weirdest things hit that button again. One of the weirdest things about Ethereum is that by default, which is very unsafe and very unusual in any sort of computer system, and with all of the respective computer scientists that have spoken before me, I'm a little confused as to why people don't bring this up more often. But we have transaction contention as the default. So in pretty much any toy system where you have multiple users, they can't just muck around with each other's state information.
00:03:30.958 - 00:04:03.030, Speaker A: They can't just muck around with each other's memory. Windows 31 didn't have this problem, right? Well, whatever. So then we have this other thing that's related to this, which is just broadly speaking, Ethereum is a state machine, right? We use this term all the time. We talk about it all the time. When we talk about Ethereum as a world computer, what we're talking about is we're talking about globally shared state. And that is actually where mev in my opinion, there's a lot of different types of mev. Obviously, people have given a lot of different definitions.
00:04:03.030 - 00:05:06.414, Speaker A: But ultimately the thing that we're trying to minimize are the problems that are created by users being able to muck around with each other's state when they shouldn't or when they don't expect to. So maybe they're actually playing a game where part of the game is who can flip this bit first. But then there's times where there's other games that people are playing and they don't realize that another player can come in and flip the bit out from underneath them. And so there are a lot of problems in Ethereum come from the way that we handle this merklized data structure, which is kind of what I struggle with and wrestle with as a large part of my day job, is dealing with these stated difficulties and these will actually come into play later. So keep them in mind because anytime that you're trying to verify a block or generate a new block, you're going to run into all of these stated difficulties. So it's very difficult to read the data out of the Merkel tree. That's going to be very difficult.
00:05:06.414 - 00:05:45.670, Speaker A: It's also very difficult to write data for similar reasons. It's impossible to prefetch because all of your keys are random, right? So there's no way that you can cache data at all. Totally random, extremely frustrating. Your caching is like, okay, just throw like 120 gigs of data into Ram. That's not really awesome. The caching that does exist in the existing clients is almost entirely focused on consensus, not on proof generation or general retrieval. And so again, if we're using Ethereum, we're using it because of proof, right? We're using it because consensus provides us a type of proof.
00:05:45.670 - 00:06:45.546, Speaker A: So if we're not leveraging that proof generation, then why are we even using Ethereum in the first place? Why don't we just use a centralized database, as people love to say? And I think that that's a totally valid concern. And the other thing that's pretty obvious is we can't scale storage forever, right? So we have all this state, we have all these weird things that are going on in state that are these weird side effects. And at some point we're going to run out of disk space. We have to have a way of truncating the chain. And so when we talk about state rent and whatever it's called now and regenesis and there's a whole bunch of things in the Ethereum research community around how do we prune state. And this is going to be very relevant to the activity of block building and block production. And so right now we have a reality where if you use Ethereum, you can't get the summary.
00:06:45.546 - 00:07:24.540, Speaker A: If you're using uniswap info, you're relying on the graph to provide you the summary of the Ethereum state that you use to transact with. So if you're making investment decisions based on uniswap info, you're actually trusting the graph to tell you what the state of Ethereum is. And there's no way for you to verify that. And ideally, that graph entity, the graph indexer or what have you, would be an entity within the Ethereum consensus model. There are people that you could slash within Ethereum natively. It would be a native part of the protocol. And right now there's really no way to do that.
00:07:24.540 - 00:08:05.074, Speaker A: So if you want to keep it running, you have to address some of these broken models. Right? So the stated difficulties, the issues with Ethereum state, I think absolutely are super high priority. That's actually why I started working on 1559, which is a weird historic aside. But we have to start addressing these state issues anyway, and we have to address these mev issues anyway, so we're going to address them together. So these are a list of EIPS that are starting to get at the mechanisms that I'm describing. So the first one, most important, one transaction envelopes. We can make new transaction types.
00:08:05.074 - 00:08:37.970, Speaker A: This is insanely important. This is like a superpower for Ethereum. Just put a little plug here. Cosmos SDKs obviously supported this for a very long time, but to have transaction types in Ethereum is a significant improvement. Obviously, no new transaction types, no 1550, 915, 59 will have a huge impact on the mem pool, which no one else has brought up yet. And that will in turn have a huge impact on mev. As an aside for anyone who may happen to know and can send me a message somewhere, I don't know how we actually have multiple.
00:08:37.970 - 00:09:39.458, Speaker A: We're putting each new feature in a new transaction and I don't know how we unify those so that we have one transaction type. I don't know if anyone's actually described that yet. Optional access Lists so this is a list of addresses and storage keys that the transaction plans to accesses outside the list are possible but become more expensive. So this is basically a way of hinting the block builder which is currently the block producer, and giving them some clue about what the memory access pattern needs to be when they see the transaction in the mempool. So they can start preloading some information before they actually have to go build the block. Again, this is because there's some runtime brutality in the ethereum system that's unavoidable, right? So because of how state works, we have to start giving these hints because we're not going to be able to build blocks otherwise, period. And then a block access list just takes those access lists of the transactions and puts them all into the block and makes a little field for them in the block.
00:09:39.458 - 00:10:23.982, Speaker A: And then hashes that just like you have transactions and then the transaction hash, or you have receipts, and the receipts hash. And again, this is for the purposes of facilitating Statelessness. So there's a similarity here. There's a relationship between statelessness and the reduction of mev. And so my suggestion here is that because Tina sort of again, this isn't really my area of expertise and Tina asked me to give a talk and I'm happy to give. So I kind of just threw this thing together, just sort of based on some conversations I've been having with people, frankly, over the years. And so my basic suggestion is a new transaction type which adds two predicates, very simple predicates.
00:10:23.982 - 00:10:55.802, Speaker A: Only apply this transaction against these merkel leaves. So you reference the ethereum state as merkel leaves that you want this transaction applied against. That's the first one. And the second one is only include the transaction if this set of merkel leaves has these values. I'm sorry, there's some lines missing at the end of the block, right? So basically, if this transaction results in me having a bunch of money at the end, run it. If it doesn't, don't run it. These are very simple.
00:10:55.802 - 00:11:53.600, Speaker A: This is very much like this is not a steal a man argument, right? This is just to sort of get our foot in the door and sort of start to understand the power of some of these concepts. These are pretty tricky predicates to use, but they're sort of like a generalized solution to slippage in uniswap, right? It's like, well, can we actually get all transactions to just sort of have that property? And this is a way that we can do that. These are pretty easy to implement, but they're pretty difficult to use. We could make more complex comparators, sort of more traditional ones that actually somehow inspect the value and know the value. That's theoretically possible with something like homomorphic encryption or some sort of weird mercury homomorphic hashing, where you can assert that a greater value has a greater hash or some zany thing. But that's way out of my field of expertise. I'm sure it's theoretically possible, but I have no idea how you would start to do that.
00:11:53.600 - 00:12:47.710, Speaker A: And we're already mucking around a lot with mercury that's also another one of my hats is messing around with mercury on the Cosmos SDK side. I think that there's a lot of opportunities there. So we probably could do this. So the benefits of this system is now block producers, builders and other transactors know which transactions will be contentious without needing to execute them, if you trust the statement in there. But you can even do a light verification with ETH call that will verify the hint that was provided with the transaction. And that's very powerful, right? Because you may know, because you can't just look at the to and the from of a transaction and know if it's going to mutate the state that you care about. That's the important piece that's sort of missing from this slide.
00:12:47.710 - 00:13:42.018, Speaker A: You need these hints because of the way that internal transactions, quote unquote, work. And ultimately the goal of these types of additions to Ethereum is to just remove, get us out of a contentious first mentality. And I could go on and rant about this forever. When we were working on super early ETH two, like super early me, Vlad Vitalik and Greg Meredith and occasionally guest stars would show up. But we were always talking about removing having asynchronous transactions on the chain, right? It's this synchronicity that's a problem which has also been talked about during this conference as well as the shared memory. And the two of them together is just like a lethal combination. And so we can work towards removing those things by adding new transaction types over time.
00:13:42.018 - 00:14:17.600, Speaker A: That move us closer. Iteratively move us closer to the correct solution and do so in a relatively quick pace without necessarily having to make l two changes or things of this sort. And so I've kind of already hinted at this. So Phil mentioned this blog post or this thread in his talk. It's from Vitalik. He's basically explaining how we can separate block proposers from block builders. The highlighted part is sort of the important thing.
00:14:17.600 - 00:15:16.880, Speaker A: The idea is that we have an outside market of actors that we call block builders produce bundles, which is basically like an mev bundler consisting of complete block contents and a fee for the proposer, right? So we're basically saying, well, let's generalize how Flashbots works today. And what I'm suggesting is let's actually offload some of that computation in the block building to the users themselves, ultimately with the goal of, well, if this new transaction type is used, block builders should charge less for these transactions to be included. Which is an interesting aside, right? Because the users are doing computation on behalf of the block builder, somehow, they should get a rebate for that. And that's a significant discount to the actual block producer. So they should get a rebate for that as well. Okay, I will wrap it up in two minutes. All right.
00:15:16.880 - 00:16:21.042, Speaker A: The perfect block creation has these properties, pipeline, data access, constant time, construction and verification in relation to bytes included. This is important because it actually provides it solves some pricing problems that we have that are theoretical, that I won't have time to get into. And then the goal is that we want to achieve like Bitcoin level mev, right? Bitcoin has mev, but no one really talks about it because it's an application specific chain. So we should be able to achieve that by actually reducing the amount of state computation that block producers need to do. Also, many Ethereum killers separate transaction ordering from execution and they do that for scaling purposes, but we're doing it for a similar reason and we'll also achieve a scaling benefit as well. Also worth noting, there's some new clients on Ethereum that by again sort of addressing how mercalization is done. They can greatly expand the amount of gas that can fit into a block.
00:16:21.042 - 00:17:06.994, Speaker A: And so it's all related, right? All these things have some intersection, have some relation. All right, so next steps, someone write an EIP, someone implement it. That's easier said than done. It should be really easy to get this on the main net because it's a new transaction type, it doesn't have to really interfere with things. Some of the features we may want to add to the system is we may want to modify ETH call to generate the hints that we need and we may want to build services that make it easier to extract state from the existing chain, which is something that I'm already working on. And there's a link provided in the slide and that's it. I'd like to give thanks to the pirate ship tina phil.
00:17:06.994 - 00:17:17.540, Speaker A: Edgar. Lev et. And you know, over the years I've talked about this idea to a lot of different people and I can't really name them all and thank them all, but thanks to those people for listening to me as well. And thank you.
