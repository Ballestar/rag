00:00:00.570 - 00:00:31.880, Speaker A: Welcome. We are Near Protocol and we are here to talk about centralizing the web again. But more specifically, this is a workshop to test drive our DevTools. So we're going to have two people on the stage today. My name is Jane and this is Al X. Hi everyone. Since I have the mic, I'll just do a quick intro for myself.
00:00:31.880 - 00:01:12.574, Speaker A: I've been in software for a long time, but I'm actually fairly new to the blockchain, so this is fun for me. Before that I did various things including like Logitech, Google. My other previous recent job was actually working on Pokemon Go. So yay, I know a bit about scale. So hopefully we can get blockchain to be able to support an app like Pokemon Go. That's the goal anyhow. So what is near protocol? Near we are a shorted layer, one protocol.
00:01:12.574 - 00:02:04.434, Speaker A: And specifically what are we trying to do different from other protocols? We are focusing on developer friendly tools and end user experience. Basically two main points. Like if you are an engineer trying to develop apps, you should be able to get started really quickly without installing five different things which kind of don't work with each other very well. And ideally you'd want to use languages that are already existing and not learn a new thing. So that's our focus from the engineering side and from the end user side. We also want to built in a few things into the protocol itself so that it's easier to make user friendly app. Like what I like to say is that for a really popular app, my grandma has to be able to use it.
00:02:04.434 - 00:02:11.720, Speaker A: And I'm sorry, I'm not going to make my grandma install MetaMask. That's just not happening. So until we can fix that.
00:02:13.610 - 00:02:14.018, Speaker B: It'S.
00:02:14.034 - 00:02:51.874, Speaker A: Going to be challenging to have a real popular app and that's where we're trying to make a difference. All right, so where are we now? We are not main net yet. We have a fully functioning DevNet which everybody can try. And this is going to be the point of this workshop. And we are at the point where we can run a multi node network and pretty soon getting to testnet but not there yet. Cool. And basically that's all the slides I have.
00:02:51.874 - 00:03:26.190, Speaker A: So now we're going to go and just demo everything. So what we're going to do is actually do some live coding. So we're going to have two things that we need to do. First of all, somebody come up with a simple app that we're going to code live. This is going to be cool. Okay, sure. Well it's funny that you say that because now we have an example of that that's going to be trivial.
00:03:26.190 - 00:04:03.902, Speaker A: Do it in three minutes. Okay. Open your studio, click this particular template, create. So when we go here, this is an online ID. If you start from a template, it will actually give you some starting code to play with and you can kind of browse around. The contract itself is defined in main TypeScript file. This is using TypeScript, which is a standard language.
00:04:03.902 - 00:04:27.496, Speaker A: This is cool. If you know JavaScript, you're going to be able to do this, I promise. Cool. So this is already a to do. I'm going to click run. What's happening right now is this online ID is actually deploying the contract to our hosted DevNet. Whoa.
00:04:27.496 - 00:04:30.252, Speaker A: What happened? Did I pick the wrong template?
00:04:30.316 - 00:04:31.920, Speaker B: Yeah, I think so.
00:04:31.990 - 00:05:16.610, Speaker A: Oh, my God. There was like one thing I had to do, right? And I messed it up. Well, we'll try again. Yes. So as I was saying, what this is doing behind the scenes is deploying the smart contract to our hosted DevNet and the contract is deployed. And now we can go and actually add our to do.
00:05:25.950 - 00:05:27.100, Speaker B: Caps. Look.
00:05:31.510 - 00:05:36.694, Speaker A: Bam. Done. Okay, but let's actually have a different example so that we can do refresh the page.
00:05:36.732 - 00:05:37.830, Speaker B: Is it persistent?
00:05:38.250 - 00:05:55.696, Speaker A: Refresh the page. All right, yeah, it works. But now let's actually have a different example so that we can we can.
00:05:55.718 - 00:05:56.972, Speaker B: Build to do from scratch.
00:05:57.116 - 00:05:58.764, Speaker A: You want to build to do from scratch?
00:05:58.812 - 00:05:59.600, Speaker B: Whichever.
00:06:00.440 - 00:06:02.710, Speaker A: How about we build that locking thing?
00:06:04.200 - 00:06:09.044, Speaker B: But that's a prepared all right, well.
00:06:09.082 - 00:06:35.116, Speaker A: Somebody has to come up with an idea and code it to do list.
00:06:35.218 - 00:06:36.728, Speaker B: Okay, I'm coding.
00:06:36.824 - 00:06:46.050, Speaker A: You're coding. So he's going to code and I'm going to just comment on what's happening. And we're going to have all going to have lots of fun.
00:06:46.900 - 00:07:00.630, Speaker C: Just before the fun, if I could ask that the beverages go out of the amphitheater. Thank you. And food too. And now the fun begins. Sorry.
00:07:05.980 - 00:07:35.150, Speaker B: Okay, so we're going to start from scratch. Instead of cloning the existing to do, we will clone a Hello World example. So Hello World doesn't have much as in. It just has. Hello, world.
00:07:36.640 - 00:07:38.668, Speaker A: It's a very important app, though.
00:07:38.834 - 00:08:33.502, Speaker B: Yeah. Okay, so the only function we have in the smart contract today is Hello World. We will have more so we can add a to do. And so the way we're going to develop because let's pretend I have no idea how to build it, we're going to open some other template and we're going to be taking inspiration from it. So let's use a guest book so that we don't literally copy paste code from the to do. So the way you interact with the storage on near is slightly different than it is in Ethereum. Instead of having sort of class members, you have an API to the storage, which looks more similar to the way you do it in web two.
00:08:33.502 - 00:08:38.210, Speaker B: Like if you're building a node JS application, you're probably going to be using some sort of API, like firebase.
00:08:38.870 - 00:08:41.730, Speaker A: Yeah. This is basically a key value pair of storage.
00:08:42.630 - 00:08:51.880, Speaker B: Right. And so I guess what we're going to do okay, so we see the API, it's set bytes or set U 64 that should be sufficient to start.
00:08:53.770 - 00:08:55.670, Speaker A: There should be also a set string.
00:08:56.250 - 00:09:38.448, Speaker B: I think it's set item. Maybe we will try set string first. Okay, so one thing we will need is because to do is a list of things we want to do. And we don't have a list, we're going to simulate the list. So the first thing we're going to do is we're going to say let and so we need some sort of a key. So the key, let's say it's next item and then let's just store it. So setItem is effectively setting a string.
00:09:38.448 - 00:09:40.700, Speaker B: We can try set string. I don't think that will compile.
00:09:42.560 - 00:09:48.264, Speaker A: Well, we'll find out. We do need an example of compile error for a real workshop.
00:09:48.392 - 00:10:09.636, Speaker B: So the library function to convert U 64 to string is near string. I actually have no idea why it is not something more standard, I don't know. Okay, near stir will convert next item to a string. I guess TypeScript does not have a standard function for two string text. That's the argument that is passed should.
00:10:09.658 - 00:10:11.350, Speaker A: Be just two string. No.
00:10:14.360 - 00:11:00.450, Speaker B: But I guess there is a reason we have near stir. Maybe something doesn't work. Well, I guess this is unnecessary. Okay, so that makes sense, right? We see. We get the next item ID, store the item, increase the next item ID and we will also need get to Dos. It would work well, I guess if you do plus plus here, it will naturally not work because plus plus would happen after it is stored. Like if you do this, that should work, no, right? Yeah, that's not happening.
00:11:00.450 - 00:11:37.996, Speaker B: Right. In general, we model it more or less after node JS experience. With the idea being that one of the ideas is that the ecosystem of JavaScript developers is a little bigger than Solidity developers and so it would be nice to try to convert more of them. And so the hypothesis is that if you have experience closer to what they used to, you might be able to convert them. Okay, so get to Dos returns array of strings. What's wrong with the array of strings?
00:11:38.188 - 00:11:40.210, Speaker A: It wants you to return something.
00:11:40.820 - 00:12:10.730, Speaker B: I see. Okay. And so as you can see, this IDE is already better than notepad. But even then, like remix for example, for Solidity because it actually does more sophisticated checks. So you can see array string is underlined because I'm actually not returning array of strings. So this is more sophisticated analytics than what any solidity IDE does today. And that's because TypeScript is a common language which has a lot of tooling already available for it.
00:12:10.730 - 00:12:37.450, Speaker B: So we're going to get the same next item. That's not how we create array of strings. Okay, let's google it.
00:12:40.220 - 00:12:43.240, Speaker A: I think you may need to pass in the size.
00:12:43.390 - 00:12:44.908, Speaker B: Well, I am passing the size, right?
00:12:44.994 - 00:12:47.036, Speaker A: Round brackets or something like that.
00:12:47.138 - 00:12:55.324, Speaker B: Okay, let's see new array. Yeah, but how does it know the type of the element.
00:12:55.372 - 00:12:56.688, Speaker A: I don't need the type.
00:12:56.774 - 00:13:05.012, Speaker B: Oh, it doesn't care. Well, I guess, yeah, at the very least I need to use round brackets, right?
00:13:05.066 - 00:13:05.670, Speaker A: Yeah.
00:13:08.520 - 00:13:53.526, Speaker B: Oh no, I think this works. Let's see, let's try get string. Okay, so now one thing we can try to do is we can write a test for it testing. Everybody always tests their code, right? That's how it's done. Right? Okay, let's see. So there's some boilerplate code here. It uses Jasmine, which is a standard testing framework for JavaScript.
00:13:53.526 - 00:14:17.206, Speaker B: And the way you communicate with the smart contract is you need to say which methods you expose methods. The view methods is something that would be, I guess it's called View in solidity as well. Right. A method which cannot change the state. That's my guess. Okay, so the view method is something that does not change the state. So in our case that would be get to dos and the change method is something that does change the state.
00:14:17.206 - 00:14:50.190, Speaker B: So set to do then we can write a test. Let's have a test which says simple to do test or rather if I add new elements. And so before all, let's say is there a contract exposed? Yes. So contract set to do and you just pass arguments. Unfortunately you cannot just pass position arguments. That would be the best. Right now the interface is that you need to pass a dictionary of arguments.
00:14:50.190 - 00:15:32.670, Speaker B: But let's add two to two elements to to do result is and so you can use async await, which allows you to effectively write a code which looks like it's serial, but it uses asynchronous calls to the smart contract. And so we expect the result to be probability of this working zero. You know why that's just a prediction doesn't compile well, we can kill the second thing.
00:15:32.740 - 00:15:34.382, Speaker A: Okay, now it's above zero.
00:15:34.516 - 00:15:36.480, Speaker B: Above zero. Okay, let's see.
00:15:37.590 - 00:15:42.014, Speaker A: So when you click test oh, you still have a compiler.
00:15:42.142 - 00:15:44.738, Speaker B: I still do have a compiler, yeah.
00:15:44.904 - 00:16:18.590, Speaker A: But while Alex is fixing the compiler, I can talk about what would actually happen when you click test and things compiled. So this online ID on test will actually deploy like a test specific instance of a contract and that instance will have a clean starting state so it will not have any data and then the tests are going to actually run against that instance of the contract.
00:16:19.490 - 00:17:01.530, Speaker B: So the compilation error was that next item was U in 64 and for array size and for the for loop it's expected in 32. So now that this is fixed, the test doesn't pass, it returns an empty array. The reason for that that's going to be easy to fix is that in the test in the before all, when I sent set to do, I did not put a weight in front of it. So it queued it asynchronously called two of those set to dos but they didn't finish and so by the time it requested them, the requests were not processed yet. Okay, let's test this.
00:17:05.020 - 00:17:06.632, Speaker A: Did you do this on purpose?
00:17:06.776 - 00:17:11.950, Speaker B: No, but this is not the first time I do this mistake and it still doesn't work.
00:17:17.660 - 00:17:20.920, Speaker A: Wait, you can actually read the error?
00:17:21.280 - 00:18:09.684, Speaker B: Well, I see the error. It returns an empty thing. Right. So now let's do something cool specifically, and let's see if that works. We can log as we go, so let's do you can use near log. And so even though this is the back end code, this is the smart contract code as you run it, unless something breaks, that is expected to appear in your development console. So effectively the way it works is that we stream all the messages from the contract execution and we can see total elements is zero.
00:18:09.684 - 00:18:53.400, Speaker B: That is not at all what we expected. But you see, the debugging process is pretty quick now, because I can log something from the back end side, I can see that the next item, which was expected to be two, is zero. Right. So the problem is that next item did not increase. And so now let's see what actually happens after we store it. So it makes sense to print both local value and global to see if the storage works. Let's see.
00:18:53.400 - 00:19:40.290, Speaker B: Oops. Oh, wait, that's the wrong studio. How it doesn't compile anymore. That's because I'm trying to add an integer to a string. And so that's also a big difference with building Solidity. Right? Because if your smart contract fails on Solidity, if the transaction fails itself, especially, then the logging just disappears. It depends on the toolings, but more often than not, that's what's going to happen.
00:19:40.290 - 00:20:19.234, Speaker B: Well, I guess something fails on our side as well. The application comes in browser, and on the network is separated one MVP pattern.
00:20:19.282 - 00:20:21.640, Speaker C: Or like how they have.
00:20:23.930 - 00:20:43.598, Speaker A: So let's see. There are a couple of questions. Yeah. So basically, what is the app structure for? Do you mean the overall ID or kind of like a high level of what goes where we see something running in browser.
00:20:43.694 - 00:20:45.922, Speaker B: Obviously something must be running in the.
00:20:46.056 - 00:21:37.060, Speaker A: Network on the yeah, okay. Yeah. So what is happening is the contract itself is being deployed to a DevNet which is hosted basically by us. It's right now a single node DevNet. And the UI that you're seeing pop up in the new window, that's essentially GitHub pages. So we're hosting the UI for this dev environment, and that way you don't have to worry about where do I put my HTML pages? And everything's already configured, so that when you're running.
00:21:39.190 - 00:21:40.626, Speaker B: Yeah, it's passing now.
00:21:40.728 - 00:21:42.518, Speaker A: Oh, you fixed it good.
00:21:42.604 - 00:21:49.000, Speaker B: It was the wrong function name. It was set to do instead of add to do, and it was actually in the log. I just didn't see it.
00:21:51.610 - 00:21:52.358, Speaker A: Cool.
00:21:52.524 - 00:22:23.614, Speaker B: But the structure so main TS is a smart contract. That's what's executed as you develop it's. Executed on the DevNet. DevNet is like a Ganache type of thing with a DevNet. Specifically, the studio has its own hosted Ganache. But if you run studio locally, you will have DevNet locally and then your tests and your front end in the way we package it are also part of your smart contract package. And so test JavaScript is something that is not going to be executed by the miners.
00:22:23.614 - 00:22:36.134, Speaker B: It's something that you execute locally in the browser, but it is part of the full package and it communicates to the contract through this boilerplate code. This is effectively the connector. Sorry.
00:22:36.252 - 00:22:43.990, Speaker A: Oh, do you want to show what happens in the network tab when you run the tests? Because that's very enlightening.
00:22:44.410 - 00:22:45.430, Speaker B: Okay, let's go.
00:22:45.500 - 00:22:50.694, Speaker A: All of these requests are actually going to the DevNet, which is like the Ganache which we're hosting.
00:22:50.742 - 00:22:55.420, Speaker B: Okay, so it's executing. Yes. It's calling submit transaction, submit transaction, get transaction result.
00:22:57.150 - 00:23:13.360, Speaker A: And if you're really into low level hacking, you can look at the request, see what's going on there. It's just sending a bunch of bytes because there's some stuff in between. So you're not going to get too much out of it, but you can figure out which URL we're hosting this stuff on.
00:23:13.990 - 00:23:22.630, Speaker B: And so now it fails because we did not redeploy the test. And so the state is not erased. So now it has four elements instead of two. That is sort of expected.
00:23:23.050 - 00:23:25.798, Speaker A: Well, right, you're supposed to click test every time.
00:23:25.884 - 00:24:09.550, Speaker B: Right? And again, the front end is part of the package, so you can very quickly build some sort of a front end. So again, this boilerplate code here, which instantiates the contract, you're again saying which methods you want to get exposed and then you effectively so there's only one div. Okay, let's not over engineer it. Will something like this work?
00:24:10.800 - 00:24:12.110, Speaker A: So let's see.
00:24:15.680 - 00:24:22.690, Speaker B: Well, we will know in a second and then let's just have a button right after contract message.
00:24:39.850 - 00:24:44.710, Speaker A: This is, by the way, now just plain JavaScript HTML development.
00:24:45.050 - 00:24:59.230, Speaker B: Obviously, ideally you would use something more sophisticated like you would use React or View or whichever have you. But for the sake of this short demo, we're going to make it simple.
00:25:05.620 - 00:25:21.428, Speaker A: The way this connects to the blockchain, we have a JavaScript library which you can import into any HTML file. And essentially then you are basically going to be writing code in JavaScript for your front end.
00:25:21.594 - 00:25:26.980, Speaker C: In the future, each of these calls are going to be a transaction.
00:25:27.560 - 00:25:57.688, Speaker B: They are transactions right now. Yes. They're going to be spread over. Right? So, yes, it goes to one of the nodes, goes through the mem pool, ends up on the block. Because the idea is that it's a BFT consensus, meaning that the moment the block is produced, you have decent certainty it's not going to be enrolled. So you're not waiting for multiple blocks for confirmation. And let's say the block production time is 3 seconds.
00:25:57.688 - 00:26:18.500, Speaker B: That means within 3 seconds it will get back to you. Like as an app developer, you might still want to have something happening during the 3 seconds to reduce the delay. Like if you know what's going to happen, like if it's a to do, ideally you will just add it right away hoping that it's going to go through. So await.
00:26:22.860 - 00:26:29.208, Speaker A: Well, in a sense, the await JavaScript API is an equivalent of doing that.
00:26:29.294 - 00:26:33.944, Speaker B: Right. So contract had to do will only return once the transaction settled.
00:26:34.072 - 00:26:36.990, Speaker C: Yeah, but what happens if somebody adds something else?
00:26:39.200 - 00:26:54.790, Speaker B: Maybe after my transaction is due, I already have. Right. So there are going to be events. They don't exist today, but yeah, it's going to be similar to ethereum. So okay, so let's test it almost worked.
00:26:57.540 - 00:26:59.760, Speaker A: Add to there's no defined.
00:27:03.040 - 00:27:43.160, Speaker B: But also have a weight somewhere where I'm not supposed to. That's because it's not an async function. Let's give it a try again. Whoop. Yay. And now we have a working to do application on the blockchain with almost yeah.
00:27:45.210 - 00:27:46.530, Speaker A: There is a UI bug.
00:27:46.610 - 00:27:56.300, Speaker B: Yeah, but besides that, let's do the simplest possible fix.
00:27:59.950 - 00:28:03.210, Speaker A: Not only we have the application, we have a tests for it too.
00:28:03.280 - 00:28:12.238, Speaker B: Yeah, we have a fully functional blockchain application with tests. What else?
00:28:12.404 - 00:28:14.960, Speaker A: Well, what was that? 20 minutes. Not bad.
00:28:16.530 - 00:28:20.158, Speaker B: Decent. Cool.
00:28:20.324 - 00:28:27.558, Speaker A: Let's do a demo of some stuff that some stuff built with near memory.
00:28:27.594 - 00:28:29.346, Speaker B: That'S not safe for work. You know it, right?
00:28:29.448 - 00:28:30.130, Speaker A: It's fine.
00:28:30.200 - 00:28:40.120, Speaker B: Sure. Okay. So we have few toy applications built on near and if any of you guys want to build something on near, please post it there as well. We have reddit called built with near.
00:28:41.050 - 00:28:43.910, Speaker A: You can be famous. You can be on reddit.
00:28:45.690 - 00:29:16.530, Speaker B: Sometime in the future you will say, I was person number three to post on Built on near, which is the most popular subreddit today. But yeah, so we have a few applications here. One is if you guys know R Place, a very popular subreddit where people just collectively draw something on like a canvas. We have this smart contract. So effectively this is running on near. You can draw something and that gets persisted and then you can be proactive. Like this is constantly changing.
00:29:16.530 - 00:29:56.078, Speaker B: It's being a little slow, I would say. Yeah. And so there's a couple of other examples to see what is possible. And the cool thing about it is that I don't know exactly how to do that, but there's a way to jump to the source code, I guess. If you just oops, if you go back to Built with near, you can actually open this link in studio, which will bring you to the development environment with that particular application in there. And then you can fork it and you can just start building from that state. So that will be your own version of it.
00:29:56.078 - 00:30:20.976, Speaker B: So if you run it, it's not going to have the same picture. State is not forked though. My internet became very slow. Okay, cool. I guess people are showing up for the hackathon, right? So you see the state is completely empty right now. It's a new forked version. You can draw something and if we're lucky and we refresh it, it's going to stay.
00:30:20.976 - 00:30:52.010, Speaker B: Yeah, cool. And we just finished. I think the next person is on here, so we can do a couple of questions. Anyone has questions? We have an incredible tool here for questions. Even if you don't have questions, raise your hand just to catch it. No questions. Cool, thank you.
00:30:57.280 - 00:31:07.570, Speaker A: If you guys come up with a question later on, we are upstairs and we also have some coffee at our table. So come talk to us and hang out.
00:31:08.260 - 00:31:09.330, Speaker B: Doesn't work.
00:31:10.660 - 00:31:11.570, Speaker A: Thank you.
00:31:14.180 - 00:31:15.600, Speaker B: The other one that I showed is.
00:31:15.670 - 00:31:17.090, Speaker C: Yeah, it's a local one.
00:31:21.880 - 00:31:22.710, Speaker B: All right.
00:31:24.520 - 00:31:38.520, Speaker C: Okay. So up next in this room is provable Oracle eyes. I'm talking about Oracle eyes. 2.0 yeah, decent, supportive.
00:31:40.380 - 00:31:44.668, Speaker B: Anything that can cause them to wasn't actually thank you. No problem.
00:31:44.834 - 00:31:46.590, Speaker A: Right here.
00:31:50.400 - 00:31:51.150, Speaker C: Yeah.
00:32:04.310 - 00:32:09.570, Speaker B: Probably want to do territory.
00:32:10.150 - 00:33:14.808, Speaker C: Let me you hello, everyone. So I will do a quick introduction on Oracleize. So how many of you know what Noracle is? Excellent. So I don't have to waste half an hour to explain that. Maybe just a few minutes. So we have rebranded like a couple of days ago to Provable to better represents our new strategy going forward. You will see that in the initial part of the presentation.
00:33:14.808 - 00:34:05.356, Speaker C: So what we have traditionally been doing is solving the Oracle problem. What is that problem? Basically that blockchain applications live in a world garden. They are not capable of reaching out to the Internet. And it's impossible to get data from a solidity smart contract, for instance. So what you want to do is basically somehow circumvent the limitation so that you can implement data rich smart contracts and have maybe a smart contract that triggers a payment or some actions depending on real world events. So on paper, the solution has been called the blockchain Oracle. Basically, and this is something that in theory has existed for a while, even before Ethereum came to life.
00:34:05.356 - 00:34:58.276, Speaker C: But in practice, the need for Oracles is very recent because of the complex smart contracts and DApps that are being built today. So the Oracle is basically an entity that somehow and it's not important how at the moment connects the external world with the blockchain. The blockchain is like isolated. So in order to keep the rest of the presentation consistent and to facilitate the understanding, I think it's useful to define the main entities with just three simple names. One is like the application in the blockchain space. We typically call it DAP or smart contract. It depends.
00:34:58.276 - 00:35:37.804, Speaker C: But this is basically your piece of code that is basically in need of data. This is the data, the data source. So basically what you would like to reach out to. And normally in a normal application you would just do maybe an HTP call to their web APIs or something to get data from there. So that's typically one line of code in most languages, right? Just call the API, maybe it's a public API, no even need of authentication. In like a few seconds you are done, you have the data. It's probably JSON formatted so you can read it very easily and very quickly.
00:35:37.804 - 00:36:13.376, Speaker C: Unfortunately, from the blockchain it's not possible. So if the application is isolated, you have the oracle that solves the problem and the oracle could be anything. It doesn't need to be provable, it doesn't need to be oracleized, it doesn't need to be chainlink or witnessnet. I mean, it could also be the data source directly pushing the data to the blockchain. For example, Thomson Reuters, which is a very common financial data source, has an integration with the blockchain. So there is no need to use a third party oracle to connect Thomson Reuters data with your application. You just go to Thomson Reuters and they do both data source and Oracle.
00:36:13.376 - 00:37:18.664, Speaker C: Unfortunately, this is not very scalable because it's unlikely that all the data sources on the internet will adapt to the blockchain and will integrate with Ethereum Mainnet for different reasons. So the ambition here is basically to enable a seamless connection with all existing data sources with a blockchain, with no need for the data sources to adapt and do the heavy lifting and the hard work that, for example, Thompson Reuters decided to do. So Provable is basically enabling death. We have been doing that since 2015 on Ethereum. We launched on September 2015 on the Ethereum Main net and the way we have decided to do it at the beginning was driven by the context of the market. We found basically there was nothing on Ethereum back then, so we had to design a protocol to get the data. We had to run the actual Oracle so be an operator to keep the service up.
00:37:18.664 - 00:38:04.340, Speaker C: And also we had to try to understand what people wanted because there was no one building applications in need of data on the blockchain back then. So it was a big gamble we decided to take and actually the traction started coming a couple of years later. So what does it mean? Well, that historically Provable, which it was called like Oracle 1.0 if you want, has been a centralized service because we were the operator running the entire thing. So this seems like to make little sense because the application like the blockchain is decentralized. This is the value proposition in most cases, like let's keep this decentralized, we don't want central counterparties. Still in most cases the data source is centralized.
00:38:04.340 - 00:39:24.340, Speaker C: Like you want to get data from a single web API or from few web APIs that maybe the end of the day get their own internal data from the same source. So what happens? Well that basically here you don't really want to compromise the security of the system, so you don't want to lose the decentralization and you don't want even basically the data to be tampered with during the delivery process. So the Oracle in between needs to somehow guarantee that the data has not been tampered with and that it's safe. Garbage in, garbage out. So if the application is perfect, decentralized and transparent, but then you feed it with garbage, the payment maybe is going to be triggered correctly but on wrong inputs, so wrong outputs, right? That's what you want to avoid and we have been doing that via providing some guarantees we call authenticity proofs. So the authenticity proofs are basically some proofs that try to show that the data fetching process that the Oracle did from the data source has been done in an isolated way so that basically there was no possibility to manipulate the data and that data is authentic. So these are the integrations we are currently running.
00:39:24.340 - 00:40:04.828, Speaker C: Like we have integrations with all those different blockchains because 80% of our work is off chain is in securing the data fetching process and generating those authenticity proofs. Then there is a small integration layer on each one of those blockchains. And as we have announced few days ago on Ethereum we have been just running our own integration as on all the others. But we will be. Supporting for the last mile. Also other protocols such as Chainlink or Witnet and few others that basically have the aim to basically decentralize the network of node operators. Right now we are the only node operator on the main net basically for a general purpose data fetching.
00:40:04.828 - 00:41:35.020, Speaker C: One day if people will decide to value decentralization of this service, they may decide to choose chainlink or something else and maybe delegate this task to more nodes, to more node node operators. So in the rest of the presentation I will be showing the existing interface of Oracleize which is the one you find on every blockchain and on the Ethereum main net. And this is the one that is being used by approximately 1000 projects on GitHub. So if you go on GitHub and look for the Oracle API you will find like I think now it's a bit more than 1000 repositories making use of that for the daily theorem projects. And these are some statistics that we have collected to basically show what those projects are building, like those data rich DApps and I think it's quite interesting to see that a big chunk is gambling, right? The blue one is gambling, surprise, surprise, Ethereum mainnet as the entire ecosystem basically has huge ambition to decentralize finance, insurance and so on. But data rich DApps at the moment as for the number of application at least is mostly leveraging like Crowdfunding which is ICOs and assets and tokens that use it internally for denologics and gambling finance is here. Insurance is here, so they are part of it, but the number of applications is still limited.
00:41:35.020 - 00:42:38.224, Speaker C: So I don't want to spend too much time now on explaining how this works because we will be around me and the rest of my team here. So if you want to ask some questions, more technical questions on how this works under the hood, we will be happy to answer. But in general, these are the two keywords, like blockchain, of course, that's the interface, like where you want to use the service on. And this is like how we secure the data fetching process. So the authenticity process are based on technologies like intellis checks, ledger, nanos, TLS notary, which is a software isolation technique and few others. The idea is always the same, which is basically let's prove that a secure enclave, a secure isolated process, provably isolated process has done data fetching so we couldn't tamper with it. So basically the guarantee you have right now with the traditional Oracle 1.0
00:42:38.224 - 00:43:24.864, Speaker C: service is that if Oracle is the Oracle answers, then the answer is correct, because you can check the authenticity proof, but the Oracle may not answer. So this is the risk you're taking with our traditional approach. And that's why projects such as Chainlink are trying to decentralize that. So that basically it's easier to basically expect that it will answer. Which is important if you want an application that keeps running for a very long time and you are afraid that the Oracle may disappear in a couple of years or in something like that. Right. Still, if you are a developer and you expect to bid on something like that, you have to do basically your own math and decide what you need because decentralization is very important.
00:43:24.864 - 00:44:00.920, Speaker C: But right now we don't see the actual market valuing it much like we see it also with ICOs. We see it with many different other components in the network. We give the tools to the community and we do a lot of work to give the tools for the community and nobody cares. They just want to buy the NFT, they want to invest in the Dao, they want to invest in the ICO before the contract is verified, before the contract is public. They just don't care. So we don't know yet how much people will value decentralization. If they don't value it at all, the entire blockchain movement will probably fail.
00:44:00.920 - 00:44:53.612, Speaker C: So we hope they will value it at least a little bit, but we don't know how much they will value it. So the idea is that the existing Oracleized interface fits really well. As for gas efficiency, for example, if you don't care too much about the risk of the Oracle potentially not answering in the future. So if you're building a DAP where for example, you are the administrator, that's probably not a big deal because you are the point of failure anyway and people are trusting you. So that's not a big deal. But if your application is supposed to be fully autonomous and run forever with no changes or something like that, you are encouraged to look for some other approaches that give you those kind of guarantees. But our aim with the traditional interface which is why we have decided to keep it, to keep the traditional one is to be as efficient as possible.
00:44:53.612 - 00:45:50.320, Speaker C: So since the traditional Oracle is 1.0 interface doesn't need to support a decentralized service, the idea is that using that one you get the cheapest gas cost you can because the layer is so thin that it's impossible to make it cheaper. For example, you don't need to use token to secure the decentralized incentive system, you don't need to have different layers in between to solve disputes or anything like that, like as thin as possible. While if you want decentralization on other things we will be operating also on other networks such as chainlink which is here as a sponsor as well. And you can just basically use Oracleize via chainlink or Oracleize and other nodes or just other nodes. It's up to you. So basically these are the features of the provable service and in general the existing interface we have is also very simple.
00:45:50.320 - 00:46:29.164, Speaker C: Typically you just use one function where you specify the URL you want, which is the API call in 99% of the cases you want to make. So you will see an example shortly. It's really simple. Basically this is the line of code. Sorry, the contract is quite old, I will show you an updated version in a second, but the logic is the same. Basically you decide how to secure the data fetching process. So what kind of authenticity proof you want? Here we have selected TLS, notary you can select others and here you're just saying reach out to the Oracle.
00:46:29.164 - 00:47:03.140, Speaker C: This is my task. I want to get the data on the ethereum price in US dollar from cryptocompair. The process is asynchronous. So basically the first transaction will reach out to the Oracle. Then the Oracle needs to basically process the query and it will send back a transaction. So the Oracle will reach out to your contract calling your callback function and the callback function guess what contains the result and the authenticity proof. Then the authenticity proof can be verified.
00:47:03.140 - 00:48:10.700, Speaker C: If you look in our documentation you will find more details out of scope here, but you can verify the proof depending on the way you use the service. There is a different cost to verify the proof right now. For example, if you ask for a random number from a ledger device like a ledger Nos, we have a custom application that is open source and anyone can verify. You can check that the random number we generate comes from there and you can verify on the blockchain the authenticity proof at a cost of approximately 100,000 gas, something like that. And then you can do whatever you like with the data, right? You can just continue from where you left your logic flow in the application. So that's the part for the random number generator. So if you care about this use case which is basically gambling few others probably we have released a paper analyzing the differences between this trusted computing based approach for the generation of random number outside of the blockchain and existing ways to do that without using trusted computing.
00:48:10.700 - 00:48:48.392, Speaker C: Like the most trivial approach is commit reveal scheme, right? There are many other ways to generate random numbers. We also know about the other upcoming approaches to generate randomness on chain. We may be with the beacon on future Ethereum 2.0 versions, but they all have some kind of limitations. Like for example in the case of the beacon, you have just one random number every six minutes. In the case of commit revisit scheme, it doesn't work well with applications where the bankroll, for example in casinos is shared among investors. I mean, it's quite complex.
00:48:48.392 - 00:50:08.052, Speaker C: But if you look for this white paper we released a couple of years ago, there is a complete analysis comparing the trust assumptions we make here with the trusted computing technique with all the other existing systems. Of course, you can use it also to delegate to an off chain context the execution of a piece of code. It's the same logic. Instead of asking to the Oracle to basically get data from a web API, you ask the Oracle to execute a piece of code and give you the result. One nice side effect of using a trusted execution environment is that you don't need the process to be fully deterministic because it will just be executed once you want and you will be able to prove that that execution has really happened within a trusted execution environment. However, if then you want to maybe aggregate this data with something from other node operators or something from other Oracles that do the same, you need to ensure on your side that the execution is deterministic or that you have defined an aggregation method that makes sense. For example, if you generate a random number, of course the different Oracles will find a different one.
00:50:08.052 - 00:50:55.426, Speaker C: So then you need to understand how to aggregate it in a way that makes sense and doesn't break the security properties. So yeah, this is basically the description of Oracle S 1.0 which we keep offering. So it works with any web API and these are the technologies you can select at the moment. And yeah, this is basically what has been used in the wild by most projects. Like on the main net we have processed 1 million transactions to date in like four years basically. So some useful links if you're a developers developer basically this is the support channel on GitHub.
00:50:55.426 - 00:51:30.458, Speaker C: Here there is the Ethereum API, one for the interior interface. This is the documentation docs Oracle. It contains pretty much everything and I will show you some examples in a second. This is the main slide. If you are a developer you should probably take a picture in case you are interested to use it. So basically if you want to use Oracleize on a private chain, this is possible and is being done by a lot of people, especially during development. You can just download this tool called the Ethereum Bridge.
00:51:30.458 - 00:52:09.846, Speaker C: And the Ethereum Bridge is basically Node tool that injects the Oracle contrast and interface on your local chain. So that you can test it in memory or on your own local setup basically. So you can test the Oracle based contracts on any context without needing to change even a single line of code. It just works in the same way as it would on the mainnet or on all testnets. We are integrated with all testnets basically. You can also use it just in memory. If you are familiar with Remix, like Remix Ethereum.org,
00:52:09.846 - 00:52:42.182, Speaker C: you go to the official one. In the settings section there are some plugins and there is the Oracleized one. You can just click the Oracleized button and it's integrated straight away in the memory execution you can test it. There are some other useful pages here to verify the proofs of chain if you prefer. This is a tool so you can verify if for example the 1 million proofs we have sent back on main net are valid or not. So you can see if we have ever cheated in the last four years, basically. And that's pretty much it.
00:52:42.182 - 00:53:07.790, Speaker C: So I will show you now. This is a test query page. The test query page does what you would expect it to do. Basically you define what's the query for example here you just say fine. This is an Http get request. Very simple. And this is the API I want to call.
00:53:07.790 - 00:53:40.682, Speaker C: Could be any API. There are some helpers such as the JSON one, so that you can filter down the full response to just the piece you want. But you don't have to do that, it's just for gas efficiency. Then you just click on Test query if you want. You can also select utility proof for testing. It's not needed in production definitely. Then you wait and here on the bottom you will find I should have duplicated the screen and basically you get the result.
00:53:40.682 - 00:54:16.902, Speaker C: It's exactly the same you would have by doing the HTP. Call yourself that's trivial, but doing it via this page gives you the exact response you will get via Provable, basically. So if you go to our GitHub repository there are many repositories. And for Ethereum, like Ethereum examples is a repository which contains many examples. So I guess nobody is using Serpent anymore. Today. We had an API for serpent as well.
00:54:16.902 - 00:55:23.360, Speaker C: But in Solidity you just go here. There are more complex examples within the folders. In the main one you have these simple examples such as I don't know, diesel price for example it's the exact same format you have seen in the slide, right, just Oracleized query, you define the query. This is XML. You can use XML filtering and you get it in the callback. Right? Well the documentation docs Oracle it again if you go to the Ethereum section there is a quick start and you find also best practices during the Akaton it's not that important to follow them maybe because you don't have time and typically everything is just put together pretty much randomly from my experience. But if you go to production, please go back to this section and read it because it's important also for security considerations to prevent common mistakes or issues.
00:55:23.360 - 00:56:30.366, Speaker C: Last but not least, the Remix integration. So that's the plugin basically it's quite useful to get started because without having to set up the Ethereum bridge on your local chain or to send a real transaction on the main net, you can just use Remix and do an in memory execution and test this setup with your acquirers integration. This is just a stupid contract that basically keeps getting the price of Ethereum in bitcoin I think via the Kraken API it does it continuously. So this is really bad to run on mainnet because this gets very expensive very quickly. But for testing it's quite interesting. So again to enable it you just have to go to Settings and Plugins. Here you find a list of plugins that are integrated with Remix.
00:56:30.366 - 00:57:44.004, Speaker C: Oracle has been the first one being integrated so that's why it's here. If you click you find something like that which I admit looks ugly but it works and does the job. So now you basically have to somehow move this window which is always challenging, I did it somehow and then you just compile the contract. This contractor well, I already compiled it well, let me do it again because you compile the contract and you deploy the contract it should like in the constructor this is reaching out to Oracleize. So when you click on deploy in theory the plugin will show you that you have reached out to Oracleize with a query. It will show you some details on the query and the fact that there is no result yet because it's being executed off chain now.
00:57:44.042 - 00:57:44.340, Speaker B: Right?
00:57:44.410 - 00:58:40.230, Speaker C: So this is a simulated execution of the blockchain in memory and also the integration with Oracle is just in memory. It's just been run live. And here Oracle is has returned the result and sent back the transaction. So then in the console you can just read what it did and go on as usual with Remix and this is quite convenient for testing. Also something that should work is that when you click on this ID here which identifies your query, it should send you to an external page to check the query status on the Orchalized panel. So you can see under the hood what's going on if you have selected a proof, what's the proof and how long it took to generate all this kind of stuff, that's pretty much.
00:58:42.380 - 00:58:43.224, Speaker B: It.
00:58:43.422 - 00:59:36.772, Speaker C: If you have any questions I think we have still between one and 60 seconds left. Thank you. Any question? Trustworthiness is a very interesting word. So if I was asking you, what's the temperature here, I'm sure the majority of you will go on Google and ask Google and consider it trustworthy. The reality is that you don't know even where Google got this data from. So trustworthiness is not within the scope of the Oracle. It's on the developer to choose what your application can consider trustworthy.
00:59:36.772 - 01:00:33.700, Speaker C: So my suggestion is to select independent data sources for the same data when possible. Like the temperature is an easy example, and maybe you can find five data sources or something and try to aggregate the data coming from them. Still, this gets very expensive. This is why it all comes down to the cost of decentralization. Do you prefer to give to your users of your application a cheap interaction with the contract with one or two point of failures? Or do you prefer to make it super safe, but make the interaction much more expensive? I don't know. I think it should be on the developer as a choice, and this will be reflected on the adoption of their platform, which depends on the use case, I guess. I mean, the role of the Oracle is the one of proving that the data is authentic and is coming from the data source.
01:00:33.700 - 01:01:10.470, Speaker C: Then, if the data source has compromised the data or is lying, that's not a problem of the Oracle. That's a problem of the data source the developer has chosen, which was not trustworthy after all. So the Oracle is not about this is not about trusting the Oracle. It's about using the Oracle as a data transport layer to get the data from the Internet. When you write a piece of code in Python out of the blockchain, or in whatever language you like, you call a Web API. So is the data trustworthy? Well, it's not a problem of the library you used for the request. It depends on the data source on the Web API you are calling.
01:01:10.470 - 01:01:17.408, Speaker C: Thanks again. If anyone has questions, I will be around.
01:01:17.494 - 01:01:24.630, Speaker B: Thanks. It okay.
