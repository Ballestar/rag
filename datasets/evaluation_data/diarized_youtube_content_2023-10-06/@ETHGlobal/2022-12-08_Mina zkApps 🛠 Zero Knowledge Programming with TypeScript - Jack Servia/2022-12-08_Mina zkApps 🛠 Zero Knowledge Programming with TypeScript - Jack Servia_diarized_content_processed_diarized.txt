00:00:06.170 - 00:00:30.230, Speaker A: I'm Jack. I work at a company called O of One Labs, and we incubated the MENA Protocol, which is a layer one blockchain that we're going to be talking about today. I'm based in Denver, Colorado. That's my Twitter, and I'm a developer relations engineer. So okay, I'm just not going to use this. I think it doesn't work. Okay, so what are we going to go through? We're going to talk about Snarky JS, which is the smart contract language that we use for Mina.
00:00:30.230 - 00:00:57.770, Speaker A: We're going to do a simple example of a smart contract that checks. If the number you submit as passing as an argument is the next value in a Fibonacci sequence, then we're going to make this recursive. And then finally we're going to talk about the Mina Protocol. And we'll talk about where you can learn more and we'll do questions and answers. After you can come grab me. I'll stand next to the door for a little bit. Okay, so Snarky JS, it's a TypeScript library for defining zero knowledge proofs.
00:00:57.770 - 00:01:14.340, Speaker A: And it's also the smart contract language for the Mina Protocol. This is what it looks like. Hopefully. It looks like something that you can figure out, because it is something that you can figure out. Everything is in TypeScript. So you can keep using the tools you're familiar with, like NPM prettier ESLint vs. Code.
00:01:14.340 - 00:01:36.326, Speaker A: And it's very easy to learn. You can see here the IntelliSense support is super good. So you can just dive into a code base and if you're curious about what something does, hover over it and you'll get a pretty good explanation. It's also extremely powerful. This is for two reasons. One is Kimchi, which is our proof system, and we have fully trusted setup. We have custom constraints for hash functions, elliptic curves and encryption.
00:01:36.326 - 00:01:56.014, Speaker A: This just means that these operations are very efficient. The proof size is constant. Thus the O of One, it's recursive, meaning that we can verify proofs inside of other proofs. And it's plonked. So we can add new features like dynamic array access and a couple other things. Really the point of this is just that we've put all the horsepower that we can under the hood here. So that's one side.
00:01:56.014 - 00:02:26.266, Speaker A: And then the other side is what does it actually look like to use this? What does the Snarky JS library look like? And there's a few things that make it really powerful. One of the first is we have method chaining. This makes it very easy for developers to think through their programs in a pretty linear way. So you can kind of see here we have an example. We've got this value guess. We can call the equals method on it pass in zero, and then we can call the not method. And so we're going to take something in this case, I think, an array of fields we're going to get a boolean out in.
00:02:26.266 - 00:02:48.660, Speaker A: This is not red peg. This probably seems pretty familiar. And that's the point. We've done our best to make programming in Starky JS feel a lot like programming in ecosystems you're familiar with already. Also, we have Structs, which are exactly what they sound like. They provide a layer of abstraction that makes data quite a bit easier to think about. We can see an example here.
00:02:48.660 - 00:03:24.134, Speaker A: We have this struct. It has an array with public key and string, and it's called My Tuple. And then we can, down here, pass this in as an argument, this type. And so a fundamental requirement of all zero knowledge proof systems is that the values are ultimately represented as something called a finite field element. And these are for the most part, like unsigned integers. But there's a couple interesting features or things that work differently. And so Structs, eventually, fundamentally, they're all composed out of these field elements.
00:03:24.134 - 00:03:57.526, Speaker A: But with this abstraction, we can define things like this that are much easier to work with. And so the Struct will figure out how to take this information that we know how to work with in a format that makes sense and turn it into this underlying field representation. So finally, plenty of the stuff that you need is already implemented in Starkey JS. So we have all sorts of different types. These are these Structs for groups, public keys, private keys, signatures, scalars, et cetera. Efficient hash functions, efficient encryption and decryption efficient signatures. We have merkel trees and an API for recursion and more coming all the time.
00:03:57.526 - 00:04:34.542, Speaker A: So a lot of the stuff that you need is just included in the Sarkyjs Library to begin with. Okay, why did we choose TypeScript? Because we're ecosystem focused. So the idea is that probably some people want to build crazy cryptographic primitives that let you do things that seem impossible and that's awesome. You should totally build those. And then there's other people who might want to ship user facing products that make use of these powerful primitives. And the idea is that you'll just be able to import a library with whatever crazy thing like card shuffling or something that's hard to do. And we want to have code reuse that's as high as it is in the JavaScript ecosystem.
00:04:34.542 - 00:05:07.950, Speaker A: I think that that will kind of allow a whole new type of application to kind of come forward, which is applications that have the best product people and the best sort of like cryptographers working together to sort of open doors. This is just a rehash. We'll go through it because we're going real quick. So how does Snarky JS work? Here it is in five sentences. It's a TypeScript library. All the information is represented in one of these Snarky JS compatible types. So these are all composed of the field type and can be constructed using this Struct abstraction.
00:05:07.950 - 00:05:53.206, Speaker A: It provides classes and functions that are compatible with this field type or the Structs that are composed of them. So we have. Like for example, if we have a field of value one, then we have an add method on this field type that we can use to add another field to it. Okay, so Snarky JS can represent any of the operations that we do this way as this Kimchi Arithmetization, which is basically a math problem that represents the program that we write in Snarky JS. Then when a user interacts with the Snarky JS program, we can use this math problem version of the program to generate a zero knowledge proof that their interaction was legal. How do the smart contracts work? Developers write the smart contracts in TypeScript and they deploy the verification key to the Zkap account. So a Zkap account is just like a contract account on Ethereum.
00:05:53.206 - 00:06:19.826, Speaker A: I mean, it works a little bit differently, but it's the same idea. So a user generates this verification key for their program and they deploy the verification key to Mina. And then we have a new smart contract on the MENA network. Users run the smart contract in their browser and then they generate a zero knowledge proof that their interaction was valid. When it comes time for people to actually interact with the app once it's deployed, so we can kind of see what this looks like. We have my cool ZK app. A user does some stuff with it in the browser.
00:06:19.826 - 00:06:44.302, Speaker A: They make a transaction and the transaction has a zero knowledge proof and they send it to MENA. And if it's valid, then everything associated with that transaction gets committed. And if it's invalid, then it's dropped. So if the Mina blockchain can validate this zero knowledge proof, then it commits any of the relevant state updates. This is kind of what this ends up looking like. We have a smart contract method. It takes in some arguments, some state from the smart contract and some values from the state of the world.
00:06:44.302 - 00:07:23.062, Speaker A: So smart contract state is exactly what it sounds like. Arguments are things that the user provide and values from the world can be things like block height, verifiable, randomness, that kind of thing. And what we get out when we run it is updates to the state and updates to the state of the smart contract and updates to the state of the world and a zero knowledge proof. And so we pass this zero knowledge proof onto Mina and if the proof is valid, then the state gets updated as described here. We'll skip through that real quick. Okay, how do ZK apps work? So you install your smart contract in your UI repository and then you deploy it. And that's all, it's just TypeScript.
00:07:23.062 - 00:07:59.400, Speaker A: So you can publish it however you want to on GitHub or using NPM and then you can just install it exactly as you would any other dependency. The smart contract is really just a dependency of your front end in this case. And you call it just like you would any other library. Okay, so we'll get on to an example and I'm sorry that I'm going so fast. Like I said, we're way behind time, so come stop me after if you have any questions. I know I'm kind of glossing over some stuff, but here's what we'll do. We're going to write a Smart Contract that calculates the next number of the Bonachi sequence and it'll have two pieces of state, n minus two and N minus one.
00:07:59.400 - 00:08:35.442, Speaker A: And it'll have a method update. This will let us update N minus two and N minus one, but only if we pass in the correct number, the correct next number in the sequence. To write our ZK app, we're just going to extend this Smart Contract class of Snarky JS into Fibonacci sequence. And now we have a Smart Contract and we'll define some state. And so Zkapps can contain on chain state. And in this case we need two pieces of it, n minus one and N minus two. And they're both of the type field.
00:08:35.442 - 00:09:23.810, Speaker A: We use this state decorator to basically tell Snarky JS, hey, this is a variable and you should do all the sort of work to make sure that when a user alters this variable in their browser, then if necessary, we reflect this change in the actual blockchain itself. So only types that are built out of field or structs that are composed of fields can be used for these state variables. And I think that's kind of all there is to say about state. We'll come back to it in just a second. The next thing that we're going to do is we're going to override this deploy method. So this Deploy method is a method that's run when the Smart Contract is deployed. It's kind of like the constructor or like if you have like a truffle file, it's the JavaScript trunk that deploys your contract.
00:09:23.810 - 00:10:17.134, Speaker A: So in this case, we're going to pass in some things from basically our deploy tool and then we're also going to set N minus one and N minus two to their initial values. And so we're going to set N minus two to a field element of value zero and N minus one to a field element of value one. And so now when the Smart Contract is deployed, we know that these values will be initialized to zero and one respectively. Finally, we're going to define a user callable method, in this case update. And so Update will take one argument, N of type field and we can make as many methods as we want. Each one can have its own logic and do as much computation as you'd like. So the methods of the Smart Contract describe how it can be invoked once the Smart Contract is actually deployed.
00:10:17.134 - 00:11:02.830, Speaker A: And it's worth kind of calling out here that this value is actually private. Anything that we pass into these user defined methods is private until the point that it gets mutated and emitted in an event or used to update some sort of on chain state. So of course the state of the blockchain is public and the events and stuff are public, but the actual execution of this code is not public. You do it yourself in your browser and you only share a zero knowledge proof that says that you did it correctly and then any meaningful output of this. So in this case, this end value is not going to be revealed. We pass it in, but we are passing it in on our local machine. It doesn't ever reach the nodes.
00:11:02.830 - 00:12:31.120, Speaker A: That's something kind of worth calling out is that anything that you pass in is private and along the the course of the execution it remains private until you do something not private with it, basically. So the update method, we're going to use this Git method on n minus two and n minus one and this is going to grab these values from the blockchain and then store them in these local variables. So when we run this code, we're going to grab the values from the actual blockchain and put them in our local runtime. And then what we're going to do is we're going to add n minus two to n minus one in order to get the next number in the Fibonacci sequence and we're going to assert that this new state, the next number in the Fibonacci sequence is equal to N, the value that we pass in. And what this assertion statement does is it basically says well, first of all, if this doesn't hold true, stop the execution. But second of all, set up the zero knowledge proof in such a way that even if a user could override the error that this throws, they will not be able to generate a valid zero knowledge proof. There's cryptographically nothing that they can do in order to make a valid zero knowledge proof for invoking this method, unless what they pass in does equal new state which also equals n minus two added to n minus one.
00:12:31.120 - 00:13:28.362, Speaker A: Finally, the last thing that we have to do is we'll set our on chain state to new values. So we're going to basically take our new the value that we passed in the next number in the sequence and we're going to set that to n minus one and then we're going to move n minus one over to n minus two and n minus two is going to get sort of pushed off the end. So that's it. That's kind of the basic structure of the Smart Contract. We define state, set up our deployment and then define the methods that users will be able to call once the Smart Contract is deployed. Now we're going to do something extra cool and I'll just play through this really quickly. The point is kind of like to understand what's possible just because we have limited time, what we can do this Smart contract as it works right now is the same as an ethereum smart contract a user calls a method.
00:13:28.362 - 00:13:58.410, Speaker A: They create a transaction, they send a transaction, they wait for it to be mined, and they pay a fee. But Mina allows you to structure things quite differently using recursive zero knowledge proofs. And so instead of writing a smart contract, what we do here is we create a ZK program. And a ZK program is kind of like a subset of a smart contract. It's a provable program. It doesn't have the connective tissue for things like state and that kind of thing. So it's a provable program.
00:13:58.410 - 00:14:52.710, Speaker A: But what's really cool is that if we look at these methods, we can see as input, we can actually take proofs. And the output of sort of running this is also a proof. And so we can verify that the proofs that we pass in are valid inside of this proof. So we can have a proof that accepts other proofs as arguments and then verifies that these proofs are valid and then also does some other thing. And this is really powerful because you have arbitrary branches and merges, and you can do it an infinite number of times. So you could do something like use this to prove that you've kept a correct moving average for 100 years or ten years without having to store all of the previous data. You could use this to do something like make a smart contract that, I don't know, maybe does, like machine learning inferencing or something, and has to scale horizontally across many machines.
00:14:52.710 - 00:15:29.554, Speaker A: And you can do it for simpler, more practical things. Like if you want to build a game, you can build a game where one user makes a proof, sends it to the other user, the user validates their proof and then builds a proof on top of their proof that proves that their move is legal. And so you could do something like build a game where users go back and forth, peer to peer. There's no blocks, there's no fees. And at the end, we get a single proof that attests to the fact that the entire game has been played correctly. And then we can pass that proof as an input into Amina smart contract and settle the game that way. So this opens the door to all kinds of crazy stuff, mostly probably people who are interested in kind of the scalability aspect.
00:15:29.554 - 00:16:06.618, Speaker A: So come talk to me about this more after if you're interested. Yeah, it's pretty simple. We can just have we basically make a type for the type of proof that we're going to use and then and then we pass this in as an argument in our smart contract and call verify on it. Okay, now let's talk about the Mina protocol. What is Mina? It's a layer on blockchain that proves its entire finalized state using recursive zero knowledge proofs. So it works kind of like we just described. While other blockchains grow, they need all of the information in order to be able to verify any of the information.
00:16:06.618 - 00:16:34.860, Speaker A: Basically, Mina does not. You just need a zero knowledge proof and the information that you're interested in in order to be able to verify that information is valid. And so it stays at fixed size 22. This cool or is it actually useful? It's both. It's really cool and it's really useful. So the first reason is obviously privacy. I think we kind of touched on this a little bit before, but Ethereum smart contracts run on every single node, so all the information is public.
00:16:34.860 - 00:17:18.622, Speaker A: You can see what this kind of looks like. If we call some method on an Ethereum smart contract, we send it to every single node, and every single node has to run this method. Mina smart contracts run in the browser, and so the arguments and the intermediate values are private by default. What this means is that the user runs this smart contract themselves. They don't have to share what that looks like with anybody, and then they just take the relevant state updates and the proof and send that onto the MENA blockchain. Mina simply verifies the proof and updates the state on chain if you know the proof is valid. Okay, what about scalability? There's no gas model for ZK apps.
00:17:18.622 - 00:17:56.866, Speaker A: They run off chain. And so the amount of computation doesn't affect the transaction cost. You can actually do an unlimited amount of computation, especially using this recursive proof mechanism, and then send a single transaction that attests to all of this. So developers can use recursion to build application specific roll ups. We kind of touched on this a little bit earlier. What about decentralization? Okay, so as we talked about, Mina stays 22. So the amount of information you need in order to verify that the current state route of Mina is valid is 22.
00:17:56.866 - 00:18:41.874, Speaker A: So it's possible to validate the entire chain state using just this small zero knowledge proof. And what that means in practice is that there's no need to rely on trusted third party node operators like Infuria or Alchemy or something like that. You can run basically a node that only worries about your account but doesn't have any sort of other security concessions. It's a full node, but it's a full node only for your account. Bridging is another thing that we can do kind of differently than I think, a lot of other blockchains. A smart contract on another chain can bridge the whole Mina state just by verifying the most recent proof. That and so what that means is that, well, I guess here's a good example.
00:18:41.874 - 00:19:34.690, Speaker A: We can write a smart contract on Ethereum with a method, and the method will take in as an argument the, you know, the root of this merkel tree, and it will also take in the most recent Mina zero knowledge proof. And we can pass in the zero you know, then any user can call this method pass in the most recent zero knowledge proof and pass in the Mina state route. And this Ethereum contract can check that the zero knowledge proof is valid. And if it is, then it can update the state route on Ethereum. And then when a user wants to use some specific information from Mina, they can, I don't know, grab this chunk down here and provide the rest of the merkel path and then validate it against the actual state route that's stored in this bridge contract in this case. And so this is not just hypothetical. The Nil Foundation is working on this right now with a joint grant from the Ethereum Foundation and the MENA Foundation.
00:19:34.690 - 00:20:21.346, Speaker A: So, yeah, you can actually check out a demo. We'll have a QR code at the end that has this demo. We pass in our three relevant pieces of information and create a transaction and actually eventually send it through MetaMask to one of the Ethereum testnets. I forget which one. Another thing that can work kind of differently is Oracles. This is something that I'm not quite as exposed to, but the kind of broad strokes idea is that users will be able to create proofs that they've accessed a website through this SSL exchange. And so when you go to a website right now, you have a little lock in your browser and it basically says, we use some protocol to ensure that I'm talking to the party that I think I'm talking to, and they're talking to me.
00:20:21.346 - 00:21:05.150, Speaker A: And nobody's tampering with anything in the middle. But the problem with this is that it's an interactive exchange. And so it's only compelling to the two parties involved in it using zero knowledge truths. We can take this interactive exchange and make it non interactive. And so what this would end up looking like in practice is a user might be able to do something like go to, I don't know, a website that publishes the results of soccer games, and they could prove I went to the New York Times or whatever website publishes soccer games. And I saw that on this page. We had the result of this soccer game I'm sorry, football game published as, let's say, I don't know, America Lost.
00:21:05.150 - 00:22:15.414, Speaker A: Let's say that then we can take this information and pass it straight into a smart contract. We can get a non interactive proof that we went to this website and that it said that this was true, and then we can pass it into another smart contract on the blockchain. So this opens the door to kind of people being able to create Oracles without having to set up these complicated pools of relayers that are going to, I don't know, stake some sort of capital and participate in some kind of game theory thing. You can just cryptographically know that this person really did go to this website and the website really did say this thing? What else is possible? Well, we actually don't even know everything that's possible yet. And that's why we're really excited to be here because there's plenty of things that we hadn't really thought about six months ago that seem like a good idea and like a feasible idea now. And that's kind of what we're hoping is know everybody at ETH India probably has a lot of collective brain power and maybe we can find new things that we can do with mina that we didn't even know were possible yet. We have all this technology and it opens a bunch of unique doors that nobody has really explored yet.
00:22:15.414 - 00:22:37.434, Speaker A: And with a bunch of people, I think we can kind of explore all these avenues together and maybe find some really cool things that nobody has even thought about doing yet. We'll skip this and now we'll talk about where can we get more. So how do you get started? It's really simple. We have a single developer tool. It's called the Zkapp CLI. It's very powerful and it's very easy to use. It's just an NPN package.
00:22:37.434 - 00:23:17.974, Speaker A: You can install it and then you can run ZK project and then a name, let's say hello. When you do this, it'll create a project for you, scaffold it and also include an example smart contract and an example test. And so you can just install the ZCAP CLI, create a project and then start poking around with it and look at the IntelliSense in Vs code and get a sense for what's going on. And you can even deploy this to Berkeley Testnet tonight. There will be cards next to the door when you leave that have simple instructions for this. So yeah, you can get started in like five minutes. This way we also have a bunch of tutorials and other documentation.
00:23:17.974 - 00:23:44.530, Speaker A: I will have a link for that after. How else can you get involved? So you can visit our docs. That's probably the easiest way to get started. You can also apply for retroactive grants. We have a retroactive grant program. We have also ZK Ignite, which is a I don't know, I think we'll have more details at the desk. But it's basically a program where we have I think we have the next slide talks about it.
00:23:44.530 - 00:24:33.822, Speaker A: And then finally you can also build a Zkap, which is a good thing to do because Zkaps are all eligible for the prizes here at ETH India. Okay, so, yeah, ZK Ignite, you can start building ZK apps and get rewarded from a pool of 250,000 mina with some bonus prizes. This is a code you can scan to kind of get signed up. And then in order to kind of get yourself up to speed on all of this, you can also check out the docs at forward slash Dkapps. And this is a QR code that you can scan really quickly. If you're all snapbacks of other QR code in a second, this one has got links to the presentation here and some of the things that I talked about in it. Like, for example, the Nil Foundation bridge.
00:24:33.822 - 00:25:07.582, Speaker A: I think it has links to the docs, some GitHub repositories, some other things. So I'll do this one for a second and then I'll flip back to the other one in 54321 and if you miss it, just come stop me after. Our booth is in the middle kind of right in the between the hallway, between the left section of the room and the right section of the room. And here's the ZK Ignite Cohort zero QR code. Awesome. I'm sorry I went so fast. If you have any questions, come talk to me after.
00:25:07.582 - 00:25:14.160, Speaker A: I will have way better answers for you then. But thank you so much for having me and I hope this was interesting.
