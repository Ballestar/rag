00:00:02.130 - 00:00:24.762, Speaker A: You. Nice to see you again today. Hello. Awesome.
00:00:24.896 - 00:00:37.980, Speaker B: Hello, everyone, and welcome to the ETH Online 2023 Safe Workshop. Building a plugin with the Safe Core protocol. Joining us today is Hedman Martinez who will be taking us through the session. And with that, I will pass it over to Herman to get the session started.
00:00:38.430 - 00:01:26.474, Speaker A: Thank. Hello everyone. Thank you for attending. I'm working as devrel Engineer at Safe and today I want to share how to build a plugin with the SafeCore Protocol. So you may or may not know what the SafeCore Protocol is. It was shared publicly a few months ago. Many new terms and concepts were introduced like modules, Manager, Registry, plugin and now I would like to show you a little bit what all of this is and specifically how to build plugins that can extend the functionality of smart accounts.
00:01:26.474 - 00:02:57.646, Speaker A: So before going deeper, I would like to share first some issues we have with modular smart accounts that they will fail if there's no interoperability, no discovery, and no security. By interoperability it means that currently there's a risk of vendor locking, multiple projects, working on tools and extensions for smart accounts that are not compatible, creating a fragmented ecosystem. Also there's duplicate work. We are trying to fix this issue with the SafeCore Protocol by creating a protocol that is account agnostic and will allow to communicate smart accounts with these extensions. Regarding discovery, there's no central place these days to discover smart account extensions. So there's an issue for users to discover what kind of extensions they can connect or enable in their accounts to expand their functionality, but also the other way around for the developers of them. Regarding security, there's also an issue where users need to trust every single extension they want to use.
00:02:57.646 - 00:04:19.830, Speaker A: So to solve also discovery and security, we are introducing registries that are like curated list of these components, the modules where developers can submit their plugins to it and also users via Manager contract, they can trust this registry and then select the modules or plugins they want to enable in their accounts. So the estate of the SafeCore Protocol today, it is still an alpha version. It's ready for hacking and playing around with it, but not ready for use in production. So expect changes and things to break. It is designed to be account agnostic, but first we are focusing on the Safe, specifically version one, point X to speed up the development. It is open source, everything is public and you can read all the contracts and documentation about that. And currently we are looking for community feedback and now it is the best time to help us evolve this protocol.
00:04:19.830 - 00:05:50.500, Speaker A: So before sharing the overview, I would recommend to check before this or maybe later another workshop that was presented at If New York 2023 on East Global where I was showing like a big overview and diagrams more in detail on how the flows on this protocol work right now. I will cover that quickly and then share some code examples to actually implement a plugin. But yeah, let's go with the diagrams. So at Safe we have the Safe account and then we have different elements that can be plugged into the accounts directly to extend the functionality. For example, modules are able to initiate transactions, transaction guards are able to parse and check the transactions that are being executed and act on them, maybe reject them if some conditions are not met. And then followback handlers are able to add extra functions to the core smart account. With the SafeCore protocol, what we are doing is removing the direct connection of all these components and just enable Safe protocol manager directly into your account.
00:05:50.500 - 00:06:57.610, Speaker A: This manager would have access to a registry where multiple modules are listed. There would be an owner of this registry that is curating this list and then also the manager would allow to communicate, would allow the communication between the accounts and the modules. And there are different kind of modules like plugins hooks, function handlers and so on. Today we are going to be talking about plugins, specifically the ones that are able to initiate transactions that will be sent to the manager and then to the account. So let's see how to add a plugin to our registry, enable a plugin in an account and then how to execute a transaction via a plugin. Again, to get more details on this, I recommend checking the other worksheet. So to add a plugin to the registry, basically we can call the function add module in the registry and just add it to the list.
00:06:57.610 - 00:08:11.634, Speaker A: This has to be done by the owner of course. Then if we want to enable a plugin in an account, if we are a user, then we would need to execute a transaction that tells the manager to enable a specific plugin with a specific kind of permission. Then this manager will check if the plugin is added to the registry, will ask the plugin what kind of permission does it need and then the manager will store in the storage. Okay, this Safe has enabled this manager, sorry, this plugin with this kind of permission. Finally, how are transactions executed via a plugin? Now here the flow starts on the plugin side by calling a function in the plugin, let's say exec. Now the plugin will send this transaction to the manager. Depending on the kind of permission this plugin has, one of these two functions can be executed, execute root access or execute transaction where we can pass the save where this transaction is going to be executed and the transaction itself.
00:08:11.634 - 00:09:16.694, Speaker A: And this transaction will also have some metadata to give some context to the transaction and tell interfaces who is the plugin initiating them and we will see more of this later. Then the manager when it receives the transaction, it will check if the plugin is enabled into the save. It will also make sure that the plugin is added to the registry and it can be used correctly. Then the manager will ask the plugin what is the kind of permission it has. We'll make sure and we will compare with the data that is stored in the manager's storage. And if everything is okay, the manager will finally send the transaction from the plugin to the Safe so the safe can execute it. This was very fast, but now we are cover the plugin and the manager sides a bit more in detail.
00:09:16.694 - 00:10:21.650, Speaker A: So basically for all these four components, there are interfaces that anybody can implement and deploy its own manager, its own registry. Today we are going to see our own plugin. So the interface for a plugin, it's simple, it's small, it has four functions name, version, metadata provider and requires root access that we need to implement. And then on the manager side, probably we don't need to implement a manager, but we will need to call some functions. Depending on the permissions the plugin has, we can call execute transaction or execute root access. So let's see some code. Here I have Visual Studio with some folders, some repos, the SafeCore protocol where you can find the official implementations of the registry and the manager.
00:10:21.650 - 00:10:50.714, Speaker A: Also check some interfaces. Then in the specs you can see some documentation and diagrams and flows. And now we will work with the SafeCore Protocol demo. This folder has two projects inside. One is web and the other is Contract. The web is a Safe app that we can see here. This is the Safe web app.
00:10:50.714 - 00:11:35.558, Speaker A: I just created a Safe on Gurley and then if we go to app I added a custom app that is called SafeCore Protocol Demo. And this one, it shows a registry in Gurley with multiple plugins that are listed there. So we are going to add one here and enable it in our Safe. So that is the web. And let's open the contracts here in the contracts, this is a half heart repository with some examples that we can see here. Well, I have some tabs open. Also there are some useful scripts to deploy the plugin we implement also to add it to a registry.
00:11:35.558 - 00:12:33.742, Speaker A: Here we will be using a registry that is a test registry. So anybody can add anything there just for testing purposes. So let's start with the different plugins. This one, let's create a very, very simple base test plugin. If you remember, there's an interface that needs to be implemented, the Isafe protocol plugin where we have a name, a version required root access, it can be true or false and then the metadata provider function. Also if we want to execute transactions depending on the permissions the plugin has, we can have, let's say a test plugin or a test plugin with root access. Very quickly.
00:12:33.742 - 00:14:12.140, Speaker A: Root access means that the kind of means that transactions, for example, if a plugin has root access it can execute delegate calls and also transactions where the destination is the safe or the manager. So kind of admin transactions can be executed because if the destination is the safe or the manager, maybe the signers of the safe can be replaced or maybe new plugins can be enabled or disabled that is kind of admin permission. Anything else is just not root access. So with a plugin that has not root access we can implement a function that is called execute from plugin, for example, that receives the manager where we are going to send our transaction. We need to specify the save that will execute it and also the transaction that the save will execute and then this function can call the manager, specifically the function execute transaction and pass the save on the transaction. If we are talking about plugin with root access then this is very similar. We just need to make sure that the variable requires root access is true and instead of calling the method execute transaction, we can call the one called execute root access.
00:14:12.140 - 00:15:53.862, Speaker A: So now we can see talking about metadata because here when we send a transaction, this safe root access transaction has some metadata, not just the transaction itself. This metadata can be something similar to this like a name of the plugin, the version if it requires root access or not, but also different things like an app URL where there can be an interface deployed that is able to interact with the plugin if there are some things to be done there on the interface. Maybe an icon for the URL or whatever. Now, if we see a very basic implementation of this abstract contract, this is an abstract contract as well, but it has a constructor where we can pass some metadata and we will store here some things that are required by the interface like the name version and required root access. And also with the metadata we are going to encoded it, calculate the metadata hash and store it there for later. Now, this metadata can be handled in different ways. There is an Enume where we can specify where this metadata will be stored.
00:15:53.862 - 00:16:51.680, Speaker A: For example, maybe in IPFS or maybe in a URL, in an API or maybe in the contract itself. Or maybe we can emit an event from the plugin that has the metadata and that we can check later in the future. So let's see these two last ones, the contract and the event. So here for example, if we have a base plugin with a stored metadata that is also a base plugin, we will have a constructor where we are passing the metadata and encoding it. But also the interface requires to implement the metadata provider function that returns the provider type and the location. The provider type will specify how this metadata is handled in the plugin. In this case it says contract and then the location where to find it.
00:16:51.680 - 00:18:07.430, Speaker A: In this case it's in this contract, in the plugin. So the interface will read this information, will know it is stored in the contract in this contract and then it can call the retrieve metadata, pass the metadata hash and receive the encoded metadata in return. So now the interface will be able to display here like the name the interface and also a link pointing to the interface where we can interact with the plugin in case we are using, for example, the events metadata. We can implement this similarly but differently. We can have a constructor where we are passing the metadata and here in the constructor we can emit the metadata event, pass the metadata hash and the metadata encoded. So later if the interface calls the metadata provider function, it will receive that the provider type is an event. It will know that the event was triggered by this contract.
00:18:07.430 - 00:19:26.702, Speaker A: Meaning that the interface will know how to access that metadata. Let's see now a plugin that uses the event metadata, for example, an Allow list plugin. What it does is not relevant, not very relevant for us right now, but basically allows, let's say we have a safe with three owners and then we want to interact with uniswap smart contract to swap two tokens. But we want to allow these owners to execute this transaction independently without the need of collecting the signatures from the other signers. Then these owners, or let's say the save could call the method add to Allow list or remove from allow list and there they can add some destinations where these owners, if they use the plugin they could interact with directly. In this case Asaif could add the uniswap smart contract to do the swapping. So now this contract is a base plugin with events metadata.
00:19:26.702 - 00:20:20.150, Speaker A: This means that in the constructor the plugin metadata is emitted and it has a name, it has a version, it defines, it requires root access or not and then it has some other properties. Let's add here some ETH online Allow list plugin for example, in version one. And for the app URL, let's say Httpsample.com here. Ideally, ideally no, it's mandatory. We will have the URL where we can interact with this plugin. But now that we have this plugin implemented, well, maybe it's interesting how the execution works here.
00:20:20.150 - 00:21:18.520, Speaker A: It basically this function execute from plugin can be called from an owner of the save, passing the manager, the save and the transaction. As we saw before in the interface, it will check that it can only be called by an owner. And then it will check because we can pass an array of transactions. It will check that the destinations of these transactions are added to the allow list. And finally it will call the manager execute transaction because it does not have root access. Passing the save and the transaction with the nons and the metadata hash. So now let's deploy this contract on Gurley we need to install the project, we need to build it as well.
00:21:18.520 - 00:22:21.530, Speaker A: Okay, and now we can deploy it deploy on Gurley. Okay, this will deploy the new plugin in Gurley. We will see the address in a bit. Okay, here it is. Now that it's deployed, we want to add it to the registry. In the real world this would be more bureaucratic talking with the owner of the registry, meeting the security requirements like auditing it and so on. Here in the test world we just need to call Yarn, there's a script here in this project to add it to the test registry register plugin on Gurley as well.
00:22:21.530 - 00:23:34.504, Speaker A: And now if we go to the interface here we see that the plugin is not added yet. Now we see that the registry address is this one. The plugin we are adding to the registry has this name. It's online Allow List plugin in this address. And if we refresh the registry here, in the end we will see that there is a new plugin added to the registry with the name, with the version and with our URL that was example but can be or must be a proper one so we can enable it in the Save. And if we see this generates a batch transaction with two actions. The first one is enabling a module, this is telling the safe account, this one to enable a module.
00:23:34.504 - 00:25:14.212, Speaker A: This address is the manager that we are enabling in the account and then we are enabling a plugin. So we call the manager, the Abd, which is the same and we are telling to enable this plugin, the one we just deployed with no root access so we can execute it and when this is ready in the settings we will see that now DSAFE has a module enabled. Okay, transaction successful, we can go to settings modules and now we see that this is the manager. Now that we have the manager enabled and also the plugin enabled, we could use the plugin. We can also enable other plugins like this one for example, the relay plugin. We see that now there's only one transaction to calling the manager, the IBD enabling this plugin with no root access that we can execute. So now we can enable in our account all the plugins we see in the registry that we like also disable them.
00:25:14.212 - 00:26:49.646, Speaker A: Of course now transaction was successful and here in the registry we need to reload it. We see that the relay plugin now offers us the option to disable but we don't want to disable, we want to use it. So this plugin, one of the metadata properties for the interface, is actually pointing to an existing interface where we need one transaction. And this plugin will allow us to relay a transaction, not just execute it with our safe, but a relay will pay the fees for us so we can create a transaction where we are sending some tokens to ourselves. But we are not executing this, just signing it, making it ready so the relay can later execute it. Okay, now the transaction was added to the queue and now the interface of this relay plugin sees that there's a transaction ready to be executed. And this interface will allow us to call the plugin and to execute the transaction by relaying it using gelato relay.
00:26:49.646 - 00:28:17.260, Speaker A: So now we just have to wait a little bit and the transaction will be executed. And also the relay plugin will extract some funds according to the gas costs from the Safe and send them to the relay. Takes a little bit but it will go through at some point. Okay, so now the transaction was relayed using the relay plugin. So now we can see some resources. It's basically the ones I just showed the SafeCore protocol and the SafeCore protocol specs in the Safeglobal organization in GitHub. If you want to check the demo that I used is SafeCore protocol demo in the five eight, which is an organization more for experimental things we are working on.
00:28:17.260 - 00:28:55.400, Speaker A: And then the UI for the registry, you can find it in the last URL. You can contact us on Twitter. We have some docs discord a forum. Thank you very much for attending this workshop. I hope it was useful for you. Also remember to again to check the previous one at if New York 2023 to get a more detailed overview on the diagrams and how everything is connected. So thank you very much.
00:28:55.400 - 00:28:57.474, Speaker A: Cheers.
00:28:57.522 - 00:29:02.680, Speaker B: Thank you. Herman, there were a few questions, I don't know if you have time to take some or not.
00:29:04.810 - 00:29:05.560, Speaker A: Yes.
00:29:07.050 - 00:29:14.830, Speaker B: Yeah, so there was one question early, early on. Can you please also provide a high level explanation of the goal of this invention?
00:29:15.490 - 00:30:25.670, Speaker A: Of the goal? Yes. The main objective is to create a protocol that can be used by different accounts. So it is account agnostic and also solves a few issues that currently smart accounts have when using extensions like plugins to extend the functionality of these smart accounts. And these issues are of interoperability, for example, different smart accounts implementing different ways of connect these extensions. So you would have to implement an extension for one account, then the same extension rewrite it to use it with another smart account. But here this protocol with the manager and the plugin would be account agnostic. So ideally all the plugins would be able to be reused by different smart accounts.
00:30:25.670 - 00:30:49.950, Speaker A: And then there's the discovery. The registry allows to have one place with trust with different modules that can be added there and gives users some trust and also developers a place where they can show what they have implemented. Nice.
00:30:50.100 - 00:30:56.370, Speaker B: And then while designing our DApps, we will only be interacting with the safe or the plugin contracts.
00:31:00.950 - 00:31:39.870, Speaker A: Here only the I mean it's up to the developer but I think interacting only with the plugin would be enough because plugins allow to bypass all the signature validation that the accounts do with the different signers. In the case of the Safe, that is, a multi signature plugins can bypass all the collection of the signatures from different signers. So interfaces can just interact with the plugin to initiate the transactions that later the accounts will receive and execute.
00:31:42.370 - 00:32:05.000, Speaker B: If ERC 6900 is adopted, then plugins would need to follow a different convention to be compatible. As a developer, I'm in two minds about using Safe plugins for scaling, if any. They prefer to be compatible to the ERC. Why should I then use Safe plugins, which ERC sorry, 6900?
00:32:10.510 - 00:32:32.830, Speaker A: Yeah, I guess there are different ways to implement how these extensions are connected to accounts, but yeah, that could be discussed. Sorry if my answer was not very detailed.
00:32:34.530 - 00:32:39.250, Speaker B: And then I think acid, you want to ask your question? You have your hand raised.
00:32:41.510 - 00:33:50.634, Speaker A: Yeah. Thank you. I was wondering if the flow that you just showed us with the Core protocol is relevant to processing transactions for accounts created with Auth Kit account abstraction. So how is the SafeCore protocol related with the Auth Kit on the account abstraction SDK? The Auth Kit can generate or calculate externally owned accounts from an email or web two login. And then what the SDK does is using these externally owned accounts to deploy saves and add themselves as the signers of these saves. And then once you have a save, in case you want to extend the functionality connecting plugins or hooks or other modules, you could do that by using the SafeCore protocol. Great.
00:33:50.634 - 00:33:54.730, Speaker A: Thank you very much. And then last question.
00:33:54.800 - 00:33:56.730, Speaker B: How can we bundle transactions.
00:34:00.030 - 00:35:09.134, Speaker A: In this case? Well, the Safe offers the option to execute batch transactions by calling the multisend contract, because it is a smart account regarding plugins, depending on the permission they have, if they have root access or not, multiple transactions can be executed at the same time. So basically, the plugins that require root access, meaning that they are allowed to do these kind of admin transactions, they can only execute one transaction at a time. However, if the plugin does not require root access, when the plugin sends a transaction from the plugin to the manager and later to the account, it's not just one transaction, but an array of transactions so you could batch them there. Awesome.
00:35:09.252 - 00:35:21.430, Speaker B: Well, thank you very much, Hayman, for the great workshop and presentation. And thank you all for attending. Don't forget that today we start. The hacking will begin later today during the opening ceremony. So hope to see you all there.
00:35:21.580 - 00:35:22.050, Speaker A: Cheers.
00:35:22.130 - 00:35:22.870, Speaker B: Thank you.
00:35:23.020 - 00:35:23.974, Speaker A: Thank you. Have a good day.
00:35:24.012 - 00:35:24.850, Speaker B: Good weekend. Bye.
