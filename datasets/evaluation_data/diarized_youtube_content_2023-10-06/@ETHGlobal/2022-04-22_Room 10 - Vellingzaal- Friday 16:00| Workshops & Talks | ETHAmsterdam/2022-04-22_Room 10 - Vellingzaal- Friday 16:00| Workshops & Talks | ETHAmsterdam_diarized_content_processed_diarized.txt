00:00:16.430 - 00:00:27.620, Speaker A: I think we can wait for a few minutes. It was a really great quest to figure out what the room we are and how it finds. So let's maybe one more minutes and we will start.
00:00:30.950 - 00:00:31.700, Speaker B: You.
00:00:37.790 - 00:01:21.826, Speaker A: So hello to everyone. So great to see you here and especially on S Global hackathon. Maybe you know that Gearbox originally was a finalist one year ago and really I so appreciate the hackers who create something interesting, something new in DeFi space. So pretty happy to be here and to be honest, we are very open. So feel free during hackathon to ask me or my teammates to help you everywhere because we are burned from hackathon. So it's pretty native to be there. And let's start to talking about Gearbox and what we are working on.
00:01:21.826 - 00:02:22.138, Speaker A: So Gearbox mission is to bring capital efficiency in device space and we create the way how to create composable leverage in defy. So at the moment in the second version we can achieve x twelve leverage and we provide leverage as a service. So we do not focus on make IMM with leverage or a service which could help you to open short or long position. Instead of that, we create a really interesting protocol which could provide you ability to use leverage funds across defy protocols. And this feature opened a really amazing opportunities because you can create a lot of new composable strategies. And another thing which very very significant at this market that there is no funding raise. So let's start and make hands dirty from architecture side.
00:02:22.138 - 00:03:02.566, Speaker A: So as you can see, Gearbox is two side protocol. On the left side you can see liquidity providers. These people who are looking for passive strategy. They just provide liquidity to get high APY and it's available they are looking for, they are not willing to sit at the computer 24 to seven, find best strategy and so on and so on. And to be honest, I am a shit trader. If I go and believe that Zitcoin will go up, it will immediately go down and so on and so on. So for people like me, liquidity providing is a good value because I shouldn't spend my time, I want to put money and that's all.
00:03:02.566 - 00:03:43.650, Speaker A: But what is really interesting is the right part. And here you can see a trader, this guy want to be more capital efficient. So trader could open a credit account. Credit account is in UDFI primitive. This is isolated smart contract. So when traders send funds to this credit account, this credit account could immediately take margin loan from the pool. And after opening this credit account, trader could send different financial orders or transactions in our way to get which could be executed on behalf of credit account on third party protocol.
00:03:43.650 - 00:04:28.930, Speaker A: So let's check how it works step by step. So on the first point, as I said, you as a trader could open credit account. And here you can see trader provide ten S and takes nine S from the pool. So after opening credit account trader has 100s. Each credit account is nominated in one asset. So here you can see credit account which is nominated an easy room, which simply means that debt, interest rate and fees are also in S. And then when you open credit account you can use it across different protocol, however, you have no direct access to the fund.
00:04:28.930 - 00:05:32.182, Speaker A: So basically you can't put money into your pocket, however, you can use it for different strategies on different protocols and let's check how it works. So from the technical side, as a trader you send a transaction and usually transaction is address and the call data. But instead of sending this transaction to uniswap, for example, you send the same call data to a special smart contract which is called adapter. So basically you have uniswap v three adapter, uniswap v two adapter, curve adapter and so on and so on. And sending transaction to such a contract, this transaction would be executed and credit account funds would be involved. So basically from developer side you send the same transaction to credit account, likewise you want to use and then your funds would be executed. So we have a few checks to understand that pool funds are safe.
00:05:32.182 - 00:06:04.990, Speaker A: The first one, we should be really ensured that the contract you want to interact is whitelisted. I think it's pretty simple. The second point that we want to understand that the token which you could get as result could be used as collateral. Pretty simple. If you want to swap S to die, it's okay. If you want to swap S to some shitcoin, it's not good for us. Because you as a trader use not only your own funds, you use some pool funds and we should be insured.
00:06:04.990 - 00:07:00.198, Speaker A: And the last check after transaction was done, we check that health factor is more than one, which means that we have enough collateral to pay debt back maybe. Any questions at this point? Oh, it's clear. Okay, so now let's check what means this health factor and how credit account could be considered. So basically on the right side you can see credit account as a list of different assets and each asset has quantity and price which is taken from chainlink price Oracle. So basically we can compute pretty simple values. The first one is portfolio value. We can multiply each asset quantity to price summarize and get how much money in underlying asset which is S.
00:07:00.198 - 00:07:48.050, Speaker A: In our case we can get if we swap everything immediately. It's pretty clear. The next point, which is called threshold weighted value or TV at this page, means threshold weighted value. So basically liquidation takes time and during liquidation time price can go down. So we could make an overcolorization. However, in Ava it's a huge overcolorization, like 50% more in Gearbox we use a parameter which is liquidation threshold LTI. On this slide which represent maximum expected price drop during liquidation time.
00:07:48.050 - 00:08:23.840, Speaker A: So basically it works as if price is going down, health factor becomes one. So this credit account could be liquidated by third party liquidators. However, we have a liquidation threshold which becomes a buffer to have enough funds to send them back to the pool. And this liquidation threshold could be close to one for two stable coins. For example, Dai and USDC. Because we do not expect in a few more blocks that the price between Dai and USDC would be dramatically changed. Correct.
00:08:23.840 - 00:09:34.422, Speaker A: By the way, as opposite, if we have two assets like Bitcoin and Dai, of course Bitcoin price could go down drastically at this pace, liquidation threshold could be 0.6 or 0.7 to create enough buffer to be liquidated and after liquidation have enough funds to pay back debt and interest rate. And as a liquidator you just get a discount from portfolio value. So you as a liquidator because everything computed with chain link price feed which looks like pretty fair prices get 5% discount. So basically if portfolio costs if portfolio cost 100s, you can take it from ninety five s and five s would be your profit to swap everything back and pay to the pool. And simply health factor is just the ratio between threshold weighted value and borrow amount plus interest rate.
00:09:34.422 - 00:09:48.140, Speaker A: And it's pretty clear that if health factor is less than one, that means the threshold weighted value is less than borrow amount and this account could be liquidated. Any questions at the moment.
00:09:50.990 - 00:09:51.354, Speaker C: Guys?
00:09:51.392 - 00:09:55.980, Speaker A: Do not hesitate because it's pretty complex or not or it's clear.
00:09:56.590 - 00:09:57.340, Speaker D: Okay.
00:09:58.610 - 00:10:50.702, Speaker A: It's okay. Cool. Yeah. So basically you can really imagine that credit account have a few boxes with different coins and each your transaction. Then you put coins from one box and put into other box and then we recompute the value and understand is it enough for us money to pay back so each transaction I know it's a pretty strange words, but even if you put something into a farm, you get some LP tokens. So basically you subtract from one token and increase the quantity of LP tokens. So basically gearbox then you're switching tokens between these boxes or these boxes could be viewed like a table, like a credit account.
00:10:50.702 - 00:12:01.314, Speaker A: And then this pretty simple mass help us to keep your credit account to be able to pay this debt back and it's really created good things for us. Basically, as I mentioned, with these credit accounts you can work on behalf of them with many DeFi protocols. So what we should really do with you is to write a simple contract which is called wrapper, which is called adapter. And this adapter has the same API, like original one. If you want to write adapter for uniswap v two, this adapter will have the same API like original smart contract and all stuff would be encapsulated. So if you want to use funds from credit account on gearbox you create the same transaction like for original uniswap, just make call and methods like create interface in hardhead, get call data and write methods and parameters. You get call data and send it not to original one to adapter and it would be executed.
00:12:01.314 - 00:13:20.730, Speaker A: So it's a pretty simple integration. And another part which is also pretty interesting based on that, because credit accounts are really isolated smart contracts, each of them has their own balance. So you as a user could definitely go to Azerscan, figure out your credit account and get balances. And there are one more interesting feature, which we implemented with Wallet Connect because you can connect gearbox as standalone application with some native interface like Uniswap or Earn or something like that, to get direct interaction. And this Uniswap or Earn or Curve would really believe that you behave on behalf of this credit account. So, a short video, we use Wallet Connect for these purposes and here you can see we enter this Wallet Connect link, then we go to Uniswap interface and now it connected to our smart contract. And then, because we provide the same programmatic interface, you have balances from native way and you can really sign transaction as originally.
00:13:20.730 - 00:14:40.470, Speaker A: So it's totally native experience for end users, whoever funds are used from credit account smart contract. So basically you sign up through MetaMask and all magic happens because it looks like your MetaMask credit account. Maybe a good example, I tried to say it's like a credit card in real world, you can open it once and use across many different shops or restaurants. The same logic here you open your credit account as another smart contract and then you can execute any transaction and build strategies in a more native way. So, just a few questions and a few comments here. If we talk about Gearbox, it's a pretty interesting way because we really address different segments here for liquidity providers, as I mentioned, this is people who are looking for passive strategies, they just provide funds and that's all. And on the trader side, it's people who really could create more value through their strategies, trading positions and so on and so on.
00:14:40.470 - 00:15:14.094, Speaker A: And it creates a good market for us because there is no funding create. And if you compare us for example with Perp, which also works on leverage or square is on the both sides of this protocol you can see pro players. And if it's a bull run, everybody wants to buy ethereum because we expect that as price will go up. It's why funding rate could also increase. Because nobody want to be other side. Correct. And Gearbox total opposite.
00:15:14.094 - 00:15:57.070, Speaker A: Because we do not compete, we do not play each against other. Because these guys on liquidity side take value from just providing a liquidity for high APY. And guys who work on the trader side on credit accounts are pro. Guys who know how to trade, how to make profitable strategies how to earn money. And Gearbox could be considered like a platform which shares money from people which they helped for capital efficiency and provide to LP site. And basically maybe the solution as I said, I am a shit trader. How to provide money and get some part of profits.
00:15:57.070 - 00:16:46.894, Speaker A: And let's check how it works. Maybe on let me check on programmatic site. Any questions at this moment? Guys, please do not hesitate because it's a pretty complex stuff. I know it's maybe not so. So basically to understand how to works programmatically with Gearbox we have a website devgearboxify and you can check all these explanations. And basically as you can see here, we have a lot of such things which connects pools and credit managers which simply contract which simplify all operations. There are another layer which is called core contracts.
00:16:46.894 - 00:17:59.826, Speaker A: And if you want to get everything, you maybe can go to contract discovery option and understand how to figure out and how to take these contracts. But if you go to the crazy account sites, what I believe are pretty interesting, maybe it's how it works. So from technical point we have a user and user could send transaction to adapters and credit facade which just an interface to work with other stuff like open and close credit accounts, provide additional collateral and so on and so on. And when you send a transaction, it goes through a filter. You can see then the call transitioned to this credit account and then it executed on behalf of it on third party protocol. In V two we support seven major defy protocols. It's uniswap V two, uniswap V three, sushi swap curve, careful P, tokens as well, convex, Earn and Lido.
00:17:59.826 - 00:18:58.374, Speaker A: And basically let me share, I think maybe it's more interesting for you strategy you can build. So maybe it's not the latest presentation, but here you can see some interesting things like yield generation, short long position. So here you can take extend leverage, then you can go to open credit account and rub BTC. Then you swap to USDC and then you can open short position and put your stable coins into earn. So what's impossible because there are a lot of leverage protocols in the space when you can just short and do nothing. With this stable coin in Gearbox you can simply put it to earn to generate additional APY and it makes your position more profitable. And if you found sometimes that it's not profitable, you simply could switch from wiren to convex to get more APY.
00:18:58.374 - 00:20:07.802, Speaker A: And it has pretty low overhead because your funds on credit account and you manage them as your native wallet. Another possible way is to work with Lido with the same things you can get X ten leverage, then open a zero credit account so your debt is always in S. Then you really stake this S and put it into Convex and you can get around 40% APY because as I said totally is composable. You can move funds back and forth to get more APY and create pretty complex strategies and we really do not want to show maybe all things. I really believe that you can create a lot of stuff what could be used for Gearbox and maybe a few ideas here that it's. How it work from feature which we designed for V two which is called multiple. So basically what you should do is just to write an array of things you want to execute on Gearbox.
00:20:07.802 - 00:20:58.306, Speaker A: You can see here I want to make a swap. So I generate call data for this call. So I want to execute function which is called swap tokens for exec tokens it's pretty well known for uniswap V two I provide amounts what I want, I provide path which should be used then and address of created account. However it's automatically replaced to existing one and deadline. Then I create a list of calls and just call a function which is called multiple and it's done. So the easiest way to build strategy, you just explain the system what you want to get and they do all this stuff and only one collateral check. So basically overhead in gas cost could be close to you do everything manually through MetaMask and then you will pay around 200K.
00:20:58.306 - 00:21:54.434, Speaker A: It depends how many assets you have for full control check and that's all and you get extend leverage, which is pretty cool from my point. What's more we have some strategies and ideas about ribbon and so on and let me check from here. Yeah, so basically we try to explain all stuff and provide some additional information how it could be executed. So feel free to check here if you have any questions. And as I said from Gearbox, our best goal is to create great developer experience. I believe it's a complex stuff, so feel free to provide us feedback which things should be really explained more especially from documentation domain. It's pretty significant for us and maybe a little bit more about things and limits what we have.
00:21:54.434 - 00:23:14.250, Speaker A: We work with token which have chain link price oracles sometimes people asking can I add my shitcoin or not? Not unfortunately because it have no price feed and we definitely depends chaining price feed because now we have some conversation with Ava maker and market leaders to clarify what's the best solution to get price feeds on chain in 2022. And chain leak is a leader at the moment, maybe maker has their own price fees. But by the way, it's a pretty simple when you start new token and even if it's traded on finance, it doesn't mean that it have enough liquidity. And if we start to use it as collateral and you as an owner of this token have 90% of supply, it's pretty simple to change the rate. Chain link will provide the same data but at the end of the day it could not be considered as good collateral. The second limit, gearbox yet works only with ERC 20 tokens, which also pretty understandable and the latest things that to add new protocol to a system we use Dao and gearbox. Dao is very active, so feel free to go there.
00:23:14.250 - 00:23:27.550, Speaker A: A lot of people could help you and tell and provide support. So basically that's all. If you have any questions, let's discuss and I will be happy to answer. Or it could be in person. During the hackathon.
00:23:29.730 - 00:23:35.810, Speaker E: Question, you talked a bit about the Dow and I noticed that there was a graph with the insurance part.
00:23:35.880 - 00:23:55.942, Speaker A: So the Dao insuring the pool? Yeah. Cool, thanks for question. Yeah. You talk about this insurance? Yeah. Dow treasury. Yeah. So basically this question is related how gearbox earn money because we take two kind of fees.
00:23:55.942 - 00:24:43.750, Speaker A: The first fee is like some overhead for interest rate. So we take a difference between interest rate for LP providers and traders and it's like ten person. So basically, if you have four person on the pool, it would cost 4.42 trader and all these funds would go to the pool back. But what is interesting, we do not provide these fees directly to the Dow Treasury. Instead of that, we reinvest these funds to the pool and then put LP tokens, which is called diesel tokens, into Dow Treasury. And this approach has a very good three advantages.
00:24:43.750 - 00:25:52.926, Speaker A: The first one, we increase pool TVL by putting fees there. The second point tokens which are in Dow Treasury generate more income because LP tokens and LP rate is going up with usage of gearbox. And the third part, if liquidation was a little bit later than expected and we have some loss to keep this LP token rate on the same level because LP earn money, then rate of this LP token goes up. Each time we get money back on the interest rate, we burn some LP token from Dow Treasury and cover this loss. So gearbox has automatically working insurance for the pools. However, of course we need maybe more time to generate enough LP tokens in Dow Treasury but they really behave like automatic insurance for all our operations which create additional level of safety. But thanks for these questions.
00:25:52.926 - 00:26:13.798, Speaker A: Amazing. More questions? Yes. So with that mechanism there's increased liquidity in the pool. However, if there's ever a late liquidation.
00:26:13.894 - 00:26:16.890, Speaker C: Would everyone suffer, including the treasury?
00:26:17.970 - 00:26:49.522, Speaker A: Not in treasury. So basically, treasury holds LP token from each pool. Now we have four different pools, so this picture could be replicated four times. We have Dai, USDC, west and Rabbitc. Basically, each pool generates LP tokens. When you close your credit account, all fees are transferred there. So if we have some late liquidation on some particular pool, this LP token which correspondingly connects would be burned automatically.
00:26:49.522 - 00:27:33.170, Speaker A: If we have not enough balance, this insurance wouldn't work. Of course we consider this way and by the way, I believe it's totally honest because it creates a good responsibility from the Dao side to create really realistic parameters. Because Dao manage these parameters about interest rate, about interest rate model and so on and so on. And Dao should take responsibility with their funds to set up these parameters. Pretty correct. If they would be pretty high, nobody would come and Dao could not generate more fees. If they could be pretty low, it could be a lot of late liquidations and Dao would really leave money through this mechanism.
00:27:33.170 - 00:28:22.220, Speaker A: So it creates a good feedback for Dao to be focused on parameters with responsibility and maybe a few things which could be really done maybe during the hackathon two days. It's not much to generate. I totally understand that. So with the team we have a few ideas what could be done. Of course, the first point is to build some adapters and just to show you how it works basically I don't know, I think we should have yeah. So it's not surprisingly and extremely difficult. So basically you can see how it works line by line.
00:28:22.220 - 00:28:38.736, Speaker A: It's an adapter for uniswap three. Can you hear font or I can make a little bit bigger. Let's try. Yeah. Is it better? Yeah. Nice, thanks. So basically it's how to build uniswap V three adapter parameter.
00:28:38.736 - 00:29:31.072, Speaker A: So we take original function which is called exact int single with parameters and all these data structures was taken from original uniswap v three. We provide the same interface like original uniswap and as I said, if you send this call data to original contracts your own fund would be involved. If you send to gearbox adapter the same call data it would be executed with credit account funds. Then the first point we get your own credit account. So there is pretty simple function which called credit account to revert. If you have no credit account yet, sorry, you will be reverted if you had. We will definitely get address of this isolated smart contract which holds your funds and which funds should be executed.
00:29:31.072 - 00:30:08.556, Speaker A: The next point, we really call to credit manager to check that this transaction has enough allowance because it's like automatic approvement. And we have two policy for some contracts which we really trust. Like uniswap, we can create max int for some contracts we do not trust. We increase this allowance and after transaction we set it to zero. But uniswap e three we totally trust. If something happens with uniswap it would be end of defy and we can go to build mobile applications for pizza delivery or something like that. So no worrying.
00:30:08.556 - 00:31:01.152, Speaker A: Then we really update the recipient of transactions. So we want to get money back on credit account not to send somewhere just for security reason. Then you can see we really prepare call data with updated parameters. And then it's pretty interesting, we check balances of two tokens which would be swapped before just getting this balance of function. Then we really call function which called execute order. And this function translate your call data to credit manager which translate to credit account execute on behalf and return bytes which decode it to amounts out. And then you just should run pretty simple function which is called check collateral change.
00:31:01.152 - 00:31:34.460, Speaker A: And this function do all other magic. It compares how many collateral it was before and how many collateral you have at the moment. Just comparing the difference. As I said, gearbox is like you move assets between different boxes and if it's enough collateral, it's okay, it's done. If there is some lack of collateral, your transaction would be reverted. It's how we keep things. So as you can see, it's pretty simple to build an adapter for third party protocols and start to work.
00:31:34.460 - 00:32:53.572, Speaker A: There another point which we really definitely believe could be interesting is to build or is it clear at the moment or any questions? Yes. Another point which also could be pretty interesting is to build tokenized funds upon credit account because sometimes people special institutionals they do not want to behave from one account. Basically these people you can really make some strategies on credit account side and provide tokens for people who trust you as a trader. It's also an option like shares of future profits. It also could be interesting and of course different strategies, how to invest this money, how to get earned from convex from earn and so on and so on. A few days ago, Ilgis, our co founder, has a really interesting strategy to invest a part of money in the YDX because it was a negative interest rate and some of them into gearbox and this difference could also generate additional yields so we do not limit it. Only with gearbox you can be totally creative here and maybe some infrastructure things people also asked for.
00:32:53.572 - 00:33:28.876, Speaker A: So we want to eliminate liquidations. When someone is liquidated, it's not well for this person and for the protocol too. Of course we take liquidation fee, but it's not we are willing to create. Nobody could build a reliable business on liquidations as a protocol. So maybe any things like connection with protocols who could provide additional collateral like DeFi saver you can build your own bot which could emergency send funds to you. You can simply swap some assets. For example, as I said, there is a liquidation threshold.
00:33:28.876 - 00:34:00.148, Speaker A: So if you have depth in stablecoin and you have rub BTC, of course, because liquidation threshold around 0.7, it's low Valuated. And maybe as emergency things, you can swap BTC back to stablecoin, which would increase health factor as a result. Maybe something there, because we definitely want to reduce the quantity of liquidations and maybe ivan, can you really say hello?
00:34:00.314 - 00:34:00.956, Speaker D: Hi.
00:34:01.098 - 00:35:28.844, Speaker A: Yeah, but basically you can provide some additional info about strategies. He's a very well experienced guy in strategies and how to earn money, very successful guys. So basically, if you have any information about DeFi and all the protocols he could also consult you more questions? Yeah how many positions can there be in the account? Because DWE is like sum of stuff so when you calculate the value, do you actually iterate through the positions? Absolutely. Yeah. How large is yeah. So basically we have such things which called Alova token list, it limits these 256 tokens because to reduce gas cost to compute this portfolio value, we have a few ideas. The first one we keep inside the contract like a bit mask and one as a bit means that this token has nonzero balance and we should check it because each computation like quantity of token multiplied to price requires ice to go to price feed, requires us to go to token contract and of course, on scale it could be not well.
00:35:28.844 - 00:36:01.396, Speaker A: So basically at this point we have optimization to keep this bitmask to be more gas efficient. Another point which was implemented in V two. If we found that we have enough health factor, we stop to check in. Because we do not need to know how many health factor you have. We should just prove that it's more than one. And as I said, because we use bitmask in UN 256, we have 256 tokens. In V one, we have, I think, around 15 tokens.
00:36:01.396 - 00:36:35.620, Speaker A: In V two, it would be around 50 tokens as well. So many things and basically up to you. I think it's cool if you won't even have a lot of them because basically liquidation price and to make liquidation profitable it more depends on minimum allowed borrower amount. If you have a huge credit account, taking 5% could cover a lot of expenses. If you have like $100, taking 5% is just a $5. And there is no way for you to make this liquidation profitable.
00:36:37.800 - 00:36:41.888, Speaker D: All of the prices of the assets are taken from China.
00:36:42.064 - 00:37:05.820, Speaker A: Yeah. So pretty cool questions. Thanks for asking. Just a little bit show about. So we have oracle things. We have a special contract which is called Price Oracle. It's a core contract which create like a service for other credit managers to compute such stuff.
00:37:05.820 - 00:38:22.260, Speaker A: Basically for basic assets we use with chainlink and for LP tokens we have a special contracts which compute these prices based on chainlink price feeds. So let me show an example so this is an example how we compute for example how we compute yarn price. So as you can see, our price Oracle has the same interface like original chain link price feed. So when you call latest round data, which is done by price Oracle, it really get at first underlying asset of wiren. Then we get price per share from wiren pool via your vault. Then we have limits to be more safety. Because sometimes maybe someone could find the way to manipulate with price per share.
00:38:22.260 - 00:38:57.890, Speaker A: So to really reduce this risk, we compare. And if this price. Per share is out of bounds, we immediately rewards and then we simply multiply to provide such a thing. So basically, this approach could be really used for earn, for careful P and for Convex as well. So we do all this stuff for you. However, if you are willing to integrate new protocol, maybe you should start to consider how to compute some prices for tokens. We should get SLP tokens there.
00:38:57.890 - 00:39:04.068, Speaker A: Yes. Sorry.
00:39:04.234 - 00:39:07.060, Speaker D: How do you position yourself against Aven?
00:39:07.800 - 00:39:46.812, Speaker A: Aven probably in terms of lending. Yeah. What's the opportunity of the application? Yes, basically, as you can see, using Ava, you can get up to x three leverage. At the best case in Gearbox you can get x ten, which is much more efficient. And another point, which is also pretty cool. So let's consider how it work if we start to think about competition. So basically, let's assume that traders start different strategies.
00:39:46.812 - 00:40:36.144, Speaker A: Some of them provide more profits, some of them provide lower profits, and it create demand for pools. So interest rate goes up, and this interest rate makes some strategies less profitable. So people should really switch to most profitable ones. So, for example, if you open as a trader earn position when it was four percentage, then the price go down. You have to really switch to Convex to generate more APY. And it's why we create pretty cool interest rate for liquidity providers. Because liquidity providers get like a part of your profits here.
00:40:36.144 - 00:41:00.970, Speaker A: If you found a good way to get 6% APY from Convex, it means that you will get four or five on the liquidity providers pool. And it's okay, more and more guys could go there, provide their money for passive strategies. Gearbox like a money market, which can find good market equilibrium with extend leverage. I think it's a pretty cool moment.
00:41:01.580 - 00:41:05.960, Speaker D: Is that like in the case where someone would prefer to use Ava?
00:41:06.300 - 00:41:41.328, Speaker A: Yeah, absolutely. Because Gerbos has a limited assets, we have a limited asset in Ava. You can really provide one s get, I don't know, 0.8 USDC and it's not a leverage at all. But by the way, you definitely can work with this USDC with all protocols in a space. In Gearbox, we have limited protocols. However, even adding these seven major defy protocols could cover maybe 80% of needs of traders and strategies.
00:41:41.328 - 00:42:50.610, Speaker A: But we are pretty open, as I show you on uniswap with three adapter. It's pretty simple to build such an adapter and connect more and more things. I believe we have maybe some lack of defy protocols which we could trust, because of course, we have some serious attention to security. And if this protocol do not pass a few good if this protocol do not get some security audits from well known firm, we simply, as a Dow, I believe, do not connect it because it's a high risk and maybe using our funds you can do that. But in Gearbox we create more safe way in connecting things? Yes. Are you planning to bring Gearbox cross chain? Maybe we have some conversation to go to another chains but at the moment we want to focus on Ethereum, Mainet. At the beginning we are still very gas efficient.
00:42:50.610 - 00:44:10.962, Speaker A: We more gas efficient than our so if you want to open some short or long position gearbox would be like 13% gas efficiency cheaper, so we focus on that. But when we would have enough liquidity find better PMF strategy and people who use Gearbox on everyday basis of course we can ask them which network are really needed for you to make more money and we will follow real needs not just to be deployed on ten networks and then have a few users everywhere. So I believe we should really solve customer problems that just to go and check what's going on on other networks. Any more questions? What's about timing? Ivan? We have 1 hour 50 minutes if you have no questions. As I said, we really definitely believe that we want to create a great developer experience. So feel free if you get stuck, ask me. I think you can find yeah, maybe.
00:44:11.016 - 00:44:13.026, Speaker E: Some interesting ideas is to share what.
00:44:13.048 - 00:44:15.746, Speaker D: Things can be done composably so that.
00:44:15.848 - 00:44:20.950, Speaker E: Hackers can qualify for a few things at a time like the cross domination with other sponsors.
00:44:21.450 - 00:44:27.574, Speaker A: Yeah, it's totally possible. Can you maybe provide some additional send.
00:44:27.612 - 00:44:39.100, Speaker E: A link in discord and Twitter? So yes, like for example notification with EPNS, maybe payment with Uitx rates as you mentioned, adapter for one h something with other also.
00:44:41.070 - 00:45:52.786, Speaker A: Yeah, I think it's a good point because as I started Gearbox is about composability so we do not want to compete with other stuff. Instead of that we try to combine and really work together. So I think it's a pretty cool idea to be integrated with more sponsors and create more value for end users because in V two it's also a pretty interesting way. We create this feature called Multicol as I mentioned. So you can wrap a lot of stuff in one transaction and basically you create a widget for third party site you just go to lida and you can see you can get stake s or you can press a button and get staked s with leverage. When you press this button it opens a widget you can set up how much leverage you want, enter amount and then in one click it opens your position or increase existing one if you have already OpenCredit account and for end user it create a very smooth UX because you shouldn't definitely go to our website either. You can really go to third party website, make a one click and it's done.
00:45:52.786 - 00:47:06.196, Speaker A: And now you have x ten lido position which could generate a lot of stuff. So basically we are really looking for developers who would be happy to create such things to work together and to be truly composable. It's a good point. So I think I mean maybe yeah, let me show if you yeah, wait a second. You can go to Gearbox Fi to check so all things you can go to our channel on discord for S Global or to go to Dao because a lot of supporters and Gearboxdao they are pretty active to help you will be here in person so feel free to ask. And one more question today I had from developer about testnets. So as from my experience I participated in many blockchain hackathons if a project could be shared by a link so you can provide an ability for person just open your application and it works on testnet it creates a good experience for people and for Jury as well.
00:47:06.196 - 00:47:55.040, Speaker A: So basically we have V one deployed on Coven and to fulfill these needs we create a special service which sync uniswap pairs. It syncs chaining price oracle as well. So you have prices updated with current mainet and I got the same problems when we deployed the first version it was like one s cost $400 and people say, oh, it doesn't work, it's buggy. There is no prices in a system like $400. After that we create this sync. So if you need extra tokens Coven, Ethereum as well, we can support you and provide wherever you want to be deployed, connected, feel free and at the end of the day, you can make a really working application on Coven. And I believe today we will deploy.
00:47:55.040 - 00:48:29.790, Speaker A: The second version requires much more syncing contracts because we are going to sync earn convex and curve as well to provide a really smooth experience. So deploying on Coven playground you will have the same services, the same protocols like on Mainet. I think time is up. Yeah. Thanks so much. Thanks guys. Thank you for your attention and I hope today and this weekend we will be something really interesting.
00:48:29.790 - 00:48:31.740, Speaker A: Thank you, bye.
00:48:33.880 - 00:48:34.630, Speaker B: It.
00:49:14.160 - 00:49:19.580, Speaker E: It make sure you close turn off go to like nighttime mode.
00:49:24.240 - 00:49:24.990, Speaker A: Close?
00:49:29.000 - 00:49:31.488, Speaker E: Yeah, I mean it's your stuff that's.
00:49:31.504 - 00:49:32.932, Speaker A: Going to pop up so whatever.
00:49:32.986 - 00:49:53.150, Speaker B: You're so cool. If it.
00:50:37.850 - 00:50:43.718, Speaker E: So go to go to system we need to set up we need to turn off mirroring so that.
00:50:43.724 - 00:50:44.520, Speaker B: We can put.
00:50:46.730 - 00:50:47.190, Speaker C: Really?
00:50:47.260 - 00:50:48.120, Speaker E: Yeah, so.
00:50:49.930 - 00:50:51.160, Speaker C: You can just share.
00:50:53.430 - 00:52:07.470, Speaker B: And then eight so that's looks like yourself.
00:52:25.190 - 00:52:25.506, Speaker A: Yeah.
00:52:25.528 - 00:52:26.606, Speaker E: Nothing secret.
00:52:26.798 - 00:52:33.820, Speaker B: Maybe you want to go to the yeah.
00:52:39.800 - 00:53:06.600, Speaker C: They'Re all chasing them, right? One on one. Okay.
00:53:08.370 - 00:53:36.420, Speaker B: You doing okay? Sorry, one time.
00:53:40.410 - 00:53:42.614, Speaker C: Yeah, but you have all the chrome things.
00:53:42.652 - 00:54:06.930, Speaker B: No, it's good, we're good, we're good. No, but it's like being able to breathe. I think it's are we ready to do that? Wait a moment.
00:57:11.220 - 00:57:52.100, Speaker C: Thanks for joining us. We're really excited to tell you about Mina ZK apps built on the Mina protocol which is a layer one blockchain focused on zero knowledge with ZK app, smart contracts and a ZK bridge to interrupt with Ethereum and other blockchains. Today we have a few presenters myself, I work at O One Labs. I'm a PM for ZK apps. We have Evan Shapiro, the CEO of Mina Foundation, who will talk about the ZK Bridge. And then we have Brandon Case, an architect engineer at O One Labs, who's going to talk about Snarky JS, walk through a Hello World and give some more info to help people get going. Okay, let's talk about architecture.
00:57:52.100 - 00:58:23.752, Speaker C: As mentioned, Mina is a layer one blockchain. Our main net was launched March 2021. The big difference with Mina is whereas other blockchains are large and increasing in size as new blocks are mined. For instance, Bitcoin is 402gb in size and Ethereum is over 1 TB. Mina remains a fixed 22 KB in size. All you need is this 10 knowledge proof to verify the entire history of the chain. We call this a succinct blockchain.
00:58:23.752 - 00:59:23.570, Speaker C: Using recursive ZK Snarks, the current state of the blockchain can be compressed into a single ZK snark, letting anyone instantly sync the blockchain with the security of a full node. An enormous amount of research has gone into ZK snarks lately, both inside our company and across the industry. And our cryptography team at Owen Labs has created ZK Snark we call Kimchi, which is setupless, efficient and extensible. And it's based on Plonk 15. And you might be wondering, if we have a 22 kilobyte blockchain, how do Block Explorers query this historic transaction data? We have a type of node as one of the many nodes in our network, called an archive node, and Block Explorers can query the historic data through that, but you don't need any of that data to verify the actual chain and the consensus of it. And so with Mina based on zkSNARKs, we had an opportunity to re envision the design of a smart contracting platform. So let's talk about how Zkaps work.
00:59:23.570 - 00:59:49.560, Speaker C: As a point of reference, let's look at Ethereum. DApps. So at Ethereum, I'm sure most people are familiar with this. On Ethereum, smart contracts execute on chain. Users send a transaction, specifying a method and data arguments, and every node across the network executes these same instructions. It solves a real problem, but it's very inefficient. In contrast, Mina ZK apps use a different model.
00:59:49.560 - 01:00:37.720, Speaker C: We have off chain execution, and the smart contract runs in a web browser. Using WASM, a user will execute one of the methods on the smart contract, and private data that a user inputs into a method will end up. The smart contract will generate a zero knowledge proof, which gets sent to the blockchain, along with a list of state updates if that blockchain is proven to be correct for that particular ZCAP account. So this gives us a few advantages. We achieve blockchain scalability through succeedness. We have that 22 kilobyte proof to that proofs consensus. So that source of truth always remains very small, which of course, is the key aspect of a blockchain.
01:00:37.720 - 01:01:39.432, Speaker C: We also get user privacy through zero knowledge because the smart contracts are running off chain in a user's web browser, any data that the developer wants to keep private, they can specify private data arguments that will be input into the smart contract that the blockchain will never see. And then we also have the opportunity to have unlimited off chain execution. So Xero knowledge proofs have a unique characteristic where no matter how large your computation is, whether it's very quick or very long, doesn't matter because that zero knowledge proof that results from running that function will always be quick to verify. So we send that zero knowledge proof to the chain, and the chain can always verify that very quickly. So how does this work? A Zkapp consists of two things. So just as a matter of terminology, we use the term Zkapp to talk about the UI, the user interface, and a smart contract. And the smart contract is written with Snarky JS.
01:01:39.432 - 01:02:37.470, Speaker C: So Brandon and his portion about Snarky JS, that's what he's going to help people get started with. So how does this work? When a developer writes a smart contract and they run their build in their application, it generates a prover function and a verification key. The prover function runs locally and generates a zero knowledge proof. So this is what's going to run in the user's web browser when they're interacting with the CK app. And then it also generates a verification key that they deploy to the network. So if you're a developer and you update your application logic, you will build again and generate a new verification key that you deploy to the blockchain, and then you have a new deployment. So any transactions will then have to pass the verification key at that point in time.
01:02:37.470 - 01:03:37.810, Speaker C: So again, deploying a verification to the chain creates what we call a Zkap account. This is exactly identical to a Mina account. However, when the verification key exists on it, we call this a Zkap account. And transactions, they have to be valid, as mentioned, for the verification function, and they will only be accepted by the network if they are in fact appropriate for that ZCAP account. And that's how we can ensure that even with off chain execution, that we know that zero knowledge proof that the user has run the expected computation. And if they haven't, the transaction will simply be rejected by the network. Okay, so in a little more detail, let's talk about how a smart contract works.
01:03:37.810 - 01:04:13.672, Speaker C: A smart contract, keep in mind we're running in the user's web browser, accepts a few different things. We have method arguments which can be private data. And then we also have some smart contract states, which is public data that lives on the blockchain. And this generates a couple of outputs. So updates to the state of the smart contract, that public state that lives on chain, and updates to the state of the world. So maybe you sent Mina and you changed somebody else's balance. And one really important thing to mention is we have what are called preconditions.
01:04:13.672 - 01:04:35.030, Speaker C: So as a developer, if you want an action to only occur such as sending funds from account A to account B after a certain block height, you can specify certain preconditions and you can specify those based on either something that's account state related or network related related that way too.
01:04:39.480 - 01:04:40.084, Speaker B: Okay.
01:04:40.202 - 01:05:15.520, Speaker C: And smart contracts, the really cool thing about smart contracts on Mina protocol is they're written in typescripts. So you have the opportunity to use DS code, NPM, prettier, whole bunch of technology that you're already familiar with and you can download if you want to get started today, you can download our ZCAP CLI. So for Brandon's presentation, just keep in mind that you can run two commands and have a project set up and be ready to go with your projects. And I want to pass to Evan to talk about the bridge.
01:05:18.980 - 01:06:31.612, Speaker F: Awesome, thank you. Yeah, I'm going to talk about a part of Mina, a really cool component called the ZK Bridge. So this is this question of, okay, we have this cool Zkap functionality. How can we make this useful and available on all these other platforms? Because we have very efficient zero knowledge proofs. Maybe there's some way we can get that to other chains, which seems like it would be pretty cool thing and valuable to everyone else on those other platforms. So the answer to this we have is this DK bridge, which leverages Mina's succinctness for a cryptographically secure bridge to Ethereum and other chains. The current merkle route of the ledger, the current state of the ledger is correct and has valid consensus information backing it since the beginning of time.
01:06:31.612 - 01:07:16.284, Speaker F: And you can check that zero knowledge proof and know that you're looking at the correct state of Mina. And what's cool is this is lightweight enough that we can run that itself inside of an EVM contract. So that's as if we have a full node of Mina, in a sense running inside of a smart contract. And what's cool then is that anybody can then update that smart contract because the smart contract itself can run Mina's consensus and strongest chain rule. So it's like this decentralized way of having a contract that contains the strongest state of Mina at any time. And then what's cool is that with one bridge update, so one verification of a recursive zero knowledge proof, you can move over all the state that has changed on Mina since the last time you updated the recursive zero knowledge proof on Ethereum. So if that made sense, great.
01:07:16.284 - 01:07:49.576, Speaker F: If not, we're going to run through an example so you'll see how it works in detail. The example we're going to go with is let's say we wanted like a private proof of attendance. I think there is actually proof attendance program, which is super cool. This is like a private version of that. And we want to make that work between mina and Ethereum. So the way this can work is first, what happens is a developer is going to write this program called Was at Ethereum that runs on mina. And a user can create a new zero CK app account on mina with the verification key for the app.
01:07:49.576 - 01:08:25.652, Speaker F: The developer wrote, great so far. And the data field on this is all zeros because we haven't filled it in yet, but we'll fill it in in a second. Next that happens is user submits a zero knowledge proof that says, okay, in this example, I have an identity. That identity has been verified by a third party. Like, I went to the DMV website and looked at that page and it was good, as well as an actual valid ETH Amsterdam Pass and they matched. And then what I can do is I can make a zero knowledge proof of that and submit it to Mina. And then that allows me to update the data fields on mina on this DK app, in this example, to my Ethereum public key.
01:08:25.652 - 01:09:09.084, Speaker F: So note that if I didn't have a valid zero knowledge proof that contained this private information about my attendance, I would not be able to update this ZK app with that public key. And it would just be all zero still. But because I was, I was able to add my Ethereum public key into the Mina account. Great. So what's next is that we have to get that mina state account onto Ethereum itself. And for that, we're going to look at what I've called here like the Mina Bridge account on Ethereum, which contains as its data, not the whole tree, actually, but just the merkel root of the tree for mina's ledger. And then an operator, someone who wants to update that account in a decentralized way, can send over that merkel route and consensus information back to Ethereum.
01:09:09.084 - 01:10:15.848, Speaker F: And if the consensus information in that new proof is actually stronger than the proof that was already on Ethereum, it updates to that latest proof and latest merkel route. So after this, our Merko route that happens to contain the ZK app, which happens to contain my Ethereum address, is now on Ethereum. Great. So after that so in this example, it's like a Dao for people that happen to attend. Here what we can do is someone can attempt to register and the registration process includes a merkel path from the Mina merkel route in the Ethereum smart contract down to that account that contains that Ethereum public key. And the user can prove that that was included, that corresponded to the verification key that actually corresponded to the ZK app that was written, and that they actually have the private key that can make signatures which correspond to that public key in any case. So with this, they can register themselves into a Dao using a ZK proof that they have the rights to do that.
01:10:15.848 - 01:10:43.580, Speaker F: So I hope I didn't go to that too quickly. But that's basically the flow that one can imagine for how you can write something on Mina that takes advantage of zero knowledge proofs. And then from Ethereum or other chains, you can then access that as part of your application. So there's a bunch of possibilities one could imagine with this. You could build a private Dao if you wanted to. You could pull real data in to bootstrap more DeFi things. You could build NFTs that have some cool ZK properties.
01:10:43.580 - 01:11:23.596, Speaker F: One in particular I think would be cool is like a collection where each person can own at most one NFT. So if you have a bunch of capital, you're still limited in how much you can take from the collection. You can put anonymized proof of on chain information. For Ethereum or other chains, you could build ZK powered games like Battleship is like a good one. There's a privacy element. I think another thing that potentially will be cool, well, at least interesting is making it possible to actually move private enterprise data onto public chains for that interoperability without losing the privacy aspect for those as well. As one thing I think is also very cool, it's very easy to spin up a ZK roll up in this framework because the cryptography is done.
01:11:23.596 - 01:11:34.000, Speaker F: You just kind of have to write the recursive step for your ZK roll up and then do that off chain and then submit a big proof back to but that's all I have for this part. Thanks. Yeah, I'll hand it up to Brandon.
01:11:41.480 - 01:12:11.656, Speaker E: Hello. Cool. Okay, I'm going to talk about snarky JS. So Snarky JS is a toolkit SDK that lets you build ZK apps and you use TypeScript. And so because it's TypeScript as Jason mentioned, we can use open technologies. The actual execution happens in the browser or node JS typical runtime environment. You can use existing JavaScript and TypeScript libraries and tools.
01:12:11.656 - 01:12:44.344, Speaker E: That means you can also use like Vs code and you get all the benefits that you get from Vs code. All the ID support of just JavaScript and TypeScript that thousands or millions of person hours have been poured into. You get to use that. So cool. Snarky JS. I know maybe some of this stuff seems really scary after we saw the details of the architecture and the bridge example, but the code is really not scary. I will prove it in a moment.
01:12:44.344 - 01:13:35.576, Speaker E: First, so I want to talk about the base sort of unit of data in zero knowledge programming field element. So a field element, it can store a number that's almost 256 bits in size for the field that Mina uses. You can think of it like a UN 256 in solidity, but it's just slightly smaller for those that are like ZK crazy people. The field type in Snarkyjs. This is the base field of the Pious Curve and the scalar field of the vesta curve in Mina's pasta curve system. Unless someone on my team corrects me and I got those mixed up. But if you don't know what I just said, it really doesn't matter.
01:13:35.576 - 01:14:18.144, Speaker E: Just think of it like a 256 bit unsigned integer. In typical programming of TypeScript, you might sum two numbers by creating a local variable and then writing the integer literal one, the symbol plus, and then an integer literal three. I guess I don't know a numeric literal. I don't know what you call them in JavaScript, but those are JavaScript numbers. In TypeScript we can't override numeric literals. So we have a little bit of wrapper glue to sort of tell the Snarky JS engine that we're using field elements. So this is how you would add one and three and this is a little cumbersome.
01:14:18.144 - 01:14:41.900, Speaker E: So there's some syntactic sugar anywhere that it's unambiguous. What you mean the methods accept a numeric literal, a string literal that corresponds to a number or another field element. So it's just like a little bit slightly more characters than one plus three.
01:14:42.050 - 01:14:42.364, Speaker A: Cool.
01:14:42.402 - 01:15:25.130, Speaker E: So there's other built in types besides fields. Here's a few of them. So besides field, Bool is one and this is just a field that's constrained to be zero or one. But it has a bunch of helpful methods on it for things that you might want to do. With Bools, we have unsigned integers of sizes that are normal for machine like computational machines like this laptop and then public key, private key signature. For Mina's system we have a schnorr signature and then some other cryptography things, group scalers. The scalar is the other field in the recursive pasta system.
01:15:25.130 - 01:16:03.670, Speaker E: Again, it doesn't matter if you don't know what I'm talking about. All of these have built in methods on them. And because it's TypeScript and because we have Vs code and other IDs like that, you can just import one of these things, create an instance of it, and then write your variable name dot. And then Autocomplete will just help you explore the SDK. You can just write functions. So in TypeScript you write a function like this, you can give your parameters types and you can return a type. And here we are adding one to x and then doubling it or multiplying it by two.
01:16:03.670 - 01:16:46.992, Speaker E: Just like in TypeScript. I mean it is TypeScript, but just to really show you, we can take a part of that expression and assign it to a local variable. So it's really normal programming. I'm harping on this because if you attempt to program using any other zero knowledge proof framework, you will miss normal programming, I think. So let's go through a simple hello world. Okay, a hello world smart contract. So we're going to write a smart contract that has a single piece of state, a field element that we call x and we're going to constrain the well, we're going to have one method called update.
01:16:46.992 - 01:17:18.640, Speaker E: And we're going to only allow update to replace X with its square. So just to give you a sense of what I'm talking about, if we start at three, the only update that's valid is nine. And if we're at nine, the only update that's valid is 81. So if we start with three, update it to nine and then we try and update it to 75. Actually, the proof won't even be created. But if you try and send something messy, or if you try and spoof the chain, it'll also reject your transaction.
01:17:19.620 - 01:17:20.032, Speaker A: Cool.
01:17:20.086 - 01:18:04.776, Speaker E: So let's write it. First we extend smart contract. You just write a class extend smart contract. We make the state by adding a member variable with some decorator stuff. And this line of code is a bit confusing, I suppose, but it's doing so much for you that it's amazing. What this says is X is a piece of state that lives on chain and its type is field. And you can actually use any type that's built out of field elements here, which I'm not going to show in this slide deck, but you can see in our examples and this is public and on chain.
01:18:04.776 - 01:18:21.430, Speaker E: So we're going to say what happens when we deploy. Okay? By default there's some things that happen, but we want to override the default by setting it to three. So we call super deploy with the input and we set X to three.
01:18:22.840 - 01:18:23.396, Speaker A: Okay?
01:18:23.498 - 01:19:00.568, Speaker E: So now the actual update method, let's just speak about methods. I guess smart contracts have multiple methods or they can this one only has one and these are the things that you can do to a smart contract. So this is like the functions you can invoke on it. And Jason was mentioning this, but I'll say it again with the code. The state, the member variable there, that's public. That's on chain. Anything you store there is publicly know.
01:19:00.568 - 01:19:24.900, Speaker E: If you store a hash, then only the hash is publicly readable. But it's public. The arguments to the methods are private and they're only visible on the user's machine. And if you don't put them in some public state, they will just remain private. In this case, we are putting it into public state. So you can see that on line. The third line of that method.
01:19:24.900 - 01:20:27.112, Speaker E: The other thing that's happening here is on the first line of the method, we're calling this X Get, which fetches the current state of the ZK app from the chain. And there's some magic that happens that Gregor can tell you later where this isn't actually asynchronous because we sort of get it before this runs. But the point is, I mean, there were a couple of reasons we did that, but a nice benefit is you don't have to even worry about like async await. You can just write normal, plain, sequential programs so that gets the state. And then we do this thing on. The second line where we add an assert we assert that the square of X is equal to the thing that we passed in. And this isn't just something that, I guess typically when you have assertions, you put them in there for sort of your sanity as a developer.
01:20:27.112 - 01:21:02.112, Speaker E: But this is actually something that is sort of part of our smart contract. The thing that actually happens when we run this again, Jason talked about this in the abstract, I'm going to talk about it in the concrete. What we do when this executes is we produce a transaction. It has a proof in it that says we ran the code in this update method with some private arguments. And the result of that were the following instructions that get sent to the chain. In this case, set X to be nine. That's the instruction.
01:21:02.112 - 01:21:43.590, Speaker E: And it assumes a precondition that X is three. So that gets baked into the smart contract. If the transaction is sent when the state is not three, then this will fail, which is what we want because we only want to update it to its square. Okay, so this is kind of what smart contracts look like. I mean, this is a very simple one, but there's member variables which you can use for state, public state. You can override the deploy method and you can add methods with this at method decorator that correspond to the specific updates that you want to perform to the network, I guess.
01:21:44.920 - 01:21:45.428, Speaker A: Cool.
01:21:45.514 - 01:22:29.920, Speaker E: So now to test this, there's, I guess, a lot of things you can do. The thing that we recommend that you do for this hackathon, because it is the most easy to use at the moment is testing locally. Here's an example, what we're doing here. At the top, we're grabbing an instance of this local blockchain. You can kind of think of this like a sandbox VM, literally. It's like part of Mina that's compiled to JavaScript so it is accurately emulating the real blockchain. And then we send a transaction using account.
01:22:29.920 - 01:23:12.640, Speaker E: One is the one who pays the fees for the transaction. So you have a private key there. And then in there we're only deploying the smart contract in this example and then sending that's, that dot send at the end. And then we can also at the top here, we can send an update, we can update it to nine. And then afterwards we can get account states and then print them out or check them against something else in like jest in a Jest test. If you're a web programmer, you'll know what that means. Or you could just put that in another executable for your testing purposes.
01:23:12.640 - 01:23:47.880, Speaker E: Yeah. So I also want to just show Evan touched on this. But roll ups. Here's a roll up and it's like ten lines. It's probably like going to be 50 lines if you actually unwind the dot, dot dots, but it's 50 lines. A ZK roll up this API we have not fully wired in, but I just thought it would be really cool to show. So at Proof system you extend proof to make a custom proof that's not this proof isn't actually on chain.
01:23:47.880 - 01:24:39.020, Speaker E: We create the proof and then send the proof through a smart contract on chain. So we extend something different and then maybe you deposit money into the roll up. You can send transactions between accounts within this roll up environment and then you can merge proofs together. So, yeah, this is pretty cool. The one thing I also want to just touch on this for people who have tried to use recursive zero knowledge proof programming before, it's probably not a large number of people, but if this is one of you, you have to flip between the two different fields every time you recurse. And this is actually really complicated and annoying to write code for. And the pickles recursion execution engine in Mina.
01:24:39.020 - 01:25:45.564, Speaker E: Double flips for you. So all this means is you really only have to think in one field, which is really something that makes your life easier. So that's that. How do you learn more? Well, you can go to these places. So the docs, the discord, you should also look for people with these hoodies, most of which are members of either the Mina Foundation or O of One Labs and we can help you understand things. Oh, and the other thing I want to mention, we are in real time getting like we have, we have successfully deployed Zkap transaction like Zkap Smart contracts to a live test network and interacted with them in a live network environment in constrained conditions. And we are actively at this second, working on making those constrained conditions less constrained.
01:25:45.564 - 01:26:09.130, Speaker E: So if you are at a point in your hackathon project where you are like, I'm done, I'm tested it's great. And I want to hook this up to a live network, then you should look for well, look for people in these hoodies and we'll point you to the person in the hoodie that you should talk to so that's that.
01:26:11.740 - 01:26:12.008, Speaker A: We.
01:26:12.014 - 01:26:12.760, Speaker E: Have time for questions.
01:26:12.830 - 01:26:13.610, Speaker F: I think.
01:26:19.420 - 01:26:20.170, Speaker B: It.
01:26:22.380 - 01:26:28.672, Speaker E: Yeah. Do we want to mic the question? Answerers? I can just talk really loud. I'll repeat your question.
01:26:28.726 - 01:26:29.424, Speaker B: Okay.
01:26:29.622 - 01:27:47.152, Speaker E: Given the constrained size of the chain, how do you infer the state of any particular concept at a given time? Yeah, so the question was given the constrained size of the chain, how do we get the state of anything that we care about? Okay, so there's like a lot of nuance and a lot of different answers. So I will answer the question that I think that you're asking, which is and you tell me if I'm answering the wrong question. So this 22 kilobyte number actually on our homepage, there's like a SuperScript and you can click on it and it's a blog post that I contributed to that explains in detail exactly what we mean by these 22 KB. If you read those details, you'll see there's a proof that's like 1 KB ish and then there's like a bit of metadata and a merkel path to an account that you care about. How do you get the state that you care about? You ask a node that has some state and I just want to highlight the nodes that are participating in consensus and mining blocks. They have the current state of the world. You need that to produce blocks.
01:27:47.152 - 01:28:21.604, Speaker E: You do not need that to be like a full node in the security sense, but you need that to produce blocks. So there are a lot of nodes in the network that have the current state of all the accounts. There is no node that's needed for consensus that has ancient archive state. As Jason was saying. There are some that do because sometimes people want it, but it's not needed for consensus. But it is needed for consensus to produce blocks to have that state. So sorry, this is a long winded answer, but you just go and ask those nodes for the state in the same way that you go and ask an arbitrary ethereum node for your account and it gives it to you.
01:28:21.802 - 01:28:23.030, Speaker B: It's the same thing.
01:28:24.840 - 01:28:32.244, Speaker E: Do you think there's any limitations with doing all this proof? Because I see this there's a verification fee as well.
01:28:32.362 - 01:28:32.644, Speaker A: Yes.
01:28:32.682 - 01:29:30.250, Speaker E: Also there's constraints that need to be met for the proof when it comes in as well that goes into it. Do you think if I had like a really big program that I was running, do you think that maybe I might be the question was, are there constraints on how big the program is, given that there's this fixed verification key? And naively, the answer is yes, there is a fixed maximum size that your computation can be per verification key. And this is true. However, because we have recursion, we can just recurse and loop a bunch of times and do very complex things that don't fit without recursion into one proof. I guess I'm realizing that might not make sense to people, but it is true. So that's the answer. Yeah.
01:29:31.500 - 01:29:41.656, Speaker D: So do you some Snark team algorithm that doesn't require a setup for each and every new startup?
01:29:41.688 - 01:30:02.292, Speaker E: Yes, very good question, and I wish that we had mentioned it in the talk. I'll mention it now. The Mina ZK snark does not have a trusted setup. It is a false god that I don't know what the term is. It is untrue that Snarks imply trusted setups. Some people have this meme. It's not a real thing.
01:30:02.292 - 01:30:39.680, Speaker E: Our Snark does not have a trusted setup and it's universal. And one of our cryptographers can correct me if I say this wrong, but that means that we can basically change what the circuit is at runtime and change. And in Mina's case, we can recurse arbitrary new circuits into the main Mina circuit. So all this means, like, when you are writing a ZK app, when you're writing a smart contract, you can deploy an arbitrary new circuit and it gets folded into Mina. And there's no trusted setup. There's no setup.
01:30:41.060 - 01:30:43.330, Speaker D: But is there no trust?
01:30:43.780 - 01:30:53.552, Speaker E: There is full trust. Sorry. You trust no one because the cryptography works without trusting a setup.
01:30:53.696 - 01:30:59.216, Speaker D: I mean, you said that your setup is not trust. Did you have, like, a ceremony?
01:30:59.408 - 01:31:03.430, Speaker E: No, Mina did not have a ceremony because Mina's Snark does not require a.
01:31:04.680 - 01:31:06.636, Speaker D: So it is safe?
01:31:06.768 - 01:31:36.672, Speaker E: It is safe. And the cryptography is even safer than I think. Ceremonies aren't that untrustworthy personally, but Mina didn't have any ceremony, and so it's even more safe than if you did. So, yes, it's safe. Good cryptography. I mean, it's newer cryptography, so sometimes that scares people. But we have very smart researchers and research papers and audits and people reviewing stuff.
01:31:36.672 - 01:31:38.016, Speaker E: So I think it's fine.
01:31:38.118 - 01:31:48.336, Speaker A: Okay. When you said strongest train, I guess that relates to some mechanism like proof of stake.
01:31:48.448 - 01:32:32.500, Speaker E: Yes. So actually the recursive zero knowledge proof way that Mina compresses the blockchain is sort of orthogonal to the Consensus mechanism and actually an early test version of Mina. We implemented proof of work because it was easier, but we didn't want to release that. So it's proof of stake because we chose that we wanted proof of stake. And specifically, the consensus mechanism is a variant of Oroboros, which is called Oroboros Samasica, and you can look online and read about it. There's a bunch of talks and papers and things. Oroboros was originally created by the IOHK cardano folks and Mina tweaked some things to make it work in a succinct environment.
01:32:32.500 - 01:32:34.710, Speaker E: Yes.
01:32:36.280 - 01:32:37.590, Speaker D: How connect.
01:32:41.080 - 01:33:25.636, Speaker E: Say that again? How do you connect? Like an NFT? Yeah. One thing I'm really excited about is bringing Mina proofs to Ethereum through the bridge as non transferable NFTs. I think that's like an awesome cool thing. That framework for building that has not been written. It would be a really good hackathon project. I'm going to contribute to judging on one of the projects, and if someone implements that and it works, I will vote for that project. The answer is you should build that.
01:33:25.636 - 01:33:43.930, Speaker E: I don't know. The ZK bridge isn't deployed yet, right. So you can't actually run it yet on Ethereum. Ethereum. But you can still build the infrastructure. So that right. When the bridge is deployed, we can do that sort of thing.
01:33:43.930 - 01:33:48.430, Speaker E: So I hope that sort of answers your question.
01:33:49.760 - 01:33:51.630, Speaker D: Could you repeat the the question?
01:33:52.000 - 01:34:37.870, Speaker E: Sorry. The question was how do we interact with ERC 721 NFTs in Mina? And I guess with Mina, I answered one half of that, which was, how do you output them? And then the other half is how do you input them? And that is also part of a bridge that doesn't yet fully exist. But also if you build part of that, it would be a good hackathon project, and you can talk to if you feel like you have enough in your brain to understand how to build something like that. One of us in the hoodies can help you understand how to do that as a project.
01:34:39.360 - 01:34:45.804, Speaker D: Another question, do I understand correctly that the bridge basically you could use it.
01:34:45.842 - 01:34:51.688, Speaker B: To reduce fees from instead of verifying.
01:34:51.704 - 01:35:01.190, Speaker D: The proof on the ethereum chain, you have to just verify the miracle pass. Right. So that's the gas optimization that you could do, right?
01:35:05.960 - 01:35:14.212, Speaker E: Yes. Well, someone is verifying the Mina proof on chain, like whoever is updating the bridge. But yes, once it's already there, it's just a merkel lookup.
01:35:14.276 - 01:35:14.552, Speaker D: Okay.
01:35:14.606 - 01:35:14.968, Speaker E: Right?
01:35:15.054 - 01:35:25.080, Speaker D: Yeah. Are you supposed to update the bridge? Who runs the bridge?
01:35:25.520 - 01:35:38.876, Speaker E: Yeah. There are a lot of entities that could run that post those updates. I bet Evan has. Thoughts on the plan is it'll be.
01:35:38.898 - 01:35:44.016, Speaker F: Decentralized, anyone can be an operator. And if you want to help us test being an operator, then you should.
01:35:44.038 - 01:36:29.010, Speaker E: Also reach out to us. I'll repeat on the microphone, the plan is that, well, it's decentralized. Anyone can be an operator. And Mina Foundation, as represented by Evan, says that they want I'm part of OVone Labs separate company. They want to help people be operators. If you want to be one of those operators, you should talk to someone in a hoodie, and we'll help you learn about that. The question is, how does the fee system work? So, yeah, I think Jason mentioned this, but because all transactions in Mina and actually even before Zkapps, this is how it works.
01:36:29.010 - 01:37:07.580, Speaker E: They all correspond to verifying a proof. They're all the same price. So they're all the same price. I guess there's some nuance where there is a way to build ZK apps such that a single method that you write in Snarky JS actually compiles to several transactions, and then you pay per extra transaction, but it's a fixed gas cost per transaction. And that means you can do some crazy computation, which the user will pay for, because when they're using your application, they'll perform that a computation, but you don't pay for it with gas.
01:37:10.390 - 01:37:25.814, Speaker A: I'm curious if I have, let's say, ten pending transaction, and every one of the transaction wants to interact with one smart contract, does it mean just one transaction will go through and the nine are invalid because the one will change?
01:37:25.852 - 01:38:07.570, Speaker E: Good question. Yeah. If you build your state machine in such a way, like this example, where there's like a sequential ordering of updates that needs to happen, then there's a race, and whoever gets their first wins, and the rest are invalid. But you can design your state machine. And there are a lot of ways to do this in ZK apps and conceptually, you can design your state machine such that updates can be reordered. And that is what you should do if you want that property. But it means that you have to think a little bit harder about how you design your smart contract.
01:38:08.170 - 01:38:08.920, Speaker A: Please.
01:38:11.290 - 01:38:51.300, Speaker C: So that's a really great question because with the off chain execution model and off chain storage, which is in progress, as far as making it elegant, there are a couple of different approaches to that. Also, the preconditions we mentioned, the network preconditions and account preconditions, I believe that we can work on that to create very elegant preconditions that might be tailored to a specific app that could really help address that. And then when we have rollouts as well, and actually one of our CK app builders in our recent program has started a roll up that would have another opportunity to provide sequencing as well for a particular app and use case.
01:38:57.280 - 01:38:58.030, Speaker A: Cool.
01:38:58.960 - 01:39:06.646, Speaker E: Any more questions? Oh, go ahead.
01:39:06.828 - 01:39:15.634, Speaker A: I think we need to store more complex data on off chain because what if we lost off chain data forever?
01:39:15.762 - 01:40:07.606, Speaker E: Yeah, so the question was, sometimes we need to store things off chain because they might be more complex. I should just mention, because we didn't mention this in the current testnet, I guess this isn't set in stone. We're thinking that each account has eight field elements worth of storage on chain, which is a very small. So a lot of times you'll have data that isn't on chain. And the question was, what happens if that data gets lost? And the answer is your application won't work, but Mina will still. So it's up to you as an application developer, I guess sorry, there's a couple answers to this. The current answer is it's up to you as an application developer to solve this problem in the way that you think is important for your application.
01:40:07.606 - 01:41:18.560, Speaker E: So the easiest thing to do is just have a file that has the state in it and you can think of this as like a single sequencer. And this is from my understanding, how basically all the L two S work right now that people have a lot of capital on and people seem to be okay with that. You can do something that's more safe and decentralized by having a tendermint chain that keeps track of the state, or you can have the merkel tree in, I don't know, some flash drive that you make a copy of and hand to your friend so you can do anything for the state. As a Snarky JS toolkit developer, person, architect, whatever, I'm called myself and Jason and a bunch of other people, we will be working on ways to solve this problem in sort of more cookie cutter ways. So it's easier for application developers to make that decision and they can just kind of take something off the shelf. But right now it's a little bit more manual. Yeah, hopefully that makes sense.
01:41:22.380 - 01:41:22.792, Speaker A: Cool.
01:41:22.846 - 01:41:49.590, Speaker E: I think we're out of time, actually, so thank you. Remember anyone wearing these colored hoodies and or these links, you can come and ask other questions or whatever, and please build stuff. There's prizes. I think someone's going to announce that, so yeah. Thank you.
01:41:53.160 - 01:41:54.500, Speaker A: What's our prize?
01:41:56.040 - 01:41:57.830, Speaker E: We have prizes. Okay.
01:43:38.620 - 01:57:37.300, Speaker B: It Ram. It sam SA sam. Sam. Sam it's sam it.
01:59:45.390 - 01:59:52.834, Speaker A: Put it on the biggest part of your wrist and kind kind of get it slightly that way. It looks kind of tight. Whatever.
01:59:52.872 - 01:59:54.210, Speaker C: It doesn't no one cares.
01:59:54.550 - 01:59:55.326, Speaker E: No one cares.
01:59:55.358 - 02:00:24.146, Speaker A: Let's let's go have fun. You don't need you don't do that. This is just oh, yeah. No, we'll get you another. I thought it was really, like you.
02:00:24.168 - 02:00:29.860, Speaker E: Had, like imagine that.
02:00:32.730 - 02:00:42.950, Speaker A: Yeah, in a good way, though. You can tell when people, like, really push.
02:00:52.020 - 02:01:03.550, Speaker E: But I never write down oh, really? Just, like, kind of know and what. And I just I didn't do it at that time, but I think I'm.
