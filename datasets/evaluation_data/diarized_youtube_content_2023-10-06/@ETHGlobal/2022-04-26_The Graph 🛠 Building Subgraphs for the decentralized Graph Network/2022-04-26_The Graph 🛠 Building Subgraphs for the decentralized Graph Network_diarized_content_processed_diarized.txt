00:00:05.770 - 00:00:27.970, Speaker A: Seems like I need a new laptop. Yeah. My name is Simon. I'm a solutions engineer at Edge Node. That's one of the core devs behind the graph. And because we lost a little bit of time, I'd just go very quick and maybe have some time for questions. So like, for a DAP you need to be fully decentralized.
00:00:27.970 - 00:00:57.598, Speaker A: This is what the graph can do. So you can have no servers, you can break free from authorities. So this is roughly how it looks. So you have like, DApps, they communicate with smart contracts. The problem there is that the blockchain is not really made for data reading, it's made for data writing. So you pay gas to the miners to get your block in, but you do not pay anybody to read the data. So nobody's actually incentivized to do this.
00:00:57.598 - 00:01:35.958, Speaker A: And if you look at the protocols, it's kind of a mess. It's everything mixed together. And then if you want to retrieve data in the front end, it looks like this kind of very messy code. So the graph is kind of this API, provides APIs for this decentralized future that we all work towards together. We have currently 1 billion queries on the hosted service per day and it's a decentralized indexing protocol. Actually, it's not only the hosted service. So when you look back to those all transactions that are kind of mixed on the blockchain, what the graph actually does is kind of it creates separate databases for each of the protocols.
00:01:35.958 - 00:02:30.170, Speaker A: So then you can just query the one data that you're actually needing. So kind of the new architecture is like you have a user interface that directly writes to the blockchain but reads from an indexing protocol like the graph and you have the data sources. This ethereum but also near is integrated Arbitrum optimism and RV is being worked on. So like there are even more data sources that come that can be indexed by the graph. So in the end, we end up with this very neat GraphQL query that yeah, that was the same before, but it's just much, much nicer. So since one year you can really deploy your subgraph to a decentralized network, there are 150 indexes all over the world and then it's going up. So it's really possible to have decentralized data storage for your DAP.
00:02:30.170 - 00:02:56.882, Speaker A: Yeah. So you can really have truly decentralized apps. Yeah. This workshop usually it's 1 hour, but I do it in 15 minutes. So we look at NFTs So NFTs basically are these simple contracts or interfaces. Basically we just look at the transfer event. So every time you move an NFT around, then a transfer event is emitted and in the subgraph you just store that.
00:02:56.882 - 00:03:19.820, Speaker A: As I said before, you can watch for these events and then store it into the database. So this is how roughly it looks. On the top you have the DAP, it writes through the smart contracts. The graph node indexes. The data from the smart contract, puts it into the store, and on the left side, the DAP queries through a GraphQL API. This data. I have some tips and tricks here, but I skipped that.
00:03:19.820 - 00:03:52.338, Speaker A: Also, there are some patterns, but we will see them later. But actually, when you scan that QR code here, then you arrive on a GitHub page. And on GitHub page, this presentation is linked so you can kind of at your own time go through. Because what I really want to show you is how it's actually made. Because that's why we are here, kind of. It's a hackathon, not a pump and dump conference. And here is my Twitter.
00:03:52.338 - 00:04:16.682, Speaker A: But yeah, let's start with this. So I should have it open already. Here it is. All right, so basically we just take an NFT contract. Oh, that's the wrong one. Yeah, it's old. So we take NFT contract.
00:04:16.682 - 00:04:44.866, Speaker A: So in this example, we take the hashmask contract. So it's kind of this address on Ethercan. And then you need to install the graph CLI. And then you can run this simple or maybe even a little bit complex command. What it does, it says like, I want to create a new subgraph. I want to have it using the subgraph studio. So I'm ready to deploy the decentralized network.
00:04:44.866 - 00:05:14.290, Speaker A: I did specify the contract that I want to index. I want to index all the events automatically. That's cool. Then I give a name for the contract to say which network. This is Ethereum mainnet, but you can also do binance, polygon, Arbitrum, optimism, salo and whatever on any other kind of EVM compatible blockchain, but also near. But then the context look a bit different. But I mean, it's if Amsterdam here so we do Ethereum.
00:05:14.290 - 00:05:41.980, Speaker A: Yes, then you can provide an Abi. Actually, on Ethereum you don't need to provide an Abi. And then you give a name for the folder. And lastly, a name for the subgraph that you create later in studio. All right, let's do this. I go quickly in my folder. So let's just copy paste this in.
00:05:41.980 - 00:05:47.100, Speaker A: I think it should work without Avi. So let's kick that.
00:05:49.310 - 00:05:50.300, Speaker B: Let's see.
00:05:54.210 - 00:05:57.520, Speaker A: What it does. Yeah, all right.
00:06:00.210 - 00:06:02.510, Speaker B: This was kind of expected.
00:06:08.980 - 00:06:42.350, Speaker A: So, yeah, I tested it before. So this directory already existed, but it fetches the API from either scan. Then it creates this subgroup Scaffold, which we just look into now. And then it initialize the whole thing. It installs a dependency with yarn and bootstraps, everything. It's actually quite convenient, especially this index events. Like if you get started with a subgraph development and you have kind of a contract you want to index, I would advise you to use that index events because that creates you boilerplate code that makes more or less sense.
00:06:42.350 - 00:06:53.090, Speaker A: So we can now go into this what's to say hashmark subgraph two.
00:06:58.180 - 00:06:59.250, Speaker B: Here it is.
00:07:00.340 - 00:07:37.982, Speaker A: Um, right, so this is how it looks like. So when I when I look at the subgraph, then usually what's interesting is actually it's package JSON because it's JavaScript project. So here in the package JSON, it's actually not that much going on. So you have these two dependencies graph CLI and graph TS. And then you have this code chain and build commands. We will execute them. So you will just see also the deploy command is already here.
00:07:37.982 - 00:08:29.130, Speaker A: So it's quite convenient. Then the next thing that I look at is the subgraph YAML. Here is kind of the manifest of the subgraph. Here it's written what's going on? So we have stuff like again, which network do we index, what's the name of the contract, what's the contract address, the API name? And here the event handlers. Like which events we all start to watch for. And what's important, unfortunately not comes out of the box is that I would really advise to if you have the source that you provide the start block because then you tell the graph that just start at this block and not like from block zero, which makes indexing much faster. So we can actually go in this creation transaction.
00:08:29.130 - 00:08:52.274, Speaker A: And then we have here the start block. So we can take the start block, put it here and yeah, I would say that's it. And then it also generates a schema. It's kind of a database schema. You have the entities, entities you can think about. It's kind of tables. Now we just stored events.
00:08:52.274 - 00:09:16.302, Speaker A: It's not super sophisticated. So we just have this approval stuff, the name change that is a little bit special for the hash mask. Then ownership transferred. But then the transfer event, which is actually the one that I'm most interested in. And then we have a mapping and the mappings is kind of this glue code. So here you say like which events do we want to watch for? So we have the event handler. So we want to say for example, every transfer I want to do something.
00:09:16.302 - 00:09:48.314, Speaker A: Then you say like, okay, this is the handler. Then it jumps into, jumps into this mappings and checks for this handle transfer and then executes this. Also this is actually quite simple. So we just create a new entity, we give it some ID. It makes sense to use the transaction hash and the log index. So it's kind of identical per actual event. Then we have the from token ID and we just save it.
00:09:48.314 - 00:10:19.154, Speaker A: It's not so crazy. And now if we have this, we can already do this yarn code gen. This in the background creates the boilerplate code. So it goes into this generated folder and writes according to the API and the database schema. It writes these helper functions which in the end and in development helps. So you can for example, say like, oh, I want to know what's inside of the transfer event. Because assembly script is similar to TypeScript, it just works.
00:10:19.154 - 00:10:38.170, Speaker A: So I can click here and then I see. Oh, it's an ethereum event. Can go into an Ethereum event. I test these parameters and stuff. So you can start to explore the code through that feature. Then the next command is kind of VR and build. So I want to see if we can actually build this subgraph now here locally before we try to deploy.
00:10:38.170 - 00:11:21.120, Speaker A: Okay, that works. And yeah, and then we can actually just go to Luxubgraph Studio. Connect a wallet, ethereum Mainnet connect. You can also log in with Phenosis Multisig. So you have a little bit more control, maybe of your team if you have bigger subgraphs. That's what we do with those subgraphs that we currently migrate for a lot of projects. This week we had Gelato, for example, migrated to decentralized network.
00:11:21.120 - 00:11:41.000, Speaker A: And yeah, kind of this is really going on. Like the Ethereum Mainnet subgraphs from the hosted service. They are now slowly but surely coming over to a decentralized network. Yeah, sometimes you need to do refreshes because we are still early.
00:11:41.150 - 00:11:42.344, Speaker B: Yes. Here it is.
00:11:42.382 - 00:11:43.370, Speaker A: Sign message.
00:11:45.340 - 00:11:45.896, Speaker B: Cool.
00:11:45.998 - 00:11:53.150, Speaker A: So you see, I already did a lot of those test stuff. I hope I don't have any hash mask yet.
00:11:54.400 - 00:12:02.624, Speaker B: Let me check what I named it here. Hashmask. Okay. All right.
00:12:02.662 - 00:12:32.050, Speaker A: This exists. You click of create a new subgraph. You say you index ethereum mainnet. Only mainnet ethereum Mainnet is supported at the moment on the subgraph studio. All right, then you take the name here. This one, the slug. It's important that this correspondence here in this, it's kind of the slug that you need to combine.
00:12:32.050 - 00:13:08.830, Speaker A: Then you need to authenticate. So you run this graph auth command. And then you can do yarn deploy. I forgot to save. Then you will be asked for version. Yeah, whatever makes sense in your project. Kind of keeps the version name and then yeah, it's deployed.
00:13:08.830 - 00:13:25.010, Speaker A: Sometimes this fails, but we are lucky today. And then if it fails, just retry. I mean, like, it's the same with the browser force refresh, retry. Eventually it will work. Yeah. So we have it now deployed. So we see it already here.
00:13:25.010 - 00:13:49.770, Speaker A: It starts syncing. This is just in the subgraph studio. So it's still on a centralized server. If you really want to publish it to the decentralized network, then you click on this one. You say Ethereum Mainnet can also be the first one to signal on it. Although I don't have any GRTS on that account. But this is actually how it would work if you redeploy to decentralized network.
00:13:49.770 - 00:14:08.430, Speaker A: Yeah, but we have it already here. So you have a temporary query URL that you can use for your development. And you can go into playground. You can, for example, say like, yeah, let's see what we have. We should see already some transfers.
00:14:12.950 - 00:14:13.700, Speaker B: Yeah.
00:14:16.500 - 00:14:36.164, Speaker A: Yes. See. All right, so we see. We see already the transfer. So it so it happened. So, I mean, like, it took me ten minutes to kind of bootstrap this subgraph from the contract that is already there. But since I just now just continue working on that subgraph until they throw us out.
00:14:36.164 - 00:15:18.110, Speaker A: So the next step would be we say like, okay, I mean this is nice, but we'd meet down with just the events index. It's a good start already. I mean, it helps you have GraphQL for your event, but it's not really cool. So what I said before is what I'm actually interested in is just a transfer. So we can go here and just start to clean up the thing. So we can just remove all that stuff. Also the entities, the schema, where is it? And mappings.
00:15:18.110 - 00:16:41.154, Speaker A: Then I can do yarn code gen. And the other cool thing about this is that it will now tell me like, hey, you're trying to import stuff that doesn't exist because I regenerated the code. So the editor now helps me. I can just be like late night coding unprepared at the hackathon and the editor helps me to do everything and I can do again yarn build, which then kind of confirms to me that the subgraph like, it's everything, it's correct when it looks not bad. Now the next step would be, I mean, you can follow that GitHub repo here to actually make a little bit more sense out of it. So we can say, okay, we can for example, introduce this pattern with the Immutable events so we can say like, okay, and we can store the block number, the timestamp so it makes a little bit more sense and we see like from who to who that the subgraph goes. So if we first update the schema, so now we have from token ID timestamp, block number that makes a bit more sense and then also to we also need to a little bit extend the mappings actually.
00:16:41.154 - 00:17:27.342, Speaker A: But I mean, it's not that crazy difference between before we just get out a little bit more data out of this transfer event and see, now it says me, oh, I don't have the entity, the block number on the entity. And the reason behind is that I changed the schema, but I didn't run yarn, code gen. So the editor doesn't know about my new intention. And as soon as I do this magically after some while, this disappears. Yeah, here it is again. Okay, now we have it extended, we don't need to deploy. Now, the next step is actually we are not just interested in transfers, we are actually interested in tokens and owners and the contract.
00:17:27.342 - 00:17:56.906, Speaker A: And we even maybe want to have kind of some aggregations on those tokens and also some aggregations on the owner. So we want to know which owner does own how many tokens. So the first step to actually go in this direction is to write the schema. This schema is more or less clear. I would say it's similar. What we now have is this derived from field. So you see that transfers are linked to these transfers and it goes through this token field that we have here.
00:17:56.906 - 00:18:27.240, Speaker A: So we can have this reverse lookup through the tables. But you can also read that in the docs or come to our discord and ask me and I will happy to explain it a little bit more verbose. So this makes a little bit more sense. So this kind of actually starts to really give us insights into what's going on. Nice. I didn't write the actual mappings code.
00:18:27.850 - 00:18:29.240, Speaker B: I think it's here.
00:18:32.600 - 00:18:57.060, Speaker A: Yes. So let's take this whole function and discuss it in Vs code. We see a lot of interesting patterns here. All right, again. Oh, maybe I need to import everything. This is copy paste error.
00:18:58.440 - 00:18:59.590, Speaker B: Let me check.
00:19:02.920 - 00:19:22.030, Speaker A: All right, this is I can go to this. The editor also helps with this autocomplete stuff.
00:19:25.120 - 00:19:26.030, Speaker B: All right.
00:19:26.480 - 00:19:34.844, Speaker A: So I can say like, okay, where do you find the contract? And then it says it's in this generated schema. Then I can say it wants to.
00:19:34.882 - 00:19:35.470, Speaker B: Have.
00:19:37.600 - 00:19:40.060, Speaker A: The event address to Hex string.
00:19:41.520 - 00:19:42.092, Speaker B: All right.
00:19:42.146 - 00:19:49.860, Speaker A: The token, it's probably also in the scheme. Or I can load it. Big int will be in graph TS.
00:19:51.080 - 00:20:10.120, Speaker B: And here we have the tool hex string. Quickly fix this token number. Didn't we have a token number ID? Just skip it.
00:20:13.450 - 00:20:16.118, Speaker A: Right? The hash mask. They don't have a token URISA.
00:20:16.134 - 00:21:13.990, Speaker B: We need to skip that. Possibly this will work. The address it it over to x three. All right.
00:21:17.810 - 00:21:30.826, Speaker A: This looks already good. Not sure what is this?
00:21:31.008 - 00:21:34.110, Speaker B: Possibly not from the balance.
00:21:45.840 - 00:22:07.984, Speaker A: Let's skip that for now. Okay, so what we do here now we make it a little bit more complex. So we have a transfer event. Again, this is similar. We store some stuff, then we store a token ID. We have this helper function get or create owner which tries to load the owner from the database. And if it doesn't exist, it will just create it and save it and then return it.
00:22:07.984 - 00:22:34.756, Speaker A: So that's quite handy. That's a good pattern. Like for this kind of returning, you don't know if the object already exists. Then here we load the contract from the database as a kind of a singleton where we store these aggregations on top. But also here with bind. We bind now to the contract instance so we can do Eve calls on the instance. So like the name and the symbol.
00:22:34.756 - 00:23:08.628, Speaker A: These are Eve calls that go back. Be careful with ease calls in general because they take a lot of time. They are usually the main reason that the subgraph doesn't index fast. That's why I only do it like kind of once I try to say, okay, if we don't see the contract initially, then we didn't save it. Then I go through and initialize it and then I do the if calls. But then in the next transfer we have the contract already in the database and then I don't need to do these if calls again. And so we kind of hear this kind of this initialized thing.
00:23:08.628 - 00:23:39.120, Speaker A: Then the same with the token. Like the first time we see a transfer, we see a token. Then we can take with other contracts that get the token Uri. But unfortunately Hashmask doesn't adhere to this metadata pattern. So I have to comment this out. Yeah. And then I say, okay, I go just up with as soon as I see a new token, then I know can increase the total supply of the contract.
00:23:39.120 - 00:24:16.910, Speaker A: And then also I assign an owner to the token, I do add more to the transfer and then I save everything and that's it. Now let's see if I can build this. It might run into weird problems because I kind of just comment the code out and the schema expects some values, but let's just deploy again. Now we increase the version so it doesn't collide.
00:24:36.960 - 00:24:37.516, Speaker B: It.
00:24:37.618 - 00:25:09.300, Speaker A: Yeah. In the meantime, I know it was a little bit quick and a little bit fast. Usually I have an hour for these workshops and my laptop doesn't have any problems. But yeah, we tried our best. But if you still have any questions, like we have a graph booth, I try to be there as much as possible. So if you have any ideas what you want to do with the graph, if you want to build a subgraph or you want to query an existing subgraph, so on and so forth, feel free to come by. There should be always kind of good people around to give you a nice answer.
00:25:09.300 - 00:25:45.600, Speaker A: Feel also free to follow me on Twitter and write me DMs. I try to answer to them, although, I mean, like the hackathon is a bit hectic, but maybe you can try and I try my best to answer all those. And if that doesn't work, you can also still go into the Graph Discord. We have dedicated support, tech support people that are around here for the weekend, especially for your questions. So go to the graph discord or also to the Eve Global discord. Both should have kind of some coverage, so you should really be able to find someone who helps. Yeah.
00:25:45.600 - 00:26:18.670, Speaker A: And last but not least, in beginning of June, there is the Graph Day in San Francisco. So for those who are in the US or like to travel to the US, feel free to come by. There are also scholarships for hackers if you want to. Yes. So let's go quickly back and see our results. It should yeah, it had deployed, but it might result in an indexing error. Not bad.
00:26:18.670 - 00:26:39.590, Speaker A: All right, now we can start to query. And now it's quite more interesting because we can actually see the tokens. Right. So we see tokens owners, we see some transfers on the tokens. Yeah. So we have much better, actually, data now that makes much more sense.
00:26:40.360 - 00:26:41.988, Speaker B: Contracts. Let's check this.
00:26:42.074 - 00:27:09.128, Speaker A: We can also see like how many tokens we already seen. Maybe it's a bug. I never checked. One last thing. If you do this and you go into this query URL yeah, feel free on directly kind of open this into your browser. Then here you have kind of this very neat GraphQL interface. It's better than the playground here.
00:27:09.128 - 00:28:00.948, Speaker A: So you can go here in the Explorer and start to explore the subgraph. Actually, the same applies to every subgraph that is on the decentralized network. So when you, for example, go to what's a cool subgraph ENS so you can do the same, although it's not linked. So this is kind of a trick that I show you. So you can click right click Open Address in a new tab you have this very neat graphic URL interface and you can start to explore. This one is a bit bigger than the one before, but I mean, like UI, you can go there and see like accounts first ten, the ID one with domains, the name, whatever sent the query. And then yeah, you see, these are the burned ENS addresses.
00:28:01.044 - 00:28:01.690, Speaker B: Interesting.
00:28:02.140 - 00:28:08.980, Speaker A: Yeah, I learned something. I think that's it. Thank you so much for your attention. Sorry for the stress and yeah, fun hacking.
