00:00:00.570 - 00:01:10.434, Speaker A: Program we have, we have two Bonnie programs. The first is called the Safety program. That is to build any kind of a gaming application utilizing some very simple application interfaces of our SDK, you got a chance to win $1,500. And we also have a C builder program which is like incredibly popular from our last experience because for that, you can just use any setter SDK functionality, build any kind of application, and the first two people registered with us will be able to split the $1,000 award in total. So we found out that's a really incredible program and if you just want to spend like two or 3 hours, try it out, you can. So just before we formally start, I just want to say that this is going to be probably one of the last times where we kind of talk through the raw level of API of setter. In the future, we're not only going to talk about the raw level of API, but also going to start to talk more about the application facing stuff.
00:01:10.434 - 00:01:45.758, Speaker A: That is if you're just, for example, building a game that is focusing only on this kind of HTML Five game, we will have some very simple wrapping API around that. But that part is still being cooked right now. And we are going to have our main net launch next month. And in fact, we just had our private main net launch at our booth. So whatever the software you downloaded at our booth is actually running on main net today. It's just like nobody knows about that yet. So you guys kind of get the exclusive access, early access to this.
00:01:45.758 - 00:02:14.840, Speaker A: So without further ado, I will pass the mic to Michael and we'll just talk about the current SDK stack we have. We currently have like three kinds of SDK, but they all share resonate similar kind of interfaces. One is VAM SDK, the other is two system like native mobile SDK of Android iOS. So this is like a very intimate environment. So feel free to stop us at any moment and ask any questions.
00:02:15.930 - 00:03:11.786, Speaker B: All right. Hey everyone. I'm Michael from Saturn Network and today I'm going to just briefly go through our current setup of our SDKs. So just a brief introduction of Satter is like we're this generalized state channel network that supports both payments and generalized DApps, which could be highly interactive and scalable. And some examples of the past projects we've seen at other hackathons are for example, this is a prediction market. So basically we use chainlink as an onchain Oracle and then clients will send conditional payment based on the Oracle results from on chain. So if some conditions is met, Alice is going to send a payment to Bob in that.
00:03:11.888 - 00:03:56.818, Speaker A: So this is the part that is a little bit different from, let's say, Lightning Network or any other just simple off chain payment design that you have the native capability to send a payment off chain, but that is conditionally depending on some other conditions. And that condition can be an onchain contract and also can be an off chain state channel contract that is finally resolved on chain. So that's kind of like the construct. You send out a conditional payment, you can think that that conditional payment is wrapped with a contract address and that contract address has some function pointer towards that contract. A certain function. We have kind of an expected interface towards the dependency contract. So that's kind of like roughly how it works under the hood.
00:03:56.818 - 00:04:02.460, Speaker A: But in terms of the API talk, you can look at the doc and we can definitely help you walk through that.
00:04:03.790 - 00:04:49.590, Speaker B: Right? And this is another example where I think it's a very good use case of micro payments. So you have a cloud provider that provides some kind of SLA guarantee for service. And if say, the provider violates the SLA terms and the service is down, then you notice that and the provider is going to send you a micro payment as a compensation. So this is another use case of how powerful the Setter's conditional payment framework is. And I think this code is on GitHub and you can check it out and see how it calls the Setter APIs. How many of you are like web developers or any mobile developer?
00:04:50.090 - 00:04:50.742, Speaker A: Okay, cool.
00:04:50.796 - 00:05:54.650, Speaker B: So we actually have SDKs for Web Android OS, and I'm going to just go through the APIs of the Web SDK because that's probably the easiest one to demo. Let's see here we have sorry. Okay, so if you go to Setter Network, GitHub IO, and that's where all our documents are. Just go through a simple demo here. Sorry. And if you go to GitHub.com Setter network and search for the Setter web SDK and under demo, there is a very basic demo of how you set up a setup client and open a state channel and send payment of one way to the counterparty.
00:05:54.650 - 00:06:38.540, Speaker B: So it's a micro payment, right? So if you were to send this on chain, you're going to cost more gas than the actual payment, but in this case you can send one way free and instantly. And to run this, we provide a pre built satellite client binaries for both Mac and Linux. And you just go to GitHub.com Setter Network, Setter client and you check out the repo and you follow the README. So this is going to start a local Setter node. So it's going to connect to the Setter network service providers and basically it routes the payments for you.
00:06:38.910 - 00:06:40.842, Speaker A: But if you're using mobile, this step.
00:06:40.896 - 00:07:53.982, Speaker B: Is definitely not needed, right? If you're using mobile, it's not needed. So the mobile SDK has the settler client embedded and you don't need to. So this is for web and desktop. And let's see, can you use Raw? So this is on NPM and you can NPM install this package setter web SDK So basically you do like a new setter clients and this is the endpoint to your local Setter node and you do like client open channel and it's a promise. And once it resolves, it gives you a channel ID, which isn't quite useful in this case, but you can verify it on chain, and then you can get the balance of the Kind and it will print the balance in the console. And you do like Send East, which sends an unconditional payment of one way to the destination. And you wait a second, and then you check the balance.
00:07:53.982 - 00:08:38.374, Speaker B: And the balance should be updated. So I tried to run this before, but it seems like I got some error which I'll figure out very soon guarantee that's a very simple basic payments. And for more complicated stuff where if you want to build something like the Gomoku game we have you're going to look at more APIs. So basically you can create an app session that has the virtual contract sorry, the information of the virtual Gomoku contract and then you can send a payment based on the condition of the Gomoku contract.
00:08:38.522 - 00:09:50.070, Speaker A: Maybe at this point. Let me just inject here and talk about the concept of virtual contract or like state channel contract. So how many of you actually heard about generalized H channel, the general contract? Okay, all right, so the concept of generalized H channel exists is basically you have some programs and that involves certain defined parties. Let's say there are like three defined party involved in a game, 4610, but it's limited number, so it's not infinite number. Now the concept of state channel is so that basically for each state transition of this application, we don't actually need to broadcast a blockchain transaction to the entire network. We only need to reach consensus among these ten people as long as we get all the signatures from all the ten people on a serialized state of this application. Basically, let's say the application has some internal parameters, internal data structures and all that stuff, but all that stuff can be serialized into some data structure.
00:09:50.070 - 00:11:35.718, Speaker A: So let's say in the very concrete case of phone call, you can serialize that entire data structure into a byte array or some like a protobile format. We actually recommend protobot here to do this kind of data structure serialization, as we do have this kind of in call, robot parts are built and that is also open source available on Solidity. So you get this newest app state, and the idea is that you basically add your signature on it and you send to your counterparty and your counterparty will receive the state update, look at state update and figure out whether this state update you're proposing is actually valid state update. If this is actually valid state update, the counterparty sends back that state update basically. Now this entire process is kind of the state progression of a state channel application. So you basically kind of do this kind of entire state progression little by little. And the interesting part here is that now where does that actual game or chessboard game or gongo game actually live? Well, in the cooperative case you don't actually need to instantiate any smart contract on the blockchain because you only need to kind of agree on, okay, this is a code that we are going to run if we deploy the stuff on the blockchain, right? So basically let's say we agree on the bytecode of the program, we agree on the parameter of the bytecode, we agree on the input or a random noun that is kind of marking, deduplicating any kind of ambiguity of our agreements because we may want to play multifaction of the game.
00:11:35.718 - 00:12:12.838, Speaker A: So we agree on these things and we cache all the stuff together and generate something called the virtual address. So Ethereum recently introduced something called the creator tool that kind of let us escape that process that is available in our next version of your leaf. But not right now. Right now we still use the concept of this virtual address. Now you have this virtual address. What it means is that once you actually want to do some resolution, let's say one of your party dropped offline in the process of playing the game with you. Now you got into a situation where you are halfway through the game.
00:12:12.838 - 00:13:18.170, Speaker A: You have some conditional off chain payment that is depending on the game result. So the dependency though is established through the conditional payment, like send conditional payment cost. And now what you want to do is you actually need to actually deploy the contract on the blockchain and then revert the process like doing the onchain transaction and stuff like that. But most of them for the short time of the hackstone we probably don't like. You guys probably may not have the time to do this kind of entire flow kind of transition. But I just want to talk about this process so I can share that how generally a state channel is progressing the internal state and also in terms how the state is actually working. Right now the app or the virtual address that I talked about is generated through the call of create app section.
00:13:18.170 - 00:14:30.258, Speaker A: Yeah, create app section and there are some app info in it and that is kind of where we stuff all the garbage of the contract code and all that stuff into that and you stop the API, you stop the binary, you stuff the constructor parameter, you stop the not that's kind of the app input. And once you have that app session created, now what you can do is you can kind of send a conditional payment, send ease or send like your 20 width condition on it. There is a specified destination, specific string and specific condition. And if you click into that condition, what condition really is is talking about like effectively the first thing is what is the dependency? So the address is basically marked Identifier of the dependency. So you basically pass that part in. And there are also some other things that is needed for this particular case of conditional payment. That is you want to track whether the off chain process is actually finalized or not.
00:14:30.258 - 00:14:54.470, Speaker A: And in most of the cases it will actually be finalized and in normal cases it will be totally finalized and the per result will get you what is the result of the game. And in the case of a simple boolean condition, the per result is basically just going to return boolean basically pay off money and if you win the chat, the money you conditional pay off gets resolved.
00:14:54.550 - 00:14:54.982, Speaker B: False.
00:14:55.046 - 00:15:30.240, Speaker A: But the other way gets resolved. Is it just a callback or do we have that question? So this stuff is the parameters that is passed into the SDK, but I think it handles that for you. So when the progression of the state finally resolves, you just call result condition group and all this stuff will automatically get results for you. No worries. We will go through these APIs, just come to our developer, ask questions. In this port we'll copy.
00:15:32.200 - 00:16:05.470, Speaker B: So in the case of deploy, basically if Alice and Bob goes into dispute right, and say the Gomoku contract is actually deployed on chain, in that case we require that the contract implements two methods, is finalized in query results. In that case the SDK handles how basically queries on chain to see if the condition is finalized. So basically it transitions from a virtual contract to an actual deployed contract and the interfaces still remain the same.
00:16:06.160 - 00:16:22.150, Speaker A: But in most cases this thing won't trigger. And probably in the development process of this hack zone, we probably don't need to go into that like the condition part yet. Just want to get a general understanding of that. Even for single payments it's also a little bit.
00:16:26.680 - 00:17:13.460, Speaker B: So yeah, and we also provide if you want to do interactive games like last time someone did like let me show just go back to the page last time at East Denver, right, someone did say for example, this one, it's a rock paper, scissor kind of game. So it's called Bulls, Bears and Buffet. Corns.
00:17:28.200 - 00:17:55.480, Speaker A: And the balance. Oh, just like don't either. Cool. That's my wife, unfortunately. And also like you know, on the mobile you lose some money. Yeah, it can be a chore. Great, excellent.
00:17:55.480 - 00:18:09.630, Speaker A: Thanks a lot. Also on the mobile stack, we also have my example, you can refer to the east numbers. They probably all have that there.
00:18:11.760 - 00:18:17.090, Speaker B: Yeah, there's a battle bumper. Yeah, this one.
00:18:17.540 - 00:18:25.250, Speaker C: All right, cool. So what I'm going to do is I have my wallet as an app and I want to create a game.
00:18:25.620 - 00:18:27.364, Speaker A: Against one of my friends.
00:18:27.482 - 00:19:03.470, Speaker C: So in Imessage we have an extension where I can instantiate a new game. What this is going to do is it's going to create a new seller client and also create a game and send an invite. So the game concept is I need to place four bombs. Now this is all packaged up. So in that package it's also the Southern Game ID and my current game State. So when I send that to one of my friends, he's going to receive a message on his side. Sorry.
00:19:03.470 - 00:19:22.884, Speaker C: Now he gets three tries to try not to blow up. He blows up, he loses one, two. So now the game is complete. The stake between the two wallets can.
00:19:22.922 - 00:19:25.910, Speaker A: Now transact and everybody gets paid ahead.
00:19:27.640 - 00:20:03.090, Speaker B: So that's pretty much it. Basically, I think they use this. Let me show you this. Send State API, which we have the current version of this SDK. But in the future we're going to decouple this from the SDK. So you can send States via any other form you can upload to IPFS and then the counterparty can download it, but the state machine can still progress. Basically, we provide this framework to handle the State progression for you and more on that later.
00:20:03.090 - 00:20:54.464, Speaker B: Feel free to catch me at question. Yeah, that's a good question because we are like well, I think the prerequisite is for us to say, deploy the State channel contract on standard core. So that's like a prerequisite. But since they're EVM compatible, I think that should be pretty easy task. And if I have some time I can look into that and see how easy it is. What's that? Yeah, definitely just try to run the demo. It won't work for now.
00:20:54.464 - 00:21:27.690, Speaker B: I'm just going to fix the server side. For some reason it was getting me contact stat unexpected, but I'll fix that and then you can try to run the demo. And there is another, there is a slightly more complicated demo with Send and Receive. So in this one you can basically client one sends to client two, and I believe client two also sends back to client one. So you have like two people send to each other.
00:21:31.900 - 00:21:36.200, Speaker A: On any other blockchain as long as EVM compatible can support their construct.
00:21:39.040 - 00:21:50.610, Speaker B: Technically, as long as the blockchain supports some kind of tuning, complete smart contract logic, we can implement a seller contract. And then we're doing that for some other blockchains as well.
00:21:51.620 - 00:22:00.348, Speaker A: Yeah, sure. All right, any questions? We're going to be right there.
00:22:00.534 - 00:22:01.750, Speaker B: Yeah, we're right there.
00:22:03.640 - 00:22:41.730, Speaker A: All of you guys are very welcome to After Talk at one of these newcomer T shirts and some of the cool speakers we have. And we have a lot of amazing prints or both dumpar. Yeah, so we have that the comical game. We have something called so if you're tired of coding or anything, just like play some game and maybe you got off on the leaderboard and switch back, it all right. Thanks a lot.
