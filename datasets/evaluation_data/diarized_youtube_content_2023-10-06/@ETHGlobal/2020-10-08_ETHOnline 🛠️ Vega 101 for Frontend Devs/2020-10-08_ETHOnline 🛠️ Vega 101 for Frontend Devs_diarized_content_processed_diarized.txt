00:00:00.250 - 00:00:22.560, Speaker A: Vega 101 for front end GABS. Today we have Barney joining us who will be taking us through the session. One quick reminder to everyone, any issues, please do not hesitate to reach out to myself or anyone else on the East Global team. And with that, I'll pass it over to Barney to introduce himself and get the session started.
00:00:28.530 - 00:00:28.918, Speaker B: Thank.
00:00:28.964 - 00:01:21.282, Speaker C: Hi there everyone. My name is Barney. I'm one of the co founders of Vega and I'm going to walk you through the Vega Protocol today, give you a little bit of background information and then also kind of introduce you to some of the features of the Vega APIs and the features of Vega for front end development and building visualizations. I'll also tell you a little bit about some of the bounties that we've got up during ETH online and some of the ways you can participate there. And at the end I'll be happy to take any questions that you might have. So just to sort of set the agenda there briefly to talk about what we're going to cover today, what is Vega Protocol? I'll give you a bit of a whirlwind tour of some of the things that Vega can do and just give you an explanation of that. I'll talk through the hackathon bounties and what it is we're looking for and then I'll show you some of the developer resources that we have at Vega that you can use.
00:01:21.282 - 00:02:11.090, Speaker C: And then finally, for the bulk of the session, I'll actually walk you through some live coding and we'll build a very simple kind of web app that connects to Vega streaming APIs and takes a look at some of the data that Vega exposes. So let's get started and talk first about a bit about what is Vega Protocol. So Vega Protocol is what I call like a next generation sort of cross chain derivatives decentralized exchange. Protocol is designed to allow capital efficient derivatives trading. It's also designed to allow cross chain settlement. So in order to do sort of risk management and the performance that we wanted to kind of compete with centralized exchanges, vega is designed as its own kind of blockchain, its own sort of layer, one that's kind of vertically integrated. It's optimized for trading from the consensus layer all the way up to the kind of APIs and databases and stores that exist on the nodes.
00:02:11.090 - 00:02:53.294, Speaker C: That gives us fast decentralized order books. It also gives us the ability to do things like prevent front running. And there's some great research on our website if you want to take a look after this, which has some papers and stuff around front running, around liquidity and other things. It also means we can offer really high leverage and really high capital efficiency compared to other on chain exchanges. That's because we don't need to use things like liquidation auctions and we can actually do atomic margining and liquidation. So Baker gives us sort of vastly improved experience over purely Ethereum only sort of derivatives protocols. And it allows us to create a kind of really exciting set of products, but it integrates with Ethereum and in future other blockchains, but the first integrations with Ethereum.
00:02:53.294 - 00:03:25.290, Speaker C: So to begin with, every asset that you trade on Vega will be like an Ether or an ERC 20. And that's kind of where the assets come from and how the settlement works. And we have a bridge between the two blockchains that works to do that. So that's a very high level on Vega and you'll see some more as we go through of some of the things that Vega can do. So let's talk a little bit about what we're doing in terms of bounties. So in terms of bounties, we're offering $5,000 worth of bounties. I think it's played in dai.
00:03:25.290 - 00:04:15.226, Speaker C: There's $3,000 grand prize for the winner of the overall competition and then $1,500 and $500 each for the runners up in third place. So what we're looking to do is we have this huge trove of data that comes out of Vega. It's a completely transparent blockchain, which means you can find out way more information about what's going on from a trading perspective than you would ever be able to see on a centralized exchange. You can find out when people get closed out or wrecked, you can find out what the prices are, you can find out the risk management that's going on, see everything happening and you can connect to the streaming APIs. And so something we're really interested in doing is understanding how we can visualize that data, how we can look at it and how we can show what goes on Vega. To give you a demonstration of what Vega actually looks like right now, this is our testnet. So here you can see the Vega testnet running and you can see it looks a lot like a normal trading interface.
00:04:15.226 - 00:04:57.340, Speaker C: Everything happening here is happening on chain. So this is all stuff that's going on, chain, environment, everything is decentralized. And you can see it looks very sort of normal and boring in a way. Like it's a functional front end, it's a functional exchange, but it doesn't really highlight any of the exciting things about Vega, like the ability to see what's going on with other people's positions, to see the money and the movement of collateral between people's wallets and things like that. So we're really interested in seeing the different ways we can pull that information together and visualize that information. So that's really what we're looking for in these bounties and something that we want to see. And so that's really going to be the focus of what we're doing here.
00:04:57.340 - 00:05:02.086, Speaker C: So to talk a little bit about the architecture of Vega and how Vega.
00:05:02.118 - 00:05:02.700, Speaker B: Works.
00:05:09.470 - 00:05:48.074, Speaker C: Apologies, my slideshow is not behaving talk a bit about the architecture and how Vega works. Vega's a blockchain. As I mentioned, it runs on tendermint as a consensus layer, which means it uses the same underlying software libraries that things like the Cosmos network. But as I mentioned, the blockchain is customized for trading. So the entire core of Vega is custom built to process the Vega protocol, to do risk management, margin calculations and to manage positions and to keep the network safe. There's lots more information on the web at Vega XYZ as well. So there's a few developer resources that will help you get on the way.
00:05:48.074 - 00:06:38.726, Speaker C: So Docs Ethonline, Vega XYZ is a public doc site which shows some of our API docs. There's actually another testnet doc site which when you get onboarded to the testnet gives you a lot more information and I'll show you some of that in a minute, but we can go through some of that and you'll be able to see it. Gives you a lot of examples of how to use Vega. We also have the community forums at Community Vega XYZ and the Discord, where me and a lot of the technical team hang out and are happy to answer questions at Vega XYZ slash Discord. So what I wanted to do now, and for the bulk of this session, is actually to give you some sort of hands on stuff and some hands on demonstrations of some of the things that are going on. So the first thing we're going to do is quickly just take a look at the Vega Block Explorer to kind of orientate ourselves with the network. So here you can see the Block Explorer hopefully, which is our current network.
00:06:38.726 - 00:07:30.346, Speaker C: So our testnet is currently running seven validator nodes and you can see some information about the recent blocks. And if I click through there, this is a very early Block Explorer, but it's something that you'll be linked to in the testnet onboarding and you can use to see some of the content of the blocks. Let's take a look in trading. All right, call that a curse of the demo and we'll move on from the Block Explorer. But let's look at the actual documentation because that's so taking a look at the documentation here, this is the Vegas Testnet Doc site with a number of different bits of docs. So first thing you'll find here is lots of information about Vega markets and how to trade on them. You can see we've got a lot of information about what's currently there on the network and some of the information about how things work.
00:07:30.346 - 00:08:00.670, Speaker C: Really suggest you browse this wallets and signing again. If you want to make transactions on the network, then you're going to need to use the wallets. We have a command line application for Wallets which allows you to create your own on your machine. At the moment we're also running that as a server sort of centrally to enable us to quickly create testnet accounts when we recreate the testnet and to quickly get people up to speed. But eventually you'll be able to download that it'll be completely open source. And there'll also be Web Wallets as well. So in future there'll be the ability to use Vegas to trade entirely from within a Web Wallet.
00:08:00.670 - 00:08:34.170, Speaker C: So that's another way you can do that. Looking at the API section, we've got some pretty good documentation for the three types of APIs that we offer. These APIs are all exposed by the node, so there's nothing centralized here. It's each node runs a server. We have gRPC, so that's the kind of protocol buffers RPC. We have very sort of comprehensive docs of that which are generated from the underlying protocol. You can see all of the things that can be done there, including making trades, withdrawing collateral, depositing collateral, getting margin information, et cetera.
00:08:34.170 - 00:09:18.080, Speaker C: We also have rest APIs. The Rest APIs are effectively based on the gRPC APIs as well. So they use the same underlying APIs, but they just allow you to do things in a much simpler way, using kind of curl or using your favorite sort of web client. And then the final type and the type that we're going to look at today in most of this session is the GraphQL documentation. The GraphQL APIs GraphQL is really ideal for building front ends and streaming data visualizations because it allows you to quickly get streaming data to customize queries and to join across data types. Again, we have reference dots there, but we also have the GraphQL Playground which allows you to test out queries. So for example, here I could take a look.
00:09:18.080 - 00:09:56.586, Speaker C: Subscription trades. Let's get a size and let's get a price. And if I do that, you'll see that every trade that's happening on our testnet is streaming through into the GraphQL Playground. So it's really easy to sort of test out your queries and test out the APIs using that playground. Again, a very useful tool. There's a section of how to guides as well, so if you want to sort of get started with a few different things, there are some guides which kind of walk you through stuff as well. If you find something wrong on Testnet or on the documentation or something is missing, please feel free to report an issue that will take you through to our NLT page and the Nults page can be used to share your feedback with us.
00:09:56.586 - 00:10:17.626, Speaker C: And to get started. You can also report feedback in Discord or use the forums as well. Very happy to take that in any of those channels. Don't forget to join the Discord. It's really where the technical team hang out and where I hang out, where it's easy for us to answer some questions. There's a few bits of examples and again, these things will be shared with you as well. There's a few bits of examples.
00:10:17.626 - 00:11:18.194, Speaker C: So for instance, we have some Samplace API scripts on GitHub which give you again some code which you can get started with, which help you kind of use some of the APIs via Rest or gRPC. We also have a Python client for the gRPC. So if you're actually a fan of Python or you want to do some data processing before the data gets to your front end, you can actually use the Python Library that's published to the Python Package Index and you can access Vega that way as well. So that being said, let's start our little project and let's see what we can create using Vega in a short amount of time. So let me start from the beginning, go outside my finished version and let's recreate this in a live coding sort of setting. So first thing I'm going to do is I'm going to be using the Svelte front end framework for this because it's very simple, very easy to get started and build something. But everything you see here will be very easy to translate, to react, or your own favorite front end.
00:11:18.194 - 00:11:39.434, Speaker C: So I'm going to create a new project here by doing Mpxd Git to download the Svelte template from GitHub. And then I'm going to install the libraries that I need to access GraphQL and subscriptions from my application. So again, just quickly do that. I've actually done that in the wrong place.
00:11:39.632 - 00:11:42.140, Speaker B: It's not going to work. Go into here.
00:11:46.210 - 00:12:19.814, Speaker C: I can install those things and it should work just fine. There we go. And I'm also going to copy the file which I've got, which contains my testnet information into the source folder of this, just so that I've got that testnet logon information available to me. So now what I should find is that if I create another terminal here, do an MPM run dev should find.
00:12:19.852 - 00:12:20.440, Speaker B: That.
00:12:23.850 - 00:12:25.782, Speaker C: Do an NPM install for the template.
00:12:25.846 - 00:12:26.522, Speaker B: Let's do that.
00:12:26.576 - 00:12:55.138, Speaker C: So we'll do an NPM install to install the Svelte framework. The dependencies were downloaded, but that didn't actually install the framework itself. So now when I do a run dev, we should find that we get there we go, we've got the dev server running. So if I switch to my browser, we can see that I've got the spelt. Hello world. We've got a basic application up and running, nice and easy. So let's go back to Vs code and then let's get creating something.
00:12:55.138 - 00:13:01.480, Speaker C: So firstly, let's just go to index. Let's give the wrong one.
00:13:04.330 - 00:13:04.946, Speaker B: And let's.
00:13:04.978 - 00:13:19.638, Speaker C: Give this a call title. So let's give that a title, save that and we'll see. As soon as we switch back to there, you can see that everything has updated.
00:13:19.814 - 00:13:23.354, Speaker B: So let's take a look into my.
00:13:23.392 - 00:14:00.070, Speaker C: Live documentation, my source application here. And again, let's change this heading to the online trade streamer. Just that everything is all hooked up. Okay, there we go, that's all working. So now we can start actually writing some code that's going to use Vega. So we're going to get rid of this name from the script, which means that I'm going to just open name JS and we're going to remove the name from the properties as well. We don't need any of these properties in here and we can go back to the application.
00:14:00.070 - 00:14:39.958, Speaker C: And now let's actually create a new file to download some trade data from Vegas. Let's use the Svelte store framework. It's very simple to use and that allows us to sort of quickly do this. So firstly I'm going to import the Readable Store definition from Svelte framework. If you're using a different framework, this will be different. And then I'm going to get the subscription client for GraphQL. So to be able to subscribe to a GraphQL subscription, there's the import there and I'm going to import the endpoint that I'm using for testnet from the secrets file that I just copied in.
00:14:39.958 - 00:14:44.594, Speaker C: So now let's just create ourselves a function in order to stream some trades.
00:14:44.642 - 00:14:54.554, Speaker B: So export stream, this will be our.
00:14:54.592 - 00:15:37.874, Speaker C: Trade streamer and this is how Svelte works. When you export a function like this to create a trade stream, then you basically create a stream or a store. It's a readable store. It starts off empty. So we just create it initializing with an empty array and we provide a function which should be called when the store is started and it provides a set method which gets passed in that allows us to set the data. So let's create an empty array for our trades and then let's create a client to the GraphQL endpoint for our subscription. So we've now got a subscription client that lets us run any query the same as in the GraphQL playground.
00:15:37.874 - 00:15:49.800, Speaker C: So the same as this playground here. We could run this query and we'd get things out of there. So let's actually copy that query. That's going to be useful to us perhaps. And let's put that query into our code.
00:15:51.050 - 00:15:55.790, Speaker B: So Trades query.
00:15:58.050 - 00:15:59.310, Speaker C: Trades Query.
00:16:04.210 - 00:16:09.946, Speaker B: And some reason my copy did not work because I'm going to copy from my other file.
00:16:09.978 - 00:16:36.762, Speaker C: So let's take the trades, let's get the price, the size, but let's also get the ID of the buyer and the seller and the ID of the trade. So we've got all that information available to us in the response. And let's also set ourselves a max number of trades that we want to store in the client, something like 256, so that we don't end up filling up all our memory if we leave it open for a long time. And that's basically ready to create a subscription now.
00:16:36.816 - 00:16:40.650, Speaker B: So let's do this const request.
00:16:44.610 - 00:16:51.826, Speaker C: Equals client request. Then we send the query to the.
00:16:51.848 - 00:16:57.214, Speaker B: Request query is traits query and let's.
00:16:57.262 - 00:16:59.334, Speaker C: Also just tell this that we would.
00:16:59.372 - 00:17:06.230, Speaker B: Like actually that's everything. And then let's subscribe to the result of that request.
00:17:09.850 - 00:17:42.814, Speaker C: And we send an object in. And the main thing that we provide is a next function which is going to take the response and do something with it. So we're going to get the response from this GraphQL query. At the moment, we've really just submitted this query instead of we want to subscribe to trades to Vega, the Vega Node, and we're going to get a response back with some trades in. You can see it's really actually very simple to get this data out of the node. And now let's just do a bit of a check. Let's just check that our response actually has some data in it and that the data contains some trades.
00:17:42.814 - 00:18:02.874, Speaker C: Because if you get empty data, you don't want to have a sort of null pointer exception or something like that. And if it does, let's log first off, let's log in the console that we received some trades just so that we can see what's going on if we need to debug it. And then let's add those trades to the existing trades array that we just defined up here.
00:18:02.912 - 00:18:07.770, Speaker B: So we'll do trades Concate.
00:18:10.670 - 00:18:55.414, Speaker C: Concatenate the trades on. And what we want to do is we want to concatenate the Earth data trades. So this is just, again, the response from the GraphQL query. And then what we can do is we can say, let's slice that array and let's set it to be a max with a max trade. So now if after we concatenate that this isn't going to work, this is going to work or not, this may not work because this is probably going to always take the beginning of the probably always get to the beginning of the array. So we're going to get the wrong set of max trades, which is not going to be exactly what we want. So I'm going to leave that off for now.
00:18:55.414 - 00:19:39.762, Speaker C: We're going to have to deal with that later. We'll deal with our very long thing and then we call the set function that was passed into this just to set the trades and set it on our way so that's all there is to it to create something that connects to Vegas. So when we build a simple front end in a second, what we'll find is that we've done enough to subscribe to the trade data, we've done enough to receive that data, add it to an array of trades, and then publish that out to the application that we're building. And one of the things that's really exciting about the playgrounds is if you click Docs on the right, you can see that everything that you can do, as well as all the docs that I showed you earlier, everything you can do is here. So you can take a look at the trade subscription. You can see everything that's available. You can see what data I get about a buyer.
00:19:39.762 - 00:20:14.020, Speaker C: You can even find you can actually find the positions and the margins for the buyer if you wanted and view that. So you get a really rich set of data that's available via the GraphQL API. So let's move back to our application and let's build something in the front end because at the moment we've just got the boilerplate that came in. So let's replace that boilerplate. Instead of a paragraph with that text in, let's stick a listing and then let's do.
00:20:18.790 - 00:20:23.590, Speaker B: Each trade trade.
00:20:24.490 - 00:20:54.202, Speaker C: And then in brackets, we're going to do trade ID here. And this is just useful so that it can sort of keep track of the trades and knows that the ID is the thing to key the results on. So we'll do that and then in there let's just create a line and then let's just put some information about our trade. So trade size and trade price. So there we go. So that we got that in there and now we're just going to need to import the trade stream that we created.
00:20:54.266 - 00:21:08.130, Speaker B: So import stream from store and then.
00:21:08.200 - 00:21:25.366, Speaker C: Let'S just instantiate that trade stream and create a new trade stream like that. Let's see what's happening. Do we have a list of trades or not? No, we have an error. That's the fun that you get in the live demo. Trades is not defined, it's a reasonable sounding error.
00:21:25.398 - 00:21:27.594, Speaker B: So let's try and work out what we've done.
00:21:27.792 - 00:21:30.140, Speaker C: So we've defined our trades there.
00:21:36.990 - 00:22:04.024, Speaker B: Interesting one stores. What are we missing? What are we missing? We got an error here. Stores line 21 five.
00:22:04.062 - 00:22:06.312, Speaker C: So something's failed to compile this door.
00:22:06.456 - 00:22:18.268, Speaker B: So let's just take a look back in there. Where is ah, we've got our function.
00:22:18.354 - 00:22:35.510, Speaker C: Start, but after this function start we need to close the brackets around the readable that we're returning. So we compile that and see what's happening over here. Hey, there we go. So we've now very quickly been able to build something that streams trades but as you can see we are.
00:22:37.960 - 00:22:38.324, Speaker B: Just.
00:22:38.362 - 00:22:47.736, Speaker C: Getting the size and information. So let's see if we can add some more information to these trades here. So let's add the buyer and seller. So let's go into the app and.
00:22:47.758 - 00:22:53.690, Speaker B: Then let's just have the trade ID.
00:22:54.380 - 00:23:03.116, Speaker C: And then let's see if we can get a funky little arrow and then.
00:23:03.138 - 00:23:05.452, Speaker B: Let'S put trade buyer ID.
00:23:05.506 - 00:23:18.210, Speaker C: So now we can see who's buying and selling the trade and then let's go back and there we go. So we've now created something pretty interesting there and then.
00:23:20.200 - 00:23:26.996, Speaker B: Let'S just go back into the store and let's just see.
00:23:27.018 - 00:23:28.470, Speaker C: What happens if we.
00:23:33.640 - 00:23:41.100, Speaker B: This workshop, that's.
00:23:41.120 - 00:23:45.530, Speaker C: Going to be the wrong way of doing it. It's going to be.
00:23:49.740 - 00:24:06.496, Speaker B: Stock length minus trades. It's one that should take the last.
00:24:06.598 - 00:24:08.144, Speaker C: Rather than the first and so now.
00:24:08.182 - 00:24:12.230, Speaker B: We should start to see things. No.
00:24:15.080 - 00:24:21.876, Speaker C: My programming is not working very well here. So let's remove the slice and then.
00:24:21.898 - 00:24:24.984, Speaker B: Let'S just go for, let's go for.
00:24:25.022 - 00:24:52.060, Speaker C: This way around of doing it. You guys will probably be better coders in JavaScript than me. It's not my usual language but let's reverse it so that we get the new ones on top at least. So we can see them kind of coming in. There we go. So we can now see each time we get a new block, we're getting a new set of trades being pushed into the client here on Vega. So that is a very quick sort of tour of some of the front end development.
00:24:52.060 - 00:25:56.452, Speaker C: Obviously, pretty much every feature is available via the GraphQL. So as well as being able to sort of look at the data, that kind of gets created by queries and by subscriptions, you also have mutations. So you can actually submit transactions to the blockchain, you can prepare transactions and submit them once they're signed, and you can basically do everything that you could do from any of the other APIs and any interaction with the Vega network via the GraphQL. So that kind of concludes a very quick obviously we only have sort of half an hour or so to do this, so a very quick sort of summary of how to start building things with Vega. Hopefully what you guys can see is that actually connecting to the nodes, connecting to the network, getting data out, querying about trades is really, really easy. Obviously, if you're building interesting complex visualizations, it might be that you actually want to do this in Python or do this in Node and store some data and do some stuff on the server side, or it might be that you want to just build something entirely client side. That's up to you.
00:25:56.452 - 00:26:43.044, Speaker C: But we've done a very quick tour of the GraphQL APIs and some of the documentation and we've demonstrated how easy it is to build something against the Vega network and nodes and use the APIs. So I really I'd like to hand it over to you guys just to sort of find out if you've got any questions. And I'm going to take a look at the chat as well and see if there's any questions that I can answer in the chat as well. But feel free to add questions in the chat or once I've gone through these ones, speak up as well. So, first one block time on Vega is roughly in the order of seven or 800 milliseconds. So if I switch back over to testnet and look at our network panel here, you can see the last block. Every so often it samples a block duration, so sometimes they're up to sort of a second 900.
00:26:43.044 - 00:27:15.048, Speaker C: Got some slow blocks going on there. I'm not sure why. We occasionally build new features and give ourselves some performance headaches, and that's something that will obviously settle down as we get through public testnet and into main net. But the usual expected block time is sort of seven or 800 milliseconds. We're seeing slightly higher sometimes at the moment that maybe that some of the new features are slowing things down occasionally, but you can see you're sort of getting that seven or 800 a lot of the time and then occasionally getting longer blocks as well. So that's the block time question. Do groups of trades come in with each block?
00:27:15.224 - 00:27:15.852, Speaker B: Yes.
00:27:15.986 - 00:27:48.596, Speaker C: So trade ordering works in the order that the group of trades in the block exists. So the block is ordered. It's not just a bag of not just a set of trades, it's actually an ordered set of trades. There's actually some really cool stuff. If I go to here, there's a really cool paper that I really recommend if you're kind of interested in some of this techie stuff. And there's actually a talk about it as well. So the talk, which is quite a long way down this one here with Klaus talking about Mitigating front running and ordering.
00:27:48.596 - 00:28:27.670, Speaker C: So this is a really good introduction talk to this. But there's a paper on it as well, which is available here on Iser. And this paper basically covers our unique research into how to get fair ordering of transactions within a block. So we've actually designed a protocol which runs at the consensus layer of Vega to give fair ordering. And it means that if you trust that the two thirds of Validators are sort of honest nodes, then you also trust that you've got fair access to the order book. So that's really worth a check. So any other questions from anyone on the technical side, on the protocol side, on the network side? Anything about Vega? Very happy to answer any questions you have.
00:28:27.670 - 00:29:07.484, Speaker C: And of course, obviously, if there's no questions right now, we're also very happy in Discord to answer questions in the public chat channels or via DM and direct message on Twitter, wherever else you find us. Always very happy to engage with you guys. Same in the forums. Just interested to keep the conversation going. To get your feedback as well as your questions, any feedback you have, anything you like, anything you don't like. Very happy with any of that. This demo on GitHub, yeah, I'll happily share the code from today's demo and some links to some of the other demos and example scripts as well.
00:29:07.484 - 00:29:10.590, Speaker C: Absolutely. Very happy to share that information as well.
00:29:14.820 - 00:29:42.730, Speaker A: Thanks so much, Barney, that was a great session. If there's no more questions from any of the hackers on the call, as Barney mentioned, you're more than welcome to reach out in Discord in the Sponsor channel. And yeah, perhaps you could even share these slides in the sponsor channel. Barney for the hackers and yeah, thanks so much. That was really.
00:29:44.860 - 00:30:06.796, Speaker C: Very happy to share the slides. I'll get them onto Discord in the channel and we'll get the information up onto GitHub for the quick Example demo that I created and some of the instructions for that, too. So happy to share that. Thanks everyone, for your time and thanks for your interest in Vega. Thanks for participating in the hackathon. I'm really excited to see I think there's some really cool stuff we can do with the data in.
00:30:06.818 - 00:30:07.192, Speaker B: Vega.
00:30:07.256 - 00:30:15.812, Speaker C: It creates an absolute ton of data, and I think it'll be really fun to see some of the visualizations. And I've been thinking about ideas myself, but I don't have time to do any. So we're really excited to see what.
00:30:15.826 - 00:30:16.950, Speaker B: You guys come up with.
00:30:18.520 - 00:30:21.730, Speaker A: Cool. Thanks, Barney. Cheers. Thanks.
