00:00:06.170 - 00:00:07.200, Speaker A: Okay, we're good.
00:00:09.490 - 00:00:51.546, Speaker B: All right. Welcome, everybody, to a hackath workshop. This time we've got one of our sponsors and partners threebox with us. Zach Furland, an engineer at Three Box, is going to be giving an intro, an overview, and some code walkthrough through to what Three Box actually is and how you can use it in your project. So thank you, Jack, for taking the time to teach us a little bit about the project today. If everybody doesn't know, the Week one check ins are happening this today and yesterday. So make sure to check out your cohort channel, drop an update about what you've been working on, what your project is.
00:00:51.546 - 00:01:41.098, Speaker B: It's always interesting to see where different people are at different stages, and then once we have that information, the ETH Global team is able to kind of help you get rid of any blockers or challenges that you're facing. So make sure to do that. If you're not in the cohort channel, it might be because you haven't created your project name yet or added a project. So the way you get around that is by going to your hacker dashboard and just creating something. It can be a placeholder name, but just make sure to do that, and then we'll get you in a cohort, and then the little logistics things will be all settled for the rest of the event. Before we jump into it, does anybody want to give a one sentence update for what they've been working on? Just one sentence, nothing too long. You can put it in the chat.
00:01:41.098 - 00:01:51.600, Speaker B: You can unmute. I'm just curious where people are at if they want to share anything. There we go. Save it, animal. Yeah.
00:01:52.710 - 00:01:59.010, Speaker A: We have been working for implementing Verifiable credentials document on top of ceramic.
00:01:59.830 - 00:02:06.050, Speaker B: Cool. Ceramic cousins with three box. This is on topic.
00:02:06.130 - 00:02:06.694, Speaker A: Anybody else?
00:02:06.732 - 00:02:08.920, Speaker B: We'll take one more before we jump into it.
00:02:13.210 - 00:02:37.840, Speaker C: Sure. I'm working on a contacts app. It's hopefully going to be able to allow you to enter your own contact information, but then subscribe to other people. And then you slowly build up a contacts address book, but you're not updating any of the contact information other than your own, and you're just getting the information from other people.
00:02:39.010 - 00:02:53.220, Speaker B: Awesome. You guys are both in the right place to learn about Three Box and user IDs, contacts, stuff like that. This is perfect. All right, Zach, I will let you take it away and start your work.
00:02:53.910 - 00:02:54.660, Speaker A: Great.
00:02:55.910 - 00:02:56.274, Speaker B: Yeah.
00:02:56.312 - 00:03:33.270, Speaker A: Thanks for the intro. Like Trent said, I'm going to do basically a little intro and then walk through some of the things. We have a brief overview and then probably just show some of the code and kind of dive a little deeper. Since we are built on IPFS and Orbitdb, kind of show what some of the underlying things look like. Blower API. I can share screen here, right? Open that up. All right, cool.
00:03:33.270 - 00:04:17.808, Speaker A: Yeah. We're Three Box and gist of it is we provide a user centric data and identity layer for your applications. Basically what that means is you can authenticate with an Ethereum account and then you get access to this keychain that which you can then link data, link other accounts, permission data, then you can kind of take that and build these other perimeters on top of it. So some of the most common use cases we saw early was profiles for example. So one of the things you can do is you can link an Ethereum account and then you can link it to all profile data. So you can write data to a public store. These things look like just basically key value stores.
00:04:17.808 - 00:04:56.240, Speaker A: So you could add a name, an image, you can link a Twitter proof, that kind of thing. And then other people are able to resolve this data in SDB. Like I said, this is all an IPFS part of this as well is there's also private space, so you can also encrypt data with the same keychain. And if you for example go to one app and then go open it up in another, you could authenticate there and resolve the same data there as well. So you end up with this shared local cache across applications. Beyond that there's also these things called spaces in a similar theme. You end up permissioning data to your application.
00:04:56.240 - 00:05:28.260, Speaker A: So if you're running an application, you don't have to run any back ends or anything. You kind of create a space and a user can store the stuff. You get this key value store and then users can store stuff and you can write stuff to the space for the user and the same thing, they could bring that and permission that data to another application if they wanted. So it provides you all the ways to do that. So I'll see here a good place to start if you're building on it is kind of come to our docs here. And this has a walkthrough of basically the different pieces. I said all separated here.
00:05:28.260 - 00:06:18.280, Speaker A: It's like what identity looks like, auth profiles, these storage mechanisms, I guess I forgot this messaging. So on top of these things you can also then using the same primitives is basically build threads and chat systems and things like that. So say you have something like a comment system, you can resolve profiles, you can also have the comments in a thread and these data structures can be shared based off lip and IPFS. So see some of those yeah, these kind of go in kind of detail if you want to quick start. The main thing you'll be interacting with is something called three box JS. So it's our main JavaScript library. And if you're going to implement on your app, you just pull this library in and then use these Auth functions here and these write and read functions.
00:06:18.280 - 00:06:57.236, Speaker A: So I'll go through those in a moment. Often when people are first starting, they kind of implement. So we do have a few things that are easy to pop in your projects besides just like if you were going to build your whole data layer on three box alone, a lot of people start with these. We have a few basic react plugins that kind of show and give you a good idea what this stuff looks like. What I was just saying so one of the things what I said was like profiles so a lot of places DApps are showing just ethereum addresses like in leaderboards or comments or anything else. Instead of showing that you can actually show a hover that resolves those data for the profile. It's kind of like showing what it looks like here.
00:06:57.236 - 00:07:44.420, Speaker A: So you're showing address for a leaderboard. So some people are implementing these where instead of showing addresses you can have a resolve to data in the profile. So you can actually have verifiable links to GitHub and Twitter in here and then there's just like this kind of metadata images I attach that are stored in IPFS and names and stuff like that. So now you can bring this any stuff you don't want to store on chain or instead of storing like as just an unstructured blob in IPS, now you have a way to resolve this data and bring it into your own app or see it in other places. Another one of those plugins is commons plugin. So same before, this is what the comments actually look like here's like an example of it here. So it's all built in three box in a space in a thread and again they're resolving three box profiles here and this data is stored in a log here.
00:07:44.420 - 00:08:23.620, Speaker A: All these comments are signed. I said if you're listening to this live, you'd actually be listening to the same thread. So in every three box, anytime you're using three box JS, you're actually running an IPS node in the browser and that's actually connecting to basically pub sub runs for these same DBS and topics. So you can get updates here. So anytime I write a comment here, that'd be sent out to other peers or through our printing service as well. So this is one of the implementations, another one is these kind of chat boxes, similar. So these have been some of the easy ways that people have quickly added some social features into their apps.
00:08:23.620 - 00:09:11.516, Speaker A: Let's see. So I'll go over to a little bit of a demo now, kind of what it looks like underneath and some of the pieces we're actually doing, kind of like what our infra setup looks like. Yeah, during this part, feel free to ask any questions at any point and at the end we'll save a bunch of time to basically help with anyone who already started implementations or has any questions about what we're doing. We also mentioned ceramic before, probably can mention a little bit at the end. But this will mostly just be like three box part and it'll give kind of an idea of what drove thinking about ceramic after. So you see here, this is not too fancy of an example app. This is just a simple page using three box JS.
00:09:11.516 - 00:09:57.702, Speaker A: Like I said, it already connected. So when I authenticate here, let's see might to reload this. Yeah, so part of this is we have this thing called 3D connect now. So the keychain, basically your underlying keys are now managed in this iframe. Eventually they could be like in other wallets or in MetaMask and they could have a similar RPC layer for these kind of identity or permissioning functions. Right now, like I said, it's the iframe. So this is basically asking me when I authenticate.
00:09:57.702 - 00:10:31.920, Speaker A: I sign a message and then I'm driving a keychain from that for use in three box. So right here it says basically do you want to use my profile? It also asks me if I want to access like a space after if I open one of those. So I'll press continue here. This is an account I already had. So I already signed initial message. I have this keychain available already. One of the things that helps us link this all together, like identity is a big part of build to permission this data build to manage your keys, build to bring it to different contexts like this.
00:10:31.920 - 00:11:05.190, Speaker A: So we use something called DIDs. These are decentralized identifiers. Basically the idea is you end up with this opaque Identifier that you can use that then to resolve key material mainly. Like for example, you can use this Identifier to resolve public keys. So if you're signing data in any way, you could resolve it to this Identifier and then verify those data payloads. You don't have to resolve it with any centralized one. You could have these different basically anyone can implement different did methods.
00:11:05.190 - 00:11:31.386, Speaker A: Ours is a specific one to us, the three box. So you see the prefix here. And our did implementation is also implemented on IPFS. So you could probably recognize this right here. So like that doc, I think I'll show that after. But like I said, the main thing we do right now is you take this did and then you can link it to an ethereum address. And what this does here is this is creating a proof.
00:11:31.386 - 00:12:34.654, Speaker A: Like I said, I'm signing it with for example, my EEP key and I'm also signing it with my keychain after as well. And that creates a proof that anyone else can resolve these two things and see that these two things are linked to each other. So you can see here, for example, actually just I'll get this right here. Let's see. So I have the box object on the window. I'll just get it from these DIDs. Like I said, ours are in IPFS.
00:12:34.654 - 00:13:12.590, Speaker A: So if you're using our did resolver, which is this three it resolves this basically IPFS object. And you can see what this actually looks like. So Sample has the keys here. Signing key also has these other key material here. So you can see in this one as my signing key. You'll see after once I sign this data in here, I'm basically resolving this did and I'm getting the signing key. And then I can verify that payload as encryption key management key is just the ETH address.
00:13:12.590 - 00:13:39.640, Speaker A: So it's kind of how you update these kind of documents. Right now you get the single document, but in the future, like in the context of ceramic, you could link lots of accounts, you could do key rotations and all that kind of things. But right now it looks just like this. Like I said, we have this public store. This is kind of where most of their profile stuff is. So I can just add something here. So I set some data, set these values here.
00:13:39.640 - 00:14:41.526, Speaker A: Yeah, now I have the same example. Open just add another domain here. So I'll open it up there as well. It like I said, if you go to another domain now, it's going to look similar to like you'll see again, basically three ID connect will pop up. So now I'm on another domain. It's saying like, do I want to now permission this data and give access to this page to build to decrypt a space or load that data. So I'll press continue now this domain, get access to resolve the rest of that and open it up here.
00:14:41.526 - 00:15:24.894, Speaker A: So I could do the same, like in a private store and have access to this keychain inside the Iframe to decrypt this data. So you could imagine like, this would be a different app and you need to be able to bring this space in this data here and load it. Yeah, so then I was going to show here. So like I said, three boxes built on Orbitdb, which is this DB layer built on top of IPFS, and they implement these basically these data logs. So it's an easy way to get like before for a profile. For example, if you're implementing an app, you might just throw that data in a Blob, push it to IP fest, and you end up with this unstructured data that no one else can resolve or verify. And it's hard to update.
00:15:24.894 - 00:15:48.300, Speaker A: So if you're going to update it, you'd be pushing a new object each time. This is like a good way to build key value stores on top of it. And you do that by building an underlying chain and log of values. It's kind of like a change log. Some people are familiar, I guess, with CRDTs. That's the format for Orbit. So I can show what the underlying data actually looks like that you're seeing here.
00:15:48.300 - 00:16:18.226, Speaker A: So I just opened up the underlying values. As you can see, each one of these entries is in IPLD. So you get these CIDs right here, these hashes, each one of the entries, these resolve to these objects here. You can see this metadata. Let's talk about the identities. So you see the actual payload here. So the cool thing is they're signed with these DIDs.
00:16:18.226 - 00:16:43.520, Speaker A: So it's an identity. Also this right here is just creating a proof also to you have like a temporal key in the browser. This is also creating a link between this did and that key signing this payload here. Like I said, you can resolve then the public key through the did doc verify this payload. And now anyone else can load this data and verify it. You don't need to trust where it came from. Just like upload trust like what the data is.
00:16:43.520 - 00:17:08.886, Speaker A: So another peer, if they would have the same DB opener, want to listen to it, I could write an update here. They could get this, they could verify that this came from this did in the context. Could be like verify it came from this ethereum address, for example. So you can see some of the logs here. So these things build a chain of values. You can see this is referencing the next, so the prior entry. And that is one of these objects up here.
00:17:08.886 - 00:17:52.622, Speaker A: Again, I guess like this one right here. And yeah, the cool thing is if you wrote these two pages could be entirely disconnected if they were offline. I could write values to both. Once I come back online, I could share these with one peer or another and then build a similar chain locally, again verify it and then construct this kind of key value store here. One of the things we have that kind of makes it possible right now is we run a three box pinning service. So all this data is pinned in our infrastructure right now. Also, like I said, if other peers are open at the same time, like in the thread, you'd be storing all that thread data on your client in the browser.
00:17:52.622 - 00:18:40.580, Speaker A: So you have all these local caches. But I said if any of those go offline or they're not available to sync it, we are storing and syncing it all on ours. Eventually we'd want like a bunch of service providers to provide similar services or you'd even be able to select different providers in different contexts. And either choose like say if you want to put it in persistent through filecoin or you want to just persist it in some other form through some service provider that has some guarantees. Yeah, like I was saying before, if you're actually influencing your application, it looks the same, but you might make a separate space for your app. So this is permissioning, it separately. So it's asking me again like, do I want to give this app access to this space? So I'm going to say yes.
00:18:40.580 - 00:19:24.020, Speaker A: Signing a thing here confirming. So then I got the space and if I had an application, I could just have this. And then if I went to another app, so they might ask, can you use my app space? I'll say, yes, the same thing here. And it doesn't allow granular permission like over at separate keys right now. But this is a good way to kind of get a similar effect. The last thing I'll show quickly is that we have threads as well, and these are built on the same underlined logs. Instead of building key value stores, you have a word list of comments or other kind of data or event changes or whatever you need there.
00:19:24.020 - 00:19:58.490, Speaker A: So I'll open the thread. Let's see, actually I'll create a confidential thread. So we do have a few options for threads. You can create a public one, anyone can write to it. You can create one with one or more moderators, and moderators can delete comments and stuff. You can create a members only thread which basically has these action controllers for just allowing certain DIDs or certain Ethereum addresses to write data to that thread. And then similarly, you can have member ones which are also encrypted to a set of members.
00:19:58.490 - 00:20:22.980, Speaker A: So I'll just create thread here to a space. I'm in thread. As you can see on the moderator. I do have the ID here. For this space, there's a thread address I'll write. Some things come to this. Yes, I'll come to this page and let's see, open up the same space.
00:20:22.980 - 00:22:06.508, Speaker A: What is it called? My app. You it's open. Let's see. Got the same. Actually, this time I'll just open it by thread address. I don't know if it reconnected, it come back to that after. It's also less interesting with the same user.
00:22:06.508 - 00:22:34.296, Speaker A: But if you had multiple users, you basically opening these up. You could add other thread members that's managed to an access controller, where basically you're creating a separate encryption key for the thread. And like I said, just like now you have DJDS. You can resolve these public keys, you encrypt it to their public keys and have these in the access controller. They can then fetch this data, then get that key and decrypt these entries. So that's what usually would happen here. Yeah, this is the most of it.
00:22:34.296 - 00:23:26.190, Speaker A: I'm glad to actually, I guess to say the last thing. One thing. We do Fusion Library as well, one of the things we also run based on API service, that kind of it indexes these DBS as well, so you don't always have to open up my IPFS instance in the browser, sync that data. We also index most of the public data, so like profiles and spaces, and you can get that through the library as well. That doesn't allow you to write it, but you can quickly read data from any of the public items and public threads as well. Guess I'm not getting this one. There we go.
00:23:26.190 - 00:23:53.230, Speaker A: It's just loading kind of slow. Finally, eventually loaded these entries here. If I type something here, we'll see it. Get it pretty quickly here. Same thing as a moderator, I can delete posts. I said they do stay in the underlying log still. The underlying data is still there.
00:23:53.230 - 00:24:32.904, Speaker A: I'll show quickly just what these look like. They look pretty similar. So I'll do. Let's see. Um yeah, so similarly, like here's the log, these values payloads say what these look like here, so you can see that these are just encrypted values. And then quickly I'll show basically, like I said, these have also access controllers. And these access controllers are stored in a similar way in a log.
00:24:32.904 - 00:25:10.660, Speaker A: So I can get that do same thing. So I'll read all the logs out from here. The axe controller just has one entry right now. Since I was just added as a moderator when I created it, basically you do is you create it's who the did is capability. And like I said, then you can resolve the public key for that did and encrypt the key for this thread to that user. So if I was going to add someone else, it'd simply do the same thing, create an entry here, and when I sync all this stuff locally, if I have access to it, I'll be able to get that key and decrypt it. Yeah.
00:25:10.660 - 00:25:53.086, Speaker A: So that's just the three box right now. I can take any questions. I see there's some things in the chat. Yeah. Is there anything I want to do for the format for questions? Do we should just ask them in the chat or open it up if anyone wants to ask anything?
00:25:53.188 - 00:25:57.954, Speaker B: Yeah, it looks like some people have written out questions, but see Danny and maybe some other people.
00:25:57.992 - 00:25:59.220, Speaker A: Oh, Denny's here too.
00:26:01.750 - 00:26:07.750, Speaker B: Is there anybody who hasn't had their question answered and just wants to jump in with audio?
00:26:08.090 - 00:26:09.480, Speaker D: Hey, can I ask?
00:26:10.250 - 00:26:11.000, Speaker B: Sure.
00:26:11.690 - 00:26:29.610, Speaker D: Yes. I'm trying to join a confidential thread using an Identity Wallet instance, but it doesn't work. It just stops when I'm able to join a public thread. But then confidential threads just join by thread address method just doesn't resolve.
00:26:30.430 - 00:27:10.780, Speaker A: Okay, yeah, I can look into that after this. We did have just for context, like everyone else, we also have something called Identity Wallet, which manages the keys, just specific three box. So if you're indicating three box alone, you could use Identity Wallet to basically manage the did and the keychain here for three box. So if you were on a server or you want to link accounts in a different way, you can use it in any wallet. Or if you didn't have context where you could get a Web three provider because otherwise that's the interface right now. Yeah, I think we tested a little bit less with the Identity Wallet. So I can sync with you on sync with you on Slack after.
00:27:11.470 - 00:27:13.706, Speaker D: Sure, that works. Thank you.
00:27:13.888 - 00:27:14.620, Speaker A: Cool.
00:27:26.000 - 00:27:38.350, Speaker E: Is it possible to log in via MetaMask or another wallet or something like that. Or I can see on the home page you can kind of do that when I log into the three box website.
00:27:39.440 - 00:27:48.850, Speaker A: Yeah, exactly. So right now Threebox always takes any web Three provider to use an authentication method to drive the keys through three box.
00:27:49.540 - 00:27:57.190, Speaker E: And how do you hook into that in your code? How do you make it pop up the box? Basically, that lets somebody log in.
00:27:57.800 - 00:28:14.152, Speaker A: Yeah. So that's all part of the three box library right here. That's one thing we didn't really see. So they stepped to the docs here. Basically, if you're going to use it, you just create a box and then you authenticate user. And at this point that's when it's going to use. That kind of iframe thing is called three ID connect.
00:28:14.152 - 00:28:28.040, Speaker A: It's just another thing. It's actually running identity wallet, which I was just talking about, to manage the keys. But when you do that, it'll basically ask whatever web Three provider that's passed here. So you pass the provider here, would.
00:28:28.050 - 00:28:34.816, Speaker E: That be kind of MetaMask or Web Connect and those kind of things and then it will pop up the relevant sort of boxes for those.
00:28:34.998 - 00:28:36.130, Speaker A: Yeah, exactly.
00:28:37.620 - 00:29:18.956, Speaker E: I've got a kind of architecture I'm thinking of using. I want to sanity check it. I'm going to have some databases which are going to be using, I think, textiles buckets. And the idea is that one user might have access to five or six buckets or something like that. And so each bucket would have its own private key. And my idea was to maybe put those private keys in the private part of three box so that a number of people could all have access to the same bucket. And there's no way of removing access, but it gives me a way of sharing groups.
00:29:18.956 - 00:29:22.796, Speaker E: Is that a good use of three box? Is that a good way of architecting.
00:29:22.828 - 00:29:23.696, Speaker A: It or is there a better way.
00:29:23.718 - 00:29:25.010, Speaker E: Of doing something like that?
00:29:25.620 - 00:29:59.404, Speaker A: Yeah, I don't know if it's the best way, but definitely like in a hackathon, a good way to kind of get a similar thing, an abstraction is to use like a thread as a log to manage it, similar to how we're doing, like an access controller. So you could use the GIDS here and one of the confidential threads to basically create a log of a way to share key materials or access through that to other things. So I don't know if you're going to have separate keys, but if you had just like a single key that you're creating each time, you could then store that in a log. And like I said, same as our access controllers, basically.
00:29:59.522 - 00:30:23.140, Speaker E: So my buckets are going to behave as if they're users, basically. So the buckets are each going to have their own private key. And then you may have in your three box, you might have access to six buckets therefore you've got six private keys in there and then other people might have access to these same buckets.
00:30:26.120 - 00:30:29.876, Speaker A: Yeah. And then to share access, you saying you have to share the key.
00:30:29.978 - 00:30:31.284, Speaker E: You have to share the private key.
00:30:31.322 - 00:30:31.840, Speaker A: Somehow.
00:30:31.920 - 00:30:35.750, Speaker E: Not quite sure the best mechanism for doing that.
00:30:36.540 - 00:30:58.270, Speaker A: I think usually a thread is a good way to manage that and manage that between users. Probably like any of that kind of metadata. It might not be optimal overall. You might want it as part of actually part of the DD method or just have these extra keys there. And eventually the stuff you want to do in ceramic makes it easier to link these accounts and permission keys and access and manage.
00:30:59.700 - 00:31:12.504, Speaker E: How do I share a thread between a selected group of users? How do I make it so that other people can't see that thread? How do I get somebody to join a thread or invite somebody to join a thread?
00:31:12.652 - 00:31:40.750, Speaker A: Yeah. For confidential threads, the only thing I have to keep track of is, like, the thread address here. Yeah. Then with that they could resolve any of it. Sometimes thing is hard is you have to know the did or just you have to know the ETH address or the did of the other users you want to invite to it. If it's an encrypted thread, if it's just a public one and you want to encrypt stuff yourself or manage it some other way, then you just have to know the thread address and anyone can resolve that without any extra action. Yeah.
00:31:51.220 - 00:31:57.360, Speaker B: Anybody else want to unmute and ask their questions? I see a few more in the chat.
00:32:03.080 - 00:32:09.910, Speaker A: And Danny from the three box team is here as well. I don't know, Danny, if you want to give a briefing on ceramic after.
00:32:10.620 - 00:32:20.170, Speaker B: Or not, I would have a very simple one. Are there contracts on Ethereum testnets for $3?
00:32:22.140 - 00:32:26.276, Speaker A: So there's no contracts for just transaction.
00:32:26.308 - 00:32:27.144, Speaker B: Right there's anchoring.
00:32:27.192 - 00:32:37.980, Speaker A: So there's no yeah, there's actually no transactions at all. Right now it just uses an Ethereum account. It just needs another key pair as a way to authenticate and manage the keychain here as well.
00:32:38.050 - 00:32:41.132, Speaker B: So it's all about the signature and not so much about the transaction.
00:32:41.276 - 00:32:52.180, Speaker A: Yeah, exactly. So it could actually be on any testnet, it could be used across them. And you can easily link other chains and other things in the future as well as as long you have a key to drive that authenticate to this keychain.
00:33:16.880 - 00:33:21.500, Speaker B: Danny, did you want to talk about ceramic a little bit? If you can jump on audio.
00:33:29.400 - 00:33:29.668, Speaker A: I.
00:33:29.674 - 00:33:58.720, Speaker B: Should probably check if he's still here. Maybe not audio issues. Sometimes if you have wireless headphones, they don't like zoom.
00:34:06.660 - 00:34:30.404, Speaker A: Yeah. Anyways, yeah. The gist of it is like going beyond what we kind of built here and taking all our learnings here is ceramics. One of the things we're working on and a lot of same. Things like how we were managing right now. It resolves basically all these links to data, to other accounts, to managing your keys. Permission of those keys is something you can do in these documents.
00:34:30.404 - 00:35:31.710, Speaker A: In Ceramic being like you also don't have to just use because there's some limitations for this kind of data structure. So like using CRDs in some context makes a lot of sense, but there's also pretty slow syncing in it. Often you might want a spectrum of different properties depending on your application. So the idea here is like you eventually build a resolve it to other data stores and those service providers for any services you needed, rather it's like persisting data or anything else. So you could actually use three IDs with textile as well, basically like any other database layers like that as the identity provider in those. So you could be signing stuff and resolving keys through ceramic and three IDs and then the same thing if you need certain other properties below that, like say you need an index and service need like a persistence layer, anything like that. Basically you would have these documents that point to these service providers and kind of say how you want to deal with this data, what kind of relationship you have there, and then other people can resolve these things as well.
00:35:31.710 - 00:35:38.930, Speaker A: Yeah, I think we could talk more about that and follow up stuff. Or you'll find us on Slack as well.
00:35:45.940 - 00:36:12.584, Speaker B: We're just going to see if we can get the call in number if Danny wants to call in and give some more context. So we'll just hang on for one more second. Any hackers want to share if they plan to use three box or kind of what ideas they're working on right now specifically related?
00:36:12.632 - 00:36:13.230, Speaker A: Yeah.
00:36:13.680 - 00:36:15.196, Speaker C: Is it okay for me to go?
00:36:15.298 - 00:36:15.996, Speaker B: Sure.
00:36:16.178 - 00:37:32.180, Speaker C: I mentioned a little bit about this in the comments on zoom, but I'm kind of putting off working on this bigger project and focusing on a smaller thing because the bigger project, I don't think I would be able to get it done within the hackathon. But the bigger project is making it possible for giving an application that allows the user to manage their data and then just tie in identity like different identities to a segment of that data. Maybe also doing it through these profiles that are set to be either read or write. Maybe those profiles follow a schema of some sort so that multiple different apps of a similar type could know how to access the data that it's getting access to through that profile. And then you tie that identity to the profile and then you can log in with that identity and it automatically has access to the subset of data that you've connected to it and the application now has access to that identity. Whatever you need to do. But you have this management tool that manages all the data and connects that data to these profiles and then the identities to the profile.
00:37:32.180 - 00:37:47.690, Speaker C: I don't know if you have any thoughts about that, if you think that that's really close or really far away or what needs to be developed to make that happen now.
00:37:48.620 - 00:39:01.970, Speaker A: Yeah, it's definitely close to a lot of problems we're thinking about with Ceramic. So I was saying right now it's very limited into the missing, even though we have the structured so first case that people were just storing and they're building DApps and they print stuff on chain, so they just put it in a Blob in IPFS one step, I was at least putting it in some structured form and having it in some basic key value form that people can other people can read it, but still, practically, it's hard without Schemas to really know how to resolve and actually consume that data in an easy way in a different context. Kind of hard creating that mechanism to do it. And like I said, people have a spectrum of needs for their apps and this is not going to be the one for all them. So people might want to just build, push bigger files, push stuff some different structure so you'd hope that kind of metadata and that kind of coordination takes place in these kind of documents in some form. Like you're saying it has all these links and you might resolve it through it could be any underlying data provider and then the Schema isn't separate and the identities can also be resolved through a three ID here or like any other did provider as well. If there's any other identities, that makes a lot of sense.
00:39:03.380 - 00:39:29.930, Speaker C: When I initially started thinking about this, it looked like ceramic was the tool I would need to use. But I've been focused totally on three box. Would ceramic be that tool or in the future, would it be the one tool that I would need to use and three box would just be an implementation? Or would I still continue to use threebox as like the developer friendly API for ceramic underneath? Because I know that threebox plans to use ceramic too.
00:39:30.380 - 00:39:59.780, Speaker A: Yeah, exactly. But like I said, three box would just be most of the stuff in three box. Like all the stuff you saw with links and permissioning. Stuff like Schema's X Control would be in ceramic instead of three box. And three box would more look like would actually almost just be like orbitdb with this identity layer and way to resolve that stuff through ceramic. That's why it's kind of like an iteration of where we're moving this identity stuff. The links did stuff out of what's, three box now more into ceramic.
00:40:01.320 - 00:40:12.820, Speaker C: Do you know when the library from Ceramic would be available to start using? I know it exists right now, but I've read that it's still heavily under development.
00:40:13.160 - 00:40:47.392, Speaker A: Yeah, it's pretty early. I think some teams here are trying to create basically some of these documents. So, like, the format for what schema would look like or how you would resolve data to different service providers and stuff. So I think some people are exploring that. We have basic ways to create the documents, checkpoint them and stuff and verify them. But yeah, it's not used in three box JS yet that will be coming in still a few months out, and then that would be the point we built to attach other providers and other identities and stuff. Cool.
00:40:47.446 - 00:40:48.290, Speaker C: Thanks, man.
00:40:49.620 - 00:40:56.710, Speaker A: We definitely love inputs, like how you'd imagine connecting these things in some way and if it makes sense to fit in these documents or how they would look like.
00:41:03.420 - 00:41:07.320, Speaker B: Danny, did you want to add anything to that? Looks like you got in successfully.
00:41:09.580 - 00:41:18.590, Speaker A: Yeah, I think I'm here. I didn't catch a lot of the review Zach gave, but it sounds like he covered a lot of it. But are there specific questions that more context is useful on?
00:41:23.390 - 00:41:28.430, Speaker B: I will leave that to people in the chat. Did most of the questions get answered?
00:41:33.410 - 00:41:44.500, Speaker C: All of my questions got answered, although I would love to keep talking about ceramic if there's something more that there is to cover, but maybe we've covered everything.
00:41:45.510 - 00:41:54.360, Speaker A: Yeah, I think we also talked about doing a separate session on ceramic maybe sometime next week, so we can dive deep into that then as well.
00:42:01.120 - 00:42:06.850, Speaker B: All right, Jack, if there's nothing else you'd like to cover, we could probably wrap up.
00:42:09.460 - 00:42:18.790, Speaker A: Yep, that's good. And I'm in now, I think three I'll be in the box channel as well.
00:42:21.400 - 00:42:47.160, Speaker B: Awesome. Well, thank you for going through all this stuff, and there was some good discussion as well. Appreciate you and Danny hopping in, answering some questions. This is going to be useful for people and like all of the workshops, we recorded it, so if anybody missed something or wants to go back through, this will be available on the ETHGlobal YouTube channel, and we'll make sure to drop it in the three box channel as well in the hackafest Slack.
00:42:47.740 - 00:42:48.570, Speaker A: All right.
00:42:50.460 - 00:42:55.280, Speaker B: Thank you, everybody, for coming out, and we'll see you in Slack.
00:42:55.860 - 00:42:57.790, Speaker A: Thank you. Thanks, everyone.
