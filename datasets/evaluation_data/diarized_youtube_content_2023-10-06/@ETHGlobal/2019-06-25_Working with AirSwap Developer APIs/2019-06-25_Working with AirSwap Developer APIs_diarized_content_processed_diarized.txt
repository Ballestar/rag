00:00:00.330 - 00:01:02.698, Speaker A: So hello, thank you for coming. I'm going to talk a little bit today about the AirSwap libraries that we just open sourced this week, as well as about building on the swap protocol and some ideas to get you started this weekend real quickly. So what I'm going to walk through is an example application that's built only using the these open sourced libraries. The initial things that we'll touch on are mostly things that are just going to help you build your decentralized applications more quickly. And these libraries are the same ones that we've used to build all of the products at AirSwap. And so that includes things like getting token metadata really quickly, approving balances and tokens for trade, as well as all kinds of other little helpful things that we'll touch on here. And then after that we'll go through the swap protocol and how you can interact with it programmatically to make trades and perform atomic swaps.
00:01:02.698 - 00:02:26.170, Speaker A: And then we'll also do just a really bare bones how can I make an order, sign it, send it to someone else and have them fill it. So whether you want to use the full protocol where you're actually going to reach out to these automated liquidity providers and get orders from them, or whether you're making an app where you just want to be able to sign an order and send it to someone to perform a simple swap, we'll cover both of those use cases. Okay, so what we have at the top here is all of our imports from AirSwap JS, which you can install from NPM. And you'll see these token metadata, delta balances, Dex index swap. These are the ones that I've selected because they're probably going to be the most useful. But there's a lot more in there if you just want to take a look through the code. And I really encourage you as you build things this week to check to see if we've already built it because it's likely that we have and if it has anything to do with tokens or common utilities like wrapping wealth unwrapping WETH that's actually available in the ERC 20 library here, then yeah, take a look.
00:02:26.170 - 00:03:26.630, Speaker A: I'm going to refresh the app and I'm just going to walk through what each of these sections is and does. So here we have the metadata. Oops, I'm going to start the server here. All right, so this is token metadata coming from our token metadata class which is logged out here. So you can get all of the most popular ERC 20 tokens. You're going to get this whole JSON object that has a bunch of information like the amount of decimals, the token address, and then also most of them come with an image URL that's crawled from Coin market cap. So if you need any of that data in your applications, you can just pull that in.
00:03:26.630 - 00:03:56.130, Speaker A: We also have balance. Lookups. So what you'll see here is I'm connected through MetaMask and it's actually looking at my die and WETH balance. So if we pop over to the code, that's going to happen in our first then block. So let's just start at the top first. Actually, first thing we're going to do is wait for our metadata to be ready. It's asynchronous and then once we get it, we're going to render it.
00:03:56.130 - 00:04:49.148, Speaker A: I won't step through every line here because it is commented if you want to come back for it. Is that a little better? Maybe like this? Yeah. All right, so here I've decided just arbitrarily to render Die and WETH. But again, you could look through all this token metadata here and iterate over it and find what you need. It's most likely if it's an ERC 20 that it's going to be in here. The next utility is the Dex Index Library, and this is an open source tool that we built earlier this year. And it allows you to programmatically search all of the popular DEXes for any arbitrary queries.
00:04:49.148 - 00:06:00.854, Speaker A: So that could be like, I want n amount of X token and it's going to reach out to DDEX, Etadai, AirSwap, some Zero X relayers, Bancorp Uniswap, you name it. And it's going to send all that back to you so that you can find for whatever type of liquidity your application needs. What at that moment is actually the optimal decks to perform that trade on. All right, okay, so you're going to see that I just signed something there and you're going to actually see that every time I refresh the page. So what it's doing there is it's programmatically connecting to the swap protocol. And in order to do that, to prove your identity on the system, you have to sign a piece of arbitrary data each time. And so that's what that signature is for.
00:06:00.854 - 00:07:01.332, Speaker A: And then once that happens, I'll show you in the code in a minute. But we're reaching out to all of these automated liquidity providers who are connected to the network right now and asking them, hey, I want an order for this amount of this token. And what they're actually sending back here, you'll see some of these, they're not online, so the request timed out. But a lot of them, they're actually sending back an actionable order that was transmitted peer to peer specifically for your address so no one else can fill this order. That's kind of one of the fundamental principles of the protocol is at this point in time, this maker has signed this order specifically for you and you can execute it at the bottom of the app. So let's look through the code here real quickly. So the first thing that we're going to do is we're connecting to the router.
00:07:01.332 - 00:08:03.930, Speaker A: And again, this is coming from one of our classes in our library here. Once we're connected, we're going to get ETH orders. This is a helper function that I just wrote specifically for this example. But basically what it does is it looks at the token address that you want to buy or sell the amount, and then whether you're on the buy or the sell side, from there, it reaches out to the router and gets back a bunch of orders in this promise here. And so we're going to set those onto our state and then that's how they're being rendered on the Dom. So let's actually fill one of these orders. Let's say I believe this is for 50 die.
00:08:03.930 - 00:08:52.570, Speaker A: Yeah. So right here in our original routine, we're going to look up an amount of 50 die from each of these makers. So I'm going to ask them all for new orders. We're going to wait for them to come back. All right, so I got an order back from this automated maker. I'm going to take it down here to this little fill order box. I'm going to hit fill.
00:08:52.570 - 00:09:35.052, Speaker A: I'm going to say, yes, I actually want to make this trade. And we're going to see here in the console we have a fill order success. And we should see the MetaMask notification come up in just a minute that our transaction was mined. So what we're doing here is what I was talking a little bit about originally, which is the full swap protocol. So we're connecting to the router, which is a messaging system that passes messages back and forth between peers. And we're contacting everyone and saying, hey, I want 50 die. What kind of order can you give me? We're getting back a bunch of signed orders.
00:09:35.052 - 00:10:31.430, Speaker A: We're choosing the one that we want to execute, and then we're submitting it to the ethereum blockchain. So that's sort of like the full loop. But what I'm going to show you next is perhaps you just want to build like an NFT trading application. Like you want to trade CryptoKitties or make like a GoDaddy clone, but for ENS names, which are now ERC, 721 NFTs. You could do that as well, but it might not fit specifically into the scope of the protocol that we just went through, right, where you're reaching out to these automated makers and everything. So for these use cases and to kind of just fit into the theme of your application, you can totally just at the most basic level, put in the parameters of the order that you want, sign it, transmit it to the person who it's intended for, and then they can fill it. And all of the helper methods and everything that you need to facilitate this are, of course, here.
00:10:31.430 - 00:11:10.190, Speaker A: And so that's what we're going to do next. So I'm switching to a different account and to the original account. We're going to paste in that address here as the taker. And the terminology here, maker taker. It's kind of common in trading. If you've worked with DEXes, you might have heard it before, but it's also very literal, right? Like for AirSwap. The person who is literally making the order and signing it originally is the maker.
00:11:10.190 - 00:12:15.390, Speaker A: So in my case, in this little order builder here, we're going to be the maker. And so we're going to say, hey, we want to trade WETH and we want to trade like just a little bit of WETH taker is going to give us die and they're just going to give us one die. So let's go ahead and generate that order. We're going to sign off on it. And we just generated a signed order. So you can see in your application how you can just put in some arbitrary parameters, sign it, and then pass it off to some other user. So now we're going to switch back to the account who the order was created for, have them paste it in, going to hit fill and confirm that we want to make this trade and submit it to the blockchain.
00:12:15.390 - 00:13:29.130, Speaker A: So you might notice a couple other things too. Like, for example, I'm putting in a token symbol here, right? Like, I put in WETH and I put in die. And for the amounts, I put in like human readable amounts, I said like 0.1 and one. But as you know, on the ethereum level, at the EVM level, we always need to work with atomic amounts and we always need to work with token addresses, not like these human friendly symbols and whatnot. And so sometimes if you've worked with Web Three, you know that those are the painful, annoying parts and we have helpers and libraries that will do all that for you. So let's take a look at the code that was facilitating that, right? So this one can help you a lot when you're working with token amounts.
00:13:29.130 - 00:14:25.854, Speaker A: This is on the token metadata class. It's going to format the atomic value, which is like that really long decimal value that you're concerned with when you're submitting to the contract. And so you put in a human readable value and it'll always give you back the correct value for that token specifically, as well as the conversions from it's really useful to work with symbols a lot of the time instead of addresses when you're in your code. So here we get this tokens by symbol from our metadata class and then we literally just say WETH. And then here it has all of the tokens properties, right? So we want the address when we're working with the protocol. But down here in the Dom, we might want the image AirSwap image URL, or maybe the symbol or some other thing for our UI. So that is what I had prepared at this point.
00:14:25.854 - 00:15:31.186, Speaker A: I'll open up the floor for any questions and yeah, thank you. All right, happy hacking, guys. I'm glad that you asked that. So one thing that I think would be a really good use case would be something that I kind of referenced in the talk, which is like an NFT Trading marketplace. So with the new version of the swap contract that was deployed, you can trade ERC 720 Ones as well as ERC 20s through AirSwap. So specifically, ENS just did the big upgrade to the new ENS system. And what that means is that as part of that, all of the names are now ERC 720 Ones natively.
00:15:31.186 - 00:16:28.810, Speaker A: So you could create like a really cool marketplace for people to swap around their ERC 720 Ones, trade them for Dai, sell subdomains, things like that. So that would be one cool use case, of course, too. Anything that involves trading is going to fit really well with AirSwap, like more traditional Arbitrage bots. That's one thing that AirSwap is really good for because you can request very large amounts, specifically of stablecoins and things on AirSwap. Makers keep really large reserves of them because they don't have to lock them all up on chain or in an order book. And so at any given time, you can get really large lots of dai, which could facilitate some cool Arbitrage bots and things like that. All right, so before I finish, I'll just leave you with some resources for the weekend.
00:16:28.810 - 00:17:35.540, Speaker A: This is the NPM package just published today. This is our developer's repo developer's website rather. And this is a blog post that we just published today that has a bunch of helpful ideas, a couple that I just touched on our Gitter channel if you need help during the week, and a few other code snippets to get you started here. Any other questions? So in that video, are there all the other things? Because I think we can you can put this link in this card, please. Okay, I will do that. Yeah. This medium post or if you just go to Developers AirSwap IO, that's probably going to be the best place for you.
00:17:35.540 - 00:17:51.560, Speaker A: It has a little joining us for ETH New York. Learn more. So, yeah, through here and clicking this, which takes you to the blog, will give you everything that you need. Got it. Thanks, guys.
