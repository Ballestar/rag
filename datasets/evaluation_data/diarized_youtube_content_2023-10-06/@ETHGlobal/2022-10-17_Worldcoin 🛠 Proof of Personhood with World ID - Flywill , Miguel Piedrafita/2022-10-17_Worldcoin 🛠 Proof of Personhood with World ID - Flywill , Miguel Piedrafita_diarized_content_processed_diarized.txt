00:00:08.650 - 00:01:07.938, Speaker A: I am Miguel and this is Flywheel and we are here to talk to you about wallcoin and wallad and basically how to make any app fully civil assistant within a few minutes and without while keeping everyone's private. So before that, I want to talk a little bit about why we're doing this. And the reason why we believe that this is a really big deal is because I feel like everyone here can agree crypto is really, really awesome. But at the same time, it has a bunch of problems, which is mostly with its value being hoarded a little bit. We all know about being early. And the thing is, especially for things like Ladam that are now joining more and more in crypto and where it's clear that it can solve really big problems, most of the value for things like ethereum or Bitcoin has already been captured by the people that were there at first, and that is not great. And that can hinder a little bit on the innovation that we can all achieve with this.
00:01:07.938 - 00:02:20.838, Speaker A: And so at Walt Queen, we had this question, like, what if Bitcoin had started instead of by? However, it got started by just giving one Bitcoin to every human in the world and then seeing how the network effects played out, how having a currency that was fully globally available was still being modern and online and cryptocurrency played out. And so we wanted to find this out. Obviously, we cannot buy a Bitcoin for every human, I wish. But instead we said, okay, let's make an ERC 20 token and let's do the same experiment with it. Let's make a token that every person gets for free and then we'll see how that affects the supply, let's see how that enables new people to interact with all of these ecosystems that we're building. And the big question there obviously was if we're going to be giving this token that is worth something and we're going to be giving out for free, a lot of people are going to be trying to get it for free multiple times and just like steal from everyone, really. And so this question, we went back and forth, we learned about this thing called Civil Attacks, which is pretty modern concept nowadays because all of these NFT means and Airdrops are suffering from it.
00:02:20.838 - 00:03:01.094, Speaker A: It basically means that some of your users are not really unique users, they're just like someone running a bunch of accounts. And this is really what we want to avoid. We want to make our protocol and every other protocol out there while we're at it, civil assistance. And so we went back and forth into different solutions that we could use for this. Maybe we could ask for an email or a phone, which is better than nothing, but kind of similar to what Gitcoin is doing, but still not enough. KYC can work, but there's some areas of the world that don't have ID documents or don't have a database to check them against. And also from a privacy standpoint it's really bad because we would have to get everyone's IDs and we really don't want that.
00:03:01.094 - 00:03:57.750, Speaker A: There's other approaches like web of trust where you are saying I trust these people around me and then that progates that has the issue of you need an initial set of people to trust and then over time, if you know a lot of people, it's easier and easier to fake another human. We looked into biometrics, like using your fingerprint and using your DNA which both work, except for the fingerprint doesn't really have enough information for 8 billion humans. There are going to be some people that have similar enough fingerprints so that we cannot tell them apart. And DNA has the opposite problem. It is really really unique, but it's super expensive and super slow to measure and also very invasive. And so we wanted a solution that was both private, inclusive, meaning that we could onboard every human in the world, all 8 billion humans, into the system. And that again was scalable and didn't leave anyone behind.
00:03:57.750 - 00:04:43.158, Speaker A: And so we ended up setting with Irises which are like the perfect middle point between fingerprints and DNA. They're still unique, they are pretty hard to change and even then you can most of the times detect it and at the same time they are really quick to scan, measure and use. And so this is great using the system. We had a system where we were taking no images. We do take an image of the iris, but then we delete it and just extract information from there no name, no contact info, no KYC, no phone number really. There's no link between this hash of an iris really and anything in the real world. But for us it felt like it wasn't enough.
00:04:43.158 - 00:05:17.790, Speaker A: We wanted something more. We wanted something that would allow us to really not just be private, but be fully anonymous. And so we started looking into serial edge proofs. And how aside from saying this is a human that owns a public key that has been certified by an orb as human, we could also say this is just like one of those humans. And we have no idea. There's no way to even link them to the hash of their scan. And we ended up with this system which allowed us to prove cryptographically on chain.
00:05:17.790 - 00:06:05.502, Speaker A: I am a real person and I have never done something. At the start that something was mostly claimed coin. But as more developers came to us and said we want to reuse this technology that you guys have made on our own apps, we started thinking maybe we can expand this so that this can be added to everyone, to governance, NFTs, Airdrops, even web. Two actions like joining a discord channel which will help a lot with spam. And so we created this thing called Wallid, which is a protocol that lets you fully anonymously verify that someone is a real human being and that has never done an action before, like claiming wallcoin. And so it's a privacy first decentralized entity solution. It's not even identity in the sense that it is fully anonymous per app.
00:06:05.502 - 00:06:48.080, Speaker A: So if I use my wallet ID on two different apps, these two different apps will get completely different IDs of who I am, which doesn't makes it so that you cannot even track people along us. It enables anonymous proof of personhood, which can pretty much search for every use case that civil assistance would use. And it's also an open protocol that runs on the blockchain on publicly verified smart contracts and where you get to keep your own keys. And so, for example, if you were just making an AirDrop to integrate this, you just need to add a widget which we'll talk a little bit more about and that's it. You're set it's really that easy. So now Flywell is going to talk a little bit about how it works.
00:06:52.550 - 00:07:07.650, Speaker B: Thank you. I'll switch computers over there.
00:07:10.420 - 00:08:21.652, Speaker C: All right, so here's roughly how the world ID protocol works. So you go to an ORV physically one of these guys and the ORV will verify you're a unique person and you get your world ID. So in the background, what actually is happening is your WorldCoin app is going to generate a unique random identity commitment that's going to live in your phone and it's going to show the public part to the ORV. The ORV is going to do the verification that you're a unique person and then add that identity to the public list on chain of verified identities. The cool thing about these zero knowledge proofs is that there's literally no link between your identity and your wallet or your identity. And anytime that you use use it, every time that you use it, the WorldCoin app will generate a zero knowledge proof that you're someone in that set of verified persons, but without revealing who you are. And the protocol is very complex to support for this anonymous proof of personhood.
00:08:21.652 - 00:09:22.716, Speaker C: But we've abstracted all of this complexity so you can integrate quite easily. So the way it will work is you install the widget in your app, the widget will connect to the WorldCoin app, receive that zero knowledge proof, and then you can verify it on our smart contract or on our API. After you verify it, you know for a fact that that person has been verified by an ORV and it's an actual person. And then I'm going to show you how to integrate it using the API, which is the fastest route to integrate. However, if you want to do something on chain, we definitely recommend doing on the smart contract side. We'll also show that in a little bit. So let's say I have this example of I want to issue POAP, but I want to make sure that the POAP can only be claimed once by a single person.
00:09:22.716 - 00:09:41.664, Speaker C: So I have this very simple form where I can click claim POAP and I receive the POAP in my wallet. This of course is very easy to farm and spam and and steal all the PO apps. So we can simply add World ID to prevent that.
00:09:41.862 - 00:09:44.550, Speaker B: And let me get my app here.
00:09:51.770 - 00:10:29.970, Speaker C: So to do this, we simply need to add the WorldCoin widget. So you can easily install it by just running yarn WorldCoin ID. This will install the widget on your project. You can now just simply load the widget. If you're using Next JS, this is an important part. You need to do this dynamic import as I'm doing, because the widget relies on window being set. So if you don't do this, you'll get an error.
00:10:29.970 - 00:10:33.140, Speaker C: And then just remember to do the dynamic import.
00:10:37.570 - 00:10:54.050, Speaker B: Thank you, copilot all right, there we go. So I have the widget imported. We can then mount the widget.
00:10:57.130 - 00:11:18.610, Speaker C: You're going to need to provide a couple of things to the widget. So one is the action. ID. The Action ID basically defines the scope of the uniqueness for your own application. So you can just go to developer Worldcoin.org and you can create any number of Action IDs there. It'll ask you if you want to create something on production or staging.
00:11:18.610 - 00:12:02.278, Speaker C: And it'll ask you if you want to run it on chain or just with the API. And then you'll also need something called signal. So the signal is an additional security measure that you can add. And it depends on what your application is, what makes sense to do. So, for instance, if you're doing an AirDrop and you don't set a signal, what I can do is man in the middle attack that claiming process where I get the serial knowledge proof from the user. And then I change to my wallet address to receive the AirDrop that would have belonged to the other person. If you add the signal, the signal becomes part of the proof.
00:12:02.278 - 00:12:21.700, Speaker C: So if I tamper with it, then the proof will become invalid. So depending on your use case, it might make sense to use different types of signals. But then something like this, in this case, the signal can be the wallet address or it can be something else.
00:12:22.390 - 00:13:02.200, Speaker B: And then we're also going to need the Action ID. So just do all right, then we're going to need to receive the proof here. Just console log for now. All right, let's see if this works. Need to run the server.
00:13:06.210 - 00:13:38.022, Speaker C: All right, so now we have the widget mounted. Super easy to do. Just make sure to set the right params once the verification process happens, then I'll receive the proof in this method. And then here comes probably the most important part. What you need to do is verify that proof. The fact that you got the proof from the widget is no safety measure at all. It's obviously on the front end, very easy to spoof, very easy to change.
00:13:38.022 - 00:14:18.150, Speaker C: So what you want to do is grab that proof and verify it either on chain or with our API. But don't just assume that because you got the success method that this is going to work. And then to verify the proof is quite easy. So if you're doing the API, you're going to want to do this from your back end. Again, if you do it from the front end, it's quite easy to spoof. So make sure to call it from the back end. And you're simply going to want to do something like this where I call the API.
00:14:18.150 - 00:15:10.034, Speaker C: You don't have to remember the endpoint, of course, it's very well documented, so don't worry about it. And then either the API or the Smart contract is going to take five params to verify the proof. So first is going to be the action ID. The second thing, let's just send the action ID. Of course, if you don't send the exact same params, this is not going to work. So be sure to send the exact same params. Second of all, the signal both of those params are set by you and sent to the Widget.
00:15:10.034 - 00:15:11.960, Speaker C: So make sure to use the same ones.
00:15:12.490 - 00:15:17.270, Speaker B: Let's see what signal that we use here. Flywheel ETH.
00:15:19.790 - 00:15:55.358, Speaker C: And then the other three params are what comes from the response on the Widget. So if you see this verification response object, it actually has these three parameters merkel root, nullifier hash, and proof. And those are the additional three params that you need to send out. I'm just going to do it like this. And then if the response is successful, 200 code, you know the proof is valid. If the same person tries to verify again, then you'll get an error. Or of course, if the proof is invalid.
00:15:55.358 - 00:16:26.398, Speaker C: And just to add a little bit more to that. So the three params that we're sending, they have different purposes. The merkel root is used just to prove that you're part of the merkel tree where the identities are stored. The proof is just the zero knowledge proof. The interesting one to take a look at is the nullifier hash. The nullifier hash is basically the user ID. It's going to be unique for every person and every application.
00:16:26.398 - 00:16:59.580, Speaker C: So this is what ensures uniqueness. If the same person tries to verify for the same action ID again, you'll receive the same nullifier hash and you know that's the same person. Well, what's cool is this will always be different for every application. So if I use my world ID with this POAP app, then my nullifier hash will be different than if I use it to verify my lens profile. And now Miguel is going to show you how to integrate on the Smart contract side.
00:17:09.930 - 00:17:10.534, Speaker B: There we go.
00:17:10.572 - 00:17:43.628, Speaker A: It never goes in the right direction. The first time. Okay, so first of all, all of the stuff that we're saying here right now, it's probably way more better explained in the documentation. So any questions or any doubts or even like the endpoint ID or all of that is going to be there. But yeah, let's look at some code. Start easy. Let's say that we are like we've seen how to verify it on the API and the API behind the scenes.
00:17:43.628 - 00:18:11.108, Speaker A: What it's doing is calling on chain anyways. It's always verified on chain. The API is just a convenience measure for people that are not super familiar with Web three or people that are making applications like the pop one, where really adding an onchain component doesn't really make sense. But for most of the implementations of this, you'd probably want to use a smart contract. And so let me make the font size a little higher. Hopefully that's big enough. This is an example contract.
00:18:11.108 - 00:18:47.000, Speaker A: That what it's going to do is it's just going to AirDrop some tokens and don't get scared by all of the measure. All of the text here, most of this is just comment. This is one of our example star kits. And so the part that you need to look into is this claim function which receives four parameters. First is the address that is going to receive the proof. We do it this way instead of just defaulting to MSE sender in order to make it so that anyone can submit a transaction and so you can pay for gas for your users, which is really nice. And then the other three arguments are the ones that you got from the Widget, like Paolo demoed.
00:18:47.000 - 00:19:16.220, Speaker A: And so in here we're going to want to do three things to verify it. And then you can do whatever you want to finish your logic. First of all, we're going to check if the nullifier has that we are getting here is already on our list of people that have claimed this. So you'll see up here I have a mapping of the UN, which is the nullifier hash to a boolean. And this is going to be false by default. So we'll just get right through it. Like Paolo mentioned, this is a unique ID for this action and this person.
00:19:16.220 - 00:19:56.010, Speaker A: Meaning that if they do it again, you'll see later down here, we're just going to mark it as true. And this is like the dumbest solution for making sure that they cannot reuse. You can also do some interesting things with this. But the most common use case is just checking if it is included and after verifying making it included. And so afterwards what we're going to do is call the wall ID contract and just say in verify proof and we're passing the route that we received group ID, which is always one, then the signal of the proof. And for the API, the signal doesn't really matter. Usually it's on the smart contract side where it really, really does matter.
00:19:56.010 - 00:20:28.964, Speaker A: An example of where this would matter is let's say that I submit this proof. I'm not using the signal. Someone can just front run my transaction in the mempool, change the receiver and get all the tokens by themselves. And then I cannot verify again because I already went through by adding any number of parameters here on the signal. What I can ensure is if this parameter doesn't match the one that the user specified when they generated the proof, then the verification is going to fail. And then if someone were to tamper with our transaction, it's not going to get verified. And so yeah, you can add any number of parameters in here.
00:20:28.964 - 00:21:07.650, Speaker A: It's kind of like a way of checking that the parameters that the contract received are the ones that the user intended. And usually we just want to add any parameters that your function is going to receive in here. In this case we only have one, which is the address and then every other thing that we received. The action ID is important. We are getting that in the constructor here and you're just going to get the action ID like the string that Paulo showed, which is like wid underscored a bunch of letters and numbers. What we're doing here is encoding it and hashing it. This is required by the Smart Contract solution and if you're using one of our story kits it will be handled automatically for you.
00:21:07.650 - 00:22:12.244, Speaker A: And then finally this call, if the proof doesn't get verified for any reason, be it the user is not registered as a human or the signal has been changed or they haven't done this again, then this is going to fail. If that doesn't happen, then we're just going to mark it as true so that the next time that the same user calls, this function is going to revert right here and then we will proceed to do whatever we actually want to do. In this case, send them some tokens. A more advanced version of this would be we have this integration with Lens protocol where users can mark their accounts as humans and the implementation of that follows kind of the same pattern with one difference. As you can see, the first thing that we're doing is we're getting the profile ID, which instead of the address is the parameter that we care about. Here which profile we are verifying and then the three parameters we're going to verify the proof, passing the profile ID because that's the signal because that's the parameter that we care about. And then since this is really a unique Identifier, it just only for my app.
00:22:12.244 - 00:23:08.010, Speaker A: What I can say is if this user has already verified a profile, we can use that to unverify that profile before verifying a new one. To make sure that if I fuck up and verify the wrong profile or any point want to change the profile that I have verified, I still have that option without allowing me to verify multiple ones. So this is an example use case of how you can use the nullifier hash as some sort of anonymous action ID. So in this case instead of setting the nullifier hash to true, what I'm doing is I'm sending it to the profile ID and if that is different from zero, that is the default. What I'm going to do before is just unverify the other profile ID which in this case is just emitting an event because Lens takes care of accounting for this in this part. And finally let's look at how we would hook all of this up on the front end. So I have the front end for this here.
00:23:08.010 - 00:24:11.864, Speaker A: It has a bunch of models and stuff but the one that you care about is the verify model which is where we have the profile that we want to verify already and the only thing that we're going to do is run the wall ID widget. Our signal is going to be the profile ID and we're doing some sanitizing here to encode it as a uint which you sometimes have to do when you're not working with strings and then the action ID and everything is going to be just fine. Once this is successful we are just going to call set proof and then send it to another component. In this case we're going to use the Wagmereact library to write it to a contract. So we're calling the verify function on the contract that I just showed. We're only doing this though if we have a profile and we have a proof. So until we actually go through with the verification this is not going to trigger and then once it does we are sending all of the same arguments that we saw here before and then calling the method that should call the contract.
00:24:11.864 - 00:24:49.822, Speaker A: If it doesn't revert, it will go through, everyone is happy and we are verified. So yeah, just to recap a little bit, the system is quite complex but we've made it super, super easy to use. You can just drop in a few lines of JavaScript, integrate a wallet connect style JavaScript widget that acts in a similar way of a captcha and just allows the user to scan a QR code, get a zero noise. Proof that you can verify even either through an API or most commonly on chain. And get to know that that user has never done whatever action your app cares about.
00:24:49.876 - 00:24:50.480, Speaker B: Once.
00:24:52.370 - 00:25:37.102, Speaker A: On the upside, I didn't have time to hook it up to show my phone screen here. I thought enough shifting with the computers was enough. This is what it pops up on the wallcoin app where it will just show the name of the app and say the app wants to verify that you haven't done this specific thing before and it will tell you what that specific thing is. And then when you click verify it's where it sends the proof to the website again, the code is really, really simple. Verifying the proof with the API takes probably a minute. Doing it on the Smart contract takes a little bit more. But we've been working really hard to provide lots of examples and start kits and pretty much anything that you would need to have fully commented code that you can just take the example that I showed that start with the AirDrop change.
00:25:37.102 - 00:26:19.950, Speaker A: The thing that is in the end and in most of the cases, you're going to be fine. And yeah, the really cool thing is we have civil assistance now and it is super, super flexible. It's not just protecting airdrops. There's a lot of things that you can do, especially with governance and voting quadrant funding, things like Wallcoin. There's been a lot of talk about solvent NFTs, which are solvent to your wallet, which isn't ideal because then you lose your wallet and you're fucked. Something like the thing that I showed for the lens profiles could be used to bound NFTs to a Wall ID profile, instead making it so that if you lose your wallet or if at any point you want to transfer them, you can still transfer them as long as you can generate proofs with your wall ID. And there's a lot of other really cool use cases.
00:26:19.950 - 00:27:14.762, Speaker A: All of the links that we have mentioned are in the documentation, including the explanation of how this works, links to probably not this talk because it will not be out there, but all the similar talks that we've done in the past. Documentation, guides, testnet simulator so that you don't have to go to the Orb to try your app. You can just use a faucet that will give you unlimited entities to test with on testnet examples and much, much more. So yeah, you can just go to ID walcoin.org and we'll also be doing the entire hackathon both on the Wallcoin Discord, which you can access at Discord Ggwalcoin and at the Ifgoval Discord on the Sponsors channel. Yeah, we wanted to give a little shout out at these three projects, semaphore, Hubble and Wallet Connect, which are kind of like the projects that are allowing us to do all the things that we're doing here. Most if not all of these projects.
00:27:14.762 - 00:27:45.482, Speaker A: Actually, all of these projects are open source. I'm sure everyone is familiar with. Walletconnect Hubble is an old project by the Ethereum Foundation and Semaphore is also an open source project by some really cool people. And those are the things that really enable all of the stuff that we're doing here. And yeah, we got started with this around E Amsterdam, so pre loss of this year. And we've been working into making more apps like the lens integration. We're working with Gitcoin Passport to get integrated there as well, and many others.
00:27:45.482 - 00:28:28.318, Speaker A: And we are hoping to release this MultiChain right now it's mostly on polygon, but will be multi chain hopefully by early 2023. And, yeah, I personally think it's a really exciting solution. I've made a bunch of things that sound super hard, but really just take a few lines of code like a contract that will receive any tokens and split it through every human on Earth, or at least every human that has registered and things that before you could just not think of how to do. And, yeah, I'm really, really looking forward to see what everyone else makes. Yeah. If you have any questions, our booth is upstairs on the left. First one that you see and we'll be here all weekend.
00:28:28.318 - 00:28:41.110, Speaker A: You have discord? I have papa hair. Pretty easy to spot. Yeah. Thank you for listening. Hope you have funny.
