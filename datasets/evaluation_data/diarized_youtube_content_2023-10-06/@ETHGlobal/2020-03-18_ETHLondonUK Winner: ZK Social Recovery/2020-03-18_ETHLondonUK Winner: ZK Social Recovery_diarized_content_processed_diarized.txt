00:00:00.170 - 00:00:26.950, Speaker A: So yeah, we're the ZK social recovery team. We're kind of going through a rebrand exercise at the moment. So some people also know us as secret guardians. Anyway, so I'm Tom, I work at Aztec. By day they're somewhere sat over in the corner, I think. And then guys, do you want to introduce yourselves? Makoto from ENS and Kickback and I'm Janice and I work with smart contract wallets mainly. So we combined everything.
00:00:26.950 - 00:00:56.666, Speaker A: Yeah, exactly. So we came with a problem statement. So smart contracts these days, smart contract wallets these days so you can think of things like monolith. Argent increasingly have this feature where you can nominate guardians. And these guardians basically if you lose your private key or you lose your access to your smart contract wallet, these guardians can restore you access to your wallet. So they're in quite a privileged position. But talking things through, we quite quickly realized that these guardian addresses are stored in public on chain.
00:00:56.666 - 00:01:28.694, Speaker A: And so anybody on chain can see who your guardian address is. We think that's both a privacy concern and a security concern. So we set out to try and fix this. So to do this, we basically rely on zero knowledge technology. So we've built a yannis has built a proof of concept smart contract wallet and then I've integrated some zero knowledge stuff into it. And Makoto has put together helped draft this front end along with we're using a tool called Sol UI by Ram, which is really, really useful. So check it out anyway.
00:01:28.694 - 00:02:17.206, Speaker A: So how does this work? So normally in a smart contract wallet, your guardian address is stored on chain in public. Now instead of doing that, we take a hash of this. And when you add a guardian to your wallet, you store the hash of the address of the guardian on chain, which means nobody else can work out what this maps to. And then fundamentally when a user is trying to get access back to their wallet, a guardian has to generate a zero knowledge proof that they know the pre image to this hash. Now the only way that they're going to be able to have this proof satisfied is if they do in fact know the pre image to this hash. Which means that they are a valid guardian. So if we take you through what this looks like step by step so the first thing we're going to do is we use Socrates to build some of the ZK snark stuff that we need.
00:02:17.206 - 00:02:53.794, Speaker A: Specifically we're using a snark called Gruff 16. So first of all, when you're using these sort of things, you have to do various steps and you're going to see some like Matrix s stuff going on. So there's various steps going on here. When you're using ZK snarks you have to do a trusted setup where you're basically creating some toxic waste. And some of the crypto points that are used in this, we're creating a proof here we're computing some secret information and also generating various keys. You'll see, at some point a proof is going to get output from this. It looks like, I think there's three elliptic curve points and you can see here at the bottom.
00:02:53.794 - 00:03:25.454, Speaker A: So we get a proof out. So that's going to be our Guardian's proof eventually that they know the pre image to the hash that is stored on chain. So that's the local proof side of things. Now, this would happen on the client locally, ideally in the browser, if you can get this working in the browser. So the next thing we built was ZK Social Recovery is in the app. So this is connected to Rinkby and it allows you to deploy one of these ZK wallets, as we call them. So click execute, MetaMask pops up, all standard stuff.
00:03:25.454 - 00:04:03.654, Speaker A: So this is going to, first of all deploy the wallet. It's then going to deploy the associated verification contract. So when a Guardian calls recover on the ZK wallet, the method is going to static call out to a proof verification contract and it sends the proof to this this verifies that the ZK snout proof is correct. And if so, the normal mechanics can continue. So we're on Rinkby, so this might take 30 seconds, something like that. But basically, once you've deployed this wallet, you can then interact with it. You can get state, I think MetaMask is requesting my signature.
00:04:03.654 - 00:04:25.662, Speaker A: So it's also deploying the proof validator. So it wants two signatures. And then you can do various things you can send just as a normal wallet. And then we have to set our proof validator. We have to link these two contracts together. This will ideally be abstracted away in a future version. You can add a Guardian by adding this hashed address that we talked about.
00:04:25.662 - 00:04:46.900, Speaker A: It has to be split into two segments at the moment, some technical details. And then eventually, once you're working through this flow, you can then call a ZK Recover where you pass in some of those proof variables that you saw on the iterm terminal anyway. So that's ZK recovery. It's on GitHub. Feel free to check it out. And yeah, thank you for everything. It's been great.
