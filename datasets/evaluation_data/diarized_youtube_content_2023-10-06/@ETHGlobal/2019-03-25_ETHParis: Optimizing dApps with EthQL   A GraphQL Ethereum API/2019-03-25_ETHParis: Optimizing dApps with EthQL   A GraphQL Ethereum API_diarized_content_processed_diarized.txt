00:00:03.440 - 00:00:05.920, Speaker A: Hey everyone. My name is Michael.
00:00:06.000 - 00:00:06.816, Speaker B: This is Chris.
00:00:06.928 - 00:01:14.890, Speaker A: Maybe I'll we're from infura Today we're going to be talking about optimizing your DApps using something we're working on called Ethql. So just about infuria quick background maybe probably have heard about us, but we were founded a couple of years ago, almost originally as just a project inside of Consensus, meant to deliver infrastructure for other projects inside Consensus and quickly saw the demand from the entire ecosystem to leverage our infrastructure to really simplify that component of their DAP development. So our mission all along was really just to simplify and enrich the developer experience. So for three years we've been just providing easy, scalable and reliable access to the Ethereum data. And we also have done our very best to support in the ecosystem projects that make running full infrastructure, full node infrastructure on Ethereum easier. Things like VIP node. We've been a financial sponsor for that project, big fans of that project.
00:01:14.890 - 00:02:03.636, Speaker A: Alexei Akanov's work on Turbogeth is another example that we've sponsored and helped as far as eliminating some of the requirements it takes to run a full node. I know there's a lot of misinformation people claiming that running Ethereum node is so difficult that only if Infuria knows how to do it. Not really true at all. But at the same time, it is actually pretty hard for a non tech person to really know how to run a node. So we work to address that as well. So if you look at the evolution of Ethereum, so on the client side, it went from one client to many clients as far as developing, you go from the EVM assembly into more rich languages for facilitating that serpent. Solidity Viper started with absolutely no frameworks.
00:02:03.636 - 00:02:33.750, Speaker A: You were just kind of like on your own back in the day. Now we have Truffle, Embark, Parisol, other things out there that make kind of that whole development cycle much easier. But then as far as accessing data from the blockchain, we started with JSON RPC and that's kind of still what we have. So if you've developed a DAP or you've worked on trying to pull data from a blockchain, you know how painful it can be sometimes to get data from the blockchain using JSON RPC. So that leads us to Ethql, which is what Chris is going to take from here and explain about.
00:02:35.160 - 00:03:25.620, Speaker B: Thank you. So let's talk about JSON RPC. JSON RPC was developed to give you access into the node, right? To send transactions to pull data off of the chain. It's not really designed as an efficient querying mechanism or efficient querying API. The JSON RPC interface, like a lot of resource based interface, suffers from overfetching and underfetching problems, right? It lacks support for things like explicit data relationships, hierarchy. If you're just getting into the ecosystem and trying to create adapt, you have to read the yellow paper to figure out what all these data types are. How they relate, then you have to refer back to the JSON RPC wiki or some documentation to figure out how to access it.
00:03:25.620 - 00:04:07.570, Speaker B: It's not a great developer experience. The simplicity of the JSON RPC is great, but it also does not really support a developer ecosystem. Doesn't give you a lot of great tools, doesn't give you a way to describe the SCM at all. So there's a lot of things lacking within the developer experience. So essentially Ethereum Data is a graph, right? I would posit that any nontrivial data that you're going to have in an application is a graph, right? You have different data types or different documents. You have relationships between those documents. What I'm showing in this slide is a simplified view of Ethereum data.
00:04:07.570 - 00:05:00.764, Speaker B: Blocks, transactions, logs, accounts, they all exist as sort of different calls, different data types that have relationships, but they're only sort of implied via hash references when you pull a block or you pull a transaction. And this kind of relationship is not easily captured in a resource based API. It comes down to that. Getting useful data off the blockchain is hard, right? If you want to pull a block, you want to scan headers. That's pretty easy to do. But when you try to start getting into application level, querying things that are even as simple as this, get only transactions related to my contracts, list addresses that had sent transactions in the last block, show all token transfers, et cetera, et cetera. This stuff is not easy to pull off in JSON RPC, right? Usually requires multiple calls.
00:05:00.764 - 00:05:35.576, Speaker B: You have to aggregate that data, have to filter it down, and then you can display it to your user. So that's when we started thinking about GraphQL as an interface into Ethereum. So ethereum plus GraphQL is what we're calling Ethql. It's a little bit of background into GraphQL. GraphQL natively views its data as a graph. So it's all about relationships. It's all about being able to traverse the data in a very easy way.
00:05:35.576 - 00:06:20.200, Speaker B: It's been in use in Facebook since 2012. They open sourced it in 2015. And essentially what they were trying to do is figure out how to hyper optimize mobile clients, right? If you're talking about a Rest interface or something that's resource based for something like Facebook, you have to grab do a call for user data, then a call for say, newsfeed data, then a call for this data and that data and compile it all in. So they created GraphQL as a way to optimize this experience. It's a single self describing endpoint. So it doesn't have that hierarchy of sort of rest paths that you have to memorize in a rest world. It's self describing, so you don't have to have an overlay on it like JSON schema or Swagger.
00:06:20.200 - 00:06:49.776, Speaker B: And here's where it gets really interesting, is that really flips the script on who's presenting the data or who's in control of the data. Control is not a great word. But if I'm developing a server, if I'm developing a Rust interface, I have the data in my database and I'm saying, okay, here's a resource. Here's all the fields in that resource. I'm going to give it to you because I don't know exactly what you're going to need, but you'll probably need something in this data. So I'm going to give you everything. And then I define other resources that relate to it.
00:06:49.776 - 00:07:41.248, Speaker B: Right, but the server is control of how the data is displayed with GraphQL, they flip the script and say the client is in control of the data. Right? So rather than the server giving you just blatant document of fields that you don't need, the client specifically asks for, okay, I'm interested in a block, and I just want the number in the hash of that block just because I want to see where we're at. The server will only send that information. It solves a lot of problems with Rest, not only the overfetching, under, fetching problem that I just was talking about, but also data relationships. Versioning deprecation Paging Extensibility, which is a big one. Extensibility is a big one that Ethql gives to an API interface. And my favorite is that it's strongly typed and it provides query validation out of the box.
00:07:41.248 - 00:08:15.256, Speaker B: So you can easily build tools on it, you can easily query the schema and know exactly what you can ask for and exactly what you can receive. So why would we want to use Esql? So it finally presents data as an applicable graph. It integrates with a lot of powerful front end libraries that you might want to use. Apollo client maybe relay things like this. It fetches exactly the data you need, and no more, no less in a single call, which is important. I'll dig into that later. We reduce round trips to the server.
00:08:15.256 - 00:09:06.216, Speaker B: So we were improving the user experience by reducing bandwidth, by reducing wait times, by reducing rendering times, and that allows the developers to build on a modern tool set using an Extensible API. It really eliminates the need for DApp developers to use JSON RPC. So Ethql has been developing pretty rapidly. There's a lot going on in this space. It started as a sidecar server to originally start bringing GraphQL to Ethereum. A few people, Raul Kripalani, who started the original server, plus Nick Johnson, were working on parallel tracks to bring GraphQL. We eventually found each other, and we've now started to formalize it into an EIP.
00:09:06.216 - 00:09:25.776, Speaker B: So that's now up. EIP 1767 is up. It's still open for comment. If you're interested in it, please check it out. But comments use cases open to dialogue. There's a POC implementation of it currently in Gethmaster, so if you wanted to play around with it in Geth, you can clone master. Compile.
00:09:25.776 - 00:10:37.432, Speaker B: The server GraphQL enables the GraphQL interface, and you can play with a node. And the standard version is focused on providing a simple yet powerful JSON RPC equivalent. On the other side of things, the server that Raul Kripalani started is still being developed, and it's more focused as an overlay. On top of the standard spec, we're really focused on application level features, things, a pluggable backend where you can create a plugin for your own abi custom contracts, and it handles a lot of the decoding and encoding for you. Flexible deployment Model as a server sidecar, the kind of features that the Ethql Extended project has is flexible block selection, single block, list of blocks, range of blocks, navigating through blocks to transactions, to accounts. We're currently built on Web Three, but we've optimized it through smart caching data loader batching. We have transaction filters, so you can say, okay, give me all the transactions in this block that only have logs or that only have input data, that kind of a thing.
00:10:37.432 - 00:11:15.412, Speaker B: We provide X rays into transaction logs. So rather than getting back the raw hex data, you're getting back something that actually is decoded and is actually meaningful to display to a user. We currently support ERC 20. We support ENS address resolution, and you can traverse storage maps, arrays of maps, maps of maps, et cetera. So getting started is easy. If you wanted to try hacking on this weekend, there's three ways this is really going around the Ethql Extended server. So you can go to our repo, clone it.
00:11:15.412 - 00:11:48.444, Speaker B: If you're running your own node, you basically start it with your own flag J, and then whatever your node's JSON RPC interface is. And then you can go to the local host, the local host link. Easier than that. If you sign up for Infura, you can use your Infuria account download or clone the repo, use your Infuria ID, start the server, go to the Localhost 4000. The easiest is that we have set up a URL for you already. So you could just go to that bottom link. It'll.
00:11:48.444 - 00:12:17.170, Speaker B: Pull up the graph. IQL interface. So you could start playing around, experimenting with queries yourself. If you're building something, you can use that as the URL, your GraphQL client URL as well. So let's talk efficiency gains. We did some testing early on in the project to see how it would compare. So essentially we pulled five blocks from the chain.
00:12:17.170 - 00:13:20.150, Speaker B: We're fetching the block hash and the sending address of each of the transactions, the value, and for each of the senders, we're getting their current balance. So on the left side, that's what a GraphQL query for this data looks like. We're selecting a range of blocks hash transactions, the account information and value, right? So you can already see if for those of you who are new to GraphQL, it's a bit strange as a query language, but the data types are nested in here, right? So you have blocks transactions nested in blocks, accounts nested in transactions. So you can already see a query tree getting formed of that original diagram that I showed before. This is the query tree that's getting selected. So if you were to do this over JSON RPC, it essentially amounts to a little over 1800 requests. So there's three or 400 transactions in each of these blocks.
00:13:20.150 - 00:13:47.200, Speaker B: We're pulling five blocks in all of the transactions, plus a Get account for each of those transactions. Right. So that's 1800. The sum of all the data coming back is a little bit over a meg. With EQL, it's a single call and 218k. So it's an 81% reduction in the amount of data sent over the wire. All right, I'm going to try to demo this.
00:13:47.200 - 00:14:28.222, Speaker B: All right, so this is the graph IQL interface. For those of you who haven't played around with GraphQL before, this is the link that I was showing on the other slide. So if we wanted to get a block, say the latest block, and we just wanted to see what the number was. All right, I'm just going to try to peg it to this number really quick. See how many transactions. 74. Okay.
00:14:28.222 - 00:14:58.394, Speaker B: So you can kind of see already the kind of tool set that you can have with GraphQL auto filling based on the schema. It's an introspective schema. So you can basically pull anything back. Give me a second. So you can pull back the information regarding the structure of the API and you can get these things like autofill or let's say that you don't know what you can query on. There's documentation built on the site. Right.
00:14:58.394 - 00:15:31.874, Speaker B: So we're doing a block, we're looking for transactions, and then you can kind of drill into the documentation. I'll just close this out a little bit. All right, so here we see we're pulling back all the transactions, all the indexing. Maybe I just want to see the ones that have logs with logs. True. All right, so now we're starting to filter out the transactions that are coming back to only the ones that we care about. Let's say we want to see what the decoded transaction looks like.
00:15:31.874 - 00:16:04.782, Speaker B: Right. Operation. So with this, I'm decoding ERC 20 transactions. I can see what operation ERC 20 transfer. So the decoding of the ERC 20 is happening in the extended layer. The way that I like to think about it is that the standard layer is optimizing your querying from the node perspective. Right.
00:16:04.782 - 00:17:09.400, Speaker B: It's remapping a more efficient interface onto the node itself. The ethql extended is a sidecar that you can attach to the node either through an RPC interface or the IPC interface. And all of the logic for the decoding is happening there. And what that gives you, since it's built on a plugin architecture, that gives you the ability to add standards like ERC 20, your own contracts, if you wanted to add within geth the idea of indexing is more than I think a node should handle. The indexing layer is going to happen, probably off chain or off the client itself and into something like the Ethql. Extended server indexing is something that we actually have on our roadmap to build into the extended project. Yeah, cool.
00:17:09.400 - 00:17:31.790, Speaker B: That would be great. If you wanted to write like an Ethql extension for that and package it in with the rest of the node. You could write a plugin that would use any arbitrary indexing. It could use your own data. It could use something from another service. That's definitely possible. Token contract.
00:17:31.790 - 00:18:32.690, Speaker B: So with just those few lines of code, I'm able to pull back not the latest block anymore, but this block number. And then information about all of the ERC, 20 tokens that have been traded or transferred. Let me go back here. Thanks. So, kind of to extend on the demo a little bit, I have an example app that I built for if you go to a repo, which I'll show you, at the end, there's a really simple react based app that I did, plus an example and node of how to query GraphQL. So this is a simple DAP and basically just scans the latest block for, ERC, 20 transfers. It aggregates it based on the symbol and then sorts it descending right.
00:18:32.690 - 00:19:14.390, Speaker B: Largest value transfers top to the smallest transfers on the bottom. And this is basically the code that does it. There's not a whole lot of code to it. Again, on the left side, sort of what I just demoed, this is the query. And on the right side, for those of you that build in react, that's really all you need to connect the data source to your application. So I'm using Apollo client. You have an Apollo component query component where you're inserting the query, you can tell it to poll so all of the polling is handled for you and basically once it returns, it shoves all the data back into your components.
00:19:14.390 - 00:20:19.618, Speaker B: So really quickly you can start building data centric components, connect them into these higher level queries and the data just sort of resolves and propagates down the component tree. So what's coming next for the roadmap for the Ethql? For EQ in general. We're trying to finalize the 1767 spec so that we can start building on it, propagating it into other clients right now, like I said, the proof of concept is in Geth, but we're trying to get it into Parity and Pantheon and all of the rest of the clients as well. On the extended side, we want to add support for more standards, popular standards like 721 ERC 165. We have ENS address resolution support, but we also want to add decoding ability for ENS events. We want to make it so that's easy and flexible to deploy and embed into your applications. GraphQL subscriptions is something that's big.
00:20:19.618 - 00:21:17.318, Speaker B: It's not going to be part of the core specification, the core EIP, but we want to be able to add that as a layer on top. So opening an EIP for subscriptions which will make sort of all the filtered and subscriptions event subscriptions, things like that really simple to deal with and eliminate the need for polling. We want to add schema variants for Paging and also relay clients integration with indexing backends, two level cache and new filtering strategies, things that support the DAP developers. Because at the end of the day the Ethql project is made for DAP developers, for you guys to use it, break it, contribute to it, let us know what you think about it. We're on gitter. This is the repo again. Come say hi with a star, open a pull request comment and then here's some links for some more information.
00:21:17.318 - 00:22:16.468, Speaker B: So we set up some documentation docs if you wanted to learn more. We have an Ethql playground, the thing that I was just demoing with at the hack Ethql and Fiore IO and then Examples repo which has the example application I showed plus a node example at the bottom and that's it. Thank you very much. So the graph, it's interesting that you bring that up. So the graph is focused on event data solely and as far as I understand it, they're abstracting the chain away, right? Like they want to be not only for Ethereum, but for other chains as well. But they're solely focused on indexing event data. What Ethql does, it provides that and a complete replacement for JSON RPC.
00:22:16.468 - 00:24:07.304, Speaker B: So you can do things like get block block scans for transaction hashes or whatever your use case is. Additionally, what it provides is the call and send raw transaction functions, right, which the graph does not. So really Ethql is a complete meant is an Ethereum specific GraphQL interface. Yeah. So it's not necessarily a query planner, not a query planner per se, but we do use batching and caching. So the nice thing about GraphQL is because of the structure and because of the way that the spec is defined, every GraphQL query basically turns into a query tree, right? Yeah, that's correct currently, yes. So the nice part about sort of the indexing thing so right now it's a very simple interface, I would say, right.
00:24:07.304 - 00:27:07.910, Speaker B: It's basically a skin to be able to reduce the data and round trips. But since it has like a plugin architecture, basically you can start putting in more sophisticated indexing things that are more specific to your use cases. What we're trying to do is provide enough to make it useful but not so much that it's opinionated for people's particular use case and leave that open to the developers to be able to put specific things in. Yes, I think there's a little bit to unpack here I might need to dive into that more specifically statedef. I'm not sure. I mean, we do support it in a pretty simple way. Like we have the ability to decode storage so that you can at least see what's in there doing.
00:27:07.910 - 00:27:42.700, Speaker B: An actual state diff, like, built into the query language isn't yet supported. Yeah, cool. All right. That's a good question. I'd have to check on that. I think it's MIT, but I would have to check the license on it. Give me a second.
00:27:42.700 - 00:27:52.440, Speaker B: Yeah.
