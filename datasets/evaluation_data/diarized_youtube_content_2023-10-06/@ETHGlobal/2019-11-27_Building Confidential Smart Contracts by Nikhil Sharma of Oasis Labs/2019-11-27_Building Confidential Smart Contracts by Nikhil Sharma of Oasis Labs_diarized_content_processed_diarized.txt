00:00:10.120 - 00:01:00.664, Speaker A: All right, so we're going to go ahead and get started. So we are Awakening Slabs, and this workshop is to teach you about building confidential smart contracts on our Platform. So, just out of curiosity, by showing how many of you have heard of us before, so we're going to do two things. First, we're going to talk about why you should build it on our Platform, and then I'm going to actually show you how to. So, as I'm sure all of you know, there are quite a few data breaches that have been happening over the past couple of decades. And most recently, probably the equifax one is in most recent memory. And so all of these data breaches put personal information at risk, and that leads to a lot of mistrust of major corporations.
00:01:00.664 - 00:02:05.500, Speaker A: For example, a study that the Hopkins Pron about why users that quit Facebook decided to do so the leading reason was that they just no longer trust Facebook. Personally, I don't like them. So what does Oasis Labs do? It allows you to build applications that are decentralized and preserve a lot of or provide a lot of integrity guarantees, but also give strong privacy and security guarantees that work without having to trust any centralized third party. So how does this all work? Let's go into an overview of how our Platform actually functions. So, there are a lot of trust issues with both cloud infrastructure and applications that run on them. And as we discussed, that leads to undesirable data leaks. And the Oasis Platform uses smart contracts that are scalable due to our new approach to scalable consensus.
00:02:05.500 - 00:03:16.490, Speaker A: And all contract code is run within trusted execution environments, which gives confidentiality guarantees. And together, these two things enable us to do things like analytics and machine learning that are privacy preserved. So, smart contracts, by themselves, they enable replicated compute, which gives integrity guarantees on its own and has immutability in its distributed ledger. But these two things by themselves don't provide any kind of privacy guarantee. For that, you need secure enclaves for trusted execution environments. So what these are are they're essentially black boxes in memory on nodes within the Oasis network. And so even if you don't trust the nodes in the network, the nodes actually don't see anything that any of your personal data.
00:03:16.490 - 00:04:39.136, Speaker A: The smart contract code and encrypted sensitive data is loaded into this black box. Computation is run, and the results are encrypted and fit out as output that only parties that have access can see. So how does all of this tie together and allow you to develop on Platform? So, we have a new Oasis SDK that we just released that includes a CLI that makes building things really easy, a gateway for executing transactions, and some new Rust libraries that make doing a lot of blockchain specific things completely abstract away. This also comes with a new WASM runtime, which is useful for compiling and running your programs within secure enclave. And we also have a developer dashboard that serves as a portal where you can deploy your smart contracts and monitor their activity. So this is a diagram of how everything ties together. So we have our CLI, which lets you initialize projects, build them, and also then you can deploy them on our dashboard where you can track them.
00:04:39.136 - 00:05:45.664, Speaker A: And once these services are these contracts are deployed, you can interact with them via the Oasis client, which is a JavaScript library that lets you do these transactions. And these transactions go through either our new Oasis gateway or link Sustained Web Three gateway and go to our network, where they are submitted to nodes that run these transactions within or run all compute within Insecure enclave using that was runtime. Okay, so let's go ahead and get into some specifics of how to do that. So I'm going to show you how to build and test a secret ballot, which is a voting application that has no centralized party managing the votes. So then we're going to run a local Oasis blockchain to which we'll deploy the service, and we're going to execute a few transactions through a front end application. Yes. Just back on the previous slide.
00:05:45.664 - 00:06:46.212, Speaker A: Those Oasis nodes are owned by you guys currently? Yes. Eventually, anybody will be able to be a front. Okay, and will you have a slide about the hardware requirements and all that as well? Don't have a slide about it, but we can talk about it after. Let's get right into how to actually do this. So this is an example of a Rust smart contract. So when you use our CLI to initialize an application, you can just use run command Oasis in it when you have our CLI downloaded, and it will make this directory structure where you have both an application layer and a service layer. So this service layer is really just a Rust package, and your actual smart contract code will go within this main Rs file.
00:06:46.212 - 00:08:27.550, Speaker A: So this is what that looks like. And within that main Rs, you want to do two things. You want to define the state that you want your smart contract to manage, and you also want to define RPCU to actually manipulate or read that state. So to define your state that you can do just with a standard Rust struct. So for a secret voting application, we want to manage the description of what the vote is for, the list of candidates to vote for, how many votes each candidate has, whether or not voting is open, who is the administrator of the vote and can do things like close the vote and a map of who has voted for what. And again, all of this information is going to be stored, encrypted and be private at all times, unless it's being manipulated within a secure and then you'll notice this annotation here that essentially is a trait that tells our platform or that enables this contract to have that state read from and updated in our platform storage. So actually updating that state that's done within this simple ballot where you have a constructor where you can initialize a ballot with a description and a list of candidates, you have some getters where you can get a list of candidates, the description and whether or not voting is still open.
00:08:27.550 - 00:09:10.010, Speaker A: And one thing you might notice that's there for all of these RPCs is this context tag. So for those of you that are familiar with Solidity, this is essentially the same as message. So message sender, you can do context sender. And all the things that message typically has in Solidity contract context will have empower. Then you can go ahead and do other functionality like voting. You'll notice that if voting is closed, it's not going to accept any votes. You try to vote for somebody that's not, the list of candidates won't let you so on.
00:09:10.010 - 00:10:17.384, Speaker A: You can try and close the ballot, but it'll return an error unless you are the one that created the ballot. And once voting is closed, you can read both the winner and also a list of the total tally for candidates. Yeah, and so we also another difference between writing standard Rust packages and our smart contract is this one macro. That this service macro. So all this does is when from our CLI we try to build this application, it'll tell you to that handles how this Rust code is compiled into a WASM binary that can then be read in our Insecure encrypt and work as expected. All right, so let's go ahead and try building that. So I'm in that same service directory and I can just go ahead and wait build that'll take a minute.
00:10:17.384 - 00:11:15.680, Speaker A: And so while that's happening, we're going to talk about testing. So you can write unit tests for these contracts before you actually deploy or do anything with them, just as you can do normally in Rust. You have this functionality to create an account using the Oasis test library. And so we can go ahead and generate, test, create a couple of accounts, one that's going to be for our admin and one that's going to be for a generic voter. Then initialize a ballot object that has this admin set as the admin. You can check that the description and candidates are what you expect them to be, check that voting is indeed open, and check that you cannot actually read the winner quite yet. And we simulate few votes.
00:11:15.680 - 00:12:05.650, Speaker A: So the generic voter first voted for item zero beef and then changed their vote to item one, yogurt. And then the admin decided to also vote for yogurt as their dinner option. Yeah, then a couple more checks to make sure that the admin can close voting, but generic voters can't to check to see that nobody can vote after voting is closed, and a few checks to ensure that the winner and results are what we expected to be. So yeah, so now that our ballot is prepared, we can run these test cases super simply with just a wait for test that'll take a couple of seconds. Do you have any questions?
00:12:11.380 - 00:12:16.868, Speaker B: Is all the transactions private by default so you don't have to do anything extra?
00:12:17.034 - 00:12:24.356, Speaker A: Yeah, when you deploy deployed confidentially by default, you can set a flag to.
00:12:24.378 - 00:12:37.530, Speaker B: Make it confidential to like when all the transactions are replicated on all the nodes, how do you prevent people just from reading the.
00:12:43.020 - 00:13:28.296, Speaker A: Yeah, so that's still a thing that we're working on solving. Anybody can still read the list of transactions, such as who executed what methods on which contract. But you can't see the actual state? No. So all that state is encrypted and sent over like a TLS. Okay, so as you can see, these test cases passed. If you try to mess with it and try to see if you can vote after the ballot is closed. Sorry, what is the argument that you were talking about? Is that the yogurt versus the other thing? Yeah, just whatever is they pass this argument to their transaction.
00:13:28.296 - 00:14:31.808, Speaker A: They can't see that they can just see that somebody coded. Yeah. Okay, now we have clearly broken the test, fixed it now and then let's move on to the actual application. So to run the application, I have some application code and to actually do that, we need to run a local blockchain for transactions to be made to and that you can do super simply with our command line. Also just run away chains. See, you get a bunch of different accounts and now you have this local chain running that's listening for transactions to come through. So how does the application actually work? So we have this secret ballot front end app that is written using view JS and pretty much all of it you can ignore as like front end specific stuff.
00:14:31.808 - 00:15:21.010, Speaker A: The only important stuff for actually interacting with our clients happens in this storage JS file, which in view is the mechanism for local state management. So what state do we want to track? So I just have which Pokemon is best starter, and a list of choices. We can have this valid object that is currently null, but when we deploy it with our client, it will be null. You have this bytecode that was generated. So when I ran away to build, that was actually placed in this target directory target service. And you have that. So this is now a link to that.
00:15:21.010 - 00:16:11.520, Speaker A: And this gateway refers to that locally running blockchain that you have. So when you try to connect to Oasis, this is an example using the web Three gateway. You can also do it with our Oasis developer gateway. But essentially you initialize a wallet object from using a mnemonic and you connect to that gateway. Then if you want to deploy a service you have to read in that WASM bytecode and call this Oasis deploy function from our client. And along with the bytecode, you also pass in constructor arguments. And if you want, you can pass in things like a gas limit and whether you want to be confidential or not, that's where you pass this in over here.
00:16:11.520 - 00:17:02.610, Speaker A: And to actually interact with your deployed service from our clients, it's super simple. Once you have that valid object instantiated after the deploy, you just call the methods directly along with any arguments that they might need. Now that actually should have you running on and you can see the vote running. So what's happening now is that it's deploying a service. Now that that service is deployed, this ID field comes up in the query parameters which is just application specific. But this ID is really just the address at which your smart contract is deployed. You need to identify it.
00:17:02.610 - 00:18:20.090, Speaker A: You can participate in Vote which uses the getters for getting the description of the canvas and enables you to vote for Pokemon. Charmander is my personal favorite, so I'm going to vote for him. Since I am the admin of the vote and I deployed it, I have this option to close the vote and now that I've closed it, I can view results which should show up. But you can see that Charmander has won. And if you go back to that place where I was running the local blockchain, all of these clicks executed transactions with that locally running chain via the client and you can parse them however you want. If any of the transactions didn't work, you'd see errors in certain info that's that demo application. No, it just deploys a new one each time you like, I just deploy it right now.
00:18:20.090 - 00:19:48.180, Speaker A: If you wanted to if you had an address that you beforehand you could have, it was just like connect to that. So if you if you since I did pass in the ID as a query parameter, it deployed service with a function. If you did, it would just load service using. So yeah, so going back to these, we have a bunch of resources to get started developing on our platform. So this tutorial that I just walked you through, along with the Kickstart guide dev, we also have a GitHub repo open source library and we have our developer Dashboard at Dashboard. Yeah. So anybody hopefully this incentivizes you to build smart contracts on the platform that you've seen how easy it is and whoever builds the best one during the hackathon, we have a $2,000 more flexible where you were able to see themselves everybody that voted.
00:19:48.180 - 00:20:13.260, Speaker A: Yeah. So everybody can see the tally of the book. Yeah, it's like super simple to change that too. That was just so I could show the cool graph. If you wanted to, you could just not have this result function and then you could only have this. We don't mind. It at midnight.
00:20:13.260 - 00:20:38.530, Speaker A: It's totally up to you. Right now it's configured so that anybody can see the vote. If you wanted to, you can make it. It yeah. Well, thank you. And we'll be around to help guide anybody else that needs help with.
