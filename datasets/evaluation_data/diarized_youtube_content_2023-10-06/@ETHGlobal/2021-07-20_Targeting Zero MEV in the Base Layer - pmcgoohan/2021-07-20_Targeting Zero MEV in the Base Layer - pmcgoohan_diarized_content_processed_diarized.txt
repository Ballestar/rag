00:00:00.650 - 00:00:19.670, Speaker A: Our guest, PMC Guhan. I'm sorry for butchering your name, but feel free to directly share screen. Can you unmute yourself?
00:00:37.560 - 00:00:39.830, Speaker B: It okay. Can you hear me now?
00:00:41.400 - 00:00:42.150, Speaker A: Yes.
00:00:42.600 - 00:00:45.670, Speaker B: Great. Can you see my presentation at all?
00:00:47.480 - 00:00:49.044, Speaker A: We cannot see it.
00:00:49.242 - 00:01:13.756, Speaker B: Right, hang on. Let's see. I spent ages preparing this and obviously it didn't work. I logged in ages ago, but I still failed. So where do I go if I just go back into it? That's probably not a good idea, is it? You can hear me. So if I just share screen hang on. You can share the screen for me? Okay.
00:01:13.858 - 00:01:15.852, Speaker A: Yes. I can do it for you. Easier for you.
00:01:15.906 - 00:01:22.124, Speaker B: Yeah, do that, Tina. Brilliant. And then I can just maximize it here, can't I? Yeah. Brilliant.
00:01:22.172 - 00:01:26.784, Speaker A: Yes. Can you just give me a second? Let me open it up.
00:01:26.902 - 00:01:29.270, Speaker B: Sorry, I haven't used Google meet before.
00:01:31.080 - 00:01:36.116, Speaker A: You can introduce yourself a bit while I open up the sure.
00:01:36.218 - 00:02:08.480, Speaker B: Okay, brilliant. Yeah. Well, I'm so excited to be on, guys. Thank you very much to the organizers for thinking of me and for organizing such a great event with such kind of diversity of views. It's such an important topic. I was very chuffed with Charlie for having very sweetly put me at the beginning of the mev timeline there in 2014. I'd really like to be at the end of the mev timeline in 2022.
00:02:08.480 - 00:02:15.520, Speaker B: Let's be optimistic. So that's where I'd like to go with this talk. Are you any closer to sharing there, Tina?
00:02:16.180 - 00:02:20.000, Speaker A: I believe I'm currently sharing. Can everyone see screen?
00:02:20.070 - 00:02:35.368, Speaker B: Yeah. You'll see my slide? Brilliant. Okay, fantastic. I'll crack on, then. So I'm going to start with a very quick definition of mev. Mev is a profit to be made by Reordering and Censoring transactions. So I'm sort of using this original definition, as I call it.
00:02:35.368 - 00:03:07.868, Speaker B: I'm not including block rewards or gas fees or just any way that miners make money. I'm also not including latency arbitrage and actually probably includes cross chain latency arbitrage. And I'll come back to that. Reordering and Censoring transactions is data corruption. Transactions are data, so reordering them is data corruption. And you might be thinking, well, what do you mean by that? Because transactions seem fine to me. They're atomic and they're digitally signed and they're validated by thousands of nodes.
00:03:07.868 - 00:03:41.896, Speaker B: Well, the reason is that data order is as important as data content. So I'm going to give you an example of a picture file. There's a beautiful picture file. So what would that look like if I took every pixel in the file and I reordered them? So I'm keeping the same content, but I'm reordering it, so it might look something like that. So I think we'd all agree that's a pretty corrupt looking file. So the bad news is that this is actually on the left here. Each one of these pixels represents a transaction in the ethereum network.
00:03:41.896 - 00:04:31.176, Speaker B: So on the left, they're ordered by arrival time. I've taken this data from infura, and on the right, they're ordered by inclusion time. So that's the time that those transactions were actually included on the Ethereum blockchain. So what you're looking at on the right is the data corruption created by mev extraction, gas price auctions and mev auctions colluding to create this data corruption in the network. So that's real data corruption from the last few days. So what we're doing here is we're selling the right to corrupt transaction data in this way. So I guess what I'm getting at is you can't be surprised if you sell the right to corrupt transaction data, that your data ends up being corrupt and you get these mev effects.
00:04:31.176 - 00:05:00.084, Speaker B: It's kind of literally what we're doing. So what I'm trying to make the point here is that mev is equivalent, which actually is I defined it as reordering and censoring transactions and that that is equivalent to data corruption because we can see what happens when we do that. So I've done a sort of triangle here, just because it's pretty, but actually, honestly, this is the best way of thinking about it. They're just directly equivalent. And this is why it's only preventable in the base layer. That's why I'm interested in the base layer. Only a base layer fix is going to work.
00:05:00.084 - 00:05:27.730, Speaker B: I mean, obviously, every l two above it needs to be doing it as well. But the base layer needs to do it too. So in terms of sort of a statistical analysis rather than my not so pretty pictures, the average inclusion time for a transaction going through the mempool seems to be around two minutes, 30 seconds. On average. That's twelve blocks. It's pretty high. Right? The standard deviation of inclusion time is 20 minutes.
00:05:27.730 - 00:05:52.324, Speaker B: Right. That is some serious variance. So time order is corrupt in Ethereum. Now, that means latency arbitrage is not possible because latency is a measure of time. And this is what our time axis looks like. Looks like this. So we can't talk in a meaningful way about latency arbitrage and good forms of arbitrage, and even in some senses, cross chain arbitrage.
00:05:52.324 - 00:06:19.440, Speaker B: In those terms, it's all bad. So what we need is some transactional order integrity. Now, Mahima's touched on know, what do we mean by fair? So this concerns some people. Well, by what measure? Fair for who? And who gets to decide? But it's very simple. It's send time order. That's our ideal. If Alice sent her transaction before Bob's, it should be included first.
00:06:19.440 - 00:06:40.070, Speaker B: If Bob sent his transaction before Alice, then his should be included first. So I'm not saying this is easy. I mean, I'm really not. But I am saying it's objectively fair. This is really important. And the reason it's objectively fair is it models reality. And this is what any transaction processing system actually needs to do.
00:06:40.070 - 00:07:08.700, Speaker B: It's trying to audit and log and record reality. And this is reality. They either did or they didn't send their transactions before each other. Now, remember, mev is a profit to be made by reordering and Censoring transactions. If you get sentime order, you don't have mev anymore. It's gone. So now we've got a measure of order integrity, and we can measure it very simply and define it simply as minimal divergence from sometime.
00:07:08.700 - 00:07:49.950, Speaker B: But there's actually an equally important measure, I would say, which is symmetrical divergence from some time. So asymmetry would, for example, be Cistadol, always having zero milliseconds latency access to the markets and Wall Street bets traders always having 300 milliseconds plus, I think, 300 low. So that's an obvious asymmetry. So what I'm showing here is we've got the kind of worst to best on TPS, essentially. So Ethereum where we are now, I've got to say, sorry to say, but we're at the bottom of the heat. We've got high asymmetrical send time error. Transaction order is very corrupt, wealthiest, best resource benefit Nasdaq, I've just sort of dealt with.
00:07:49.950 - 00:08:32.840, Speaker B: We've got these asymmetries, but the actual transaction order is broadly okay, but the asymmetries are nasty. What we're going to do is we're just going to leapfrog Nasdaq all the way over here, and we're just going to end up here, over here at the best Ethereum. Soon we're going to have a low symmetrical send time error, where transaction order approximates send time. All participants are treated equally. Now, the point I want to make about this is centralized exchanges can't do this because they're centralized, they can only do arrival time we're distributed. So we can aggregate arrival times and get something that approximates send time orders is a massive advantage. So our current sort of woes come from us being decentralized in one sense, but it's going to be our superpower.
00:08:32.840 - 00:09:14.952, Speaker B: So that sounds good. How do we get there? So I'm proposing a class of solutions with many potential implementations, but three broad characteristics. So first thing we need to do decentralized content creation. So we've touched on this before, but why are we letting miners order transactions if it causes all these problems? It's because we can't stop them because content is centralized. So we've got this decentralized application layer of many computers. We got this decentralized blockchain structure, but the mine is just like hidden in there. At the very crucial moment when a block's created, one single computer has total tyrannical control over what transactions go into it.
00:09:14.952 - 00:09:39.520, Speaker B: So the solution should be no surprise to anybody at this conference. It's the way Satoshi solved double spending. It's how we'll solve mev. We decentralize. Many nodes will decide the content of one block. So the next big problem we've got is the structure of the mempool, by which I really mean that there is no structure to the mempool. It's an unstructured mess.
00:09:39.520 - 00:10:15.548, Speaker B: It's essentially a graveyard for send time order. We've got hundreds and thousands of transactions sloshing around, probably about 150,000 right now, I'd guess. Now this increased choice of transactions leads directly to increased mev opportunities, all right? Because you've got more transactions for a minor, that your tyranical miner to exploit massive range. So what we could do is we could chunk up the mempool at low latency. So I'm talking about maybe one to every 3 seconds. And we can do this quickly because there's no need to execute these transactions. We're doing basic validation on them.
00:10:15.548 - 00:10:42.820, Speaker B: We're not updating state and broadcasting blocks to everybody and attesting them. So the idea is that if you're doing it in three second chunks, you will have about 70 transactions to exploit per chunk. 70, not 100,000. So less mev. The other thing about this, so this is what I'm sort of building here is the most basic version of a content layer. It's called plain alex. And it does very, very little.
00:10:42.820 - 00:11:03.968, Speaker B: It just does what I've talked about there. It doesn't try fair ordering or anything like that other than the innate amount that comes from chunking up the mempool. So for this to work, it's got to be non optional. All right? So this is why it's a base layer solution. So the content layer creates chunks. The validators must write these chunks in order. If they don't, they will fail at a station.
00:11:03.968 - 00:11:25.936, Speaker B: And the idea of this is that corrupting transaction order will require the same resources. You basically have to mount a 51% attack. Rather than just being a minor and choosing them, you need to escalate all the way up to that level. That's what we're trying to do. So let's look at the advantages of doing that. I've done some research. This is based on real data.
00:11:25.936 - 00:11:41.044, Speaker B: So by mev type, as far as I could tell with the flashbots bundles, I've done some analysis. We're getting about 43% of what is uncontroversially exploitative, I would say. So to my mind, it always up here.
00:11:41.242 - 00:11:47.316, Speaker A: Can you look at the zoom screen? Because I'm scrolling for you, but I'm.
00:11:47.348 - 00:12:09.744, Speaker B: Not exactly sure which oh, you're scrolling for me? Sorry. Oh no, I didn't realize. I thought I was doing all the scrolling. Yeah. So you want to be on the pie chart. Sorry about that. Okay, so that's right, we're on the pie chart here.
00:12:09.744 - 00:12:55.680, Speaker B: So what we've got is 43% of the most exploitative mev sandwich attacks and backruns make up 43% of the mev that we're getting through flashpots bundles. So what I'm talking about doing, if you chunk up content chunks at 12 seconds, right, every 12 seconds, and this is based on real data, you could get a potential reduction of 40%. Well, actually, sorry, the reduction you would have got in that data set was 40%. And that is just by reducing the number of transactions that there are available to attack with. So I'm not trying to do it every 12 seconds. I'm trying to do it every one to 3 seconds. So the mev reduction could be greater than 40% potentially.
00:12:55.680 - 00:13:28.488, Speaker B: There we go. So I'll go on to the next advantages. Tina, next slide. Thank you. So I'm not sure how long I've got actually. Have I got long enough to go through these? I will quickly, very quickly. So, other advantages we've done the 40% reduction, lower user costs overall when you count Mev extracted and big costs, better data integrity, some user experience improvements, remaining Mev is more democratized, which I know some people are a fan of.
00:13:28.488 - 00:14:09.028, Speaker B: So you've only got 70 transactions to mine, not 100,000. So you don't need a massive mining rig, bandwidth reduction potentially because you've got fewer transaction messages once they're chunked. So there's ways you can do that. I'm not going to go into the last one, but it's quite good roadmap. So how could you possibly do this getting from reducing mev to solving mev? So I put some dates in for fun. That plain annex that I've just described is really pretty simple as far as these things go. I would suggest relatively quick to implement relatively you get that immediate significant Mev reduction, but the fun really starts when you start doing other things with the content there.
00:14:09.028 - 00:15:07.076, Speaker B: So in Dark Alex for example, you could have users encrypting transactions, sending them to the Mempool. If you can get this running at a frequency of every 3 seconds, say, then you can use time lock encryption timed at 5 seconds, for example, you don't get any block delays, you encrypt your transactions, order them and then decrypt them within maybe several times within the space of one block. So you're not slowing down the structural there. You don't have to use timelock, you could use threshold encryption. I quite like the idea of a reputation market for key split holders and then you kind of solved mev at that point. I would go further after that and go on to the fair ordering because I want to get to send time and be the best that I talked about earlier. So when you do that, you could have pickers that I've described in the diagram earlier of the content layer that choose these transactions actually seem to map quite closely to equitas replicas.
00:15:07.076 - 00:15:53.936, Speaker B: What I like about encrypting beforehand is that in that instance you have protected yourself against collusion because bad actors are minimally incentivized to order encrypted transactions fairly. All right, even bad actors, good actors are going to do it fairly anyway. Bad actors are minimally incentivized because the easiest thing to do, the least work, the least overhead is just to pop a transaction on a list in arrival time. It's the cheapest thing to do CPU wise and there's no advantage to doing anything else. So I would say though you could go straight from plain Alex to fair Alex, you don't have to do Dark Alex. I just wanted to get the ideas down. So at that point I'm going to boldly claim that mev has solved you have objectively fair distributed Systems For All.
00:15:53.936 - 00:16:09.116, Speaker B: Best transaction system on the planet. The thing we always wanted for ethereum. The thing I wanted for ethereum. When I first noticed this issue in 2014, I've written Yay there to remind me to say, Yay, we done it. Perhaps worth looking at.
00:16:09.138 - 00:16:22.744, Speaker A: Anyway, on that note, thank you for your presentation and we should move on to the next speaker. Rick Dudley.
00:16:22.872 - 00:16:23.790, Speaker B: Thanks, Guys.
00:16:25.840 - 00:16:26.330, Speaker A: Thank You.
