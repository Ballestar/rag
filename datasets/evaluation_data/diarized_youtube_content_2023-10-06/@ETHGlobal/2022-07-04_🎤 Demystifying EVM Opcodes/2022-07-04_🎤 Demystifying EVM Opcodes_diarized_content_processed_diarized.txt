00:00:06.250 - 00:00:27.800, Speaker A: Welcome everyone. It's good to be here. Good to see all your faces. How many of you are a solidity developer? Quite a few. That's good. If you don't develop solidity or on Ethereum, this might be a little ten difficult. That's okay, you're welcome to sit in.
00:00:27.800 - 00:00:55.866, Speaker A: But today I'm going to go over a topic that is usually difficult to find online. EVM opcodes is something that solidity developers, whether they know it or not, deal with every day. And this is good to. So I'm Gilbert. I work at Macro. We have a fellowship where you can learn stuff. We do audits.
00:00:55.866 - 00:01:36.970, Speaker A: More on that later. So first, these are all the things that we're going to go over. We're going to learn why we want to learn EVM mop codes. We're going to learn what a virtual machine is. Very briefly, we're going to have an animated introduction to the EVM. We're going to look at a slightly easier syntax, and then we're going to see how opcodes directly relate to the solidity language. So to start off, why do we want to learn EVM opcodes? Well, the answer is we want to become a better solidity engineer.
00:01:36.970 - 00:02:17.430, Speaker A: A better solidity engineer is not just about developing, but it's also about security. Obviously, we are working with smart contracts that handle a lot of money. You need to write secure code. EVM will help you understand how solidity works, which means you will write fewer bugs. A lot of design decisions around solidity is based on the EVM directly. So if you know why those decisions are made, you're going to be better off. And of course, all sorts of interesting design patterns and solidity are related to low level EVM opcodes.
00:02:17.430 - 00:02:49.694, Speaker A: So let's just move on to virtual machines. So real quick, what is a virtual machine? Well, a virtual machine is named after a physical machine. Physical machines are the things that actually run the hardware that runs on your computer. Usually it's X 86 or Arm. Nowadays. There's an apple m one. But the point is that the lowest level of instruction is binary for a physical machine.
00:02:49.694 - 00:03:21.360, Speaker A: So here we have some binary. Here is an example of the add opcode for X 86, and it happens to be the same for Arm. And then we have another set of binary for the subtract opcode. You may have heard that machines are all zeros and ones. This is where we're talking about right now. The physical machine is going to look at this binary, and based on this binary is going to do something. In this case, it's going to add or subtract or whatever.
00:03:21.360 - 00:04:06.570, Speaker A: There's lots of opcodes, but these are basic ones. Now contrast that to a virtual machine. Virtual machine is software instead of hardware. And virtual machines pretend to be like physical machines. So virtual machines usually also have opcodes. So this opcode, for example, is the opcode for adding two integers together on the JVM JVM pretends to be a physical machine. What's the benefit of that? Well, the benefit is that you can take code that runs on the JBM and then Oracle or whoever writes the JBM makes it work for different machines.
00:04:06.570 - 00:04:35.060, Speaker A: So your benefit is that you can take your code and you can run it on multiple machines. That's the whole point of a virtual machine. And EVM is no different. EVM is a virtual machine, ethereum virtual machine. That's what it stands for. And the purpose is so that you can run the EVM on multiple hardwares that's good for decentralization. We want to run Ethereum on as many platforms as we can, and the aspect of the virtual machine helps us do that.
00:04:35.060 - 00:05:08.710, Speaker A: So what we're going to do next is we are going to look at how the EVM runs. There's three parts to the EVM. There's the stack, there's memory and there is storage. So we're going to take a look at how that works. So first we have the Opcode syntax. What you see on the slide is some binary, but usually binary is too long. As humans, it's harder to read.
00:05:08.710 - 00:05:47.134, Speaker A: So we take chunks of binary. Every four characters of binary equals one character of Hex. And then we put all of that together into one string. So this here is a single byte. One byte is eight bits or eight binary characters or two Hex characters. And this is generally what we do when we're working with Opcodes. We write it in this format even though the Opcode is in Hex, written in Hex.
00:05:47.134 - 00:06:26.990, Speaker A: We also have the human readable name. So here we have Add. We call this Hex code add, and we can pretty much use them interchangeably whenever we're discussing Opcodes. So that's the lowest point. So now on the right we have some Opcodes in human readable name and some Opcodes take some data, as you will see. So we're going to actually run through a bit of EVM execution. Keep in mind that this is the lowest level that you will deal with when working with the EVM.
00:06:26.990 - 00:06:56.458, Speaker A: When you compile solidity, you get something on the right. You don't get your solidity code on the EVM. Instead it gets compiled to Opcodes. And then that is what actually runs on the blockchain. So what we're doing here is we're going to see what is actually going on. When you run a contract on the blockchain, there's no solidity code. So first we have a push one.
00:06:56.458 - 00:07:21.250, Speaker A: Push one is an Opcode that takes the next byte, in this case three, and puts it on the stack. And that's the entirety of the Opcode. Each Opcode is going to do something very simple usually. So you've just learned push one. There are many pushes. Here's another example. Push two says to push the next two bytes onto the stack.
00:07:21.250 - 00:07:58.122, Speaker A: So the next two bytes is just the number four, but it's written to be in two bytes because we have extra zeros. In this example, there's no reason to do that. You can still use a push one. This is just showing you that if you had a bigger number, you could push bigger numbers onto the stack. Here's another example of push one. And now we're going to look at swap two. Swap two will swap the top of the stack with whatever X that you're using.
00:07:58.122 - 00:08:36.586, Speaker A: So there's swap one, swap two, swap three, swap four, all the way up to swap 16. And when we swap, as you'll see, it just takes the top and swaps it with something else. So let me show you that again. We have nine, then we swap and then this is the state of our stack. Now swap only goes up to 16, which means that well, not which means, but yeah, which means you can only reach back that far. You can only reach back up to 16 spots in your stack. If your stack gets too big, that might be a problem.
00:08:36.586 - 00:09:12.680, Speaker A: Specifically in Solidity, if you have too many variables, you've probably seen the stack is too big. Compile time error. This is why there's only 16. You can go back. All right. And lastly on this example we have add will pop the top two out of the stack, which means it's going to consume four and three and then it's going to push back the result onto the stack, which is seven. And that's generally how the EVM works.
00:09:12.680 - 00:10:09.880, Speaker A: If you understand this, you probably do because stacks are not hard and you're all software developers. If you want to learn more about the EVM opcodes, a lot of them are going to be specific to Ethereum. So for example, color is an opcode and color pushes a value onto the stack. It doesn't take any arguments and it simply puts in Solidity message sender. So every time you type in message sender in Solidity, the number of bytes you're adding to your contract is actually only one because Caller is an opcode and that's one byte and yeah, it's pretty cool. So normally I would take questions during one of our fellowships, but right now it's a talk. So I'm going to move on.
00:10:09.880 - 00:10:43.780, Speaker A: Each stack item is 32 bytes. That's just the way it works. If you have something larger than 32 bytes and you need it on the stack, you get to do really complicated stuff. Or you can use memory. So memory is another data structure that you have access to on the EVM. For memory, it's just a really long array. Effectively it starts at zero and it goes as long as you want.
00:10:43.780 - 00:11:24.320, Speaker A: In practice, it doesn't go as long as you want because you will eventually run out of gas. But technically there's no restriction as to what memory address you decide to use. So we're going to look at the M store opcode. So first we're just going to push some values like we did before and this value Mstore takes two arguments. The first argument is where you want to store in memory. So this 20 is referring to the memory address 20. Well, this is technically 32.
00:11:24.320 - 00:12:06.740, Speaker A: The second argument is the value itself. So in this example, we are storing the value three at memory address zero x 20. So when we do that, and you want to pay attention now because animation is fancy, we consume those two items off the stack and then we write to memory that value. That's how Mstore works. Now if we want to actually use that value, we can read from memory as well. So M load only takes one argument instead of two. That is again, the memory address.
00:12:06.740 - 00:13:04.760, Speaker A: And when we run M load, it will pop that off the stack and copy this from memory onto our stack. So now after our M load we have the value that we originally stored and of course we can do this as many times as we want. So in terms of memory, memory is pretty cheap. But of course memory only exists for a single transaction. If you want to store stuff over many transactions, as you might guess, you need storage. So with storage it turns out that it behaves pretty much pretty close to the same way as memory does. So we can replace these M stores and M loads with S stores and S loads and we get the same result.
00:13:04.760 - 00:14:00.470, Speaker A: There are some restrictions such as well, I'll talk about that later, that's too advanced, but it behaves pretty similar. So you might ask why don't we just use storage instead of memory, isn't it? Why not just always use storage? Well, the reason is storage is extremely expensive on a blockchain. So a single S store can be anywhere between 2900 or 20,000 gas. But memory only costs like three gas. So that's the main reason we don't use storage for everything, only store what you really need because it's very expensive. That's effectively it. So we just went over to stack, we just went over memory, we just went over storage.
00:14:00.470 - 00:14:45.080, Speaker A: Memory is like a giant array. Storage is like a key value database. And that's all you really need to get going with the EBM. So what we're going to do now is we're going to learn a slightly easier syntax using a small programming language that I wrote. And we're only going to look at one feature and we want to do this because it compacts the syntax so that we can learn solidity concepts a bit easier. So on the left we have what we just learned. We have opcodes, some data associated with that.
00:14:45.080 - 00:15:28.414, Speaker A: Now what we want to write instead is this syntax. So S expressions, every time you have a parentheses, the first item is going to be the opcode, and then the items after that are just going to be arguments to that opcode. And in this case, if you have data, you can just write the number instead of having to say push one, push two or whatever. And that's it. That's all we're going to learn for now. Now we're going to move on to tying this opcode knowledge to solidity itself. So here are some primitives.
00:15:28.414 - 00:16:02.960, Speaker A: We just talked about message sender a little while ago. And all of these that you see here that you write have native opcodes. I didn't list all of them here, but this is enough to give you an idea. Message sender is the caller opcode. Message value is the call value opcode and so on. So all of these Solidity concepts have a dedicated opcode tied to them. That's pretty easy.
00:16:02.960 - 00:16:31.270, Speaker A: Next. Let's look at Payable. Payable is a solidity feature. You may have noticed that if you want to get paid from a function, you need to write the payable keyword. This is not an EVM related concept. This is a solidity related concept. Solidity has decided to block your functions from receiving ether if you don't put the payable keyword.
00:16:31.270 - 00:17:08.740, Speaker A: So here is some opcodes that are a rough equivalent of non payable functions. First we take the call value and we see if it's equal to zero. And if it's not equal to zero, then we jump to some location in the bytecode that reverts this hashtag syntax here. This is called a label in trim. It's not EVM, this is trim. And a label is just a position in your bytecode. So it's an easier way to jump to a specific spot in your bytecode without having to count bytes and manually type the number.
00:17:08.740 - 00:17:47.002, Speaker A: But yeah, this is what happens for every function. You don't have payable. We have this code generated here. So by implication, it turns out if you write payable on your function, you're actually reducing the code size of your contract. Fun fact, here's some more stuff. Storage variables. So storage variables are compiled by use, not by definition.
00:17:47.002 - 00:18:16.940, Speaker A: So you can define as many storage variables as you want and it does not add to your contract by code. The reason for this is because storage is a key value database. You don't have to initialize your keys, you just use them. If you try to read a key that you've never used before, that's just going to be zero. It's not going to throw an error. That's why uints start at zero, because of that fact. That's how the EVM works.
00:18:16.940 - 00:18:52.870, Speaker A: Now, stores variables are index based. So here we are setting something equal to Y. We are setting something equal to Z. If you look at the first arguments to each S store, we have one and two. The reason for that is because solidity takes your variables and applies indices to them. So Y is considered ox one and Z is ox two. Same thing for reading.
00:18:52.870 - 00:19:20.718, Speaker A: Reading takes an S load. If you want to read Y, that's going to be an S load. Zero x one y is the second storage, the second variable in your contract. So that's why it's one instead of zero or any other number. So these are all index based. Now, because they're index based, sometimes that doesn't matter, sometimes it does. Your variable names certainly do not matter.
00:19:20.718 - 00:20:15.114, Speaker A: You can name your variables whatever you want and it will still work because the bytecode that you end up with do not have variable names in them. Now, this does matter when you start introducing contract upgradability. When you have contract upgradability, you do not want to reorder your variables because when you reorder your variables, then all of the code changes according to those variables. So again, this doesn't matter if you're just writing a plain contract, but it does matter if you're writing an upgradable contract. So do not reorder your variables. All right, let's look at another interesting concept. We have compact storage.
00:20:15.114 - 00:20:49.524, Speaker A: So in Solidity, if you have multiple variables next to each other that are less than 256 bits, which is 32 bytes, which is the word size for EVM, then Solidity will compact them. Compact them means that it will store both of them in the same storage slot. And that has some benefits. So over here we are using X and Y. And this first part is loading X. We have an S load zero. Zero is in the first storage slot.
00:20:49.524 - 00:21:23.924, Speaker A: So we s load zero. But we don't just S load it because this storage slot, which is 32 bytes now has two variables in it, not just one. It has both X and Y. So what we do is we bitmask it. This value here is how you do bitmasking. If you don't know what bitmasking is, you can check it out later. It's a pretty fun concept and not difficult to learn, but effectively we are whitelisting bits out of this 32 bytes of data.
00:21:23.924 - 00:21:53.284, Speaker A: So the first byte we are considering considering to be X. The second one is very similar. We are bitmasking the second byte from the right. But we can't just do that. We also have to shift it so that it becomes its actual value. Otherwise it's going to be bigger than intended. And this opcode just takes the top two and adds it together.
00:21:53.284 - 00:22:39.220, Speaker A: That's pretty simple. So this is a somewhat advanced concept, but as you can see, it's not that hard. Now, the benefit to doing compact storage at all is because whenever you do an S load, the first S load that you do for a given slot is going to be 2100 gas. And then every other S load on that same slot is going to be only 100 gas. So if you have two variables in the same slot, you're not paying 2100 gas for both of them, which is great. That's why Solidity decides to do that. It saves you gas without much effort.
00:22:39.220 - 00:23:11.830, Speaker A: All right, we have just a few left. An if statement. If statements are a little bit more advanced, but still not difficult. So this first line of trim we have over here, we are seeing if X is equal to three. So we S load zero for x. Then we'd use the EQ Opcode to compare it to three and jump. I will jump if the top value of the stack is not zero.
00:23:11.830 - 00:23:55.184, Speaker A: So if they're equal, then it's going to be a one, otherwise it'll be a zero. And if it is a one, then we jump to the then label which will revert. Now, the way reverts work, and also the way returns work, is that you have to store your message in memory and then tell the EVM where it lives in memory. So that's kind of what we're doing here. I'm omitting some stuff because it's not that important. Basically we store a string into memory and then we revert using that string. That's the then case.
00:23:55.184 - 00:24:24.380, Speaker A: If we go to the Else case, that's just incrementing by seven. That's straightforward. We do an S load, nest store and so on. One interesting thing to note is that down here we have another S load. So as of this moment, solidity zero x zero eight. Solidity does not optimize S loads. So every time you reference a variable in solidity, you are doing another S load.
00:24:24.380 - 00:25:14.442, Speaker A: So if you really wanted to avoid extra S loads, you need to store it in a local variable first and then reference that local variable. All right, now we're getting slightly more advanced. Every time you call a function from another contract, you're using the call opcode or the static call, or the delegate call. But the point here is that you're using a Opcode to make that function call and it requires a bunch of stuff. Don't worry about that. What I want you to focus on is that this is an external call. External calls on the EVM are very different from internal calls.
00:25:14.442 - 00:26:05.840, Speaker A: In fact, the EVM does not have a concept of internal calls. That is a solidity specific thing. So let's look at internal calls and compare internal function calls on the EVM. It's just jumping to a specific spot in your bytecode and then jumping back. So here in this pseudocode, we push a specific address in our bytecode, then we jump to the internal code and then we expect it to jump back. So in bar FN we do our stuff and at the end we jump because we expect the return address to be on the stack. So we jump and just jump back.
00:26:05.840 - 00:26:55.550, Speaker A: That'll probably take a bit of studying, but that's okay. Last thing I want to go over is this one. So same idea, except now we have a parameter. So you can see the code now has a parameter. And really all that means is that we are pushing that parameter on the stack first before we jump. And then down here we assume that parameter is on the stack and this code is doing that by s loading x and then adding. Adding takes two arguments, so it expects another argument to be there, which is the parameter, but that's about it.
00:26:55.550 - 00:27:25.492, Speaker A: Again, during an actual fellowship, I would be very happy to take questions. If you want to learn more about that. We have the link here. Fellowship is for senior engineers. We learn advanced things like the EBM and security and common contract patterns and things you need to do to make sure that those things are secure. We also do audits at Macro. Right now, I am doing lots of audits.
00:27:25.492 - 00:28:13.610, Speaker A: Not at the same time, because that would be bad. But if you need an audit, we also have that. And if you want to learn more about Opcodes, this link is my favorite link. There's lots of links, but this one's great because it actually explains a lot of gas costs for each Opcode. But yeah, that's it. It any questions? Yes. Correct.
00:28:13.610 - 00:28:58.056, Speaker A: Yes. The question was, is Viper also compiled to EVM bytecode? And the answer is yes. Solidity is not the only language that you can use, and the reason is because we have that virtual machine. So you could, if you wanted to, like I did, write your own language and have that compiled to EVM bytecode, and it will run on the chain just like anything else. Good question. All right, if you all have more questions, I'll be here for the next 15 minutes. We also have our other co founder, David and Keishawn over here, and Tim.
00:28:58.056 - 00:29:09.260, Speaker A: So we have a whole group here. So, yeah, happy to meet you all and happy to take more questions. Thanks. Bye.
