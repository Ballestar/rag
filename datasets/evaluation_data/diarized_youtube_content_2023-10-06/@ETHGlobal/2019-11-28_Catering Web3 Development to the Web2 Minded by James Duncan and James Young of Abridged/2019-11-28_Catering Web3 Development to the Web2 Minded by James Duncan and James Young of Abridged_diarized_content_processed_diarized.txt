00:00:08.490 - 00:00:29.550, Speaker A: Hey everybody, thanks for coming. So yeah, this is intuitive with the applications. James. James yeah. And so we'll just go through a bit of an overview of bridge.
00:00:55.010 - 00:00:55.374, Speaker B: Of.
00:00:55.412 - 00:00:59.390, Speaker A: All your sort of methodology. We talked about the bounty opportunities.
00:01:00.850 - 00:01:01.600, Speaker B: Cool.
00:01:02.050 - 00:01:26.870, Speaker C: Yeah, cool. All right, so I have a background in games, social games specifically. So prior to doing crypto and Web Three, I was doing games, online advertising also have experience when it comes to infrastructure. So one of my first acquisition.
00:01:34.190 - 00:01:34.554, Speaker A: Have.
00:01:34.592 - 00:01:54.590, Speaker C: Some enterprise experience as well. And all of this kind of Web Two stuff has led to figuring out how to make not only the user experience better for users, but the developer experience and focused on scalability and user onboarding.
00:01:58.150 - 00:02:22.870, Speaker A: This is a quote that I hear from James Young actually is like it's not as much about how often you go fast in order to make that viral application or that thing that can take off. And so a big part of what we're trying to do here is build that framework for really fast application development.
00:02:27.310 - 00:03:06.760, Speaker C: That's a great point. I think that instead of trying to create the perfect system, it's about being able to flesh out ideas quickly. And that's the real design philosophy behind what we've built in terms of the SDK is to be able to be the tooling that allows you as a developer to get from idea into something that's tangible as quickly as possible and that's where the value lies. So the idea here is that you want to be able to iterate and learn as quickly as possible and that comes back from feedback and that's been one of the big takeaways from previous experience with Lights. It's all about data driven metrics and being able to iterate and see what works.
00:03:11.250 - 00:03:11.662, Speaker B: Yeah.
00:03:11.716 - 00:03:54.300, Speaker A: In Web Three, James was part of the team that built the first PCR, also built first state channel with bank chain, recently deployed Molot earlier this year, which is another sort of thing happening in the space and then most recently Bridge and was the first real production deployment of Create Two. So Create Two is an opcode that was included in the last hard work to mainly originally used for the counterfactual state channels by L Four. But James Young decided that it was actually a really useful onboarding tool to launch an account without having to upload any report.
00:03:54.850 - 00:04:55.220, Speaker C: Yeah, the reason why we talk about this is it's all about iteration, it's all about learning. And so as we travel altogether as developers through this space and trying to understand what crypto is the tooling that we provide, and we'll show a demo of this and you guys can play around with it as well. Is just to be able to iterate and try to see and figure out where this goes and how you as a developer can get your ideas out there and figure out, from a usability perspective how to make apps that ultimately generate revenue. It's kind of this weird thing where we're in early in the market when it comes to crypto is like it's a currency, but there are so few apps that are actually generating revenue. And all of this is an exploration in terms of being able to figure out what works and what doesn't. And hopefully you as developers can use SDK and hopefully it's useful for you so that you can flesh out your ideas as well as possible.
00:04:59.430 - 00:05:56.370, Speaker A: So, yeah, the focus for a long time has been on scaling, right, in our space. But without onboarding, the scaling doesn't matter. And we kind of have solved scaling. Like, we've had State Channels out for more than a year now, but no one's using them because they don't need to. There's no users, right? And so the real focus and this is a post, like James has been thinking about this for a year and a half, just the onboarding side of things like what needs to happen in order for scaling to even matter. And it really comes down to sort of key management. And so that's kind of one of the design principles that we're also focused on within the account contract design, which is our sort of onboarding piece of toolkit provider.
00:06:00.490 - 00:06:55.558, Speaker C: The experience with State Challenge was like, you're building something that scales, but it's really hard to actually get to that app because you have to download an extension and what happens is you lose your keys. You have this whole onboarding process of this is where we talk about programmable money. Programmable access is with key based wallets, which we're all used to, especially coming from Bitcoin. It's like only having a computer with root access, right? And so we've solved that in generalized computing decades ago and we need to move towards that when it comes to fund management, doing what you can do from a user experience perspective when you're building an app as a developer, you don't have to force your users up front to have to figure out what the mnemonic is. Pretty scary for user to have to.
00:06:55.564 - 00:06:58.934, Speaker A: Say, okay, well, if you don't write.
00:06:58.972 - 00:08:02.078, Speaker C: Down your private key and you lose it, you're going to lose access to your fund. But at the same time, don't write it in too many different places because if someone finds it or if it leaks, then they're going to steal your fund. So there's this like crypto paradox here. And I think in a lot of ways in order for us to be able to sell collectively as developers for mainstream adoption is to be able to provide that safety and recovery mechanisms. Because when you think about it in terms of like a traditional bank, that's part of the service they provide, is that safeness? Where that safety factor for like fund management? The bank is going to be around and they're going to hold your money and they're going to keep it so that you make sure you don't lose it. And if you lose your car, you can always get it replaced, things like that. And so I think there's a lot of things that we can do with contract based fund management and the whole design space that could be explored for best practices there.
00:08:02.078 - 00:08:21.330, Speaker C: And I think once we begin to adopt these best practices, then you see mainstream adoption happening. Then from mainstream adoption, then it's like this one two punch where you need the ease of onboarding that will allow apps to be able to have scale and then solve for scalability.
00:08:24.520 - 00:08:49.816, Speaker A: And so this is going a little more into what a bridge we offer specifically. And this is like the account contract design. Again, so noncustodial was a primary feature that we don't want to be private keys. The user is always in control of their money and right, it's contract based. And we use Ephemeral keys that are related to every instance that users logging.
00:08:49.848 - 00:08:51.656, Speaker C: In with or device that they're logging.
00:08:51.688 - 00:09:57.518, Speaker A: In with in order to access their accounts. So you can also build a whitelist of keys essentially, that allows for social recovery. And this is just a little diagram to kind of like show what the system looks like a little bit. So it's like a normal username password login, potentially, if you want to link this to a web two off account contract that isn't deployed to chain, but it's created. And then you have multiple device keys either with the Guardian or with your computer, as well as and then the second step to that onboarding process is that PR ramp. So we're working with a number of Pram providers to also make an easy integration for the developers who get there. We skip over channels in this presentation just to keep it simpler.
00:09:57.518 - 00:10:05.842, Speaker A: But if you all want to talk about our script channel implementation, we're also interested in people using that. From here we can go into our.
00:10:05.896 - 00:10:06.500, Speaker B: Demo.
00:10:08.490 - 00:10:14.440, Speaker A: And I'm actually realizing that we didn't upload any test to our account.
00:10:18.490 - 00:11:12.854, Speaker C: Yeah, so I think that so you can either go to that QR code or you can go to so feel free. We have this, it works in Safari. It works in all browsers. It actually works on your phone. So if you go to playground Abridge IO, you will see this playground. I'm going to actually open it up in Chrome so I can fund it through MetaMask. My Internet connection is really slow.
00:11:12.854 - 00:11:36.830, Speaker C: So real quick, I'm not going to go through everything here in terms of the demo. But you can go to this page. We have the SDK embedded on the site. So there's no plugin, there's no nothing that you need to install. What you basically get is when you load the page, a burner wallet. So up off the top in the purple, you'll see that there's a device address. And this is in local storage.
00:11:36.830 - 00:12:13.562, Speaker C: A public private key pair gets generated. I can go to initialize. I can choose my network, so I can go to Robson, Rinkby, covan and SOCOL, which are the testnets. And on the left side are categories of all of our method calls. So they're broken out into several categories for account. What I can do is at first create an account, and you'll see that whenever I click on these different method calls, you'll see that yellow part change, and this yellow part is actually at the top, the parameters that you would actually input as a developer.
00:12:13.706 - 00:12:14.014, Speaker A: Here.
00:12:14.052 - 00:12:50.422, Speaker C: In the middle part, you have the code that actually you would write, and you can execute the code if you wanted to by clicking Run. And at the bottom here, you have the console output. So if you were to open up your JavaScript console, you would see the exact same thing. We have a whole event based interface, so you can listen for events as they happen. And then if you click on State, it gives you the whole SDK state object where at the top it's a summary. So what we're doing here now is when you just load the page, you get a burner wallet, you get a device address. I'm on Robson.
00:12:50.422 - 00:13:25.998, Speaker C: What I can do here is I think I have cobany. So I'm going to switch to Coban. And this is the code that you would write. And essentially, you can just cut and paste. And we have a few implementations that are in production and they actually use the playground for testing and to be able to make sure that they're writing things correctly. And oftentimes it's just like cut and paste from the code into their specific implementation. And so what I'm going to do is I'm going to switch to Covan, because up here, I don't think you can read it because of the resolution.
00:13:25.998 - 00:13:30.370, Speaker C: I'm on Robson, so I can go. I'm going to switch to Covan.
00:13:30.450 - 00:13:30.646, Speaker B: Now.
00:13:30.668 - 00:14:10.898, Speaker C: I'm on covan. I have a device address. And what I want to do now is I want to create from this device address a contract based address. And so this contract that I generate, counterfactually means that I'm creating an account address, a smart contract that will hold my funds, but the contract is yet to be deployed. And that's what it means by counterfactually creating it. We also have integration into ENS. So you can type in an ENS or just click the random button and it'll create a random ENS label for you.
00:14:10.898 - 00:15:44.210, Speaker C: When I click Run, what you'll see is at the top. Now, instead of just the network and the device address, you have multiple different things. In this top level dashboard, what you have now is an account address. So this account address is that smart contract that's yet to be deployed. And what I'm going to do is take this, copy that account address, I'm going to send it some command e, and hopefully my Internet connection through MetaMask will allow me to send this. I'm not sure what's going on with MetaMask. So if this transaction were to actually deploy, you would actually see that my account balance would increase automatically.
00:15:44.210 - 00:16:34.038, Speaker C: We have a listener in the back that connects on our back end servers that connect to watch different account addresses. And then you would be able to deploy your account. And what deploying your account does is it would send a signed transaction from your front end. It would hit our relayer. We're actually going to integrate with gas station network now that gas station network is live. And it would then deploy the contract on the user's behalf and then get refunded the gas for deployment from the account balance that if I was able to send via MetaMask, I would send. Let me try to see if I.
00:16:34.044 - 00:16:35.080, Speaker B: Can do this again.
00:16:59.110 - 00:17:47.962, Speaker C: So if I won't belabor this, it seems like MetaMask is not working at the moment for some reason. And then once the account has been deployed, what I could do is I could go into state channels. And if you're wanting to tap on this, more than happy to explain this in more detail, but the state channel implementation is really easy. You have a bunch of categories in terms of payment. And so our state channel implementation, we refer to it as payment. So you can send money into a channel. We have this account balance which is this virtual balance which is our off chain balance.
00:17:47.962 - 00:18:56.614, Speaker C: So that similar to other state channel implementations, no gas fee and it's instantaneous and you can send to other recipients without them having an ETH address. So we have this notion of anonymous payments as well. And we have examples that you can play around with. We have a tic TAC toe game example and you can look at our GitHub repo at the top right click on it, you can see example code that runs all of this so that you can essentially, instead of having to start from scratch, you can either look at the repo or look at the code examples. And yeah, we have the notion of account friend recovery. Since this is a contract based wallet, it's basically a multi tick. So you can have N of M recovery options if you were to deploy the friend recovery extension.
00:18:56.614 - 00:20:16.146, Speaker C: So the idea when we're building out this contract based wallet, one, we wanted to make it really easy to implement. We wanted to make sure that you as a developer have full control of the whole experience from beginning to end. Because coming from a gaming background that funnel drop off, having to go to a third party app we thought was kind of detrimental. So you as a developer need to own that whole experience and in order to be feature rich but not have it be too expensive to deploy a contract, we have this notion of contract extension and so the account Friend Recovery is what is considered a contract extension. So you'll notice one of the first things that you do when you're adding your account friend recovery extension is it actually is another contract that is deployed, that's attached and that has access to your account based wallet. So other implementations of contract based wallets cost in the dollars. So when we were pricing this out, ETH at that time was about 300 USD for one e.
00:20:16.146 - 00:21:12.002, Speaker C: And there are these other contract based wallets would cost between like five to $20 to deploy a contract. We thought that was too much. So our basic implementation of our contract based wallet when ETH is at 300 costs about between 20 and deploy, because it's very simple. It's just a mapping of device addresses that have access to the contract. And that's what we use in terms of a design to extend for other types of logic, like friend recovery. So when you're doing friend recovery, you're actually launching a separate contract and you're attaching it to that extended logic, to your contract based wallet, essentially. And we see a marketplace eventually, someday, of people being able, or other developers being able to create their own type of contract extension for logic.
00:21:12.002 - 00:21:23.946, Speaker C: So, for example, if funds come in that are in ETH or some whitelisted token, you can have a contract extension that automatically converts it via uniswap to.
00:21:23.968 - 00:21:25.258, Speaker A: Like, Dai, for example.
00:21:25.344 - 00:21:54.580, Speaker C: So your users can only need to see things that are in, like USD just to make the user experience easier. Things like yeah, that is a very high level overview, and I apologize sincerely. I don't know what's going on with my MetaMask. I would walk you through the whole process. It requires funds to go into the contract in order to deploy and do the state channels, which I can't show right now.
00:21:56.150 - 00:21:58.334, Speaker A: So it requires funds to go into the contract.
00:21:58.382 - 00:22:00.086, Speaker C: It's not deployed yet. That's right.
00:22:00.188 - 00:22:00.646, Speaker B: Cool.
00:22:00.748 - 00:22:03.350, Speaker C: So what happens is essentially.
00:22:05.370 - 00:22:05.878, Speaker B: Oh, it.
00:22:05.884 - 00:22:06.582, Speaker C: Just worked for me.
00:22:06.636 - 00:22:12.940, Speaker A: Well, I have do you want to just send me your address?
00:22:13.470 - 00:22:28.210, Speaker B: Yeah. Directly.
00:22:38.410 - 00:24:04.130, Speaker C: Okay, so okay, so, yeah, the the idea is that when you send funds to that account address that has yet to be deployed effectively, you are like locking your funds in because there's no contract behind it to be able to withdraw funds out. And so what you need to do is, once funds hit, though, we have an indexer that watches and can automatically deploy the contract on behalf of the user. But that's something that you as a developer, we think should be in charge of in terms of the actual flow. So there might be use cases where you, in your app, in your context of your app, may want to do that automatically for the user, and you can do that, or there may be times when you don't want to do that automatically. So the SDK is super flexible. And so that's why we created this playground for you as a developer to be able to understand because there are different kind of states. There's pre deployed contract states, there's post deployed contract states and you get to choose as a developer how you want to facilitate key management on behalf of users.
00:24:04.130 - 00:24:41.310, Speaker C: The SDK from a design perspective tries to do its best to be non custodial. So key management happens locally in the browser. There's no storing of private keys on the server. We don't touch it at all. As you as a developer, though, having access to the SDK can program things as you wish for the end user. And same with our C channel implementation. It's fully noncustodial.
00:24:41.310 - 00:24:56.660, Speaker C: Yeah, I don't know what's happening. MetaMask is not sending up.
00:24:58.840 - 00:25:11.050, Speaker A: Well, if you all do want more proper demo playground, feel free to get in touch. Just have like one last slide on Bounties available.
00:25:16.570 - 00:25:17.480, Speaker B: Make sure.
00:25:21.930 - 00:26:28.234, Speaker A: So there's a bunch of there's like eight example apps that just came out that you can check. We have a blog post on Medium. Also have some QR codes if you're interested on sort of like a native mobile app. For Frank, it's a video sharing, content tipping sort of app really rudimentary basic, but it kind of gets the point. Process account contracts and data channels integrated there's also in the future for Bridge, there's going to be a dev portal that allows for a graphic interface, drag and drop and also data user data that you can sort of see what features are really performing and which features aren't to make better design decisions. Some of our goals and then right at this hackathon we have three different bounties, $500 apiece. Essentially the main points are if you create a nice onboarding flow that's eligible, a nice state channel implementation also eligible.
00:26:28.234 - 00:26:49.240, Speaker A: And then the best app, UX is sort of the third piece. Outside of that though, if you do just create a sort of like example tutorial of a very basic app, that's also something that we're interested in supporting. So feel free to ask questions or dig in more final.
00:26:55.550 - 00:26:56.058, Speaker B: Questions.
00:26:56.144 - 00:27:06.860, Speaker A: Oh yeah, so this is actually just for the Medium post, but I have these flyers right here for Frank that have.
00:27:08.830 - 00:27:16.210, Speaker B: Download. It's actually really cool. Fits.
00:27:18.390 - 00:27:20.420, Speaker A: Cool. Any questions?
00:27:22.820 - 00:27:26.210, Speaker B: Sweet. Yeah. Thanks guys. Thanks.
