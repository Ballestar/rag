00:00:04.330 - 00:00:56.800, Speaker A: Good evening, everyone. So I'm Johnny and I am an engineer for Chainlink. My focus really is on operations, so really around the scalability, how easy it is to operate, the monitoring, and really the ease of use of operation of Chainlink link. It's a decentralized Oracle network and so it's specifically for connecting your contracts to external data feeds. So to get started, I'll be going over a intro to Chainlink for anyone who's not that familiar, a sample problem. So why Chainlink would be useful in a specific situation, an implementation walkthrough, which I would recommend everyone to join into. If you've got your laptops at the redder, won't be that hard.
00:00:56.800 - 00:01:42.874, Speaker A: A live demo and question and answers after that. So I will get going. So in order to understand Chainlink, you must first really understand that contracts are not able to connect to external data. For anyone who has worked in soliditor and has been building contracts. You'll know, you cannot just call an external API if you want to get external data in. If you want to call JSON API, top API, you want to connect to a database, really anything off chain for a data source that you'd want to pull in on chain to use as a condition in your smart contract, you can't do it. So really, that is the main problem what Chainlink is trying to solve.
00:01:42.874 - 00:02:17.880, Speaker A: It's a big limiting factor for smart contract adoption. We truly believe that smart contracts without a reliable data feed and without being able to connect to off chain data sources are not feasible, not really. They're limited to just token transactions. Like if anyone's seen if you've built on Ethereum or used Ethereum. Most of the time that you use Ethereum is mostly for gambling apps. For decentralized exchanges, there's not really any real use case. What you can do.
00:02:17.880 - 00:03:32.446, Speaker A: We believe that is because you cannot connect your external contracts, your contracts to external data feeds. We're focused on being able to connect contracts to external data feeds for anyone who's built anything with web like API developer. You'll understand there are thousands and thousands of APIs out there what will do a million different things for you. They'll give you different data, whether that will be for the weather price, data, stock data, like anything really, there's an API for it. So Chainlink is all about being able to connect your contracts to those external data feeds, skip to head one. And as well as that, a big issue with adopting smart contracts in general is not being able to connect to typical payment providers. Like if you want to send someone actual fiat money, whether that is USD, the pound, euro, whatever, you cannot do that.
00:03:32.446 - 00:04:15.062, Speaker A: Currently in a smart contract, you have to use some form of wrap token, whether that's Dai or any other sort of stable coin. But then you've still got to be able to get that off and it's not really usable. Well, not really user friendly anyway for anyone who's not really worked with crypto. So Chainlink is also allowing people to connect their contracts to payment gateways, like PayPal for example. So you can actually trigger real payments from the events of a smart contract. Pretty key. And as well as that, Chainlink will also support being able to connect to different networks.
00:04:15.062 - 00:05:02.086, Speaker A: So for example, if you've got an Ethereum smart contract and you've got some conditions in there and out of the back of the conditions, you want to trigger a transaction on Bitcoin to send someone some money based on, say if you've got an insurance contract, then Chainlink will allow you to do that. The main way it does that is something called external adapters. Chainlink is very extendable. There's the notation of external adapters which are like little microservices. I like to think of them as like API proxies. So for example, any API what needs credentials, it's not really JSON, it needs some form of converting to be JSON, like a Soap API. You can build them on top of Chainlink.
00:05:02.086 - 00:05:41.480, Speaker A: It's really simple. They can be done in any language. Like a lot of the time if anyone's familiar with like, we run a lot of adapters in Lambda. So it's just like an API proxy. You give it a key and it'll call the API and then Chainlink will return that data back on Chain to you. The beauty about external adapters is that you don't really need any blockchain knowledge at all. Like if you've developed an API before and if you're familiar in Java, Go, node, whatever, just build your external adapter in the language you prefer and as long as it returns a specific JSON payload back, you're fine.
00:05:41.480 - 00:06:50.214, Speaker A: To get a bigger picture of Chainlink, it is a decentralized Oracle network. And what we mean by that is that you aren't relying on one party to get the data for you. A lot of the alternate solutions at the minute are specifically relying on central parties. They might provide proofs, but in terms of availability and reliability, there's still the potential for downtime for you not to be able to get the data in your contract to break, which goes against the purpose of blockchain in the first. So for example, with Chainlink, rather than saying like the example I'll be going over is to get the Ethereum price. So for example, in this sense you could say I want six chain link nodes to get me the price of Ethereum from four data sources. That could be four different exchanges.
00:06:50.214 - 00:07:20.018, Speaker A: Wherever you want to get the price from all the chain link nodes go out, get that data. So you've got six nodes. The six nodes might be calling different APIs, but then when all the six nodes come back, then they all aggregate that data and then reply back on Chain with that data. In terms of reliability, you've always got the failover. If one of one, two, three of them nodes are down. You're always going to have a node. You're always going to have a node fetching that data.
00:07:20.018 - 00:08:04.930, Speaker A: If one of the APIs is down, my other nodes are using different APIs. So it's a way of really trust minimizing the retrieval of external data onto the blockchain. So based on this example, like for example, you get the Ethereum price. It's someone like your salary contract. For example, you say, I want to pay Bob $50, but I want to pay in Ethereum. So you just get the price of Ethereum based on that rate. Then you convert how much Ethereum you're going to send to Bob and then just send that.
00:08:04.930 - 00:08:48.076, Speaker A: But without the reliable data feed, then you wouldn't be able to get the price of Ethereum and send Bob his money. Simple example. So to go into more detail of a sample problem, like got a smart contract that knows its market price. It can make crypto payments based on the price in fiat and requires escrow or deposits based on that price. So, good example. You've got Alice and Bob. Alice has a website.
00:08:48.076 - 00:09:42.574, Speaker A: Bob is contracted to do SEO for that website because Alice wants her website at the top of Google, like standard sort of SEO agreement. And if Bob does his job right, then Bob's going to get paid $50 worth of Ethereum. But we want to do all of this on chain. So for example, if you think about that, practically you'd need to get price of Ethereum. You need to get the ranking of that website, like where it is on Google, by using an API. The criteria and the terms of the contract is basically check the ranking of Alice's site. If the value is less than ten, get the current price of Ethereum and pay Bob $50 worth of Ethereum.
00:09:42.574 - 00:10:25.812, Speaker A: If you're thinking in terms of like a smart contract and like if he was building that in solidity, it's pretty simple. But the key piece of the puzzle that you're missing in this sense is being able to connect two external data feeds and get the ranking of Alice's site and the current price, Ethereum. Alice. In this situation, Alice would first send some Ethereum to the smart contract. Think of this as escrow. So based if Bob does his job right, then is some Ethereum in a contract. Bob says he's done his job right, alice goes to trigger the contract.
00:10:25.812 - 00:11:12.310, Speaker A: And then once Alice triggers that contract, then the Ethereum contract would make a request to chainlink. Chainlink would use multiple data sources, it would check the ranking, it would get the price and then start feeding that back into the contract. The beauty of this is that you're not relying on a single source of truth. You are getting your data from multiple endpoints. You're using multiple exchanges, multiple aggregators, many. So in the happy path, if you think about this contract, there's obviously the situations where Bob don't really do his job right. And the ranking hasn't really gone up that much.
00:11:12.310 - 00:11:37.260, Speaker A: But in the happy path, once Alice triggers the transaction, everything comes back. Okay. Chainlinks called the SEO ranking. The ranking is gone. Higher up, it's less than ten. It's got the price of ethereum and then it will trigger the transaction. Send Bobby's money and convert and send the right amount based on the price of ethereum.
00:11:37.260 - 00:12:07.368, Speaker A: Enough of the sample problem. So, ways to implement. So if anyone's got the laptops opened or interested to get yourself ready now. So I'm going to go through the steps just to do this for yourself. So I've been talking a lot about the price of ethereum. This basic example will get the price of ethereum and at the end I'll show a demo of that. Doing it on Chain as well, but you can go along.
00:12:07.368 - 00:12:51.780, Speaker A: So there's two ways if you want to use chain link. Easiest way is for anyone who's done contracts is just using a web IDE, whether that be Remix or Superblocks. If using Remix, you don't have to sync anything, don't really have to set up a local environment. It's good for beginners. For anyone who likes working in Zeppelin, OS or Truffle, all integrated, you can use it. It's good for that. Like I was recently doing some stress testing with Chainlink and I've got like a Truffle script and it just like asynchronously Fires, like a ton of requests like to chain link and wait some fill and it's all done in Truffle.
00:12:51.780 - 00:13:26.912, Speaker A: We will be focusing on just on Remix today. Really simple. So I would load the workshop page up and when you load the page up, you'll see like his different events. If you scroll to the bottom, you'll see East Denver. And really that's the section we're going to go over a little bit. But yeah, this is the only link really. You need to type in everything's at the bottom under this.
00:13:26.912 - 00:14:26.180, Speaker A: I'll just go through the steps as well. So for this example, we're going to be using Robston. The example also utilizes ENS. So for example, our chainlink contracts and our chainlink nodes have ENS addresses and our contracts, when they talk to the chainlink nodes, use the ENS address to resolve the Ethereum address to send the request. So first, if you've not got MetaMask installed, get MetaMask on your browser. Get some Robstone ethereum if you've not got any already, and get some Robstone link as well because you'll need some link to be able to fund the Oracle to serve your request. I'll skip over, but if wants the previous slides or anything, just let me know.
00:14:26.180 - 00:15:24.950, Speaker A: So to make this easier for yourself, you want to add the link token onto your MetaMask in Robston. You can use the NS address for that. So if you add a custom token in MetaMask, just type the address it should resolve and then you get the token. Just add that and once you want to force it and put in your Robson address, then once it's confirmed, you'll see the link in your balance. And then once you've got that and you've got some ethereum, you're pretty much ready to go. People all right with remix and stuff? Used it before. Two, let's get going.
00:15:24.950 - 00:16:23.450, Speaker A: If you're not doing this workshop, don't worry, because I'm going to do it at the end, but good for you to follow through. When you get to remix, make sure you change your compiler version to zero 4.24. The source, the flat file source we're going to be linking to is zero point 24, so it won't build unless you select that compiler version at the bottom of the workshop page. There should be a link to a solidity file. You should see a contract link at the bottom, if not, you can. I mean, it's a lot to type out if you're just doing this from the slide, but it's on the bottom of that workshop page if anyone's following along. Are you all right? You good? What's that? Sorry.
00:16:23.450 - 00:17:04.730, Speaker A: Yes. Get that one. So once you've got that contract, that contract up, paste it into remix. Simple. The contract is so big, if it looks a bit overwhelming, it's just because it's a flat contract. So we've got all the dependencies in there for you, so you don't have to mess around with copy and pasting all the dependencies in which I hate doing. So just again, make sure you're on the right compiler version.
00:17:04.730 - 00:17:28.446, Speaker A: Click start to compile if auto compile isn't enabled. And if all is good, you should see the right hand side. All green. Yeah. Got some thumbs up. Yeah. Right, sue, switch to the run tab.
00:17:28.446 - 00:18:16.760, Speaker A: So you want to actually deploy the contract to Robston now and make sure you select the A Ropston consumer contract. I think it pretty much selects it by default, but you may get one of the different dependency contracts. Make sure it's that contract and deploy it because it's Robston. It might take a little while, especially if loads of people are sending contract deployment transactions at the minute. Yeah. Yes. If I go back to just because it's a long link, if you go to the workshop page or just Google like chain link docs and this page will be on there, unlike the drop down.
00:18:16.760 - 00:19:20.320, Speaker A: Yeah. Go to the Eve Denver one. Yeah. Not the top one, because the contract's a little bit different. Get back through deployed, it all right. Very bottom Denver one have a link to the right contract file. The slightly different one at the very bottom of the workshop page under no worries.
00:19:20.320 - 00:20:24.980, Speaker A: So once you've got the contract deployed, you've got the clipboard symbol to copy the address because you want to send some link to it. So if you go in MetaMask and if you've got some Robstone link, then just send a couple of link to that. It uses one link per transaction. So send like three or four, not really that much. And don't worry if I'm going a bit too fast because I'm just thinking I need to do a live demo at the end so I don't mind going through this with anyone. But yeah, the contract you've deployed needs link because when you create an Oracle request, when you call chain link it creates that request by sending the link token. And the link token is of ERC, six, six, seven, which is basically like two, two, three if anyone knows the ERC, numbers, but a tiny bit different.
00:20:24.980 - 00:21:02.072, Speaker A: So basically is a transfer and call where it encapsulates data within the request. And that data it encapsulates is the parameters of the Oracle request. It tells the chain link node what it's going to do. If you've got through okay, then you should see the function after it's been deployed for request ethereum price. And the steps for this are on the workshop link as well. If you're going to enter like near the bottom, it'll give you that job ID. It's a copper USD.
00:21:02.072 - 00:22:00.990, Speaker A: So we are getting the ethereum price in USD to give a little bit of information around the job ID. If you create a job on a chain link node, like it tells it what to do, it will be a Http get. Then convert the value to like uint 256 and then write it back on chain. So that job ID is the primary key for that job chain link node. If you do go to send the transaction and you see that error pop up, it's because you've not got any links sent to the contract. So if you did do that, then your contract has just made a request to a chain link node. When the chain link node is notified, when the transaction is confirmed, it will trigger the event log which will then kick the chain link node into gear, get it to call the endpoint, convert it to the right value and then write it back on chain.
00:22:00.990 - 00:23:08.720, Speaker A: Let's get through this. And if you have done that and you're following through then if you click like current price on there, you'll see price come through your contract and that's good. Done. So I will show you this now. So want to just show off, show the actual contract off a little bit more for people who know solidar. So this contract imports what we called the chain linked contract. So you'll see there that Aerops and Consumer inherits the chain linked contract and then it inherits the honorable just for withdrawing tokens out of it.
00:23:08.720 - 00:24:46.974, Speaker A: There's the ENS addresses you can see in the constructor is setting up chain link with ENS and then there's request price method. So just to run through that a little bit, it's creating a new chain link request with the job ID. It's just passing that in creating a new chain link request for that request, it's just adding a URL, standard URL, and then it's creating an array just for JSON parsing. So, for example, that array just tells it what value to actually parse in the JSON when it gets the response back to right back on chain, then just like a multiplier value and then the actual chain link request call put it in there. So I ran this earlier and it reported that the Ethereum price was $137.5. So if I run this again, what do you mean by unique? Sorry? Oh, it's always the same. So copy and paste it from that workshop document so that job ID points to what we call a job on the node.
00:24:46.974 - 00:25:20.846, Speaker A: And all that job is is literally just a bit of JSON where it says, like, I want to do http get JSON parse F-U-N 256 conversion, multiply it and then write it back on chain. If you see the JSON spec, it's pretty simple. It's just like what we call core adapters and then they're just written out as like types. It's just like tasks in the job. Wonder if that's done while I've been talking. Hey, it's not moved much. They changed like 15 cent.
00:25:20.846 - 00:26:16.500, Speaker A: But yeah, just an example there. And in this contract as well, there's like request ethereum price, which gets the latest price of ethereum. Pretty simple. Request, the daily change, it's all using the same API, but it's just like a simple example, just different endpoints. And the last market where it got that value from. For example, I could show you, this is the one I called earlier for the change in a day. So the reason you see it being a larger value like that is because obviously it's not floating point precision in solidity and ethereum.
00:26:16.500 - 00:27:34.690, Speaker A: So what it does is just multiply the value and then if you wanted to use that value, then you can divide it by whatever it's multiplied by, just so it keeps like, the decimal points and you get actual accuracy when you're getting the value. Questions? Yeah. Oh, there's just quickly, it's on the workshop page as well on the documentation. So it's just like Robston chain link and you go on that page, it'll ask you for your address and it'll send you some link. All right, let me it gets saved in the same contract. So you'll see like there I'm just calling some instance variables on the contract and you'll see breach request method. There's also what we call a fulfillment.
00:27:34.690 - 00:28:28.720, Speaker A: Yeah. So for example, if you want to call a different API or get different data, then deploy your own contract. But all you have to do to work with chainlink is just implement our chainlinks contract and then you'll get all the methods to be able to create chainlink requests. We have contracts what we will maintain just in the future for the decentralization they're not owned by anyone. It's just contracts what create different objects for managing different things. But all you do is we have an NPM repository. Just install it, import the contract, which like the chain links contract.
00:28:28.720 - 00:29:16.620, Speaker A: Yeah, yes. You can design your contract in a way where people can just get the last price. So, for example, on fulfillment, it stores the price to state. But like, for example, you could rather than just storing one price, you could store the timestamp and the price and then people using your contract can get the price. Check the timestamp, see if it was in their parameters, whether it was like 1015 minutes ago or two minutes ago, for example. Flexible. You can do it.
00:29:16.620 - 00:29:29.160, Speaker A: Oh, yes. Worth mentioning the bouncer. So we are holding a bouncer. The best person who uses chain link in the best way, you'll get $1,000 worth of link token.
