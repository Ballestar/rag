00:00:00.250 - 00:00:32.614, Speaker A: In some DEXes we use something called ticks. And what a tick is is it's a way of splitting up the range of prices into a finite set of values. So to allow liquidity providers to choose a finite price range, we split the price up into these ticks. And you can imagine it looking something like this. Every tick is one of these powers. So this is tick zero in the middle. And what that represents is a price of 1.1.
00:00:32.614 - 00:01:10.914, Speaker A: Tick number one is 1.1 to the power of one and so on. And that goes off in both directions. And so splitting the price up into these ticks, instead of having an infinite number of different prices, allows us to enable liquidity to providers to choose the upper and lower bound on where they want to provide liquidity. So if you want to provide liquidity from a price of 20 to 50 USDC per uni, you can do these quick logarithmic calculations. And these are the two ticks that your liquidity would be provided between. So they're equal to 1.1
00:01:10.914 - 00:01:52.994, Speaker A: to the power of 29,900 and that gives you the price of 20. Sounds kind of confusing, but lots of this is done in the background. And at the end of this presentation, I will show you where in our code you can integrate. So you don't have to understand all of the complex math that's going on in the background. So actually in the contracts we implement a square root price for various technical reasons. I'm not going to go into those technical reasons today, but if you want to understand more about why we implement it like that, then you can take a look at the Uniswap V three white paper. But for now, the understanding of it being a power of 1.1
00:01:52.994 - 00:02:49.118, Speaker A: is enough to understand the rest of the presentation. So additionally, uniswap v three has these things called fee tiers, which is essentially we have three different pools for each token pair. So where in uniswap v two and in other decentralized exchanges, there is one pool per token pair with a certain fee that goes to liquidity providers. Uniswap v three provides three different fee tiers one where the liquidity providers get zero 5%, one where they get 0.3%, and one where they get 1%. And what this allows is for liquidity providers who are giving liquidity for more volatile and more risky assets, they can choose to take a higher percentage fee to sort of support their risk. And for super stable assets, let's say you were providing liquidity for USDC Dai.
00:02:49.118 - 00:03:38.500, Speaker A: You can choose to take away smaller fee because you're not really taking on much risk with those assets. So that's what this says at the bottom here. So the way we record prices in the contracts is using something called observations. As trades are made on uniswap, the contracts record something called observations in an array. These observations mean that you can access historical price data on chain, which you can't normally access. Historical state of a smart contract. So recording these observations as time goes on means that in the current block you can access the tick that a pool was in, aka the price that the pool was in in a previous point in time.
00:03:38.500 - 00:04:25.822, Speaker A: So the array looks something like this. Let's say the observations array had five spaces. We circle around overwriting previous values, so there's always the five most recent prices are stored. So if you had an array like this, which is observations 13 through to 17 and you wanted to now write observation 18, it gets written in to our pool contract over observation 13. So you always have the five most recent observations. What is stored in those observations from the tick point of view is something called the tick cumulative. So we don't just store what tick I e what price the pool was at at that moment.
00:04:25.822 - 00:05:34.022, Speaker A: We actually store something called the tick cumulative at that moment, which is essentially the sum of all of the ticks so far in the history of the contract at every point in time. So at time zero, the tick was added to it, and then at time one the tick gets added to it again and that continues onwards. So if you have the cumulative tick at point n and point n plus 30, so that's 30 seconds apart. So you can get those two readings from the observations array, the tick cumulative now, let's say, and the tick cumulative 30 seconds ago, you can subtract one from the other. And that then works out to give you the sum of the ticks just between those two points in time. And if you then divide by the number of seconds that have passed, it gives you the average tick or the average price for that period of time. So that's then giving you a more manipulation resistant tick or a more manipulation resistant price.
00:05:34.022 - 00:06:58.882, Speaker A: Because if you just take the current price, someone might have quickly done a trade to push it either up or down in their favor, whereas this gives you the average price over a period of time of your choosing, so that if someone changes the price now, the average isn't as affected by that. So the tick isn't actually the price, it's just as we saw earlier, it's a power of 1.1. So we can put our average tick that we calculated on the previous slide into our formula and that gives us the price. This all seems probably quite confusing, but there's lots of helper functions to abstract away the math in the background and to help you with that. So, if you look at the uniswap V three periphery GitHub, you will find something called the Oracle Library, and there's currently also a contract called the Weighted Oracle Library. The two of them are about to be merged, but currently both of them exist and the two of those provide you with some helper functions. So to get the mean tick over a period of time from a particular uniswap pair or pool, you can call the consult function and that will return you the mean tick over that time.
00:06:58.882 - 00:07:57.830, Speaker A: Then to turn that tick into a price or into a quote, there's another function in the Library where you give it the two tokens, you give it the tick and it will output the quote for you so that you don't have to understand all of the math that's going on in the background. We've implemented that for you. There's a number of other helper functions in there, including methods to help you average the tick across different fee tiers, if that's something that interests you. Or you can just choose one fee tier pool and purely consult and get quotes at that. So these are the functions that should be helping you this week during the hackathon, the V Three periphery GitHub has a load of other helper libraries to help with other things on uniswap V Three Two. So feel free to browse through all of those. And the Oracle Library and the Weighted Oracle Library will be where you find helper functions for creating an onchain V Three Oracle.
00:07:57.830 - 00:08:03.800, Speaker A: So I think now we go to questions.
00:08:08.830 - 00:08:27.390, Speaker B: If anybody has questions for Alice, please feel free to drop it in the chat or unmute yourself and ask directly. It can be on anything that she covered in the session or maybe something else related to uniswap. Don't be shy.
00:08:29.250 - 00:08:33.600, Speaker C: Hi, I have a quick hello.
00:08:33.970 - 00:08:34.766, Speaker A: Hi.
00:08:34.948 - 00:09:32.980, Speaker C: Yes. My question is, let's just suppose there is a big spike in the price of the token at any point. But if I do the query and I see by the Oracle, I'll get a price which will be much lower than that at that point of time because it's averaged out. So in that case, the price Oracle that I get, would that be useful? It won't be useful because the actual price of the coin or token or whatever has gone up. But I'm still kind of what I'm saying is the price we get from the Oracle would be smoothened version of the price versus the reality what happening now. So what we do in that situation, how is that price useful at that point?
00:09:33.910 - 00:11:12.674, Speaker A: Yeah, it's a tricky balance to try and get between ensuring you have an up to date price and not a stale price, which is the situation you're talking about, but also trying to make sure that if someone wants to manipulate the price and steal money from a protocol, that they can't do that. So what our function allows you to do is, do you remember when I said you can provide a number of seconds over which you want your time period? So if you want a super up to date price that is not smoothed out at all, you could look at the current price, however, that's then subject to manipulation by individuals, particularly individuals with a lot of money or with a flash loan. And the larger you then make that interval of time, the less manipulable it is, but also yes, the less up to date it stays with the true current price. So that's just a decision that each individual protocol developer has to make. How much manipulation are they willing to accept versus how stale are they willing to allow their price to be? So you could take an average of the last minute and that means that if someone's manipulated it in the last block, it won't change so much. You could do it over five minutes, half an hour a day. It really depends on your individual application of how much risk you're willing to take of someone manipulating the price purposefully versus how stale the price can get.
00:11:12.674 - 00:11:16.070, Speaker A: And that's just a decision of individual protocols.
00:11:18.170 - 00:11:52.490, Speaker C: So you're basically trying to say that we are creating a use case where a more secure use case or kind of something sudden spike occurs. You don't want to participate in that kind of euphoric going up or down. If somebody wants to avoid that, they can rely on these price codes. And again, as you said, that we can define the time horizon. So we can go back and forth in terms of, like you said, how still the data you want to get. Yeah, right. Yeah.
00:11:52.490 - 00:12:13.506, Speaker C: And my second question is chainlink. I think the chainlink product also they have their price work as well. How do you different mean? Is it just another kind of like that or something different, something strategic in your implementation?
00:12:13.698 - 00:12:54.210, Speaker A: Yes. So the way that Uniswap works is it's getting its prices from the Uniswap exchange. So when individuals are trading different tokens for each other, the price is all recorded on chain. And so we are fetching that price from the actual trades that are happening live on Ethereum. The chainlink Oracle isn't actually based on an exchange. It's a certain number of pre approved parties who can submit a price to the Oracle. And the Oracle then looks at all the submissions from the approved parties and averages out the price and people can go and look that up on chain.
00:12:54.210 - 00:13:21.200, Speaker A: So Uniswaps is decentralized in that everyone's trades contribute to the current price and it's just looking at the actual market on chainlinks. Chainlinks is a certain number of pre approved parties submitting a price that they are fetching realistically from an exchange somewhere. But it's not prices coming directly from that exchange itself.
00:13:24.690 - 00:13:26.080, Speaker D: I have two questions.
00:13:27.410 - 00:13:28.160, Speaker A: Yes.
00:13:30.290 - 00:13:41.220, Speaker D: Sorry. First of all, I'm just curious if you have a sense for how much traffic is on V two versus V three.
00:13:43.350 - 00:13:58.540, Speaker A: Yes, we have stats on that on our website. You can see graphs of how much volume is done on unisoft V three and Unisop V two each day. I haven't looked at the graphs in the last few days, but you'll be able to find that on our website.
00:13:59.470 - 00:14:08.940, Speaker D: And would you expect that whichever one has more traffic would be more accurate, or that's not necessarily true because of the way you changed it.
00:14:09.970 - 00:15:16.802, Speaker A: So actually, with uniswap v three, the way that liquidity is provided means that trades cause the price to change less extremely than they did on uniswap v two. So in general, we think that uniswap v three prices are going to be less manipulable, even over a smaller amount of liquidity on the protocol, just because of how the prices are. Because of how liquidity is provided, the prices are also calculated differently. On uniswap v two, it was an arithmetic mean, and on uniswap v three, it's a geometric mean. So you're welcome to go and read about the differences between those two types of means. But in general, it means that v three will probably track the current price slightly more closely. But if you read about the ins and outs of arithmetic and geometric means, there are pros and cons of using each of them.
00:15:16.936 - 00:15:28.098, Speaker D: Sure, I'd definitely do that. And the second question is, you mentioned that there was like a circular queue, I guess, for the historical balances. How big is that queue?
00:15:28.274 - 00:16:16.050, Speaker A: So each pool is initialized with a queue of just one, and anybody can submit a transaction that increases the size of the queue. So it starts with just an array of one, where it only ever has one observation that continually gets overwritten. And obviously that's not very helpful if you want an average price over a period of time, because you need two data points to do that. I haven't looked recently at how many observations the major pools have, but certainly some of them have had those increased by protocols. So if a protocol knows that they're going to want the USDC ETH price regularly and they're going to want ten observations, they can just quickly send a transaction that increases the size of the array to ten and the pool will forever then write at least ten until someone increases it further.
00:16:16.210 - 00:16:18.920, Speaker D: Is there any limit on the size of that number?
00:16:20.330 - 00:16:29.260, Speaker A: I believe yes, but it's huge. I think it might be 65,000 ish the power of two. That's around 65,000.
00:16:30.430 - 00:16:31.420, Speaker D: Thank you.
00:16:37.970 - 00:16:49.742, Speaker B: Great. And there's also a question in the chat from It Burns. Is there an indexer we could use right now? Something implemented over the graph?
00:16:49.806 - 00:17:27.774, Speaker A: For example? There is a uniswap graph or subgraph sorry, that I'm sure you'll be able to find on the graphs website that will record historical trades. In general, if you want to implement an Oracle, that would be used for implementing it on chain so that smart contracts can access the price. So the presentation that I've just explained is for on chain pricing. If you want off chain pricing, then yes, you can go and find the uniswap v three subgraph and you'll be able to find prices of transactions from.
00:17:27.812 - 00:17:54.550, Speaker C: That'S another question I have is you said that you observations of any transactions now there are different tokens, so many permutation combination of tokens. So are you saying that store all those observations in the chain?
00:17:55.450 - 00:18:31.460, Speaker A: Yes. So each pool that people can trade on is only for two tokens. So if you want to trade ETH for USDC, you would go and find the ETH USDC pool that has just ETH and USDC inside it for people to trade and that records its own price observations. So the observations within that smart contract only record the price for ETH USDC. If you want the price for a different pair of tokens, you would go and find the pool relating to that pair and the observations for that pair are in that smart contract. Does that make sense?
00:18:31.910 - 00:18:33.460, Speaker C: Yes. Thank you.
00:18:38.700 - 00:18:41.288, Speaker E: I have a question, can I ask?
00:18:41.454 - 00:18:42.072, Speaker A: Yes.
00:18:42.206 - 00:19:11.760, Speaker E: So who initializes the pool? Do you whitelist the tokens and how does it work like the first initialization, like how much liquidity one should provide? Should one provide both tokens or only once or only one token? Can you a bit make a short simulation in words of a pool initialization?
00:19:13.540 - 00:20:03.010, Speaker A: So anyone can deploy a new pool for a token pair if it doesn't already exist. There's a factory contract that is provided by uniswap and you just say the two tokens that you want and if that contract doesn't already exist, it'll give you the option to deploy a new one. And you can do that through our interface. It's obviously deployed with no liquidity and whenever you add liquidity, you add it at the going price. So I believe the first deposit of liquidity you can add at any ratio, that would quickly get traded of course to the current going price. And anytime anyone adds liquidity to a pool, they have to add the liquidity at the current ratio, which is the current price. So that adding liquidity, you don't alter the price.
00:20:03.010 - 00:20:07.830, Speaker A: Was there anything else you asked?
00:20:09.000 - 00:20:12.070, Speaker E: No, it's fine, I think. Yeah.
00:20:18.790 - 00:20:30.630, Speaker B: Has anyone else got a question for Alice? Feel free to unmute or drop your question in the chat. I see. There is another question here. How is the price for the first trade defined?
00:20:31.710 - 00:21:03.650, Speaker A: It's just defined by the current ratio of the liquidity. So if there's one ETH in the pool and there's 4000 USDC, then the current price is 4000 USDC per ETH and that price will change as you make the trade. So you'll end up with a slightly different price for your trade, but that's how the initial price of your trade is calculated. So really the initial trade price is calculated by is set by whoever first adds liquidity to the pool.
00:21:10.810 - 00:21:58.660, Speaker E: Can I ask you another question? Sorry? Is there any fully view function, like solidity view type function, which can provide the uniswap price? So without using an off chain quota or a lens function or something that maybe we can integrate directly on our contracts and because it's difficult to access your storage right, to see your previous observations, therefore this makes the things a bit difficult. So what's your opinion on that?
00:21:58.970 - 00:22:57.190, Speaker A: So there is on each pool, the current tick is made public and using the formula that I showed earlier in this presentation, this is being recorded so you can come back and reference it. You would be able to calculate the current price so you could plug the current tick value that the contract provides. You do it 1.1 to the power of that and a square root and you'll get the price of the pool at that current moment. But that is a spot price which should not be relied upon in DeFi protocols because it's manipulable. Someone can quickly do a large trade and alter the price so that they can then use that to their advantage in your protocol. The way to get a more resistant price is to do a time weighted average price over time.
00:22:57.190 - 00:23:41.410, Speaker A: And you should be able to very easily use this Oracle Library. It exposes everything you need to calculate that price on chain. If you call the consult function for the pool that you want to query and you give it the period of time you want to query it over, it'll give you the tick, which is the price. And depending on the amount of time you provide it, that is less manipulable than the current price that you would find in the contract. And then you can pass that tick into get quote at tick to get the actual current price. And you don't have to do any of that math yourself. And I would recommend this over just looking at the current tick in a pool.
00:23:41.990 - 00:24:00.140, Speaker E: But this price is reliable only within two initialized ticks, right? Like if a swap is too big and it crosses a tick, the actual value that you will get in a swap is more. It's not simply not that the price times the amount.
00:24:01.710 - 00:24:11.230, Speaker A: Yes. If you trade, I think this is what you're asking, if you perform a trade, you don't get the current going price because of slippage.
00:24:12.530 - 00:24:16.586, Speaker E: Yes. And tick crossing also it's a thing, right?
00:24:16.708 - 00:25:07.380, Speaker A: Tick crossing is just slippage. When the price changes as you make a trade, the price on chain has to change and the price changing means that the tick might change. And if you cross a tick, it just quickly removes some liquidity and adds some other liquidity to the pool. That tick crossing will be recorded as an observation under certain circumstances. I won't go into the exact circumstances that cause an observation, but there's certain things that cause that and those observations are what are looked at when you call the consult function. So actually calling the consult function, it includes tick crossings, it includes when people have added liquidity, it looks at all the observations that have occurred instead of just looking at the current tick thanks.
00:25:14.150 - 00:25:44.950, Speaker B: Great. Has anyone got any last questions for Alice before we close out the session for today? Okay, great. Thanks so much, Alice, for the great session and for handling all the questions coming in. If you want to connect with the Uniswap team, they are in the sponsor Uniswap channel in discord. And yeah, feel free to drop your questions there if you think of anything else. Thanks again, Alice, and thanks everyone for joining.
