00:00:03.750 - 00:00:41.640, Speaker A: Hello everyone. So I will do a quick introduction on Oracleize. So how many of you know what Noracle is? Excellent, so I don't have to waste half an hour to explain that. Maybe just a few minutes. So we have rebranded like a couple of days ago to provable to better represents our new strategy going forward. You will see that in the initial part of the presentation. So what we have traditionally been doing is solving the Oracle problem.
00:00:41.640 - 00:01:52.882, Speaker A: What is that problem? Basically that blockchain applications live in a walled garden. They are not capable of reaching out to the internet and it's impossible to get data from a solidity smart contract, for instance. So what you want to do is basically somehow circumvent the limitation so that you can implement data rich smart contracts and have maybe a smart contract that triggers a payment or some actions depending on real world events. So on paper, the solution has been called the blockchain Oracle. Basically, and this is something that in theory has existed for a while, even before Ethereum came to life. But in practice, the need for Oracles is very recent because of the complex smart contracts and DApps that are being built today. So the Oracle is basically an entity that somehow it's not important how at the moment connects the external world with the blockchain.
00:01:52.882 - 00:02:42.938, Speaker A: The blockchain is like isolated. So in order to keep the rest of the presentation consistent and to facilitate the understanding, I think it's useful to define the main entities with just three simple names. One is like the application in the blockchain space. We typically call it DAP or smart contract, it depends. But this is basically your piece of code that is basically in need of data. This is the data, the data source. So basically what you would like to reach out to, and normally in a normal application, you would just do maybe an HTP call to their web APIs or something to get data from there.
00:02:42.938 - 00:03:21.346, Speaker A: So that's typically one line of code in most languages, right? Just call the API, maybe it's a public API, no even need of authentication. In like a few seconds you're done, you have the data. It's probably in JSON formatted, so you can read it very easily and very quickly. Unfortunately, from the blockchain it's not possible. So if the application is isolated, you have the Oracle that solves the problem and the Oracle could be anything. It doesn't need to be approvable, it doesn't need to be Oracleized, it doesn't need to be chainlink or witnessnet. I mean, it could also be the data source directly pushing the data to the blockchain.
00:03:21.346 - 00:04:15.558, Speaker A: For example, Thomson Reuters, which is a very common financial data source, has an integration with the blockchain. So there is no need to use a third party Oracle to connect Thomson Reuters data with your application. You just go to Thomson Reuters and they do both data source and Oracle. Unfortunately, this is not very scalable because it's unlikely that all the data sources on the internet will adapt to the blockchain and will integrate with Ethereum Mainnet for different reasons. So the ambition here is basically to enable a seamless connection with all existing data sources with a blockchain, with no need for the data sources to adapt and do the heavy lifting and the hard work that for example, Thompson Reuters decided to do. So Provable is basically enabling death. We have been doing that since 2015 on Ethereum.
00:04:15.558 - 00:05:05.066, Speaker A: We launched on September 2015 on the Herm Main net and the way we have decided to do it at the beginning was driven by the context of the market. We found basically there was nothing on Ethereum back then. So we had to design a protocol to get the data. We had to run the actual Oracle so be an operator to keep the service up. And also we had to try to understand what people wanted because there was no one building applications in need of data on the blockchain back then. So it was a big gamble we decided to take and actually the traction started coming a couple of years later. So what does it mean? Well that historically Provable, which it was called like Oracleized 1.0
00:05:05.066 - 00:05:57.958, Speaker A: if you want, has been a centralized service because we were the operator running the entire thing. So this seems like to make little sense because the application like the blockchain is decentralized. This is the value proposition in most cases, like let's keep decentralized, we don't want central counterparties. Still in most cases the data source is centralized. Like you want to get data from a single web API or from few web APIs that maybe the end of the day get their own internal data from the same source. So what happens? Well, that basically here you don't really want to compromise the security of the system, so you don't want to lose the decentralization and you don't want even basically the data to be tampered with during the delivery process. So the Oracle in between needs to somehow guarantee that the data has not been tampered with and that it's safe.
00:05:57.958 - 00:07:02.090, Speaker A: Garbage in, garbage out. So if the application is perfect, decentralized and transparent, but then you feed it with garbage, the payment maybe is going to be triggered correctly, but on wrong inputs, so wrong outputs, right, that's what you want to avoid. And we have been doing that via providing some guarantees we call authenticity proofs. So the authenticity proofs are basically some proofs that try to show that the data fetching process that the Oracle did from the data source has been done in an isolated way, so that basically there was no possibility to manipulate the data and that the data is authentic. So these are the integrations we are currently running. Like we have integrations with all those different blockchains because 80% of our work is off chain is in securing the data fetching process and generating those authenticity proofs. Then there is a small integration layer on each one of those blockchains.
00:07:02.090 - 00:08:14.566, Speaker A: And as we have announced few days ago on Ethereum we have been just running our own integration as on all the others, but we will be supporting for the last mile also other protocols such as Chainlink or Witnet and few others that basically have the aim to basically decentralize the network of node operators. Right now we are the only node operator on the main net, basically for a general purpose data fetching. One day if people will decide to value decentralization of this service, they may decide to choose Chainlink or something else and maybe delegate this task to more nodes, to more node node operators. So in the rest of the presentation, I will be showing the existing interface of Oracleize, which is the one you find on every blockchain and on the theorem main net. And this is the one that is being used by approximately 1000 projects on GitHub. So if you go on GitHub and look for the Oracle API you will find like I think now it's a bit more than 1000 repositories making use of that for their Ethereum projects. And these are some statistics that we have collected to basically show what those projects are building.
00:08:14.566 - 00:09:32.030, Speaker A: Like those data reach DApps and I think it's quite interesting to see that a big chunk is gambling, right? The blue one is gambling, surprise, surprise, Ethereum mainnet as the entire ecosystem basically has huge ambition to decentralize finance, insurance and so on. But data rich DApps at the moment, as for the number of application at least is mostly leveraging like crowdfunding which is ICOs and assets and tokens that use it internally for the non logics. And gambling. Finance is here, insurance is here, so they are part of it, but the number of applications is still limited. So I don't want to spend too much time now on explaining how this works because we will be around me and the rest of my team here. So if you want to ask some questions, more technical questions on how this works under the hood, we will be happy to answer. But in general, these are the two keywords like blockchain of course that's the interface like where you want to use the service on and this is like how we secure the data fetching process.
00:09:32.030 - 00:10:31.714, Speaker A: So the authenticity proofs are based on technologies like intelligent ledger, nanos, TLS notary, which is a software isolation technique and few others. The idea is always the same, which is basically let's prove that a secure enclave, a secure isolated process, provably isolated process has done data fetching so we couldn't tamper with it. So basically the guarantee you have right now with the traditional Oracleized 1.0 service is that if Oracle is the Oracle answers, then the answer is correct because you can check the authenticity proof. But the Oracle may not answer so this is the risk you're taking with our traditional approach. And that's why projects such as Chainlink are trying to decentralize that. So that basically it's easier to basically expect that it will answer, which is important if you want an application that keeps running for a very long time and you are afraid that the Oracle may disappear in a couple of years or in something like that.
00:10:31.714 - 00:11:15.166, Speaker A: Right. Still, if you are a developer and you expect to build on something like that, you have to do basically your own math and decide what you need, because decentralization is very important. But right now we don't see the actual market valuing it much like we see it also with ICOs. We see it with many different other components in the network. We give the tools to the community and we do a lot of work to give the tools for the community and nobody cares. They just want to buy the NFT, they want to invest in the Dao, they want to invest in the ICO before the contract is verified, before the contract is public. They just don't care.
00:11:15.166 - 00:11:54.734, Speaker A: So we don't know yet how much people will value decentralization. If they don't value it at all, the entire blockchain movement will probably fail. So we hope they will value it at least a little bit, but we don't know how much they will value it. So the idea is that the existing Oracle interface fits really well. As for gas efficiency, for example, if you don't care too much about the risk of the Oracle potentially not answering in the future. So if you're building a DAP where for example, you are the administrator, that's probably not a big deal because you are the point of failure anyway and people are trusting you. So that's not a big deal.
00:11:54.734 - 00:12:52.094, Speaker A: But if your application is supposed to be fully autonomous and run forever with no changes or something like that, you are encouraged to look for some other approaches that give you those kind of guarantees. But our aim with the traditional interface, which is why we have decided to keep it, to keep the traditional one is to be as efficient as possible. So since the traditional Oracle is 1.0 interface doesn't need to support a decentralized service, the idea is that using that one you get the cheapest gas cost you can because the layer is so thin that it's impossible to make it cheaper. For example, you don't need to use token to secure the decentralized incentive system, you don't need to have different layers in between to solve disputes or anything like that. It's like as thin as possible. While if you want decentralization on other things, we will be operating also on other networks such as Chainlink, which is here as a sponsor as well.
00:12:52.094 - 00:13:26.640, Speaker A: And you can just basically use Oracle via Chainlink or Oracleize and other nodes, or just other nodes. It's up to you. So basically these are the features of the provable service and in general, the existing interface we have is also very simple. Typically you just use one function where you specify the URL you want, which is the API call in 99% of the cases you want to make. So you will see an example shortly. It's really simple. Basically this is the line of code.
00:13:26.640 - 00:14:02.518, Speaker A: Sorry, the contract is quite old, I will show you an updated version in a second, but the logic is the same. Basically you decide how to secure the data fetching process. So what kind of authenticity proof you want? Here we have selected TLS notary you can select others. And here you're just saying reach out to the Oracle. This is my task. I want to get the data on the Ethereum price in US dollar from cryptocompair. The process is asynchronous.
00:14:02.518 - 00:14:58.060, Speaker A: So basically the first transaction will reach out to the Oracle. Then the Oracle needs to basically process the query and it will send back a transaction. So the Oracle will reach out to your contract calling your callback function and the callback function guess what contains the result and the authenticity proof. And the authenticity proof can be verified. If you look in our documentation, you will find more details out of scope here, but you can verify the proof depending on the way you use the service. There is a different cost to verify the proof right? Now, for example, if you ask for a random number from a ledger device, like a ledger Nos, we have a custom application, it is open source and anyone can verify. You can check that the random number we generate comes from there and you can verify on the blockchain the authenticity proof at a cost of approximately 100,000 gas, something like that.
00:14:58.060 - 00:15:54.810, Speaker A: And then you can do whatever you like with the data, right? You can just continue from where you left your logic flow in the application. So that's the part for the random number generator. So if you care about this use case which is basically gambling few others probably we have released a paper analyzing the differences between this trusted computing based approach for the generation of random number outside of the blockchain and existing ways to do that without using trusted computing. Like the most trivial approach is commit reveal scheme, right? There are many other ways to generate random numbers. We also know about the other upcoming approaches to generate randomness on chain. We may be with the beacon on future Ethereum 2.0 versions, but they all have some kind of limitations.
00:15:54.810 - 00:16:45.520, Speaker A: Like for example, in the case of the beacon, you have just one random number every six minutes. In the case of commit revision scheme, it doesn't work well with applications where the bankroll, for example in casinos is shared among investors. I mean, it's quite complex. But if you look for this white paper we released a couple of years ago, there is a complete analysis comparing the trust assumptions we make here with the trusted computing technique with all the other existing systems. Of course you can use it also to delegate to an off chain context the execution of a piece of code. It's the same logic. Instead of asking to the Oracle to basically get data from a web API, you ask the Oracle to execute a piece of code and give you the result.
00:16:45.520 - 00:17:50.660, Speaker A: One nice side effect of using a trusted execution environment is that you don't need the process to be fully deterministic because it will just be executed once you want and you will be able to prove that that execution has really happened within a trusted execution environment. However, if then you want to maybe aggregate this data with something from other node operators or something from other Oracles that do the same, you need to ensure on your side that the execution is deterministic or that you have defined an aggregation method that makes sense. For example, if you generate a random number, of course the different Oracles will find a different one. So then you need to understand how to aggregate it in a way that makes sense and doesn't break the security properties. So yeah, this is basically the description of Oracle 1.0 which we keep offering. So it works with any web API and these are the technologies you can select at the moment.
00:17:50.660 - 00:18:34.620, Speaker A: And yeah, this is basically what has been used in the wild by most projects. Like on the main net we have processed 1 million transactions to date in like four years basically. So some useful links if you're a developers developer basically this is the support channel on GitHub. Here there is the Ethereum API one for the interim interface. This is the documentation docs Oracle. It contains pretty much everything and I will show you some examples in a second. This is the main slide.
00:18:34.620 - 00:19:24.796, Speaker A: If you are a developer, you should probably take a picture in case you are interested to use it. So basically if you want to use Oracleize on a private chain, this is possible and is being done by a lot of people, especially during development. You can just download this tool called the Ethereum Bridge. And the Ethereum Bridge is basically node tool that injects the Oracle contracts and interface on your local chain, so that you can test it in memory or on your own local setup, basically. So you can test the Oracle based contracts on any context without needing to change even a single line of code. It just works in the same way as it would on the main net or on all testnets. We are integrated with all testnets.
00:19:24.796 - 00:19:50.308, Speaker A: Basically. You can also use it just in memory. If you are familiar with Remix, like Remix Ethereum.org, you go to the official one. In the settings section there are some plugins and there is the Oracleized one. You can just click the Oracle button and it's integrated straight away in the memory execution you can test it. There are some other useful pages here to verify the proofs of chain if you prefer.
00:19:50.308 - 00:20:22.724, Speaker A: This is a tool so you can verify if for example the 1 million proofs we have sent back on main net are valid or not. So you can see if we have ever cheated in the last four years, basically. And that's pretty much it. So I will show you now. This is a test query page. The test query page does what you would expect it to do. Basically you define what's the query for example here you just say fine.
00:20:22.724 - 00:20:48.376, Speaker A: This is an HTP get request, very simple. And this is the API I want to call. Could be any API. There are some helpers such as the JSON one so that you can filter down the full response to just the piece you want. But you don't have to do that, it's just for gas efficiency. Then you just click on test query if you want. You can also select utility proof for testing.
00:20:48.376 - 00:21:36.376, Speaker A: It's not needed in production, definitely. Then you wait and here on the bottom you will find I should have duplicated the screen and basically you get the result. It's exactly the same you would have by doing the Http call yourself. That's trivial, but doing it via this page gives you the exact response you will get via Provable, basically. So if you go to our GitHub repository there are many repositories. And for Ethereum, like Ethereum Examples is a repository which contains many examples. So I guess nobody is using Serpent anymore.
00:21:36.376 - 00:22:26.056, Speaker A: Today we had an API for serpent as well, but in Solidity you just go here there are more complex examples within the folders. In the main one you have these simple examples such as I don't know, diesel price for example. It's the exact same format you have seen in the slide, right? Just Oracleized query. You define the query. This is XML. You can use XML filtering and you get it in the callback, right? Well the documentation docs oracleize it again. If you go to the Ethereum section there is a quick start and you find also best practices during the Akaton.
00:22:26.056 - 00:23:31.424, Speaker A: It's not that important to follow them maybe because you don't have time and typically everything is just put together pretty much randomly from my experience. But if you go to production, please go back to this section and read it because it's important also for security considerations to prevent common mistakes or issues. Last but not least the Remix integration. So that's the plugin. Basically it's quite useful to get started because without having to set up the Ethereum bridge on your local chain or to send a real transaction on the main net you can just use Remix and do an immemory execution and test the setup with your acquirers integration. This is just a stupid contract that basically keeps getting the price of Ethereum in bitcoin, I think via the Kraken API. It does it continuously.
00:23:31.424 - 00:24:05.740, Speaker A: So this is really bad to run on mainnet because this gets very expensive very quickly. But I mean, for testing it's quite interesting. So again, to enable it, you just have to go to Settings and Plugins. Here you find a list of plugins that are integrated with Remix. Oracle has been the first one being integrated. So that's why it's here. If you click, you find something like that, which I admit looks ugly, but it works and does the job.
00:24:05.740 - 00:24:59.742, Speaker A: So now you basically have to somehow move this window, which is always challenging. I did it somehow. And then you just compile the contract. This contract? Well, I already compiled it. Well, let me do it again. Because you compile the contract and you deploy the contract, it should like in the constructor, this is reaching out to Oracleize. So when you click on Deploy, in theory the plugin will show you that you have reached out to Oracle with a query.
00:24:59.742 - 00:25:28.670, Speaker A: It will show you some details on the query and the fact that there is no result yet because it's being executed off chain now. Right. So this is a simulated execution of the blockchain in memory. And also the integration with Oracleize is just in memory. It's just being run live. And here Oracle is has returned the result and sent back the transaction. So then in the console you can just read what it did and go on as usual with Remix.
00:25:28.670 - 00:26:35.530, Speaker A: And this is quite convenient for testing. Also, something that should work is that when you click on this ID here, which identifies your query, it should send you to an external page to check the query status on the Orclize panel. So you can see under the hood what's going on. If you have selected a proof, what's the proof, and how long it took to generate all this kind of stuff, that's pretty much it. If you have any questions, I think we have still between one and 60 seconds left. Thank you. Any question? Trustworthiness is a very interesting word.
00:26:35.530 - 00:27:17.696, Speaker A: So if I was asking you what's the temperature here, I'm sure the majority of you will go on Google and ask Google and consider it trustworthy. The reality is that you don't know even where Google got this data from. So trustworthiness is not within the scope of the Oracle. It's on the developer to choose what your application can consider trustworthy. So my suggestion is to select independent data sources for the same data when possible. Like the temperature is an easy example and maybe you can find five data sources or something and try to aggregate the data coming from them. Still, this gets very expensive.
00:27:17.696 - 00:28:06.260, Speaker A: This is why it all comes down to the cost of decentralization. Do you prefer to give to your users of your application a cheap interaction with the contract with one or two point of failures or do you prefer to make it super safe, but make the interaction much more expensive? I don't know. I think it should be on the developer as a choice. And this will be reflected on the adoption of their platform, which depends on the use case, I guess. I mean, the role of the Oracle is the one of proving that the data is authentic and is coming from the data source. Then if the data source has compromised the data or is lying, that's not a problem of the Oracle. That's the problem of the data source the developer has chosen, which was not trustworthy after all.
00:28:06.260 - 00:28:39.908, Speaker A: So the Oracle is not about this is not about trusting the Oracle. It's about using the Oracle as a data transport layer to get the data from the Internet. When you write a piece of code in Python, out of the blockchain or whatever language you like, you call a web API. So is the data trustworthy? Well, it's not a problem of the library you used for the request. It depends on the data source on the web API you are calling. Thanks again. If anyone has questions, I will be around.
00:28:39.908 - 00:28:40.130, Speaker A: Thanks.
