00:00:11.210 - 00:00:50.262, Speaker A: Hey everyone. I'm super excited to welcome you all on this workshop. So today we'll be talking about Vaults Protocol and how you can go about building the future of DeFi on top of Vault Protocol. So my name is Arthur Begian. I'm the CTO and co founder at Pulse Labs, the company behind the creators of Pulse Protocol. If you ever have any questions or just want to have a chat, feel free to ping me on discord or Twitter and yeah, let's start. So the agenda for this talk is kind of split up into a few parts.
00:00:50.262 - 00:01:42.190, Speaker A: Initially, we will talk through the kind of the bounties, the rewards that you've prepared for the ETH Amsterdam hackathon. Then we'll briefly talk about Vault's Protocol and how it works and how it delivers on its promise of effectively creating capital efficient interest rate swaps on top of DeFi. Then we'll dive into the developer resources it can leverage to kind of build on top of Vault and kind of bring the next generation of dividend products into life. And then finally we'll conclude with a dev workshop where we'll together kind of build a liquidator bot on Top of Votes Protocol and then in the end let you guys ask any questions you have. Cool. So for Vaults, we have kind of brought $8,000 worth of bounties for the developers that choose to build on us. So for the most useful application, we'll be distributing $4,000.
00:01:42.190 - 00:02:38.746, Speaker A: For the most creative application built on polls will be distributing two point five K dollars. And we also have another tier, which is for another interesting application, which is going to be $1.5 thousand. So, I guess what's? Bolt protocol? When thinking about Volts Protocol, you can effectively define it as a kind of non custodial market maker for interest rate swaps. And you can think of it as like the dYdX for interest rates. If you think of dYdX as a protocol where you can effectively showcase your views on directional price movements, you can think of Bolts as a protocol where you can showcase your views on directional interest rate movements. So before we dive into the actual mechanics that enable Vaults Protocol to shine, be good to talk briefly through what interest rate soaps are and kind of what they mean in the context of traditional finance.
00:02:38.746 - 00:03:56.742, Speaker A: So if we think about traditional finance, the amount of notional that gets traded annually in interest rate swaps is around $1 quadrillion, which is just an immense number which shows effectively how big this market is. But if you ask a retail user, like a typical average person, they wouldn't really know and they wouldn't really tell you that they have used interest rate swaps directly. But if you want to think of the most obvious use cases where interest rate swaps are applied, you can think about mortgages, you can think about fixed rate loans. All of them, in one way or another, leverage an underlying interest rate swap to kind of fix the rate of return. So how does Vault work and how does Vault kind of deliver on its promise of kind of bringing interest rate swaps to the world of DeFi? So you can think of Vault as like a combination of three key kind of zero to one innovations modules that make up the protocol. So the first one is a kind of concentrated liquidity virtual automated market maker which effectively brings a two xSAM that lets variable takers and fixed takers exchange variable and fixed cash flows amongst themselves. So you can think of a simple scenario where you deposit funds into Ave, get an aUSDC token which has a variable rate of return.
00:03:56.742 - 00:05:52.922, Speaker A: You can then take it and bring it to vault protocol and get into a fixed taker swap, which effectively means you can give up the variable rate in return for a fixed rate that comes from variable takers. Another key module that they have designed that kind of enables the creation of interest rates is the margin engine which is kind of completely separate from the VMM where the VMM is mainly used for price discovery, margin engine is mainly used for kind of cash settlements, the management of underlying tokens as well as liquidations on the protocol. And the neat thing about interest rate markets relative to prices is the fact that interest rates tend to kind of exhibit a mean reverting behavior meaning that as a liquidity provider you can effectively choose a given fixed rate range which could be like between 1% and 4% and provide liquidity within that range. And because interest rates tend to be mean reverting it's less likely that the rates kind of would get out of bound of your range. And another kind of interesting feature of the margin engine is that it doesn't actually force you to use the underlying yield bearing tokens as collateral, it actually enables you to kind of express your views on interest rate movements by just depositing the single underlying asset as collateral and kind of trading rates on leverage. And if you think about the final kind of piece of the puzzle that makes up both protocol is the kind of the onchain PWAP rate Oracle design that we came up with, which effectively can be thought of as a kind of a buffer which continuously pulls data from on chain activity on protocols like Ave compound, and then uses this data to calculate historical rates of return, which are then used to determine margin requirements on the protocol, but also used for settlement purposes. And we spent a lot of time thinking about how we could build this rate.
00:05:52.922 - 00:07:03.838, Speaker A: Oracle and initially we were thinking of using an off chain solution, but eventually we kind of took inspiration from the TWAP Oracle design of Uniswap and came up with a mechanic which lets us effectively write historical rates on chain by leveraging the users of the protocol. So every time somebody swaps or kind of mints liquidity on the protocol as a side effect of the transaction. They cause a write to happen on the rate protocol of vaults which basically ends up kind of accumulating a historical buster of rates which is something that hasn't really been introduced before in DeFi. And if you want to think of the Rate Oracle as a primitive in itself, you can think of it as a perfect solution for a historical rate analytics platform. And also it could be used for future generations of kind of interest rate protocols and other derivatives that wish to leverage historical rate data to come up with better margin requirements and better risk measures for the future of DeFi. So if we want to think about the kind of agents on the protocol, they can effectively be split into three fundamental groups. So you have fixed takers, you have variable takers and you have liquidity providers.
00:07:03.838 - 00:08:11.420, Speaker A: So if you look at the diagram on the slide you can see that at the center you have vault protocol, the VMM and the margin engine duo. On the left you got the fixed takers who are effectively receiving fixed rates and giving up variable rates through the protocol. On the other side you get variable takers who effectively promise fixed rates to the fixed takers. So they act as guarantors of fixed rates and in return they receive the variable rates. And the final piece of the puzzle is the liquidity providers who are effectively agents who are comfortable entering into both fixed taker and variable taker positions with both sides of the market and they're able to do that by using single kind of underlying LP. So it could be in terms of USDC or it can be in terms of Dai or any other kind of alternative crypto asset and they can do that while still kind of collecting fees from kind of traders on the protocol. So if you want to dive a bit deeper into each agent and how they work and what are the main use cases for each agent type in the protocol, we can start with fixed takers who are I guess the easiest type to understand.
00:08:11.420 - 00:09:32.690, Speaker A: So we can think of fixed takers as like CFI, organizations such as Coinbase, BlockFi, et cetera, who could effectively promise fixed rate of return to their customers. But right now at this moment they kind of only are able to hold kind of variable yield assets such as cUSDC or aUSDC and so on. So what they can effectively do, they can use vaults in order to fix the rate of return they are receiving on the cUSDC and remove this risk that stems from the uncertainty about variable rates from their kind of balance sheet when promising fixed rates to their customers. And you can think of similar scenarios when thinking about fixed rate takers that could kind of be facilitated by kind of family offices fintechs and protocol treasuries who kind of tend to be more risk averse and on the more risk averse spectrum when thinking about kind of risk reward in context of rates. If we kind of then move on to the other side of the market, which is the variable takers. We can think of a simple scenario where a variable taker is a trader who believes that the variable rates in a given protocol, such as compound, are going to go up relative to the fixed rates currently offered in the market. If they have that view, and they would like to lever up their exposure on that view and kind of maximize their PNL.
00:09:32.690 - 00:10:51.658, Speaker A: If they end up being right, they can choose to do so by depositing collateral into vaults and getting it to a variable taker swap at ten to 15 X leverage. Which then means that if the realized variable rate ends up being 15% and the fixed rate ends up being 10%, then they effectively get the delta between ten and 15% which gets multiplied by the leverage factor. And then in this scenario, if the variable rate ends up being higher than the fixed rate, the variable takers get very high kind of leveraged returns. And we can think of a typical user type who would love to kind of engage in such activities is like a typical DeFi Dgen or that could even be like a team that leverages underlying vaults infrastructure to enable vaults that effectively bring strategies that deploy variable taker funds by pooling very different investors. There's also another interesting application of variable taker swaps. So there's actually an interesting idea. Imagine that you hold some assets in ave and if you want to then get compound rate of return right now you would have to take your funds and then bring them all over to compound.
00:10:51.658 - 00:12:11.430, Speaker A: But with vaults you can actually keep your assets on Aave. You can go and effectively enter a fixed taker swap with Aave which effectively means that you give up your variable rate of return and in return get the fixed rate. But you can then go on another interest rate swap market where you enter into variable rate swap in compound and as soon as all the cash flows end up canceling each other, you effectively get a variable to variable swap which means that you can keep your assets on Ave but get variable yield from compound. So yeah, that's kind of how the variable takers work. I guess the final category of users which we have on the protocol is liquidity providers are the kind of the backbone of the protocol. And when thinking about the liquidity providers, we can think of agents who might have a belief that in the next 90 days, the fixed rate on the protocol is going to be around 10%. In that scenario they can choose to effectively deploy collateral into a custom fixed rate range and the more concentrated this range, the higher kind of APY opportunities you have as a liquidity provider to generate kind of fees based on the collateral that you deposited.
00:12:11.430 - 00:13:45.010, Speaker A: And the cool thing about the design of the protocol is that because we're utilizing a two axis AMM, that means that as a liquidity provider, you can enter into positions with both fixed takers and variable takers. Meaning that you can effectively net out the cash flows from both sides of the market and you can recycle your collateral and keep entering into positions and kind of generate yield while staying market neutral relative to the underlying interest rates in the markets. And the market makers in our mind could be sophisticated traders and D five vault creators who are likely to engage in this types of activity. And one interesting project that could be kind of built as part of the hackathon is NLP Optimization Vault, which effectively kind of tries to obstruct away all of the kind of complexities involved with kind of managing the fixed rate ranges, managing the margin requirements and so on, while giving kind of retail investors an opportunity to passively provide liquidity on Rolts. If you want to kind of jump straight into kind of building on the protocol, I recommend kind of you check out our docs as well as the Discord server where you can come and ask any questions that might be of interest to you. Additionally, you can also come to our medium or read our live paper in order to get a better idea of how the protocol works behind the scenes. And then finally, if you just want to ape into vaults, you can check out our UI and start trading.
00:13:45.010 - 00:14:39.906, Speaker A: Basically, this is the theoretical part of the workshop. It's kind of over now. I guess the most exciting part is we'll try and kind of build something together. And for the purposes of this workshop, we're going to try and build a liquidator bot. So before we kind of dive into how to build a liquidator bot, maybe it would be helpful if I kind of explain how they work and what is the utility that they bring to the protocol. So if you think about a scenario where a given trader enters into a leveraged position on vaults, in order for the protocol to stay safe, there needs to be a mechanic that liquidates positions that are kind of risky in a timely manner. And liquidations on vaults happen in a very simple mechanic.
00:14:39.906 - 00:15:31.746, Speaker A: So let's imagine there is a position which has a margin account which is below liquidation margin requirement. This means that anyone can come in and try and liquidate them. They can be liquidity providers or traders, and in return for the liquidation, they can get a share of the margin of the liquidated entity. And that's effectively the incentive that enables incentivizes liquidator bots to keep the system healthy and free of risk. Well, as free as possible. Cool. So if you think of liquidation, it can be fundamentally broken down into two key phases the first phase is what we call like a pre processing phase is where you'd effectively try and pull various different positions on the protocol that are active.
00:15:31.746 - 00:16:03.330, Speaker A: They can be traders, liquidity providers. Once that's done, you can then start kind of sorting them based on how risky they are. And then once you discover a position which you feel is kind of below liquidation threshold, you should be able to kind of liquidate the position. And the challenging thing isn't actually the liquidation itself. The challenging thing is to be the first who finds an opportunity to liquidate. So you can think of the liquidators as kind of the high frequency traders of DeFi. Cool.
00:16:03.330 - 00:17:24.470, Speaker A: So the purpose of this workshop is just to motivate you guys by showing how you can build like a very simple liquidator bot with a single position, a single liquidity provider and a single liquidator. And once we go through, it would be great to see kind of how you guys can take this idea and spin it further and maybe build something a lot more smarter and less naive than what I'm going to show you now. So if you want to jump into the code base, you can just scan this QR code. So I'll let you guys take a few seconds if you want to follow along and then we can jump into the workshop. Cool. So the link should take you to the vault core repository and on the vaults core repository you can follow up and go to the liquidator bot section. Initially we'll go through the design of a simple liquidator bot which will then follow up by simulation, which creates a single liquidity provider position and then tries to liquidate it, fails to liquidate it because the margin requirement is satisfied.
00:17:24.470 - 00:18:45.910, Speaker A: And then we'll manually tweak the API in the underlying market to make the position liquidable to show that basically the liquidator bot works. So first we will refer to this liquidator bot smart contract, which is a simple kind of test liquidator bot contract which has a few key functions. The set margin engine function lets you pass in the address of the margin engine that you would like to reference. And the margin engine effectively just references a given interest rate swap pool and interest rate swap pools tend to differ depending on the underlying rate oracle, depending on their kind of maturity date and so on. Once the margin engine is set, then you can call the function Getmeliquator reward which will pull out the proportional margin that gets allocated as an incentive for kind of successful liquidators. Then moving on, we have the get liquidation margin requirement function which takes us input the recipient wallet, address the tick lower and the tick upper of the position. So the tick lower and tick upper are effectively numbers that represent the fixed rate ranges within which liquidity providers can deposit collateral.
00:18:45.910 - 00:19:47.430, Speaker A: And this function pulls out a position and outputs the liquidation margin requirement for that specific position and then final function is just called liquidate position. It also takes as input the owner address, the lower tick and the upper tick and then tries to call a liquidation. And this will be successful if and only if the liquidation margin requirement is not satisfied by a given position or liquidity provider. So this is basically the design of a simple liquidator bot. If we then want to run a simulation and see how it functions on top of a localhost environment, we can follow along and kind of open the Liquidatorbot Simulation file, which has a bunch of code, but at its essence. It just sets up an environment where it kind of deploys a Margin engine. A Rate Oracle, a token which we can leverage for testing purposes for our simulation.
00:19:47.430 - 00:20:57.774, Speaker A: It then says the margin engine parameters for the given interest rates or pool. And if you want to learn more about what these parameters mean, feel free to check out our light paper and dive deeper. Once the parameters are set, we go on and deploy the periphery of the protocol which access the contract that access the entry point into vaults. Once the setup is done, we're ready for the actual simulation. So before we start the simulation, we manually tweak the reserve normalized income in the underlying lending pool and all that does is effectively manually sets the historical APY in order for the liquidation position requirement to be met for our purposes. And then once that's done, we manually set the rate Oracle value to fetch the data from the underlying Galvan lending pool. Once that's done, we can check this historical API matches the one that we have set, and then we can move on and set the liquidator reward for a given margin engine.
00:20:57.774 - 00:22:23.340, Speaker A: In this case, we'll set it to 5%, meaning that after successful liquidation, a liquidator will get 5% of the margin of a liquidated entity. Once this is done, we are free then to kind of deploy our liquidator bot smart contract on top of the local test network and follow up by setting the margin engine to be the margin engine address behind the interface or pool within which you want to kind of conduct the liquidation. Then moving on, we can kind of fetch this newly set margin engine to make sure it's the correct one and then kind of check if the liquidation proportion reward proportion is also correctly set. Once all of these checks are over, we can actually start our scenario. So the first thing that we do is we initiate a liquidity provider position and in order to do that, we need to call the mint or burn function of the periphery, which takes us input the margin address, which kind of has a one to one relationship with the interest rate. So pool on the protocol, we reference the tick lower and tick upper which have a one to one relationship with a given fixed rate upper and fixed rate lower. We also provide the notional amount that the trader wants to kind of facilitate liquidity in and provide a margin delta, which specifies how much margin you would like to provide to support a given liquidity provider position.
00:22:23.340 - 00:23:43.590, Speaker A: Once that's done, we can then check the initial margin requirement of our liquidity provider, which will then come up to be higher than lower than the actual margin account, meaning that the trader is safe. And we can test this by trying to call the liquid position function through our liquidator bot, which we expect to be reverted with an error that says cannot liquidate, which means that the position is safe and it's not risky. But what we're going to do after that is we're going to advance our pool by one day, and we're going to manually tweak the interest rate to go from all the way from 3% to 7%. We're going to write this value to our rate Oracle, and once that's done, we can then try and check the liquidation margin requirement. And once we check that, we can see that the liquidation margin requirement is going to end up being higher than the margin account of our trade. It means that at that state we are then able to liquidate the position. So yeah, once that's done, we can then kind of reference the current bounds of the liquidator bought contract, which should show up zero, but after a successful liquidation, it should be equal to the margin account of the liquid entity multiplied by the 5% reward that we have set as part of the simulation.
00:23:43.590 - 00:24:24.740, Speaker A: So let's just try and run this script and see what happens. Cool. So I don't know if you can see the screen. Let me just enlarge it a bit. So if we just go step by step. The first thing that the console prints is the historical API, which is around 3%, that is manually set on Ave. And once we have done that, we can then print the liquidation margin requirement and the initial margin requirement of our liquidity provider, which are around 27 73,430 thousand respectively.
00:24:24.740 - 00:25:20.392, Speaker A: And we know that the margin account of our liquidity provider is around 500K, meaning that at this stage they are kind of safe and they cannot be liquidated. But we can see that after the manual tweaking of the APY and kind of rolling of time into the future, the historical API is now 7.6%, meaning that if we check the liquidation margin now, it's around 692,000, which is higher than the margin account of the entity that we're trying to liquidate. And so, after a scarce liquidation, we can see that the balance of the liquid or smart contract goes all the way from zero to 25,000, which is exactly equal to kind of 5% of the 500K margin deposit that PSC in the beginning of the simulation. That's effectively a very simple rundown of a liquidation on both protocol. Cool. That concludes the talk.
00:25:20.392 - 00:26:26.310, Speaker A: And yeah, if you guys have any questions, feel free to ask them. Actually, I have questions. How would you calculate it? Yeah, so the historical API essentially is calculated by looking at the let's say you have a one year pool and you want to calculate the historical API with a six month look back window. You just need to check out the reserve normalized income in case of ave today and the reserve normalized income six months ago. Find the ratio between those two, and as soon as you find the ratio, you get the rate. And as soon as you get the rate, you can then analyze it and get the APY that you can reference in the margin engine. Is it expected to decrease? Yeah, and that's kind of the design.
00:26:26.310 - 00:27:57.758, Speaker A: So in order to avoid kind of a range of different attack vectors that could result because of short term fluctuations in interest rates, we have kind of created TVA protocol which is resistant to this sort of fluctuations because it takes a much longer view on the historical rates and comes up with more smooth kind of time series of margin requirements for traders on the protocol. Meaning that you are protected from this sort of kind of attack vectors and scenarios. Thank you. Yeah. How come one wallet can so the way it works is, as a liquidity provider, as soon as you choose your kind of upper bound and the lower bound for the range, you end up getting a kind of liquidity provider position account which has its own margin requirement. And so each position on the protocol is kind of uniquely identifiable by this set of these three parameters. And the reason why we decided to kind of split it such that each position is uniquely identifiable by its address, upper tick and lower tick is because it allows us to calculate margin requirements for liquidity providers by simulating trading activity on the protocol.
00:27:57.758 - 00:29:00.120, Speaker A: Because you can think of liquidity providers as traders in the future in the sense that even though right now you don't have a position as a liquidity provider, you are effectively saying that I'm ready to enter into position in the future, and these are the rates at which I'm kind of comfortable doing that. And what happens behind the scenes is we simulate this transaction in our margin engine and we come up with a margin requirement that is the highest possible requirement that you could get if somebody, if a trader, were to come and treat your position fully. And, yeah, that's kind of what kind of facilitated the design decision. Thank you. Cool. I guess if there's no more questions, thanks everyone, for attending this workshop and can't wait to see what you guys end up building. If you have any questions at any point during the conference or the hackathon, feel free to check out our booth and we'll be more than happy to help you out.
