00:00:00.570 - 00:00:40.020, Speaker A: Hey everyone, just going to wait for a couple of seconds for the live stream to get set up. Great. Hey everyone, good morning, good evening, good afternoon. Depending on where you are, we have German from nosis space doing a workshop on Safe modding 101 create your own Safe Module. Questions go into the zoom chat in German, will answer them at the end of the workshop. And with that I'll pass the mic off to German.
00:00:41.080 - 00:01:29.620, Speaker B: Hello everyone and thank you for having us. So I'm German, I work at the Nosisafe team. And today I want to present you how to build or how to create your own safe module. So today we are going to cover three points. The first one will be the Self Modules architecture. What are the components that are present in this architecture and how they are connected and also why we need them. Then we are going to talk about how to manage different safe modules and what are the operations that we can execute.
00:01:29.620 - 00:02:25.968, Speaker B: For example, we can enable a module into a safe. We can disable a module, we can execute a transaction using a module instead of the regular common flow, where the signers need to sign, et cetera. So in general, we are going to see how to use them. And lastly, we are going to see and mention some repositories that contain different site modules and some examples. So that would be where to find them. Let's start with the site Modules architecture. If we talk about an external own account, the architecture, if we can call it that way, is pretty simple, right? In order to execute a transaction, we just need a single key to sign that transaction and then we are ready to execute it.
00:02:25.968 - 00:03:45.040, Speaker B: However, if we are using a Nosisafe account, which is a smart contract that also acts as a multi SIG, we can handle different or multiple keys and we can define how many of them are needed or are needed to sign a transaction and make it executable. We can do this step or this action on chain, submitting every signature to the contract, or we can do it off chain. And if we do that off chain, we can use a transaction service that we collect all the required signatures and then we can call the smart contract just once with the transaction we want to execute and all the signatures concatenated and attached to the transaction. That is the regular flow. However, there's a different way to execute transactions where the signers of the multisig are not involved. And this other way is using Safe Modules. Safe Modules that are used by third parties.
00:03:45.040 - 00:05:11.580, Speaker B: Third parties are any accounts out there in the network that can call a method in the Safe module. And the Safe module is an independent smart contract that is deployed in the same network as the Nosisafe. The Nosisafe. Before we can use this module, the signers of the safe need to create a transaction and sign it altogether to enable this module. And once this module is enabled, then the third party, any account can use it and this module will send a transaction to the Nosisafe and it will be executed without the approval of the signers. So we have two different flows using the signers or using the module in case at any point in time we lose our keys and we lose the control of our Safe. If our Safe module is about or is implementing a recovery mechanism somehow, this third party individual or multiple accounts could create a transaction, for example, to replace the multiple keys.
00:05:11.580 - 00:06:21.388, Speaker B: That's one of the functionalities that could be done in this environment. So the main thing is that Safe modules extend the functionality of the Safe. You can even implement different ways of how not all the owners, for example, have the same weight when they have to sign transactions. For example, if we have five keys and we just require three of them. But we could define different logic where one of the owners, for example, or one of the third parties involved in this module is more important than the others or whatever. That depends on what you want to build. There are also some Safe modules or a kind of Safe module that is called Safe Modifier and is also a smart contract independent of the Nosisafe that implements some interfaces from the Nosisafe.
00:06:21.388 - 00:07:43.630, Speaker B: Because the important thing about modifiers is that they are placed between a Nosisafe account and a Safe module that of course is used by a third party. These Safe modifiers act as a filter for the transactions that are sent from the Safe modules to the Nosisafe. They relate the transactions, but depending on the logic inside these modifiers, some of them could be relayed or not. There's also the possibility that we want to change multiple Safe modifiers to have different filters. And anosisafe can have enabled multiple Safe modules as well as the Safe modifier that can enable multiple safe modules. And of course, because the Safe modifiers are a kind of modules, we can have some of them enabled to the Nosisafe at a time. So that was basically the architecture or the different elements that are in place.
00:07:43.630 - 00:09:22.604, Speaker B: And now let's see what are some use cases for these modules. As I told you before, modules can expand the functionality of the Safe and some examples could be regarding roles. The common flow to execute a transaction using a Safe is by having different signers and at least we need some of them to sign something. But with a Safe module we could forget about designers and grant some admin rights to specific accounts, allowing them to execute transactions or calls to specific addresses, calling specific methods and specific parameters. And if the conditions that are defined are met, then we allow these now admin addresses to execute these transactions without the need of the approvals of the safe signers. We could also define some spending limits to certain accounts where we allow them to withdraw or to send some funds out of the safe without any other authorization. We could also talking about recovery mechanisms, implement a recovery mechanism like social recovery for example.
00:09:22.604 - 00:11:27.280, Speaker B: We could deploy a module that has set different accounts that later in time they could altogether create a transaction that replaced the initial signers of the safe. If we prove that they are not reachable and that we lost these keys, or for example, these are just examples of what can be done. We could define secret questions and for example encrypt the answer of a question for you in case you lose your keys and if you know the answer and provide that answer to the contract, then you can again execute this transaction to replace the original signers. Also, save modules can define, allow and deny lists of the target addresses that can be called or decide if safe module is is now in use or if it's not in use anymore. And the modifiers as we saw before, they can implement time logs or cool down periods where if you have a module and then a modifier and then the safe and the module executes a transaction, sorry, sends a transaction to the safe, but that transaction is received first, but by the modifier. And the modifier for example, has defined that every transaction needs to wait for one day, then all the received transactions could be Nqed and wait there for one day. These are just different possibilities.
00:11:27.280 - 00:12:37.610, Speaker B: But if you are interested in safe modules, what you can implement there the logic, it really depends on your needs. So now we saw what was the architecture, let's see how we can manage them. What are the different operations these operations are? We can enable a module in a safe, we can disable a module, we can check if a certain address is enabled, we can get the list of all the modules that are currently enabled and lastly, we can execute a transaction using a module. So let's see all of them a little bit in detail. And this is just the different steps we need to do in order to execute a transaction using a module. We saw them before, we need to deploy a new safe or use an existing one. We need to deploy a new safe module or use an existing one.
00:12:37.610 - 00:13:55.952, Speaker B: We need to enable the module from the save and then after that, that module is ready to execute transactions. So now we have two different point of views here we have the point of view from the safe that will receive these transactions coming from the module and we have the point of view from the module that is sending the transactions to the safe. Let's start with the safe and let's continue with the module. So, Nosisafe Sol this is a super simplified version of the Nosisafe contract that among other things, it is a module Manager. The module manager is one of the safe core contracts that implements all the logic to perform these operations that we saw before, like enable a module, disable a module, execute a transaction using a module, et cetera. So when we set up a new nosisafe, there's a call to set up modules. And if we see the module manager contract, also super simplified, we see that there are two variables.
00:13:55.952 - 00:15:25.840, Speaker B: We have the sentinel modules that is set to the address Zero X one that we will use later, and we have the modules variable, that is a mapping where the keys and the values are addresses. And when we set up the modules, we are going to use the sentinel module, the address Cox one, as the value and the key as the key and the value of that initial module mapping. With this mapping, we will build a kind of a linked list, where if we want to add a new module, we are going to use it as the value where the key is the sentinel module. Because if we want to navigate through this mapping, we just know the sentinel module. So we check that key and get the value that would be a module that is enabled, for example, then we also need to store this module as a key and point to a value that is the sentinel module. If there are no modules enabled, or if we have more modules, then the value of the key that was a module will be a different module. And we are going to have something like a linked list that we could navigate forward but not backwards until we find the sentinel module.
00:15:25.840 - 00:16:49.516, Speaker B: So knowing that we can enable a module, knowing that a module cannot be null or cannot be the sentinel because we need the sentinel to identify the beginning and the end of this linked list and we cannot add a module twice, we can also disable a module very similar, but the opposite action. And we have to validate the module address and check that it was already enabled. We can see if a module is enabled by checking if the module we are passing to this method is different than the sentinel module, and if the value of this key, using this module as the key is different. Than Zero X, knowing that there is some value there. We could also return or get all the list paginated of the modules that are enabled in the contract. We can provide to this method an address that we call the Start. For the first time will be the sentinel address and then the page size, depending on the amount of modules we want to get.
00:16:49.516 - 00:17:59.788, Speaker B: And this method will iterate in the list in the mapping. And in the end we will get an array depending on the page size of modules and the next module that we can use as the start address of the following page. And finally and one of the most important operations is execute a transaction. This is a public method accept transaction from module that can be called by any account. In this case, modules will call this method. But there's one very important check that must be met and is that the message sender must be enabled. Knowing that only the modules that call this method, only if they are enabled they can continue with the execution else otherwise anyone could execute a transaction and that is something that we want to prevent.
00:17:59.788 - 00:19:20.168, Speaker B: Only allowed modules and depending if this transaction is successful or fails, then different events are going to be emitted. Perfect. So we saw the side of the safe and now we are going to see the side of the module. This is a very simple and incomplete module that we call custom module and is a module. Later we are going to see what is that it has a target that somehow was set before and it has a public method that receives some properties of the transaction we want to send to the safe to execute it to value data and operation. And if we see there's one call that will return the boolean success and that call is using the target, the target is the save that has this module enabled. Or if we are using a modifier then it's the modifier because the module will send this transaction to the modifier and then the modifier to the safe.
00:19:20.168 - 00:20:36.048, Speaker B: So whatever it is, we are using that target and call the method accept transaction from module and pass these properties. So we saw what are the different components in this architecture, the modules and the modifiers also how to handle them, how to add them, remove them, get a list of them. And now we are going to see some examples or mention some famous modules that are used these days. First of all, some repositories that are very useful. First one is the Safe contract that you can find in the account Safeglobal from GitHub. Safe contracts is where all the safe core contracts are and there you can find specifically the module manager where these operations for modules are defined. Then we have the Safe modules also from the same account on GitHub.
00:20:36.048 - 00:21:36.968, Speaker B: And this has the implementation of a couple of modules that the team built. Specifically the Allowance module for example. And finally we have another very important repository which is from Zodiac inside the Gnosis account. And Zodiac is a composable dow tooling standard that is built on top of the Nosisafe and they have implemented different modules and modifiers that are used by quite some dows. So let's see some examples. I provide here the links so if you are interested you can check them later. These are for example, this module is the one that is used here.
00:21:36.968 - 00:23:14.500, Speaker B: The custom module is a module. This was implemented by the Zodiac team and if you go to GitHub you can see this module that has a target which is the account that is receiving the transactions that are sent from this module. There are some setters and at some point we have a method that is called exec that is internal. So you could use that from your module, it has some logic and we can see the call to the method exec transaction from module that is in the target as we saw before. Same for the modifier. The modifier is also a module, it implements some logic that is inside the Nosisafe in order to handle all the modules that can be enabled into the modifier. So here we can find the modules, the sentinel, some errors and events and we need to override one of these methods, for example the exact transaction from module that is public and that anybody can call and here we can define the logic of this modifier.
00:23:14.500 - 00:24:58.730, Speaker B: Also at the end here we can find the functions that handle all the logic regarding enable, disabling modules, et cetera. And then we have some examples for modules, for example, the allowance module. This module is like a registry of transfer allowances that can be used by specific accounts, knowing that a transfer allowance is specific for a safe, for a token and for a delegate account. So these delegates accounts will be able to move some funds depending on the allowance that is set without any other interaction from the signers of the safe. Also another module that exists is the exit module. The exit module is similar to the Molokdao's race quit and it allows the participants, for example, of a Dao that is built on top of the safe and that has this module enabled to redeem some tokens in exchange of a portion of all the funds that are stored in the Dow or in the safe. And we have also some modifiers like delay modifiers that we mentioned before where all the transactions are queued sometime and then they can be executed later in time.
00:24:58.730 - 00:26:40.760, Speaker B: Or we can have also the roles modifier and the roles modifier allows Nosisafe for example, to enforce permissions on enabled modules and these permissions are granular and role based. So we can define if a module is associated with a specific role, we can define the type of calls that this module can execute and the addresses that the target addresses of these transactions, they must be approved inside this role or also the functions that are called and also the variables that are used. So, knowing these three big topics now the question is will you build the next safe module in the following weeks with us? We hope so. So that's all from my side, you can find us on Twitter, on Nosisafe and we also use discord on our forum and also we have a specific channel in the ifglobal discord. So thank you very much everyone for attending and I hope this talk was useful for you.
00:26:47.510 - 00:26:49.890, Speaker A: I think you have one question in the chat.
00:26:50.950 - 00:27:50.480, Speaker B: Yeah. It says, can Safe be created and managed by an external smart contract? Not interested in building Gnosis features? Yes, Safes can be deployed by the Safe Factory and the Safe Factory has a method to create proxy and to deploy anoxysafe and that can be called. It's just a call you have to send to this contract. I see there are no more questions in the chat, but if you have any other question that comes to you later, we will be in Discord and we can check that there.
00:27:52.070 - 00:28:20.554, Speaker A: All right, perfect. Thank you so much for taking the time to do this wonderful workshop with the hack money hackers. Yeah, as German said that he will be reachable. He and the team will be reachable on the East Global Discord in sponsor Nosisafe. So if you have any questions, definitely feel free to reach out there. And with that being said, thank you so much to the rest of you for joining today's workshop. We do have one more sorry.
00:28:20.554 - 00:28:21.914, Speaker A: Yeah, go ahead.
00:28:22.112 - 00:28:39.826, Speaker B: One more thing. We have two bounties for this hackathon. One is free, like building something on top of the save whatever you want. And the other is specifically building something using the role modifier. So that was it. Thank you.
00:28:39.968 - 00:28:54.260, Speaker A: Perfect. Sounds good. Thanks for the announcement. And, yeah, we do have one more workshop after this scaffold ETH one. So hope to see all of you there as well. Otherwise, have a great rest of your day. Or evening or morning.
00:28:54.260 - 00:28:54.990, Speaker A: Bye.
