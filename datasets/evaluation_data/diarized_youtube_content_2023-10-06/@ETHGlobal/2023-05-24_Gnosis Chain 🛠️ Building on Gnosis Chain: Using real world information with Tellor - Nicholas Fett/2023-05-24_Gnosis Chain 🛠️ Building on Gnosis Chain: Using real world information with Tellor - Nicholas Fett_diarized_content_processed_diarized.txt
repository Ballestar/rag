00:00:08.250 - 00:00:43.326, Speaker A: Hey, guys. My name is Nick Fett. I'm one of the founders of Teller, and I'm here on behalf of Gnosis Chain. So figure out how to click here. Before I get into just what Teller is, I thought I'd at least I have to at least say the sponsor who brought me here and why Gnosis Chain? So for those of you that don't know about Gnosis Chain, gnosis Chain is an alternative L One. So similar to Ethereum, it is an EVM, and it's got the works. So it's got a bridge, explorers, AMMS, all the wallets aboard.
00:00:43.326 - 00:01:19.482, Speaker A: And I know you guys are like, well, why the hell do we need another L One or another chain? But the truth of the matter is, if you actually look at all the L two S or anything that's actually cheap, they're all like, really shitty. There's like a multi SIG or a centralized sequencer or an admin key, and they can rug you at any point. So if you want to actually build a censorship resistant application, come to nosis Chain. We'll love you over there. Okay. Onto Teller. So kind of how I got started with Teller back in 2017.
00:01:19.482 - 00:02:05.662, Speaker A: I was trying to build a derivatives protocol. I was trying to do where you could lock ETH into a smart contract. Then you would have long and short tokens that represented like, long bitcoin, short bitcoin. And I know this was like, novel back in 2017. Anyway, got an Ethereum Foundation grant to start building that, and you quickly ran into the problem of, okay, well, who gets to say what the price of Bitcoin is? And the problem is that smart contracts can't read outside information. So due to the fact that you have to be able to replay it for all of time, if you were reading an API, if somebody a year down the road tried to run that smart contract function, they would call the API and it would get a different result. So things would break.
00:02:05.662 - 00:02:44.714, Speaker A: So everything needs to be an input. And this input is what's called the Oracle. So who gets to do that is a big problem for things, obviously, such as price fees when building derivatives and then other things, bridges, other pieces, which I'll kind of get into. So what are the Oracles? So back in 2017, there actually was an Oracle live on Ethereum. If you guys remember Oracle eyes, this was Thomas Bertani. He ran Oracle Eyes, and you would, like, pay him a quarter or $0.50 in ETH and he would return the result of your API call.
00:02:44.714 - 00:03:10.306, Speaker A: And that was literally the Oracle that people were going live with in production back then. This was pre chainlink, pre everyone. And that's obviously a really bad Oracle. The reason is that if he died or if he decided to change the value or rug you, you would have no recourse. So you can go beyond that and it's okay. Well, how could we make that a little bit better? I don't know. We trusted Thomas.
00:03:10.306 - 00:03:42.474, Speaker A: Let's trust Vitalik and we'll trust Stani. Okay, so we'll do a multi SIG, and that can also be an oracle. And that's like whenever Maker started, they were one of the first people with their own kind of custom oracle. And it was basically just a multisig. They had 14 people and it was a multisig and it worked. You just have to trust assumptions of a multisig. But basically you have to kind of rethink about how you're thinking about an oracle.
00:03:42.474 - 00:04:35.310, Speaker A: And it's just how do you come to consensus on data? And this is sort of the problem because in the blockchain world we're really sort of honed to thinking about coming to consensus at the chain level, but then at the app level it's still the same way. How do you come to consensus quickly on a piece of data? And you obviously can't build a blockchain now it's actually possible with roll ups, but building blockchains on top of blockchains to decentralize, it gets really old, really fast. So we'll kind of go into how we solve that problem and how some of the other people are and how you can use them. So what are oracles used for? Obviously there's price feeds, bridges. So bridges are oracles. If you have Gnosis chain over here and ethereum over here, they don't know anything about each other. You might as well be reading an API from Coinbase.
00:04:35.310 - 00:05:25.882, Speaker A: A bridge basically just reduces the assumption. You have more generalized oracles where you can ask it any question, know who's kind of like at the bottom prediction, know who's the President of the United States who won the Lakers game. You can ask it these general questions or you can have very specific oracles like what's the block header of Bitcoin next? That's still an oracle and you need some way to come to consensus around it. Other things, insurance as well, anything off chain. Anytime they talk about, if you hear somebody say like, oh, we're going to put real world data on chain, it's sort of this meme. And the problem is, okay, well, who's putting the real world data on chain? That's an horrible problem. You probably have some centralized entity that is in charge of saying it went on chain or it went off chain.
00:05:25.882 - 00:06:19.374, Speaker A: And that's a problem. You should maybe use Tellers to decentralize that a little bit. But as we kind of go into building these generalized consensus mechanisms, the scalability trilemma, it holds for oracles too. So if you want this thing to be really fast, it's probably not going to be very decentralized and it's just a trade off. And so any oracle that you guys see out there that you're thinking about using, if they claim like, we can update your price speed with instant finality every block. And you're like, there's just no way, besides the fact that it would be really expensive for that much data to chain. Because you can kind of think of if you had the question like, who's the President of the United States? What's like a really slow Oracle.
00:06:19.374 - 00:06:56.522, Speaker A: If you guys remember, one of the original Oracles out there was Auger or like Gnosis, back when Gnosis was a prediction market. And basically what you would do is you would have all these tokens and you would have to ask it a yes question or it would have to be a yes no question. And then people would stake all their tokens on whether it was going to be a yes answer or a no answer. And it would take like a week. And that was an Oracle and that was a valid, it was a great way to do it. The obvious trade off there is it's super, super slow. So didn't really work for price feeds.
00:06:56.522 - 00:07:51.514, Speaker A: So we've since come to some better solutions, which gets me now to how Teller actually works. So teller, it's kind of a simple Oracle. We really focus on how can we actually be decentralized? We came into the space if we're building on Ethereum, if we're building on Gnosis chain, if we're building on these networks, you're only as decentralized as your least decentralized point. So what you want to do is make sure that the Oracle isn't that sort of centralized choking point. So how can we make sure that this is decentralized in the sense that anybody can do it and anybody can validate it? And so the way our Oracle works is you stake some Teller tokens. So you grab like on main net, it's like a few thousand dollars worth of Teller tokens, not a crazy amount, and you lock it into a smart contract. Then somebody else comes and they tip.
00:07:51.514 - 00:08:33.162, Speaker A: They say, hey, I'll pay one dollars, or probably on Ethereum more since the gas is really expensive, I'll pay you one dollars. If you submit the price of Bitcoin on chain. All of those staked reporters then right now they're all like mev bots on our network, they race each other to go and submit the price of Bitcoin unchain. You don't want to use it right away though. So this is sort of the caveat that makes it slow is you actually need to validate it because there's no way for the smart contract to intrinsically know that that value is correct once you put it on chain. You could put anything on chain, but it's an optimistic Oracle. So you put it on chain, if nobody disputes it for a period of time, then you can use it.
00:08:33.162 - 00:09:06.514, Speaker A: What is that period of time? Well, that's up to you. If you want to yolo it and say five minutes, okay, you can do that. If you want to wait ten minutes, 15 minutes. Usually it's really fast, like a minute for a dispute. Just because all the other reporters are running these monitors to catch each other. Because if you catch it, you submit a dispute fee. So a small fee, and then if you win, it gets pulled off, the data gets pulled off, goes to a two day long vote, you can win the guy's whole stake.
00:09:06.514 - 00:09:42.260, Speaker A: So it's very profitable to win these disputes and then for the user. So the way that we sort of use teller to make it really fast is once that data gets pulled off chain, you don't have to wait for that result. You as the user don't actually care. The next person would just throw it on chain and that's who your dollar would go to. So the wait period is roughly how long you are going to wait for a dispute. All right. And then your smart contract reads the data.
00:09:42.260 - 00:11:05.206, Speaker A: So now let's kind of get into what are just some best practices whenever doing these Oracles. And you guys are at a hackathon, so I wanted to try and keep it hackathon focused as far as what can you build with Oracles, what are good use cases for a blockchain? The biggest thing and the biggest problem that most people have whenever they're starting to use an Oracle is you'll hear people with very niche use cases. So it'll be something like I think there was one guy, he wanted to do car insurance on the blockchain. Car insurance is really hard and he's like, well, could there be an Oracle that says whether or not somebody got an accident? If you think about it, who's that Oracle? Who can actually validate that? And that's a problem of you want it to be something that everybody can validate because once it's put on chain, if you can't go actually see that that person got in a car accident, you can't validate it or say anything about the truth of it. So there would probably be rampant insurance fraud. And this is a problem with most things. So if you have some calculation that takes really long to run, or if there's the classic example is like, what is it like crop insurance in Africa we're going to make on the blockchain, whether it rains in a certain region.
00:11:05.206 - 00:11:58.302, Speaker A: This was always like one of the old examples that people would do at a hackathon. And the problem was always, well, how do you tell if it rained in a given region? It's really hard and it's not necessarily straightforward. Whereas the price of bitcoin we know what the price of bitcoin is. It's very easy to tell if you lied. But on the price of bitcoin piece too, there's actually a lot of trade offs whenever you're even defining the price of bitcoin. So for instance, if you're talking about the price of bitcoin, you can have, okay, well, if you say what's the price of bitcoin on coinbase, that's a different answer than what's the price of bitcoin as a median between coinbase, Prakin and binance. And that's actually a different answer than what's the price of bitcoin if you just answer it.
00:11:58.302 - 00:12:46.462, Speaker A: And there's actually different trade offs for each one because the first one, what's the price of bitcoin on coinbase? Super, super easy to verify. And if you're using this DeFi protocol, for instance, as like a hedging platform, you know what exchange you're able to hedge and that's super useful for financial tools. The downside, of course, is decentralization. You know, that the person, if you want to throw that Oracle feed, you just have to go throw the API in Coinbase and go make some big trades on Coinbase. Whereas if you just say, okay, well, what's the price of bitcoin? This is where that subjective data comes in the middle. Okay, so if it's just the price of bitcoin, well, maybe there's like a 1% wiggle room in there because it's not going to be exactly the same on every exchange. So you sort of have to be okay with that wiggle room.
00:12:46.462 - 00:13:26.954, Speaker A: But yeah, just different sort of trade offs you have to think about as you're putting it on. We always recommend any Oracle that's like, oh, just put in your API and we'll go get it. It's like, well, that's centralized API. You don't want to use that for your Oracle. You have to think about how can you get the data without a centralized API and then you can potentially have a decentralized Oracle in the so, all right, I'm going fast because I know we were started a little bit late. So going to keep us on time. This is just the basics, how Oracles actually work.
00:13:26.954 - 00:14:00.130, Speaker A: So there's several different kinds of Oracles. There's. Push, Oracles, and pull, Oracles. So a push Oracle is one that will push it directly to your smart contract and implement an action. A pull Oracle is one, say, like Chainlink or Teller, where it updates its own smart contract and then you have to run a function and go grab it. So there's two different things. Usually they're actually converging as time goes on, just because what you can do now is there's a lot, whether it's Gelato or the Keeper network or those, you can just sort of automate the action.
00:14:00.130 - 00:14:50.454, Speaker A: Once the pole Oracle is ready, run some action and push it to your smart contract. So that's usually best practice. Now, do we want to look at code real fast? Maybe we can yeah, we can show you guys how easy it is to kind of look to build an Oracle. Sorry, you guys see that? Can I zoom in better? All right, I can zoom in again. The way the Teller works is it's a generic Oracle. And this is what's kind of important that I wanted to show you guys. We have a helper smart contract.
00:14:50.454 - 00:15:33.322, Speaker A: You can just come. So this is sample using teller. It's a repo in our GitHub. You just NPMI using Teller, folds it into your Node modules, and then you can import it and do sample using Teller is using Teller makes it easy to inherit it. But the way that Teller actually works as far as getting what you want and knowing is we call it query data. So we have these data specs for how we define what a piece of data is. So the spot price data spec what we do is here is we encode the word spot price and then for instance GNO USD and that's asking the Oracle for the Gnosis US dollar spot price.
00:15:33.322 - 00:16:26.460, Speaker A: Obviously there's lots and lots of different data specs that we you know, other ones that we have are like snapshot vote result. So you put in a snapshot vote ID and a chain and a contract and it'll go get you a result of a snapshot proposal. Other ones you can do like EVM calls to different chains. So you just need to give it a chain, a contract address and then call data and it'll return that call to your smart contract. And these are ones that we already have but you can actually come and it's open source. So we have these hosted on IPFS you can make your own data specs. So if you want to really think about okay, what's something custom that I would want to do really the Sky's the limits there's a lot of different pieces that we've done.
00:16:26.460 - 00:17:04.966, Speaker A: Another fun one is we do like cross chain balances. So like what we do is we'll return like a merkel route of all the balances. So if you have a token on ethereum, and let's say you want to AirDrop over on polygon to the token holders of a token on ethereum, all you would want to do is you could put like the Merkel. Route of all of those balances over on Ethereum or over on Polygon. And now people can go and claim it and prove that they have that balance. And that's a much more efficient method than bridging over all the balances. So basically kind of just telling you you can put on whatever you want.
00:17:04.966 - 00:18:04.070, Speaker A: It's not limited by any type it just returns bytes data so you'll have to decode it at the end. But if you want to return very large strings you can do that. And then yeah, you run once after you would tip for it or put it on chain yourself. You just run git data before the query ID and then this one this is showing down here the best practice block timestamp -15 minutes you're waiting 15 minutes for a dispute making sure that it's valid and then you can update it. So that's about as simple as it gets. I'll go back to my presentation. I know they're ending over there, so I'm guessing that means I have to and but I wanted to give kind of before we ended, just I know some people were still looking for ideas or if you wanted ideas.
00:18:04.070 - 00:18:44.098, Speaker A: These are some of the cool ones that I was hoping people would build, whether hopefully on Gnosis Chain or with Teller other ones. So things that you could do, you could build token bridges. So we were just talking about how you can use that EVM call, but you could make it a mixer, which is what I think people should do. So you could fork some tornado cash code where there's a proof of a deposit, but why don't you just take that proof, go put it on another chain. Now all of a sudden you got a mixer and you could put it on ten different chains if you put a chain ID in there as well. And now you're mixing across chains. So some cool ideas.
00:18:44.098 - 00:19:22.318, Speaker A: I want to see somebody do a BRC 20 on chain. So you could use an Oracle to go grab ordinals data from the bitcoin blockchain. You put that stuff tokenize them, put them on the Ethereum network, maybe get some of the maxis on board. Other things bounty programs. So we've seen people do this with Oracles. You can use an Oracle to bring on how many Twitter followers do you have, how many discord followers does your channel have, how much volume does your token have? And then you could set up Bounties in a decentralized way, like, hey, I'll claim this, I'll get you 500 new Twitter followers. The Oracle will bring on the start Twitter followers and the end Twitter followers.
00:19:22.318 - 00:20:10.398, Speaker A: If you bump that number up by 500, you're going to get this bounty. You could do something like that with an Oracle. Other things that we're working on, you, you could really go if you wanted to get really sort of econ about it, you could build like a decentralized so, like, how would you do that? That's more of a question for how do you structure okay, what data do you put on chain? How do you put lots and lots of data on chain? And then yeah, kind of last same thing like music bounties you can put on spotify streams, you can put on okay, did an artist release a new album? Something like that. Lots of different things you can do with an Oracle and hopefully it kind of sparked your guys interest. So anyway, here's my contact. Thanks. Hopefully you guys learned a little something about Oracles.
00:20:10.398 - 00:20:57.774, Speaker A: Definitely give me a follow on Twitter. Do I have time for questions? Yeah, if you guys have a question or two, I can answer it. Yeah. So he asked if we have a token. We do. So you have to stake our token that's that on. Yeah.
00:20:57.774 - 00:21:44.250, Speaker A: So he asked, how do you validate like, if you're asking for a cross chain information, how do you validate that it's not a fork of the chain and that's why it's like, optimistic. So you would want to wait on it. The person could potentially get slashed if they're doing it well, yeah, it would probably be invalid and it would get voted and disputed, but if you were the user so you would want to wait, it would depend on what value you were bringing over. Right. If you were doing a token bridge, for instance, and you're bringing over $10, nobody's going to fork your chain over $10. You can probably read it relatively quickly, but if you're bringing over $100 million yeah. You're going to want to wait for 100 block confirmations to make sure that thing's secure.
00:21:44.250 - 00:21:53.710, Speaker A: Yeah, I think that's just general best practice for these bridges. All right, well, thank you, everyone. Bye.
