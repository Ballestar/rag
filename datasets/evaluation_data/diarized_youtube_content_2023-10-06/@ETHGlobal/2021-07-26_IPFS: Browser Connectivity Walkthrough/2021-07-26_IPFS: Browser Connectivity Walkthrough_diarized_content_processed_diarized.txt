00:00:10.390 - 00:00:27.820, Speaker A: Okay. Hi everybody. Welcome to the IPFS browser connectivity walkthrough workshop. We have Ryan here, who's from our sponsor IPFS, and he's going to be running this great workshop for you guys. Ryan, I'll leave it to you to introduce yourself and get started.
00:00:28.830 - 00:00:56.006, Speaker B: All right? Hi everyone. My name is Ryan, but more known as Discordian. You can call me Disco for short. This is IPFS Jumpstart, creating an in browser peer to peer application and interactive workshop. So if you want to, you'll be able to follow along. And let's get started. So some people here might be wondering, what is IPFS? So we'll go over that briefly, but feel free to ask questions as they come up.
00:00:56.006 - 00:01:48.410, Speaker B: So IPFS, aka the Interplanetary File System, is a peer to peer data storage protocol. It's typically used over the wider public network, but will work fine within a LAN and can even be used in a private network over the Internet encrypted using shared keys. So IPFS addresses content using CIDs and data is shared peer to peer between people using IPFS. A CID is a unique identifier that helps with data discovery and deduplication. IPFS can also utilize IPNs, aka the Interplanetary Name System, to have one CID that can be updated to point to a new CID. This works by the publishing node generating a key pair. Then that node can publish CIDs to that associated public key.
00:01:48.410 - 00:02:36.518, Speaker B: If this key or IPNs address is shared, then a receiving node can access the latest version of content using that IPNs address as the publishing node publishes changes periodically. So IPFS is built upon Lib P to P. This is used as the backbone of IPFS for peer to peer communications for practical application uses. This gives us access to an easy to use publish subscribe system, aka PubSub. We can simply subscribe to a topic we're interested in as well as publish to it. All subscribed peers will see the published message. IPFS is also accessible over Http via public gateways such as IPFS, IO and DWeb Link.
00:02:36.518 - 00:03:31.980, Speaker B: This gives non IPFS users a sort of portal into IPFS without all the features of running their own node. So, what are we going to be doing today? Well, today we are going to learn how to discover and connect to other peers in a peer to peer browser application. We'll go over using WebRTC Star to connect directly with peers as well as circuit relay in case Nat traversal isn't possible. Then we will learn how peers can communicate with each other. So we're going to be using Pub Sub today to build a simple chat application, and then we will learn what some possible pitfalls you might encounter along the way. I personally encountered some surprising Pitfalls in making my first in browser IPFS application, and I'll be going over those today as well. After, I think would be a good time to answer any unanswered questions.
00:03:31.980 - 00:04:22.502, Speaker B: And then you will need a text editor for this workshop. There are several amazing ones available, including Vs code, Notepad, plus, plus Kate BIM, Nano, Emacs, Sublime, and more. Today I will be using Vs code, but we're mostly just going to be editing one file, so just use whatever you prefer. All right, if you plan to follow along, you'll want to download the starter kit linked at the top. So that's just workshop thedisco zone and hopefully that works out fine and everyone can access and download that. The main file we'll be editing today is Chat JS, which will be included in the zip. You can view your changes by opening index HTML in your browser.
00:04:22.502 - 00:04:50.210, Speaker B: So we'll be starting with part zero. What I do is I just copy part zero into a live folder and then just work on it from there. But you can do whatever you prefer if you don't plan on following along. I'll be streaming the process here as well. At the bottom of this slide, I've linked roughly what this demo will look like after we're complete today. So if something goes wrong, a completed version that you can just download and run is available there. It's complete with a guide.
00:04:50.210 - 00:05:21.540, Speaker B: So please let me know in the chat if you run into any issues getting set up. Otherwise, we'll be moving on to explaining what's going on. And I don't see any questions so far. So we will go into Vs code. All right, so what I have open here is this is part zero. Maybe I'll just open that up quick for a visual. So when you first get your zip, you'll have all these directories.
00:05:21.540 - 00:06:01.694, Speaker B: I have copied out zero bare bones, and I'm editing Chat JS. So this is up here are just variables and constants we'll be using later. In here is what will be running on load. So all this does is create an IPFS node, which we can use directly in the browser right away, and I will open that up to show you. So this is our bare bones screen. So I've created some basic HTML for us to have. We got our red circle in the corner.
00:06:01.694 - 00:06:35.400, Speaker B: We got a zero here, can enter a display name. We can chat. But none of those features exist yet. We were just looking at the JavaScript. All it does is create a node. So how do we access that node? Well, we can right click and inspect, or you can press CTRL Shift. I usually to get to this window, I'm just going to go over to the my screen went black and oh, that hasn't happened before.
00:06:35.400 - 00:06:42.790, Speaker B: So is the screen black on my stream?
00:06:43.210 - 00:06:48.380, Speaker A: Yeah, you can try stopping share and then restarting it.
00:06:49.070 - 00:07:01.380, Speaker B: Okay. Zoom button. See, those buttons are on the black screen.
00:07:04.550 - 00:07:05.970, Speaker A: That's strange.
00:07:10.710 - 00:07:21.560, Speaker B: I can leave Zoom and come back. Okay, yeah, you can try that. We'll hold the fort. Cool.
00:07:22.330 - 00:08:16.000, Speaker A: We'll entertain everybody. Okay, so while we wait, whenever we have big breaks like this. I like to see where everyone's coming from. If you guys feel comfortable, you can put into the zoom chat, like what country you're from. I always find that really interesting. Or if you're in the United States, like your east coast. West coast? Whoa, this is super cool, seeing a couple portugals, Germany.
00:08:16.000 - 00:08:20.304, Speaker A: Okay, Ryan's back. Everything's looking good. I'll let you continue.
00:08:20.502 - 00:08:44.228, Speaker B: Wicked cool. Okay, I've moved the control bar over to the other screen too, just in case that happens again. Okay, so where was I? Right, we just got our first node going. We have our browser window. We were at inspect, and we were just going over to the console. Now we're in the console in our code. We created a variable IPFS.
00:08:44.228 - 00:09:04.908, Speaker B: So we can do await awaitip ID. And we can see our own peer ID here. We expand that out. We can see that these would be the addresses we're listening on. And this is an array of zero. So we are not listening on any addresses. And we want to be listening on addresses so we can get browser peers.
00:09:04.908 - 00:09:58.604, Speaker B: We can check if we do have peers and we can see we have nine. So these will mostly probably be IPFS preload nodes, which helps us access content when we're in a browser. We're going to move on to step one now, get BS code back open, and this will be the connecting to peers step. The first thing I'm going to do is update our constant. We have here the bootstraps, and we have now added in my bootstrap node. So what that node gives us is then we have the ability to we connect to a Goips node. And this actually gives us the ability to use circuit relay.
00:09:58.604 - 00:10:28.984, Speaker B: Now, really quick, I'm going to open up a diagram. And this is on Docs IPFS IO going to how to IPFS in the web browser, create a simple chat app. And we have this diagram. See if I can zoom that in. What we've just connected to here. Oh, no, it just keeps zooming is P to P circuit. And that allows us if we're stuck behind a Nat, we can form connections through the circuit relay.
00:10:28.984 - 00:11:02.176, Speaker B: Just like turn where WebRTC star works, more like stunt. So this means using WebRTC star, we can discover a peer, but if the knot gives us trouble, we can't directly connect with the pier. So we have to use P to P circuit. So using both in conjunction should more or less guarantee that you can always form a connection between peers. Moving on from that, we'll go back to Vs code and continue setting that up. So we have our bootstraps there. We're going to copy in a function real quick for the IPFS class constructor.
00:11:02.176 - 00:11:21.100, Speaker B: Can see the importance. Okay, yeah, good question. So we're going to quickly look over yep, the same file. So this is Kate. I happen to have this file open in there. So it's actually gotten from right here in the index HTML there is an import. So it imports IPFS min JS.
00:11:21.100 - 00:11:43.350, Speaker B: And if you look at your files, you have that file right there. So that'll work over IPFS. I just figured it's a simple way to just quickly get rolling. You don't need NPM or anything installed, but you're more than welcome to use it. Okay. Back to Vs code. So we are going to continue copying things.
00:11:43.350 - 00:12:32.500, Speaker B: All right, so we're going to get a function called Do Bootstrap and I might gloss over some of these functions bit quickly in the interest of time, but Do Bootstrap what this function does is this connects to our bootstrap nodes that we defined in this constant up here. And if reconnect is true, what it does is it initially disconnects from the bootstraps. So what will happen if a connection fails? Often it'll be left in your bootstraps. You attempt the reconnection but it doesn't seem like it actually attempts the reconnection. If you just manually disconnect first using IPFS form disconnect, that gets around that issue. So we'll just move right into the next function. And this function is probably the longest explanation of the entire workshop, but please bear with me.
00:12:32.500 - 00:13:14.526, Speaker B: I'll try to break it down as simply as possible and ignore the bad practices here. So we have process announced. So what we use Process Announced for is for Pub sub. We are going to subscribe to a circuit called, I believe it's called Announce circuit and we'll attach this function to it. Then whenever that topic gets a message, then this function will be called what this function does. So the first thing we do is we store our own ID. This is for use for comparison pretty much immediately after, for example, where if the message came from us, we don't bother processing it.
00:13:14.526 - 00:13:54.374, Speaker B: We already know what the information was. So we return. Then we decode the data. So messages on IPFS will contain all sorts of information but the data that you send over will be in data. So you want to decode that using a text decoder. And I expect that to be an address or just a string in general. So we search for peer alives, which I will be explaining a bit more later, but more or less we sent Keep alive packets because I noticed in browser if I don't do that then eventually I will disconnect from my peers and I have had a lot of trouble getting reconnected to the peers.
00:13:54.374 - 00:14:27.154, Speaker B: So if I just keep the connection alive with peer alives, I find that just totally dodges that issue altogether. We store the time that we last saw. Let's see, this would be a message from the circuit relay and the circuit relay also sends over Keep alive messages. Here is where we expect to receive a peer to peer circuit address. And what it does is it splits and tries to get the peer ID out of it. In the console log, you'll see these messages quite often. And that's the peer that you saw announced.
00:14:27.154 - 00:14:58.602, Speaker B: And then, just to make it clear, it compares it against your own peer ID. Then going on from there, we get a list of the peers we're connected to and this. Is simply to check that we're not already connected to the peer. Because if we are already connected to the peer, we're probably connected over WebRTC star, which is a direct connection, exactly what we want. So we just return. Then if we didn't, then we end up logging the circuit relay address and then we simply attempt the connection twice. Specifically twice.
00:14:58.602 - 00:15:19.306, Speaker B: Because I find very often it fails the first time. And the solution is literally to just try again. I find it doesn't fail twice in a row, and I'm not entirely sure what causes it. But this little thing here has helped me out a lot. All right, so that's the long bit. So we're going? To go ahead and add another helper function. This is check alive.
00:15:19.306 - 00:15:54.490, Speaker B: This is mostly just used to update the status ball in the corner, which is that little red dot that I mentioned right here. And then we're going to update our onload function with all new information. So we've now expanded our create. We've explicitly enabled relaying, which I'm not sure if you still need to do that, but it's here. We have done it. Then this is where we add in our WebRTC star node. These are both the same node just using IPV four and I-P-V six separately.
00:15:54.490 - 00:16:23.694, Speaker B: We attempt that bootstrap using that function we mentioned before. Every second we update our status. Ball. And here's where we actually subscribe to the announce circuit, attach the function to it and then we set an interval. So every 15 seconds we are sending peer alive on there so other peers can know if we are around. All right, so might be wondering what this looks like in the browser. It won't be a big change because we still don't have messages sending.
00:16:23.694 - 00:17:24.136, Speaker B: I have just refreshed here, and you can see that now we have a green dot. So we got the green dot because now we're actually connected to the peer to peer circuit relay, and it is advertising keep alive. We've detected those, and now we can see that we are in fact connected in a way that we can see other peers. So we're going to jump right into sending messages. All right? So we're going to scroll back to the top going to drop in a join channel function so I've made a simple wrapper this uses our prefix here combined with the channel that we specify so we can join channels related to our chat application that we're building here. It's a very simple wrapper just for subscribe, which we already used for the announce circuit. Copying.
00:17:24.136 - 00:17:47.104, Speaker B: Two more. So here we have send message and send message. So the first send message, this is just a simple wrapper again on two Pub sub. So this would be a publish instead of a subscribe. Basically the exact same thing. But we're sending a message now. That message doesn't have to be a string, it can actually be anything you want.
00:17:47.104 - 00:18:16.220, Speaker B: It accepts binary just fine. Then we have this send message function. So this is the more high level one. This is what allows us to actually get the data from the text input box so that's at the bottom of the web page. And then we're just going to copy in one more function before we update our onload. So this one's out. So this is used for just dropping the messages that we received into the message area.
00:18:16.220 - 00:18:43.190, Speaker B: So you can see what messages you got. There's a very simple replace on here to help prevent XSS. Just filters out the triangle brackets, replace them with their HTML safe equivalent. Then we're going to scroll down to the bottom into onload. We need to do a little bit more in here. After we do our bootstraps, we want to join a channel named Global. This way anyone who's following along will all be in the same channel.
00:18:43.190 - 00:19:37.876, Speaker B: And then we're also going to drop in this when we type in text and press Enter, then it will actually receive the message. So that seems all good so far. We are going to save that refresh. Give it a second to there we go, it went green. Going to give myself a little name here and then quickly open firefox. And then I'm going to name this one Fire Disco. If I type hello in this, it also shows up in here.
00:19:37.876 - 00:20:08.172, Speaker B: But hopefully if anyone else is following along then they will be able to see it as well. I see your question, George. Is it possible to encrypt messages? It absolutely is possible, but you'd have to write your own encryption scheme. Otherwise, as you saw, anyone can subscribe to a topic and see the messages in plain text just fine. So that would be a task left up to the developer. Oh, hey, I see more activity. All right.
00:20:08.172 - 00:20:46.360, Speaker B: Now before we run out of time, I'm going to quickly show just possible pitfalls and maybe where this could be taken from there. This is the shortest part possible pitfalls. So I actually ended up mentioning my main pitfall in all the other explanations. So the main pitfall was connections. Losing connections due to no keep alive. So if you're ever feeling like you cannot stay connected to these peers, don't be afraid to do something like this. This literally is just in the bootstrapping code.
00:20:46.360 - 00:21:25.300, Speaker B: You subscribe to a keep alive topic that everyone knows. I send one over it every 4 seconds. Kind of simple but that's really it. And then another pitfall I found while making this demo. So I'm going to show this off just because this will be the continuation from the simple demo that we're working on here. So you can see there's a lot going on, but this is the same base code just taken further. So you can see we got emojis and everything and we got picture sharing.
00:21:25.300 - 00:22:16.900, Speaker B: It all just works and it's all the same base code, a lesson I learned. So another pitfall when I was doing this is right now you can verify that a message came from somebody, but if somebody logged, like, let's say a bad actor logged that message and then replayed it, let's say several days later, maybe in order to make it seem like someone said something else, that would work. So messages are signed. You could get around that by setting a timestamp on your messages and then just checking. Like, let's say you have a rule, like, messages can only be three minutes old. Well, then after three minutes, those messages expired and you just reject them. So let's see, is the message delivery synchronous or asynchronous? That would be asynchronous.
00:22:16.900 - 00:23:02.950, Speaker B: It's very asynchronous. So if you sent a message and let's say your connection with the peer is bad, or maybe nonexistent, but another peer is connected and is aware that you are subscribed to that topic, the middle peer can relay the message for you, if that makes sense. And you can still verify that it came from the sender because messages are signed. I hope that answers it. Let's see, I'll get the presentation open again. So this would be a very good time for answering questions. I'm going to just get this open.
00:23:02.950 - 00:23:33.076, Speaker B: So here I've linked the guide that this workshop is based on. That's where I got the diagram that I opened up early on in this workshop. The demo that's linked there is the demo that I just had open showing everybody. Then we have the IPFS docs and then a link to Jsipfs. So I recommend everyone checks out everything they can. I personally really liked the docs IPFS IO. That's how I started my IPFS journey.
00:23:33.076 - 00:24:06.550, Speaker B: But yeah. Okay. What testing tools are available for IPFS? I guess that would depend what you want to test. I am not entirely sure how to answer that question. Yeah, I would say that entirely depends on what you want to test. All right, that's all I have.
00:24:08.680 - 00:24:52.530, Speaker A: Okay, if there aren't any more questions for Ryan, thank you so much, Ryan, for hosting this really amazing workshop. It was super informative. Thank you, IPFS, for sponsoring Hackfs this year. And I want to remind everyone that you can talk to Ryan on Discord in the Hackfs Sponsor IPFS channel. And also there's going to be workshops happening all week this week, including a brainstorming session on Thursday and a team formation later in the week, and kickoff is on Friday. So, yeah, really excited to see you guys at more of our events this coming week and hope everyone has a really great day.
00:24:52.980 - 00:24:54.830, Speaker B: Bye bye, everyone.
