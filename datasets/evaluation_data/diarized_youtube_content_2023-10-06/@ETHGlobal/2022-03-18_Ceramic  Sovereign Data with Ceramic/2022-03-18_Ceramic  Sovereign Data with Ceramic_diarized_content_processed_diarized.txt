00:00:00.170 - 00:00:20.730, Speaker A: Ceramic. I'll let Matthew give himself a quick introduction. I think we'll be taking questions at the end of the presentation, so if you want to put your questions in the chat, we will get to them afterwards. Make sure to use this chance to ask Matthew some questions as this stuff's going to be very useful for your build. But without further ado, Matthew, I'd love to give you the floor. We'd love to hear your presentation.
00:00:20.890 - 00:00:42.246, Speaker B: Excellent. Thanks, Luke. Hi, I'm Matthew. I'm with ceramic. Actually just joined the Ceramic team, like, two weeks ago as a developer advocate. So we're building the team out to try to better serve the developers in the community. We're excited to be here at the ETH Global event to talk to you guys about what we're doing over at Ceramic a little bit.
00:00:42.246 - 00:01:22.150, Speaker B: So we're going to start this whole presentation with a little bit of an overview and a vision of Ceramic. And then we'll jump in and I'll show you how to get started. Because I think that's one of the hardest things when you're stepping into a new project is how do I get this thing up and running? As Luke had mentioned, you can put your questions in chat. We have a limited amount of time. I don't know how many of them will be able to get to directly, but if I can't, for any reason get to your questions, make sure you put them in that discord channel there's one for Ceramic specifically. And then I'll show you guys our discord channel at the end of this. Please join and ask us whatever questions you have just in case we can't get to them.
00:01:22.150 - 00:01:46.394, Speaker B: So that's important there. So I'm going to go ahead and share it and we'll get this thing moving along. Hopefully we're in good standing here. I apologize if I'm a little bit grumbly and rumbly here. I'm a tad bit sick, unfortunately. Cool. I'm hoping we see a ceramic slide and that I shared this screen correctly.
00:01:46.394 - 00:02:05.720, Speaker B: If somebody in the chat can just thumbs up the fact that you see a nice dark slide on the screen that says Ceramic on it, you would be a here. Thank you. That is wonderful. Cool. So, as I said, ceramic overview and vision. We're going to start with the overview. What is this thing? Right, but before we dive too into that sorry.
00:02:05.720 - 00:02:54.270, Speaker B: Let's talk about who we are. The ceramic team. The team that's working on this project has focused significantly on a very deep Web Three experience. As a part of that. For the past few years, since 2016, they've been really adamant about shipping developer products directly targeted at managing that identity. Inside of Web Three, the big product is ceramic, and it's kind of made up of some smaller products like the Ceramic Koer, the Glaze Suite, Self ID and soon to be Cacao, which is currently getting fleshed out as we speak. The team is also responsible for creating some of these core Web Three standards that we see today, specifically around decentralized identity.
00:02:54.270 - 00:03:32.240, Speaker B: So if you guys want to go read up on the entire did standard and spec, go for it. There's the link. I hope you got a strong stomach for tech documentation. If so, but the point being is that we've been around the block for a while, deep into this space, and the project itself is not one that's going to go anywhere anytime soon, as it has some of the best backing right now in the Web Three industry. So that's a little bit on the history of things. So let's dive into what this thing actually is, which is what you care about more. I hope so.
00:03:32.240 - 00:04:16.894, Speaker B: If I had to sum it up in one sentence, okay. Ceramic is very simply a decentralized network for composable data. If only it were that easy, right? If only we could just hang on to this one sentence and never have to explain it further than that. Right. Even though that's kind of straightened to the point there's so much more going on, and it's not always the easiest to get up and running and working with right away, which, again, that's an experience that's currently changing. So why does something like this need to exist? And if we think about the Web Two way, the answer becomes really obvious without even answering how Ceramic is solving it. The web.
00:04:16.894 - 00:04:51.318, Speaker B: Two life, right? Like, there's a user, a service that typically interacts with another application or some other service at some point, that application calls an API. Maybe two, three, four API calls down the way a database gets hit. Right. But it's an API most likely that's interacting with that database. It's not the user or the original service directly. Which means that the view that we get back we're going to loosely call it a view the view that we get back from the data might be tainted. Right.
00:04:51.318 - 00:05:26.246, Speaker B: There's no way that we can trust that that's actually what was in the database. We can mutate that when we get it back, before we send it back to the app and eventually render it to the user. Right. The other major problem with this is that the data is really tightly coupled with this application. Typically, the app is the only thing that has access to all of the data. Sure, there might be some exposure of a small subset of that data that you can hit using some publicly exposed API. We see this a lot.
00:05:26.246 - 00:06:09.886, Speaker B: If you go to any Twitter, Facebook, whatever, there's an API for you that you can get information about yourself mostly. But it's not everything. Right. And this becomes a problem when you want to create an environment that interoperates well and in a decentralized way. And that's exactly what ceramic aims to solve. It's not just that decentralized network where we can store data. It's doing that with a goal of saying, hey, this application at any given moment can look up the data on the network because it's not coupled to its database, it's on this peer to peer network.
00:06:09.886 - 00:06:44.046, Speaker B: So I can just go get that. And the user of that application can then mutate that data in a way they see fit and publish that back to the network. And the second app gets that update in real time. Really cool things can be done with a system like this. Really simple things can also be done. Something as simple as your friends list can travel with you from your decentralized Twitter app down to your decentralized Facebook app. You'd never need to re add your friends.
00:06:44.046 - 00:07:43.760, Speaker B: They would just be a part of you and your identity the whole way. And that's a small example. Some simpler things that make this really intriguing is Preferences, right? Like if you like dark mode, what if every application you went to automatically toggled dark mode for you? We can get that by saving a little bit of data to this network that the applications are aware of and that they can load. Now you're probably wondering, well, there's some challenges with this. How does the first app know what the second app knows? And how do we make sure that everybody creates data in a way that everybody can read and understand? And that's currently where the biggest challenge lies. And it's one of the things that we're working on and really leaning on the community for to say, hey, help us figure out what a standard social profile on Ceramic looks like. Help us figure out what a standard preferences profile looks like.
00:07:43.760 - 00:08:37.502, Speaker B: We most likely are going to be putting a cool little demo in that board channel for you guys so you can see some of this interoperability with Ceramic in real time. So going back to our initial statement of Ceramic is a decentralized network, right? Solving data interoperability. We can kind of expand on that a little bit by saying if you use Ceramic, you're able to create and serve dynamic content through applications. That content gets created by an identity, one of those decentralized identities that the team has been so ingrained with. Typically they create that by using a data model, but they're not bound to that. We could kind of put any data we want into the Ceramic network right now. The data model makes it to where it's more composable.
00:08:37.502 - 00:08:57.042, Speaker B: We can share it and say, hey, the data for this app looks like this. This is the schema. If you use this schema, then we have interoperability. It's not a mandatory piece, so the data model part is optional. But then where does it get stored? Well, it's not on your back end. It's not in some mongo database somewhere. It's not in a SQL database somewhere.
00:08:57.042 - 00:09:37.298, Speaker B: It's on the Ceramic network itself, which is a collection of nodes running the Core Ceramic client in a peer to peer manner and sharing the information about the streams and the data models. So that's the long way to explain what Ceramic is. Let's talk about what the vision of our team is going forward. Right? I think that's important too. All of this matters because if you're going to build something like this, you're looking to solve some things. So there's a couple qualities that we sat down and decided were things that Ceramic cared about. They kind of fall in the four pillars.
00:09:37.298 - 00:10:13.018, Speaker B: The Ceramic network has to be scalable, it has to be mutable, it needs to be flexible. And it absolutely should check the interoperability box. And that means there's a local first design to this. When you're creating an application, you're spinning up a ceramic node rather than a database and you're interacting with that. And that node is probably running local on your machine. Depending on what network you put it on, it can communicate with other people's nodes and then we get the shareability about it. But the reason for this is so that we can get faster real time updates.
00:10:13.018 - 00:10:52.966, Speaker B: If you had to query across a giant network to get information, it's going to take a little bit of time. By being local first, it's a little bit faster. It also eliminates the need for some large global consensus situation taking place all the time. The data has to be mutable, right? Like we want the users or soon even applications to be able to update the data that exists on the network. And that's kind of a little bit backwards if we want to trust the data. Right. And how we trust it is by making the history of all those changes a read only state so we can see what's changed.
00:10:52.966 - 00:11:24.022, Speaker B: We can read that at any moment. It's a matter of we'll allow you to make those changes. But the history itself is the source of truth for the existence of that data stream. It's flexible, right? So whatever you need as far as format goes, the types of data or types of streams is what we're calling them, streams. Those types are expanding and growing. We're adding more stream types as we go through. So if you go to jump in with Ceramic and you're like, man, Tile Document isn't what I need.
00:11:24.022 - 00:11:36.794, Speaker B: Tile Document is just like a MongoDB document. It's just a JSON document. It's very similar to that. It's not mongo. It's the easiest way for me to explain it. There's a Tile document. Data stream type.
00:11:36.794 - 00:12:15.014, Speaker B: You might be like, that's not what I need. We have a couple other stream types currently and there's more in the works. So Ceramic is aiming to expand that not only the type of data, but then standardizing it in some way to make it a single unified interface so that everybody has access to that data. And that data is tied to a user. Kind of a user can be an application in this sense. It's really tied to an identity that decentralized identity. So anything that that identity owns as far as streams go, other apps can call on if they know about them.
00:12:15.014 - 00:12:42.538, Speaker B: So it's pretty cool. And that makes it also blockchain agnostic, which is like one of the cooler things about this. It's all layered on top of IPFS and it has a lot of interchangeability for the underlying blockchain technology taking place. So you're not bound to just building on Ethereum if you're going to end up using ceramic. Polygon is also supported. I think there's going to be more support added as time goes on. Right.
00:12:42.538 - 00:13:31.358, Speaker B: So this really makes it to where you have flexibility as a developer. And ultimately, hopefully, this drives a completely new era of open source information where we desilo data and we can have verified credentials running around, we can have preferences that follow us, we can take conversations with us everywhere we go. And it's not one company or one application deciding what data looks like. It's an entire consensus of ecosystems saying, hey, this is the type of data that's valuable to us and we can access it from all around the web. It's shared by the people that care about it. And the most important thing is you control it. It's your data.
00:13:31.358 - 00:14:19.754, Speaker B: You get to use it whenever you want, however you want, and wherever you want. And that's one of the major, major things that matter. When we're building out something like ceramic, what can you store? Well, there's kind of like six core components of what we mean when we say sovereign data. Sovereign data is really hard to unpack. So if you just think of all the stuff that could fit into these buckets of ideas, these components, right? ID and reputation, verified credentials. We mentioned things like cross app data, which would be like credentials or cookies that you might have, maybe user preferences, maybe you have some NFT content that you want to use. It most likely falls into one of these components.
00:14:19.754 - 00:14:59.446, Speaker B: And when you combine these, just like the whole Captain Planet thing, depending on if you follow cartoons in America as a kid, you kind of get what we mean when we say sovereign data. This is a complete picture that you're in control of. So before we jump into getting started, I just want to make everybody aware. We do have two bounties for this hackathon. The first one is to create a decentralized social app that leverages both ceramic and Lens. The app should also include a data model. Second one is to create an application that takes the Lens profile NFT and uses that as a stream controller with ceramic.
00:14:59.446 - 00:15:39.366, Speaker B: Again, couple that with a data model. So we're going to jump over, do the getting started, and then I'll shoot you over the discord link and we can go from there. So this is a good old section of Vs code here and what I really want to do is show you how to get up and running. The first thing is you're going to need the ceramic CLI. This is the core component of ceramic. It is what allows you to run a ceramic node. Once you have that installed, you can simply run your local node.
00:15:39.366 - 00:16:22.758, Speaker B: So I'm going to open three terminals to kind of separate these concerns a little bit to make it easier. I'll rename this one ceramic, and this terminal is just going to run ceramic. So once you have that package installed, which is a simple NPM, install it's in the docs. You're going to do ceramic and you can where is it at? I've glazed my way through this enough. Okay, we'll just ignore it. The demo gods are going to get me because I'm not feeling very well at the moment. So we'll do ceramic, and then I'm just going to specify a network for this.
00:16:22.758 - 00:17:00.098, Speaker B: And that network for me is going to be local. And if you don't specify that network there we go. That's what I wanted. It's the Damon. If you don't specify the network, you end up on test net by default, which is fine. But since I'm just doing a quick demo here, I'm going to keep it all in memory, rather, because I've published this data model 4567 times, it doesn't make sense to constantly keep putting that on the testnet. So if you don't pass in that network flag, you'll be on testnet and your stuff will be shareable, which is cool.
00:17:00.098 - 00:17:34.938, Speaker B: So that's all it takes is you're going to take the CLI, you're going to install it, and then you're going to say, hey, like ceramic, start the daemon. You can just hit enter there and you're going to get a node that's running, right. So I currently have ceramic running it's on this machine. I could now query it if I want. There's not a whole lot going on as we might speak. So the second piece of this tech stack that matters is called glaze. And glaze is like a layer up abstraction that helps you interact with the ceramic network a little bit easier.
00:17:34.938 - 00:18:02.454, Speaker B: Again. It's an NPM package. So you would simply come in and do an NPM install. You can install the glaze CLI and you'll have access to glaze. So I'm going to go ahead and I'm going to set up this terminal. We're going to call this glaze. And the first thing I'm going to do once I have glaze installed is I need to create that decentralized ID, because again, all the data that we're going to work with is tied to an ID.
00:18:02.454 - 00:18:24.990, Speaker B: So I have to have an ID, and that's really simple. We'll just take glaze and we're going to say, hey, take the did and create a new one for me. And we hit enter, and we get two things. So we get the actual decentralized ID, and then we get this seed. The D is cut off. Kind of weird. We're going to want to copy this seed.
00:18:24.990 - 00:19:03.530, Speaker B: We're going to set this as an environment variable in two terminals. The first one is this terminal. We're going to export did key, and we're going to set it equal to this. This will allow us to use Glaze without having to pass this key. Every time we run a Glaze command, I'm going to come back over here to my main terminal, and I'm going to do the same thing. We're going to export did key instead of equal there. And this will allow us to read it into the application that we have as an environment variable to use it to actually set up the ceramic instance.
00:19:03.530 - 00:19:24.320, Speaker B: All right, glaze is up and running so we can interact with the network in an easy way. Ceramic is up and running. We have that node going on over here. Even though nothing seems to have happened yet. That's okay. And we've set up our environment to get started. We have our seed for our ID saved and ready to go.
00:19:24.320 - 00:19:59.722, Speaker B: The next thing we're going to do is we're actually going to create a data model. And that model is really just a collection of a definition that defines what schemas belong to it, and it gets associated with a decentralized ID. So this ends up on the network. And this is one of the key pieces to the interoperability, letting different applications pull the data model, and they know what the data is going to look like. We're going to use Glaze for that. We simply say hey, glaze model create So create us a data model, and we're going to give it a friendly name. We're going to call it LF Grow.
00:19:59.722 - 00:20:32.406, Speaker B: Why not? We hit Enter and we have a model that's as simple as it gets. We can take a look at it, inspect and oops, spelling matters. Fat fingers don't. And you'll see that we don't have anything in it. It's a very empty and blank model, so we need to add some schemas to it. I've staged a couple of schemas to make this quicker. I'll show you what they look like.
00:20:32.406 - 00:21:00.638, Speaker B: We're going to start with this schema, which is a person. It's nothing fantastic. It follows the syntax and the guidelines outlined here at JSON. Schema of this specific draft. If you want to know what keys you can use and what restrictions you can place on this schema, you're referencing one of the standards. In order to pull that information over, we're going to title it hey. This schema is going to be called a person.
00:21:00.638 - 00:21:25.400, Speaker B: It's going to define a person. We tell it what type it is, and then we define some properties. Our person is going to have a name, which is a string. It's going to have an age, which is an integer. It's going to have friends, which is an array of more people. Right? Probably not the most flexible schema in the world, not necessarily the point at the moment. I'm showing it to you this way because it's a whole lot easier to read.
00:21:25.400 - 00:22:16.962, Speaker B: And what I'm going to do is I'm going to use Glaze now to put that into the model, right? I want to load it into this schema's model or into the LF grow model as a schema. So the way I do that is I say, hey, Glaze, we're going to use the model API. We're going to add to the LF grow model a schema called Person. And we're going to paste in that super awesome JSON that we had because we have our environment variable set with our did seed. We're not going to have to authenticate for this. It's going to read right from there. And now we have a model that's updated and we were to inspect that's.
00:22:16.962 - 00:22:38.510, Speaker B: We can see now there's a schema associated with that. The next piece we're going to add is the actual definition for the model. And it's going to look like this. It's a name, a description, and a schema. That's all the definition is. What are we naming the model? In this case? We're going to name it Lfgro, the description. Hey, it's a demo model.
00:22:38.510 - 00:23:16.950, Speaker B: And what schema does it point to? And it points to this schema back here, specifically this version. And we're taking the version rather than this identifier for the schema because you can have changes to your schema, and this will allow breaking changes to not impact you if you're just grabbing a specific version of the schema. So we pass that in right there. So we'll go ahead and do that. Same thing as before. Hey, Glaze, we're going to use the models. We're going to add to the LF grow model a definition.
00:23:16.950 - 00:23:50.486, Speaker B: We're going to give it an alias, a friendly name we can use. It's going to be Person definition. So now if we, again, one more time inspect that, you can see that we have definitions that are loaded, and there's a version for that definition. It's pointing to a schema, which happens to be a version up here. And the schema exists. So our model is starting to be built out and packaged altogether. So we're happy with that.
00:23:50.486 - 00:24:21.120, Speaker B: We don't want to add actually any data right now. We'll do that through our application. Like, life is grand. Let's go ahead and publish that. So we're going to publish that to the ceramic network using Glaze. Again, this is all like pre application build, just getting set up and running, right? So we're going to publish the ceramic node that we have running over here, and we're going to publish that LF grow model. We're also going to create an output file so that we can read it into our application.
00:24:21.120 - 00:24:41.074, Speaker B: Boom. So everything is published to Ceramic. Again, nothing's really happening over here. That's okay. And we now have this file that outlines the model for us. If we go ahead and take a look at it. We clearly just see it has definitions, the person definition.
00:24:41.074 - 00:25:10.298, Speaker B: It's everything that we get when we look at Inspect just in JSON format. Okay, I know we're moving quick, so bear with me and life is grand. The next thing we're going to do is actually interact with it. Okay, so that's great. Let's go ahead and fire up some JavaScript and we'll interact with this thing. Let me minimize this for now. As you might expect, as developers, you guys are going to need to import some dependencies.
00:25:10.298 - 00:25:54.590, Speaker B: You can find the list of dependencies that you're going to need in the Ceramic docs. It really depends on what did method you're going to use. In this case, we're using did key. If you were using something like three ID connect to tie this into MetaMask, these imports are going to change a little bit. The overall flow of this does not though. Basically what our code is going to do is it's going to read in that seed that we set as our environment variable and it's going to use that to set up and authenticate our did service that we're then going to pump into a Ceramic client. So now when we use Ceramic, we are interacting as that identity that we put in there.
00:25:54.590 - 00:26:15.826, Speaker B: Okay, so we'll start once we have our client, we're going to read in that data model. So that was in the model JSON. We're going to load that in so that we can reference it by its friendly name. We can just say, hey, use person. That's an alias. We know what Person is, we know what it looks like. And then we're going to set up a did data store.
00:26:15.826 - 00:26:38.170, Speaker B: We can interact with the data in both of these ways. Using the did data store, it ties it to the identity. So it's a little bit more tightly coupled with the identity. So that's what that looks like. I'll show you this. It'll be simple. We're going to create a variable that just follows or an object rather that just follows our schema.
00:26:38.170 - 00:26:55.166, Speaker B: And then we're going to say, hey, like the data model stuff, create a tile. And that's because this is a tile document. Sorry for the pop up. That's because this is a tile document. This is the data type that we're using. It's tile document. So create a tile that comes from Person.
00:26:55.166 - 00:27:28.522, Speaker B: Well, Person is the alias that we had loaded in. That's what we named that thing. Put this data into it and then show us the ID of it. Right. It's nothing crazy, but we're about to write some data to Ceramic that contains what we need it to. So I'm going to run this script. I just made a quick NPM script thing in here because there's a flag that I needed to add for experimental JSON features for me.
00:27:28.522 - 00:28:10.790, Speaker B: So ignore all these warnings. This is the output of that so we created a stream, a data stream when we put John Doe into the ceramic network. And if I were to copy that, I can use ceramic now finally to show that and it's going to take a second. And we just pulled that record from the ceramic node that's running locally. And what's really cool is if this was on testnet or mainnet and it was able to communicate with other nodes, we could just take this same stream ID. I could pass it over to you and you could get this information into your application as well. So that kind of pulls us to time.
00:28:10.790 - 00:28:29.680, Speaker B: Unfortunately there was a couple more things. It was just showing you how to use the ID data store and how to use ceramic itself. Right. Three different layers. They're all doing the same thing though. They're all writing a stream and they're all getting data back from a stream. So I know that was a lot.
00:28:29.680 - 00:28:53.960, Speaker B: We didn't want to stop sharing quite yet. I know that was a lot and I know that there's not a ton of time to ask questions here. So what I want to do is leave you with this. I know this kind of sucks to type. Okay, cool. If we can run a little long, I'll run a little long. I'll leave this up here right now too.
00:28:53.960 - 00:29:29.140, Speaker B: I will paste this in the ceramic sponsor chat for the East Global Discord. This is our discord if you want to come over to ask us more pointed questions. But let's jump back to the demo since we have the time. I'll put it in that chat. Okay, so we have a note. This stream ID is queryable from other applications that are connected to ceramic nodes where those ceramic nodes are able to communicate with one another. So testnet, really good way to get nodes together.
00:29:29.140 - 00:30:05.678, Speaker B: I'm actually going to take this and we're going to use this here in a second. So I'm going to take this stream ID, which we're calling all the tile documents, the actual data itself, we're calling them streams. So I'm just going to go ahead and comment this out. We don't need it anymore. That was just one way to do it. And what I want to do is we're going to jump to use ceramic instead of the did data store right now. And in order to use the ceramic part of all of this, the ceramic library, you need the stream ID.
00:30:05.678 - 00:30:39.158, Speaker B: So this is querying known documents, right? So you have to have the stream ID. There are ways to get the stream ID but if you have them then instead of using the ceramic CLI, we can just call the ceramic library and load that stream too. So that's what we'll do. Now I'm going to run my show Magic script and bam. So that queries it too. Are we getting much difference out of this? No, one of them is a terminal. Way to do it.
00:30:39.158 - 00:31:25.880, Speaker B: And the other one's programmatic, that's all I'm trying to show you is that you can call on ceramic the same way two different ways if you need to. What's great about this is now you can do like your application could do whatever it wanted to with the content. Yeah, I'll share the magic script also. It's honestly just node with a flag to use experimental features, but I'll show it to you. So now if you loaded that stream into your application, you have access to this. So you could say, hey, every user who's 40 or older gets access to whatever chat room, right? The 40 and up club or whoever has friends. Maybe I can start mapping out a contact list of all of your friends because I'm a social app or whatever it might be.
00:31:25.880 - 00:32:16.514, Speaker B: Looks like we got some stuff in Chat. Can a ceramic model be modified from a D app too by using just a stream ID? Yeah, you can modify stuff so you would load that stream in and kind of apply an update or a mutation to it and write it back. That would be the exact idea is on DAP One maybe I add my best friend to his wallet, to my contact list because maybe I'm bankrolling his gambling habit with crypto, I don't know. And then on DApp Two I need to send him something else or I just need to know his address for some reason or he changed it. I could edit that on DAP Two if I wanted to. So it's not just for queries, it's also for writing data. If you remember the first thing we did up here with Model create tile.
00:32:16.514 - 00:32:52.862, Speaker B: We actually wrote the data so we could mutate it in this same application if we wanted to. And we could do that with ceramic or we could do that with the did data store. It's totally up to your convention on how your development is going. So the final piece to this demo is using that data store. So these documents that we put on Ceramic, they're kind of there. They're not like tightly coupled with my identity. They're attached to the identity.
00:32:52.862 - 00:33:58.120, Speaker B: Remember we had the seed, but they're not super easily queryable, right? Like we needed the stream ID to do that. Whereas if we use this did data store, we're actually going to say, hey, load the person definition. If you remember, that was a friendly name that we gave to the model. So we're going to say, hey, take this data that we want to store, find this, schema this definition, this data model that I know the name of and write it as it should be. And then if we wanted to query for it later, we can just say, hey, like store, go get the tile document or the stream rather associated with this alias. So this just becomes a little bit more user friendly or developer friendly, really. For us to write and read because we don't have to keep track of nasty stream IDs along the way nearly as much.
00:33:58.120 - 00:34:26.382, Speaker B: So I'll show you this. It's not going to be any more mind blowing than the other stuff. And then I'll show you my script. So we just have a second person. We're going to use the data store that we set up up here. So we're saying, hey, grab our ceramic instance and take the model out of this and create a data store that's really tightly coupled to the Identifier. And that Identifier could be something like three ID connect.
00:34:26.382 - 00:35:07.898, Speaker B: If you were going to build social apps, we spun up a key ID so our application can write data. It doesn't have to be a user. So we're going to say, hey, grab the person definition, stuff this in that person definition and yeah, then we're going to be good to go. And you might be asking what the person definition is. I'm pretty sure that is. Sorry, when we ran the Glaze command earlier, we said that we named it I'll show you what we typed. We named it person definition, right? So we ran this Glaze model ad and we gave it this friendly name of person definition.
00:35:07.898 - 00:35:23.362, Speaker B: So that's kind of where we're getting that from. Not kind of. That's exactly where we're getting that from to load that. So we don't have to know the schema. We don't have to know what's in it. We've already loaded that model. It's helpful if we know what's in it, but we can use it now.
00:35:23.362 - 00:35:53.758, Speaker B: So we'll go ahead and do that. We'll show magic, takes a second. We're not frozen. Cool. And now we have Jane Doe. So this was both a write and a read. So we actually set the store using a friendly name and then we read the store using again the alias that we set up so we didn't need a complex stream ID.
00:35:53.758 - 00:36:22.946, Speaker B: And now we can do whatever we want with it. Right? We're just council logging it, but my application can make updates to it. To go back to the question of can D app two modify this? Yes, it might be wise to know. I think it's set here. One of these methods I forget off the top of my head. You'd have to look into the docs a little bit. One of them will do a complete overwrite.
00:36:22.946 - 00:37:05.746, Speaker B: So if we only wanted to update Jane DOE's age and we used, I think it's set that we would completely overwrite it, whereas there's a merge option that would just append to it. And I can't remember if that's on the store or if that's on the model manager, but one of them does a complete overwrite. The other one just appends and mutates only what's needed. So that's again digging the docs. But the answer is yeah, we can change that now that we have it. And again, if the model is published and the model is published to a ceramic network that can communicate with other nodes, then my D app can pull this. I don't have to know the magic behind it.
00:37:05.746 - 00:37:28.806, Speaker B: I just need to know the name of the model. And that kind of goes back to hey, if you're going to approach the bounties and stuff, include a data model. We're trying to figure out what that means for the rest of the space. So I'll show you my little script here. It's nothing of crazy. It runs node. This is show magic.
00:37:28.806 - 00:38:15.050, Speaker B: It runs node with the experimental JSON modules flag and then it just calls my main. If I don't do this, then when I'm reading in the JSON here, it tends to break and not work. So that's what it is, is that anyone knows did can read and modify the corresponding data model. So it's not necessarily knowing the did, it's knowing the stream ID. But the stream ID is kind of attached to a did. So I'll try to paint a picture for you that helps reconcile this. I'm a user.
00:38:15.050 - 00:38:39.650, Speaker B: I click onto an app. It says Connect my wallet. I connect my MetaMask wallet. The developer is using ceramics. So in that case, maybe they're using three ID connect. And when I sign that transaction to log in and not a transaction, it's just a signature, right? It's not going to charge me. We're not putting anything on chain.
00:38:39.650 - 00:39:29.778, Speaker B: I'm going to get a did that now becomes associated with my wallet being logged into that application. So when I fill out my user profile, like when I fill out my name, my age and my friends, and I post that to the ceramic network, it's associated with my did, right? So it also has a stream ID. So any app could query the stream ID. And then when I go to D app two and I click Connect Wallet, they're also using three ID connect or whatever it might be, they get my did rather than generating a new did because maybe that's what I chose to do. I can also create a brand new did if I want. But let's say I want the interoperability. So I choose to reuse what I have.
00:39:29.778 - 00:40:34.246, Speaker B: Now I can query for the data models that are tied to that did because it's the same did. So if I said hey, for this did, get the person definition, that's how it's going to get it. So it's a little, I guess, harder to understand with the key because we kind of just generated it through the terminal rather than through something like ethereum wallet. Which is why I will post I'm trying to get permission from the person that made the tutorial, which is why I hopefully will post a small video for you guys in the discord that will show exactly what you're asking. It's a cool little video that the user logs into. App one, they fill out a basic profile template and then like two or three other applications also speak that model's definition and they load things like its profile picture or a couple of other descriptions and stuff. So you kind of get a better idea by looking at that.
00:40:34.246 - 00:41:10.980, Speaker B: And a part of that tutorial is them creating a did with three ID connect so you could see how a user might use it. Whereas in this case, the key ID might be better suited from the application's point of view of saying like, hey, I'm an application, I'm going to write data so I'm going to use keydid. It's one possible use case. Is there a mechanism to protect the data model from attack? Someone adds a lot of garbage to the data. That's a really good question. As somebody who's super new to the team, I don't know if you're cool with it. I'll follow up with you in Discord about it.
00:41:10.980 - 00:42:00.702, Speaker B: I can shoot a message over to who is going to know that. And I think the biggest mechanism is the fact that we do have anchor commits that are on chain so we could see if things are wrong. But I will definitely ask and follow up because that's a really good question. User preferences and other user data could be shared across DApps. Won't a user look at this like an intrusion their privacy? No. And I can say that really confidently because if the DApps you're using are, let's say, ceramic native, or they're built with this idea of interoperability in mind, they're not going to store anything that you didn't give them permission to store. So again, this is all elective.
00:42:00.702 - 00:42:44.834, Speaker B: I have to decide to put this data where I want it to be. That doesn't stop the application from logging some of the stuff you're doing and putting it on chain. So I would go back to saying, hey, be cautious of what you use, know what applications you're interacting with. But outside of that, it's a voluntary opt in process. Like you click the connect wallet button, you know what saying. So I don't think it's a violation of privacy if we choose right and the fact that we get the choice. Remember that's like one of the major things that ceramic cares about is the fact that users get agency over their data again.
00:42:44.834 - 00:43:14.870, Speaker B: So we're trying to make sure that you're only putting what you want to put inside of the ceramic world. The problem is we can't stop nefarious developers. Right? So good questions. Are there any other questions? Okay, if there are, discord. Is the place I'm hanging out in Discord? Yeah, definitely. Let's continue the conversation in Discord. I'm hanging out in discord.
00:43:14.870 - 00:43:46.370, Speaker B: I'm probably not going to hang out hard this weekend in Discord, but all through the work weeks I'm there. Again, I invite you over to the Ceramic Discord. You'll have access to more than just me. If you do that, you can ask those hard questions to the engineers that are actually working to solve those problems. So come join the conversation and we'll do everything we can to help you. And I appreciate the fact that 1716 of you, however many of you decided to give me 45 minutes of your time, I think you all are crazy. So have a good weekend.
00:43:46.790 - 00:44:08.198, Speaker A: Well, we love having you, Matthew. It's been a great presentation and I know I can speak for the audience that we had a lot of fun listening and interacting. Thanks for joining us this afternoon everyone. I'm sure you guys enjoyed it as much as I did. As he said, continue the conversation in Discord. Definitely reach out in the ceramic channels. I did post a link that he shared earlier in our chat to the ceramic discord follow up there.
00:44:08.198 - 00:44:09.606, Speaker A: They're a great resource, they're a great.
00:44:09.628 - 00:44:10.286, Speaker B: Team to work with.
00:44:10.308 - 00:44:19.900, Speaker A: We love having them back and we'll be ending the session here, but I want to give a quick thank you to Matthew one more time. But good luck with building everyone. We look forward to seeing.
