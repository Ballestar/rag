00:00:08.450 - 00:00:48.830, Speaker A: All right, I'll get started here. So this presentation is about scaling EVM on scale blockchain. You might have heard the presentation yesterday. Again, with Scale, we're trying to really want to unlock the potential for Ethereum. We want to unlock the design constraints that Ethereum has work chain and provide a lot of extra scaling benefits and features configuration for data. We really believe in open model and architecture for the future. And so we've attempted at Scale to build an infrastructure that is arguably complex.
00:00:48.830 - 00:01:24.126, Speaker A: But for the DAP developer, it's very simple. We wanted to take similar to an AWS model. When you are deploying an application, you need feature sets, you need performance, you need scalability. AWS can provide you with those features. You can select different servers at P two Micro and M three large. You can add in your relational databases as you scale your platform need extra features. So why can't we have this in terms of the DAP developments that we're doing today with Ethereum and Solidity? Scale is here to provide that.
00:01:24.126 - 00:02:23.706, Speaker A: We're here to sort of replace AWS as sort of the decentralized cloud model for decentralized applications. So today I'm going to walk through a little bit about the Scale infrastructure because I think a lot of questions. One of the presentations we had yesterday is like, okay, well, how do you achieve this? I want to give you a little taste of how we're able to achieve this sort of AWS like marketplace for decentralized applications. And then I'll walk into a use case for file storage specifically and I'll go into a new product releasing this weekend. It's hot off the presses called Scalaml. And this is a way to combine trained machine learning models with smart contracts which we think is going to provide a whole new interesting business model or applications for DApp developers out there. So, by way of introduction, my name is Chadwick Strange.
00:02:23.706 - 00:03:15.140, Speaker A: I run product scale. Scale is a platform where we provide scale chains for DApp developers to deploy their solidity apps onto. And it's also on the other side of the platform we have validators to prove of stake network for providing computing power to the network. So both sides is running products. I help develop the feature sets and all the configuration layers for the scale elastic blockchain as well as provide all the software for all the validators providing computing power to the network and the integration between which is actually very interesting. It's a scale manager system which is a set of smart contracts that orchestrates the entire business logic and security model around the scale network. And this set of smart contracts lives on the Ethereum main net.
00:03:15.140 - 00:04:18.050, Speaker A: So why should you use Scale? Again, we've always said that Scale our vision and our mission is provide open and decentralized technology for DAP developers. We believe in a world of decentralized business models. So we're decentralized and there's a few dimensions of decentralization. First off, our consensus mechanism is probably, as far as I know, one of the first fully asynchronous models. This means that messages sent back in between different nodes, there's no assumption around the timing of those messages being received. A lot of other consensus protocols are partially synchronous or maybe fully synchronous, and they require assumptions around message delivery guarantees. So what this means is that if there's a network split, if there's some network split between North America or the validator sets in North America and Asia, that split will not create a consensus crash.
00:04:18.050 - 00:05:12.418, Speaker A: It actually creates a consensus pause once that network is reestablished and those messages can then continue to pass consensus resumes. So the security model around asynchronously we are a leaderless protocol. So unlike some other protocols where a single validator is actually elected to propose block to be committed to the chain, that's arguably a little bit centralized. If that leader can be Byzantine with scale, it's fully leaderless. All the validator nodes who are participating in proposing a block do so in parallel and in synchronicity to commit those blocks to the chain. We have a multi tendency model, and I'll talk a little bit more about this around the node architecture. So every node that supplies computing power to the network doesn't just provide computing power for a single scale chain.
00:05:12.418 - 00:05:58.520, Speaker A: They can provide computing power up to 128 individual scale chains. We're also businessing fault tolerant. So given that the number of nodes that supply computing power to your scale chain, less than a third of them could go Byzantine, and your consensus, your operation of your scale blockchain will continue as it moves. We use DLS threshold signatures, which is arguably a form of sort of Byzantine cryptography that provides security assumptions around data availability for our scale chain. And we are open source. A lot of our technology is fully open source right now on GitHub. We have plenty more that's open sourcing in the next couple weeks.
00:05:58.520 - 00:07:01.850, Speaker A: And all of our technology is sort of under the umbrella of the Node Foundation, the network of decentralized economics. This is a nonprofit foundation that is securing the sort of long term view of the scale network and the performance and business viability of the scale network. So what is the scale network again? It's a proof of stake network that's supplied by many nodes or validators, who are providing computing power to the network. So this is a permissionless network where all the nodes are operating together, orchestrated by the scale manager, what sits on ethereum, and all of the incentives, the economic incentives, are driven by a scale token. So network validators earn scale tokens in terms of inflationary and bounty rewards and they state scale tokens as part of the group of state security models. And there's a unique monitoring algorithm such that every node is watching every other node. So there's an accountability.
00:07:01.850 - 00:08:00.010, Speaker A: Every single node in this network is measuring and pinging random set of other nodes in the network and measuring things like latency uptime performance and other quality statistics such that if a node becomes unperformant or has a lot of downtime or has a lot of bandwidth issues, that they get proportionally decreased bounty rewards over time. So in this way, the network is holding everyone accountable for good performance and good operation. So when you select a scale chain, you're basically interacting with the scale manager system ethereum contract and you're requesting this scale side chain. And the manager selects a subset of nodes at random. So this could be actually we set it at the default of 16 nodes. So 16 nodes will supply your production ready scale side chain. Those nodes are selected at random and they provide all the computing power that you need for your network.
00:08:00.010 - 00:08:50.630, Speaker A: So this is done by a random node selection that's right now driven by special signatures and these nodes are rotated randomly. There's a rotation algorithm that swaps out nodes over the network over time. In this way, if you're operating a chain for maybe two years, say you're operating in a very expensive debt over time, it's just a static. Nodes can eventually understand what different dashes they're actually supporting. We swap this out in order to have it to providative measure for any collusion that might occur over time. And we have a unique consensus mechanism that operates on all these nodes. And you can deploy your smart contracts, interchange messaging, storage, scalaml.
00:08:50.630 - 00:09:45.600, Speaker A: These service layers are deployed on these scale chains. So when you select a scale chain of a certain size, you can select the service layer that you want, very similar to an AWS model according to what you need for your data. So how does the node work? So the node about 1000 scale nodes can run up to 8000 independent scale chains. Again, scale chains come in different sizes, like A, T, two micro and three large. We have a small, medium and large type of scale chains which provide your DAP with a certain amount of memory and storage layer. So if you need sort of a lightweight app that doesn't require a lot of storage, you can select a small scale chain. But if you need an app that has a ton of storage and needs the upper bound of transaction throughput, you can select a higher category for your needs.
00:09:45.600 - 00:10:27.974, Speaker A: So each node actually has an allocation layer that can be split up and divided in. And so each allocation layer can provide a separate side chain. So if you select a small every 60 nodes, a very small proportion of that node is allocated to your scale side chain. And this is done through docker containerization. Again, you could create a much larger chain if you want to access more performance and storage power and so on and so forth. So why should you use scale? The thing we had in mind is we wanted to make it as easy as possible for Ethereum developers to use scale. So we're fully compatible with EVM.
00:10:27.974 - 00:11:17.926, Speaker A: We've done this by taking, again, a lot of inspiration and a lot of great hard work from Ethereum. We've taken Alice, we made some slight modifications to Alice client and we call it Scald. And this is also fully open source. Why else should we use scale? Well, really effing fast and you'll see this, and I think we demonstrated this with Christine's example yesterday, where you can really improve the UX performance of your app. No longer do you have block confirmation times, you have almost immediate subsecond finality. So now you can build apps such as marketing Paywalls for blogs and whatnot. Instead of having to wait, you can actually transact commit money to a Paywall and completely access the site within seconds.
00:11:17.926 - 00:12:05.238, Speaker A: So we think this is really going to drive a whole new way of making your gas feel more like apps and you could write more powerful applications. No longer are you constrained with sort of simplify or reducing the amount of gas in your contract. We do have gas on our platform, but it's actually done as a metering agent to prevent DDoS attacks. But effectively, gas price is zero. So now you can include very interesting execution layers or complicated computations within your smart contracts. Why else? Well, we have many bridges through Ethereum. So we have bridges that support East ERC 20, ERC 721 and messaging state to transfer between Ethereum chains and scale chains.
00:12:05.238 - 00:12:57.930, Speaker A: This provides a whole new sort of design pattern for DAP developers to basically use the proof of work chain as a security layer to secure all their ETH ERC 20 ERC 721 assets and then provide all the scaling infrastructure on a scale chain. But we've also seen the opposite. A lot of ERC 721 apps, they actually want to deploy most of their applications onto scale or most of their DApps onto scale itself. They have a minting function. They can mint incredible amount of tokens and have people use these tokens. But then if a user wants to actually exchange this token onto a marketplace, they can transfer this token to the main net for the first time and then exchange it on an exchange. Why else should you use scale? Well, we've integrated file storage.
00:12:57.930 - 00:13:46.940, Speaker A: There's a few other file storage services out there like IPFS, but for any DAP that's looking to scale or provide a lot of extra features, a lot of people need file storage. So we also built file storage into scale. So instead of having to use IPFS, you have a one stop solution, an MPM library where you can use decentralized file storage with your scale endpoint, and you can use this as a standalone application for decentralized file storage, or you can integrate this with your app. And then I touched on this before. Why else should you scale? Security model. We have randomness rotation and incentives that provide within team fault tolerance and the ability. We've implemented as many features as possible to prevent collusion over time.
00:13:46.940 - 00:14:27.414, Speaker A: And just a reminder, we have six bounties at East Boston. So build something up and awesome. We want to see it awesome. UX high throughput or generative high throughput microtransactions or high computation. Again, like many people at Hackathons, you're probably not going to deploy a DAP that's going to require 20,000 transactions per second within the confines of the weekends. But there's many other things you can do or simulate those high transactions in place, or use computation, or use file storage, or use the Fast finality for UX. So what is it like working with scale? Let's try this out.
00:14:27.414 - 00:15:14.598, Speaker A: Let me switch my screen. So here is where you can register for Eastboston. Maybe some of you have already requested your scale change. So let's just see what this looks like. So I'm going to enter in my name, my email project name. So here we go. I'm given these endpoints that I can use to deploy my endpoint.
00:15:14.598 - 00:16:03.650, Speaker A: So I can use http, https WebSockets and whatnot. And I have full access to documentation, a scale faucet to get tokens, and a Block Explorer. So let's start off, let's pull this together and let's go over to this app that I'm working on. So here's the file storage application that I'm working with right now. So I've already used sort of the NPM library and the documentation that's available to understand how to upload files, download files, so on and so forth. So let's see how we can do this. I have all the files here as a component or all the functions as a component.
00:16:03.650 - 00:16:53.936, Speaker A: I've read the documentation, so I know that I need to create an environment file, add some account, private key information, and an endpoint to start deploying. So let me add my scale chain and let's try this out. Please don't spill my fake ease. All right, so here we go. I have my basic react app with some sort of file storage functionality. I want to build a way that I can upload files onto my scale chain. Again, I've already requested a scale chain that's provisioned to me.
00:16:53.936 - 00:17:29.020, Speaker A: This has been selected out of the network, providing this sort of decentralized asynchronous file storage layer. And I'm using file storage, which allows me to upload files and then basically separate or chunk up this file into small pieces. And to run this file or upload these chunks directly and write that into the EVM, into the blocks, onto the scale chain itself. So let's get started here. Let's choose a file. Let's say I want to do some images, so maybe I'm image. I love cat pictures and different animal pictures.
00:17:29.020 - 00:18:53.758, Speaker A: So let's start uploading let me try this again. Let me just use a folder endpoint in case I'm try this one more time. Try make sure to die. There we go. We uploaded a file. I bet the massive do this, maybe a wolf, so on and so forth. So I can upload smaller files, and obviously I can upload larger files, not terabytes, but possibly up to hundreds of megabytes.
00:18:53.758 - 00:19:50.690, Speaker A: So you can do MP3, s movies. Whatnot does anyone see? Maybe some issues that could come out of this by uploading files onto a scale chain. So one of the things maybe you've heard of this before is something called blockchain poisoning. So blockchain poisoning is where people can upload abusive or violent information onto a blockchain. Because of the immutable nature of a blockchain, the network participants could be liable, especially under different regimes like GDPR and whatnot. So how can we use a file storage layer where we can actually protect the image contents that are uploaded? Maybe there's a way that we can filter these contents. Maybe there's a way that we could have an autonomous contract that sits as a sort of a sentry that figures out what files are match a certain image that it actually rejects.
00:19:50.690 - 00:20:34.682, Speaker A: So this is something that we've developed for a while but haven't been able to release to find a window to release it in. But we're releasing it this weekend, and it's called scale. Now, it's a way of combining different terrace TensorFlow models with smart contracts. So, again, with TensorFlow models usually require a very heavy h five file, which is the train model. And this huge file needs to be stored onto the blockchain. And we use a service layer function that we deploy onto our endpoints, which actually functions as a predict function. So we're actually forward propagating over a trained model and getting a result that requires a lot of gas.
00:20:34.682 - 00:21:26.270, Speaker A: And this is something that you can do very easily on scale and without walking you through, because we only have ten minutes left of the entire process of coding something from scratch. I'm just going to take you for the high level steps of how you can do this with scaling on. Let me jump back to presentation. So the first thing I want to do is I want to select a TensorFlow model. And so I'm aware of a model called ResNet, which is an image recognition file, ResNet 50. The first thing I do is I go into TensorFlow, I identify a model that I wish to use, I load the model, and I save it as an h five file. And I can upload this using file storage onto a scale chain and provide that for access onto my endpoint.
00:21:26.270 - 00:22:18.570, Speaker A: The next thing I need to do is I need to write a preprocessing script. So I need to take files that I'm uploading, translate that into a matrix, and then be able to basically process that file numerically. So there's a lot of sort of boilerplate preprocessing scripts, and you'll have to define one that works for your model, for your input data. But this is an example of a very simplified one where I'm pulling in the Keras preprocessing image scripts, preprocessing the input, pulling in NumPy, and basically making an array to preprocess this input into a matrix. And as I said before, I'm uploading this large h five file using file storage onto a scale endpoint. And I'm also writing this preprocessing script and also uploading this as well using file storage. Then what I need to do is I need to create a conditional.
00:22:18.570 - 00:23:19.140, Speaker A: I need to write sort of a validate Solidity contract. And I can show you a little bit of what that is. So this is one example of where it's a validate function that's basically pulling in files and then running this Sml or Scalml service layer that we find it on the contract that pre deploys every scale endpoint that requests file storage features. And with scale ML, I'm running the predict function over that h five file, any input. Then I'm using this feature called Double double. So those of you who are familiar with machine learning scripts or machine learning data using floating points, floating points are not compatible with solidity, but this function gets around it in sort of a unique creative way where I can split that floating point and just use full integers. Then I'm writing a conditional so ResNet you can connect with a weighting model.
00:23:19.140 - 00:23:52.940, Speaker A: One of them, for example, is called ImageNet. So here's an example of the ImageNet classification. So I'm using ImageNet 1000. So here are the indices for different trained inputs. And these are sort of all animals or creatures. So maybe I want to make sure that whatever file service layer I'm using, people don't upload any images of cats. I hate cats.
00:23:52.940 - 00:24:25.650, Speaker A: I want to make sure I'm going to censor all cats, make sure they're not on there. So I'm going to go through here and select an index. So here we go. 281, 287. These are roughly some caps. And maybe I extend this whatever I need. So I wrote this conditional that's going to return false or true, whether the image index classification falls within this index.
00:24:25.650 - 00:24:56.586, Speaker A: So let me show you an example of this in action on an already deployed script. So, again, here's another file storage endpoint where I have this. This is the endpoint that I'm using for scale this deployed app. I've already uploaded some images. As you can see here, I've uploaded an MP4 file, 17 megabytes. Let's go ahead and upload. And again, this is being uploaded.
00:24:56.586 - 00:25:43.500, Speaker A: It's hitting the validator contract. It's using the predict function to take that image, converting it through the preprocessing script, running it through the conditional and determining whether it can be uploaded so that works. Choose another one, say the American black bear. There we go. File is valid, it's uploaded. Now let's choose a cat and see uploading your file. Cat images are not allowed.
00:25:43.500 - 00:26:29.100, Speaker A: Nice. Cool. So this is one very simplified application for solving blockchain poisoning. But we think there's a ton of different TensorFlow models so you can get really good grades. Another thing that we're working on actually, as a side project in East Berlin was actually taking a generative adversarial model and combining this with Scalaml. So now this is a whole new palette that you can use as DAP developers. You can look through the Keras TensorFlow library, choose a model, choose a weighting factor, and then write a simple validation script to combine machine learning models with smart contract.
00:26:29.100 - 00:27:20.010, Speaker A: So what can you do with this? What are some other examples? Well, these are just a few that we thought of perhaps fraud detection. Maybe you have some multi city wallet that's combined with Scalaml that's using some sort of fraud detection layer that's looking for transactions or different wallet addresses that are coming into your contract. And maybe you've traded in such a way that if there's a repeated transaction or a different sequence of events, you can actually reject that transaction from coming into the multistake wallet. We've shown image detection. You can use ResNet. You can use auto encoder files. Maybe you want to make sure that someone needs to actually upload a written signature as an image form, as a way to sign off on transactions.
00:27:20.010 - 00:28:02.660, Speaker A: You can use price prediction contracts and again, prevent blockchain poisoning or other issues in a decentralized or quantum fashion. So, thanks for joining. If you want to learn more, we have developers@skillapps.com that goes through a lot of our documentation. You can go to our GitHub at Skill network to look at our open source consensus mechanism, our BLS special signature library, our scaled client. You can join our Discord at scale chat, and you can reach out to me on Twitter if you have any other questions, but we're out of time right now. But happy to talk to anyone outside this room afterwards to follow up with any questions.
00:28:02.660 - 00:28:03.920, Speaker A: Thank you.
