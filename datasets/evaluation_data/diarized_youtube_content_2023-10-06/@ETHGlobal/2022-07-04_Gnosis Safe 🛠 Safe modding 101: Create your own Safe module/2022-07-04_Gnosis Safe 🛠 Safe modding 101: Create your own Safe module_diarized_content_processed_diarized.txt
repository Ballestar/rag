00:00:00.410 - 00:01:01.930, Speaker A: Thank you. Would like to introduce you or to talk about Safe Modules and a little bit of safeguards, how to create your own Safe module. So, first of all, I would like to ask a few quick questions. Please raise your hand us who knows what Nosisafe is? Okay? Quite a lot of people who is using the Nosisafe currently individually or in a team who has built anything related with Nosisafe development. Okay? And finally, who knows what safeguards and Safe Modules are? Just a few then that's good. We will talk about that today. So, the key points of this talk are going to be the Safe Modules architecture.
00:01:01.930 - 00:01:48.320, Speaker A: What are the different components that form the Safe Architecture? What they are. The Safe Modules applications. Like why are they useful? Safe Modules management, how to use them, we can enable, disabling them, execute transactions using Modules and finally some repositories where you can find some examples of Safe Modules. So where to find them? You have probably noticed that we have the what, the why, the how, the where and we are missing who and when. Well, that's obvious I guess. Who is you and when is this hackathon? So let's start. Thank you.
00:01:48.320 - 00:02:23.334, Speaker A: Safe modules. Architecture. If we talk about external loan accounts, we see that, we see that the architecture is simple. We have a private key and a public key. And the private key needs to sign every transaction in order to execute it. However, with Safe, because we are a smart contract and a multi signature wallet, we need to define a list of signers. And with their private keys they need to sign every transaction.
00:02:23.334 - 00:03:15.510, Speaker A: We can define how many of them are required to sign each transaction and after that they become executable. That happens on chain. We also have some services that allow us to collect the signatures off chain. And once we have the transaction and the signatures, we can just call the contract once to afford some gas and make the user experience easier. So this is the regular flow of a transaction execution where signers need to sign each transaction. But there are also another flow and this is using Safe Modules. Safe Modules are used by third parties that are external accounts that they can call a Safe Module.
00:03:15.510 - 00:04:30.622, Speaker A: And a Safe Module is a smart contract that is deployed in the Safe network than the Nosisafe and it has fruit access to execute transactions in the Safe. They are very powerful, but also we need to take care because it's critical. They have root access, meaning that they can execute transactions without the confirmation or the approvals of the signers. So the developers need to define a different logic in the Safe Modules and the transactions will become executable or not if those checks are passed. So we have the regular flow with the signers and the other with the Modules in case the signers become unavailable or the private keys are lost. The safe modules flow is still available and if we have a safe module for example, that implements a recovery mechanism, we could somehow replace the original signers and add new ones. There are also another type of modules and these are the safe modifiers.
00:04:30.622 - 00:05:46.726, Speaker A: Safe modifiers are usually called by safe modules that are used by third parties. So safe modifiers are placed between safe modules and the safe and they allow to add some filters to the transactions that are triggered from a module. So we are allowed to chain different safe modifiers and when a transaction from a third party is sent to a safe module, the transaction is relayed. In case we have a complex architecture that is not needed, then we should try to simplify everything as possible. But this transaction could go through every safe module and modifier and having some checks there. The Safe wallet allows to have multiple safe modules that offer extra functionality. Also safe modifiers allow to have safe modules plugged into them and of course we can also have multiple safe modifiers so safe modules allow to expand the functionality of the safe and we also have another piece of another element that are safeguards.
00:05:46.726 - 00:07:26.170, Speaker A: Safeguards can be enabled to a safe and they can execute some checks before a transaction is executed and after a transaction is executed. So there every transaction that is triggered even if it's from a safe module or from the signers will pass those checks. If any of these checks after or before reverts, then the transaction will be reverted also very critical element. So let's see some applications that modules and guards can offer. We have the multisignature control, the common flow and we also can add some functionality to implement roles, recovery mechanism, add protection layers and some things modifiers allow us regarding roles. We can create for example a safe module that gives or grants admin rights to some specific accounts. So you could imagine having a safe module where some roles are defined and this role could refer to what are the kind of transactions that can be executed, like what are the target contracts that can be called, which specific functions could be called, which range of parameters of the values could be used and give some accounts those roles.
00:07:26.170 - 00:08:53.080, Speaker A: We could also implement a token voting where a safe module is related with an ERC 20 token and do something similar like Dows do where the holders of this token have voting power in order to execute transactions. We could also have a safe module that handles spending limits. So we could allow some accounts to withdraw a specific amount of funds for a specific token without the need of creating of all the signers approving each of these withdrawals. Regarding recovery, for example, we could implement a social recovery mechanism where we define some accounts that belong to our friends or family and at some point they together could execute a transaction via that module and replace the original signers of the safe. If the private keys were lost. We could also, for example, these are just examples, you see, we could implement secret questions. If you remember long time ago in web two pages, if you forgot your password, they would allow you to answer a question like what was the name of your first teacher, what was the name of your first dog, whatever.
00:08:53.080 - 00:10:13.060, Speaker A: Here you could implement something like that where you could submit an answer and if it is the correct one, then replace the owners or allow a custodial recovery party to execute that kind of transactions. Regarding the safeguards. For example, because all the transactions pass through the checks that the guards have, we could implement an allow or deny list where we allow some well, it would be like a filter for all the transactions checking what the target contract is. And allow or not to execute a transaction. We could freeze an account if, before executing it, there's a parameter that the signers can turn on and off, et cetera. Also, with modifiers that have multiple Safe modules plugged into it, we could add a modifier that implements, for example, a queue and all the transactions that are coming from these modules would stay in that queue for one day. For example.
00:10:13.060 - 00:11:36.170, Speaker A: There are unlimited possibilities that you could explore. So how we can manage these modules and use them? The different operations that can be done are enabling a Safe module, disable it, check if a module is enabled or not into a specific safe, getting all the enabled modules in a Safe and finally execute a transaction. For the setup, we would need to deploy a Safe or use an existing one, deploy a Safe module or use an existing one, if that module is built in a way that allows multiple Safe to use it and finally execute a transaction via that module. So, let's see from the Nosisafe smart contract side and from the module side, some code. So, here we see two contracts. The first one is a super simplified Nosisafe contract, that is a Module Manager. Module Manager is one of the core contracts of the safe that has all the functionality that allows to enable modules, disable them, et cetera.
00:11:36.170 - 00:12:40.782, Speaker A: So, when we set up a new safe, inside the function setup, there is a call to the setup modules function inside the Module manager. And if we see below the Module manager, we have two variables. One is a mapping called Modules, where the keys and values are addresses, and we use a sentinel module, that is the address zero x one that we use in the beginning and at the end of this mapping to see well, to navigate it. So I'm not going to talk very deep about this. We can enable a module, it cannot be null or the sentinel, the address, we are using it for the module and also modules cannot be added twice. We can disable a module and making sure that the module was already enabled before. We also can see if a module is enabled or not.
00:12:40.782 - 00:13:53.580, Speaker A: By checking this modules mapping we can get the enabled modules list that is paginated and we can iterate on it. And finally, and the most interesting thing is that we can execute a transaction. So in the save contract there are two methods execute transaction that uses the regular flow, checking the signatures of the signers and then we have the method exec transaction from module. This is a public method that can be called by any account. However, inside of it there is a check where the message sender needs to be inside of the modules mapping, meaning that the message sender the account that is calling this method is a module that is enabled, that was inside of the Nosisafe contracts. And now if you decide to build a custom module, you could create a contract. In this case we call it Custom Module.
00:13:53.580 - 00:14:43.500, Speaker A: That is a module. Module is an interface that defines well, it's an abstract class that defines the methods that are required and that can be implemented here. So for this case, we have the custom method function that receives some parameters of a transaction, like the true value data and operation. And inside of it we are calling a target. This target is an address that was set before and if this is a module, the target can be a modifier or an aussie save. And there we can call the function exec transaction from module and pass all these parameters. So this way we are relaying the transaction from the module to the safe.
00:14:43.500 - 00:15:46.016, Speaker A: Now, let's see a little bit how to use the safeguards equally to the safe modules. We can have a safe, deploy a safeguard, enable a guard into the safe or disable it. The difference is that Safes only allow to have one safeguard instead of well, we can have multiple modules, but just one safeguard. Safeguards are enabled in the safe by the signers. And then in the safe contract there is the function exec transaction, and inside of it I just simplify the code here, but the signatures are checked. And then we get the safeguard. We see.
00:15:46.016 - 00:17:15.070, Speaker A: Or we check if that guard is different than the address zero, meaning that we indeed are using a guard. If that is correct and we are using it, then we will call the method check transaction. Then the transaction will happen and after it there will be another call to the guard calling the method check after execution. If one of these methods reverts, everything will revert and a custom guard could be implemented with two functions check transaction that receives all the parameters from anosisafe transaction and also the function check after execution that receives the transaction hash and if the transaction was successful or not. So some module repositories and examples you can read, we have the Safe contracts repo in the Safeglobal user on GitHub. There you can find the core contracts, the module manager and the guard manager that implements the functions to manage these elements. Then we have the Save Modules repository where there are some examples of modules that are used.
00:17:15.070 - 00:18:11.810, Speaker A: And also a very interesting one is the Zodiac repository under the nosis user. Zodiac is a Dao tooling standard that implements multiple safe modules for DAOs that are built on top of the Safe. And you probably will find that interesting. Here I will provide the slides in the discord of It global so you could check these links there. So we have the modules that implement or that indicate what are the functions that are required to implement if you build a module. And well, here we have some examples of modules and modifiers. Sorry, I'm running out of time.
00:18:11.810 - 00:19:09.356, Speaker A: Same for the guards. We have a base guard and also an example of a guard that debugs a transaction, checking the data before and after the transaction is executed. And now the question is will you build the next big safe module or guard? Well, we hope so. You can find us on Twitter Nosisafe. We also have a Discord and forum on Chat or forum nosis Safe IO and we also have a channel Nosisafe in Discord. Also feel free to come to our booth and claim your Nosisafe east New York POAP. And for the hackathon we have $10,000 up for graphs and two bounties.
00:19:09.356 - 00:20:03.040, Speaker A: The first one is a wild card like any integration with the nosisafe on different layers on the front end infra or contract layer in the front end you could create a new front end use our SDKs like the SafeCore SDK. If you are building an app that runs standalone and separated from our app or the Safe Apps SDK. If you want to build a Safe app that runs inside our Safe Apps store in the infra. If you want to play around signatures that are sorry. Like collecting all the signatures off chain before a transaction is executed. Or in the contract ledger. If you want to play around with modules and guards.
00:20:03.040 - 00:20:37.340, Speaker A: That is the first bounty. And the second one would be specifically related to the Roles module from Zodiac. The best use case for it. So, thank you very much. We are going to stay here all the weekend at our booth. Feel free to pop up and well, we can help you with your questions and good luck with the hackathon.
