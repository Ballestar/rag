00:00:00.570 - 00:00:23.146, Speaker A: Hey everyone, welcome to my doc. So my name is Madhir Gupta and I'm a wannabe hacker from India. And let's get started. So I have some solidity tips and tricks to share with you all. So let's start with variables. So let's talk about variable locations. Variables can be stored in stack memory and storage.
00:00:23.146 - 00:00:54.074, Speaker A: But then there's basically call data and global variables that are kind of special. So global variables for example, message sender is one of the global variables. Then call data variables are basically the function parameters of external function. So they are directly stored in call data. Let's talk about the difference between those. So the main difference is the cost of accessing and editing them. You can't edit call data function call data variables because call data is generated when the call is created.
00:00:54.074 - 00:01:32.806, Speaker A: But you can modify the stack memory and storage variables. Stack is the cheapest of all and that's why if you have the option, always use the stack variables. Memory and call data have comparable cost for reading then storage is like way more expensive than any other thing. So avoid using storage if you can. Then there are also constants in solidity and they are directly encoded into the bytecode. So neither they are stored in the stack nor in the basically memory or anything, they're directly hard coded into the bytecode. And as I said, always try to use stack.
00:01:32.806 - 00:02:18.614, Speaker A: And for example, let's say you can use stack as cache to basically keep your costs low. So for example, you have an array in storage and you want to pass all the elements. So you create a loop for I equal to zero, I is less than length of the array and I plus plus. But if you do that, then you will be reading the length of the array for like n number of times for every element you will be reading the length of the array. You can optimize that by storing the length of the array in a stack variable and then using that to compare the length. So basically rather than making N calls to the storage variable, you are now making N calls to the stack variable which saves a lot of gas. Now let's talk about the variable visibility.
00:02:18.614 - 00:02:48.958, Speaker A: So we have internal, private and public. Internal variables are like generally the most useful ones if you don't need getter information. And internal variables can be inherited by different contracts, directly edited by different contracts. So let's say I created a token and then somebody creates a new token on top of that and inherits my contracts so they'll be directly able to edit the variable. So let's take an example of Open Zeppelin. So open zeppelin. Have ERC 20 tokens.
00:02:48.958 - 00:03:50.082, Speaker A: So in the Open Zeppelin's contract, if the balances were declared internal, like there were a few versions before that earlier basically. So if those were defined internal, then I could create a new contract, let's say moderate token, inherit the, ERC, 20 token by open zeppelin, edit the name of the token, edit the decimals if I want to, so that's my own token. And then I can directly edit the balances of users, directly implement my transfer functions and do stuff like that. But if Openjeplin were to declare them private like they have done now so even if with private variables the contract that inherited them cannot edit them. So as it stands, Openjepplane has private balances. So even if I create moderate token, extend the Openjeppelin token with that and if I try to edit the balances directly it will revert so it won't allow me basically I can't do that. So if I have to edit private variables, I need to use functions defined in the original contract.
00:03:50.082 - 00:04:51.462, Speaker A: So Openjepplane has that's why defined internal transfer functions, internal transfer from functions, internal Mint functions so basically I'll never have to directly modify the balance functions, I'll always use the functions basically internal functions that will in turn modify the private functions. So this is kind of abstraction concept and if you are familiar with object oriented programming you will understand why this is a good approach. So let's talk about public functions. They are different from internal functions in the sense that for the public functions the Solidity compiler will automatically create a getter function for you. So what's a getter function? Getter function is used to basically read the value of that variable outside the smart contracts. So if you have a DApp and you want to read the value of your variable basically so you have two ways. Either you can query the ethereum blockchain directly using Get Storage RPC calls and that is a bit cumbersome because you need to know a lot of things.
00:04:51.462 - 00:05:59.514, Speaker A: For example, which storage slot your variable is, what type of it is and stuff like that. But if you have a getter function defined in the contract then you can just directly call that function. For example, if my variable name is modith so the getter function defined by the Solidity solicy compiler will be also named modith so I can just call myContract modith and I'll get that variable, the value of that variable directly accessible to me. So that makes stuff easier for the DApp developers, for debugging and for stuff like that. But the downside of that is defining a geta function takes some space on ethereum space matters because you pay for the space. If you deploy a contract, you basically have to pay for all the storage space and the storage space is actually limited to 24 KB. So if you are making a complex application basically you might run into storage space issues and at that time you might have to define your public variables as internal and use the ethereum blockchain getrpc storage rather than the getter functions.
00:05:59.514 - 00:06:31.014, Speaker A: And another thing to note is that even for private variables and internal variables they are not really private. You can always access their values through the web. Three ETS get storage at function. So don't ever think that if you are defined a function variable, nobody can see that it's never secret on the ethereum blockchain. Everyone can always access all the data, it's just a bit harder to do it then function access types. So function access types matters as well. Just like the variable types in functions.
00:06:31.014 - 00:07:07.498, Speaker A: Also we have internals, public and private. So let's talk about internal functions. Internal functions are functions which can basically be called by the contract itself. And like the other contracts that inherit it, basically like any outsider person cannot call that contract, cannot call that function. So if I deployed a contract with an internal function, no outside party, like any ethereum user or any other third party contract can call that internal function. It must always be called by a function which exists in that contract itself. Then we have public functions.
00:07:07.498 - 00:07:47.890, Speaker A: So public functions can be called by the smart contract itself as well as outside entities. So anyone can basically call the public functions. There are no restriction on public functions. External functions bring in a kind of a weird restriction that you can't call the same contract cannot call the external function itself, it must be called from an outside source. So like if I have an external function defined in my contract, I can't have another function called that external function. I'll have to create basically that external function is meant to be called by the outside world only, not the contract itself. But this can be bypassed basically.
00:07:47.890 - 00:08:19.958, Speaker A: So even with my own contract I can create an external call which will call that external functions. This will cost a bit more gas, but this is like something which can be done. So even if you have external function defined, this can be useful. Like when auditing something or basically stuff like that, you imagine that it's an external function. So this contract cannot call it, but it can happen that it can be called. You can use this, which is like a pointer provided by Salsi that points to your current contract. And then you can call the function name basically.
00:08:19.958 - 00:08:54.854, Speaker A: And it will create an external call that will call that function. And another difference about these functions is basically how they store their parameters. In public functions all the parameters you pass are copied to the memory. So copying takes a bit of gas, but not much. Then we have external functions. In external functions the parameters are not copied to the memory by default. In external functions we know that the parameters exist basically in call data because we know an external call was made.
00:08:54.854 - 00:09:25.326, Speaker A: An external call always has call data. So we don't need to copy those parameters to the memory. We can always use the call data as call data is available throughout the call. Basically. It won't ever be deleted or anything. It can't be modified, then internal functions are the cheapest of the lot because in internal functions it doesn't use call data, it doesn't copy variables through the memory, it uses references to the variables. Now, as we know, internal functions cannot be called by the outside world.
00:09:25.326 - 00:10:08.240, Speaker A: So like we don't need to provide them any data, we only need to provide them references. If a public function calls an internal function, then public function has its variable in memory already. So it can just give the address of that memory to the internal function and it will directly use those variables. It won't have to copy them again. If an external function calls an internal function, then basically the external function will have to copy those variables into memory for the internal function and then pass the reference to it. So then it becomes like the gas usage, gas savings goes away, but it's still better. So yeah, that's about the gas usage and let's move forward.
00:10:08.240 - 00:10:39.318, Speaker A: If anyone has any questions, feel free to ask. Let's talk about packing of variables. So packing is one of the things that saves you the most gas in ethereum because as I said, using storage slots in ethereum is the most expensive thing. One slot costs 20,000 gas. For comparison, in memory it costs only about 200. So there's a big jump, 100 times jump. That's why optimizing the storage is very important.
00:10:39.318 - 00:11:11.726, Speaker A: And packing of variables come into play when we are optimizing the storage. On the EVM side, the storage is divided into slots of 32 bytes. So if you have to store even like one bit of data, either zero or one, you'll have to buy a slot of 32 bytes. At the minimum, you can't buy it any less than that and you can stack 32 bytes. You can buy 64, 128 and stuff like that. So what we can do so let's say you need to store five different types of data. Each data uses one bytes.
00:11:11.726 - 00:11:50.430, Speaker A: So by default, the normal use case, what people normally will do is buy five slots and store the data in every one of them. But that is very unoptimized because storage again is very expensive. So you can pack those five variables together and store them in a single storage slot. So this is done default by default by sol C for most of the variables, variable types. So if you define UN eight, that's eight bits. 32 bytes is 256 bits. So eight by 256 you can combine 32 UN eight into a single variable.
00:11:50.430 - 00:12:37.710, Speaker A: This will happen automatically if you have defined them in a continuous manner. So if you say UN eight A, UN eight B, UN eight C, they'll all be combined together. But if you write your code like UN eight A, UN 256 b, UN eight C. So basically A and B cannot be combined because B takes all the space. So in this case, the solidity code will take three slots, one for a, one for B, one for C, but if you define that UN eight A, UN eight C, UN 256 B now A and C can be combined together. So it will now take only two slots and you have directly saved 20,000 gas. That's how you basically pack variables.
00:12:37.710 - 00:13:27.086, Speaker A: Then one thing to note is that variables in storage can be packed together, but variables in memory cannot be packed together. This doesn't really matter much because memory is cheap, as I said. But basically this means that if you have something in memory, for example, you are taking parameters in the function, then you must understand that those parameters will be unpacked variables, they won't be packed. This can have implications if you are using low level languages and then you pick up the data and say like I only want to pick up eight bits of data. But you need to understand, even if your data type is eight bits, you'll have to pick up all 256 of bits. You can't just assume that it's packed. So that's a bit advanced topic, but yeah, it's something to remember.
00:13:27.086 - 00:14:04.298, Speaker A: And this also means that you don't need to optimize memory for packing, basically, because you can't. And one thing to note, a few developers I've met don't understand that different data types can be packed together as well. It's easy to imagine that UN eight can be packed with UN eight. But you must also grasp the fact that address and UN 64 can be packed together. And because address is 64, address is 20 bytes, basically. And UN 64 is eight bytes. Eight plus 2028, it's under 32.
00:14:04.298 - 00:14:40.126, Speaker A: So it can be packed. Any combination which is under 32 bytes can be packed together. Now, booleans are one thing that are not really optimized. In salchi, a boolean only really needs one bit, because zero or one. But how salty is coded? Booleans are actually UN eight under the hood, so they actually use eight bits. Now, in normal use case that's fine, because even then you can pack 32 booleans together in one slot. But let's imagine you are creating a super optimized applications and you need multiple booleans for multiple flags.
00:14:40.126 - 00:15:14.858, Speaker A: In that case, you can define your own boolean, which will be one bit. You can pack and pack it on your own. I have code sample on my blog for that, basically. And if you define your own boolean with one bit, you can store 256 booleans in one slot. 256 bit, 256 booleans, you used to need that, but now solidity. Basically, EVM inherently has bitshift operations, so you don't need assembly anymore. Now, EVM works with 256 bits.
00:15:14.858 - 00:16:10.750, Speaker A: As I said, storage already works with 32 bytes, that is 256 bits. But even the manipulation of data works with 256 bits. So let's say if you have packed your variables together and you have multiple UN eight, and then you need to add a UN eight to UN eight. So what solidity will do under the background is convert those UN eight to UN 256 1st both of them and then add them together and get a UN 256 as an answer. So what this means is that if you are not packing your variables together, it's better to just use the 256 bit data type, full data type because you will just end up converting that internally to UN 256 anyways. So it's cheaper to basically use full data types if you are not able to pack your data types together. This is not much of a big difference because it's very cheap to convert basically variables into types.
00:16:10.750 - 00:17:00.578, Speaker A: So if you have any chance to pack your variables, I recommend that you use smaller data types. But let's say there's no chance that you can pack your variables if you have only a single variable, then it's better to use UN 256 even if you only need eight bits of data. Okay, there's that then. Try Catch is one thing I created a while back. So testing on Solidity is a nightmare, debugging testing and stuff like that. In most of the other languages you have try Catch. So what you can do, you can write code in a try block and basically you can say if this code fails, then run the Catch block, don't revert the transaction, don't exit the whole program, don't crash my windows, just run the Catch stuff and I'll be good to go.
00:17:00.578 - 00:17:44.618, Speaker A: But in Solidity you can't really do that by default, if any part of your transaction reverts, even if a subcall to a different contract reverts, your whole transaction will be reverted and there's nowhere back by default. But we can create our own try Catch Wrapper. So this is a fun thing. Basically when a function reverts, typically whole of the transaction is rolled back, as I said. But in certain cases we might not want to revert the transaction. For example, if we are doing batch functions, I'm transferring tokens to 100 users, but let's say one of those users has a bad address or something and I cannot transfer tokens to that user. So I would ideally want that I just skip transfer to that user and transfer to rest of the users.
00:17:44.618 - 00:18:26.190, Speaker A: But by default, if one of them fails, all of them will fail. So we need to create a Try catch wrapper basically around that. And we can do that by using low level calls. So that's not really assembly, but Solidity offers low level calls. For example call, delegate call and stuff like that. So we can use just call directly. Funny thing about using calls and delegate calls is basically if those transaction fails, like if that reverts, if that transaction reverts, the whole transaction won't be reverted, the low level call will just return a false statement, false result to you and then you can compare the result.
00:18:26.190 - 00:19:30.420, Speaker A: Like you can say if the result was false means the transaction was reverted. So you can do stuff like you can maybe mark that address as malicious or something like that, and if the transaction is successful, it will return true. So you can check if it's true, then everything went fine and you don't need to really do anything. Or you can clean up the code and continue your journey. So this is one fun thing, but this can be like a bit hard to use and there's no really easy way to implement this, but if you need to do it, this can be done and it's fun. Yes, well, all the state updates under that low level call will be rolled back, but nothing outside that low level callback. So everything done after creating that low level callback, call will be reverted, but everything done before or like after the low level call is returned, it will be as it is.
00:19:30.420 - 00:20:14.554, Speaker A: Okay, now I have some miscellaneous tips. So, mappings and arrays are basically two of the complex data types in solidity. So arrays, like in every other language, basically continuous data and same type of data mappings are a bit more useful or funnier in solidity. So with mapping you can say it's basically key value storage pairs. So every key has a respective value. One funny thing about solidity is that mappings are actually cheaper than arrays in implementation. Usually in most of the languages, arrays are cheaper because data is continuous.
00:20:14.554 - 00:20:44.550, Speaker A: You don't have to seek or seek read or basically stuff like that. But how the cost is calculated in solidity it's that data is always stored in a key value pair. It doesn't understand continuous data, it's always in key value pairs, key value pairs. So basically, even with arrays, your key keeps increasing by one. But it may not be continuous in the actual physical memory. That's why arrays are more expensive. So if you have a choice, you don't need to enumerate the mappings.
00:20:44.550 - 00:21:30.458, Speaker A: Basically, then always use mappings. Arrays are for only when you need whole of the keys or basically enumerate the array. Then we have using fixed type data types like bytes 32 is way more cheaper than using dynamic types like bytes. This is because when you use a dynamic type, for example string or bytes or an array, you need to use one slot to basically store the size of that variable. So if you even have like one bit bytes so if you have a bytes variable and you are only storing one character in that, even, then you will need two slots. One is to store the length of the data and one is to store the actual data. But instead you can just use bytes 32 or even smaller bytes, like bytes two one basically to just store the data.
00:21:30.458 - 00:22:29.206, Speaker A: And as these are fixed length, you don't need to store the length, you directly save half of the cost. One more good thing to do is basically use short circuiting rules to your advantage. So from this I mean that we always use hand and or stuff like that in our require statements or if statements or basically other stuff. So what we can do so you can always predict which of them will be true more often or false more often. So let's say I have a statement which says A must be true and B must be true and I know that possibility of A being false is 99% like most of the times A is false and I know that most of the times B is true. So how should I optimize this? I can either do if A and B or I can do if B and and A. Let's consider both these scenarios.
00:22:29.206 - 00:23:09.162, Speaker A: If I do A and and B then first of all I'll check if A is correct or not. In this 99% cases A will be false. So this will just skip rest of the stuff and you won't be spending any gas in comparing B. But if I do if B and and A in that case B is true for 99% of times. So you will see B is true. Okay you'll move to the next comparison, you will see A, you will see that A is mostly wrong, mostly false because you previously knew A is usually false. So you will be reverting now rather than basically reverting before.
00:23:09.162 - 00:24:19.870, Speaker A: So this means you have literally wasted some gas in comparing B because A was just going to revert anyway. So in stuff like this it really depends on how well you can guess or imagine what these answers or what the use case of your app will be and you can optimize accordingly. Then function modifiers function modifiers are super cool and super useful in solidity. So what function modifiers do is if you define a function modifier then there's a special variable underscore basically which will take the function score and put that replace that with the underscore. So let's say I've defined a function modifier only owner and I've marked my function like sample function as it can be called by only owner. So you'd imagine that the modifiers code is picked up and put on top of the basically sum function but that's not the case. How it actually works is the code of the function basically sum function is picked up and put inside the function modifier where the underscore is.
00:24:19.870 - 00:25:14.110, Speaker A: So you can even do check on top of the code, you can do checks on the bottom of the code even after underscore. You can write additional required statements and you can do checks on that. But this can be problematic because you are copying the code again and again to that stuff and creating separate copies of the code. So let's say if your function modifier has ten lines of codes, you are doing some complex checks and you are using that function modifier on five functions basically. So if by default what will happen that five different copies of that function modifier code will have to be created because every copy will go with copy of a separate function. So every separate function will have a copy of function modifiers code that will obviously use a lot of gas. You are duplicating the code, the whole ten lines of the function modifier are being duplicated again and again.
00:25:14.110 - 00:26:01.038, Speaker A: So to avoid this situation, rather than creating a function modifier, you can create an internal function and you can do all the checks in that internal function and just revert if the checks fail. This is not as powerful as function modifier, but this is cheaper. In most of the cases it's cheaper. So how functions work in functions you don't copy the whole code to the other location. If you call a function, it will basically jump to the location of that code rather than copying the whole code, it will just jump to the existing code. So there's no redundant code and that's why using function internal functions is cheaper than using function modifiers and this can basically be seen in effect in one of my PRS. The link is available on my blog, I'll share it later.
00:26:01.038 - 00:26:50.622, Speaker A: So basically what happened, I created one of the contracts in which the modifier was being used again and again and again and this is how I actually found about this. And the contract code ended up to be 26 bytes and it was a very simple contract, like not much code to do and that's when I scratched my head, looked into it why the code size is so big man, the code looks small but I'm repeating the function modifiers. So I'm trying to understand what's happening here and that's when I realized that the function modifier code is being replicated at every places. And then I just replaced the modifier with a function code size dropped from 26. In solidity you pay for every byte of data, every bit of data. So yeah, that saved a lot of ether for me. Okay, just ending this now.
00:26:50.622 - 00:27:22.074, Speaker A: This is a simple like a very basic tip. So if you have to swap two variables, a with B, B with A, you can do this directly. You can create a double hello comma world equal to world comma hello. So this will put the value of world into hello and value of hello into the world. You can do like even more than two variables and you can swap values between them. Make proper use of the optimizer. Solid optimizer is pretty good, not at the level of GCC, but yeah, it's pretty good and you should always enable that.
00:27:22.074 - 00:27:43.600, Speaker A: If you can then use native salty rather than salty JS, that's basically salty JS is JavaScript, native salty is C plus plus and you can imagine which is faster. And I guess that's it. Thank you. If anyone has any questions, I'll take them. Thank you.
00:27:47.090 - 00:27:56.246, Speaker B: Last slide, single line swaps because it's just easier to read or it's yeah.
00:27:56.268 - 00:28:11.690, Speaker A: It'S actually more gas efficient because even with the other methods, either you will be creating a third variable that takes more gas or you can do like and or bitwise operators. And bitwise operators are also expensive in solidity. So this is actually gas efficient.
00:28:12.510 - 00:28:26.718, Speaker B: Other question I had was you got two minutes, guys. You found them using a modifier, created all this issue. I was wondering if it's not too long, what was the actual process that you used to figure that out?
00:28:26.804 - 00:28:53.830, Speaker A: Yeah, I basically looked into the bytecode and I saw the same bytecode was being repeated again and again and again. And then the process was finding out what that actually was. So it took a while, but I figured out it was the modifier. Okay, let's wind up anyone wants some polymath hat? I've got plenty of them. Yeah, you can just grab them from here. I've got plenty. Let's wind this up.
00:28:53.830 - 00:28:57.380, Speaker A: Thank you, everyone. Thank you. Thank you.
