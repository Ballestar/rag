00:00:06.090 - 00:00:15.450, Speaker A: I want to kick us off with our first summit talk of the day and that is Adam talking about having fun with Hard Hat. So without further ado, let's welcome Adam on stage.
00:00:15.610 - 00:00:19.198, Speaker B: Hey Adam. Hey, how's it going?
00:00:19.364 - 00:00:23.086, Speaker A: Going great. I'll let you kick this off and welcome.
00:00:23.268 - 00:01:05.954, Speaker C: Cool, thanks so much. Cool to be there. All right, so I guess let me share my screen. So today we're talking about having fun with Hard Hat. So I guess I preface this by saying that this is not a sort of walkthrough of how to build an app specifically with Hard Hat. There are loads of really great guides out there that will show you just that and show you how to build all manner of apps here. Today I really want to, I guess, dig into Hard Hat, give a bit of an overview of what it is, the toolkit, and then I guess run through some of the cool stuff that you can do with it.
00:01:05.954 - 00:01:37.114, Speaker C: So I guess we're going to go gradually up the meme. So we're going to start obviously talk about some of the basics. Local EVM, compiling contracts, deploying them. We'll talk a little bit about testing and some of the cool plugins that you can leverage if you're using Hard Hat. And then some other stuff around like custom tasks, EVM manipulation, forking chains and contract verification. So, whole bunch of stuff. We're going to obviously try and do stuff live and so we'll see how that goes.
00:01:37.114 - 00:02:06.642, Speaker C: But that's how we're kicking things off, I guess just to really orient level set. Yes, I'm Web Three developer, worked on a bunch of stuff. I'm going to be working with Scaven E. That was how I got into the space and I know loads of folks came that same way doing a bunch of work with Austin. So I've worked on Nifty Inc. Which was built with what was formerly known as Widdler and that then became Hard Hat. So I've been using hard hat for a while.
00:02:06.642 - 00:02:36.078, Speaker C: It's been cool to see the tool set develop and I'm currently a PM working on the graph and so hopefully if there's time, also pull in a work in progress Hard Hat plugin which is making easier to develop subgraphs as well. So, bunch of context there. As I said, we're going to start at the top. So hard hat is first and foremost, there's the hard hat network. So it's basically a local ethereum node that lets you do development and be debugging. So that's super cool. In terms of getting started.
00:02:36.078 - 00:03:15.430, Speaker C: There's really good documentation. I'd encourage folks to jump into that. It's actually been revitalized quite recently also with the organization. So Hardat used to just be pretty agnostic. It had essentially the EVM, a bunch of stuff where you could do with it and then a really diverse set of plugins. But more recently they've introduced the Hard Hat toolbox which is the sort of bundled commonly used set of packages and Hard Hat plugins that they use to get started. So one thing I did in sort of preparing for this is that I updated Scaffold ETH to use the latest version of Hard Hat, and I've also pulled over to start using the toolbox.
00:03:15.430 - 00:03:19.946, Speaker C: So we'll run through all of that today. So if I've got my share, the.
00:03:19.968 - 00:03:26.126, Speaker B: Whole screen, if it'll let me yeah, perfect. Right.
00:03:26.148 - 00:03:32.320, Speaker C: Hopefully you can see the whole screen now, maybe.
00:03:33.570 - 00:03:33.982, Speaker B: Cool.
00:03:34.036 - 00:03:57.878, Speaker C: Perfect. So, yes, as I said, I'm in scaffold ETH. We're going to run through a bunch of things today within Hard Hat just to orient folks. There's. Again, great content online on getting it installed. But the heart of Hardhat in any place is the Hard Hat Config file. So essentially, this is a configuration file where you say, okay, when you're running Hardhat, here are the things I want to pull in, here are the things I want to use.
00:03:57.878 - 00:04:36.418, Speaker C: So one of the first things that you'll almost always do when you're working with Hardhat is you'll run a local chain. So if I'm running this here, I'm running a hard hat chain. And what does that mean? It's basically running a little Ethereum virtual machine on my laptop, which I can deploy contracts to. So maybe we'll start with that. And if I run yarn deploy, we'll see a bunch of stuff happening essentially to orient folks. I'm in this hard hat directory. I've got my Hard Hat hat configuration file, which, as I said, has a bunch of stuff.
00:04:36.418 - 00:05:04.734, Speaker C: We'll talk a little bit about that in a second. Then we've got my smart contract in here in the contracts folder. So this is a super simple this comes with Scaffold ETH, but it's a super simple contract which lets you set purposes. This one doesn't let you do much apart from set a new purpose, and it emits an event whenever that purpose is set. So what I did was I spun up that local chain. So you see this chain running and then I essentially deployed. So actually, if I deploy to that.
00:05:04.772 - 00:05:29.026, Speaker B: Network, local, if I deploy to this network fantastic. Good start. Let's see. Perfect. Seems to have deployed.
00:05:29.058 - 00:05:36.760, Speaker C: So now if I run back and now if I actually run a local app just so we can interrogate and see some stuff that's going on.
00:05:39.690 - 00:05:40.006, Speaker B: We.
00:05:40.028 - 00:05:51.850, Speaker C: Can get a sense. And this is yet, as I said, using the Scappled ETH framework, but we're going to really dig into some of the stuff that you can do with Hard Hat. So essentially, if we look at this contract.
00:05:53.630 - 00:05:54.874, Speaker B: And if we pull it out.
00:05:54.912 - 00:07:04.450, Speaker C: Here, if we go to the Hard Hat Config just to orient people to some stuff that's going on in here. So firstly, Hard Hat has this really cool plugin based model where you can pull in plugins which others have developed or that the Hard Hat team have developed which are relevant and interesting. So one example is the localhost so one example of a plugin which is imported here is the Tenderly plugin that lets you leverage loads of stuff that the Tenderly team can do everything from like interrogating local transactions to verifying your contracts. The hard hat toolbox I kind of talked about earlier? And the Hard Hat deploy plugin is a really great community based plugin from Wiggle Wag, which essentially lets you manage all your deployments. So just to dig into that a little bit more, deployment in Hardhat can be done in a bunch of ways, but this Hard Hat deploy plugin is really great because it gives you lots and lots of control when you're deploying your contract. So to orient you in terms of what happens here, if we go into this deploy folder, which is how Hard at deploy works, it'll essentially run all of these deployments. So this is deploying your contract.
00:07:07.670 - 00:07:07.986, Speaker B: When.
00:07:08.008 - 00:07:34.542, Speaker C: You run Hardhat deploy, it'll essentially run through these and run all of these migrations. So this first deployment of your contract is essentially getting deployed here. It's then getting deployed. And there's a bunch of other stuff here which shows you some of the power of what you can do with Hard Hat. But it's pretty simple to start with. So if we jump back to front end debug contracts, we can see this first one in here.
00:07:34.596 - 00:08:07.320, Speaker B: So that doesn't seem to have worked nicely. Okay, now perfect. This is good. Always good. Live demo stuff. Okay, let's go up here. Five, four, five.
00:08:07.320 - 00:08:32.074, Speaker B: Cool. See if we can fix this. Cool. Actually, maybe we will see if that deployed.
00:08:32.122 - 00:08:33.700, Speaker C: Okay, I know what this is.
00:08:35.510 - 00:08:38.206, Speaker B: Okay. Classic node compatibility.
00:08:38.318 - 00:08:39.410, Speaker C: MMus.
00:08:43.590 - 00:08:48.226, Speaker B: Perfect. Okay, perfect.
00:08:48.408 - 00:09:04.442, Speaker C: We're off. And we're rolling. All is well now. So if we now go back to the local host, we can see this contract. So building unstoppable apps. And now if I call this contract, firstly if I grab some funds from the faucets. So one really great thing about a local chain which you're running is that you can pretty much do whatever you want.
00:09:04.442 - 00:09:32.094, Speaker C: So here I initiated a little transaction to myself, sending myself to me so I can actually start transacting so testing with Hard Hat. If I send that fantastic. You can see I'm making this transaction. I set the purpose, and then you can see that the purpose is now updated. So I'm interacting with a local chain. So then one cool thing that often when you're working with Hard Hat is you'll be debugging your smart contracts. A cool thing which you can do, which you can't do with a normal chain is essentially console logging.
00:09:32.094 - 00:10:06.410, Speaker C: So that classic thing that you want to do essentially when you may be debugging a contract. So Hard have a special console log console sol contract which you can import into your contract so you can start to do some debugging. Maybe not so relevant to this. Like in this super simple case, but it might be that you want to test why a certain logic branch isn't being passed down. And so console logging from within your contract will let you do that. So to keep moving forward, I'll save this, I'll redeploy my contract. So essentially it gets detected, the contracts changed.
00:10:06.410 - 00:10:21.554, Speaker C: So it then needs to compile again. It's compiled, you can see it's deployed again. We go down here and now if we go in here, you can see that we've got a whole new contract. The front end is hot reloaded. But now if I call a different.
00:10:21.592 - 00:10:29.446, Speaker B: One, hopefully log my smiley face, you.
00:10:29.468 - 00:11:15.250, Speaker C: Can see that this got console logged here. So this is a really cool thing that you can do with Hardhat to essentially be maybe debugging contracts, maybe checking that variables have changed as you'd expect during execution. I would say the one thing which I've sometimes done when deploying is to forget to get rid of this import because it's obviously extra code to deploy to the chain. That's one cool thing you can do with Hardhat. So let's just jump back to the things as I said, some cool things, but also potential gotchas when you're using different plugins. So one thing is that if you want to say redeploy your contract, in this case hardhat deploy detects that actually the contract's not changed at all. You might just want to just reuses the same one.
00:11:15.250 - 00:11:37.290, Speaker C: Might be that for whatever reason, you actually do want to reset the deployment. So in this case you can call reset and it'll redeploy the contract and give you a whole fresh new app again. So that is the basics, the bare bones. And this is really cool because you can basically be adding new functionality to your contract. So let's see, this is going to be relevant timestamp.
00:11:37.870 - 00:11:45.360, Speaker B: And if we go public, view returns two, five, six.
00:11:49.650 - 00:11:50.590, Speaker C: We can do this.
00:11:50.660 - 00:11:55.140, Speaker B: And we can do block number as well.
00:11:59.270 - 00:12:29.194, Speaker C: Okay, these two new functions, we can deploy these guys essentially it's a really good place to be. Iterating and developing your contracts. So these will get deployed. We now have these new two fields which show up here and yeah, we'll talk about them again in a second. So then in terms of the next stuff that you can do with Hard hat so we've covered pretty much the local EVM compilation and deployment. Next thing that you can do is testing coverage and gas reporting. So let's run through those.
00:12:29.194 - 00:13:13.020, Speaker C: So if I run yarn test here, essentially I run some tests. So these are some unit tests which are run actually I've jumped ahead here because you can kind of see this at the bottom. So essentially these are just unit tests. So if we jump into my test, you can see essentially the tests that we've just run. So what are we doing here? So essentially this is getting run on again. Instantiated local hard hat node and essentially checks a bunch of things which you expect to happen when you're working the contract. So for example, you can test that your contract is deployed properly, you can test that when you call a given function, it has the effect that you'd expect.
00:13:13.020 - 00:14:09.338, Speaker C: And then you can also check for example that an event is emitted when you call that contract. So that's again the kind of stuff which is moving from sort of hacking iterating working on contracts towards something that looks more like sort of software development, best practices and so again a really rich toolkit. And one thing that Hardap also recently introduced is their own sort of matches which haven't fully dug into, but again is moving away from where they were using a prior Truffle library. But so testing can give you a lot more confidence when you're making changes to your contract that they're not having sort of side effects that you wouldn't expect and to make sure that actually when you've implemented things, that the result is what you would expect. So you can do all that within the Hard hat framework. There's some other cool stuff that you can kind of get when you're running your tests. So this table at the bottom is one of them.
00:14:09.338 - 00:15:10.080, Speaker C: So this is again something that comes in the Hard hat toolbox and if we jump back to the Hard hat config you can kind of see where this is configured which is the Gas Reporter. So obviously there's a large school of thought who are very focused on gas optimizations within smart contracts. And so this is one where if we look at this report, this essentially takes all of the tests that were run during the test and sees what the sort of gas usage was for those tests. And so you can see within this gas currency, this Gas reporter thing, this is coming bundled in with the toolbox. But essentially if you call enabled get true, if I run this again without it, you just have the sort of output of the tests. Whereas if I run with it again, you can kind of see this table which gives you this put and so then you can start to see as you're making changes to your contracts how that's then impacting different things. So, for example, if we add a UN two five six.
00:15:12.290 - 00:15:17.700, Speaker B: Counter equal counter, then if we do count.
00:15:24.970 - 00:15:25.654, Speaker C: Now, if.
00:15:25.692 - 00:15:30.920, Speaker B: We do yarn test, see if I.
00:15:35.370 - 00:16:28.930, Speaker C: Give it a second. You can now see that the increase in gas usage because since I've added this new storage update and so that's again, a thing where you can start to optimize, start to keep track of the cost of different actions. The last thing I think I'd call out and just in the interest of time, I think I called this in was essentially the coverage command. So this is again similarly running your tests but also giving you a sense of the coverage of your tests. So if we jump back to my contract, you can see that my contract, I added a bunch of functions here and if we look at my tests, my tests actually only really test out the set purpose function. So this is identifying if we jump in here that actually there are some lines which haven't been covered by my tests, the percentage of functions which haven't been covered by my tests. Again, this is a thing that just comes bundled in with the Hard Hat toolbox.
00:16:28.930 - 00:17:22.330, Speaker C: So again, you can not only be running tests and feel confident that your changes are not having unexpected impacts, but you can also have an understanding about actually how thorough your test coverage is. So that's testing, there's a bunch of cool stuff there. If we go back to the Meme, we can see that we've covered testing coverage and gas reporting. And so then I guess we can jump into some of the slightly more advanced stuff you can start to do with Hardhat. So we're going to talk about tasks, EVM, manipulation, forking and verification. So if we jump back to the code, if we go back to the Hard Hat config, again, just to orient you on the stuff that's going on in this file, we're importing a bunch of plugins that are useful, we're configuring a bunch of essentially exports or modules. And so a lot of these are actually networks that we want to interact with.
00:17:22.330 - 00:18:01.640, Speaker C: You saw me like changing the network that I was interacting with. So that network configuration is a big thing here and obviously folks in Scapolith want to interact with a lot of networks here. You've got the OVM, you've got some of the again API keys or configuration for some of the other plugins. But then at the bottom here we've got a bunch of tasks. So within Hard Hat you can define a lot of tasks and scripts. So tasks and scripts, there's actually a post in the documentation about when you should use one or the other and focus on tasks today essentially these essentially little snippets that can be run.
00:18:03.610 - 00:18:03.926, Speaker B: In.
00:18:03.948 - 00:18:13.466, Speaker C: The context of the Hard Hat environment. So you can start to interact with your chain with your contracts. So let's run through a couple of those I guess.
00:18:13.568 - 00:18:20.026, Speaker B: So if we go Hard hats run.
00:18:20.048 - 00:18:50.134, Speaker C: This one you can see that I just ran this task which didn't do much, it just console logged hello world. So that's not necessarily that interesting, but then you can start to see other interesting stuff that you can do. So one thing you could do is you could deploy contracts or you could update state variables or you could interact with your contracts on chain through these tasks. But the thing I want to now dig into is some of the other things that you can do within Hard Hat which is kind of interesting. So that's essentially starting to manipulate the EVM so if we take this one.
00:18:50.172 - 00:19:00.460, Speaker B: So this NPX hard hat hour if we jump back to here jump back here.
00:19:03.230 - 00:19:44.438, Speaker C: Essentially this is one of these essentially hard hat manipulations you can do where you can interact with the hard hat virtual machine to change the variables. So essentially there are a few of them that I've called out here. One is to mine a new block so that's just to add a new block number to the chain. And this one is to change the time on the chain. So you might want to do this when you've got a variable which is maybe you've got a game and actually you can only close the game after a certain amount of time but you don't want to wait that amount of time. You just want to sort of move forward in time. So if we go back again to the Ethereum app just because then we can I guess have a look at the stuff that's going on in the.
00:19:44.444 - 00:19:45.000, Speaker B: Front.
00:19:46.730 - 00:19:50.780, Speaker C: To get a sense of what's going on. If we go again add an hour.
00:19:54.190 - 00:20:03.980, Speaker B: And we interact these okay, I know what this is. Perfect.
00:20:04.670 - 00:20:31.698, Speaker C: So now we can see we mined an empty block. So when we mine that empty block you can see that actually jump forward an entire hour. So this is a timestamp. Similarly the block number is updated. So this thing where you can start to interact with the chain and so these feel like relatively small things that you can do. But there are some others that actually let you do other stuff. So for example you might want to adjust your balance.
00:20:31.698 - 00:21:07.554, Speaker C: So there's a help which actually lets you set the balance for a given account. So if we go back to this guy using hello Adamfiller ETH. If we take this and if we say okay give me ETH I'm going to run essentially this one run, give me ETH. Pass my address in here. So you can see this task was defined with this name. I added this address parameter and then what happens is that the helpers set the balance of my account to five Ether. So you can see currently I've got $15 so not one.
00:21:07.554 - 00:21:09.220, Speaker C: So we run in here.
00:21:12.070 - 00:21:13.620, Speaker B: And now if we.
00:21:16.470 - 00:21:50.810, Speaker C: I've now got five Ether. You can see it's not added five. It's actually just set my balance to five. So if I then wanted to change this maybe if I wanted to give myself 49 Ether again you can see set my balance again. You've got 49 Ether here. So again just ways in which you can start to manipulate the state again. So we've gone from like adding the time, we've gone to mining blocks, we've gone to setting balance.
00:21:50.810 - 00:22:33.470, Speaker C: What about doing something even more interesting? So this, this task lets you take some die. So this should actually be die. So this is a helper which lets you essentially define a user who's essentially impersonating an account. So to impersonate a sender which then lets you make transactions on their account which you could never normally do in normal context and send yourself some of any specified token in this case. So just to interrogate this again, this is called Takes and Die. Given a token address, a sender and a receiver, it creates this. And this should be much simpler.
00:22:33.470 - 00:23:08.646, Speaker C: It essentially takes an Abi, which is an ELC 20 abi. It then impersonates the sender account. So Heart Out will just assume the signer is the sender account. It then essentially instantiates a contract with Ethers and then transfers some of that token to you. So again, this is one where actually there's an interesting dynamic here. So we're jumping into another thing you can do which is to not just start your local EVM from nothing, but to do it from a fork. So this is one where I'll run a special command.
00:23:08.646 - 00:23:11.850, Speaker C: So I've just canceled my local EVM and I'll run a yarn fork.
00:23:12.990 - 00:23:16.246, Speaker B: So if we take this, see, I've.
00:23:16.278 - 00:23:21.360, Speaker C: Started a yarn fork and I'll deploy things to it.
00:23:23.810 - 00:23:30.910, Speaker B: Deploy if I refresh.
00:23:32.710 - 00:23:45.106, Speaker C: Actually I've got $17 on this, which is the account I have if I were to connect on localhost switch my.
00:23:45.128 - 00:23:49.070, Speaker B: Network switch network refresh my network.
00:23:49.150 - 00:24:59.046, Speaker C: You can see that actually you can see it's forked from mainnet because it's got the amount of I've got in this account on mainnet. You can actually then deploy a contract in the same way that you otherwise would. And so then essentially given this, I'm now essentially interacting with the chain which looks exactly like mainnet. So again, this is a super cool thing which harder lets you do because you can actually start to interact with this chain, lets you interact with this chain as if it is a real chain. So this is one where essentially if we go to Die refresh, this is the Die contract on mainnet. But my local fork is essentially looking at this. And so the way that this works if we go to package JSON is that when you run fork, essentially you run a normal hard hat node but you specify an RPC to use for the fork.
00:24:59.046 - 00:25:47.718, Speaker C: And so then essentially whenever you call for state that's only on the main chain, it will essentially defer to and use this RPC. And so that's again like a really powerful unlock if you want to maybe simulate or test what happens. I've used this in scenarios where I wanted to check what happened or verify that a bunch of transactions would have the outcome that I wanted them to. I could fork mainnet, run those transactions on my local EVM, maybe generate a bunch of signatures that do those kind of things and not worry too much about and then I could have confidence when I actually executed them on the real chain that things would happen as expected. Anyway. So where was I? If I jump back to what that then allows me to do is then if I say, okay, let's take some die and save this. So this is again on the localhost network.
00:25:47.718 - 00:26:10.180, Speaker C: This is the Dai contract. And sending from this Dai person to and I'd want to specify my address here. I think that's the right one. Run this. You can see now if we take my address, if we take my balance, you can see I've got five die. I've just given myself five die. Again, if I run that again.
00:26:12.390 - 00:26:12.706, Speaker B: And.
00:26:12.728 - 00:26:46.414, Speaker C: I run that address again, I've got ten die. And so again, one final really cool thing you can do so you can fork the network, you can send yourself die, you can act as other people, is a cool thing to do with hard hat final thing, I think. So again, this is just to talk to the plugin, like all of the plugins that exist on actually one other thing you can do is essentially verify contracts. So one thing I could do if I want to deploy is I could actually deploy to Rinkobee. I could deploy this contract to Rinker B. I'll do that.
00:26:46.452 - 00:26:47.040, Speaker B: Now.
00:26:50.370 - 00:27:06.600, Speaker C: This is actually deploying live to a testnet. One final thing that you can get out of the box is verifying your contracts. So now if I essentially take this contract ID, if we actually go and look at it on Rinker B.
00:27:08.490 - 00:27:09.480, Speaker B: That one.
00:27:14.090 - 00:27:17.786, Speaker C: We are going to be literally up to the minute we run in.
00:27:17.808 - 00:27:25.020, Speaker B: Here, take a look at this contract. Did that work?
00:27:26.670 - 00:27:34.350, Speaker C: Like it may not have. Maybe we're not going to make it at the last minute.
00:27:36.770 - 00:27:37.920, Speaker B: Let's see.
00:27:41.810 - 00:28:03.080, Speaker C: Okay, it's still indexing, but it should show up in a second. One final thing they can do, maybe it's not going to show up until this indexes is essentially verify contracts. And so if I run this last yarn, verify network, network wrinkle B command with this address.
00:28:05.530 - 00:28:06.806, Speaker B: Call this, this will.
00:28:06.828 - 00:28:23.710, Speaker C: Then verify the contract. Check the contract here. Perfect. It's submitted for verification and any minute now it should hopefully come back and it'd be verified.
00:28:26.050 - 00:28:31.134, Speaker B: And that's it, I think, and wait.
00:28:31.172 - 00:28:37.826, Speaker C: For the verification result. So now if we refresh back in.
00:28:37.848 - 00:28:38.420, Speaker B: Here.
00:28:42.630 - 00:28:48.760, Speaker C: There'S the verify contract. And that's all I got.
00:28:49.850 - 00:28:50.454, Speaker B: Amazing.
00:28:50.572 - 00:29:15.390, Speaker A: Well, as usual, this wouldn't be a talk if something doesn't go slightly according to plan, but this was great. A lot of interesting tips and tricks. And I'm glad that it's recorded because I got to really dig into some of these commands to actually do this on my own too. So appreciate this, Adam. Thank you so much. I hope everybody in the audience enjoyed this primer as well. And unfortunately we are a little bit over time, so we have any time for questions.
00:29:15.390 - 00:29:25.120, Speaker A: But if there are any that come up, I will send them to you directly and then we'll answer them back to the person who asked those questions. On the chat, so thank you so much.
