00:00:01.770 - 00:00:04.126, Speaker A: Cool. Hello and welcome.
00:00:04.308 - 00:00:04.702, Speaker B: Cool.
00:00:04.756 - 00:00:39.178, Speaker A: Thanks, Andrew. Hi, and welcome, everyone, to the Protocol Labs workshop minty fresh NFTs with IPFS. Joining us today is Yusuf. We'll kick off the session with a short workshop video clip, and then Yusuf will be taking some questions at the end. Why? One last reminder for everybody to just stake their spot for NFT hack. If you haven't done that yet, if you are struggling at all, please don't hesitate to reach out to myself or anyone else on the ETH Global team. Cool.
00:00:39.178 - 00:00:45.210, Speaker A: And let me just quickly grab the video clip and we'll kick off the session.
00:00:48.270 - 00:02:00.340, Speaker B: Hi, I'm Yusef from Protocol Labs, and lately I've been working on Minting NFTs with IPFS and Ethereum because I'm writing a guide on how to do just that. And in order to figure it out myself and to really explore the space, I wrote this command line application called Minty, and the guide is based on the app and just walks you through the code. And I'm just going to do that in person. Now, hopefully we can learn some interesting things about how IPFS and NFTs can work together. The guide, first of all, kind of gets into why you would want to do this, and I think for me, the most compelling reason is that with an NFT, you can't, generally speaking, store the primary data for an image or so on, on the blockchain, because it's incredibly expensive to do. So, state has to be replicated across every node and validated and all that. You have to pay gas or whatever the equivalent might be for your blockchain platform.
00:02:00.340 - 00:02:56.020, Speaker B: So you link to these things that exist off chain, but if you use a URL, like an Http URL to do so, like linked to data stored on a cloud bucket, for example, that URL can point to something different tomorrow than it did today. So any NFT that's Minted containing that URL had its meaning changed out from under it. Right. So IPFS is a pretty natural solution to this problem because IPFS uses content addressing to locate content. So when you add something to IPFS, it generates a hash, and the hash is used to find who's providing the content. And the only content that that hash could ever point to is the content that created the hash. So there's no way to ever change the data without just breaking the link, basically.
00:02:56.020 - 00:03:50.520, Speaker B: So that's a pretty useful property. And the other nice thing about IPFS is that if the original provider of the data goes away, but anybody else on the network still has a copy, then it can still be retrieved, which is nice because the crypto landscape changes quickly, I guess is a way to put it. And it's certainly possible that an NFT platform could shift or disappear, and you would still want the NFTs themselves to have value because the blockchain would presumably live on. Right, okay. So getting away from the motivations for why you would want to use IPFS for NFTs. How does that actually work? Right? So that's why I wrote Minty. And we can take a look at what it actually looks like right now.
00:03:50.520 - 00:04:29.602, Speaker B: Here we are. I've got the Minty repo checked out, and I'm going to start a local environment, which means I'm going to run a local Ethereum DevNet and also a local IPFS node. And now I have sort of a blank ethereum network to work with. And so I'm going to deploy a smart contract into it with this Minty deploy command. I should briefly mention that I've NPM installed a bunch of stuff. It's going to create a deployment JSON file, and I'm going to override the old one that I had lying around. And then that has some information in it.
00:04:29.602 - 00:05:16.500, Speaker B: It has the address of the contract and the abi. These are the pieces that future Minty commands are going to use to connect to the deployed contract. So I run Minty help real quick. We can see what Minty can do, right? So I can make a new NFT and give it the path to an image file. I can show some details and metadata about an existing NFT. I can transfer a token to some new owner, and I can pin the data for a token to remote service, which we'll get into in a few minutes and deploy we just saw. Also, if I want help on a specific command, I can ask for it by saying Minty Help, Mint, or whatever command I'm looking for.
00:05:16.500 - 00:05:41.878, Speaker B: Okay, now let's Mint a new token. So I'm going to say minty. Mint. And then I'm going to give it the path to this lovely IPFS logo I have on my machine. So give it a name IPFS logo. And there we go. So it has minted a new NFT hooray.
00:05:41.878 - 00:06:28.860, Speaker B: It has the token ID one. And here's the IPFS URL for its metadata and also an HTP URL for my local IPFS gateway. So this one, the first one I could put into Brave or IPFS desktop and resolve the content that way. Or if I don't have those installed, I could go here and just view it in Chrome. So this is that same metadata that's displayed in the Minty Mint output and stored as JSON on IPFS. And inside that JSON, actually, you can see here we have the IPFS Uri for the asset itself, for the image. So and that's this URL here.
00:06:28.860 - 00:07:10.920, Speaker B: Here we see the IPFS logo, and that's great. So that's all our data in IPFS and associated with a token ID. And so if we want after the fact, we can view that data again with Minty show. And I'm going to pass in a flag to also get like the block that it was mined on and who owned it at the time of its creation, because I can transfer the token to a new address. And now if I run Minty show again. It'll say this guy is the owner now, but it was originally created by this guy over here. All right, so that's pretty cool.
00:07:10.920 - 00:08:02.200, Speaker B: But how does this all actually work? Right? That's what this is all about. It's like figuring out the process of doing it. And specifically, how do you do it in code, right? So here we are in a JavaScript file. This is a node JS application, although the same techniques should work in the browser once a few PRS land in Jsipss. So we've got here I am reading that deployment info JSON file that I showed you earlier to get the contract abi and address. And then using that I'm using Ethersjs, which is a smart contract interaction library to connect to the contract. And now I have a contract instance that I can call functions on or methods on.
00:08:02.200 - 00:08:58.946, Speaker B: And here's my local IPFS instance and it's actually driving that local IPFS demon over its Http control API. But again, soon this will all be possible using an embedded Jsipfs node completely contained within the browser. So that's kind of interesting, but there are some considerations there that make it a little trickier to set up in the interest of simplicity. Minty is a command line app. Okay? So I've set up my IPFS and my blockchain connections and now I want to create an NFT. So here we are in the Create NFT asset data method. I am going to add the data to IPFS and I'm doing so one thing to kind of call out here is that I'm putting my data inside a directory on IPFS.
00:08:58.946 - 00:10:19.730, Speaker B: And the reason I'm doing that is because since this is an example app, I want things to be kind of friendly and distinguishable in the output so it's easier to tell which is the asset and which is the metadata if I include a nice human readable file name. So if you put your IPFS data into a directory, you can get these little human readable file names as part of the Uri. But if you don't want to store that human readable bytes on the blockchain, you might want to escape this part. So anyway, you've got your data into IPFS and now I have a CID, and then I'm going to make sure that it has that slash prefix to turn it into a Uri. And because we have those human readable names, we add that to the end as well. And then I'm going to make that JSON metadata object by taking the name and description passed in by the user, putting the Uri in there in the image field, which is its standard location in the ERC 721 metadata schema. Although as an entity platform, you have pretty much free rein to define your own metadata conventions, this seems like a pretty good baseline that everybody more or less tries to be compatible with because it gets you some nice features like wallet support out of the box.
00:10:19.730 - 00:11:17.130, Speaker B: So people can kind of give you an overview of NFTs even if they don't support your platform specifically. Okay, so now that I've got that metadata object, I'm going to stringify it. I can convert it into just a JSON string and store that into IPFS as well. So yeah, with those I am going to either use the default owner address or the one passed in by the user and mint the new token. And the way that works is I call the smart contract function passing in that metadata, it gives me a transaction because I can't get the new Token ID out immediately. The way this works is like calling the smart contract function because it modifies blockchain state. It has to wait until a block containing the transaction has been mined and confirmed by the network before we know for sure that the new token has been created.
00:11:17.130 - 00:12:09.570, Speaker B: And so once we have this transaction, we can call wait on it, that's going to hang out until the transaction is confirmed and give us a receipt. And the receipt is going to contain events that are remitted by the contract. So I should take a minute to check out the contract itself. I'm using a base contract from Open Zeppelin, which is very comprehensive and does everything that an ERC 721 token should do and lets me make this contract very simple. So the way it works is first it's going to add that IPFS for you just so we only have to store it once in the blockchain instead of for every token. And then you have a counter that gets incremented with every new token and that becomes the Token ID. The token is issued to the new owner and Safe Mint does a check to make sure that the owner can receive tokens.
00:12:09.570 - 00:13:05.446, Speaker B: It's possible for another smart contract to call this function and to be the owner of the new token. But for that to work, the contract has to support receiving tokens. Okay, so then you also have this set Token Uri where we take the metadata Uri passed in by the user and associate it with the Token ID and that's really it. Otherwise it is a fog standard. ERC 721 Token as implemented by opens up. All right, so back in Minty JS, that base contract, right, when it does mint the token, it's going to emit a transfer event. This event also gets emitted when token changes ownership, but for a new token, the from address is going to be all zeros.
00:13:05.446 - 00:13:52.058, Speaker B: But at any rate, we don't really have to check for any of that because we know there's only going to be one transfer event in this transaction and all we care about is the Token ID. So we pull that out of the event arguments and return it to the user. So that kind of takes care of token creation for us. We now have everything we need and we return some data to the user and then another bit of code formats it for display. So then, yeah, if you want to get the data out again, it's pretty simple. We go here and call the Smart Contracts tokenuri function, which is built into the base contract. And this time we don't have to mess about with receipts because this token Uri doesn't modify any blockchain state.
00:13:52.058 - 00:14:50.670, Speaker B: So a read only function can just return more or less right away based on information that it's already in the blockchain. And then so once we have the Uri, we use that to fetch the IPFS JSON using this little helper here, which just pulls the data out and treats it as a JSON string parses the JSON. So that's cool. And in the Git NFT command, this is where you can optionally get some historical info. And that works by querying the record of events that have applied to this token ID before. In Ethersjs that we're using, you build a filter for the transfer event and say, I want it, give me all the events from this token, and the first one is going to be the creation event. So that's what we care about is getting the creator's address and the block number that it was mined.
00:14:50.670 - 00:15:36.710, Speaker B: Okay, so now we can add a token. We can get a token transferring works pretty much the same way. We just call the transfer function and wait for it to be completed. And then now there's sort of one missing piece, which is that we've so far been adding IPFS data to my local IPFS node which is running on my laptop. And sometimes I like to turn my laptop off. So when that happens, if somebody tries to request that data, they may not be able to find it. There's a chance that they will, because the way IPFS works, the data is first going to be stored on my machine and then advertised to the network.
00:15:36.710 - 00:16:32.560, Speaker B: Anybody who requests it will temporarily keep a copy around in their local IPFS repo and provide it to the network as well. And that makes it more resilient and kind of shares the load across the network. But those copies are temporary. We can't fill up everybody's disk with redundant data. So if you want your data to persist long term without running your own IPFS infrastructure, like IPFS cluster for example, which is a highlight, you can request that a remote service pins the data for you and makes it highly available on their IPFS infrastructure. And one of the nicest services that I know of for doing this is Pinata, who is also by the way. They have excellent resources for learning about NFTs, especially as they relate to IPFS on their blog, which I highly recommend.
00:16:32.560 - 00:17:52.614, Speaker B: So if you haven't signed up for Pinata already, they have a free tier. It's really easy and takes a couple of minutes and then boom, you'll get yourself a access token. Once you have an access token. I'm going to skip the whole creating and fetching the token for brevity's sake. But once you have one, if you set it to the Pinata API token, environment variable Minty will pick it up by default and let you pin things to Pinata. If you would rather use a different service or you just don't want to mess about with environment variables or whatever, you can edit the configuration in this file config default JS and paste your token in here or replace Pinata with a different now. So now that I've done that, I should be able to say Minty Pin one the token ID, it will look up the Uris and everything from the blockchain and ask Pinata, hey, will you please pin these IPFS CIDs for me? And Pinata will go and connect to my local IPFS node, and also my local IPFS node will try to connect to them.
00:17:52.614 - 00:18:40.086, Speaker B: And Pinata is going to be like, hey, you have this data. My node is like, sure. And then Pinata stores a copy and keeps it alive indefinitely as long as I continue to pay my Pinata bills, I guess. Although I have yet to exceed the free tier in my experimentation. Okay, so now we have the data pinned, and if I want, I can go to I can say IPFS Pin remote LS and give it the name of the pinning service, and then it will go and ask Pinata for a list of all the pins that I have created so that way I can confirm. Yeah, okay. Yes, it was added so cool.
00:18:40.086 - 00:19:35.400, Speaker B: That's most of the Minty functionality right there, and there's certainly a lot of work that could be done to take this and turn it into like, a fully decentralized DAP that runs in the browser. I'm personally really excited about that work, and I'm eager to see where that ends up. And as someone who's relatively new to NFTs, there's just a lot of exciting movement happening that I am happy to be a part of now. So hopefully this has been helpful. If you have questions for me personally, please hit me up. You can email me at yusef at protocol AI or try to find me on some kind of social media, which I occasionally check. Thanks very much.
00:19:42.750 - 00:20:02.640, Speaker A: Great. Thanks so much. Yusuf, that was great. Apologies that I wasn't on full screen for the first minute or two. Yeah, we can open the floor to some questions that have come up in the chat. Yeah. Yusuf, if maybe you want to give yourself a quick intro, say hi and then jump into the questions.
00:20:03.010 - 00:20:28.050, Speaker C: Yeah. Hi, everybody. Thanks for sitting through my pre recorded thing. My bandwidth at home was a little sketchy, so I figured that was the safe bet. And there's a few questions in Chat that I could go through real quick and then we could open it up for some more stuff. So first we've got to store metadata on IPFS while minting via another platform, like a Gui Minter. That's definitely doable.
00:20:28.050 - 00:21:17.550, Speaker C: You can either add any way you get data into IPFS is fine, and then you should be able to take that IPFS Uri and send it off to a Gui platform. Although there's a little caveat that the platform will probably need to add some kind of support for IPFS. You could add a gateway Uri instead if they only support HTP Uris, but that's sort of dependent on the platform specifics. And then there's a question about what types of files can you not store in IPFS? There's no real restriction as far as I know. IPFS is pretty much agnostic to what kind of data it stores. It's just bytes as far as it's concerned. The only practical restriction would be what kind of data is viewable in the browser or whatever you're using to present the token.
00:21:17.550 - 00:22:14.970, Speaker C: So probably an image file or video is cool, but maybe not like an executable or something like that. There's good questions about what guarantees are there for storing IPFS data long term, and IPFS is it doesn't guarantee persistence of data. That's something that we're trying at Protocol Labs. We're really focused on Filecoin as the eventual answer here. We think that there's a really huge potential for using Filecoin as the long term persistence layer for this kind of data. The movement along those lines isn't really ready to present publicly yet, but we're internally figuring this out and trying to package it up in a friendly way for people to use. And when that does happen, it's very likely to be using IPFS as the interface for managing and viewing the data, and then it gets shuffled into Filecoin sort of behind the scenes.
00:22:14.970 - 00:23:15.582, Speaker C: And I actually have something to say on those lines in a little bit once we get through these. But as far as why pinata is expensive, I can't really comment on that because I don't know their economics very well. Yeah, so there's a good question that just came in from YouTube saying who's responsible for paying for pinning, right? Should it be the person who mints the NFT? Is it the person who owns it? And so on. That, again, I don't have a super satisfactory answer for because I think it depends on the goals of the NFT platform. To an extent. It might be worth the platform's while to sort of eat the pinning cost in order to gain adoption, or it might be advantageous to allow users to add their own to sort of take care of the pinning for themselves. I don't know.
00:23:15.582 - 00:24:41.162, Speaker C: Ideally, in the perfect future land when the sort of pin to file coin functionality is rock solid, then that would be what I would recommend. But that's not a satisfactory answer today. So I think today it's sort of a compromise between making things super easy for the users, in which case the easiest solution is for the platform to kind of subsidize the pinning for at least temporarily, and then the more decentralized version is to encourage users to also pin the data themselves. And then somebody's asking about, say, I don't know a ton about Argweave, although I've been super curious about it and I've been researching it a lot in the past couple of weeks, largely because of the NFT use case is a good fit coming from a Protocol Labs perspective. Obviously I want everybody to use IPFS and filecoin, but I think it's certainly worth exploring Rweave and they have some interesting properties that make it attractive for this use case. Again, I don't want to take a side on it really, although I suppose as a PL employee, I'm honor bound to show our stuff. But I do think that IPFS is a good fit for this kind of data as well.
00:24:41.162 - 00:25:57.380, Speaker C: But I think hopefully there's like a good synergy story to flog a buzzword there or whatever that we can complement each other in the future. And so I'm actually spending a lot of time personally just researching this because I find our week pretty intriguing. And then Isaac is asking if I know the general cost and sizing of instances for pinning nodes. I think that if you are really optimizing for cost, you would probably as an NFT platform, run your own IPFS cluster, which would be less expensive than delegating to a service like Pinata. And in that case it's just basically the cost of running some EC two machines plus whatever storage you actually end up using for the nodes. But specifically for you guys here at NFT Hack, i, as the first PL employee to be speaking here, get to be the one to announce that we're launching a beta program for this thing called NFT Storage. If you type that into your browser, you should be able to sign up and we're going to subsidize storage costs for NFT Storage for everybody that's participating in NFT Hack for an indefinite future.
00:25:57.380 - 00:27:05.320, Speaker C: Basically, we're going to store your data for free up to a few gigabytes and let everybody have a chance to play with this and it's going to be stored on IPFS and pinned. And then also we're going to take the data and shuffle it into filecoin so that we get experience with that whole process and then you'll be able to see the filecoin like deal CIDs and so on, that are backing up your data. So this is brand new. It's just gotten live this morning, but there's going to be if you stick around, I think it's Saturday. Alan Shaw from PL is going to be talking about it, and he'll give you all the details and get sort of behind the scenes of that a little bit more than I'm able to know. The code is available, it's on my GitHub organization right now, but we're probably going to move it into like an IPFS docs examples repo soon and the guide that I showed at the beginning I am hoping to have published by the end of the day today and that will live on the IPFS doc site. So yeah, that's cool.
00:27:05.320 - 00:27:14.300, Speaker C: I'm now realized I've been talking for a long time, so if anybody has any questions that you want toss at me, please go for it.
00:27:18.990 - 00:27:50.070, Speaker A: Yeah, anybody's free to unmute themselves and ask use of their question live. If you're a bit shy, you can drop it in the chat, but yeah, feel free to ask the questions live. Yeah, there was a question from YouTube about if anybody knows what the cost of pinata pinning is recently or yeah, is the code showed available on GitHub?
00:27:52.490 - 00:29:00.560, Speaker C: Yeah, the code is there on let's see, drop the link again. Here it is. Minty is the GitHub repo and yeah, the Pinata pricing currently I'm looking at their page now, they have different tiers for tailored to NFT platforms. Their NFT platform launched here, they're asking $500 a month and then scaled here is 1000 a month. But I don't know when you would be likely to hit those limits as I have not tried to run a production NFT platform. So about pinning in general, right, basically pinning means that there's sort of two aspects to it. There's like a local pin, meaning if I say to my local IPFS node, please pin this content, that just means my node is never going to throw it away unless I unpin it.
00:29:00.560 - 00:30:12.258, Speaker C: But then there's a service named like Pinata. They will also pin your content and keep it on their nodes, but with an additional guarantee that they're going to be online all the time and have enough replication to make it available to anybody who requests it. So there's a common misconception about IPFS that when you add data to IPFS that it gets replicated across the entire network right away, or that it's sort of like on IPFS in the same way that data is on the cloud, if that makes sense. But really it's much more similar to a peer to peer file sharing service like the BitTorrent protocol. There's a lot of similarities at a protocol level, although there's lots of differences in terms of the use case and everything else. But when I have data on my IPFS node, it doesn't automatically get spread out. So that's why the remote pinning service kind of is part of the story here because they need to, generally speaking, for data that you want to be super durable, it's a good idea to ensure that you sort of have a guarantee to that effect.
00:30:12.258 - 00:30:46.800, Speaker C: And again, if you're running your own infrastructure, you can provide that guarantee yourself with IPFS cluster, but especially for startup platforms, they may not want to do that. And it is definitely possible to run IPFS nodes on AWS. You can start your own pinning service if you like, or you can just the IPFS cluster will just let you pin any content to it directly without having to use the service API necessarily. Yeah, and once again, NFT Storage is the thing that you guys should go check out.
00:30:49.730 - 00:31:02.818, Speaker A: Thanks so much, Yusuf. That was really great session. And yeah, I think you got through almost all the questions. There's one last question here, I think, that you can answer in the chat and then we'll wrap it up.
00:31:02.984 - 00:31:18.460, Speaker C: Yeah, unfortunately, I'm not qualified to answer anything about SIA because I just am not educated. But possibly someone else from PL that you may bump into at NFT hack would be able to. It's just not anything I've had time to look into yet.
00:31:19.230 - 00:31:38.518, Speaker A: Yeah, that's great. There is the Sponsor Protocol Labs channel that everybody's free to reach out in if they've got any specific questions or haven't had time to ask them during the workshop. But big thanks, Yusuf, and everybody has a great afternoon.
00:31:38.694 - 00:31:40.140, Speaker B: Thanks so much for having me.
00:31:40.590 - 00:31:42.210, Speaker A: Yeah, thanks, yusef.
00:31:42.870 - 00:31:43.550, Speaker C: Cool. Bye.
