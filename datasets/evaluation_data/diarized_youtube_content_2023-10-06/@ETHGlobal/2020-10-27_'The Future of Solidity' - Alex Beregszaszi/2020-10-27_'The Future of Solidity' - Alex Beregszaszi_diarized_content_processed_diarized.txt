00:00:00.250 - 00:00:23.802, Speaker A: Um, next up will be Alex. So my teammate from Solidity, Alex, is actually co leading the Solidity team and he's also leading the eWASM team. But this talk is going to focus on Solidity. Alex is going to present the future of Solidity, which will entail a feature preview for the upcoming 0.8 release. But I guess also a bit more than that. Hi Alex.
00:00:23.802 - 00:00:24.480, Speaker A: Welcome.
00:00:28.730 - 00:00:38.470, Speaker B: Heather. I'm just trying to share. Is it shared?
00:00:38.890 - 00:00:40.460, Speaker A: Yes, we can see it.
00:00:51.310 - 00:00:56.160, Speaker B: I'm just a bit confused with Zoom. Can you also hear me?
00:00:56.610 - 00:00:57.360, Speaker A: Yes.
00:00:59.410 - 00:01:33.820, Speaker B: Okay, now I can hear you as well. Thank you, Francis. Okay, let's get through this. So what I'm talking about today is a couple of different parts regarding Solidity. Initially the goal was just to talk about zero eight, but if time allows, we'll see. I'm going to go a bit further than 0.8. But before that before that, I just wanted to highlight a couple of things.
00:01:33.820 - 00:02:34.830, Speaker B: We have launched this week a language portal which can be found on Soliditylang.org. And it has all the relevant links to everything, including the blog, all the different forums, the releases, and also some background detail. And I think all of the links I have in the slides can be found through the portal. Now, the portal is still in development and it's just the first version and we hope to make it much more packed with features and content. But that's just going to take time. The second thing I wanted to mention is this underhanded Solidity coding contest, which is a fun little challenge to see if you can hide functionality and the source code. Now, regarding the agenda of today, here's another link which also can be found on the portal.
00:02:34.830 - 00:03:14.186, Speaker B: It goes through the past five years of Solidity had, the language has changed with a couple of interesting tidbits, but we're not going to talk about that today. I'm going to have three parts, but depends on how we get on with time. First. The short term part is I just wanted to make clear how the release process works in the team. I know we have mentioned this many times already, but it never hurts to mention it once more. So we try to make really frequent releases two, three weeks. I know sometimes we haven't really gotten to do that and maybe it took like six weeks.
00:03:14.186 - 00:03:45.394, Speaker B: And in case of bugs, we do make quicker releases. But I think we are fairly consistent at two, three releases releases every two, three weeks. And we also try to make breaking releases twice a year. We haven't really done this so far, but maybe this year going to be the first year we actually achieved it. So the last breaking release was zero seven in July and we hope to have one 0.8 by end of this year. And for 0.8,
00:03:45.394 - 00:04:20.222, Speaker B: I've collected four interesting features which seem to be becoming part of 0.8. I think some parts may change slightly. But I think mostly what I have in these slides going to be what's included in eight. Regarding those, there might be some other smaller or different changes I haven't listed. But this just isn't time to go through everything. So the first interesting one, I'm sure everybody is waiting for this forever by now. Let's start with a simple example here.
00:04:20.222 - 00:05:17.986, Speaker B: So what happens in this function if he passed in minus one and one, the function would return one because it wraps around and why doesn't it just revert? We really shouldn't wrap around, one could say, and there's a very simple reason to that because Solidity is just exposing what the EVM is doing. We are not trying to add extra code because that costs gas and people don't really like to spend extra gas if they don't need to. But in this particular case it seems that actually people are willing to spend gas because they don't really want this to happen. And that is signaled by the Safe Math libraries or the Safemath library. Well, actually probably more of them which in practice everybody uses. So the good news is that you may not need to use it anymore in eight. So in 0.8
00:05:17.986 - 00:06:31.266, Speaker B: we are introducing what's called checked arithmetic by default. So this piece of code here would cause a revert in the previous example and this is exactly what SafeMap is doing. But what if you actually want the overflow the wrapping around behavior? We actually got you covered because we have this extra feature here called unchecked and any piece of code which is wrapped in the unchecked block won't have the overflow or underflow checking generated so those will behave as they were in 0.7. I haven't really gone through everything here. There are various different edge cases so please check the documentation because it's much more than these two slides could cover. But there's another interesting piece here regarding type convergence. Actually a few weeks ago I tweeted about what do you think is address minus one valid? And initially it was a poll.
00:06:31.266 - 00:07:31.260, Speaker B: So the initial the response to that was what I hoped I'm going to get is that it's not valid. But then people actually checked the documentation or remix and turned out yes, it is actually code which compiles. So the poll ended up saying it's valid code. The reason we found this, because it's not about finding, but the reason it came up as a discussion is because we were heavily working on the Smt checker functionality and we wanted to properly implement different type conversions and actually all these little details on this slide and the next slide is the outcome of that review process. And we found that this is rather confusing. So I collected a couple of different strange conversion scenarios here. Unfortunately we are not really interactive but I gave you 2 seconds to think what each of these going to result in.
00:07:31.260 - 00:08:34.040, Speaker B: Okay, so this is what actually happens. I mean some of them you could understand. It could be said to be intuitive, but I find it rather confusing that we have so many different rules and in many cases we restrict everything and then we have this type conversion mess. Luckily we won't have this type conversion mess anymore. The really interesting part down here is the bottom tree cases. So depending on just basically this very last line here, the outcome would depend on the implementation. And by implementation I mean whether first the sign conversion is taking place on this line or whether the size conversion is taking place first, the outcomes would be different.
00:08:34.040 - 00:09:24.406, Speaker B: This is of course not a problem in solidarity because the order precedence hasn't changed, neither it did in the new code generator compared to the old one. So nobody has really seen this as an issue. But as we are having more compilers for Solidity and more people looking into Solidity, if this is not well specified then this could become a problem. But there just doesn't seem to be any reason to support this functionality. So we actually just removed it. So all of these weird cases here, with the exception of this valid address, all of these are becoming invalid. So basically the literal has to be the literal is this here.
00:09:24.406 - 00:10:29.718, Speaker B: So it has to be less or equal to the bitwidth of the type and the signs must match the type. And by this I mean that if it's an unsigned type, it's not possible to assign a sign number to it, it's only possible to assign it to sign numbers we do have. One exception is address zero because that's really useful and it's used very frequently. Now another I think extremely important piece is panic codes and you will see that this is actually connected quite a bit to the stuff previously discussed. So currently there are two different ways where code can abort. And the one case is where the code is going to have an invalid upcode and that means that all gas is going to be consumed. In the second case is where we have a revert upcode and of course this only applies after Constantinople or Byzantium.
00:10:29.718 - 00:11:22.000, Speaker B: Anyway, this has been introduced a couple of years ago but it hasn't been there initially. So basically there are two ways to abort execution with failure. One case is with the invalid of code when all gas is consumed and the second case is the revert of code where the remaining gas is kept. There's another main difference between these two is that with revert it is possible to send a message to the caller and that message could explain why did we abort. Now this is what we have today. Before eight, in many cases, invalid opcode would be used internally and this is changing. Now, just a bit more explanation what reverts are.
00:11:22.000 - 00:12:13.120, Speaker B: So this case like with the require statement, which I'm sure everybody is aware of, that of course uses the revert of code. And actually what happens here is that we have an encoding for this message. We're not just putting this message into the revert message, rather we encapsulate it and we encapsulate it with the Abi encoding. And practically it just looks like a function call. So the error function which has a string and then we just encode the message. So one could say that this expression here, this statement, the required statement would equal to this one. So it's just a weird way to encode the same thing.
00:12:13.120 - 00:13:16.340, Speaker B: So we have these error messages and now we're introducing a second case, the panic messages. And a panic message is basically any kind of internal error is emitted as a panic message. So the main benefit we get here is that we are not going to consume all the gas and second, we are able to deduce from the outside. Why did the execution stopped? I didn't list here all the different panic codes and I think it's still possible to argue whether the code should be different because the release hasn't really come out yet. But we do have, I think I'm missing three or four more because there just wasn't enough space on the slide. It's however, documented in the breaking branch. So it's possible to still discuss these error codes, but this is roughly what they mean.
00:13:16.340 - 00:13:47.286, Speaker B: There is a specific error code for manually calling a cert. There is a specific error code for under or overflow. Obviously that's outside of the unchecked blocks. There is a specific one for division or modulo by zero. There's specific one for out of bounds access and type conversion. There's also for trying to allocate too much memory, et cetera. There are a bunch of different error codes.
00:13:47.286 - 00:14:24.114, Speaker B: I actually invite all of you guys to check the documentation and maybe give some feedback because it would be bad to hard code these. And then next reads people wanted to change them. And the fourth big change I think is the Abi encoder V two. What changes related to it. Now, maybe I should just give a first explanation what the hell Abi encoder V two is. I'm sure many of you do know what it is, but maybe some others don't. So it has been introduced in 2017.
00:14:24.114 - 00:15:11.320, Speaker B: So quite a while ago. And the Abi encoder is this piece of code which generates the code to decode and encode all the inputs and outputs from a contract. So when somebody is sending data to contract, it's encoded into this Abi data structure and that needs to be decoded and any response has to be encoded. And the compiler has two implementations of this code generator. The one is I guess Abi encoder V One and the other one is Abi encoder V two. The main difference from the old one is that V Two generates Yule code and the V One just generates EVM bytecode. So it's kind of hard to work with.
00:15:11.320 - 00:16:54.470, Speaker B: So the Yule code is much better maintainable and it also supports more types and probably that's the reason some of you have used it because it does support various features from Structs which are not supported by the old API encoder. But some of you may have also noticed that this v two is a bit more strict than the old one and in some cases it may consume more gas. And this gas question may have been more relevant, I guess early on when this was introduced, but especially last year we have worked by last year, I mean 2019, and earlier this year we have worked quite a bit on the optimization capabilities for you. So I think actually the gas costs are not all that much off compared to the old one, but it is way more strict and because this was a second encoder, it had to be enabled by choice. So we had this experimental Pragma for AB encoder v two and for a long while this has to be added in the source code, in every single source code you want to use it. And if a given source code doesn't have it and you mix these together, that is also working. And then for a long while, whenever anyone specified this experimental Pragma, the metadata also had an experimental flag to signal that this may not be production ready software.
00:16:54.470 - 00:18:06.046, Speaker B: However, we have removed this experimental flag from the metadata last year with the six release, but we still kept the experimental Pragma and now with eight we are changing this. It is going to be enabled by default, but for those who still want to use the old one, which I don't see any reason to, but if you still want to use the old one, you can do that. We are introducing a new Pragma here called AB encoder and it has two options v one and v two. So if you want to keep using the old version, you have to introduce this extra line. You can also explicitly use this new one, but it is enabled by default and to make life a tiny bit easier, probably we are going to keep supporting the experimental Pragma, but it's going to emit a warning. Now that is all about the zero eight I wanted to highlight, but there's of course a lot more. We have a project in GitHub I haven't linked here, but I guess I can show it through the Q and A if you have time.
00:18:06.046 - 00:19:01.242, Speaker B: And that project we use to rank and sort different proposals and discuss them and that project is just basically working of these labels. What I'm trying to show here is that we have two important labels we work with the language design and the breaking change. And you can see that there are 126 open language design issues. So that's quite a bit of changes. And that means of course, these four changes I mentioned are not the only ones which we are discussing. Obviously it's not possible to discuss all the 126 changes every week, but we do pick from these issues. And here I picked actually four different issues I wanted to highlight, which are important, at least in my opinion in the medium term.
00:19:01.242 - 00:19:42.046, Speaker B: So whatever I said regarding 0.8 is probably what we agreed on as a team. But this part of the talk is more like an opinion piece. It's not like a final decision from the team and I'm not trying to make it look like so. But I think these four issues I'm going to briefly talk about are really interesting and important for the future. I'm sure you have heard about this solidity to Yule code generator for a long while because we have been saying this for years that yeah, we're going to have this Yule code generator done. And yeah, actually we are quite close to that.
00:19:42.046 - 00:20:29.654, Speaker B: So we have a project board, a separate project board, not the one I mentioned, just for this solidity to Yule code generator. And this project board is becoming rather empty. So it would have like five different columns from Icebox to in progress to In Review to Done. And we only have a handful of issues in the Icebox and over 50 issues in the Done, but unfortunately it's still not 100% complete. We have two major things to finish. One is support for libraries and some cases of copying between memory and storage. However, we at the same time trying to maybe consider moving off libraries.
00:20:29.654 - 00:21:53.426, Speaker B: So I'm not sure what's going to happen with this here. The main goal of having this sold to Yule conversion is to have better maintainability and also because the Abi encoder v two generates Yule, it provides a much better integration. So one could imagine that if we are using this sold to Yule and Abi encoder v two, then we have the entire contract generated in Yule and we can apply optimizations on Yule itself, then we can translate that Yule code to EVM and then we can also apply optimizations on the EVM bytecode. Compared to that today it's a bit different because if you compile directly to EVM in the compiler and then use the API encoder v two, what that means is one needs to compile the API encoder v two output to EVM and then consider the EVM code. So by moving to this intermediate step, we're going to have much better possibilities for optimization. And it also going to finally give some solution to the stack 2D pair. There is actually a piece of code implemented called the Memory Escalator, which can move variables from the stack into memory and back and forth and that is implemented on Yule.
00:21:53.426 - 00:22:43.910, Speaker B: So hopefully that is also going to be fixed by this. I don't truly give any deadline when it's going to happen, but yeah, we're really hoping to get this down fairly quickly. So this salt to yield project. This feature can already compile a bunch of contracts. It can compile the uniswap factory as well, I believe and it can also compile the E two deposit contract and it can almost compile diagnosis safe in the multisig wallet. There's only just one feature missing in each another I think. Rather interesting functionality we are discussing and here's the link for the discussion is enums not with metadata.
00:22:43.910 - 00:23:39.414, Speaker B: Yeah, enums with data or algebraic data types. So here's a small example. As you can see, we are using the enum syntax and it is possible to have various oh, why is the okay, yeah, there should be a semicolon, there a comma there. Anyway, this is the current syntax. This is not implemented, this is only under discussion. I think what I wanted to actually highlight here so you should rather just go to the issue because it's a lot to discuss. But this is a simple example and what can be I guess seen in the next slide is that we don't have a syntax for matching yet.
00:23:39.414 - 00:24:46.670, Speaker B: So basically one would need to have a long if else chain to evaluate all the different types and the current conversation is really just focusing on how to encode this in the abi and the storage. And I guess once we have that done then we could talk about the matching but anybody is invited to come up with any suggestions and especially I would be interested to see if anybody is really interested in this functionality and how would you use it. Another really highly debated topic is the templates. I think this issue was created in 2016, maybe even 2015. So it exists for a long time and it has been discussed for a long while. On the issue. Actually there are a couple of links to different GitHub, Gists or Gists which have a variety of examples and I'm not going to go into too deep into that, but here's a simple example from how to do typecasting.
00:24:46.670 - 00:25:54.450, Speaker B: It's kind of like a weird example but it shows the syntax. I mean it's nothing really strange or unfamiliar, it's kind of similar to C plus plus and Rest. What we are more, I guess busy with regarding templates is writing more examples to find potential problems and by doing so we also figured that we would need a lot of different introspection helpers for types and this is somewhat related. Standard library is something we also this is like the fourth topic we also have heavily discussed. I want to make sure everybody understands we're not trying to compete with Open Zeppelin. So it's not a standard library for ERCs and higher level protocols and functionality. It's rather a standard library for moving more features from outside of the compiler code base and to also maybe decouple the EVM specific behavior a bit more from the compiler.
00:25:54.450 - 00:26:51.010, Speaker B: I gave here two different examples. So one thing, what could happen with having a standard library is removing the need for global functions we have. Now this here, it doesn't really say anything more where this standard library lives. It just means that by default in the namespace, there wouldn't be an EC recover as it is today, but rather it has to be explicitly imported. And one could imagine that maybe this standard library would be still part of the compiler. And all this means is just cleaning up the namespace, which is I think already a useful step to make, but we could also implement some of these helpers in Solidity itself. This is an actual implementation for EC recover, even if it doesn't look nice, but it is possible to move functionality out of the compiler.
00:26:51.010 - 00:28:30.710, Speaker B: And I think this is going to be some of the really interesting steps to do. And some of these examples I gave prior, like the templates and algebraic data types, these actually play quite well into the standard library discussion. And now we got to the very end is what the long term going to be like for Solidity? So this just has a bunch of different questions and I feel I have some answers to them, but I don't think we have enough time for that. But one question is will we have different targets or different dialects of the language? Will we support roll ups, different roll up systems in the compiler? Will we support some kind of sharding or will we support eWASM? Just a brief answer is what I discussed about this Sol Yule stage is that Yule is an intermediate language which not only can be converted into EVM, but it can be converted into other bytecodes as well. So internally in the compiler we have a piece which converts it into eWASM or just WebAssembly, but we also had a discussion with the OVM team and it would be possible to translate it into OVM bytecode. However, that hasn't been implemented. And the importance of dialects or targets would be to have the capability to disable features in the source code which would be specific to a different specific target.
00:28:30.710 - 00:28:42.810, Speaker B: Yeah, I'm not sure if we have time maybe for one question, but I think I filled out the 30 minutes, so yeah, that's what's I guess next for Solidity.
00:28:44.270 - 00:29:12.340, Speaker A: Great. Thank you, Alex. Yeah, we are perfectly on time, so we don't have that much time left for questions, but I want to ask one question before we wrap it up. So basically all of this was more or less about the future language design of Solidity. Are you currently happy about the setup and process, how it's working? Or if you could make a wish, who would you wish to have participate in the language design more?
00:29:14.950 - 00:29:55.246, Speaker B: Everyone. Yeah, I think definitely the participants we have today is mostly auditors and some people who have been around in Ethereum quite a long time, and maybe those people who have been around since 2016 when the community was tiny. They don't really feel anxious to reach out to projects because they feel like they're on the same level. And I would encourage everyone that we are not like some weirdos hidden somewhere. We are just like you. So we'd like to talk to you. Whether you start your first hackathon or whether you have deployed your DeFi project, we want feedback from all of you.
00:29:55.268 - 00:30:01.020, Speaker A: Guys that are nice closing words. Thanks so much, Alex. And.
