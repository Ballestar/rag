00:00:06.220 - 00:00:52.100, Speaker A: Good evening. Wow. Well, I suppose some of you want to sleep, so I'll try to get directly to the matter. My name is Dmitry. I'm doing engineering at Luneslabs, and today, in a couple of slides in a couple of slides, I will tell you about what is Fluence and what's the reason for it to exist. And I will just focus on why it matters on Hackathon. Then I will tell you about the Fluence DevNet.
00:00:52.100 - 00:01:53.290, Speaker A: Sorry? Well, I hope that that's the right presentation doesn't matter. Then I'll tell you about what is shipped with DevNet, and then I'll make a quick demo of what could be done with DevNet. So what is fluence? And let's skip some slides. Fluence is not a blockchain. Fluence is a network of application specific blockchains with a shared security layer. So while blockchains are usually focused on monetary transactions, on tokens, switching tokens, and so on, usually they store transaction history forever, and they have huge blockchains. Well, for Fluence, all of this is not true.
00:01:53.290 - 00:03:22.420, Speaker A: Fluence is mostly focused on generic applications, general purpose applications. With Fluence you could run, for example, high performance user applications like distributed applications backends right? Now, usually DApps has some part on the chain and a lot of things in centralized environments. Or for example, you may launch Database, Rest, API and similar things. The key idea of Fluence is a hybrid architecture. So the network is divided into layers. The Speed Layer, which consists of very small clusters combined together with tendermint and running WebAssembly, and a security layer, which keeps the running past clusters in check. To make this possible, we delegate some job on existing solution existing networks, namely Ethereum and Swarm.
00:03:22.420 - 00:04:33.420, Speaker A: Speed Layer is what could be used right now and what could help some of you maybe do something, maybe. We have just a few workers per cluster. It's good to have a cluster of four workers, or even of one. So each cluster is dedicated to handle just one application. So one application, one cluster, and the client interacts with the cluster directly. Each cluster stores all the data required for computations, for state transitions, for responding to queries locally. And due to the small size of the clusters, we need to have some means to access the data of the clusters from the outside to verify that they behave.
00:04:33.420 - 00:05:00.512, Speaker A: And to make it possible, the real time clusters store the data to the swarm. Also we have security layer. Well, actually, if you have any question about security layer, I will tell you about how it works. But for now, let's skip it. We have compaction. It's wonderful. Dispute resolution, wonderful.
00:05:00.512 - 00:05:34.000, Speaker A: We can make SQL also wonderful. It's much more secure than just hand shards, for example. And that's also wonderful. Finally, the qualities of the Fluence network are speed, security, and cost efficiency. Everything in destroyed manner. And that's made possible with two layers. For speed and cost efficiency, we use Speed Layer.
00:05:34.000 - 00:06:44.710, Speaker A: Clients do not wait for validation to be performed before clients could have the results of their transactions. We have small clusters, so their consensus is reached with just a little delay. And we also don't need to pay for many workers, which helps with the cost efficiency. And we store data locally, so there's no need to traverse back and forth through the network to fetch the data required. And we have Security Layer, which acts well as a security layer, as a delayed validation layer. So let's switch to practice. Good news is that DevNet, which is a speed layer implementation of Fluence, is already live.
00:06:44.710 - 00:07:37.480, Speaker A: And these possibilities to use Fluence are not theoretical, but practical. We have several examples of what could be done with Fluence, which you could just hit clone try and so on. For example, we have a decentralized SQL database, or we have probably fair gambling with a Dice game. I will show it later. That's how our timeline looks like, what our timeline looks like. Currently we are there. DevNet means speed layer implementation.
00:07:37.480 - 00:09:02.240, Speaker A: Then we are planning to implement Security Layer over this year to reach the testnet milestone. And while we have incentivization, it will be the main net during the DevNet period. To fix the availability issues, we offer ability to pin applications to your own nodes, so that even without incentivization, you could have decentralized available applications. Here are some important links. We have a network dashboard, I will show it in a couple of minutes. We have the Fluence book on documentation, and in case you have any questions next morning, probably you could join our discord and we'll be happy to answer them. In general, if you're curious about the DevNet and about the possibilities which Fluence could bring to you, here we have the most valuable links on a single page, fluence network links.
00:09:02.240 - 00:10:26.608, Speaker A: Let's take a look on this page and make a short demo. And to do it, I need to switch from mirroring to from standing to mirroring, so that's the links, contacts, repository, Twitter and so on. And we have several examples. We have SQL database, tic TAC toe game, guessing game based on Rust tutorial and ADAS game. So if you're curious, we could take a look and look on anyone. Any suggestions? Let's take a look on a Dice game, because that's so well, I just love playing it. It looks quite trivial.
00:10:26.608 - 00:11:16.596, Speaker A: I can set the bet guess number and then roll Dice and probably I will get rich. Usually it takes around a second or less. No, that's how it could be. So that's how it works. You could take a look on it at Dice Fluence network. And this is the most explained oh no, that's the wrong link. The most explained example.
00:11:16.596 - 00:12:31.640, Speaker A: So we have the full tutorial here how to set up Rust, how to implement the state management. That's how you could make a persistent state which is kept between the calls, just a public variable. Here we have the gateway function. To make a gateway function, the only thing you should do is to add notation to annotate the function with the invocation handler annotation. So all you need to do to enable Fluence execution of your Rust application is a couple of lines of code import SDK and set invocation handler. We have CLI tool. We have network dashboard.
00:12:31.640 - 00:13:04.970, Speaker A: Let's take a look on the Dashboard. We have a few applications deployed. Now, I suppose the dice game is application number one. Here we have the members of the cluster which holds this application. Right now they are combined with Tendermint. If you're familiar with the Tendermint familiar with Tendermint. Wow.
00:13:04.970 - 00:13:44.800, Speaker A: This information is enough for Dana's Block. We have DNA's time and these are public keys of Tendermint. This information is stored in Ethereum and we could check the cluster. This is the height of tendermint chain. So we played a lot. The dice game the same for Nodes. Nodes has capacity.
00:13:44.800 - 00:14:19.520, Speaker A: It's the number of applications which could run. Currently we just assign the same capabilities, the same amount of CPU and memory for each application. But in future we are planning to make more fine grained control of the resources. Node could be private. Private node is the one which serves the developer privately. So it launches only applications of this developer. That's for availability.
00:14:19.520 - 00:14:58.270, Speaker A: Just like pinning in IPFS. So that's all I could show. In 15 minutes. We could take a look on a SQL database. For example, just for fun and for being curious, we took Lamidb. Have you heard about Lamidb in your life? Lamidb is a very simple implementation of full feature SQL database in Rust. We haven't coded it, we took it.
00:14:58.270 - 00:15:26.100, Speaker A: Edit those two lines and it works. It's deployed. So let's play tic TAC toe game. Oh, I need to log in. I'm not sure Russian letters will work. They should, but I'm not sure. Could play with a machine.
00:15:26.100 - 00:16:17.030, Speaker A: It's not very clever. I win. For each of these examples we have a tutorial. And each tutorial ends with what? Not for tic TAC toe. For each of the dice game tutorials, we have open problems in the bottom. For example, you could implement the leaderboard for all the players of the dice game to find out the best one, the most skillful in playing the dice. So that's all for now.
00:16:17.030 - 00:17:04.420, Speaker A: In case you have any questions about theory or practice, please let me know. When are we going to go to sleep? The most practical question. So thank you for being alive after 01:00 A.m.. See you tomorrow. Please give Fluency a chance by visiting our website when your mind is fresh. Thank you.
