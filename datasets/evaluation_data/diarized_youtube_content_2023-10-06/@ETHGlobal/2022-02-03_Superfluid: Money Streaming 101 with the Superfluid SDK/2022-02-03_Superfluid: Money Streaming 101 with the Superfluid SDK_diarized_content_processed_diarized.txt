00:00:14.940 - 00:00:17.968, Speaker A: You. Great.
00:00:18.054 - 00:00:32.690, Speaker B: So welcome to the workshop on money streaming 101 with superfluid SDK. So we have Sam here, who will be leading the workshop. He'll take questions at the end, towards the end of the session. And Sam, I'll let you take the lead.
00:00:34.020 - 00:01:06.370, Speaker A: All right, thank you so much, guys. It's great to be here. And obviously it's always fun for me to talk to you Superfluid and see lots of people joining these workshops. So what we'll do today is I'll go through a quick presentation on what Superfluid is, kind of from a high level perspective, how it works. I'll go through a couple of very practical examples in our docs which use our SDK, and then at the end, we'll open up some time for questions. So feel free to leave questions in the chat, and we will get to as many of them as we possibly can at the end. So let me pull up our presentation here and share my screen.
00:01:06.370 - 00:02:08.844, Speaker A: All right, my assumption is that you guys can see my screen. Feel free to jump in and let me know if you can't. Okay, so what we're going to do is we're going to talk through what Superfluid is at first, and then we'll get into some of those practical examples. Like I said, so Superfluid is a protocol for digital native programmable cash flows. So you can stream money without having to lock up capital and then do really interesting things with programmability around those cash flows. The first thing that we like to kind of talk about every time we bring up Superfluid in an environment like this is that one of the premises we have for what blockchains are and why they're important is that we make the analogy to the Internet being something to information that blockchain is to value. Right? And in the case of Superfluid, we notice that services in real life flow in real time from provider to client.
00:02:08.844 - 00:03:02.308, Speaker A: If I'm working for you on an hourly basis, I'm providing that service in real time. And we believe that payments should work in the same way. So this kind of leads us into money streaming. So continuous payments are frictionless, open ended connections between two accounts. So if I want to send you money for providing services so in the case of, let's say I wanted to pay you in a stream for a subscription or to be an employee in my company instead of having to pay you every two weeks in these lump sum discrete transactions. We allow you to pay for services in real time, on a second by second basis. So what happens is we take that lump sum amount, divide it up amongst the number of seconds between now and let's say, the end of the month, and you receive a little bit on a second by second basis, so the money is flowing in real time.
00:03:02.308 - 00:03:54.230, Speaker A: And we think that this allows there to be this interesting direct link between the time you're providing the service and the money you're receiving in exchange. And the cool thing about this is that it's all on chain. And we can use these on chain agreements to do other really interesting things. There's no unpayment risk. Fran, who's our CEO, who does some of these presentations sometimes, often talks about when he did consulting in previous roles, he'd go three, four, five months without getting paid, sometimes. With Superfluid, when you put the agreement on chain, you have way less unpayment risk, right? So in terms of the overall protocol itself, like I said, these are on chain open ended agreements. And the way kind of behind the scenes that we're achieving this is we're calculating the balance of each user every single second.
00:03:54.230 - 00:04:41.412, Speaker A: So from a high level point of view, I'll get into the architecture a bit more with a few interesting aspects of the protocol. One of them is Super Tokens, the other is super agreements. And then the thing that kind of holds it all together as like the brain of the protocol is the Superfluid Host contract, which does a lot of other interesting things for us. Again, I mentioned a bit earlier that these aren't only just on chain agreements for money streaming, they are also programmable. So you can do things like create super apps, which you can send money into, and then upon receiving that money, you can then redirect these funds into interesting places and do really cool things with them. So we have lots of super app examples in our docs and in our repo. You're welcome to take a look at those and understand how to use them.
00:04:41.412 - 00:05:33.904, Speaker A: But today I'll briefly go through one aspect of super apps and then just get into the SDK stuff. So on this hackathon, right, we have $4,000 in Bounties 2000 for the best overall project, both on Superfluid 1000 for the best financial innovation, using Superfluid 1000 for the most futuristic project, which when we put that prize out, we usually get something very interesting. So I'm excited to see what's submitted for that one. And just to be eligible, you have to use Superfluid in some way. You have to either create a super app or just use our SDK and just interact with our code base in some fashion. So, getting into interacting with the protocol, we'll talk through some high level architecture bits and then we'll get into the SDK. So, I mentioned that there are three things on the back end that are important to understand when working with Superfluid.
00:05:33.904 - 00:05:55.224, Speaker A: One of them is the Superfluid host contract, which acts as the brain. Its interface is isuperfluid soul. If you're interested, you can check it out in our repo. The second thing are agreements. So we have two main agreements right now. One of them is the constant flow agreement and the other is the instant distribution agreement. I won't dive too deeply into the instant distribution agreement.
00:05:55.224 - 00:07:05.136, Speaker A: Today, but it's worth checking out because it allows you to distribute funds on a one off basis to lots of users without having to pay an incremental gas costs for each new user you're going to send funds to. But today we're going to specifically discuss the constant flow agreement because that's what facilitates all of the money streaming that you're probably familiar with. And then finally, the third kind of type of contract you'll be interacting with are super token contracts. So things like Dix, which is super token, dai Ethx, which is a super token version of ETH native super tokens as well. We might talk through a bit, but that's the third thing to keep in mind, right? Super token contracts, you can see all of this stuff visually if you go to the Superfluid dashboard, you can go there at App Superfluid Finance and play around with your own money streams using no code at all, if you'd like. We'll also use it to walk through some of the SDK things in just a second. If you're looking for more information, like on the developer side, you can also use the Superfluid Developer console and you can get much more in depth developer information here.
00:07:05.136 - 00:07:45.340, Speaker A: You can write custom subgraph queries, you can see a lot of the stream data, and you can even save addresses in an address book and manage them that way as well. So again, we have a couple of developer resources you're welcome to check out here. The first is app superfluid finance for the no code version. And then you can check out the Superfluid console at I believe it's console Superfluid Finance here. And if I'm wrong there, either Fran or Yahoo is on the call, can clarify in the chat. Okay, so getting deeper, lower level, right? We started very high level. We're progressively getting deeper and deeper.
00:07:45.340 - 00:08:37.276, Speaker A: One thing to keep in mind is that in order to use superfluid, you need to have some balance of super tokens in your wallet. So super tokens are basically an extension onto the ERC Seven Seven standard. We have much more functionality than ERC Seven Seven S. But one thing to keep in mind there is that we inherit a lot of the basic ERC 20 stuff. So sending tokens via transfer, all of these things, you can do them all with super tokens. And one big key cornerstone of DFI more broadly is interoperability, right? So we want to make sure that existing tokens that have been just deployed as ERC 20s can also be used in superfluid. So we've deployed a kind of wrapper contract which will allow you to wrap existing ERC 20 assets as super tokens using what we call the upgrade function.
00:08:37.276 - 00:09:27.132, Speaker A: And you can then unwrap them using a downgrade function. So you can very simply call Upgrade, which will then mint you super tokens in a one to one corresponds with how many tokens you like to wrap. So if you call upgrade with five die, you can get five super token die minted to you in return. And then if you want to ever just redeem that super token die for the underlying asset, you can very easily hit downgrade, burn those super tokens and get your underlying ERC 20s back out of that contract when it comes to interacting with the agreements themselves. Right. To create a money stream, this is kind of the flow that's happening in Solidity. So you need to like at the most bare bones level in Solidity, you need to pass arguments to a function on the superfluid sole contract to open a flow.
00:09:27.132 - 00:10:15.592, Speaker A: And what you'd pass into that call agreement function is the address of the agreement you're going to interact with and then also an encoded transaction object which specifies what you want to do with your money stream, for example. Right? So if you wanted to pass in some kind of create flow operation here, you could do that and then the protocol will open up your stream from you into whoever you defined the receiver to be. So, again, very low level. We're not going to need to go that low level in our example. But I just wanted to mention it and then to kind of round out some of the lower level things here, the final thing to mention is super apps. One more time, I mentioned that the cool thing about super apps is programmability. The thing that enables a lot of the programmability within super apps are these things called super app callbacks.
00:10:15.592 - 00:11:03.500, Speaker A: Again, I will refer you to our docs look for the super apps section of our docs. You'll get much more information on this. But the key thing to note is that if I send funds into a super app, there are effectively listeners that you can define on the super app which can do things upon receiving those funds and you can do a lot of very interesting and just overall cool things with them. So it's worth checking out. Okay, so that's an overview of the protocol, some of the lower level bits. Let's go into our docs and walk through a couple of examples using our SDK, which will allow you to open up money streams in just a few lines of code. So we will shut down this presentation for now and head over to our docs.
00:11:03.500 - 00:11:24.644, Speaker A: All right, I'll take a brief look at the chat here. Looks like we got some questions coming in, which is great. Yao, thank you for answering questions. That's amazing. We'll come back to those in just a bit. But here I am in our docs. Let me zoom in because that's one of the most common requests I get here when showing things like this is to zoom in.
00:11:24.644 - 00:12:10.884, Speaker A: So if you go to our docs, you can reach them at docs superfluid finance we have this interactive tutorial section which is really helpful for getting started with the protocol. Even if you're just a beginner or coming from a JavaScript or even TypeScript background if you're a little more advanced. On the front end we have a few sections, the first of which is going to help you initialize the SDK. So just basic setup things depending on what environment you're looking to use, whether you want to use something in a node module or something on the front end. We have information for you here that will help you set this up. But for the sake of brevity, I'll just go into this money streaming section here. So we walk through that kind of advanced workflow in solidity of how you'd open a stream that way.
00:12:10.884 - 00:13:01.444, Speaker A: This makes it much simpler, right? So we have this code sandbox here that I'll open up. Let me move zoom around just a bit here. So we have this Create flow JS component which is rendered here over to the side. What I have here is an extremely simple react app with an unlocked address that has a lot of tests and fake super tokens set as the signer. And then I have the framework initialized and I'm running operations here. So let's walk through this kind of step by step. If I want to create a very simple flow using our SDK, the first thing I need to do is, well, one, I need to download the SDK from NPM, right? You can find it on NPM just by searching Superfluid Finance and SDK Core will pop up.
00:13:01.444 - 00:13:29.608, Speaker A: You're looking for SDK Core, which you can see right here. Let me zoom in a bit more. All right, close this as well. I'm using some react bootstrap things just for formatting and you'll also need Ethers, which is going to be important. So I have a function up here which is going to execute and create our flow for us. And this is happening. And basically because I'm using an unlocked account, we're doing this in kind of the way you'd use this on kind of like a back end or node module.
00:13:29.608 - 00:14:14.780, Speaker A: But you could use a MetaMask or wallet provider instead if you want to. So in this example, what I'm doing is I am initializing the framework here using this framework create pattern. I'm defining the network name and then I'm passing in the provider, which is just a provider that I've created with Ethers using an RPC URL I got from Alchemy. And then I initialize the signer here. So we have the signer and I initialize the signer by calling SF Create Signer. In this case I am passing in a private key and then also the provider quick disclaimer don't do this in your own applications where you just paste the private key in here. At the very least, have it as an environment variable, obviously, so you don't push it to GitHub accidentally.
00:14:14.780 - 00:15:19.104, Speaker A: So that's worth mentioning here I'm defining the address of the Dix token which we'll be using with Dix is just super token die. And then here I have a little try catch pattern that's going to allow me to create a flow. So here what we're doing is we're creating this create flow operation variable and calling SF CFAV one createflow we're passing in the flow rate, which is just the amount of tokens per second I want to send. We're passing in the address of the recipient and then we're passing in the dix token address. And then to actually send this transaction and broadcast it to the network, you can call createflowoperation, exec and pass in the signer that we defined up here. So we don't actually have to put the sender here. You might see some examples where there is a sender defined with a sender address that's not 100% necessary because the sender is going to be implicit in this signer here, right.
00:15:19.104 - 00:15:59.436, Speaker A: We know because we already have the private key who's the message sender on this call. And because we know that the protocol knows that you're opening up a stream from that address to the recipient here. So let's put this together. So if I enter in an ethereum address, let me grab one here from my MetaMask. All right, copy that. And if I enter in a flow rate in way per second, we can see here actually we'll calculate the amount per month for you based on what you're sending per second. In this case, I'm going to send 25 die per month.
00:15:59.436 - 00:16:33.112, Speaker A: If I send this much per second, open up the console and I'll click to create the stream. All right, so our stream was created for this example. I also console log some of the things up here. But we can go in and view our stream in the superfluid dashboard. So if I do that, we can see here I have the dashboard and we can see right here. If I zoom in a bit more, a flow was just open to this address. So we can see this here.
00:16:33.112 - 00:16:59.970, Speaker A: This was just created. We have some information about the stream, which is awesome, great. So now what I can do is I can also go back and I can update this flow and delete it. So I can actually just do this directly from the docs if I want to. So in this case, let's call update Flow directly here and we'll pass in a new flow rate. So let's change this up a little bit. You got to enter a number there.
00:16:59.970 - 00:17:31.080, Speaker A: If you try not to enter a number, you'll get an error like me. All right, let's change this up. Now we're going to lower the flow rate so that we're sending only $5 per month. Okay, I'm going to click to update. All right, fantastic. Our stream was updated here. If I open up this sandbox now, we'll take a look at how things differ with the update flow.
00:17:31.080 - 00:18:22.068, Speaker A: And basically it looks exactly the same, right? Except all you have to do is you have to make sure that this flow already exists and that the flow rate you pass in here is different. If you don't do that, you'll receive an error. And if I go back into the superfluid dashboard, zoom gets out of my way. You'll see here that this was now changed. If I refresh, we'll come back to that in just a second. We'll go back and we'll see the flow has changed, and then we'll delete it from here. But to delete a flow, again, the pattern is the same where I'm creating this delete flow operation first, and then I'm broadcasting it to the network, except in the case of deleting a flow, I will pass in the sender address, and I'll pass in the recipient, and then just the Super Token.
00:18:22.068 - 00:18:53.110, Speaker A: I don't need a flow rate if I'm deleting, because there's no flow rate needed, right? So if we go back here, we can see that our flow rate was changed. It's now $5 per month. So we did that effectively. So finally, in this section, what I will do is delete our stream. So let me paste in our address. All right, so our stream was deleted. There we go.
00:18:53.110 - 00:19:39.008, Speaker A: Okay, so now what you just saw there is how to create, update, and delete streams, right? That's enough to build out simple subscription applications or interacts with superfluid directly inside of your application. Again, if you'd like to do this in a way that includes maybe, like, a MetaMask wallet, we have examples of how to initialize that in our MPM page here in the README. And if you have any specific questions on that, feel free to reach out to me directly. I can give you example code that will help you get started with that too. But what I'd encourage you to do, if you're curious about how this works, is to come to our docs, play around with this. Also play around with the Using Super Token section if you'd like. Play around with batching transactions, which is also a super cool feature we didn't have time to discuss.
00:19:39.008 - 00:20:11.070, Speaker A: And then if you'd like to, you can also check out the Instant Distribution Section, which will make use of that Instant Distribution agreement we didn't have time to talk through. And, yeah, there's plenty here for you guys to dive into. We're at kind of like a hard time limit here, so I don't have time to go through it all. So I'll pause there. We can go through some questions and yeah, take it from there. I hope that was helpful. All right, so it looks like we have some questions.
00:20:11.070 - 00:21:02.780, Speaker A: Okay. Is there any demo about how to see stats on your stream like you have in your dash? How can I show them moving in my app? Great question. So we have some examples. Let me reshare just so I'm not just clicking around so you guys can't see it. We have this getting data section, which will make it easy to use the SDK to get to run queries, basically, with the superfluid subgraph, and then also just use the agreements to get information as well. So you can run something like SF, CFAV, One, Git Flow to get information about a particular user's streams. But we do have like I know you mentioned it sounds like you're interested in this constantly moving section.
00:21:02.780 - 00:21:38.200, Speaker A: We have an example inside of our repo. If you look inside of the let's go to our repo here. If you look inside of this example in our example section. So if you go to the protocol monorepo examples, SDK, redux react TypeScript, we have an example here that uses our little more advanced SDK I didn't go through today. Where you can create a flowing balance. So I'm just going to paste this in here because this might be helpful for you. There you go.
00:21:38.200 - 00:22:08.044, Speaker A: Yeah. Thank you. Yeah, absolutely. Notice you're using COVID. Does all of the behavior you demoed also exist on Mumbai? Yep, it's completely chain agnostic. You just need to change the RPC URL you're using if you want to use the SDK in the same exact way I did. So, for example, inside of Config JS here, you'll see in the sandbox, I have a specific link from Alchemy that know specific to COVID.
00:22:08.044 - 00:22:54.976, Speaker A: You could change this to a Mumbai RPC URL if you want, and then just change the name to Mumbai here when you initialize the framework. So, yep, chain agnostic completely. Okay. With this API, is it possible to connect a smart contract to an NFT that would be sold multiple times and iteratively built upon, but could open up a royalty stream that pays each contributor? Yes, I would say you probably would need to use what we call a super app for this. Let me send you an example as well that might be really helpful, actually. I'll go to our docs for this one. Inside of our docs, go to this super app remix example, and you'll probably get some inspiration here.
00:22:54.976 - 00:23:37.728, Speaker A: What this does is you can see here on the screen, it will take in incoming streams, run logic, and then send outgoing streams. You could probably have some kind of accounting inside the contract that checks how often it's been. Maybe I think you could do this. I think you could check how often it's been transferred and enable the app to send streams to multiple different users inside of these callbacks here. So, again, I would check out that remix example. I think that might help. All right, any other questions that I didn't have time to get to here? Looks like Yao was able to answer a few.
00:23:37.728 - 00:24:23.212, Speaker A: Can an address only open one stream to another? You're like, let's say I want to open up an address or open up a stream to Yao. I can't open up multiple streams to Yao with the same token. Right. I would need to update the flow rate to do that instead. Obviously, there are certain situations where you might want to, for administrative purposes, have multiple different flows going from one account to another, maybe within an app or something like that. What I would suggest doing is having some kind of architecture that just has accounting that calculates how much money in total should be sent from one address to another. And I think that can solve your problem.
00:24:23.212 - 00:25:24.850, Speaker A: If you have any specific use cases you're trying to send multiple flows from one user to another for, let me know and I can send you some examples because I've thought about this a few times as well. I should be able to help. Would the data field distinguish the separation for such? I am not 100% sure what you mean by that, but there is a field that you probably can see, and we're kind of running low on time, so this might have to be our last question. But there is a field here that I commented out called user data that I didn't have time to talk to. User Data allows you to pass in any arbitrary data that can be used within a super app callback, right? So let's say I want to pass in a user data field to an incoming stream that I'm sending to a super app. You can decode whatever that is and have access to that in the super app. So there's a really good example we have in our docs as well.
00:25:24.850 - 00:26:05.070, Speaker A: Inside of this section, I'll paste this in here about an NFT billboard where let me scroll all the way down and let me copy this link where here what you do is you create a stream into a billboard NFT, and you pass in a message as User Data. And whatever the most recent message is passed in here will be displayed on the NFT billboard as a message. So you're encoding a string, and that string is then visible on the NFT itself. It's honestly pretty cool. I think it unlocks a lot of use cases, and it's pretty underutilized. So if you have an interesting use case with user data, I would love to see it. I'll paste this in here.
00:26:05.070 - 00:26:45.240, Speaker A: All right, I'm going to take one more question before we have to wrap. Do you have a demo using MetaMask login to accept incoming subscription streams? Actually, yes. I just worked on one specifically this morning. That's a code sandbox that I can send you. I tell you what, Louise Xavier Padilla, if you reach out to me on Discord Sam F Superfluid, I will send you that directly because I'm also going to put that in our docs likely later today or tomorrow as well. So you guys have that there. But hit me up on Discord and I'll send you that directly.
00:26:45.240 - 00:26:53.530, Speaker A: It's just a little bit of a work in progress, that's all. Okay, I'll pause there.
00:26:58.180 - 00:27:13.090, Speaker B: That was a great workshop and we're just a bit overtime so we can follow up over the discord channel and hopefully we'll see everybody at the opening ceremony that's coming up and yeah, thanks again.
00:27:13.620 - 00:27:17.950, Speaker A: Yeah, I'm excited. Thanks so much for having me. I appreciate it. Thank you all for joining. This is a lot of fun.
