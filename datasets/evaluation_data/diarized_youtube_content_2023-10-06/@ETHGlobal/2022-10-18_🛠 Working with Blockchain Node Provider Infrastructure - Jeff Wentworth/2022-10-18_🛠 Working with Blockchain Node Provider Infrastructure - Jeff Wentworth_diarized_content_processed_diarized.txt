00:00:06.250 - 00:00:24.350, Speaker A: Good morning. Buenos. Yes. My name is Jeff and welcome to working with Blockchain node provider Infrastructure. I'm one of the ETHGlobal mentors. I'm also a co founder at a company called Curvegrid. We're a blockchain infrastructure company based in Tokyo, Japan.
00:00:24.350 - 00:01:24.018, Speaker A: So this session is a little bit different in the sense that a lot of the things that I'm going to talk about today are less applicable to a hackathon and a little bit more applicable to after the hackathon building your taking your DAP that you've hacked together over the weekend and turning it into a production decentralized application. So that's just something to keep in mind this weekend. This hackathon do whatever it takes to get things done, to get things working. But I think this is sort of after the hackathon, after the weekend, what are some of the things you can do to build a production DAP? So we're going to go through sort of three different sections today. The first is a quick overview and reminder refresher on how DApps interact with the blockchain. We're going to talk about the blockchain as a distributed system and these two parts are very important to think about. The third part, which is how we actually work with blockchain node provider infrastructure.
00:01:24.018 - 00:02:01.742, Speaker A: Everything I'm going to talk about today is also 100% applicable in the case where you run your own nodes. But there's some extra things to think about if you're going to use a node provider. What is a node provider? Node Provider is a company like Quicknode or organization like Pocket Network infra Alchemy that runs blockchain nodes on your behalf and that you use as a service. So blockchain 101, I think everybody knows exactly what is going on. In this diagram you have a DAP with a front end, a back end. There may also be other components like a database. It may talk to a third party API, and of course it's talking to the blockchain, a blockchain node.
00:02:01.742 - 00:02:38.554, Speaker A: This is the part that we want to focus on today, right? The blockchain node interaction. I'm going to go fairly quickly through this part because I think a lot of this is refresher. But again, I want to set the stage for the kind of the meat of what we're going to talk about today. So how does a typical DAP interact with the blockchain? Well, it can call smart contract functions to read data. It can query and listen to events. And those are two distinct things, right? Querying events is reading past events from the blockchain and listening to events is listening to present and future events from the blockchain. We can do other things that don't involve smart contracts like reading ETH balances.
00:02:38.554 - 00:03:32.110, Speaker A: And then we can write to the blockchain by calling a smart contract function to compose a transaction, signing it and submitting it to the blockchain. So these are different typical DAP interactions with the blockchain. You would use these interactions or you would compose these together to build DApps that would do any number of things. Here's a few examples of things that DApps typically do. Display a dashboard of token balances of a particular user. Display those token balances sorted by balance. So taking all of the token balances, whether it's ten or 100 or a million, and sorting them by balance, displaying all the NFTs that are owned by an address, and other kinds of essentially blockchain state aggregations, right? So the first three of these really fall into the category of I'm reading some data from the blockchain, I'm processing it and I'm doing something with it, I'm displaying it to the user or using it to make decisions, et cetera.
00:03:32.110 - 00:04:38.882, Speaker A: Still setting the stage here some common smart contract interfaces and I just want you to keep these in mind when we talk about some of the things later in the talk. So I think we're probably all familiar with the ERC 20 balance of function. Provide an address, get back a balance. Another one that many of you are probably familiar with is the ERC 721 enumerable function which allows us to basically provide an address and an index of the NFTs that that address owns. Retrieve a token ID. And this is in a case you would use something like this ERC 721 enumerable or any kind of enumerable smart contract capability. When you want to basically ask the smart contract what are all the things that you know about? I want to go through them basically in a loop from off chain and then ERC 721 transfer event, right? And events of course are emitted by smart contract functions and you listen to them off chain and process them and they're intended to be used by smart contract developers to indicate estate change on the blockchain to make it very efficient to build scalable DApps.
00:04:38.882 - 00:05:36.518, Speaker A: So again, just keeping these in mind for the rest of the talk. So some strategies for reading data from the blockchain. Right? Again, keeping in mind what we've just talked about. You can call a smart contract function, you can call a balance of or you can call one of the enumerable functions. But then the question becomes how often do you call it? Do you call it every certain number of minutes and cache the results? Do you call it every block? Are you doing this per address? If you're building in a hackathon it's fine because maybe you've got one or two or three addresses. But what happens when you need to start enumerating through the balances of NFTs in a loop for 100,000 addresses? Is that the kind of thing that you can do every single block or not? Well, it turns out a much more efficient way to do that of course is to process, is to listen to events, process them and cache them off chain. And this is of course something you can either build in house or use open source or use what we would call a third party chain indexer service.
00:05:36.518 - 00:06:31.722, Speaker A: This would be something like the Graph or our own multibas event monitor capabilities. Or you can also use a third party higher level API. So something like an NFT Marketplace API that will just give you all of the NFTs that a particular address owned or owned at a particular point in time, or all of the DeFi prices and balances. The key difference between these three is the first two are essentially much more decentralized and you have complete control over the data that you're getting, how you're processing it, the certainty or quality of that data. Right. If you're reading it directly from a blockchain node or from a node provider you're calling a smart contract function or processing events. If you're using a third party higher level API, the trade off is much easier to implement, right.
00:06:31.722 - 00:07:18.726, Speaker A: Because they've done much more of the hard work for you, probably cheaper. But you're giving up some of that control and knowledge over, let's say, the quality of the data. And I'm not advocating for you should do this or you should do that. These are all things to be aware of, right? These are the trade offs that we make in software engineering when we're building applications. Okay? So we've talked about DApps, we talked about reading data and if there's anything to take away from the first part of the talk, it's that there's different ways to read data. And the way that you read and process the data depends a lot on the size of your application. Right? Another thing that when you're architecting, adapt, and thinking about working with blockchain nodes is the blockchain itself, right? So we're going back to blockchain 101.
00:07:18.726 - 00:07:45.486, Speaker A: This is a blockchain. It's a decentralized ledger. It consists of nodes communicating in a peer to peer fashion over the Internet. And every node, of course, keeps a copy of the ledger. I think this is pretty familiar to everyone here. The key thing to think about with this is that a blockchain is essentially a type of distributed system. In classic distributed system theory or practice, we have the Cap theorem.
00:07:45.486 - 00:08:42.846, Speaker A: Consistency, availability, partition tolerance. You can only have two of three of them, ethereum and most EVM chains optimize for availability, right? You're always going to be able to get data from a node that you're talking to. And partition tolerance, they're able to survive the blockchain partitioning in different ways, right? There's a network break. I mean, there's an earthquake and an undersea cable gets cut and Asia is separated from North America or there's some kind of network congestion or an attack or a bug. In node software, the compromise that they make is on the consistency. And the key thing here is eventual consistency, right? And when we're building a DAP, when we're thinking about how we interact with blockchain nodes or node providers, we've always got to be thinking it's eventually consistent, it's eventually consistent. Right? And that drives a lot of the complexities around the systems that you build in a production.
00:08:42.846 - 00:10:50.922, Speaker A: DAP, there's so much to talk about here, but we're talking about ultimately node provider working with blockchain node provider infrastructure and not different ways that nodes resynchronize. So I'm just going to keep this very simple and say the nodes can get out of sync and I've written here, not just nodes but also the network, right? And so what you have to start thinking about is I might be talking to a blockchain node, but actually I have to think about all of the components in the system as being a distributed system, right? And again, in hackathon it's very, very simple. You have your Python script or TypeScript or JavaScript or Go or C or Java that's talking to a blockchain node, doing a single blockchain node potentially, or a test network that's doing very low volume of transactions. But as you start to add more components into the system, the entire system itself really becomes a distributed system and you have to start thinking about, wait a minute, there's these eventually consistent portions throughout the entire system, right? Not going to go into full Distributed Systems 101, but it's just something to keep in mind that again, this isn't just blockchain nodes, this is the entire system that we're thinking about. And so the key thing here is how does a client that's connected to one or maybe multiple of these nodes handle conditions like this? And when I say multiple nodes, again, I don't just mean multiple blockchain nodes, it might be different parts of the infrastructure, right? My client might be connected to a blockchain node here, but then sourcing some data from a pricing API or other data from an NFT API. Do all three of those have the exact same view of the world at the same point in time? And the obvious answer is no they don't. So how do we start to think about that? So the big question should you run your own blockchain nodes? And this is not controversial at all, this is just Jeff's opinion, but it sometimes kind of becomes the elephant in the room.
00:10:50.922 - 00:11:36.650, Speaker A: My overriding long term view is yes, we should all run our own blockchain nodes, no question. But we're not quite there yet, right? What I want to do is try and enumerate some of the reasons to think about running your own nodes versus outsourcing this to a node provider. And again, I don't work for a node provider, but we do make heavy use of them. So we have a lot of experience with both running our own nodes and using blockchain node providers. Good reasons that you may want to run your own blockchain nodes are for education hackathons. You're learning for development and testing, right? You're doing a lot of iterative potentially destructive R and D activities and testing activities. You may need access to the internals of a blockchain node.
00:11:36.650 - 00:12:48.078, Speaker A: For example, you may want to enumerate what some people term internal transactions, which is state changes that aren't exposed through the standard RPC API like ETH balance changes or contracts being created within other contracts. Or you may have other very specific performance requirements, right? I think in a production DAP, or sorry, not production DAP in general, these would be great reasons to run a blockchain node, a reason to use a node provider. The first one, I think, is cost, right? Anybody here who has run blockchain nodes in the past understands or currently understands that if you're doing it in production, we're talking highly available. You're running a DAP that's being used by in anger, let's say, or at a good scale by a large number of people. It costs a lot of money, right? Because you can't just run start blockchain node and you're done. I mean, we're talking you have to think about what happens if the node fails, what happens if the server goes down, what happens if there's a problem on the network. Right now you're running real production infrastructure and there's a cost behind that, not only the actual, let's say, server and software cost, but engineering time and effort.
00:12:48.078 - 00:13:55.954, Speaker A: And as with many things in this world, it's often easier to let somebody else do this. I think a good analogy for this that we can all keep in mind is it's no different than making the decision between running your own server, whether it's a Raspberry pi on your desk or a server in a data center or a VPs Virtual private server through a service like DigitalOcean or Vulture, or you use a cloud provider, right? Microsoft Azure, Google Compute Platform, or AWS. And there's no right answer, right? It's going to depend on your use case and what makes sense to you. But I would argue that for most production DApps, the answer today is node provider, right? So we've talked a lot until this point about some of the ways that we think about reading from blockchain nodes, interacting with blockchain nodes. Now we're going to talk about not just how we think about interacting with and architecting a DAP to work not just with blockchain nodes, but the particulars of node infrastructure as well. Node provider infrastructure as well. So speculative node provider.
00:13:55.954 - 00:14:57.862, Speaker A: This is just a block diagram and how it might look if Jeff, who is not a node provider, was thinking about building it. This is what you think that you may be talking to, because this is what, when I'm developing on my laptop, it's spin up a local ethereum dev client and I'm connecting to it. Most DApps, many DApps I should say, will be using one or two kinds of clients, right? Https for doing smart contract function calls potentially, and then WebSockets for listening to events. And that's critical, right? Many DApps need to have both of these capabilities. But what you're actually talking to when you're working with a blockchain node provider looks something like this. And you can Google, I mean, there's lots of talks on the internet by various node providers and some of them throw up diagrams that look very similar to this. If we start at the bottom, of course it's not just one node, right? They're running multiple nodes again for redundancy.
00:14:57.862 - 00:16:07.490, Speaker A: On top of that, there's some kind of load balancer that's taking block updates, taking event updates from the nodes and essentially arranging them, right? Am I getting this node is having a problem and it's 100 blocks behind. Let's drop that and we'll take the data from the other nodes. That's what, let's say the load balancer, the node load balancer would be doing. On top of that, I probably at some point want some kind of distributed cache, right? The reason when you do certain kind of JSON RPC calls to a node provider that the responses come back faster even than your local node is that they're not going all the way down to the node. They're saying, oh, you want blocks zero to 10,000 from three years ago? Well great, I'll just serve that from my cache and there's some kind of local cache. And then they've probably got some kind of large scale distributed cache off to the side as well. Then on top of that, they're going to have multiple HTPs and WebSocket servers, again with a load balancer in front of that and all sorts of antidos protection to actually talk to you, the DAP at the top.
00:16:07.490 - 00:16:48.330, Speaker A: So when we talk about the cost of running your own node in production, in a generalized sense, these are some of the infrastructure that you invariably end up having to build and operate, that you end up being able to offload to a node provider. That can be very helpful. It's great. Everything is sunny and wonderful, rainbows and unicorns. I've got my DAP, it's got a high performance node provider. I don't have to worry about running nodes. But what do we have here? We have a bigger, more complex distributed system, right? And the key point here is that any one of these components can fail.
00:16:48.330 - 00:17:58.302, Speaker A: And you may be the one to notice the failure, you may be the one to notice the issue, or you may be the one to notice the bottleneck. Maybe I want to query not 10,000 logs, but 10,001 logs and I get an error back, which I didn't get from a different node provider, which allows me to query up to 28,000 logs. Or I have multiple WebSocket connections for my DAP, let's say four, and one of them is misbehaving. Well, maybe there's an issue on a particular WebSocket server, right. And so these are some of the things when you're starting to architect or build adapt at scale that you have to start thinking about. Yeah, I've talked about some of these, but just to kind of enumerate them, right, using a node provider doesn't get us away from node issues, right? If a blockchain or a blockchain has issues at the core level or is taken offline for a period of hours, there's going to be node issues. We can mitigate some of that because we're offloading the upgrade and management of those nodes to the node provider, but at some point we could certainly be exposed to that.
00:17:58.302 - 00:18:46.914, Speaker A: There can be load balancer issues, I mentioned that again. You think you're connected some of your WebSocket connections or some of your HTP requests are fine, but others fail cache coherency. I'm getting back data that does not match what maybe I'm seeing on a block explorer like Etherscan or polygon scan. The data here is not the same as the data there. And what do I do about that? There could be an issue with the overall node provider. There's many node providers, just like there's many cloud providers. There could be an issue with a particular one that's, let's say a concentration risk if I only work with one node provider and then I have to deal with all the fun things around the blockchain, right? reorgs, blockchain reorganizations, blockchain forks, and I have to be thinking about that.
00:18:46.914 - 00:19:34.274, Speaker A: These issues are no different than if I was running my own blockchain nodes. And then of course, DAP issues. Like there's something broken in my DAP and is it my DAP or is it somewhere in the infrastructure as well? So for all of the benefits that we get from performance, increased performance, not having to worry about upgrades, et cetera, et cetera, there are other things that at some point we're going to have to deal with, right? I would love to give you all the answers and you should use this pattern and do this and do that. But I think probably what you're figuring out is this talk is more about getting you thinking and posing questions rather than handing you the answers. Because like many things in software engineering, it's the journey, not the destination. And that's how it's always going to be. And that's a good thing.
00:19:34.274 - 00:20:11.978, Speaker A: That's interesting and exciting. So just adding some questions to this. So thinking about all of this together, right? And what does this really mean? The first question is how much downtime can you survive? And anybody here who's worked in big It for big corporate companies, the answer is always zero. I can afford zero downtime. But that's not realistic, right? Everything goes down sooner or later. The question is how much you can survive. In classic sort of, let's say business continuity theory or thinking, you've got two considerations, right? One is recovery time objective and the other one is recovery point objective.
00:20:11.978 - 00:21:10.610, Speaker A: Recovery time objective really means how long does it take to get yourself back online, either through failing over to alternative infrastructure. In this case, if you're running your own node, it would be spinning up another node docker run docker and getting that working and switching everything over. If it's a node provider, it's switching over to the other one. If you've got an account or madly creating an account and putting your credit card in or whatever and switching everything over, that's recovery time objective, how fast can you be back online? And the second one is Recovery point objective. How much data can you afford to lose? Right? The blockchain is eventually consistent and very strongly eventually consistent. And it's proven that over the last seven years with the ethereum blockchain and longer than that for some other blockchains as well. But what happens when you're doing things like storing data that's coming from the blockchain in your own database, right? And that gets out of sync.
00:21:10.610 - 00:21:56.206, Speaker A: Somebody put some data in to mint an NFT and some of that's gone into your database and some of it's gone onto the blockchain because you're doing some kind of semi decentralized activity. Or maybe it made it onto the blockchain, but not into IPFS, right? There's data loss there. How much can you survive? And that would be recovery point objective. And again, there's no answers here. It's questions. It's going to be different for each production DAP how much data loss can you afford? And yeah, this relates again to recovery point objective, actually. How much data can you afford to lose? How much redundancy do you need? Again, I need one server on every continent.
00:21:56.206 - 00:22:58.440, Speaker A: I need two servers in every city. I mean, that's, that might be realistic someday, but there's a cost to all of that, right? And it's not the kind of thing that is going to be realistic at the beginning. So you have to think about that. How much do you automate, right? If something breaks, do you even have the ability to tell, is this a real problem or is my monitoring just broken? And I think my one suggestion here would be automate very little at the beginning and then enough so that you can sleep at night and not get woken up. And then what's your budget? Right? One thing I want to talk about here around budget is that node providers can be inexpensive. I listed cost is one of the reasons to use a node provider, not potentially and not run your own nodes for production applications. But a lot of that depends on how you architect your DAP right? And it comes back to everything we talked about in the first part around.
00:22:58.440 - 00:24:12.862, Speaker A: Am I enumerating? Every NFT. That all of the users that I know about every single block, am I making requests from six different servers in parallel? And pretty much every blockchain node provider out there has some kind of concept of number of requests per month. And I think one trend that we've noticed in the past six to twelve months is often have been differentiating, different kinds of requests based on the complexity. So for example, if you just want to know the network ID, they may charge you at a multiple of one. If you want to make a smart contract function call maybe that's a multiple of five. If you want to query past logs which uses their very advanced caching infrastructure and gives you a response very quick, maybe that's a multiple of 25 and so on and so on and so on. And I think one of the challenges there is trying to compare apples to apples in terms of cost and performance and what they offer and that's just something to keep in mind, right? And of course you can trade off some of these costs by doing your own caching as well.
00:24:12.862 - 00:24:50.700, Speaker A: But that of course brings in additional complexity. Again, not for ETH Bogota, this is all production DAP for when you want to scale after the hackathon. So thank you. I do want to highlight one of the things. So again, we get a lot of questions around. First of all, let me also say we actually work with basically all of the node providers. So the company that I co founded, Curvegrid, we have a blockchain middleware and we have relationships and business commercial relationships, basically all the node providers and they're all great in their own special ways.
00:24:50.700 - 00:25:48.300, Speaker A: But one question we often are asking ourselves is which one should I be using at this point in time or which one should I be using for this use case? So we've actually put together a public dashboard called Web Three Arena. We haven't officially launched it yet, but I'm happy to share it with you here and basically it gives you a few different metrics and we have more that we're going to expose over time around the responses that we're getting from different node providers. So right now I think I have the last 30 days polygon mainnet selected. I'm sorry that we don't have all the node providers out there, we're certainly working on that. We'd love to talk to you if you're a node provider and add your data into here, each of these different boxes here, these four boxes sort of describe the kinds of data that we're looking at. So we're looking at the latest block number by calling F block number on a five minute interval. And as you'd expect, they're all pretty much in lockstep with one another.
00:25:48.300 - 00:26:35.846, Speaker A: We're looking at http errors. So it's really quite brain dead simple. We just call ETH block number again every five minutes and see how often we get back an HTP error. If there's no lines there, it's because we haven't received any errors in the last 30 days. I think one of the ones that we're very interested in, because we do a lot of work with events, is WebSocket disconnections. So many node providers that we've found architect their HTPs stack very differently from their WebSocket stack. But WebSockets are the only way that you're going to be able to listen to events and so in this way, what we're doing is just doing S subscribe, which is subscribing to new events, to the zero address, so an address that's never actually going to receive events.
00:26:35.846 - 00:27:20.502, Speaker A: And we just want to see how often we're getting disconnected. The reason a disconnection is important is it's effectively like we've lost connection with one part of the distributed network. And so when we reconnect, we have to go through, like, a resynchronization process. And anyone who's run a chain indexer or used a chain indexer before knows that that starts to get very complicated. So Web Three Arena IO would love your feedback ahead of the launch. Looking to add more and more metrics to that and just operating it as a service to the community. In case you ever want to know, which node provider should I be using for my particular blockchain, my particular use case at every given point in time.
00:27:20.502 - 00:27:39.280, Speaker A: Thank you. My name is Jeff ETHGlobal mentor. I'll be at the mentor table and walking around it in the Discord. You can also find me on Discord as well. And that's it. We've got a couple of minutes left. Any questions in the room? I presume we can bring the mic around or you can just shout it out and I'll repeat the question.
00:27:39.280 - 00:27:50.960, Speaker A: Going once, going twice all right, I'll hang around afterwards. Happy to have you come up and ask me any questions. Thank you very much.
