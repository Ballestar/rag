00:00:12.120 - 00:00:12.670, Speaker A: You.
00:00:14.640 - 00:00:16.536, Speaker B: Hello everyone, and welcome to the ETH.
00:00:16.568 - 00:00:27.870, Speaker C: Online 2023 Wormhole Workshop building a crosschain application. Joining us today is Akshash Caraveru, who will be taking us through this session. And with that, I will pass it over to Akshash to get the session started.
00:00:29.840 - 00:01:14.652, Speaker B: Everyone, nice to meet you. Hope you all can hear me, but yeah, let's dive right in. So how many of you guys are familiar with Solidity? We're at the ETH Global Workshop, so I assume a lot of you are. That's good to hear, but yeah, Solidity, it's for developing on a blockchain, so you can have a blockchain application. Here's an example one I'm calling it. Hello, world. The only functionality in this contract or this function is sending a greeting.
00:01:14.652 - 00:01:52.048, Speaker B: So a user can call this function on a smart contract, let's say. And what it does is it will emit an event on the blockchain and then modify a state variable called greetings. This is a simple single chain application, your typical Solidity contract. Nothing crazy happening here. One note though, is that a user to interact with this contract needs to pay gas. And they need to pay gas using ethereum. So they need to have the Ethereum token in their wallet.
00:01:52.244 - 00:01:53.230, Speaker A: Makes sense.
00:01:57.840 - 00:02:32.120, Speaker B: So now let's suppose you don't have Ethereum in your wallet. You actually have the avalanche token. You can still be in luck. We can just take the exact same smart contract code and deploy it onto avalanche instead. And now this avalanche user can have a way of interacting with the smart contract on avalanche. They can call the same function, get a state variable to be modified, emit an event onto avalanche. And this avalanche user is now happy because the smart contract exists on avalanche.
00:02:32.120 - 00:04:09.100, Speaker B: And then some other user comes along and they have polygon in their wallet, they have Matic, the Matic token. And it's okay because you as a smart contract developer, deploy your smart contract onto polygon as well. And then this user with Polygon with the Mata token in their wallet can interact with your smart contract. Unfortunately, the problem here, and the reason for cross chain applications in the first place, is that an avalanche user who wants to use their avalanche token can't interact with the smart contract on the Ethereum blockchain because you need to pay gas in Ethereum. And similarly, the Ethereum user who doesn't have the avalanche token can't interact with the smart contract on avalanche. And as a little illustrative diagram, if a user only has a single token, they can only interact with smart contracts in their ecosystem. So our goal for today is going to be to write some sort of application that lets users of any token interact with the application as a whole, have some sort of unified system, write what we'll call a cross chain application that can let users with any token interact with any blockchain.
00:04:09.100 - 00:05:18.140, Speaker B: That's going to be our goal. So as a building block to this goal. What we're going to try to implement in this workshop today is this function on the right, which is a little modification of Hello World. But when the user calls it on the blockchain. So like, suppose this is on a smart contract on Ethereum. A user can call this Pay with Ethereum Gas and cause a greeting event to be an estate variable to be modified on a different blockchain of their choosing. So when you guys hear this, this should immediately raise some alarm bells and you should be confused like how is that even possible? How can a smart contract on Ethereum cause a state change in a completely different blockchain? And you're like natively, this is not something that's possible, but that's what Wormhole is going to try to support and that's one use case of cross chain messaging platforms like Oracle.
00:05:18.140 - 00:05:57.800, Speaker B: So let's try some audience interaction. Anyone have any ideas? Like suppose you yourself wanted to implement such a function with any tools at your disposal. How would you implement such a function? Any guesses or like musing of ideas? Ponder. You can put your suggestions in the chat.
00:06:07.410 - 00:06:11.280, Speaker C: Et, you can take yourself off mute if you want to say something.
00:06:11.650 - 00:06:38.280, Speaker D: Yes. So I didn't write it on the chat, but what I would do is I would create, I would create a signature like that is Verifiable in a contract in one chain. What else?
00:06:39.610 - 00:06:41.862, Speaker B: Yeah, that's a great suggestion.
00:06:41.926 - 00:06:56.460, Speaker D: I think start and I don't know what to do next, but eventually it should end up in being Verifiable in a similar contract in another chain. So it's like verifiable twice. Or.
00:07:00.130 - 00:07:54.666, Speaker B: Like I think the things that have been said so far, oracle relayers and some sort of Verifiable signature are extremely good ideas and we're going to kind of combine such ideas in this workshop today. So alluding to those points. Here is a sample solution and there's going to be some things missing in the sample solution. So I want you guys to try to point them out. But here is like a sample solution. What we do in this function, the Send crosschain greeting function, let's try to just emit an event and it's going to be the greeting requested event, just logging some information to the blockchain. And then we have some sort of off chain script that watches the Ethereum contract for these emitted events.
00:07:54.666 - 00:08:43.520, Speaker B: And whenever it sees one of these events, it goes and submits the greeting to a contract on the correct target blockchain. So if they specify avalanche or if they specify polygon, it goes and submits this greeting to one of our contracts on that blockchain that then emits an event and modified state. This is probably alluding to the Oracle relayer thing that JL mentioned in the chat. Any problems? I guess Et already alluded to the problem. So the problem is there's no signature. This is not a Verifiable mechanism. So this off chain process can just lie about the greeting that you sent.
00:08:43.520 - 00:09:35.790, Speaker B: So imagine if there's a malicious off chain process that decides to say that your greeting is something different than what you said. That would be not ideal. So alluding to ET's point, how do we pronounce this falsification of greetings? Here's what Wormhole does. This is probably the most important functionality of Wormhole. Wormhole is a cross chain messaging bridge. And how it gets the messaging to be verifiable is every message that is emitted from Wormhole on all the blockchains it's connected to gets attestations from 19 reputable organizations. And they all stamp their signature onto each published message.
00:09:35.790 - 00:10:35.966, Speaker B: And then on the target chain you can verify that two thirds of these signatures are valid so that quorum has been achieved. And then you have some notion of validity for the message rather than just relying on an untrusted messaging system that's it is not for. 19 is not hard coded. There's definitely 19 is just like the current number of reputable organizations. So combining these two solutions, this is very close to how Wormhole works. Right now you publish some sort of message on the source chain as an event in the blockchain log. These 19 entities stamp their signature onto the message and then on the target chain a script which doesn't need to be trusted.
00:10:35.966 - 00:10:54.780, Speaker B: It can be anyone brings those signatures to the target chain and then the user's contract on the target chain can verify those signatures and then do whatever they want. Take a quick pause here. Any questions about this model?
00:10:58.030 - 00:10:58.490, Speaker A: Yes.
00:10:58.560 - 00:10:59.340, Speaker D: Can I?
00:10:59.870 - 00:11:00.620, Speaker A: Yeah.
00:11:01.710 - 00:11:22.820, Speaker D: So the off chain program monitors the source chain where the message is initially published and it brings the signature from the message. From the initial message. I believe the signature is done by Wormhole, right? You said so.
00:11:24.550 - 00:11:54.750, Speaker B: The signature is 19 separate signatures. So there's going to be 13 of 19 separate signatures. And then as long as there are 13 valid signatures out of the 19. So you have to perform 13 signature verifications on the target blockchain. And this is all going to be abstracted away in a nice little function verify message. But yeah, that's the architect.
00:11:55.490 - 00:12:13.460, Speaker D: I get it. So the signature is not just the initial one, not something that goes some signature goes through the initial chain, through the initial message and is contained in the event, or.
00:12:18.570 - 00:12:32.826, Speaker B: In the initial event is read directly from the Ethereum blockchain. So whatever mechanism Ethereum has of ensuring valid messages get published onto Ethereum state.
00:12:33.008 - 00:13:22.230, Speaker D: Yeah, right, I get it. So in the initial chain, events are just plain events. But to get ported to the other chain, there are multiple nodes, like separate nodes, each with its own signature. And when all of these nodes work, when all of them sign the message, the initial message, then like 13 out of 19 when the quorum is there, then the verifying contract in the target chain accepts that as valid. And these 19 connectors are all run by wormhole?
00:13:22.390 - 00:13:31.290, Speaker B: No, these are 19 separate entities. These are like 19 big names in the blockchain industry. These are all independent actors.
00:13:33.970 - 00:13:35.790, Speaker D: I missed the slide, sorry.
00:13:35.860 - 00:13:36.814, Speaker B: I understand it now.
00:13:36.852 - 00:13:42.960, Speaker D: Right? Cool. Isn't that like super expensive so far?
00:13:45.990 - 00:14:19.990, Speaker B: Yeah. Each of these 19 guardians they're called, they each run full nodes. So it's definitely decently expensive. But that's the cost of running a block cross chain application. I suppose. It's like basically I probably have to move on just to get to all my content, but feel free to ask more questions in the chat. I can probably get to them afterwards.
00:14:19.990 - 00:15:42.150, Speaker B: But yeah, here, let's move on. So that solution works all great, but obviously it would be annoying if you as the user had to run this off chain script or you as the user had to think about verifying 13 individual signatures. So what we did is we generalized and abstracted this whole solution into a sending and a receiving interface completely. So all you have to do is look at our interface files and call Send payload to EVM on the source chain. And you just specify what contract you want to send the message to the chain that the contract is on the message you want to send, which is the payload, the gas limit you want to use, be used to call the thing on the target chain. And if you want to pass in any additional message value on the target chain, you just specify all these parameters. You put in any message value that this requires specifically to pay for the gas limit and the message value on the target chain.
00:15:42.150 - 00:16:39.538, Speaker B: And then it just happens. We run a bunch of off chain scripts that are they don't need to be trusted because the signatures are the trusted part. So we just run a bunch of these off chain scripts that will relay any message that gets requested from this interface to the correct target address. And then you just have to implement one interface on the target address. And now you have your payload on the target address and you could do anything you want with it. So, yeah, I'm going to speed run through actual code example to show you guys how you can use these functions in any projects that you might want to build in terms of cross chain applications. So, yeah, the important link here is this tiny URL.
00:16:39.538 - 00:18:24.170, Speaker B: I'll put a link in the chat, tinyurl.com wormhole hackathonresources, but this will give you a bunch of example GitHub repositories that use basically that exact interface I showed you. And I'm going to quickly work through the most basic hello wormhole example right now and show you guys how you can make it happen. Okay, so let me quickly share a coding screenplay. How many of you have heard of Foundry before? Forge Foundry. If you've heard of Hard Hat Truffle, it's basically another suite of tools to work with solidity applications. And we use a lot of it in these crosschain applications because they have a really nice way of fork testing.
00:18:24.170 - 00:18:46.240, Speaker B: Basically in all these applications we'll have very cool fork testing setup and that's all abstracted away in our solidity SDK that the readmes that are linked in that above tiny or El will describe. But basically.
00:18:48.950 - 00:18:49.922, Speaker A: As long as this test.
00:18:49.976 - 00:19:45.154, Speaker B: Passes, we're going to be happy. All this test does is deploys our contract to a source chain, deploys the contract to a target chain, and then sends a greeting, specifically the hello wormhole greeting, and then switches the fork to the target chain and then asserts that the greeting was received on the target blockchain. So let's dive right into some code. So I'm going to check out my starter branch. Here's a skeleton code for a cross chain application that you guys might want to write. I'll try to answer questions at the end. By the way.
00:19:45.154 - 00:20:28.370, Speaker B: You just want to get through this. So in this Hello Wormhole contract, basically this is going to be the sending and receiving endpoint for our cross chain application. So we're going to deploy this Hello Wormhole contract on every blockchain that we care about the source to target, let's say like ethereum and avalanche. And then we just instantiate I wormhole relayer instance. And this will let us send messages to other blockchains. So let's implement the receiver end real quick. So we're going to implement the receiver interface.
00:20:28.370 - 00:21:21.440, Speaker B: So this is the endpoint that if on another blockchain someone requests to send to this contract, this will be called by an off chain process. So I'm going to implement something real quick. The first thing to do is to make sure that message sender is the expected address. Basically to explain this line a little bit. Anyone can relay a message, but it must always go through this smart contract. And what this smart contract does is verifies those 19 signatures. So anything coming through here, you can be sure it's already been verified.
00:21:21.440 - 00:22:03.836, Speaker B: So, yeah, that's the purpose of this slide. Now I'm just going to decode some information from the payload. So as you can see in the spec, I'm going to declare that people sending things to this contract must send it in the form of the greeting and then the sender of the greeting. So if that's the case, then I can decode that information. And now I'm going to update my.
00:22:03.858 - 00:22:15.762, Speaker A: State and I'm going to admit an eventually.
00:22:15.926 - 00:22:22.190, Speaker B: And that's it. I'm just going to do these actions whenever someone tries to send a wormhole message to my contract.
00:22:23.750 - 00:22:24.500, Speaker A: Perfect.
00:22:27.190 - 00:23:15.970, Speaker B: So I'm going to run my test, make sure that this works perfect. Okay, now, next step, I got my old code. Now let's write the sending part of it. So if you remember, there's this function on the Ibornhor wheel interface called Send Payload to EVM. So I'm going to do that first here. Let's do wormhole relayer, send payload to EBM. I'm going to send it to the target chain.
00:23:15.970 - 00:23:33.910, Speaker B: The address I want to send it to is just parameter and then I'm going to send it in the exact form that we expected the information to be sent. So I'm going to encode the greeting along with the sender.
00:23:36.090 - 00:23:36.806, Speaker A: And I don't.
00:23:36.828 - 00:24:43.280, Speaker B: Need any petro value and let's just hard code gas limit to be something small, you don't need too much gas. Um, there's something missing here and what it is, is that we're requesting to spend 50,000 gas on the target chain and this can't be done free of cost. This has a price on the target chain, especially if the target chain is ethereum. So what we're going to do is this quoting function will have the cost and all we do is the cost is going to be obtained from a function on the interface as well. It's just the quoting function. So we just put the parameters that we requested, no match value and 50,000 gas limits and that's it. And now we can make sure that the cost is passed in.
00:24:43.280 - 00:26:03.880, Speaker B: Ah, then we'll make sure that message value is cost and then we will put this in as value. And so now we have sent a message and we just received it and let's see if the test passes. I already had that and it passes and we just wrote our first crosschain application. We just had to write the sending part, sending a payload and then the receiving part. We received the payload and now all we have to do is take this smart contract, deploy it onto every blockchain we want to support and then any pair of those users can send greetings to and from and cause them to be emitted on the other blockchain. That's it. This code, you take it, you deploy it to testnet right now and it will just work.
00:26:03.880 - 00:26:51.302, Speaker B: No other infrastructure needed. Yeah, it just works straight out of the box and that's because of all the wormhole infrastructure behind the scenes of the 19 guardians, 13 of 19 of them signing every single one of these, the untrusted processes that just bring those signatures to the target chain. Yeah, that's wormhole. Any questions? I'll look through the chat now but feel free to ask any other questions. And also please check out the tiny URL link I sent in the chat. This has all of the resources that you'll ever need. I can go through it right now.
00:26:51.356 - 00:26:59.390, Speaker A: But here, let me do that's.
00:26:59.490 - 00:27:03.100, Speaker C: Yeah, and I can go through the chat and read you questions as well.
00:27:04.030 - 00:27:04.780, Speaker A: Okay.
00:27:06.510 - 00:27:56.250, Speaker B: Real quick, let me go through this intro thing, the link I sent some resources, there's like many readmes. So this is the hello wormhole we just worked on. There's a GitHub with three different articles in it that could help as explanatory material. We have a token example. So suppose you want to send IERC 20 tokens to other blockchains. Wormhole has this thing called the Token Bridge, which is something built on top of Wormhole messaging, and you can compose with that as well. So you can request a message to be sent along with an IERC 20 token to another blockchain.
00:27:56.250 - 00:28:33.480, Speaker B: USDC. USDC. If you want to use CCTP cross chain token, whatever CCP stands for, you can do that too. You can send USDC along with your messages. We got an example of a full cross chain application, a bar lending application that sends things back and forth. And yeah, like all the research over here, some installation steps if you need to install node NPM or Foundry are here and deployment instructions as well.
00:28:34.650 - 00:28:37.378, Speaker A: Yeah, there's a question.
00:28:37.564 - 00:29:26.760, Speaker B: Can you also do one to many receiving chains with a single emitted event? No, not with a single emitted event, but you can do it. So basically, Wormhole at its core, you can publish a message and get the guardians to put on signatures, 13 or 19 signatures to one payload. And then you can bring that to many events manually. So you can bring that to many receiving chains manually. But if you want to use the interface that we described in this workshop, you would have to call the endpoint multiple times and that would cause multiple emitted events, and then those would automatically be taken to each receiving chain. So the answer is yes and no.
00:29:31.050 - 00:29:39.580, Speaker C: There was a question earlier on. I don't know if you answered this, but if I want to swap Dai for uniswap on Mainet to USDC on polygon, how can I do that?
00:29:41.810 - 00:30:06.610, Speaker B: If you want to swap Dai to USDC, you would have to use like this is not like a swap platform per se. This is more like a messaging platform. So you would have to obtain USDC on the source chain and then send it through. You could send it along with your message using the example Hello, USDC.
00:30:07.030 - 00:30:07.780, Speaker A: But.
00:30:09.990 - 00:30:56.978, Speaker B: Yeah, and there was yeah, that's a great question. So how this works is the entity that runs these off chain scripts I was describing in this system, we call it a delivery provider. And delivery providers can right now we have one delivery provider. They're the default one. So as you saw in the code, we didn't specify any delivery provider, so it fell to the default. And the delivery providers have full discretion on how they charge for gas on different chains. So the default one just hard codes, different prices, and they update them periodically.
00:30:56.978 - 00:31:59.910, Speaker B: But basically it's like they're doing this relank as a service and you're just paying them upfront on the source chain and then they do it. Any known vulnerabilities? No known vulnerabilities. Basically what this uses is this is something on top of Wormhole core messaging. Wormhole is something that's existed for a few years. By now, core messaging has been extremely extensively audited. And these two interfaces that I just presented about is something that we launched in July that are purely on top of it. So it's like a strict the security comes from the core layer and then this is a layer on top, so you can be confident in your security from the core and token bridge layers which have been extensively audited.
00:31:59.910 - 00:33:07.360, Speaker B: And we have security pages on our website if you want to check out where one.com that detail all of these audit. Is there a way to delay a sent message to the receiving chain? I think this goes into a concept, so the way to specify how long to wait before going to receiving chain falls under the category of finality, where you're allowed to pick the level of finality you want. So if you want the relank to happen instantly, that's an option. If you want it to happen when the message is finalized on the source chain, which is the default, the default is to wait for finality. That's an option. And anywhere in between, the options depend on the blockchain and there's information on the wormhole docs page docs wormhole.com.
00:33:07.360 - 00:33:29.960, Speaker B: But I think for some blockchains the option is to specify some constant number of blocks, but not for all of them. I think it depends on the blockchain. And the term we use in the work ecosystem is the consistency level. So yeah, hope that answers that question.
00:33:33.290 - 00:33:34.040, Speaker A: Ah.
00:33:38.010 - 00:33:44.250, Speaker B: Yeah, I guess. Thanks everyone for coming by the way, I much appreciate it. I can answer some more questions, but.
00:33:44.400 - 00:33:50.220, Speaker C: Yeah, there was one final question I think that just popped up.
00:33:50.850 - 00:34:54.426, Speaker B: What is the total time taken for this process to fully finish from signing from one chain and receiving on another chain? So that depends on the finality of blockchains. So there's like three time components that are matter here. There's finality, there's the Guardians signing the message. So remember, the 13 and 19 entities, they take some time to sign the message and then relay. So the off chain script needs to go and relay the message. The finality obviously depends on your specification and the blockchain. The Guardian signing the message is on the order of seconds usually, and the relaying is most of the time on the order of under a minute, but it varies and most of the time it's under a minute.
00:34:54.426 - 00:35:04.850, Speaker B: But we're actively improving on this time, so in some cases it'll take a little longer, but it shouldn't in most cases.
00:35:08.140 - 00:35:08.744, Speaker A: Awesome.
00:35:08.862 - 00:35:17.288, Speaker C: Well, cheers. Well, thank you for the great workshop and presentation. There was another question, I don't know if you still have time to answer it.
00:35:17.454 - 00:36:22.620, Speaker B: Yeah, this is a great question. Basically any call to send message, send payload to EVM or any call to sending will always result in the call succeeding on the target chain. But if your contract reverts, then our contract, basically how it works is the off chain entity calls our contract, our contract signs Verifies, the signatures and then calls your contract. And if your contract reverts, our contract knows and laws information about it. So then the status scripts, which are also in the websites that I'm showing there is like some testnet status utilities. These will read the event that gets emitted on the target chicken, which there will always be one and that would let you know if your contract reverted for some reason. So that's the way to monitor if the transaction were to fail on the destination chain.
00:36:27.280 - 00:36:44.320, Speaker C: I think that's the answer to the question. So thank you again for the great workshop presentation. Thank you everybody for attending. And yeah, don't forget that the opening ceremony starts in a little bit and you'll receive more information around what to expect for the next couple of weeks. So cheers. Thank you all. Have a good Friday and good weekend.
