00:00:06.010 - 00:00:32.200, Speaker A: To kind of build up. On top of all this, I'd like to welcome Zach and have him go more deep into building on the EVM on the welcome, Zach. Hey, thanks for the introduction. And thanks Raul for laying the groundwork. I think all the information was super helpful, helpful for the demo I'm about to go through. So we're running on time. So I'm going to go ahead and just jump right into it.
00:00:32.200 - 00:00:58.368, Speaker A: Share the screen. All right. Yes. If you don't know me, I'm Zach Ayesh. I'm a developer advocate with the Fem team in Protocol Labs. I've worked in Web Three for almost three years now, but this is all still new to me. This space changes so much and it's all so crazy.
00:00:58.368 - 00:01:46.880, Speaker A: So I'm never beyond learning more. And I'm really interested in infrastructure in Web Three, which is why I'm here. I think decentralized storage is a very important part of the Web Three infrastructure. Right? And if you watch any of my talks, you've probably seen this, but I'm always encouraging people not to get discouraged by Imposter syndrome. If this stuff seems intimidating in advance, it is because it is, and it's always changing and it is to everyone. We're all learning as it goes on. These are some notes I took at a conference with some of my colleagues where I'm just trying to learn the addressing scheme that Raul just presented.
00:01:46.880 - 00:02:55.764, Speaker A: So, yeah, if you're feeling like this is crazy, just know that we're all feeling that and persevere on through it. So the gin of the day is I'm going to do some demos and Remix. We're going to go over a basic contract, simple coin, just to show that all the Remix solidity features work. We're going to move on to a filecoin market consumer using that filecoin sole library that Raul talked about and in hard hat, we're going to go and we're going to mess with a simple deal bounty contract. Not dealy bounty contract, but that is a fun name. And Molly Row will probably already talked about this, but we have launched Hyperspace, which will be a more stable testnet for you to develop on closer to go early if you're used to developing in the ethereum ecosystem. And we will be using that in this demo coming up.
00:02:55.764 - 00:03:23.412, Speaker A: All right, so some resources. We're going to go ahead and go into Remix. I have MetaMask installed already, but you can go to their website to install it. Just a little browser extension up here. And I'm going to show you how to add the Hyperspace network to MetaMask. So we're going to go to Chainlist.org and we're going to click Include Testnets because Hyperspace is a testnet.
00:03:23.412 - 00:03:46.228, Speaker A: We're going to type in Hyperspace. And here you go. Here's the Hyperspace Network. It gives you the RPC address and the chain ID and the currency. You just click Add to MetaMask. This will pop up. I've already added it, so I'm not going to actually go through and do that.
00:03:46.228 - 00:04:33.888, Speaker A: But that's how you add the Hyperspace network to MetaMask. All right? And then next thing after you add Hyperspace to your MetaMask is we're going to want to fund it with Tfil since we're going to need to pay gas for every interactions we do on chain, right, so you can find that hyperspace Yoga. I like that top level domain. But yeah, if you just click here, Hyperspace Yoga. And if you just go to the main page, you can click on Faucet here in the top right. And remember, Raul kind of introduced the T four or F four addressing. So F four is the official file coin address for all Ethereum addresses.
00:04:33.888 - 00:05:15.452, Speaker A: And on testnet we just call it T four, but they're the exact same thing. And so we can actually just work with almost all tooling with just Ethereum addresses, right? So it's very similar to normal EVM workflows, right? So we're going to copy my account address from MetaMask and we're going to paste it in and we're going to do a hard captcha here. It's always very specific. These are always fun. So I need specifically pandas in a forest, right? So this panda is cool, but he's in a living room. This panda, I think is in a forest. That's a penguin.
00:05:15.452 - 00:05:34.250, Speaker A: And I believe this panda is in a forest. So not quite there yet. Forest, forest, forest. Boom. All right, send and this will send five Tfill to the wallet. I've already, as you see, pre funded it. But later on in this demo, you'll probably see I get five extra.
00:05:34.250 - 00:06:50.800, Speaker A: Okay, so now that you have a MetaMask with the Hyperspace network and some Tfill, let's go ahead and go into Remix. I already have a Remix open, but you can go to Remix Ethereum.org to get to Remix. And Remix is just a very nifty online IDE. It's great when you're starting out or you just want to do some basic tests with a smart contract. And later on we'll use Hard Hat, which has a little bit more advanced features if you're used to working locally as a dev. But here you'll see we have a contract called Simplecoin Sol, right? And all this is a very basic, very simple token contract, right, and just has a mapping for balances and a constructor that mints the whole supply of tokens to whoever deploys this contract.
00:06:50.800 - 00:07:36.510, Speaker A: A function to send coin and some functions to get balance based on the address. So let's go ahead and deploy this basic contract to Solidity. We'll check, make sure everything is compiled properly. We get the green check mark, we're good to go. And at the top here, usually when you come in, you'll actually see default to Remix VM London. We're going to go ahead and click injected provider MetaMask. So this will tell Remix to send all transactions through our MetaMask account.
00:07:36.510 - 00:08:22.172, Speaker A: While Remix VM is just like this local simulated blockchain. Right? And remember, our constructor here needs to take in a UN 256. So this is going to be how many tokens we made. I'm going to mint 1200. Seems like a fun number. And we're going to deploy now in Filecoin, in a hyperspace, it takes about 30 seconds, give or take, for a transaction to get accepted into the chain. And then after that transaction is accepted, filecoin has what's called the delayed execution model.
00:08:22.172 - 00:09:13.260, Speaker A: Right? So the transaction will be included, but until the next block, the state doesn't actually change. So it takes about a minute or so between transactions for you to see the state change come live. So this will take a second. So instead of waiting for that to come through, I have a pre deployed contract. And so Remix has this Nifty function where if you have a contract compiled so it knows the interface, it knows the Abi, you can put in the address of that pre deployed contract right here and it will know to point to that contract with the Abi. Right. So here we have our new contract.
00:09:13.260 - 00:09:53.850, Speaker A: It deployed. And if I put in my address and get balance here, you'll see that it shows 1200. So the constructor went through, we have 1200 simple coin. And if I wanted to pull up that old contract again, this was that other contract, the old contract address. I can just click this button and pull it up real fast and paste in. And in this contract I had put 1000 as my constructor. Right.
00:09:53.850 - 00:11:01.152, Speaker A: So this is just to show that, yes, all those basic Solidity functions work. And so Raul kind of laid down the introduction to Filecoin Sol. And, you know, again, to kind of just repeat a bit. Before the advent of Fem, most user interaction with the filecoin blockchain was handled by built in actors, right? Originally called spec actors. And you can kind of think of them sort of like Ethereum pre compiles. Filecoin Sol is a solidity library developed by Zondax that allows you to interact with these built in APIs via writing code in Solidity. Right? So normally before this devs would interact directly with clients and communicate in the peer to peer network in the blockchain.
00:11:01.152 - 00:11:39.360, Speaker A: But now we can do it in smart contracts, which is awesome. So let's just go explore and check out the library. And later in this presentation, for some of these important links, I'll go back over them and I'll have QR codes. If you have your phone handy that you can scan and go to these links. Right? So we're at GitHub.com Zondaxfolicornsolidity, they give you some basic info on the README and some docs. But the important things you want here are the contracts.
00:11:39.360 - 00:13:23.562, Speaker A: And so these contracts right here, they represent the abstractions of these built in actors, right? So we have an actor called the init actor. And this is the Solidity library you can use to interact with that. And what we're going to be messing with today is the market API or the market actor, right? And this contract allows us to get information about storage deals that are on the filecoin network and pull them into our smart contracts so we can write logic. So yeah, I want to talk a little bit more about storage deals, right? A common question is why the Filecoin EVM? Why not just the Ethereum EVM or any other EVM chain? Well, the reason Filecoin has access to these native primitives called storage deals. And the whole reason Filecoin was created was to be the blockchain that's tailor made for storing the Internet's data, right, the decentralized storage layer of the Internet. And now with the Fevm, for the first time you can program smart contracts around these storage deals that aren't available on any of these other EVM chains. And so this kind of unlocks a whole bunch of new use cases that I think, you know, we'll talk about later.
00:13:23.562 - 00:14:09.270, Speaker A: And we'll go over a very basic one like data dows storage, lending markets and all kinds of cool stuff. And if you want to see some live storage deals, we can do that by going to the filecoin block Explorer called Phil Fox. So click here. It's at PhilFox Info, right? And this right now is just for the main net filecoin blockchain gives us all the stats that we would like to see about that. But we're going to switch to hyperspace now. Right now it still says Wallaby, but this does point to hyperspace. So if I click here, you'll see this is Hyperspace.
00:14:09.270 - 00:14:48.614, Speaker A: PhilFox info. Wallaby was the testnet we were using before hyperspace. So that should be updated soon. But yeah, so now we're looking at the Hyperspace blockchain testnet. And if we click on Blockchain, you'll see a section called Deal List. Let's click on that and we'll see a bunch of deals that have already been made on Hyperspace and some of the info around those deals. So if we click on deal 794, you'll see that this is the provider right here.
00:14:48.614 - 00:15:57.736, Speaker A: This is the storage provider. This is who is actually storing the data and this is the client who requested the data to be stored, the deal ID that defies this deal, the block it was stored in. And importantly, here we have the piece CID. This is the CID that describes this essentially a hash that describes fully the data being stored. It represents the data and you have the size of the data being stored in this provider. So now that you kind of see some deals, let's go ahead and look at how we can use that Zondax library to actually pull information into a smart contract from the marketplace. So we'll go back to remix here and I have created this basic contract here that imports Zondax's NPM libraries.
00:15:57.736 - 00:16:43.000, Speaker A: So Zondax did package the repo as NPM libraries. Very conveniently. And we can pull in where we're going to pull in the market API contract right here. And the market types actually. And this contract, I'm actually pulling it from the GitHub directly, but you can pull it from NPM, which you'll see in the Hard Hat kit later. So what does this contract do? It's just a simple basic Gitter contract that calls all of the gitter functions. You can call on the marketapi Sol and stores those information in the contract.
00:16:43.000 - 00:17:37.736, Speaker A: This is more of just an example to show devs how you can access these APIs. And so we can get things from the deal label. We can figure out who the deal client is, the deal commitment, which is really important, that actually tells what the PCID is and what the size of the data is that brings that in. And all kinds of fun things that we can program around. And then like one function that just calls them all and we just pass in a deal ID. Like whatever deal we want to store, we pass in that ID. And so what I'm going to do, we're on the market consumer it's, compiling it's, giving some just license warnings.
00:17:37.736 - 00:18:37.508, Speaker A: These are fine. We're going to load a previously deployed contract so we don't have to wait for the deploy, right? So you could go through and deploy new. Just wait, I'm going to deploy one of my previously deployed if you wanted to deploy new, you do it the same way. Make sure you're pointing to injected provider MetaMask, that you have funds in your MetaMask and that we're pointing to the right contract and you just click deploy. There's no constructor here, so we don't have to pass any arguments when we're initiating this contract. All right, so we'll just click Add Address. We'll pull it in here and we're going to store let's store this deal that we're looking at right here, 794, right? Hint, I've already stored it, but we're just going to go through the steps.
00:18:37.508 - 00:19:17.940, Speaker A: So if I type in 794 and click Store All, MetaMask will come up with a transaction. Just click Confirm and the transaction will go through again. You'll have to wait about a minute for the state to update. But this contract, I should have already called Store All on ID 794. So let's see if things line up here. Let's look at the deal client Actor ID 1337. That's this.
00:19:17.940 - 00:19:45.950, Speaker A: Let's look at the client here. Yes, that's their ID. So that is that client. Let's look at the deal commitment. This is really important. So you'll see here that the PCID is actually represented in hex because that's what our ethereum functions take. They take bytes represented as a Hex string and PCIDs are encoded in.
00:19:45.950 - 00:21:06.622, Speaker A: I believe these are base 64 as well, I believe. And so this is literally just this piece CID, but base 16 encoded. And there's some logic later on I can show you in the Hard Hat kit that actually takes care of this for you. Yeah. And the size, this is in raw bytes and it lines up right about here with 32 gigs. So, yeah, this is the market consumer contract, just kind of showing off how you can use the followcoin Sol in a very basic way just to pull in some data. Okay, so now we're going to move on and do some work in Hard Hat, right? So if you're a little bit more experienced as a developer, you may be used to programming in a local IDE and programming with a command line interface and all that good stuff.
00:21:06.622 - 00:22:06.078, Speaker A: And Hardhat is an SDK, one of the most popular SDKs for creating, deploying and testing smart contracts using JavaScript. So it uses JavaScript to kind of create scripts that lets us automate all of those tasks. So in this demo, I'll go over a Starter kit that we've created for developers to download and easily start programming with Hard Hat on the Fevm. And we're going to interact with a basic bounty contract that uses Filecoin Sol to post a bounty for a specific PCID and size. So specific set of data and allow someone to come claim that value. Yeah. So here we have links to the Hard Hat Starter kit.
00:22:06.078 - 00:22:57.620, Speaker A: We'll go there in a second. I've linked to the Lotus stocks. So in this demo, for the sake of time, we're not actually going to create a new deal, a new storage deal on hyperspace. It's kind of a time consuming process, not too bad, but in the time constraints of this demo. But you can go to Lotus Filecoin IO and go to their tutorials and they'll tell you how to set it. You can set up a local Lotus client on your computer and you can create deals on the network using that. And in the future, hopefully, we hope to have some more convenient UI tooling methods to allow devs to easily do that.
00:22:57.620 - 00:23:32.590, Speaker A: And the deal bounty contract that we're going to go over was originally created in Foundry by a great dev, goes by Zin, I think Raul mentioned him earlier. And you can find this original repo if you prefer to program in Foundry. Here. Lotus Web Three. Deal. Bounty contract. And with that, let's go ahead and jump right to the Starter kit.
00:23:32.590 - 00:24:36.682, Speaker A: All right, so here is the repo for the Fevm Hardhead kit under Filecorn Project. And you'll see that we have basic structure, a contracts folder, a folder for deploying, a script for deploying all of our contracts, and some tasks, a task folder. And tasks in Hard Hat allow us to interact with our deployed contracts and a reading. So I'm actually going to stop sharing this window and I'm going to share my desktop. Desktop. Okay. And we're going to clone this demo, this Hardhead kit in here.
00:24:36.682 - 00:25:06.500, Speaker A: So if we click on code and copy, I have a terminal open here. I've made a directory called Demo it's probably hard to see. So let me use the font a bit. Yeah. So I've made a directory called demo. I switched into that directory. Now we're going to type in Git clone and we're going to post in that link we got and that's going to clone the repo in there.
00:25:06.500 - 00:25:52.290, Speaker A: I have a shortcut called code which will automatically open any directory we point to. It in vs. Code. If we just type Fem and tab, you'll get the full saying code fevm hardhat kit. And if you don't have this shortcut installed, you can simply just open up a Vs code editor and open up the directory using like file and open we'll hit Enter. And now we have that exact starter kit open in Vs code. And the first thing I'm going to do in here is I'm going to open a terminal.
00:25:52.290 - 00:26:11.174, Speaker A: You can do so by going up here as well and hitting new terminal. And I'm going to say yarn. Just yarn. Enter. And you may have to install Yarn if you don't have it already. Or NPM. You can use NPM if that's your package manager of choice.
00:26:11.174 - 00:27:34.956, Speaker A: But this will install all of the packages we need to run this repo, right. And it's going to go through, it's going to do its thing. And a quick walkthrough here's that README that we saw earlier written in markdown our package JSON which tells us what packages that Yarn actually downloaded. And what's very important here is the hard hat config, which allows us to configure our hard hat based on the network we want and all kinds of default behaviors that we'd like to put in there. And in this repo we have it already pointed to hyperspace. So already pointing there, it's got the chain ID and the RPC URL already in there ready to go for you. And one final thing that you'll need to do before you can start actually doing things on chain is put in a private key so that the repo can actually sign transactions with a key, right? And an easy way to do that is with a env file.
00:27:34.956 - 00:28:14.130, Speaker A: Now I'm going to stress, I always stress this. Never show anyone your private key and never check in your EMV file. So this is an example just to show you and the private key, I will put in a private key to show you how it's done. But this is just a test account. There's no real funds in this account and I will never put any real funds in this account. But if you give someone your private key, they will have access to all your funds even on Mainet. So make sure you're doing this only with a wallet that you never plan to use for actual money.
00:28:14.130 - 00:29:23.720, Speaker A: So we're going to rename this from env example env. And we're going to go to our MetaMask and I'm going to click on these ellipses here and go to account details and export private key. You have to type in your MetaMask password and you can grab the private key here and we'll delete that and we'll post it right there. I believe it actually needs to be as a string. So our Git ignore should ignore the env file. So this will not push it to git. But again, be absolutely sure that you're not putting real funds on this private key.
00:29:23.720 - 00:30:32.650, Speaker A: And so now that we've got that set up, we can go ahead and deploy our contracts. So there's a deploy script here and what it does is it goes through and looks at each of the smart contracts that's put in here. So here's that simple coin contract. We have the market consumer and we have the dealer order contract that I'm going to go through and deploys them. Now you may see that the syntax is a little bit more verbose than you would normally see in a hard hat project if you're used to that. But all we're doing here, and this is just temporary, is we're calling the RPC to get the priority fee and we're putting that in our transactions so that forces it to default to EIP 1559. This should be updated in the future to more standard syntax, but the chain is changing constantly.
00:30:32.650 - 00:31:17.508, Speaker A: So yeah, that's what this is doing. It just reads all of our contracts and deploys them. So to do that I'm going to type in, let me make sure this is visible too much. We're going to type in yarn, yarn, hard hat deploy. So it's going to compile it since this is the first time. And then it's going to go through and go through deploying each of those three contracts. Now this can take some time again.
00:31:17.508 - 00:32:32.248, Speaker A: And so what I'm going to do at this point is I'm actually going to switch from this and I have a hard hot project with some contracts that are already deployed. We'll exit out of this one and we'll open this one. No, not this repo actually right here. All right, so after the deploy script goes through, you'll see a deployments tab pop up and this points to the metadata for where your contracts are pointed to like what their address is and their Abi. And that's how you know it's gone through. And you can find this artifacts folder here to find the compiled bytecode of your contracts that actually get deployed. Okay, so we've deployed the contracts, we've got everything set up.
00:32:32.248 - 00:33:39.080, Speaker A: Let's go in and let's interact with that bounty contract. Let's look at the bounty contract and then we're going to interact with it. So under the contracts directory we'll see filecoin API examples and basic solidity examples. Basic solidity examples is where you'll just find simple coin for now and filecoin API example is where we'll find contracts that use the filecoin sol, right? And you see here that's filecoin consumer. We're going to go to deal rewarder, right? And you'll see here. We're calling in some of those APIs from Filecoin sol. Right now we have them in here locally, but I will be pointing them to some NPM packages in the future as those stabilize and we'll just walk through real quick how it works.
00:33:39.080 - 00:34:34.040, Speaker A: The constructor simply sets the owner to whoever deploys the contract. We have a simple function here, fund. It has an argument, we could actually get rid of that. It doesn't use it for anything, it's just so we can send funds to this contract to store. And now remember, the point of this contract is to act as a bounty contract, right? We want to be able to put a CID and a PCID and a size and allow a bounty hunter to come through and look at our contract, say, hey, they're looking for this PCID of this size. I can get that data stored on filecoin. I'll do that and I'll claim the bounty that they funded the contract with.
00:34:34.040 - 00:35:31.740, Speaker A: Right? And so this function adds CID. It takes in the raw CID bytes and the size of the data and adds it into our state variables. And you have to be the owner for this to work. We have some policies about how we're going to release the bounty. In this case, if the provider was already accepted a bounty for that exact data, we're not going to let them keep claiming the bounty. But this is where you can get creative. This is kind of a jumping off point for you as a dev to kind of add your own logic to start customizing it and really building out a full fledged DAP around this.
00:35:31.740 - 00:36:43.120, Speaker A: And we have this function here claim bounty, right? And what it's doing is it's actually calling the market API and getting that Git deal data commitment we looked at earlier and storing it in these variables. And then this authorized data function checks to make sure was this data actually requested as the bounty. And at the end of the method, if everything matches and it goes to the authorized and everything is good to go, it will send one fill. So this is hard coded to send one fill as the bounty. They'll send one fill to the client in that storage deal. So remember, in the storage deals they automatically have that client field and we can pull the address from that and make sure the money gets sent there. So anyone can call this method, but it'll always only get sent to whoever actually created the deal, which is what we want.
00:36:43.120 - 00:38:24.148, Speaker A: And you can see some lower level functions that are used, right? And so finally we'll actually want to do this and interact with the contract, right? So you can go to tasks to do this and tasks are written in JavaScript. So let's look at the add CID task. And this task is going to from our command line in hard hat going to add our PCID and call that function for us, right? So we're going to have these parameters, going to do the RPC calls and it's going to call the add CID function on our contract and pass in our arguments. Now there's some logic in here using this library CID that actually converts the PCID that we get what we saw on Phil Fox and converts it to the hex format that we need to pass in the EVM, right? So as an example, if we would want to run this, we would do yarn hard hat add. And the task is called add CID. Add CID. And for each of these arguments here, we're going to have to add in some info.
00:38:24.148 - 00:39:50.230, Speaker A: So contract, this is where you'll put in the contract address of where this is deployed. I have one pre recorded here, contract CID. And again we're going to put the PCID and this is actually the PCID of that deal 794 that we looked at earlier, CID and size, right, and the size of the data. So ideally when we add a CID, this data doesn't exist as a storage deal, right? And you go through and you make that storage deal or someone will make that storage deal. But to simplify things, we're going to put a bounty for a storage that already exists and then claim that bounty, right? So you would call that function and it's going to run I've actually already run this function with this exact data. So, yeah, it went through anyway. And yeah, it converted our piece ID to bytes and read it out for us.
00:39:50.230 - 00:41:12.432, Speaker A: And just a little notification, give it some time for the state to update. You can do the same thing with funds. So yarn of hard hat. And there's a task here for fund and this will send one fill to the contract and you can call fun and point it contract, paste in the address of your contract as a string and hit enter. I've already run this so we're not actually going to, well, I'll run it again, send it an extra fill of funding and finally claim bounty, right? And for this one it's going to be the same yarn hard hat. I'm going to paste this command in for time, but yarn, hard hat, clean bounty. It points to the contract, contract and we put it as a string and we put the deal ID of the bounty we want to actually claim the bounty for.
00:41:12.432 - 00:42:34.654, Speaker A: That's the argument, right? And there we'll hit enter here and that'll claim the bounty, right? And that'll send the fund to whoever created, again, whoever is the client of that storage deal, right. So the client of deal seven nine four was this person and in about a minute you should see their balance increase to 14 fill because they would have been rewarded the bounty for making this deal, right? That was a quick overview on hard hat and remix and programming on. The fevm, right? And here are some of those important resources. Again, if you missed some earlier, this is where you can find the Mock or not the Mocks, the Filecoin Sol Library. In the past they were mocks and now they are a full fledged library. Here is the link for the Hardhand Starter kit that I just went through and our new developer forums. We previously had these on Discourse.
00:42:34.654 - 00:43:30.150, Speaker A: They have now been migrated to GitHub discussions. So if you have some questions or please post them there and we'll be monitoring those. And if you're participating in this hackathon, which I hope most of you are, you'll find a cheat sheet being posted in the discord, in the Global Discord by Sarah that has a lot of these links in there as well. So thank you for listening to this demo. I hope this was very helpful for you. Tried to compact it all in the time that I had, but yeah, this is the team and if you see us around, feel free to message us on Discord Slack and in those forums and we'll be active and monitoring your questions during this hackathon. So thanks.
00:43:30.150 - 00:43:57.700, Speaker A: Awesome. Thanks so much, Doc. Just jumping in for Kartik, but thanks for running all through all that. And I think also sticks out to me is how much of is very familiar to just writing typical Ethereum smart contracts with just dropping in some different nomenclature and different addresses. So really cool to see and excited to see what everybody builds. Yeah, thank you so much for that overview, Zach.
