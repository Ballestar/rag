00:00:06.730 - 00:00:28.070, Speaker A: Up next, we have kelvin, and kelvin's going to be talking about smock. And I'll let Kevin kelvin introduce what smock is. But I'm already excited about the talk title, and I'm also glad that kelvin used a 2007 plus version of Microsoft word instead of the original. So without further ado, let's welcome kelvin.
00:00:32.720 - 00:00:33.324, Speaker B: Here we go.
00:00:33.362 - 00:00:35.708, Speaker A: Let's give you turn video on, and you can get started.
00:00:35.794 - 00:00:55.520, Speaker B: Kelvin all right, cool. Fantastic. So let me share my screen. Where is this? Okay, sharing. Perfect. Let me make sure I can see the comments just in case. Great.
00:00:55.520 - 00:01:34.030, Speaker B: All righty, so hello. Hello. I'm kelvin. And today I'm going to present to you smock. Smock is a tool that well, it's the solidity mocking library, and it's a tool that we originally built over at optimism last year to sort of simplify our smart contract development process. And today we've evolved, and we've created a v two in collaboration with DFI wonderland. And we would like to present it to you and hopefully see if you can get something out of it.
00:01:34.030 - 00:02:00.600, Speaker B: Let me make sure they're actually showing up. Where are we? There we go. Got the twitter handle for optimism, got the twitter handle for DeFi wonderland, and you've got my twitter handle. So first things first. I want to set the scene I want to set the scene for you and for why you need smock in your life. This is you. You are a smart contract developer.
00:02:00.600 - 00:02:41.584, Speaker B: You are a very smart, smart contract developer. You are a big, brain, gigantic, brain smart contract developer. And as such, you sit on your very expensive, very powerful 2013 MacBook pro, and you spit out smart contracts into the ether. Now, spitting out smart contracts into the ether is a very dangerous activity. You need to be very careful when you do this. But you are a big brain, smart contract developer, and you know that what you need is you need well tested smart contracts. So let's talk about testing.
00:02:41.584 - 00:03:15.628, Speaker B: How do people usually test their smart contracts? Well, they might do a little bit of this. They do some JavaScript, and they might do some calls and some assertions. They might do a little bit of this and some calls and some assertions. And then they sit there, and they put a little checkbox on their contract, and they say, it's safe, it's perfect, it's beautiful. But as you can see, this is a single small brain smart contract. But you, as the legitimate DeFi developer, you don't build these small smart contracts. You build real smart contracts.
00:03:15.628 - 00:04:18.176, Speaker B: You are a big brain DeFi developer, and you only build the biggest of brain contracts, right? So when your smart contract systems start to get bigger and start to get a little more complicated, it gets harder to effectively test your contracts. So you need to evolve with it, and you need to become a big brain DeFi contract smart contract tester. So how does this work? How does Smock make your life easier? Well, let's first talk about what Smock is through an example. I'm going to talk about a very specific example of how Smock functions and why it might be useful and sort of get you to sort of bring back dark memories from your past about difficulties that you might have had while trying to test smart contracts. Because I've definitely had these dark memories blocks deep in my brain. Smock is the solidity mocking library. The solidity mocking library.
00:04:18.176 - 00:04:37.316, Speaker B: There is no better. It allows you to write better tests. That is a key feature of Smock. Why do you need it? Let's talk examples. This is you. This is you, big brain testing creature. And you're going to write some smart contracts.
00:04:37.316 - 00:05:04.444, Speaker B: You're going to start with writing a small smart contract and then you might write a big smart contract. And you want to test how these things work. You want to test them individually. You want to test how they work together. You throw out words like unit testing and smoke testing and integration testing and whatever, all these different testing things. But ultimately you want to make sure that your system works or people might lose money, which is a big problem. So let's throw an example on this specifically.
00:05:04.444 - 00:06:08.950, Speaker B: Let's talk about something reasonably complicated. We're going to talk about a Merkel AirDrop. Do you know what a Merkel AirDrop is? It doesn't make a difference. The point is something reasonably complicated that people can kind of comprehend, right? So let's say we have a Merkel AirDrop and then we have a recipient of a Merkel AirDrop, right? So how would you go about testing the Merkel AirDrop contract? Well, you might do some stuff like you're going to have to create a Merkel tree and you're going to have to hash a bunch of stuff and you're going to have to deploy the contract. And then you're going to have to publish the Merkel root and you're going to have to test if you have a balance and all this, right? So it's a ton of effort, but you need to do that in order to effectively unit test your smart contract. But how are you going to test another contract that interacts with your Merkel AirDrop contract? How are you going to do that? Because you want this, right? This is the ideal end result. The ideal end result is that your recipients get their money and they can go off and do stuff and they can spend it on yams or whatever they want to spend it on.
00:06:08.950 - 00:06:53.652, Speaker B: And you don't want this, right? You don't want the AirDrop to just fall on the floor because no one can get their money. And you just whatever. It's a whole headache, right? How are you going to test this? Well, let's talk about this other character, right? This other AirDrop recipient. Think about how you might test this AirDrop recipient. Well, there's the AirDrop recipient. The answer to this question is basically for most people, if you think about it, you'd have to basically perform the entire testing process that you already performed for the first contract, right? In order to test if this person is going to get a balance, you have to go and you have to create this merkel AirDrop contract. And you got to go and set it up.
00:06:53.652 - 00:07:14.376, Speaker B: You got to do this. You got to load the whole contract. You got to deploy it. You got to do all this setup, right? This is a huge headache. So how do developers actually do this in practice? How have they been doing this? They've been writing these fixtures, right? All these fixtures. And then you get fixtures inside of your fixtures. And then you get fixtures inside of those fixtures.
00:07:14.376 - 00:07:46.420, Speaker B: And it keeps going until at the very bottom there's a Bose Einstein condensate of fixtures. And all matter is just fixtures. This is bad. What you really want is you want smock. So how does smock fix your problem? Smock means you don't need to load anything. Smock means you don't have to do all of this junk setup that you on, all this fixture code that just completely pollutes the code base. And you can just get straight to the AirDrop.
00:07:46.420 - 00:08:00.360, Speaker B: Straight to the AirDrop. And how do you do that? Through the power of mocking. We love mocking. Mocking is a beautiful thing. So let's talk about it. Let's talk about how this tool actually works. Now, you have a scenario.
00:08:00.360 - 00:08:32.624, Speaker B: You want to test a contract that interacts with a much more complex contract. But you don't want to set up the entire complex contract because that's a huge headache. So how does this actually work? How are we going to make this happen? Well, Smock gives you two primary tools. Gives you fakes and it gives you mocks. So first we're going to talk about fakes. This is what it looks like to create a fake with Smock. So you can see here, hopefully people can see my little mouse.
00:08:32.624 - 00:09:05.376, Speaker B: If you can't, you can see here that we are going to import Smock from Smock. DeFi Wonderland is where we're hosting the NPM package, where we're hosting this. You get it? And then it's really straightforward. This is a hard hat plugin. So you get this beautiful syntax where I can just say smock fake and then the name of the contract. And now I have a fully fledged fake version of my contract. That contract doesn't have any real code, but it has a real address.
00:09:05.376 - 00:09:48.744, Speaker B: And if you make calls to that contract address, you are actually going to get back real results. So, for instance, I can make let's say this fake has a function called Bark, and I tell Bark to return woof. If my smart contract calls that fake contract, it says fake contract Bark or whatever contract Bark, it's actually going to return woof. When you run the tests in the EVM. So it hooks in to the EVM in hardhat, the hard hat EVM at a low level. And so it really simulates that there is a smart contract there and you can make it do whatever you want. You can even do these beautiful assertions, this nice syntax.
00:09:48.744 - 00:10:29.380, Speaker B: If you use these Smock matchers, you can get this nice syntax and even make assertions that your mock was called with a specific input data. This basically just removes all of the need to do all this setup, right? I don't need to set up my Merkel AirDrop anymore. I just create a fake version of the Merkel AirDrop and I just give myself a balance in it. I just say the balance of me returns however much I want. What crazy. So the docs are at Smock readthedocs IO and inside those docs you're going to find some really cool things as to what you can do with these fakes. So pretty straightforward.
00:10:29.380 - 00:11:05.664, Speaker B: One thing you can just do is have it return default values. Default values, it's all zeros. So if the function is called Get address and it returns an address and you just return like this, it's going to return the zero address. You can also make it return fixed values. You can make it return a given address, a specific address, or you can make it return a number depending on what the function expects to return. You can also make the function revert. This is really useful if you want to test cases where, okay, this one thing went wrong and I want to make sure that my contract behaves properly.
00:11:05.664 - 00:11:32.050, Speaker B: But think about you have to do all this weird modification to your other smart contract to be able to get it to revert and to get into that specific state where it's going to trigger that one specific revert. No, get rid of all of that. It's just going to return the revert message that you expect. And you can test the behavior of your contract. Fantastic. You can make a revert with a string, you can make a revert with bytes. You can make a revert with whatever you want.
00:11:32.050 - 00:12:00.724, Speaker B: But here's where it gets more interesting. You can also make it return more complex structures, right? So we have support for Structs. You can make it return Struct. You can make it return arrays, right? So these are really interesting data structures beyond just the basic ones. You can even make a return dynamic values. You can stick a function inside of the return and this function can return whatever you want. And look at this.
00:12:00.724 - 00:12:24.704, Speaker B: So it could randomly return one value or the other value. I wouldn't recommend doing this in practice, but you can definitely have a more complex piece of logic inside of this return function. This return function could even be asynchronous. You can go call. You can make an Http request inside of a smart contract, which is a little insane, but only during testing. Don't try to do this in production. It won't do anything because that doesn't make any sense.
00:12:24.704 - 00:13:12.290, Speaker B: But in testing you do whatever you want. Fantastic. And you can even use the arguments that were provided to the function inside of the function that you are triggering. So for instance, if I had a function that took a UN as an input and I wanted to return whatever the input is times ten, I can do that. I can just have it take the input to the function and multiply it by ten and I'm going to get my output value and it's just going to return what I expect. Essentially, I have these beautiful things written in JavaScript that can do whatever you could possibly imagine to make your testing life easier. You no longer need to set up your contracts to be in this very specific state.
00:13:12.290 - 00:13:42.980, Speaker B: Fantastic. So fakes already get you really far. Fakes are a beautiful thing, but I have to tell you, there is something beyond fakes. There's something even more beautiful than fakes, and that of course is mocks. Mocks are fantastic. And let me tell you a little bit about mocks inside of Smock. Smock mocks are like fakes, but they're backed by a real smart contract.
00:13:42.980 - 00:14:38.190, Speaker B: So this means that you deploy your smart contract and you essentially have the ability to manipulate your smart contract after it's been deployed, which can be very useful. So a basic feature that you have with this mocking ability is call through, right? By default, when you call your contract, it's a normal contract. It's a standard solidity smart contract. It's going to behave just like the solidity code that you wrote, but you can also manipulate it. So let's say by default I have an add function and I call Count and it's going to return ten, whatever, right? And this is because there's actually solidity code running, but then I'm going to say, okay, but for now I actually want to make Count return one. And now Count returns one. Easy, right? Beautiful.
00:14:38.190 - 00:15:08.324, Speaker B: But there's more. And now let's see if this works because I animated this by hand in PowerPoint drumroll. There we go. You can set the value of a variable. This is where the game changes with MOX. You can completely manipulate what's happening inside of your smart contract. You can set the value of any variable to whatever you want.
00:15:08.324 - 00:15:42.930, Speaker B: Look at this. My variable name is being set to 1234. I can set the owner of my contract so I don't have to do all this. What if there's a bunch of complex logic that I want to test that's based on an internal variable being something? Well, I don't want to do all the complex logic to get the internal variable to be equal to that value. Right? There's a huge amount of effort that goes into this. You don't need to do that anymore. You just say, okay, well I'm going to test the case where this internal variable is equal to 1234, and I want to see how my contract works when the internal variable is equal to 1234.
00:15:42.930 - 00:16:21.820, Speaker B: But there's more. You can even set the value of a struct or a mapping. You can set the value of whatever you want. You can set a value of a nested mapping. You can change literally anything inside of your smart contract and make it possible to test every tiny little interaction without mountains of boilerplate fixture code that somebody's going to have to maintain for the rest of time. This is how you should be writing your smart contracts. And if you're not writing your smart contract tests this way, you are missing out on a deep and satisfying tool.
00:16:21.820 - 00:16:44.620, Speaker B: Tell you that this is you after learning about Smock. This is the entire universe after learning about Smock. And this is Smock. So there you go. Smock is all there is. The entire world is now just Smock. So how do you get started? Well, it's pretty straightforward.
00:16:44.620 - 00:16:57.424, Speaker B: Defiwonderland smock on NPM. The code is available, GitHub.com slash defiwonderland slash Smock. And the docs are at Smock readthocs IO. It's quite intuitive. The docs are good. The code is pretty straightforward.
00:16:57.424 - 00:17:33.580, Speaker B: It's got a really nice API. Shout out to the DeFi Wonderland team for really cleaning up the API and I really recommend that you check it out. You try to write a few tests, especially for your more complicated smart contracts, and get a feeling for just how easy it is to build great tests when you're using smart. And, of course, I'm going to throw this in there. Optimism is hiring if you're bored of your Web two job and you want to work on cool stuff like this. And there's the Jobs link lever, jobs lever, co, optimism. And that's my talk.
00:17:33.580 - 00:17:45.770, Speaker B: Pretty straightforward, pretty short, but I hope you enjoyed it and very excited to see all the new people who are now going to use Smock forever and always. Thank you.
00:17:47.020 - 00:18:19.692, Speaker A: Thank you so much, Kevin. I'm still just laughing through all the incredible stuff that you got in this. The drum rolls kill me. It's really good. One final plug for everybody. For the sake of everybody following up, what is the URL? To learn more about Smock, the website, the GitHub package, all these things in one off slides, but tell us where people can go to use it immediately.
00:18:19.836 - 00:18:36.790, Speaker B: Yes, I would recommend starting with looking at the GitHub. It's got instructions on how to get started and it's got links to everything you'll need to know. So GitHub.com D five, Wonderland Smock will have everything you need to get started.
00:18:37.320 - 00:18:53.470, Speaker A: Awesome. And one last question before we close today is obviously you've been working on this thing for a year and there are a lot of people that are using this, but what does the future of the Library look like? What are some features or additions or things it's not good at that you want to do. Just talk to us a bit more about that.
00:18:55.040 - 00:19:53.228, Speaker B: So the thing that I'm most excited for is we're planning a rewrite of the core internal stuff. Smock was originally uses a very hacky method to do what it does. It uses the fact that the ethereum JS VM emits things in events, and it turns out that emits objects by reference and you can listen to the event and then manipulate the thing that you receive in the event. And it will have an impact on the VM, which is really terrible. So what we are planning to do is a more comprehensive rewrite, which essentially involves a fork of the underlying DM instead. And the feature that I'm most excited for is the ability to directly test libraries. If you've ever tried to test libraries, you know that the standard pattern is you create these mock libraries that wrap those libraries and expose all the functions.
00:19:53.228 - 00:20:18.068, Speaker B: You can actually test them. And so in the planned sort of Smock V three, it'll be possible to directly test libraries with one of these contracts. So you don't need to keep writing this boilerplate mock code for your libraries. And you'll also be able to manipulate internal functions so you can, you know, my internal function is going to return whatever I want instead of just these external public functions.
00:20:18.244 - 00:20:21.284, Speaker A: Oh, that is incredible. It's like God mode for EVM.
00:20:21.412 - 00:20:23.000, Speaker B: God mode for EVM.
00:20:23.660 - 00:20:35.550, Speaker A: Cool. Well, thank you so much for that incredible presentation. We got to get you back on just so we can see what the next one would look like. Now you have to top yourself, if not at least meet the same expectations. But this was great.
00:20:36.720 - 00:20:37.516, Speaker B: Thank you.
00:20:37.618 - 00:20:55.600, Speaker A: Wonderful close to today's devtool summit. Thank you for hundreds of you for sticking all the way to the end. It's been six incredible hours of just back to back devtool showcases and talks. So I can't wait for the next version of this summit. It ourselves. All right. So incomplete.
