00:00:06.330 - 00:01:06.530, Speaker A: My name is Alexey or Cloudhead. I'm one of the founders of Radical, which is a stack for peer to peer code collaboration, sovereign code infrastructure and Microsoft's. Okay. And yeah, today I'm just going to kind of talk about how it works, how to use it, what we've got, what's coming up, et cetera, and try to fit everything in 30 minutes. But if you want to know more, you can go on Radical Network. I'm basically going to sort of go through the get started stuff with a little bit more and some explanation of how everything works. So first of all, what's the idea? So the idea is essentially to create a decentralized alternative to something like GitHub.
00:01:06.530 - 00:02:09.474, Speaker A: So a way for developers to collaborate on code and to publish that code in a distributed peer to peer way. And so to achieve that, we create an architecture that is quite a bit different from the traditional client server architecture. And I'm going to talk about that a little bit. But first I wanted to just kind of actually go through the steps in creating a radical identity and project and all that stuff, just so you kind of get an idea of how it works. And then I'll explain a little bit the actual architecture of it, the design and inner workings. So the first thing is the way to set things up is via CLI. So that's kind of the onboarding we do is via CLI.
00:02:09.474 - 00:02:57.202, Speaker A: So I've already installed this because otherwise you would have to wait ten minutes for it to build. But essentially there's a brew package that's slightly always behind Master and then you can also download from source. So I have this installed locally and it's called Radical. And if we just type it like this, you'll see a list of commands and it's also going to tell us that this is the first time we're using Radical. So to get started, type Radbots to authenticate. So I'm going to do that and this is essentially going to ask me to create an identity. And these identities are completely owned by the user, so they live on your own device and then they can be replicated to other devices.
00:02:57.202 - 00:03:41.220, Speaker A: So you kind of own this forever and I'm just going to fill this in. And so this is going to create a key pair. And so the passphrase is really a passphrase for the key pair. So the private key is encrypted and it's telling me, okay, like you have a peer ID, which I'll explain, but essentially it identifies this device. So my laptop in this case and a sort of personal Urn, which is multi device. So it's kind of my user ID that is across devices. Then it's telling me, okay, you can initialize a Radical project from a Git repository with Rad in it.
00:03:41.220 - 00:04:21.710, Speaker A: And so what I'll do is, so I have this folder here with a bunch of stuff and I'm going to git clone one of my projects from GitHub. So do this, and I'm going to initialize a radical project from this GitHub project, essentially, so you can clone any Git repo. We're going to go inside of it, right? Just a regular git repo. And then I'm going to call Rad in. It just going to go back here and project name. So this project is called RX. It's a pixel editor written in Rust.
00:04:21.710 - 00:04:49.900, Speaker A: Cool. Ask for default branch master. All right, it's going to initialize this. Now. It's going to ask me whether I want to use my radical signing key to sign commits. And I'm going to say yes, because this is going to well, we can do pretty cool things when we use our radical key for signing commits, like link it to Ethereum, to the rest of the radical ecosystem. So I'm going to say yes, you don't have to.
00:04:49.900 - 00:05:29.702, Speaker A: And okay, so the project is created. It's giving me a project ID, which again is in the form of a Uran, Rad Git, plus some unique Identifier. And I can always show the project ID like this. And I can also now push this project to some remote let's see what this says. Okay, you can see this. So it's essentially saying, okay, select a seed node to sync with. And these are essentially remote servers that kind of constitute a peer to peer network, and users can choose where to push their code.
00:05:29.702 - 00:06:04.642, Speaker A: And you can also have your own seed node. But since that's not set up here, the CLI asks you if you want to push to one of the sort of public nodes that we operate ourselves. The foundation operates. So I'm going to pick a node I might have already. No, yeah, I'm going to pick this node. And so it's going to do its thing. A couple of things in the output here, we're using again this radical key, which is also an SSH key.
00:06:04.642 - 00:06:47.306, Speaker A: So it's compatible with all sorts of SSH things. Okay, syncing the project ID. We see that it's syncing it to this seed node here. And then when it's done, it's telling us that we can view this project online through a web interface. So I'm going to copy this into the browser I have here so that we can check it out. So this is the project. This is essentially a web front end to the radical network.
00:06:47.306 - 00:07:41.946, Speaker A: And the interesting thing about it, and it's kind of hard to see, but the code here is actually being loaded from the seed node I pushed to. So this web front end has actually many back ends in the sense of any seed node can operate as a back end to this web front end. And you can actually see here it's going to look very small, but the seed domain name is up here, and I can put any seed in here. And it's just going to load it up and show me the code from there in the interface. You kind of also see if I zoom in the name of the seed here, which is telling me, hey, the source code is actually being fetched from this seed. And if I click on this, I'm actually going to load the actual seed node. So this seed has a lot of projects.
00:07:41.946 - 00:08:22.780, Speaker A: It has the one I just pushed, I was testing the demo. So it's kind of two separate projects with the same name, but there's a lot of stuff on here, right? And if you go to, for instance, on the main page, you can see that we have our seed nodes here, the ones you could choose from, and we can browse them. And if I go to this test project, it says it's loaded from here. And so all of the data is coming from that different seed node. So you can have your own seed nodes that host your own code and it all kind of interrupts with the same UI. All right, cool. Any questions so far? Otherwise I'll keep going.
00:08:22.780 - 00:08:54.280, Speaker A: Yeah, if that seed node goes down. So, I mean, obviously you have your code on your machine also. Ideally, you can also push to multiple seed nodes. There's nothing wrong with that. And we're also working on a peer to peer network for seed nodes to replicate data asynchronously between them. So, yeah, the idea is that your code is going to be in a bunch of different places. Cool.
00:08:54.280 - 00:09:26.034, Speaker A: Yeah. So let's go back here. So let's look a little bit at how some of this works. So Radical is obviously it's based on git. And we use git not just for code like developers, but we also use it to store all kinds of artifacts. So things like these identities that I spoke of. And so, yeah, let's look at what that looks like.
00:09:26.034 - 00:10:16.574, Speaker A: So I'm inside this project RX, right? We saw that if you do Rad dot, you can see the project ID. We can also do this is kind of just an alias, but we can also say, hey, let's look at the history of this project. And what this is going to output is not the source code history, but it's the history of this identity. And identities are super important in Radical because it's what lets you have projects hosted in multiple different places, but in an unforgettable way. Right. So if we compare this to the GitHub model or GitHub GitLab model, if you have the same project on GitHub and GitLab, well, there's no way to tell that it's the same project. Right.
00:10:16.574 - 00:11:09.294, Speaker A: They're two completely different it might be the same code in the same repository, but there's nothing that allows you to say that, oh, these are owned by the same person, or that the username on one system is the same person as that username on a different system. Right. So the Radical identities kind of solve this problem by shipping this document, which is just really a JSON document that is committed inside of Git but not in your source tree and is signed by the owners of the project or the maintainers. And so if we look at this JSON, there's this thing called delegations. And delegations is essentially signers. It's users who can sign on behalf of this project, essentially. And if I do Rad self, this is going to query my own user identity.
00:11:09.294 - 00:11:40.338, Speaker A: And you can see that my Uren matches the delegation here. So as the creator of the project, I am the first delegate, essentially. And then the payload is the stuff I filled in. So name, description, et cetera. And you can see here this key which kind of points to a previous version of this document. So these documents are upgradable and they work kind of like a multi SIG. So right now if I want to change anything about this project, I can just do an update because I'm the only signer.
00:11:40.338 - 00:12:46.500, Speaker A: But if there's multiple delegates, then we'll have to have a quorum of signatures to update the document and then a second document will exist that will point to the previous one. Cool questions? I'll keep going. Okay, so what are the other things I wanted to show? Right, so let's just look at our own documents, our personal document or identity. And so these are very extensible. So the format essentially has an extensions area where you can provide any kind of metadata you want with a certain schema. And so one of the things we're working on is for instance, associating these radical identities with ENS or with ethereum. I'm not going to go through the whole flow here because I would need like a wallet and stuff like that, but I can show some of it or like part of it.
00:12:46.500 - 00:13:32.458, Speaker A: So there's an ENS command essentially. And here it's telling us that the local identity. So this one up here is not associated with any ENS name, right? If I do something like if we just look at what we can do, there's a bunch of things we can do. And what we're working on right now is like having this setup flow which does a two way attestation between radical ENS and then ENS back to radical. This already works, but you need like an RPC node and stuff like that. So I won't do that, but I'll just show the local side of things and I'll use this command here to do Rad ENS set local. I use my ENS name and it's just going to ask me for confirmation.
00:13:32.458 - 00:14:33.650, Speaker A: And so now it's going to output essentially the new payload which has some extra information in it. And if we inspect my username again now you'll see that there is the original identity and then there's the new version of it that points to the that replaces the previous one here, right? And in here you see a separate payload that has an ENS name. We're using this to start building features that essentially link code with money or code with ethereum and on chain state, essentially. All right, cool. Let me just see what else I had in here. Not in here, but in here. So one thing I wanted to show was a little bit of how the architectural looks under the hood.
00:14:33.650 - 00:15:32.610, Speaker A: So I'm just going to open this thing and move it here. So what we've been looking at essentially is this part here, right, radical user. And we've been in our working copy, essentially. So this is just the checkout, the repository checkout. And the way things work, essentially, is that when you do a rad push that I did earlier, what it does really is it does a git push rad with a kind of rad URL. And we have a remote helper that catches that push and it actually pushes to a local repository we call the Mona Repo because it's a repository that stores all of your code across everything. Essentially all of your code, all storage, all identities are stored in this git repository that is local to your machine.
00:15:32.610 - 00:16:25.586, Speaker A: And all nodes have their own mono repository. And we use git as a transport and as a protocol to replicate things between nodes. Essentially what happened when I pushed is that first it copied the refs to this monorepo and then it did a rad sync, which essentially copies from the monorepo to a remote node. And so in this case, let's say this is like the maple seed node, for instance. All the git objects were copied to the other side. And on the other side, again, since it's just in the end git repository, it's fully git compatible. So a regular git user who doesn't have Radical installed could do a git clone or can do a git clone directly from that repository via a bridge.
00:16:25.586 - 00:17:42.560, Speaker A: And the reason we have a bridge is that this monorepo is not just a regular repo, it's sort of like a repo of repos. And I can show that a little bit if you guys are curious. And then to go back to the question that was asked earlier, on top of this, there's a peer to peer layer that's in development that essentially allows asynchronously replicates objects between different nodes according to a sort of tracking configuration. So essentially a node or a user can say, hey, I'm interested in replicating these five or these 20 or 30 projects, just keep in sync. And then as long as your demon on your computer is running, or whenever you activate Radical, it'll sort of synchronize with the peers it knows about and copy all of the reps and objects that you're interested in. Yeah, that's pretty much it. There's other capabilities already and lots of stuff we're developing, but if you just want to list projects you have radls, you can via the project.
00:17:42.560 - 00:18:33.120, Speaker A: Tracking is how you essentially collaborate. So essentially this is how you add peers to work with add and remove peers, which when you do that, essentially, it starts to track their changes. That's why it's called tracking. And so you have a remote for all of the collaborators on a project and you can manage that. And you can also list this is not going to show anything here because there's no one else on this project. But yeah, you can list remotes on various seed nodes when you're collaborating with someone. Yeah, I think that's about it.
00:18:33.120 - 00:19:35.620, Speaker A: We're pretty on time. If there's any questions, happy to answer them in relation to the hackathon. So we have a prize for someone who would implement the best subcommand on the CLI. There's lots of kind of things you could do, but just to explain how this works, essentially, it works like Git. If you have a command called like rad hello in your path, then typing rad space hello will invoke that command. So it's really just a matter of creating binary and executable in that format named something like this, that takes parameters and then it'll be picked up automatically by the CLI if installed locally. So it's extensible in that way.
00:19:35.620 - 00:20:07.760, Speaker A: Cool. Questions? Comments, concerns? No. All right. There is a question. Is there any incentive for hosting your own signals? We're working on it at the moment. There isn't, except if it's your own code, I guess, to just keep it available. But yeah, this is something we're interested in and we're working on.
00:20:07.760 - 00:21:00.138, Speaker A: Could you have your own push everything there just to be safe, and then maybe push also to some of the exactly. Yeah, exactly. And one thing that's maybe interesting regarding having a personal seed note is we use ENS to map between user identities and seed nodes. So you can let's say wait, that's not it. Let's say I go to Cloudhead radical ETH. So this is my Ethereum address, or Ethereum name under the radical domain. So this is automatically getting mapped to my seed node.
00:21:00.138 - 00:21:31.802, Speaker A: And so I can browse my projects here. Right. And so this is kind of how we're using ENS. One of the other ways we're using ENS to map between Ethereum and the sort of physical server world. So you have one of the ENS keys is called seed host. The key is a bit different, of course, but that's what it stands for. And that's how we can map between developer identities or.
00:21:31.802 - 00:22:27.704, Speaker A: Orgs and projects hosted somewhere. Yeah. No, I guess so. On the website there's a couple of things you can do. The main thing at the moment, the main thing is like if you want to register a name under Radical ETH, so an ENS name, the only advantage really over ETH is that they're kind of free forever. So you just pay once the TX fee and you have NES name forever, essentially. And then there's other things like we're reworking this, but I don't want to connect right now because I don't want to get docs, but you can essentially create orgs and stuff like that on here.
00:22:27.704 - 00:23:01.856, Speaker A: You can edit your ENS records. So like the page I had before this one here. Yeah. So there's an edit button. So you can edit all of these records from here also with your MetaMask or whatever. And what else? Yeah, there's more stuff coming up. Also we're going to have the ability to sign in with Ethereum on a seed node to be able to essentially take actions as that node.
00:23:01.856 - 00:23:59.510, Speaker A: So do like server side authenticated actions and things with also monetization, so sending money, receiving money, stuff like that. We have a team working on something called Drips, which are essentially money streaming and yeah, that's going to be part of this also. It's for all the Ethereum stuff, essentially. Do you want to say whether all of this Ethereum stuff is basically the name, registration.org, management and money? Yeah, that's kind of what I said, right? Names, orgs and incentive related things, funding, et cetera. I don't know if there's really anything else. Yeah, we have Ignosis safe integration also for so there are certain things you can do with that.
00:23:59.510 - 00:25:05.928, Speaker A: Is there a chance that these repositories, you could just the data, right? Could you address them on IPFS and then use IPFS nodes instead of like put them on IPFS? Yeah, you can do that. The reason we don't do that by default is that it's not very efficient because the representation IPFS is like, IPFS is good for big files, essentially, or it's best for big files. When you're representing a git repo, it's like thousands of small objects and the git protocol is optimized for that. So the git protocol is an interactive protocol. So when you connect to a node sorry, when you connect to a git remote and you pull or you push, you're going to have a negotiation phase where it's like, hey, these are the objects I have. And you're going to ask the other node what objects it has. And then the remote will create a pack file, which is like a compressed archive of only the things you don't have on the fly and send you that.
00:25:05.928 - 00:25:48.200, Speaker A: And then you're going to open that pack file and apply the updates locally. And that's something IPFS can't do, right? It has some optimizations, of course, but it's really not nowhere near as fast and good for that use case. We tried it actually a while ago. Yeah, good question. Is it possible to maybe extend git functionality to include this stuff on top of it, or does it not work? It's not really needed. I mean, we are sort of extending git's functionality but without modifying git itself. So this is actually something I wanted to show briefly.
00:25:48.200 - 00:27:09.950, Speaker A: Yeah, if I do this, I can see sort of the actual git refs that are stored for this project and you'll see these regular git refs that all repositories have. So essentially, your branches are stored this way, but then we have a kind of subdirectory under Rad, and we store other things, like the identity, the related identities, a pointer to your own ID, and then a document with all of the signatures for all of the reps, essentially. And so it's quite powerful. There's a bunch of things. For example, for configuration, we use git, too. Like, so the the default seeds that you're using for a project is stored under Git. Under the Git configuration, essentially, git is already really extensible, and so we're actually not at a point where we've hit any barriers or any issues with that.
00:27:09.950 - 00:27:20.370, Speaker A: Yeah. You all right? All good. Thank you all.
