00:00:11.810 - 00:00:55.854, Speaker A: All right, everybody. My name is McLean Wilkeson, one of the co founders of New Cipher. We are a data privacy layer and access control layer for Ethereum applications. Our sort of reason for existing at the company is to build the developer tools, the infrastructure that make it super easy for all of you all to build privacy preserving applications, protocols, and tools. And we really work on two core pieces of technology. One is our new cipher network, which I'll talk mostly about today. And that's just a way to provide decentralized access controls for your DApp.
00:00:55.854 - 00:02:05.178, Speaker A: So a way to build end to end encrypted applications on top of Ethereum and other smart contract platforms. And the other is some longer term R and D that we do in lattice cryptography, and specifically, or mostly in fully homomorphic encryption. But the new cipher network itself is a decentralized access control network that uses something called Threshold proxy re encryption. And the obvious question to ask before we even get started is, why can't you just use traditional asymmetric cryptography or traditional public key cryptography to basically take care of all the confidentiality and privacy in your application? Obviously, traditional vanilla asymmetric cryptography is very well understood. We have this traditional Alice and Bob narrative where Alice has some secret message or secret data that she wants to share with Bob and no one else. So all she has to do with public key cryptography is just encrypt that message with Bob's public key. She can send that message across the network to Bob, and he, using his own private key, is the only one who can actually decrypt that data and read it.
00:02:05.178 - 00:02:52.902, Speaker A: So this is very well understood, very easy to reason about, very secure. Where it gets a little bit murkier is if we start to extend this into the context of an application. So if we take Current Web today, almost all of these popular web services we use from Google, Dropbox, Amazon, Facebook, are really predicated on this idea of server side decryption. This is because most useful applications are multi user. So if Alice uploads some encrypted data to Google, there's not really any way for Google to share that data with Bob or Charlie, unless either Alice gives that person her private key or unless the data gets all decrypted server side with Google. And maybe it's okay. Maybe.
00:02:52.902 - 00:03:43.042, Speaker A: We trust Google. We trust Amazon. We trust Facebook. For a lot of us here at ETHGlobal, probably not, but we certainly don't trust some of the people that are trying to break into these servers, whether they're nation state hackers or just malicious cybercriminals or black hat hackers. And if we take it to sort of Oops, well, you can't see them, but they're supposed to be giant picture versions of these small little guys here. I guess the lighting is not good enough. But if we take to the next logical step of decentralized applications, we can't have anything decrypted server side that's sensitive, because this could be a server or a node that's under the control of one of the people we're trying to protect that data against.
00:03:43.042 - 00:04:38.766, Speaker A: This could be an IPFS node in Iran. It could be an ethereum node in Russia, for example, basically need to have some way to protect the data from the minute it leaves Alice's premises to the second it gets to the intended recipient and never exposed anywhere in the middle. So if we were to try to build some sort of access control network using just traditional public key cryptography, basically that would mean that all the nodes in the network are having to decrypt data from Alice, encrypt it again for the recipient, and send it along. So that means every node in the network has access to the plaintext data. That means any node, if it goes offline or just wants to deny somewhat access, can do that. Some of you might be familiar with this idea of Shamir's secret sharing. So we can improve upon this situation a little bit by splitting the private key up into a bunch of shares and issuing those shares out to different nodes in a potential access control network.
00:04:38.766 - 00:05:32.118, Speaker A: And this is an improvement because no one node can access the data or no one node can deny access. But we still have this problem that a sufficient number of the nodes can collude in order to decrypt the data or deny access. So at New Cipher, we use something called proxy re encryption to sort of close that loop so that everything is encrypted from Alice to Bob and not decrypted anywhere in the middle. And what proxy re encryption allows us to do is it allows Alice to use some untrusted proxy to re encrypt or re key the data that is originally encrypted under her key into being encrypted under Bob or Charlie or Dave or Evan's key. And sort of the magic about proxy re encryption is that this re encryption or this re keying happens without ever decrypting the data in the middle. So the proxy only ever sees encrypted data. It never sees plain text.
00:05:32.118 - 00:06:01.370, Speaker A: The storage layer only sees encrypted data. It never sees plain text. And just to sort of maybe help you understand that a little bit more, we have this little video example here. Let's say we have an Alice that has a bunch of private data. In this case, let's say it's financial data in Excel, she wants to encrypt that data and upload it to some remote storage. So she encrypts it on her client. She uploads it to s three or IPFS or Swarm.
00:06:01.370 - 00:06:26.194, Speaker A: At this point, she's the only one who can access that data. If Bob tries to use his private key to access it, it's not going to work. He has no way to actually decrypt the data. So that will fail. But let's fast forward a couple of days and let's say Alice decides after all, she does want to share this data with Bob. What she can do is she can create something called a re encryption key. And a re encryption key has two inputs.
00:06:26.194 - 00:07:05.890, Speaker A: The first is her private key, and the second is Bob, the recipient's public key. But there's no way to actually get these two inputs back out. Once you've created the re encryption key, it's a one way function. So she can give this re encryption key to a proxy or some node in the new cipher network, and that node can use this re encryption key to take the data that was originally encrypted for her and re encrypt it so that it's now encrypted for Bob. And in the new cipher network, nodes basically get paid for this work. And once that re encryption has happened, bob can take that re encrypted ciphertext, use his own private key to decrypt it. So the proxy never sees the data.
00:07:05.890 - 00:07:54.240, Speaker A: The storage layer never sees the data. Just Alice, who obviously, is the original data owner, and Bob, who is her intended recipient. And the other nice thing is, Alice and Bob, their private keys always stay with them, so they're not passing around private keys. So this sort of vanilla proxy encryption that we just talked about gets us pretty far in building an access control network, because now no node has access to the data. But there is one problem in the sense that we have one re encryption key with one node. Which means that if that node goes offline, either because for no fault of its own, it loses power, it gets DDoS, or it's maliciously denying people access. If that node goes offline, Bob, the recipient is going to have no way to get the data.
00:07:54.240 - 00:08:39.120, Speaker A: So we want to build in some degree of redundancy, some degree of greater collision resistance. And what we do for that is we use a threshold proxy re encryption scheme that is actually very similar to Shamir's secret sharing. But instead of splitting up the private key into a bunch of shares, we split up the re encryption key into a bunch of shares. So in this case, we just split the re encryption key up into five shares. As long as we have three of those shares, the re encryption will be successful, and Bob will be able to access the data. So that, effectively, is what the new cipher network is. It's a network of these proxy nodes that are accepting re encryption key shares on the behalf of Alice.
00:08:39.120 - 00:09:17.100, Speaker A: They're enforcing potentially any conditions, such as time or payment, that she wants to impose on that sharing policy, and then they're re encrypting ciphertext for Bob. So we've kind of introduced a couple new characters into this traditional Alice and Bob cryptography narrative. The most obvious one is Ursula. And Ursula is what we call the proxy node. So if you're writing an application for new cipher, you're going to be using these Alice and Bob characters. If you're running a node in the new cipher network, you would be using the Ursula character. And then we also have this fourth Enrico character, which is the data source.
00:09:17.100 - 00:09:34.944, Speaker A: In many applications, Alice and Enrico are going to be the same character. I'm producing data. I'm the Alice the data owner. I'm the data source as well. But in other applications, it's useful to kind of delineate between Alice and Enrico's because there could be many data sources. Let's say I'm an Alice. I have a lot of data sources.
00:09:34.944 - 00:10:14.464, Speaker A: I have my watch, I have my smartphone, my laptop, my email account. All of those are Enrico's. In the new cipher narrative, if you want to be one of the Ursula nodes in the new cipher network, basically we require nodes to stake the new cipher token as a kind of bond or collateral. So this is basically a work token that we use to allocate work within the network and to coordinate the network. So let's say you staked 5% of the new cipher tokens. You would get 5% of the re encryption work. If you do that work correctly, you would get 5% of the compensation and the payment for that work.
00:10:14.464 - 00:11:11.110, Speaker A: It is also a way to make sure that nodes behave correctly. So if you're an Ursula node and you decide you're not going to do your job correctly, you're just going to give me random garbage gibberish instead of properly reencrypting, anyone can submit basically a cryptographic proof that that re encryption is incorrect and you would get slashed and forfeit your stake. So it's an economic incentive for nodes to behave. So we have this heartbeat demo that I'll walk through in a second, and I think it's very nice because it kind of clearly illustrates all of these different characters and what their roles and responsibilities within the network are. So we have an Alice who is the ultimate data owner or the policy owner. We have this heart monitor which is we would consider an Enrico in the new cipher network. It's producing data, in this case, Alice's heartbeats, and encrypting them under Alice's public key.
00:11:11.110 - 00:11:50.370, Speaker A: In this demo, we'll just save the data locally, but in practice, you could use any storage layer. It doesn't matter. New cipher is agnostic to whether you use Swarm or IPFS or S Three. And then we also have a Doctor or Alice's doctor who is a Bob. So this is the recipient that Alice is going to grant or delegate access to her heartmain monitor data to. And then Alice will issue basically a sharing policy to the new cipher network, saying, hey, I want Bob to be able to access my data. Bob will interact with the new cipher network to get this data here, re encrypted for him.
00:11:50.370 - 00:12:30.214, Speaker A: Let's see if I can get my demo terminal to show here. Oh, there we go. This is going to be tricky because I can't actually see it on my computer. I'm going to have to turn around to look at the screen here's.
00:12:30.362 - 00:12:31.460, Speaker B: Okay, so.
00:12:35.300 - 00:12:36.288, Speaker A: First thing that we're going.
00:12:36.294 - 00:13:28.084, Speaker B: To do is I'm going to spin up a couple of these proxy nodes just locally from my machine. So I have this run only demo Ursula script here that we'll start with. And that will basically give us our first proxy node running here locally. Basically each Ursula or each node in the network will have their own unique node name here. So this one is so that's the first node. So right now network not especially useful. So we'll spin up a couple more nodes in that one.
00:13:28.084 - 00:13:35.908, Speaker B: We'll run this by the way, I'm.
00:13:35.914 - 00:13:36.896, Speaker A: Just running all this locally.
00:13:36.928 - 00:14:33.280, Speaker B: But we do have a DevNet, which all of you can use network out there in the wild, but it's just WiFi and things like that. This script will create five or six more proxy nodes. They will connect to that initial node that we spun up, learn about it, it will learn about them and then we'll all learn about each other. If we switch back first Ursula, we should some of the others. So now we have a network of, I think seven Ursulas that are running here locally, my machine. And they're ready to basically accept policies, sharing policies on behalf of users. So we'll jump up to the Alice Alicia PY file here.
00:14:33.280 - 00:15:08.930, Speaker B: And this is just a script basically that we'll use to create this. We'll skip a lot of this stuff. This is just so let's create our Alice. What we'll do first is we'll try to see if there is an Alice already exists. Let's save the disk. There's not scratch. So this is new Alice we're creating from scratch here.
00:15:08.930 - 00:15:54.218, Speaker B: We're going to tell her to connect that network of versus. And we have this thing called weakness call learning right now, which is the thing we use for node discovery. Cypress network. Instead of using like deadpool appropriate for layout, we'll create a label. So now Alice have an Alice. She has some data that she wants to share with someone. So in new Cipher we have this concept of labels.
00:15:54.394 - 00:16:19.090, Speaker A: And you can think of it kind of like a file path or directory. Alice might have a bunch of data. So she has email, she has text messages, she has snapchat social media. She doesn't want to give Bob access to everything. She just wants to give Bob access to this heart data. So she'll make this heart data label. She will create basically a policy public key for that label.
00:16:19.090 - 00:17:11.082, Speaker A: And this is the public key that all the heart data is going to be encrypted under. So when the Enricos data sources are creating data, it's all going to get encrypted under the policy key here. We're just going to generate a bunch of test or dummy data for the purposes of the demo and we're going to encrypt it under that policy key. So now we have a bunch of encrypted data and now we can fast forward a little bit and Alice could say, okay, I want to share my data with Dr. Bob. So what she needs for that is, if you remember from earlier in the presentation, a re encryption key consists of Alice's private key or the policy's private key in this case, which obviously Alice has and the recipient's public key. So we need some way to get the recipient's public key, and we'll just assume it happens through some side channel.
00:17:11.082 - 00:17:40.750, Speaker A: Maybe she went into the doctor's office and he gave his public key there. So we've got the public key, we'll initialize a Bob the same way we did an Alice. And then we don't want to just give Bob access forever. So we're going to create some conditions, and these can be any arbitrary condition that you want. In this case, we're just going to set an end time for the policy. So after, in this case, five days, bob is no longer going to have access. The access is going to be revoked.
00:17:40.750 - 00:19:11.004, Speaker A: And we're also going to set these threshold, m of N values and the M of N values are basically the number of shares that we're going to split the re encryption key up into. So in this case, we have M of two and N of three. So we're going to take that reencryption key, split it up into three different pieces, send those three different pieces out to three different nodes in the network, and as long as two of them properly reencrypt, bob should be able to access the data. So we have that policy, we'll call this Alicia Grant function method to actually issue it out into the network. And if that works, we should have this policy living out on these Ursulas that we previously created. So you'll see a similar thing. Alice has to learn about the nodes similar to how the nodes learned about each other.
00:19:11.004 - 00:19:37.492, Speaker A: As soon as she learns about three of the nodes, she'll be able to send out her three re encryption key shares and it printed out. Done. So it looks like everything worked. She had the access policy created for Dr. Bob. And assuming that did work, bob should be able to then go and ask the network to re encrypt for him. So we have a similar kind of script for Bob here that will sort of show how to do that.
00:19:37.492 - 00:20:14.190, Speaker A: We'll skip some of the setup stuff similar to how we initialize an Alice, we'll initialize a Bob. So this is the receiving character. We need Bob to join the policy that Alice is issued out to the network. So basically use that label. The label is basically the name of the policy that Dr. Bob is going to join. So he'll join that policy.
00:20:14.190 - 00:20:59.964, Speaker A: He'll check that, he'll use Alice's signing public key to verify that the policy is actually created by Alice. And then he will go and fetch all of the encrypted data from whatever storage layer it's in, whether it's Amazon, S three or IPFS or Swarm or Rweave, any where new cipher network is agnostic to where the data is stored. So he'll fetch that. But obviously it's all encrypted under Alice's policy key. So at this point, he has no way to access it. He needs to basically send that encrypted data to the new cipher network and ask it to re encrypt for him. So this is what's happening here.
00:20:59.964 - 00:21:28.070, Speaker A: He will basically say, hey, new cipher network, please re encrypt this data for me. If there's a valid policy out in the new cipher network, all the conditions are satisfied. The Ursulas will do that re encryption, they'll give him back re encrypted ciphertext that he can then use his own private key to decrypt. And if that works, he'll have the plain text, he'll have the plain text and we'll just print it out and see if we're able to read it or not.
00:21:36.120 - 00:21:37.830, Speaker B: Looks like there was no policy.
00:21:58.750 - 00:23:07.896, Speaker A: It looks like it worked. We can see all those heart rate data points coming in, getting reencrypted and then printed out in plain text for Bob. So I don't have it as part of the demo in the scripts, but we also have the ability to revoke Bob's access. So let's know six months later, Alice decides, okay, I'm going to switch care providers, I have a new doctor, I don't want Bob to access the data anymore. Now it's Charlie, so she can basically tell the new cyber network, hey, revoke this access policy for Bob, issue a new one out for her new doctor, whoever she wants to share the data with. Okay, so we have basically a couple of different testnets that are available for you to use. This is basically the Federated staking testnet.
00:23:07.896 - 00:23:47.708, Speaker A: So if you want to run one of the Ursula nodes, this is the one we recommend that you do it on. All the instructions for doing that are on Docs Newcypher.com. The name of that network is, I think you pronounce it Owamuamua. It's that weird celestial thing that flew past the Earth a couple of weeks ago. This is the initial seed node that you would learn from, but if you're just building an application or a DApp, we actually recommend that you use the DevNet, which I don't have the information for here, but should be on the hackathon repo on our GitHub, which I have the links for later. And that is just a more stable thing. That New cipher or us as a company are running all the nodes for that.
00:23:47.708 - 00:24:44.030, Speaker A: So not just random people out there in the wild. So you have basically better guarantees that all the nodes will be up and available and it'll be a lot more stable. So I'll just sort of wrap up by touching a little bit on some of the research stuff that we're doing mostly around fully homomorphic encryption. And for those of you who aren't familiar with Fhe, basically homomorphic encryption is this idea that in the same way that you can take some plain text data, apply a function to it, get a result, homomorphic encryption says that you can take some encrypted data, apply a function to it, and get an encrypted result. So we're primarily interested in looking at this for obviously blockchain applications. So potentially applications for smart contracts. So you could have private smart contracts where all the inputs are hidden and are private, so you can imagine things like secret ICOs or private auctions, private voting, potentially those sorts of things.
00:24:44.030 - 00:25:26.380, Speaker A: We've open sourced a little bit of our early research on this one. The most interesting thing is probably this new Fhe library, which is a GPU accelerated homomorphic encryption scheme. It's about 100 x faster than non GPU accelerated schemes, which, as far as we know, makes it the fastest Fhe library currently available. You can run it's open source. It's on our GitHub under the new Fhe repo. You do need, obviously a GPU to run it because that's what we use to make it vast. And we actually used it at ETH Berlin to run the first ever fully homophobic smart contract as a kind of proof of concept.
00:25:26.380 - 00:26:06.356, Speaker A: So it'd be really cool if any of you guys here sort of drove that even further. So this weekend we'd be very happy to see you build something with New Cipher Network or the new Fhe Library. We have $2,500 in prizes. One is for the most novel split between two prizes. One is the most novel use case for either the new Cipher Network or new Fhe. The other is the most impressive technical implementation. So we're very interested to see how impressive of technical achievement you can do over the weekend at East Denver.
00:26:06.356 - 00:26:39.584, Speaker A: As kind of challenge. Someone actually implemented a decentralized 23 in Me with new Fhe, which was pretty impressive. I'll just shortly mention this. The day after ETH Paris ends, we're doing a virtual online hackathon with Coinless that runs for a month. So if you like building with new cipher over this weekend, you want to keep doing it, we'd love to have you join this as well. More information, obviously our website docs newcypher.com. We have getting started guides.
00:26:39.584 - 00:27:13.932, Speaker A: We have sort of instructions for how to run that same demo that I showed you tonight on your own machine. The main proxy re encryption new Cipher network is under the new cipher repo on our GitHub. Our Threshold proxy re encryption scheme that we use is called Umbrell. Can also take a look at that if you want to work with sort of a lower level cryptography library. And then we have the new Fhe homophobic encryption library. I'll be around most of the weekend. We have one other team member here happy to try to help you in person.
00:27:13.932 - 00:27:36.660, Speaker A: If you can't find us. The fastest way to get help or ask technical questions or get stuff resolved is on our discord. So all of our engineers hang out there, pretty much 24/7. So we're a distributed team. Someone will probably be around no matter what time you ask your question. And that's it. Thanks for hearing me out and excited to see what you guys do this weekend.
00:27:40.920 - 00:27:41.670, Speaker B: It.
00:27:43.080 - 00:27:47.680, Speaker A: And I'm happy to take any questions or chat with people after. Bye.
