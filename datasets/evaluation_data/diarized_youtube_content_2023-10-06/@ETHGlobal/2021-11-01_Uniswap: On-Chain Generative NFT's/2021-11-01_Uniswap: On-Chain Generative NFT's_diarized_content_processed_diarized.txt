00:00:00.090 - 00:00:02.800, Speaker A: Introduce herself and kick the session off.
00:00:03.890 - 00:00:29.830, Speaker B: Great. Thanks, Emily. I'm also Emily and I am a developer at Uniswap. I do a lot of smart contract work there and kind of recently I was working on our NFT metadata for the Univ three positions. Yeah. So I'm going to give like a fun little talk about that today. Yeah and then I guess there'll be time for questions at the end.
00:00:29.830 - 00:01:26.518, Speaker B: So that's me and I guess take a set. Okay. Yeah. So on chain generative NFTs, this has kind of like been a new thing that's happening and maybe a lot of people might be confused and wondering, well are NFTs on chain? They're non fungible tokens on the blockchain and that is true. However, the bulk of the logic for NFTs that is on chain all kind of pertains to ownership. What address owns the NFT who has transfer right and access and that's the biggest on chain component. However kind of all the fun stuff that we've come to know and love recently with NFTs like the art and all the things you see on Openc, like the title and the description for the most part that is off chain for 99.99%
00:01:26.518 - 00:02:28.550, Speaker B: of projects like people's art isn't on chain and for good reason. Pictures take up a lot of data, especially videos and storing things on chain is extremely expensive and for good reason, that has to be replicated across all nodes. It's not entirely reasonable to be putting all that data on chain. However, lately a lot of projects have been coming up with ways to get their NFT metadata completely on chain and not depend on web APIs. All this stuff like the art and the images is actually a part of the optional metadata extension of ERC 721. So technically it doesn't even need to have the metadata but of course most do. And this metadata extension which is optional is the name of the token, the symbol and then also the token Uri.
00:02:28.550 - 00:03:30.670, Speaker B: And the token Uri is really what we're talking about here which is like the name of the individual NFT like punk 1230 whatever and then the description and then the image. And so this token Uri will return a link or a Uri which then will point to JSON and despite being on the EIP website, this JSON is actually a little dated and I'll show a better representation of that. But it will have the name, the description and the image. And for the most part this Uri that's going to be returned is pointing to a run of the mill web two API server that someone's hosting. And so technically with all this art and stuff it remains on chain. But if those web APIs go down, that art's just not there anymore. And so here's some code from Openseplin.
00:03:30.670 - 00:04:23.440, Speaker B: So with this metadata extension with name symbol but the token Uri. So what a lot of projects will do is they'll have a base uri, which is actually just like their link to their API. And then you'll attempt something like the Token ID to the end to then get some pretty JSON describing what is all the stuff surrounding your NFT. And so for example, POAP is a popular NFT proof of attendance protocol. If you've ever attended a hackathon or many of you may have gotten a POAP. And so this is what the Token metadata looks like. And for projects like POAP, you'll go to their server and you'll get all this information, including most importantly, the name, the description, and then the image, which is also another link.
00:04:23.440 - 00:05:10.094, Speaker B: However, with Unison v three, we thought it'd be fun to make everything on chain. It's fun, it's cool, and it also means we don't need to run an extra service. So for us it's even cheaper as well. And so instead of returning when we call Token Uri, which is part of that UFC metadata standard, instead of returning a link, an Http link, we return a Data URL, data URL prefixed with Data. And then the scheme provides a way to inline data in a document. And it's commonly used to embed images in HTML CSS, that's the most common use case. However, we've used them in our Token Uri schema as well.
00:05:10.094 - 00:05:24.130, Speaker B: And so a couple of examples of Data Uris. Here's two. Hello, world. Ones the data. Hello, world. And these are URLs. So URLs don't have so you do need to percent encoding.
00:05:24.130 - 00:06:09.058, Speaker B: You can also encode basics before that's what we did in Uniswap. So these two would render the same way in the browser. If you copy and paste this into your URL search bar, this is also Hello World, but base 64 encoded. So some of our code, this is the code that constructs our Token Uri. So our ERC 721 token will call into this separate contract that we have and we'll construct the Token Uri. And so you can see down here, right here is where we construct our Data URL. And we are returning JSON, not plain text or anything, and we have to kind of like sort of messily you'll see later.
00:06:09.058 - 00:07:10.002, Speaker B: Kind of doing this in Solidity was super tedious. Solidity was not made for parsing text, which is what the majority of this project was. But you can see we return the Data URL with the name, the descriptions and the image. And also we are kind of like injecting a lot of dynamic data in here about our NFTs, the Uniswap v three NFT, which I won't get into too much, but it defines the liquidity provider position inside of a pool. So not only on chain do we have ownership rights, but also a lot of financial information about the position, the range that this position covers in the Uniswap pool, and also the principal and the fees it's returned. There's a lot going on with these NFTs, but we're just talking about the fun metadata aspect. So we kind of had to take a lot of that information on that on chain information, which is not necessarily in a human readable format.
00:07:10.002 - 00:07:54.722, Speaker B: Solidity is one of the furthest things away from being like a human readable type storage situation. So we kind of had to do a lot of parsing work to get this information in a human presentable way through things like Openc and stuff. So you can see we're scraping quotes, putting addresses into strings, et cetera. And then also our image is also a data URL, but instead of JSON, it's going to be an SVG image in the base 64 encode. Cool. Yeah. So when you get our huge data URL returned and you plug that into the browser, the browser will display this for you, which is like all of the information.
00:07:54.722 - 00:08:41.490, Speaker B: It's kind of ugly, but mostly because then we have this huge Uri for our big SVG image, which then will also be decoded. Let me see. And the reason we did SVGs to store on chain. So, like I said earlier, it's so expensive to store huge something like a huge JPEG on chain where you need to save every single pixel, like the bytes for every single pixel. But in SVG format, SVG is formatted as like HTML CSS styling. So you save it as an HTML string. I think some people are unmuted.
00:08:41.490 - 00:09:18.510, Speaker B: You save it as an SVD string and then the browser can render it from the HTML and it's so much more compact to store an image that way. So a lot of the on chain images are actually going to be in SVG format. But anyway, so yeah, this is the metadata. You can see we have information about the position and that will be rendered on OpenSea looking something like this. And so our metadata consists of our title, our image, and our description.
00:09:20.130 - 00:09:20.926, Speaker C: Cool.
00:09:21.108 - 00:09:46.070, Speaker B: So what's next? Okay. Generating the SVG image. Yeah. So then after we do the JSON, we also want to get this image stored. And the way that we did that is, first of all, some of the parameters for this are all the financial aspects of what we want to show you. We want to show you your token symbols and addresses. We want to show you your tick range.
00:09:46.070 - 00:10:37.510, Speaker B: So we have all of that kind of crazy information, but also some of the funner stuff that we needed to do is make it cool and pretty. So we wanted the images to be colorful, obviously. So one way that we did that was we took colors straight from the token addresses, the ERC 720 token addresses. So it's pretty convenient. Ethereum addresses are represented in Hexadecimal, and same with colors in HTML and CSS are usually represented in three bytes Hexadecimal. So I just sort of took little snippets of the token addresses and then made those the colors for our SVG images. And then also what we did with these colors was kind of make, like, a faded tie dye background.
00:10:37.510 - 00:11:25.238, Speaker B: And so these well, this is what it looks like. These are what our SVGs look like. And this is kind of like the tie dye image background I'm talking about. So another thing we did was all of these are kind of like little circles, like, faded and spread across the background. But we wanted each individual card to be somewhat unique, even if two people kind of minted the same sort of position. So what we did here is to get sort of like a randomness well, not really random, but unique randomness is really hard on chain. And we did try and inject some randomness into our SVG as well, which I'll talk about a little bit later.
00:11:25.238 - 00:12:20.362, Speaker B: But to make them unique, what I did is to come up with the coordinate for where these colors are located in the background. I generated a coordinate using the Token ID with a lot of NFTs. And with ours, your Token ID is declared consecutively. So the first one, Minted, is 12345 and so on. So to kind of get these all unique, we use the Token ID to move the coordinates around. So basically, this coordinate right here had to be between one and 255. So what I did is I got a number by taking some hexadecimal out of the Token address again, and then multiplying that by the Token ID, which is unique, and then modulus 255.
00:12:20.362 - 00:12:51.890, Speaker B: So we are between one and 255 to get each NFT, a unique kind of color coordination across the background. And so, as you can see, kind of like mix and match. And everyone has a little unique image for their position NFT. Yeah. So putting these SVGs into Solidity was super tedious. It was super wild. It was a little frustrating at times, but as you can see, it's kind of ugly.
00:12:51.890 - 00:13:31.630, Speaker B: Solidity was not made for this type of thing. And as you can see in my editor, the syntax highlighting, it's very confused. It has no idea what's going on. It doesn't realize that these are like isolated strings. I had to even get in touch with the Solidity prettier Linting team because the Linter was getting very confused. It had no idea what was going on, and it was linting the code incorrectly and actually making it not compilable. So it was definitely I definitely felt like I was in new territory, and it was tedious.
00:13:31.630 - 00:14:25.666, Speaker B: And so this is kind of like a string interpolation, like getting our dynamic factors like the Token ID, the tick lower, the tick upper into our SVG string. And even with the numbers, you have to transform them all into strings. That doesn't happen automatically with Abi encode. It won't encode the number as string. So Openzeppen has tools for that. But one of the hardest things to get into a presentable format for these SVGs was these prices. Getting this in a human readable format on chain was so difficult because the EVM does not know, has no notion of what a decimal is, right? And we store these numbers as fixed point numbers.
00:14:25.666 - 00:15:24.002, Speaker B: So just like when you're writing to the ethereum blockchain for a token like Ether, you kind of have to times it by ten to the 18 so it can get stored on chain as a UN. In unisop, we use fixed point number format, so there was really no library for me to get a fixed point number into a nice decimal string. And that was definitely one of the most intense functions I've personally ever written. So there's a lot of work going on behind the scenes to get some solidity storage values into nice human readable text for this on chain metadata. It was definitely a huge challenge. It was fun. And then another element that we put into our SVGs and I haven't really talked about all what's going on, but I'll do that next.
00:15:24.002 - 00:16:19.590, Speaker B: But for now, I'll talk about the super rare special sparkle was another little just cool Easter egg that we decided to put in there. And this is kind of like the randomness that we tried to inject into our SVGs. Basically we wanted there to be some notion of a rare uniswap NFT. And the way we did this was kind of like people might randomly get a special sparkle in their NFT and the lower the token idea is. So the first people that mint, it's easier to get a rare one. But as minting continues, it gets harder and harder to get a rare special sparkle. And so the way that we kind of try to make this a little bit random is similar to how proof of work works in a way.
00:16:19.590 - 00:17:21.814, Speaker B: On bitcoin or Ethereum, when a miner is trying to mine an X block, they have to hash the block data against a nonce repeatedly, until finally the hash begins with six zeros or something. And when that happens, yeah, you're the winner and you get to mine the next block. And so something similar with winning the super rare special sparkle is the pseudo randomness, right? Not random, but pseudo random comes from we hash your token ID with the pool address of your position to come up with a pseudo random number. And then we compare that number against UN 256. And then really, this is kind of the most important figure here, UN 256 over the most significant bit of the token ID. And if it's less than that number, you win a super rare special sparkle. However, this number is going to get bigger and bigger over time because it's inversely correlated to the most significant having the most significant bit of the token ID.
00:17:21.814 - 00:18:10.430, Speaker B: So if the token ID gets bigger, it's going to have more bits and the most significant bit is going to be a larger number. So this is going to get bigger and bigger over time. And yeah, so we hash this kind of pseudo random number against an ever increasing number, and if it's smaller, you get the super rare special sparkle. Fun story. We are really pushing to get this out last second as the univ three deadline was approaching and we wanted to do our release. I wasn't even sure if I was going to get the super rare special sparkle in, but finally it was a day before and I was like, okay, I have time to do this. And we wanted the distribution to be a little bit better, and so I wanted to multiply this whole number times two so more people would get special stars.
00:18:10.430 - 00:18:53.014, Speaker B: But due to the nature of getting this outbast in the rush, this two was supposed to be outside the parentheses, but I put it inside the parentheses, so I actually divided by two and made it even rarer. So they are super rare. So if you have one that's really cool, you should appreciate it. I'm sure most of the people that have them don't even realize because they're more concerned just like LPU and uniswap and probably do not even look at this metadata. But yeah, so that's a fun little Easter egg. I can just quickly talk about kind of like the design work behind what's going on here. So in this position, we have our token addresses here and our token symbols here.
00:18:53.014 - 00:19:32.462, Speaker B: We want to add the addresses because anyone can deploy an ERC 20 and say the symbols we right, so making sure that we're super specific and people can verify. And then we have the fee percentage because there can be different fee tiers for univ three pools. So this really defines which pool it's in. Then we show the curve. And this position that I'm showing right here is actually out of range, meaning there's a price and hope. Ideally, your position surrounds the price, so your liquidity is being active as the price moves. However, if it is not included, you're out of range.
00:19:32.462 - 00:20:11.422, Speaker B: And so in this SVG or image, this is kind of representing that your range is above the price, right? It fades, kind of signifying something important going on down here. The price is down here, but you're above the price. We have the token ID, the min tick of your range, the max tick of your range, and kind of like where your position falls on the curve. So here's a few different ones. We were just looking at this one and you can see this one's above the range, I mean, above the price. The range is above the price. If we look at this one, this range is below the price.
00:20:11.422 - 00:20:46.358, Speaker B: And this one's also out of range, and the price is up here. These three are all in range positions, and you can kind of see the curve has a different some are a lot more concave and some are a lot flatter. So that kind of represents how concentrated your range is. So if you have a really tight range, like this one has a very tight range, this is signifying. It's kind of like zoomed in on the curve. Right. So it's like kind of flattered.
00:20:46.358 - 00:21:25.414, Speaker B: So we're only showing a very short portion of the curve. However, this one you can tell is a very wide range and you can talk because we're more like zoomed out and you can sort of see more of the curves. Yeah. What mean? I think that's the majority of it, you can see a lot of them have different color schemes depending on the tokens. I think it's kind of cool that USDC dye came out super green since they're super represent dollar values. Yeah, now we're getting on time. I think I might be done.
00:21:25.414 - 00:21:48.846, Speaker B: Do I have any other slides? Okay, cool. And then we're not the only on chain generative Art NFT. There's a few other cool projects to check out if this is something that interests you. Mandalas also does the data URL. I think actually all of these projects do. There's Mandalas, there's animal coloring book on. Yeah.
00:21:48.846 - 00:22:32.800, Speaker B: And a lot of newer projects are starting to do this. So it'll be really cool to see how people kind of take on chain data and use it to generate these presentable images. It was pretty hard for me, so I'm looking forward to seeing other people's ideas and how they tackle these issues. I also posted this cool blog post that Simon wrote about all different projects that have attempted some sort of on chain generation of the image or the metadata. So that's super informative if it's something you want to dive into deeper. And thank you.
00:22:35.330 - 00:22:53.380, Speaker A: Thanks so much, Emily. Yeah, that was a really great session. We do have two questions in the chat and Colin, if you feel comfortable unmuting yourself and asking these questions live, please feel free to. Otherwise I can read it out for you.
00:22:55.210 - 00:23:09.430, Speaker C: Sure. This seemed like pretty cool technology. I'm interested in what projects are using it outside of images and NFT images.
00:23:10.490 - 00:23:13.660, Speaker B: Which projects are using outside?
00:23:15.950 - 00:23:23.280, Speaker C: Just using this way to do a lot of computationally complex stuff.
00:23:24.370 - 00:24:12.410, Speaker B: Yeah. So I think if I understand, besides us, who else is doing this? And this slide is perfect for that because these are three other projects that I think are the closest to what we've done. This blog post has a lot of other projects that have also done it. And a lot of the projects that came before ours kind of had a way to generate images on chain that was separate from the metadata. So in the Token Uri, they return a link to IPFS or their web server and you'd still go and question on OpenSea. But because that's not always super trustworthy because servers do go down, they do disappear. They're not immutable.
00:24:12.410 - 00:25:14.642, Speaker B: In fact, there was an NFT project where everyone got rugged because it was like a fun new NFT project and people bought the NFTs and then they changed all the images to Rugs, which was kind of funny. I forget what project that was. But before this project and before Mandalas, there were a lot of projects or a few projects mentioned this blog post that would actually have a way to generate the image on chain if you really wanted to. But it was kind of separate from also what they had on the server so that there was at least some on chain evidence of the initial intention of the image. So you'll see a lot of those techniques in this blog post, but I think more and more people are kind of gravitating towards potentially using this data Uri and just getting all the metadata on chain instead of using a web server. If that answers the question, great.
00:25:14.696 - 00:25:29.190, Speaker A: Colin says cool. Cool. Has anyone else maybe got a question for Emily while she's on the call? Feel free to unmute yourself and ask the question live. Or you can drop your question in the chat.
00:25:30.490 - 00:25:40.328, Speaker B: Yeah, okay.
00:25:40.414 - 00:25:52.670, Speaker A: If there's no questions or any more questions for Emily, we can close out the session here. I guess Michael B is just asking for a GitHub link.
00:25:55.040 - 00:26:04.940, Speaker B: Yeah, how can I post that in the chat? Or I should have put like Twitter handles and GitHub links at the end, but I forgot.
00:26:05.280 - 00:26:43.230, Speaker A: I mean, you can always add it to this presentation and share the slides with me because they love it when I link these in the chat afterwards and they can just refer back to it. So if there's no further questions for Emily, I just want to say a big thank you for joining us today and taking us through the on chain generative NFTs. If you have any questions for Emily or anyone else in the Uniswap team, they are in the sponsor Uniswap Channel and Discord, and they are more than happy to answer any questions that you have. Thanks so much for joining and we'll see you soon.
00:26:44.400 - 00:26:44.810, Speaker B: Thank you.
