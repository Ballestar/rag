00:00:06.170 - 00:00:19.870, Speaker A: This is a very timely question and a talk. I want to bring on Khan, who's going to be talking about sourceify, simplifying a lot of your needs on making sure your contracts are safe and easy to read and verified. So, without further ado, please welcome Khan.
00:00:20.930 - 00:00:44.438, Speaker B: Yeah. Thank you, Kartik. Hello everyone. As Kartik mentioned, I will be talking about sourceify and sourceify verification. We at Sourceify also are doing source code verification, but more in an open and decentralized way. But we are actually more than that. We are also actually an initiative for more human friendly contract interactions.
00:00:44.438 - 00:01:38.540, Speaker B: And now I'll talk about how you can do this. So I'll start with just a normal day in webtree, just an example that you have probably already seen if you have been in Web Three space for a while. And it's this. So it's a daily thing now, although this has improved slightly, that every day we encounter interactions with contracts that we have no idea. So when you see this, this is like, what is happening? What am I doing? Am I talking to the right contract? Am I doing the right thing? And at the end of the day, this basically is the same thing as telling the contract just shut up and take my money, I have no idea what I'm doing. And the good thing is we can change this. So it is a difficult task, it's a difficult thing, but that's what we are striving for.
00:01:38.540 - 00:02:24.118, Speaker B: But as I said, a typical Web Three interaction nowadays is still a yolo signing nightmare. What we like to call this interaction signing on the wallet and just hoping for the best. And at the end of the day, what we want to achieve is something on the right instead of something on the left. I know these have changed recently in most of the wallets, but still we don't have really comprehensive messages that regular users or even the developers can understand easily. So let's dive into what you can do to achieve this. There are two sides of the equation. There are things that you can do as a smart contract developer and as a wallet developer.
00:02:24.118 - 00:03:00.490, Speaker B: So let's dive into what you can do as a smart contract developer. First thing you can do is to use the Natspec documentation. So the Natspec documentation is part of the soldity specification. It's part of the soldity documentation and it is rich documentation for functions, return variables. And it's a special form called Ethereum Natural language specification. So it looks like this. It is similar to JSDoc.
00:03:00.490 - 00:03:55.746, Speaker B: If you are familiar with the JS doc and you can find the Nat spec in your contract, it's mostly on top of the functions. It has a dev field, which is for the developer documentation. Then we have notice fields for the user documentation. Then we have the documentation for the parameters. And the nice thing about Natspec is that it supports dynamic expressions. What does it mean? It means that the fields you can see here, for instance, the old owner and new owner of this user documentation can become this. So when you are showing the users the user documentation, you can fill these variables dynamically and instead show the values to the user.
00:03:55.746 - 00:04:49.798, Speaker B: And even better, you can show something more human readable to the users. If you have for example, a reverse ENS name. Okay, so we know what user doc and devdoc is, but where can we find it? Where can we find and leverage these fields? These fields are in the Solidity contract metadata. I'm not sure, probably most of you are not familiar with the contract metadata. It is actually introduced in 2016 with the earlier versions of the Solidity, but it was actually not picked up by the community. So it is a JSON file generated by the Solid compiler which contains metadata as the name suggests. But it consists of four main fields.
00:04:49.798 - 00:05:50.276, Speaker B: Firstly Abi, then user doc, devdoc, as we have seen in the previous slides. Then we also have the compilation information and the information about source files. So the first two fields are concerned with how to interact with this contract, the metadata contract of the metadata and the next two fields are concerned with how to reproduce a contract compilation. The file looks like this, it is a JSON file as I told you. And it is, let me show it's. I'm sorry, I can just write this. Yeah.
00:05:50.276 - 00:07:02.382, Speaker B: Oh, there we go. So it is a file like this and in the output field you have the Abi devdoc and user doc and you can see the Natspec fields are embedded here. For example, the one we talked about, the Natspec comment we talked about is here replaces the owner old owner with safe with the new owner. And the other information here are as usual, the compiler settings, the EVM version, the optimizer settings, source information. And the source information also contains the content of the source file, although not always, and the hash of the source file. Okay, now we know where to find devdoc and user doc, but where is the metadata? Where can we find the metadata? Where can we find this file? If you use the soldidd compiler, it's obtainable with the metadata flag. So if you pass the metadata flag to the compiler on a terminal and the contract, you will get the metadata file.
00:07:02.382 - 00:08:21.610, Speaker B: It is also available on frameworks if you're using Truffle, after you compile the files, you can access the metadata, you can access the compiler artifacts actually. And in the artifacts you can find the metadata in the JSON fields. If you are using hardat, it is also in the artifacts. And since hardat version zero to eight, you can find the metadata of each contract in the large build file and is also embedded somewhere embedded in your contract bytecode, but not the metadata itself, but the IPF hash of the metadata file is appended to the bytecode of the contract when compiled. So the solidity compiler by default actually embeds this information along several other information at the end of your bytecode. And this is also deployed to the blockchain. You can turn this off, but by default actually, this additional field is appended at the end of the bytecode alongside the functional part of the code that corresponds to the contract we are written.
00:08:21.610 - 00:09:14.620, Speaker B: And this IPFS hash of the metadata file acts somehow as a compilation print or a digest of the whole compilation that you have done. And if you publish this metadata files, that means you can access it through its bytecode. So as we said, this is an IPFS hash of the metadata file. So if you get the contract bytecode and decode this IPFS hash, then it's available on IPFS if it's published or pinned by the author of the contract. There is actually a nice tool to see this in action that we call playground. In here you can fetch your contracts and we also have some example contracts here. Let's have a look at this.
00:09:14.620 - 00:10:14.346, Speaker B: For instance, if we want to see the code bytecode and the metadata of the ethereum deposit contract, it will fetch the bytecode of the contract. Then we'll decode this part, the highlighted parts which corresponds to the fields that we talked about. And then if we decode this, we see there is the IPFS hash and the solidity version of the contract. And here, using this hash, the metadata file actually fetch from the IPFS and we can see the metadata file here. Okay, so we use the Nat spec documentation and the second thing we can do is the source code verification on sourceify. So before diving into more, maybe let's have a look at what source code verification is. I'm pretty sure everyone has seen this green checkmark.
00:10:14.346 - 00:11:34.380, Speaker B: If you are interacting with a contract or looking at the source code of a contract and you see this and you're happy because then you know everything's verified, everything's checked, marked and this is what you see in the ether scan when you are looking for the source code of a contract. But how do we know that actually a random code on GitHub? How does it correspond to the code of this contract on blockchain? So if I give you this code, for example, how do you make sure if this is actually the code corresponding to the contract on blockchain and not just a random contract? So this is how it works. So we have the solidity files which are our source code. Then we also have the compilation settings. This is when you are compiling your contracts. This is just a default thing. And what we do is we take the source code files, then we take the compilation settings and we feed these into the compiler and we recompile everything.
00:11:34.380 - 00:12:34.242, Speaker B: This is actually when the second part of the metadata file comes in handy because this part gives us the information about how to reproduce a contract compilation. And if we have this in hand then now we can make use of this and see if we can reproduce the whole contract compilation. So we get the source code files. If you are verifying a contract, you give us source code files, you give us the settings you have, then we recompile everything. Then the compiler outputs the bytecode of the contract, the code that the machines understand, not the human readable source code, but the bytecode that is deployed on blockchain. And then we also have the contract that we want to verify. For instance, if we have this contract at this address, then we get the code of this contract from the blockchain.
00:12:34.242 - 00:13:27.120, Speaker B: Then we see if these codes match. So if these match, then it means the source code you provided in these slides and these settings are actually matching the contract on the blockchain and in sourceify we actually have two types of matches. One is the partial match when the bytecodes match and the second one is the perfect match as we call. This is when the bytecode plus the metadata match. And if you recall the highlighted fields at the end of the contract bytecode, this corresponds to these fields. So when the black fields on the match, that would be a partial match. But for a perfect match, you need the bytecodes to match as well as the metadata to match.
00:13:27.120 - 00:14:33.262, Speaker B: And if you recall, the metadata acts as a compilation fingerprint. That means if we have the metadata field matching as well, the compilation as whole is exactly the same as the original contract. And yes, this will cryptographically guarantee the whole compilation is exactly the same as the original contract. So even the soldier files are exactly the same, even the comments, variable names, even the white spaces are the same. And how does it work? So let's see, in the case when something matches, so we again have the source code files, then these files are hashed by the solidity compiler, the compiler hashes it. Actually when you are compiling the contract, then the hashes of these files are embedded in your metadata. So when we looked at the metadata file, we saw that the hash of the source files are also included.
00:14:33.262 - 00:15:30.760, Speaker B: So the hash is embedded in the fields of this source file and as well as the other files, then the IPFS hash of this whole file is taken metadata file and then the IPFS hash is embedded and encoded at the end of the contract bytecode as we have seen before. Then we see if the one on the left, the one we recompiled, is actually matching the one from the blockchain. And if it's matching, it's a full match. It's a perfect match as we call. Now let's see what happens when you make a change. When you add a comment change a variable name anything. So again we have the source code files, but this time a different source code file with a slight difference and that causes the source files hash to change.
00:15:30.760 - 00:16:20.114, Speaker B: Then the hash in the metadata file will change and consequently the hash of the metadata file will change. Now we have a different hash and this different hash will be embedded, will be appended at the end of the bytecode. So the last field will also change. And this time you will be having only a partial match, not a perfect match, but excluding the last part of the contract bytecode. This will give us a partial match. Okay then, now we know what source code verification is and how can you verify contracts. One way to do this is to use the sourcefi UI.
00:16:20.114 - 00:17:09.650, Speaker B: We have a UI for you to verify contracts. You can here provide us with the metadata file as well as the source code files and give the contracts address and the chain. Then we can recompile the whole thing and see if it's a match. And we have several chains, I think at the moment close to 30 different EVM chains that we support and where a contract verification is possible. We also have an API where you can provide the same information through an API programmatically. And we also have the documentation where you can see how to make use of the API. We also have extra tooling.
00:17:09.650 - 00:18:02.146, Speaker B: For example, with the hard head, we have the hardhead deploy plugin that you can easily verify your contracts after deploying. So if you have deployed a contract on mainnet, you can pass hardhead network mainnet sourceify and this will verify the deployed contract on sourceify. We also have a Remix plugin. If you deployed your contracts over Remix, you can easily pass the contract address and contract chain and the plugin will verify the deployed contracts. We recently also have the Foundry support. So using Foundry now you can also verify the contracts by passing the Verifier flag and sourceify. This will also verify your deployed contracts.
00:18:02.146 - 00:19:01.268, Speaker B: On Foundry, we also have a nice feature called automatic verification, also as monitoring. So this, as the name suggests, automatically verify the contracts that are deployed on the blockchain. So I'll do a short demo about this. So here on Remix, I have a simple contract called Storage Soul and this contract itself as well as its metadata is already on IPFS. So I'm going to deploy this contract on the girly test network. Then we will see how the automatic verification actually works in action. So we are waiting for our transaction to be mined, right? So our contract is deployed.
00:19:01.268 - 00:20:02.540, Speaker B: So I'm going to sourceify and I'm going to check the contract. If it's verified on sourcefy, it is currently not. So this makes use of the IPFS hash that is deployed and it listens to the blockchain for new contracts on the blockchain. If it finds a new contract, then it will check the metadata at the end of the contract, then tries to pull every information, all the source files and everything, then it will do a recompilation itself. So this should actually work in seconds. So yeah, as we can see the sourcefly monitor has captured this contract creation and automatically verified the contract because the metadata file was already published on IPFS and the source file was already there on IPFS. Yeah, currently this is only done for the Ethereum mainnet and the testnets and yeah, this automatically verifies the files.
00:20:02.540 - 00:20:41.384, Speaker B: So that means actually the second step was the source code verification on sourcefi. Then it actually becomes publishing metadata and source files on IPFS. So you don't even have to go to sourceify and verify the contracts. The only thing you have to do is publish your source file as well as the metadata in a reasonable amount of time. So it has to be done when the contracts are deployed. We have a buffer, I guess around five to ten minutes. So you have to publish that five or ten minutes after the deployment or even before maybe.
00:20:41.384 - 00:21:37.868, Speaker B: And this is only done on the Ethereum mainnet and testnets. So we also have the contract repository which is both served over the Http and IPFS. So every file that we verify we serve also on the IPFS for later fetching and it is under an IPNs name with a DNS link under repo sourceified dev and it's updated every 6 hours currently. So you can also see it here. Right now I'm showing the repo staging sourcefied dev because the main server has just got an update but it will be also available in a couple of hours. So you can also here download the whole repo or explore the repo how the contracts are structured. So we have the contracts, we have the full match, then we also have the contracts sorted by chain ID.
00:21:37.868 - 00:22:30.604, Speaker B: But I guess this is taking some time to load. Yeah, IPFS is not always the fastest network, unfortunately, but most of the time if you want to search with an IPFS hash, that works pretty well. Okay, so these were the things that you can do as a smart contract developer. Now there is the other side of the coin. What can you do as a wallet developer for your users? So again, remember the first two fields of the metadata file, they were concerning how to interact with the contract. So these were Abi, userdoc and devdoc. And as a wallet developer, what you want to do when your users are talking to a contract, you want to decode the contract call which is in bytecode and show your users meaningful message.
00:22:30.604 - 00:23:30.764, Speaker B: So what you want to do is get the user doc and decode abi on contract interactions. And for that, remember, what you need is the metadata file because the metadata file contains the abi as well as the user documentation. So what do you do you fetch the metadata from sourceify's repo, right? No, please don't do that because actually the information you need is already there. So you don't even need us need sourceify to do that. You already have the IPFS hash of the metadata file on the contract bytecode. So what you do, what you should do actually is to get the contract bytecode fetch the metadata with IPFS hash because remember, in this field you can get the IPFS hash of the metadata file then fetch it over IPFS. Then you have the Abi and the user documentation, then you can show the users more human friendly messages.
00:23:30.764 - 00:24:31.572, Speaker B: So using this information of a verified contract you can actually show something on the right instead of something on the left. So our way of human friendliness, so to say, is just one way. So we make use of human readable descriptions with nut spec comments in the metadata. But there are more ways to do that to achieve this. For instance there is the EIP 44 30 and EIP 33 24 which where the idea is to have a describer function inside the contract which upon when they are called it returns a human readable description and then runs the function that is called. So the advantage is that it can decode things like an ENS commit but this also means you have to have extra data in your contract that is deployed. There is also a recent EIP draft by Dan Finley there.
00:24:31.572 - 00:25:23.750, Speaker B: The idea is to give the user the information about the contract on the first point of contact. So when you for instance visit Uniswap.org then you will receive the API and the method describers from the website. Then this will be saved on your wallet. The nice thing about this is it's backwards compatible and it's flexible, but it's not bound to the contract itself. Yeah, and also apart from being human friendly, there are many more ways for a better UX. So you can decode the contract calls, you can warn the user if they never interacted with the address, you can say if the contract is verified, block if the known scam address, if there is a large amount or if there are large fees with the amount.
00:25:23.750 - 00:26:20.320, Speaker B: Additionally you can show the users how many times this contract was interacted with because a safe contract will have more users and a scammer would maybe have less interactions. And when was this contract deployed? An older contract is probably more legit and as well as if this contract is audited by whom it's audited. So there are lot of things actually we can do and we can do better. So let's have a recap. What is sourceify? Technically we are an open sourced automatic smart contract verification service. We have a user interface and API and tooling to verify contracts. We also have a publicly centralized content address, storage of verified contracts for everyone to access and more generally we are an initiative.
00:26:20.320 - 00:26:42.190, Speaker B: We act as a base layer and public good for other tools to build on top of an initiative to foster the use of the contract metadata, Natspec and full verification. And we are also an ongoing effort to improve smart contracts, UX safety and transparency. So thank you very much for listening and I would be happy to answer questions if you have any.
00:26:43.440 - 00:27:16.920, Speaker A: Thank you so much. I'm looking at the Q-A-I don't think we have any that are specific to this, but people want to be able to kind of see the slide decks. If we're able to also share that with us, we'd love to make there you go. So I'll be able to kind of relay that to the audience and then also we'll be able to put the links up. But this was really good. Sourceify is getting better and better. We've seen this happen, this talk talking about Socified every kind of few months to in the past year and you can see the massive improvements and that's awesome.
00:27:16.920 - 00:27:18.390, Speaker A: So thank you so much.
