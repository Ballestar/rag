00:00:00.090 - 00:00:15.280, Speaker A: Joining us today's session is with Pietru from the Mekadao team and he'll be taking us through his workshop session, auction keepers. And with that, I will pass it over to Petru to introduce himself and kick the session off.
00:00:16.370 - 00:00:54.080, Speaker B: Thank you very much. Hello everyone, I'm Petru, I'm part of the Mekadao ecosystem, specifically the sustainable ecosystem scaling core unit. It can you hear me? Yes, I think you are. And yeah, I'll talk to you guys about the auctions in maker protocol, specifically the auctions in the upgraded version, which is liquidations 2.0. And with that I'll share my screen and we start. So I believe you should see my screen now. So let's get started.
00:00:54.080 - 00:02:24.586, Speaker B: So pretty much it's going to be all about liquidations 2.0 and then an auction keeper reference implementation that you guys could check, learn from and use that for your own hacks, that you want to build your own tools and so on. Right? So today is pretty much going to be a good introduction to liquidations, how they work, and then that I hope will be a foundation for you guys to start tinkering and building with the available interfaces that the maker protocol provides to you. So, yeah, quick recap, liquidations, overview of the design choices, the smart contracts, lifecycle for liquidation, and then of course, looking at the most interesting feature that liquidation has brought, which is collateral flash lending and in the end will be auction doom keeper walkthrough. So before we start to give you a quick cap, how liquidations happen in maker protocol? They start with a user creating a vault. What that means is the user usually deposits a collateral asset, be it Ethereum or any other assets accepted by the maker governance, and they borrow dive from that position from their assets. So if the collateral price drops, then that vault can be susceptible to the liquidation because the vault has certain parameters that have given the user to follow, such as collateralization ratio, for example.
00:02:24.586 - 00:03:31.070, Speaker B: Right. Because Dai in essence always has to be backed by more than what is borrowed by the users in the end. So if the collateralization ratio is below what is set in the system, then the vault is pretty much open for liquidations, right? So when that happens, as in this example right here, for example, then keepers would act on that, act on the vault and call certain functions to basically take out all the collateral from the vault and sell it on the market, which would need to cover the debt that the user has generated. Pretty much. Right. And if the debt is being paid back, then some of that collateral can be given back to the vault and that's it. Right? And all this is done essentially to make sure that the system is always sufficiently collateralized and the system is not intended to be in debt, right? And yeah, pretty much that's the ATM.
00:03:31.070 - 00:04:08.138, Speaker B: So, moving on. Now, looking at the considerations for this liquidations 2.0 upgrade, why we call it 2.0, because previously we had an initial version that has been released when the multicolored die has been released last year, in 2019, last year. And this new feature has many more improvements from the previous one. And one of them is definitely the single block composability, which it allows you to interact with different other contracts on the Ethereum ecosystem in one block transaction. Right.
00:04:08.138 - 00:05:42.150, Speaker B: So, in essence, what happens there is you could definitely take the collateral from the auction and sell it on the DeFi market and pay back the debt, while you don't have to put any capital yourself into this process. So you just pay for the gas and that's it. Right. And besides that, of course, now you're allowed to do partial bids just as when you do typical normal limit orders, for example, any decks, right, and so on. And the other aspects are just to really incentivize more of a healthy keeper ecosystem with all these new features that are added to really have some sort of a win win situation for the users themselves, for the keepers, but also for the protocol as it intends to always be resilient and have no debt at all. So this liquidation system, it essentially contains a new type of auctions which is a Dodge auction style, which means that when the auction starts, the price of the collateral starts at a higher price and then over a period of time that price decreases deterministically. And yeah, previously liquidations in Megapurgal were an English style auction.
00:05:42.150 - 00:07:26.886, Speaker B: So that means that the price will start at zero and then it will just wait for bids to put a price on the auction and so on. This one is reversed in the intention to protect the protocol as much as possible to make sure that the debt is paid and there's no bad debt, pretty much. So, a quick example of that, let's say there's some system bad debt at around 60,000 die, the liquidations is kicked off and the stocking price of the asset is at $240, for example, compared to what the current market price is on the exchanges. Why it is 240? Because besides pulling the data from the Oracles, the liquidation point of system also adds a buffer on top of the price as to not incentivize but start the higher price auction and then slowly decrease it over time and see what opportunities arise over there. So with that, when the price starts to drop there at some point would be a market participant that will find the opportunity perfect for them. So they will act on that opportunity and buy the collateral or buy directly from their wallet or use the single block composability feature and just act on that trade and buy the Ether and pay back the die to the protocol. So in this case, Alice just buys 50,000 die or to the collateral and they're still left some 10,000 die debt.
00:07:26.886 - 00:08:34.870, Speaker B: And at the time, the price of the collateral still drops. And when it drops to another certain price that is very favorable to some actors, the leftover collateral is bought for the remaining, for example, 10,000 die. And for example, in the case where, for example, there's no option participants in the system and the price still keeps dropping, then it will not drop to zero because there's a maximum duration as well for this auction. In seconds, of course. And after this maximum duration is overdue, then this auction needs to be reset again by some keepers out there. So when it's reset, it basically loops back to the top price and again it's dropping, waiting for some opportunity to be initiated. So, moving forward, so as I mentioned, the most interesting feature that I believe you guys would be very interested in is the zero capital requirements for developing these keepers or working with the keepers with liquidation supernov.
00:08:34.870 - 00:09:41.506, Speaker B: And this is all facilitated through this amazing, interesting exchange kali pattern that has been developed at the foundation, which allows you to basically connect to any DeFi ecosystem out there and take advantage of the arbitrage market opportunities out there to sell the collateral in exchange for Dai pay back the protocol. And in return? If the arbitrage is profitable, of course, you make a change yourself as well. So that's definitely pretty cool. So, going forward now, looking at the liquidation supernova module and its exact contract, it pretty much involves three types of contracts. One is called Dog, one is called Clipper, one is called Abacus. These contracts pretty much are the necessary interfaces that you need to interact when developing for the optionkeeper. So Dog is mostly a contract that's part of the core system of the protocol.
00:09:41.506 - 00:11:00.640, Speaker B: It's just one contract deployed that essentially sets up the global parameters for other liquidations in the system. And then the next contracts which are Clipper and Abacus, they are essentially deployed for each collateral asset that is onboarded onto the protocol. Just to inform you, maker protocol, when it's accepting collateral assets into its system, it generally deploys a set of contract interfaces that are acting like adapters, that are acting as a deposit contract for the assets. And you have also other supporting contracts such as Oracle module contracts that provide the price fee data for the asset, and in this case, the liquidation contracts which are Clipper and Abacus. Yeah. So now moving forward to Clipper, clipper acts as a contract that essentially receives the collateral from the vault and is having it ready for anyone to take that collateral and auction it pretty much right. Clipper is the auctioning contract, let's say, and Abacus is the price feeding contract that Clipper reads the price of the asset of the collateral that is auctioning for pretty much.
00:11:00.640 - 00:12:21.740, Speaker B: So like I said, the Dog here pretty much contains the global parameters of the whole liquidation system in the protocol. And you as a user, when as a user, as a Keeper or as a bot, you scan these vaults and if some of them are underwater, those bots they call the dog bark function. And this function here, it confiscates right away the vault, it takes off the collagen from the vault and it says to the Clipper, it updates the depth in the system that this much depth needs to be recovered. And then it initiates the auction by calling us for the Clipper kick contract, for example, here. And then all the events are fired as well and the auction is active. And now all the Keeper bots out there could act on that and again, moving forward, the Clipper sol contract is basically responsible for the auctioning of the collateral and recovering of the diet debt. And the main function that you have to all be aware of is the Clipper take function where this magic happens when actually a Keeper calls the Clipper contract to perform an option.
00:12:21.740 - 00:13:31.310, Speaker B: And Abacus is just a price feeding contract that it has many price functions in it. And these price functions are just calculating, are defining how the price is decreasing. It's just decreasing in a linear format or more for a stair setting, exponential decrease and so on, right? And these decrease functions are determined usually when the collateral is onboarded and that decision is made by the governance in the MakerDAO. So to move on now to the liquidation cycle, just to start again, the vaults become under collateralized, the vault collateral is confiscated by dog bark. Dog bark then sends confiscated collateral to Clipper contract. Then Clipper contract now starts accepting bids and is collateral for Dai to cover the debt. And that can be done with users who have their own Dai, right? Or that can be done with the Flash lending atomic arbitrage opportunities through the Exchange Kali pattern.
00:13:31.310 - 00:15:16.914, Speaker B: And when for example, the Clipper accepts the bid and covers all the debt, then of course the option is closed. And if there's any remaining collateral in the Clipper contract, then that remaining collateral is sent back to the vault where the user can withdraw. So there's ways to how to monitor the auctions when you want to build your applications. One way is of course to look at the events that are fired once those functions are called, be it kick or take for example where we do when the auction needs to be reset. You could listen to those events also you could just look at the array of the active auctions being ready for auctioning, right? And this array pretty much just holds the ID of the auction, which in essence is just then leads to the sale. The struct here where you have all the necessary information about this specific auction, right? The amount of die that needs to be recovered, the amount of collateral to sell, what's the address of the vault that has been liquidated when the option has started what's the starting price of the collateral asset and so on, right? So here you get all the necessary information that would then fetch in your application to build your keeperbot. And of course regarding the auction status, you just call a get status function and check on the status of the auction and this will just return you if it needs to be reset or not.
00:15:16.914 - 00:17:30.038, Speaker B: And if it needs to be reset, you just call another function called Redo and that resets the auction so it can start again from a high starting price and wait for any bits available out there. A cool feature that is implemented by the governance is to incentivize keepers to redo auctions, for example, or start auctions by calling dog bark. When they do that, they usually are being paid a small fee in Dai to be active and actually partake in the auctioning process. So for example here when you call redo function you just provide the ID of the auction but then you also provide an address, any address you want, be it your cold wallet, hot wallet, or even keep your wallet here. And then you receive a small portion of Dai for calling redo, right? So again to give you a perspective now of how that specific single atomic arbitrage opportunity happens, that happens through the Exchange Kali pattern which is just a simple extra contract that is implementing an interface from the Clipper contract that then it uses to actually act in the DeFi ecosystem. So looking at this diagram here, of course we have the dog contract which essentially starts the auctions for each specific ratchal asset. Then there's a clipper contract for that specific ratchet asset which in turn has the clipper take function which in the end can also lead to the Exchange Kali pattern contract which if USA user want to use that feature or not, right? So this pattern pretty much takes a clipper call interface which you then can build on top and integrate with every other DeFi exchange out there for your own liquidity purposes to do this atomic swap arbitrage.
00:17:30.038 - 00:18:39.374, Speaker B: And at this ripper right here at MakerDAO Exchange Kalis, you'll see some examples already in production that you could get inspired and build. But the most important part is definitely just this function interface right here which is called clipper call. And yeah, that's the steps to go. So how this actually works, when you call clipper take from the Clipper contract here, of course that means that you bid on the auction, you take the collateral, right? So when you take the collateral, of course you have to provide the auction ID the amount of collateral you want to buy from there, because as Ito has mentioned before, it's a partial bid. You can say, okay, I want to just take a fraction of the available collateral and sell it for the fraction of die and just pay a bit of debt back to the system, right? And if that is profitable to me as a keeper, I'll do that. Because if I, for example, take I know there's faults that have millions of die or hundreds of millions of dies. So if you want to sell the whole collateral, then probably there will not be so many arbitrage opportunities.
00:18:39.374 - 00:20:15.406, Speaker B: But if I take, for example, one E and sell it for die, then there might be some arbitrage opportunity which for me as a Keeper, it's my own incentive to act on my own profitability rather than care about the status of the maker protocol. Right, but in essence, indirectly you're also helping the protocol because you're paying back the debt and also you're making cash yourself opportunities from integrating with the atomic arbitrage opportunity here from the liquidation 2.0. So what happens? You provide all this information, but then you also provide a call data into the function as well, which kind of addresses which exchange kali you want to use, to which exchange you want to connect. Do you want to sell your collateral that you want to take from the Clipper to Uniswap or SushiSwap or any other DeFi exchange out there and you provide all this data in the Clipper call to actually act on that exchange through the Exchange Callie contract. Yeah, and pretty much that's the gist out of it. At the Maker foundation we have built a simple auction demo keeper which implements these. It's a reference implementation written in JavaScript, which is not as efficient and effective as you might think, but it does the job and it was used definitely as just a reference implementation.
00:20:15.406 - 00:21:58.370, Speaker B: So this auction demokeeper here pretty much listens to kicked options from the protocol. It fetches all the active option data. It uses this data then to later look for opportunities to defy markets such as, for example, Uniswap, and then it tries to execute a profitable trade on these markets through the Exchange Kali pattern, the atomic swap opportunity. Right? So one of the most important functions in this clipper is definitely this, which is just it uses the clipper take function and there you just provide all the necessary information to act on that trade, right? And then as a last parameter there you can add the flash data, which is pretty much the call data that you then add to the exchange colleague contract that then acts on that trade through the Uniswap exchange, for example, or any other that you choose yourself. So a cool example here, it was done in the spring, some rub bitcoin vault has been liquidated and through this auction demo keeper, we have taken on the opportunity to sell some of the bitcoin on Uniswap. And then we got in total 211 die, which from that 189 has been paid back to the system. And as a profit has been, you as a Keeper receive 21 die in your wallet because you accidentally arbitrage with the auction demokeeper.
00:21:58.370 - 00:23:10.790, Speaker B: This is auction keeper operation diagram, which is also available on the GitHub page right here. GitHub MakerDAO auction demokeeper which you can look and get inspired if you need to, or to understand how the Keeper works. It is essentially the steps how it works, right? So of course as a user you initialize your wallet, you set up your wallet in the Keeper, which now works as a keystore file. Then once you start the Keeper, it starts fetching and decoding all necessary active auctions in the system. And if there's any active auctions, then it goes through the process of reading through the auction list, reading all the amount of collaterals available in the auction that needs to be sold. Then besides that, it checks automatically if there's any opportunities in the DeFi markets out there to sell that collateral. And if there's an opportunity, then it notifies, it prints out the arbitrage opportunity in the console log, then it builds up the call data to be used for that flash loan with the Exchange Kali contract.
00:23:10.790 - 00:24:06.970, Speaker B: And then the actual transaction happens. And when the transaction happens, of course it's one single transaction that does this atomic swap arbitrage opportunity. And if you're successful, if you pay enough gas, or if you're not racing with some other Keeper bot out there, you are successful and you can earn hefty arbitrages opportunities out there by running the Keeper. And of course if it's all good successful, then it goes back into the loop and it goes repeats the process for the next auction and next auction and next auction until there's no more options available in the system. So, yeah, in essence, this is it. I could dive deep maybe in the repo here but I believe it's pretty straightforward. It's a JavaScript implementation.
00:24:06.970 - 00:24:53.642, Speaker B: There's not many files in this Keeperbot generally and you could easily check yourself, but if you have extra time, let me try to show you. So in essence, all the good stuff is happening in the Keeper JS right here. And all the other files are just supporting modules that help facilitate the operation of the Keeper. But in essence, it's all happening here, it's all written in JavaScript. So it's pretty easy to run. There's some basic function that just sets up the wallet, of course. And when this is started, it started with the run function right here which sets up the wallet and everything.
00:24:53.642 - 00:26:17.720, Speaker B: And then it's a for loop that runs through all the collateral assets added to the JSON file in the config where it then starts initiating all the contracts, the Clipper contracts and so on for each collage asset and then start listening on them and seeing, pulling and fetching all the data that is available there to act on these options. Right? So then later opportunity check is called and this is the kind of the main function that it acts actually on the information that's out there on the opportunities. Then it calls the actual send transaction function yeah. And the rest is just supporting functions to help you run the Keeper, be it a Wallet JS, which is a module that sets up your wallet. We're looking at the exchange kali JavaScript implementations. For example, when you need to look for opportunities, the uniswap exchange, then you provide the amount of collateral you want to sell. And then you look for opportunities in the uniswap to see if there's any profiting opportunities that you could take on and then you could act and sell on the market and yeah.
00:26:17.720 - 00:27:38.334, Speaker B: Besides that, we have a transact module. That is a defined module that helps build the transactions in the Keeper. So this module pretty much takes the build transactions they're signed and then they are sent and there's some strategies to make sure if the transaction is failing, then it fails right away before you even spend any gas and so on. Right, so here you could look at and get inspired and maybe improve it further or fork it and pretty much play with it and see where can you go. And of course you can play with it, not necessarily on Mainet because you might just lose gas if you do some build transactions. You could easily play with the coven interface as well on the covenant deployment of the Maker protocol and yeah, do as you please pretty much. And as a last resource I can send you to if you want to look for all the contracts available for Maker Protocol, you could easily find it at docs MakerDAO here and then the contract addresses is pretty much here@changelockmakerdao.com.
00:27:38.334 - 00:28:12.060, Speaker B: You'll find all the addresses for Mainnet or for example for Cobb as well. And here you'll find all the contract interfaces for the protocol that, you know, look into call functions and so on. So with these resources you're more than ready to play with into the liquidations system and building your keepers or doing the atomic swap arbitrage opportunities out there. Yeah, and with that I think I'm good.
00:28:18.190 - 00:28:39.220, Speaker A: Thanks so much, Petru, that was a really great session and a lot of information for 30 minutes. There are a couple of questions in the chat if you want to take like two minutes to just address some of them. Do you need me to read them out or would you like to read them out and then answer?
00:28:39.670 - 00:29:30.178, Speaker B: I can look in the chat and read them myself? Yeah, great. All right, so the first question I see here so the Exchange colleague contract will have pairs of two, ERC, 20 tokens only, right, with one being die. So the collateral can be an NFT too, regarding NFTs. So the way Maker Protocol works, it needs to build adapters for each collateral asset that it implements into the system. Right, and then not just that, for that collateral asset you also need the liquidations for it and so on. Right. So how would you liquidate an NFT? You have to probably first of all, build a specific adapter for it that the NFT can be deposited, which then maker system recognizes it.
00:29:30.178 - 00:30:55.760, Speaker B: And besides that, you need also an Oracle for, right, which determines the price feed data of that NFT. And then if its price drops and then it gets liquidated, how do you liquidate this NFT? Right? So there's a lot of in between, let's say middleware that needs to be built specifically to handle all these edge cases. So that maker protocol could actually end up accepting NFTs. What I can say is that this is actually being worked on by the engineering teams in the MakerDAO. So go have a look at forum makerdao.com and see what you can find with the Exchange Kali contract. In essence, it has this job to just take the collateral assets from the auction, be it if any asset that the system has, right, any accepted assets, and send that collateral asset to an exchange in the DeFi ecosystem, be it uniswap or social swap or anything which is sold for Dai, right? If you don't have a direct sale for for, you can create that in your exchange colleague contract, right? You can sell it for Tether for USDC, which then you sell it for Dai, and then you get that Dai and sell it, put it back into the Maker protocol and you pay back the debt, right? I hope this answers your question.
00:30:55.760 - 00:32:03.220, Speaker B: So Exchange Kali contract pretty much takes any collateral asset from the auction and then it sends it to the DeFi exchange. You define and then you also define how you want to sell that collateral, right? The channels, how you want to direct that collateral assets for Dai, right? And then in the end, what the auction system requires is that you pay back Dai. But how you get the Dai through the exchange for the contract is your creativity and your imagination, right? I hope that answers the question. So, next question. So for creating an auction key for multiplatter die, do we have possibility to join the collateral in a pool of different ESC 20 tokens? Like balancer? And thanks for the die. I don't quite understand the question, to be honest. So for creating an auction keeper from Die, do we have possibility to join the collateral in a pool of different US 20 tokens? Thanks.
00:32:03.220 - 00:33:17.962, Speaker B: Well, I can tell you that. Like I said earlier, the Clipper contract, if it gives you the collateral, then it needs to receive die back in one block to cover the debt for that collateral that you borrowed. Right? So this only has to be done in one block, pretty much one transaction. So again, if you manage through your Exchange Kali interface to do flash lending or whatever you might be creative with, right? You could definitely do that. But all the requirements are that the collateral is given to you in one block, and in return, you have to give back Dai covering that collateral, right. And if you can make an arbitrage opportunity there and make some profits, it's your gain for sure. Is there a window in which I can reclaim before auction my collateral that has been claimed prep for auction? Um, all right.
00:33:17.962 - 00:34:06.426, Speaker B: The time window, I believe you say, right, so if there's a time window in which you can reclaim before auction that your collateral has been claimed and prepared for auction? Well, yeah, I mean, you could just look at the Oracle price feed data because there's a 1 hour delay in maker protocol of the price feed data in the vault. So before that collateral is taken for auction, you just quickly go yourself and pay die back to your vault. So you're not being liquidated, right, because you just check your collateralization ratio and see if that's at the risky level. Yeah, I hope. I answer your question then. A question from bayou. What happens when the price of the collaterals climb so quickly and there is no liquidation fast enough to liquidate the vault? Thank you.
00:34:06.426 - 00:35:34.082, Speaker B: So this is a very, let's say, a black swan event kind of scenario. If this happens, the current implementation of the liquidation process has a circuit breaker contract that essentially will disable liquidations for the protocol if the market price of that collateral asset drops below the accepted range, accepted drop percentage. Right, so that's the current implementation. The protocol engineering team is working now as well in an upgrade to the liquidation process to oversee this patch fix that there is now with the secret breaker implementation. But essentially what happens if the price target declines quickly is that the liquidations are pretty much disabled, but this secret breaker, while there's this flash crash, while the flash crash is done, then it's reinstated and then we check what happens in the market. Okay, so next question is also which are the different option markets possible to flash loan? Well, essentially all the ones that you can do these exchanges in one block transaction, right. So just to think of some, it's definitely uniswap.
00:35:34.082 - 00:36:23.880, Speaker B: And you have SushiSwap, you have Oasis Dex, which is also an exchange built by the maker foundation. You could probably check into balancer as well, do those swaps right and so on. So all you can do in one block, everything is possible. And of course, you yourself have to implement those interfaces for the exchanges that you want to interact with and have them implemented in the exchange kali pattern, which you'll then have that connected to the liquidation 2.0 process. I hope that helps. So, next question, can you provide an overview of a simple implementation for those not familiar with DeFi? So definitely, yeah, you could go check liquidations makerdao.com.
00:36:23.880 - 00:37:13.830, Speaker B: I think I have a link here, right here. So this is a web interface that showcases you how you could interact with the liquidations in the protocol. If there's any liquidations, you'll have basically interface telling you. Okay. This is a lot of collateral being sold, and you can buy as much as for one die if you want. You can give one die to the protocol, and you get something back in return. And also, of course, we have the Keeper bot, which is the auction demo keeper, that you could look more on a technical level if you're interested and see how that works, which is here at the auction demokeeper.
00:37:13.830 - 00:37:19.560, Speaker B: Thank you. Thank you, guys.
00:37:20.810 - 00:37:43.280, Speaker A: Thanks so much. Yeah, that was a lot of questions. Thanks for getting through all of yeah, Pedro will be joining the sponsor make it our channel, so you'll be able to connect with him there as well if you have any questions. And maybe he'll even share the link to his slides for everyone to use as a reference as well.
00:37:44.290 - 00:37:47.520, Speaker B: Definitely, yeah. Just let's get in touch.
00:37:48.130 - 00:37:51.790, Speaker A: Perfect. Thanks so much. And thanks, everyone for joining.
00:37:52.450 - 00:37:53.820, Speaker B: Thank you all. Enjoy it.
