00:00:00.170 - 00:00:22.560, Speaker A: A kind of technical example of integrating with flash swaps on univ three. So that's what we'll kind of go over. I have some diagrams and some code snippets and things like that, and then at the end we can leave some time for questions or feel free to kind of jump in with things if you have questions as we go.
00:00:23.970 - 00:00:24.742, Speaker B: Cool.
00:00:24.916 - 00:00:49.966, Speaker A: So let's get started. I think to begin with, we'll sort of start with kind of like a conceptual understanding of flash swaps and what they are and kind of what they mean in the context of uniswap b three. And I'm trying to get it to actually just click so I don't have to scroll here. 1 second. There we go.
00:00:50.028 - 00:00:52.334, Speaker B: Okay. Yeah.
00:00:52.372 - 00:01:32.406, Speaker A: So we'll kind of just begin with this kind of conceptual understanding of flash swaps. Essentially, a flash swap is kind of the name that we call a form of swapping that allows you to withdraw tokens with no upfront cost and then execute logic just given that you actually end up paying those funds back at the end of the transaction. And we'll kind of go into a simpler example at first before we get into our more kind of convoluted example at the end. So just to make this a little more clear, I don't know why it's.
00:01:32.438 - 00:01:33.660, Speaker B: Not there we go.
00:01:35.150 - 00:02:21.420, Speaker A: We'll start with this example. Essentially, if you guys have heard of kind of like Arbitrage is like a really great example for flash swaps, but in this example, we have two pools, let's say. So we have one pool that's 1300 dith pool. So like the kind of cheaper pool. And then we have another pool that's like the 1500 Die ETH pool without even talking about flash examples. What we can see already is that there's an Arbitrage opportunity, right, so we can buy ETH from the cheaper pool and then sell ETH on the kind of more expensive pool and gain plus 200. And this is sort of not kind of excluding talking about fees and all that kind of stuff, but you kind of get the idea.
00:02:21.420 - 00:03:24.670, Speaker A: Now, bringing in flash swaps, what you could do is actually execute this transaction without any upfront capital. So essentially we can just take advantage of this price difference with one transaction. With a flash swap, it's capital free because you actually don't really need to put capital up front. You can withdraw ETH from that first pool, execute a swap, and then pay back all within the same transaction. And so, yeah, that's kind of the advantage of doing flash swaps. And I think in this next example, I'm going to go through a couple of diagrams with you guys to sort of set up a mental model for all the different pools and things that we're going to look at code for. But by the end, you will be able to hopefully understand how to call the actual flash function that uniswap V three core provides cool.
00:03:24.670 - 00:03:29.440, Speaker A: Any questions here before we get started with the more complex example?
00:03:32.710 - 00:03:35.362, Speaker B: Great. All right.
00:03:35.416 - 00:04:18.000, Speaker A: So in this example, we're going to be talking with three different pools. Each of the pools are uniswap V, three pools of ETH and die with different fee tiers. So just as a reminder, with uniswap B three, each pool is defined by a token zero, a token one, and then a fee tier. So in each of these three pools, we kind of get we cover all the different fee tiers. And this is a fairly not practical example. Like, you normally probably wouldn't see this actually in production, but I think.
00:04:21.250 - 00:04:21.566, Speaker B: It.
00:04:21.588 - 00:05:05.098, Speaker A: Really covers a cool example of flashing. So, yeah, in these three pools, we have three different prices. So we have 1500 ETH die, 1000 ETH die, and a 2000 E die. And we're going to be executing ARB opportunities across two of the pools. So you can see here in the first pool, we can withdraw one ETH and 1500 die. And we'll kind of not really talk about the fees right now and just kind of assume it's kind of baked into withdrawing and the price and all of that. But you'll see later in the code how we ensure that this is going to be like a profitable swap.
00:05:05.098 - 00:05:36.086, Speaker A: So the first step is to withdraw one ETH and 1500 die. We'll end up swapping 1500 die and we'll swap the other one ETH across these other two pools. And so in the end, you're going to get 1.5 E in the first pool and you're going to get 2000 die out of the second pool. So it's 1500 die for 1.5 ETH in pool one. This is the one at the top, and then it's one E for 2000 die in pool two at the bottom.
00:05:36.086 - 00:06:12.180, Speaker A: So you actually end up with some profit here. You'll pay back the original pool, pool zero over here on the left one E, leaving yourself with 0.5 E profit. And then you'll pay back the original pool 1500 die, leaving yourself with a 500 die profit. Does this kind of make sense or any questions here? Essentially, this is the entire scheme of what we'll be coding. So if we don't understand this yet, then it might be harder to look at the code later. So if there's any questions, feel free to shout it.
00:06:12.180 - 00:06:22.606, Speaker A: See also sorry, Sarah, I see Albert.
00:06:22.638 - 00:06:26.420, Speaker C: Asked you to just do like, a once over this again for everyone.
00:06:26.870 - 00:06:28.418, Speaker B: Totally. Yeah.
00:06:28.584 - 00:06:39.762, Speaker A: Let's start kind of back maybe with just, like setting up the pools 1 second. I don't know why it's not clicking.
00:06:39.826 - 00:06:41.142, Speaker B: There we go. Okay.
00:06:41.276 - 00:07:30.598, Speaker A: Yeah, let's just do a quick once over and yeah, feel free to jump into questions as we go. All right, so we're setting up today's example with three different pools. Each are ETH die pools, and they have different fee tiers, right? Because there are three different fee tiers available on uniswap B, three in each of the three pools. They also have different prices, meaning there are ARB opportunities across pool one and pool two. And so this is the kind of upper pool here I'm calling pool one. And then the lower pool here, the 2000 E die, is pool two. And so this kind of diagram shows you kind of the steps that we'll take to actually take advantage of the price differences here in pool zero.
00:07:30.598 - 00:08:06.846, Speaker A: Over here, this 1500 ETH die pool. We can withdraw one ETH and 1500 die and we'll kind of see how we actually do this at the contract level. But essentially we're going to take out both tokens. This is the withdrawal phase. So we take out one ETH and 1500 die. We can then swap 1500 die in the first pool at the 1000 ETH die rate. And we can also take the one ETH that we already withdrew from pool zero and swap it in the second pool, the 2000 E die.
00:08:06.846 - 00:08:47.314, Speaker A: And if we do the math, what we end up getting is 1.5 E for the 1500 die in pool one and then we end up getting 2000 die for one E in pool two. And you can see that there's a gain here, right? We have to pay back the pool one E and we're left over with a profit of 0.5 E from pool one. And then in the bottom, we only have to pay pool zero, 1500 die. So we're left over with a profit of 500 die. And so essentially the profit total is the 0.5
00:08:47.314 - 00:08:51.860, Speaker A: E plus the 500 die that we just arbed across pool one and pool two.
00:08:53.830 - 00:08:54.580, Speaker B: Cool.
00:08:55.110 - 00:09:06.870, Speaker A: Any questions here? It was sort of just another quick once over of how we're using these three different pools and taking advantage of their price differences.
00:09:08.730 - 00:09:16.380, Speaker C: Yeah. There is a question from Dave. If you want to unmute yourself and ask Sarah live, you're more than welcome to. Otherwise I will read it out.
00:09:19.390 - 00:09:33.070, Speaker D: It was just a general question about the flash mechanism. The initial withdrawal. You say it's capital free, so is it all baked into the whole flash loan and repayments or yeah. Why is the withdrawal allowed?
00:09:33.650 - 00:10:32.020, Speaker A: Yeah, so the withdrawal is allowed because of we'll sort of kind of see how this works at the contract level, but it's essentially allowed because of a callback mechanism. So when you actually flash, you are sending tokens to say like a contract and that transaction will revert if you do not pay back the pool by the end of the transaction. So you could withdraw, execute some logic. But at the end of the transaction, because we're going back into after basically the callback happens, we go back into kind of the uniswap core logic and just check, hey, do these pools, is their balance still the same? If so, we can execute the transaction. If not, we just revert and the transaction fails. And so that it's. Like as if that withdrawal never happened? Yeah, great question.
00:10:32.020 - 00:10:59.420, Speaker A: Yes, it actually doesn't necessarily have to be profitable. You could write a contract that's not profitable, but there's no real point in doing that unless you're just kind of playing around and practicing. But in the contract that we'll look at in a second, we actually have a profitability check, a very simple one, but we'll see how that works.
00:11:02.030 - 00:11:02.780, Speaker B: Cool.
00:11:03.550 - 00:12:04.970, Speaker A: So, yeah, let's kind of dive into setting up the actual contract. So I already mentioned a little bit about this sort of like, callback structure, but essentially how swaps and flash swaps on univ three work is through a callback implementation. So the design here is that callbacks are able to give sort of your own contract autonomy of executing sort of this arbitrary logic that we talked about. But like I said before, inside this callback, the pools that you're borrowing from need to be refunded. Otherwise the transaction will be reverted when the callback closes. I sort of have a little diagram, and this is how I like to think about it inside of my head, like these different contracts interacting with each other. So on the left here, we have our contract.
00:12:04.970 - 00:12:47.950, Speaker A: This is the contract that we'll be writing and setting up and kind of going through all the steps that you need to do to actually execute this kind of flash swap logic. And we'll be interacting with the uniswap core libraries or the core contracts. And so that's what this kind of right diagram over here is representing, is the core contract, specifically uniswap B three pool sol. So if you also have that contract open, you could kind of follow along as well. But just a quick overview. Our contract is going to essentially do two main things. One is it's going to call the flash function that's defined in the core contract.
00:12:47.950 - 00:13:36.160, Speaker A: Flash is going to send amount zero and amount one of token zero and token one to our contract. And this is that kind of withdraw phase. And then after that, the uniswap B three Flash callback that we're implementing in our contract is going to, one, do all the arbitrary logic that we talked about, and then two, pay the pool back. And when this flash callback closes, we end up back in the flash function in the core contract, which does the check. Hey, have all the pools that we've touched in uniswap V three been paid back? If so, we'll finish and close the transaction. If not, we'll revert. And so that's kind of how these two contracts interact with each other.
00:13:36.160 - 00:13:41.920, Speaker A: Any questions here? I saw there might be something in the so.
00:13:48.690 - 00:13:58.450, Speaker C: Yeah, there's a question from Gideon who says, does the flash modify the liquidity of the pool in between the loan and the repayment?
00:14:03.050 - 00:14:38.000, Speaker A: No, because the transaction only goes through at the end. So when we're inside our contract executing all of our logic, the liquidity in the pool hasn't actually changed, all of this happens atomically, right? So all of the logic here is going to be one transaction that changes that state in one go. So it borrows and then executes and then repays all in one, if that makes sense.
00:14:38.770 - 00:14:53.780, Speaker E: So in particular sorry, I talk now. In particular, the state of a uniswap contract is not modified, right? If I call, like, the pool liquidity, the number is the same. Like it's not affected by that.
00:14:54.570 - 00:15:10.890, Speaker A: Yeah, you will have to pay gas fees, but you won't have to pay the LP fees, essentially if it reverts, right? Because you wouldn't have interacted with the pools if it reverts.
00:15:13.870 - 00:15:14.620, Speaker B: Cool.
00:15:14.990 - 00:15:16.700, Speaker F: Can we step in for questions?
00:15:18.190 - 00:15:19.530, Speaker A: Sorry, what was that?
00:15:19.680 - 00:15:22.250, Speaker F: Can we step in for questions or should we wait till the end?
00:15:22.400 - 00:15:26.574, Speaker A: Oh, you can step in if you want and I'll also leave time at the end too.
00:15:26.772 - 00:15:48.600, Speaker F: Okay, just a very quick question, and maybe this might be better asked at the end. But if a transaction that includes a flash swap is in a block that is uncled, does a transaction then does it still execute as one transaction in the uncled block, or does it exist as a single transaction in the uncle block? Or can it be split up into.
00:15:51.370 - 00:15:57.210, Speaker A: I'm not 100% sure, but I think it's just one transaction.
00:15:57.550 - 00:15:58.650, Speaker F: Okay, thank you.
00:15:58.720 - 00:16:03.820, Speaker A: But yeah, I'm going to have to double check on that one. Thank you. Great question, though.
00:16:06.510 - 00:16:07.260, Speaker B: Cool.
00:16:07.790 - 00:17:38.374, Speaker A: So, yeah, I think if this kind of makes sense, we can kind of go into some of the code snippets of just what is the actual logic that we're calling and what are the functions we're calling with the uniswap V three pool sol? Oh, actually this is a good slide to maybe just put all of this logic kind of back in that mental model of the diagram we saw earlier. So this withdraw phase happens inside of flash when we call the flash function that exists in the core contract and then the callback in the callback is when we're actually executing the two swaps that we talked about earlier. So this is just a great slide for if we need to kind of refresh on the mental model of what's actually happening here and what stages are happening in what contracts. So we can come back to this at the end too, after we've kind of looked at the code. All right, so in the contract that we're setting up, we essentially create a pool and then call flash on the pool with the parameters. The first parameter is the recipient. So we put the address of this contract as the recipient so that we receive the withdrawn tokens, like our contract wants to custody these tokens.
00:17:38.374 - 00:18:28.794, Speaker A: Now we also send the amounts of the token zero and token one, because that flash needs to know, okay, how much are we withdrawing of each of the tokens? And then we're going to send this abi encoded data. This essentially is just data that we want our callback to have. And so you can see on the right hand side here, we have this splash callback data struct that has the amounts. We need the amounts inside of the callback to know how much to repay the pools. We also have a payer. So this is the message sender. So who is going to be taking profits at the end? And then the three parameters at the bottom are the various pools that we're going to be working with.
00:18:28.794 - 00:19:07.030, Speaker A: So in our example, we had three different pools. So the pool key is basically the unique pool. So that's going to be the die ETH and the original fee of the pool that we're withdrawing from. And then pool fee two and pool fee three. Specify the other two fee tiered pools that we'll be working with basically in taking advantage of the ARB opportunity. And all of this data, we don't really touch inside of flash. It's just being passed to flash so that we can ingest it into the callback, which is called inside of flash.
00:19:07.030 - 00:19:55.154, Speaker A: So that's kind of the first step is let's initiate flash. The second step is actually implementing the V three flash callback. So in implementing the V three flash callback, we'll define a function uniswap v three flash callback that takes in a fee zero, a fee one and data. And this data is just going to be this flash callback data here that we defined earlier. The fee zero and fee one are computed by the flash function and that just tells us what fees we owe essentially on token zero and token one when we repay the original pool. So kind of getting into the logic here. The first step is kind of just some setup.
00:19:55.154 - 00:20:53.318, Speaker A: So let's decode this data parameter, which is the flash callback data. And again, just a quick reminder that's kind of the amounts that we've withdrawn the original kind of payer or the person who's going to be collecting the profits, and then the three kind of defining features of the pools that we're working with. And then we'll also verify the callbacks. We want to make sure that this callback is coming from the original pool. So we have the factory address and the pool key of the original pool that we're withdrawing from. We'll approve the swap router to actually ingest token zero and token one. Essentially we need this because we're going to be swapping token zero and token one, right? And that kind of goes back to this diagram here.
00:20:53.318 - 00:21:07.790, Speaker A: The swap router handles all this kind of like swap logic. So we're going to approve them to spend token zero, amount zero and token one, amount one. And that's the 1500 die and the one ETH from this diagram.
00:21:11.410 - 00:21:11.822, Speaker B: Cool.
00:21:11.876 - 00:21:41.080, Speaker A: So here is actually kind of somewhat of a profitability check, which is amount one min and amount zero min are like the minimum amounts we want to receive from the swapping because it's the amount one plus the fee that we owe and the amount zero plus the fee that we owe. If we receive less than this, we'll be losing money, right? So we'll do kind of like some profitability checks here with that.
00:21:41.930 - 00:21:42.390, Speaker B: Cool.
00:21:42.460 - 00:22:15.982, Speaker A: So now we're ready to actually execute our first swap. So we call exact input single. This is just one of the swap functions that we have available in the core contract. There's a couple of different ways you could swap. This is an exact input swap. So essentially we will be sending the contract an exact input. So for some input, just give us the exact out, the maximum amount out for this swap.
00:22:15.982 - 00:23:22.840, Speaker A: And so not to get too in the weeds with the parameters, but essentially we just have to specify which direction the swap is in. So we want to go from token one to token zero, right? We're swapping that if we look back in this example, we're swapping the die for ETH, die being our token zero and ETH being our token one. So we specify that in the first two parameters and then our fee for here we're doing the pool with fee tier two. The recipient is this address, right? So we want to hold the tokens that come from this swap. The deadline is sort of just arbitrary. In this example we set it to like far in the future in production. You probably wouldn't do that, but just for this example and then our amount in is the amount one and then our amount out minimum we set to amount zero min, which is what we just calculated back here.
00:23:22.840 - 00:24:21.702, Speaker A: Essentially that just says if we don't get at least the amount zero min then revert the swap and actually just will revert the entire transaction. And then this last parameter here, the square root price limit x 96, essentially just specifies at what price do we want to swap up until only really advanced use cases would use this. And we set it to zero here, which means we're willing to swap up to kind of like any price up until any price and then same for this amount out one instead of token one to token zero, we're going to be going token zero to token one. And so that's what this bottom kind of swap is doing here. Instead of going die to ETH, we're going ETH to die. And it's the same parameters and such. Just the only thing that changes is just we're using a different pool.
00:24:21.702 - 00:25:29.462, Speaker A: So that's why we set the fee tier to be the pool fee three instead of the pool fee two. And so after these execute, we now have a parameter amount out zero and amount out one which should strictly be greater than the kind of original amount zero and amount one that we have withdrawn. So if this is sort of doing the pay back to the contract. Right. So if our amount zero min and our amount one min, which are the amounts that we owe to the original pool, and I'll just go back here to convince you of that amount one min and amount zero min are the amount one plus the fee and the amount zero plus the fee. So this is what we owe back to the original pool. If what we owe back to the original pool is greater than zero, then let's pay the pool the amount minimum of token zero and the amount minimum of token one, and then we can pay the profits back to message sender.
00:25:29.462 - 00:25:50.760, Speaker A: So if the amount out zero is greater than amount zero min, meaning there are profits, let's calculate that profit and then pay that profit back to the message sender, which we have in that kind of like flash callback data, right? We encoded that as the payer and then same for token one.
00:25:53.050 - 00:25:53.846, Speaker B: Cool.
00:25:54.028 - 00:26:09.760, Speaker A: So that's actually the last step. I know we went a little bit fast there, so I'll leave some time for questions. Yeah, and feel free to just kind of unmute and talk out loud if you want.
00:26:12.610 - 00:26:21.200, Speaker C: Yeah, I see there are a couple of questions that came in the chat. I'm not sure if Varun feels comfortable unmuting and asking the question live.
00:26:22.770 - 00:26:33.160, Speaker F: I don't mind. Thanks for giving me the opportunity. So I guess two questions I had were is there a way to calculate gas fees? I mean, sorry, not gas fees, the loan swap fees ahead of time.
00:26:36.570 - 00:26:44.658, Speaker A: Well, yes, I think the fees are going to be equivalent to it depends on what pool you're working with.
00:26:44.844 - 00:26:45.580, Speaker B: Okay.
00:26:46.590 - 00:27:23.166, Speaker A: We specify the fee tiers here. So it's just this I'm pretty sure just this times the amount that you're borrowing will be the fees. But you can just look in the core contract and see how there's like a formula that they use to calculate the fees depending on how much you're withdrawing and what pools fees here you're working with. So, yeah, is your question like doing it off chain before I even try to execute a swap or doing it during the actual swap?
00:27:23.358 - 00:27:41.478, Speaker F: Well, I mean, you've already got a profit check in the code Walker, you did. So I just want to clarify, the fee that I'm referring to isn't the fee for executing a swap on a pool, it's the fee for borrowing or running a Flash loan.
00:27:41.574 - 00:27:41.978, Speaker B: Yes.
00:27:42.064 - 00:27:43.754, Speaker F: Was that clear? My question. Okay, cool.
00:27:43.792 - 00:27:44.380, Speaker B: Yeah.
00:27:44.990 - 00:28:00.510, Speaker A: And that's all calculated inside of Flash. So that's why it's an input into where is it? It's an input into our callback. So this just tells us how much we owe from what we've borrowed.
00:28:01.170 - 00:28:01.882, Speaker F: Got you.
00:28:01.956 - 00:28:04.658, Speaker A: Okay, I don't know if that kind.
00:28:04.664 - 00:28:11.746, Speaker F: Of it does answer the question. Out of curiosity, the calculation for fee zero and fee one, is that available somewhere to review?
00:28:11.848 - 00:28:12.798, Speaker B: It is totally.
00:28:12.894 - 00:28:36.170, Speaker A: It's inside this contract. So remember how I talked about we are writing a contract, this is our contract on the left, and we're integrating it with the core contract. So you can just go to GitHub or whatever and look at this specific contract, the uniswap V three pool. And all of this math is happening inside of Flash, which we are calling from our contract.
00:28:36.590 - 00:28:37.354, Speaker B: Got you.
00:28:37.472 - 00:28:53.886, Speaker F: Okay, thank you. Thanks, Dave. I'll go look through that. And the second question was the parameter you mentioned that was designed for more advanced cases. I think it was a square price limit, x 96. Is that akin to a slippage limit that you set when you trade?
00:28:53.998 - 00:29:32.640, Speaker A: Okay, yeah, you can use it if you're like. Totally. How you would set it is you could do some inline calculations or setting a certain slippage that you'd want to adhere to, and then it would involve some other math and calculations to actually put it into this square root price format. But then you could set that and it would be sort of like a slippage check or just like a price check in general where you could add slippage into that calculation such that you won't swap past a certain price.
00:29:33.250 - 00:29:51.060, Speaker F: And is the reason for including this check because if this transaction executes somewhere in the middle of the block and the state of the pool has changed from what you read in the previous block to the middle of the current block, is that why that you had this check inside?
00:29:51.750 - 00:29:53.380, Speaker A: That could be a reason.
00:29:53.750 - 00:29:54.222, Speaker B: Okay.
00:29:54.296 - 00:30:31.114, Speaker A: It could also be like if you're working with there's lots of reasons. For example, because in Uniswap B three, we have this notion of ticks and liquidity per tick. Essentially you could run into a case where there's lots of liquidity in between a certain range here and then none for a while. This probably wouldn't happen, but it could. And so how the algorithm works is we'll keep swapping you up the curve until your swap is finished.
00:30:31.162 - 00:30:31.374, Speaker B: Right.
00:30:31.412 - 00:31:03.820, Speaker A: And so if there's a range where there's no liquidity, then we'll actually hop you to that next price. And so it's sort of like a safety check of like, okay, maybe it's actually not a great time to make that trade. Got you. Because you're going to be swapping across all these ticks or all these ranges. And so just that's like a boundary. But that should be like a very rare case because liquidity is usually distributed pretty normally across the current or the spot price.
00:31:07.090 - 00:31:07.886, Speaker B: Perfect.
00:31:08.068 - 00:31:09.870, Speaker F: Thank you so much. I appreciate it.
00:31:10.020 - 00:31:18.328, Speaker B: Sure. It's cool.
00:31:18.494 - 00:31:20.250, Speaker A: Are there any other questions?
00:31:22.400 - 00:31:23.420, Speaker E: Yes, hi.
00:31:23.570 - 00:31:25.644, Speaker G: Can we see the slide before the last one?
00:31:25.682 - 00:31:27.180, Speaker E: I think you were paying fees.
00:31:28.160 - 00:31:33.004, Speaker A: Yes. Let's see here. Right.
00:31:33.122 - 00:31:35.600, Speaker G: Can you just explain that again, please?
00:31:35.670 - 00:32:24.350, Speaker A: Totally. Yeah. This logic is doing the repay to the original pool. So if we look back to here inside the callback after we execute the swap, we have to pay back this original 0.3% 1500 E dive pool with the original amounts that we've withdrawn plus the fees that have been calculated for us for doing this flash. And so all we're saying is from our address, from our contract repay repay the amount to the contract, basically.
00:32:25.680 - 00:32:27.390, Speaker G: Okay, thanks.
00:32:29.760 - 00:33:11.516, Speaker H: For going to my name is Mark. I've got a question related to the differences between V two flash swaps which I just spent the morning figuring out and V three. So some of the differences I can see is that this is fee one and fee two, whereas at least the code I was working on my own contract just calculated what the fee was supposed to be and basically in the end I'm sort of repaying one token and not two. So I'm just trying to understand some of the differences here.
00:33:11.698 - 00:34:07.040, Speaker A: That's a really good question. In uniswap V three, essentially there's two ways to do flash swaps on V three. One is to call Flash, which we're doing here. The flash function is a specific type of flash that allows you to borrow two tokens for one, but it allows you to borrow both. In V two, we don't have that. To simulate something more similar to V two, you could actually just call swap. You could essentially emulate a flash swap similar to V two by calling swap because we have a similar logic of doing a callback with just the regular swap function that we define in this same contract.
00:34:07.040 - 00:34:44.920, Speaker A: And so instead of specifying two tokens that you could borrow, you'd just be executing a swap, right? Like a regular swap, one token for another. But because we have this callback architecture, all swaps are technically a form of flashing because it withdraws the token first, executes some arbitrary logic and then pays that pool back. If you're trying to emulate more of like a V two style flash swap, you would just look at the function called swap in this same contract where flash is defined.
00:34:45.340 - 00:34:58.690, Speaker H: Okay, so that's what I'm doing right now. In V two is calling swap. So that part might remain the same, but the callback would be different. Right?
00:35:00.260 - 00:35:14.836, Speaker A: You would have to go look at how we implement. You would have to write a contract that implements the I forget what it's called, it's something different, but it's like uniswap B three swap callback or something like that, right?
00:35:14.858 - 00:35:26.168, Speaker H: Yeah, I think I saw reference to that. So the second part, the callback sounds like would be different, but perhaps just calling swap that might actually be the same.
00:35:26.254 - 00:35:37.004, Speaker A: It's similar, I'm sure I can't remember off the top of my head what the exact differences are, but for example, you'll have to specify the fee and set up the pool as a V three pool, right?
00:35:37.122 - 00:35:56.050, Speaker H: Not a V two pool, right? Yeah, I guess there would be some differences because of that because there's no notion of different pools at different fees in V two. Okay. I'll have to look into that. Okay. I think that helps. Just trying to figure out a scenario where I'd be paying back one of the two.
00:35:59.560 - 00:36:14.170, Speaker A: Yeah, great. Really good question. And it is a bit confusing because there is sort of like two types of kind of flash swaps you can do with V three because of this.
00:36:15.100 - 00:36:23.550, Speaker H: My other small question is apologies, I missed the first part here. Maybe it was discussed, but I noticed you're using a pay function.
00:36:24.640 - 00:36:32.648, Speaker A: Yeah, I think that's just something we've defined in one of our yeah, if you look at, I think the transfer helper contract.
00:36:32.824 - 00:36:36.732, Speaker H: Okay. That's where that's from. Right.
00:36:36.786 - 00:36:39.950, Speaker A: Okay. I don't remember if that's specifically it.
00:36:40.340 - 00:36:41.792, Speaker H: Okay, I'll look for it.
00:36:41.926 - 00:36:44.850, Speaker A: It's defined in one of our libraries or something.
00:36:45.300 - 00:36:45.868, Speaker H: Okay.
00:36:45.974 - 00:36:46.870, Speaker B: Thank you.
00:36:51.400 - 00:37:18.750, Speaker A: Albert. I don't know if there's a specific tutorial that I could point to, but we have this contract that I just walked through today up on our GitHub in the periphery repo. So I feel like if you want to read the full contract, it's all compilable. That would be a good place to start.
00:37:25.780 - 00:37:26.528, Speaker B: Cool.
00:37:26.694 - 00:37:29.760, Speaker C: Has anyone else got any questions for Sarah?
00:37:30.100 - 00:37:48.070, Speaker G: Sorry, one more question. Actually, I haven't asked that question before. One question more about the purpose of doing these flash loans. I'm assuming I don't want to say free money. If it's free money, everyone is doing it, and surely it's been Arped out of the market by now.
00:37:48.520 - 00:37:49.220, Speaker B: Yeah.
00:37:49.370 - 00:38:10.060, Speaker G: So is there an incentive to do it other than I'm assuming one of the reasons is to keep the pools in check or keep the prices in line with the rest of the market. But is the incentive big enough for people to take that sort of risk?
00:38:11.280 - 00:38:56.220, Speaker A: Yeah, I mean, the incentive is really just like the profit across pools, and you could do this across different protocols as well. Right. So it doesn't just have to only be like uniswap pools. So I think that there is a big enough incentive. I mean, people are running arbitrage bots all the time. I think the big thing is they have to be really fast. And because there are so many of these bots and such, it's probably unlikely that maybe there's some open source, like our bots and stuff, but probably unlikely that you would beat a lot of the big players that have been doing this for a while.
00:38:56.220 - 00:39:06.430, Speaker A: But the incentive is still there, and it is really good because it keeps the prices essentially you're arbing the price to the true price. Right.
00:39:10.580 - 00:39:35.076, Speaker G: You mentioned you need to be fast enough, but wouldn't you say in the blockchain world, where a block might take time to be mined and all the transactions to be processed, it's not as fast as, say, high frequency trading in the traditional. So when you say fast enough, is.
00:39:35.098 - 00:39:54.400, Speaker A: That I guess, fast enough, as in quick enough to recognize which pools can be ARB and then fast enough to get your transaction in first. Right. Because you're competing against other bots that have probably seen similar ARB opportunities.
00:39:57.380 - 00:39:57.792, Speaker E: Cool.
00:39:57.846 - 00:40:07.600, Speaker G: Okay, that makes sense. And I guess that's why some ARB traders pay extra gas fees to get their transaction through.
00:40:07.670 - 00:40:08.288, Speaker B: Right?
00:40:08.454 - 00:40:28.360, Speaker A: And so that's another thing you have to think about, too, is when you're calculating your profits, you still want to make sure that the profit is greater than all of these fees that you're paying combined. Right. So that's like, another thing that you could add on in your kind of implementation of flash swaps.
00:40:30.380 - 00:40:31.630, Speaker G: Cool, thanks.
00:40:33.040 - 00:40:33.790, Speaker B: Cool.
00:40:34.560 - 00:40:42.508, Speaker C: Great. There's just one more question from Lucas, which is this work is on testnet or not?
00:40:42.594 - 00:40:53.250, Speaker A: This contract specifically is not deployed, but it's open sourced, so you could deploy it on a testnet or play around with it if you want to.
00:40:55.300 - 00:40:55.712, Speaker B: Cool.
00:40:55.766 - 00:41:17.750, Speaker C: Thanks so much, Sarah. Yeah, thank you for that really great session. And thank you, everyone, for joining and for all the questions. If you want to connect with the Uniswap team, you can find them in discord. And I'm sure Sarah will be more than happy to link me to the slides, and I'll be sure to share that with you as well.
00:41:19.240 - 00:41:19.796, Speaker B: Cool.
00:41:19.898 - 00:41:21.176, Speaker C: Thanks so much, Sarah.
00:41:21.328 - 00:41:21.932, Speaker B: Cool.
00:41:22.066 - 00:41:22.876, Speaker A: Thanks, guys.
00:41:22.978 - 00:41:25.000, Speaker C: See ya. Bye.
