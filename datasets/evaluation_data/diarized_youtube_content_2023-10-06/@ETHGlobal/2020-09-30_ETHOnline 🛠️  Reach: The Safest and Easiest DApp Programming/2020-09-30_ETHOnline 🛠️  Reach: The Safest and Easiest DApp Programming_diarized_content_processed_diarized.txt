00:00:19.310 - 00:00:45.066, Speaker A: Cool. Jay, if you're ready to get started, we're good to go. Awesome. Well, nice to see you all, everyone. It's great to be part of this worldwide global hackathon event. And I'm excited to show you today about the Reach programming language by way of a little bit of introduction. My name is Jay McCarthy.
00:00:45.066 - 00:01:37.040, Speaker A: I'm a research professor at a university in Massachusetts and the CTO and co founder of Reach. And what I'd like to do for you today is give you a bit of a walkthrough on what Reach is and what it can do. Over here on the screen share. On the left hand side you'll see a terminal and I'll be typing in some code and stuff there. But for now, let's look over on this other side for a moment where we have just some quick slides. I want to point out, if you would like, you can go to the discord channel on the Ethereum hackers server called Sponsor Reach. And you can also go to our community Discord, which is Discord reach sh.
00:01:37.040 - 00:02:20.534, Speaker A: And we will be doing prizes for people who use Reach in the hackathon. I'll remind you of this later. Now if you would like to go and follow along with some of the stuff that I'm doing today, then you can go to our documentation which is at docs reach. Sh. And you'll get this page right here. So I'm going to be talking about things that are mainly in the overview and then a little bit in our tutorial. Like I said, if you want to follow around, you can open up the overview and you can also install there's multiple places where you can find installation instructions on the docs.
00:02:20.534 - 00:03:19.274, Speaker A: But I'm going to look at this one right here in the tutorial and I'm going to copy this line over here into My. So I'm going to go and make a directory called Reach, go into it, copy this to download Reach, and then I'm going to run Reach version to see which version I have and then make sure that I have the compiler set up by writing Reach. Compile help. And Reach is a completely dockerized application, so you don't need to really download anything other than you have docker installed and you have this little shell script that manages interacting with the docker containers that we've made. Now what I want to do is tell you about what Reach is and what it does. So I'm going to edit a file that we're going to call index RSH right, a Reach program. Now Reach is a DAP programming language.
00:03:19.274 - 00:05:15.998, Speaker A: Now when we say DAP programming language, we don't just mean a smart contract programming language like Solidity or the other variants of languages like Solidity that add more type features or make a higher level language or a different syntax. Because when you write a program in a smart contract programming language, one of the main things that you're doing is you're thinking about what is my Smart Contract, what is the state of the Smart Contract and what are the valid transitions between one state to the other state? And what other Smart Contract programming languages do is they basically give you tools to help manage your thought process of understanding what kind of state machine you want to build and which transitions are allowed. Now, from our perspective at Reach, we think that this is not the way that most people are inclined to think about the kinds of interactions that they want to enable in a decentralized application. And so instead, what Reach does is it takes the perspective that when you're writing a decentralized application, you want to think about all of the different participants to that interaction and then say what actions they are allowed to take. And when you say what actions they are allowed to take, we can then figure out behind the scenes what the state of a computation should be and which transitions are allowed. So what I'm going to do now is give you a little example of this. Now if you're following along and you download and open your own index RSH file, it's probably not going to be marked as syntax highlighted, but Reach is a subset of JavaScript.
00:05:15.998 - 00:05:56.978, Speaker A: So you can just mark it as being JavaScript in whatever code editor you use and you should be fine. Now, because we're a subset of JavaScript, we have a little tag at the beginning to indicate that you intend this file to be parsed as a Reach program. So we put at the top Reach and then the version number. And what we're going to do is we're going to define an export. So like I said, it's just like writing a JavaScript program. So we're going to define a constant main and this is going to be our Reach application. Now, a Reach application, we're going to define a few different pieces of it.
00:05:56.978 - 00:06:41.760, Speaker A: So we're going to define some compile time options, which for us will be not relevant. We're going to write down a list of the participants. So the participants and also we're going to then write a function. And this function is going to perform the computation of the decentralized application. So for now, let's just make it so that there's no participants and it doesn't do anything. So this right here is a sort of trivial Reach program that just shows the pieces of what a Reach program does. Now, I don't want this walkthrough to be only about the syntax of what you type in when you write a Reach program.
00:06:41.760 - 00:07:36.420, Speaker A: We want to think about the larger idea about what a decentralized application is. So let's make a really simple decentralized application. In this one, what we're going to do is we're going to have two participants. And these participants, we're just going to choose the name, the colloquial names Alice, and we're going to choose the other name, Bob. These are kind of like classic names that are used when you're writing a cryptographic protocol and you're talking about online interaction to sort of be the anonymous people. Now, what Alice and Bob are going to do in our little program is that Alice will ask Bob for some funds. Then Bob will send the funds and Alice will take them.
00:07:36.420 - 00:08:17.658, Speaker A: So this is a really simple interaction that's not really a useful, decentralized application. I'm just kind of giving you the idea about what Reach is doing. And we'll kind of have behind the scenes of this, that when Alice takes them, she'll share something. She'll share some information. Some information. Now, like I said, we want to focus on the really simple ideas. So I don't want to have the tutorial be making a crowdfunding campaign or something like that because I don't want to get lost in the weeds.
00:08:17.658 - 00:09:10.350, Speaker A: I want to talk about kind of the big picture. Now in a Reach program, inside of this function, which again, we write like a JavaScript function, what we do is we write down what each participant does. So how do we do that? So first of all, because we said that there are two participants, Alice and Bob, this function that defines the behavior of our decentralized application is going to take two arguments. We can call them Alice and Bob. And what these two things do is they represent that participant and we're going to write down what actions they take. So for example, we can write down the action that Alice is going to publish something. Now Reach, we use the terminology, a publication to mean that one participant sends information out to the wide world.
00:09:10.350 - 00:09:47.462, Speaker A: Because remember, on the blockchain, like Ethereum, all transactions are public. And since all transactions are public, that means that the actions that individual participants take, we call them publishing events. Now, if Alice wants to ask Bob for some funds, that means that she has to ask for a specific amount of funds. So we're going to write down here the amount that she requests. Now, if we were to run this program, let's stop for a moment and see what happens when we run it. So I'm going to save, go back to the command line, Emma, type reach. Compile and it's going to give me an error.
00:09:47.462 - 00:10:24.834, Speaker A: It's going to give me an error because we didn't say what amount is. We'll see what it says. It says on line twelve, it's an unbound identifier amount. Did you mean these other things that are built in functions? So the thing is that of course, this program doesn't contain anywhere what the amount is. What we'll do is we'll say that to figure out what the amount is, alice is going to take an action totally on her own. So we're going to write Alice only. And then we're going to pass in a thunk, which is a function that takes no arguments.
00:10:24.834 - 00:10:59.634, Speaker A: This is kind of like a normal programming idea. And so here's kind of the first look at one of the big ideas in Reach. So in Reach, the entire program, which is in between these braces right here is every action that every participant is going to take. And some of those actions involve other participants. Like for instance, when Alice makes this publication that means that on the other side bob is going to learn what she published. But there are some things that Alice can take entirely on her own. For instance, she can decide what amount she wants to do it.
00:10:59.634 - 00:11:54.414, Speaker A: Now we could write down something like she has the amount of 42 or something like that. But of course this is not really how a good application would be designed because we don't want to hard code any exactly what it is because we don't make a decentralized application that can only deal with 42 units of currency. Instead, what we want to do is make it so that every time we run this we can have a different thing. Now in a normal programming language where you weren't programming an entire decentralized application we might do something like add an argument to this function that would take in what the amount is. But the thing is that with Reach programs don't specify one function. They instead specify an entire computation regarding many different participants. Now the way that we're going to do this is that these little objects right here that we pass when we define the participants is what we call a participant interaction interface.
00:11:54.414 - 00:12:55.720, Speaker A: And what a participant interaction interface is is it is the interface between the back end code that Reach is going to generate and a front end that you would write in JavaScript or Go or something like that that would provide the actual user interface for your, for your application. So we're going to write down that there's going to be something in this interaction interface that we're going to call her request and her request. When we specify this object we're going to say what type it is. We're going to say that it is an unsigned integer 256 because that's kind of the standard type that we have on Ethereum. Now here we can say then we can say interact, interact request. So what this does is it says that the amount is going to be whatever is in this interaction interface and we want the request key. Now we can go try to run this.
00:12:55.720 - 00:13:44.790, Speaker A: We can run Reach compile and see what it says. It so it says that this is an invalid binding because secret Identifiers have to be prefixed with underscore. Did you mean to declassify this? This is kind of the next big idea of a Reach program that in Reach programs there are two kinds of information. There's information that is secret to only one participant and then there's information that has been published. And it's very dangerous to accidentally share things that you intend to keep secret. So what Reach does is it mandates that you essentially click a little box that says I confirm that I really want to share this. And the way that we do that is that we call a function called declassify.
00:13:44.790 - 00:14:43.126, Speaker A: And what declassify does is it says this value is now allowed to be shared with the world. And so now when we run this program now when we run this program, it'll work well. I mean, it'll go to the next thing but the program isn't finished yet. And so now it's going to say that you can't do exit right now. So we've successfully read request, we've bound it to the variable amount and then we've published that. Now the next part of the program sorry, the next thing that goes on in a Reach program is that anytime you write a publication like this, the perspective of the Reach program switches to what is happening in the consensus network. Again, going back to the model of what a Reach program does, the way that you want to think about a Reach program is that you have each of the participants and what actions they want to take.
00:14:43.126 - 00:16:35.600, Speaker A: And every time one of them does some action that is shared with the entire world, we then take the perspective of the world and we say, well, what should be true about that publication? So for instance, we could do something like we could write down that we are going to require that this amount be less than 100. And I don't know why, we're just sort of spitballing, you know what I mean? And so here we can write down constraints on what things could be published and then when we're done writing down all of those constraints, we're going to commit to this being what happens in the program. Now at this point we have committed and the perspective goes back to all of the participants and we can write down things, for instance, that Bob does or Alice does and so on. Now I want to just pause one moment and see what happens when we run this program. Well, when we compile it, when we compile this program, it turns out that it says that there is an error, there's an error that Reach tried to prove six theorems about our program, but there is one failure. This is kind of the next big idea about Reach programs and that Reach programs automatically take your program sorry, the Reach compiler automatically takes your program and sends it to a theorem, prover and verifies that every requirement in your program is actually satisfied by all runs of your program. And so what this means is that this requirement right here may not be true because Alice doesn't actually check to make sure that the amount that came back from the interact interface is really less than 100.
00:16:35.600 - 00:17:36.926, Speaker A: And so we can write down a check like that by writing assume that the amount is less than 100. Now, when we write this, what we're saying is we're saying that Alice, when she plays this game honestly, she always checks to make sure that the amount is less than 100. And anytime when we have a publication by someone playing the role as Alice, we always check to make sure that their amount is less than 100. So behind the scenes, what goes on is that this assumption right here is going to get turned into a runtime check on the client side of our Reach program. And this requirement right here is going to be turned into a runtime check inside of the Consensus Network contract and notice that Reach guarantees that these are always matching with one another. There are other kinds of assertions and verifications that Reach does. But I won't talk about those right now.
00:17:36.926 - 00:18:35.090, Speaker A: We'll talk about them a little bit later. Okay? So now what we can do is we can do kind of the other side of the interaction, which is what Bob does. So because we've committed, we've now switched and we're back in the perspective where any participant can do something. So we'll write down here, we'll write down Bob only, and we'll pass a funk. And in this funk, what we're going to do is we're going to call interact and we're going to say that Alice wants this amount. So what we're going to do is we're going to go up to his interaction interface and we're going to say that he has an interface function that's called Want. And the idea behind this is that Bob, of course, is not always going to spend these funds because what if Alice asks for too much money? You know what I mean? Right now he's only willing to buy some information for 40 units, but maybe tomorrow he'll be willing to spend more.
00:18:35.090 - 00:19:36.994, Speaker A: So what happens is that this interaction interface not only contains values like requests, but it actually also contains functions. So we can write down that there's a function inside here and we'll say that its argument is that it takes in a UN 256 and returns nothing. And so now what's going to happen is that when we run this Reach program, when we compile it, that is, behind the scenes, we're going to generate JavaScript backend that will have a call from Bob's backend to Bob's front end code where he can do something with this want value. And maybe one of the things that he will do is he won't return because he doesn't want to continue with the program. But supposing that he does, then what Bob is going to do is Bob is going to pay the amount and then we'll commit the transaction. Now pay is like publish, but Bob doesn't know anything that the rest of the world needs to find out. And because he doesn't know that know, there's nothing for him to publish.
00:19:36.994 - 00:20:05.022, Speaker A: But what he can do is he can pay funds. Now, when he pays these funds, he's not paying them directly to Alice. Instead he's putting them in basically an escrow account that is associated with the smart contract. Of course, on Ethereum, that means he transfers money directly to the contract. Now notice that Bob can look at this value amount and he can look at that amount here. He can pay it and we can require it there. That's because Alice published this.
00:20:05.022 - 00:20:58.542, Speaker A: If Alice didn't publish this, then it wouldn't work. So if I comment up this line and have her do an empty publish, then this program isn't going to work because it's going to say that amount is unbound. So it's going to say here that this is an unbound identifier on line 17. So line 17 is this one right here, that this amount isn't bound because publication, what it does is it provides that value for the entire world, including the smart contract perspective. So now we run the program and we get another theorem failure. And this theorem, there's actually four failures, but they're different versions of the same one is called the zero balance theorem. And what's the zero balance theorem? So this is, again, one of the things that Reach provides automatically for you behind the scenes.
00:20:58.542 - 00:21:44.570, Speaker A: It's going to guarantee that whenever you write a decentralized application, the escrow account never ends with funds inside of it. We've all heard about smart contracts being released where there's some error in the program and funds are locked away forever and they can't be gotten back. Well, that's exactly what Reach is protecting in this instance. It guarantees that all paths through your program must always end with the balance being zero. And of course, what happens here is that once Bob pays this amount, the escrow account now has those funds in it. But then the very next thing that happens is an exit because we haven't finished the program. And since it's just an exit, that means that there's funds left over and this is illegal.
00:21:44.570 - 00:22:18.540, Speaker A: It doesn't happen. It's not allowed to happen in Reach program. So it fails to compile. This is very similar to how when you program in a safe programming language like OCaml or Haskell or ML or another version of ML or something like that, you are protected against type violations. So Reach is, of course, a typed language. It's a typed variant of JavaScript, essentially. But in addition to protecting you against errors based on data, it also protects you against errors based on sort of the economic logic of this program, of your program.
00:22:18.540 - 00:23:01.130, Speaker A: Not only, of course the economic logic, but also just general things like the thing I mentioned before about the way that the assertions work. It protects us against that. So now what we need to do is we need to finish the program. So let's finish the program by saying that the next thing that happens is that Alice is going to we have to figure out what it is that she's going to share. So we're going to say that she will share. It's going to be called info, and she's going to declassify her interact info. So let's go up and add that to that interaction interface.
00:23:01.130 - 00:24:03.594, Speaker A: And we'll make a little thing right here that says info, and we'll say bytes. I just want to pause for a moment. Someone asked a question. They said, so what if the contract what if I want the contract to explicitly keep funds for later use? Can I address the contract itself as a participant? So again, one of the perspectives that Reach has is that you're making a decentralized application, and in between these braces is the entire application. There's nothing more. So what I mean by that is that imagine your program started off like this, where Alice did something and then Bob did something, and then you say you want it for later use. Well, that means that something is going to happen down the road where the contract is going to use those funds for something.
00:24:03.594 - 00:24:37.240, Speaker A: Well, really, whatever happens down the road would really be in this region right here. You would add that to your Reach program explicitly. Now, maybe one of the things that would do is it would call some foreign contract, or there would be a third party, Steve, who would come in, and Steve would do something. So this is a very simple program, though. It's just showing you the basic ideas. But in general, what Reach is going to do is it's going to guarantee that all paths through the program will always guarantee that the balance is zero. So if you want something to happen in the future to get access to that money, that has to be in the Reach program.
00:24:37.240 - 00:25:27.366, Speaker A: Okay, so what we've done is we've added this info up here, which we're going to just mark as some arbitrary bytes. And then Alice is going to declassify those. She's going to publish them, and then we will have her commit. And then after she commits, we'll make it so that Bob will only and he'll call interact Got, and he'll see the info. And then I think that's all that we need to do. So we'll go back and we'll add to Bob that he has another function that's called Got, and this will actually take in the bytes and return nothing. And so the idea here is that, well, Alice asks for the amount of money, bob sends it.
00:25:27.366 - 00:26:10.230, Speaker A: Alice then can know, share what she has, and then she can publish it, and then Bob will actually get it. So let's run the program, and we'll see it compiles. Oh. Whoops. So the balance zero thing is still failing because I actually forgot in here to say that we actually need to transfer the money to Alice. I, like, did that step of the program where Alice comes back and says, here's the information that you asked for, but I forgot to actually make it so that she gets the money back. So what we'll do is we'll say that we're going to transfer the amount to Alice.
00:26:10.230 - 00:26:57.518, Speaker A: Now at this point we run the program, at this point we run the program and it should work. So we compile it, checked twelve theorems and there were no problems. Now something that's really interesting about this is that when I first did this, I forgot to include this line. But what if I made a typo in this line and I'm going to do kind of a contrived example. Or what if I accidentally thought that there was more money available and I tried to transfer the amount plus one. This program can't possibly work because the contract only has amount. So what is Reach going to do? So what Reach is going to do is it's going to prove a different theorem.
00:26:57.518 - 00:27:35.758, Speaker A: One of those twelve that we mentioned before, this is called the balance sufficient theorem. And what the balance sufficient theorem says is that there's never a transfer that is too big. Okay, what if I only transferred some of the money? What if I forgot some of it? And I say that we're just going to transfer the amount minus one. We expect it to error and say that there's that balance zero theorem failing, which is exactly what happens. We get the balance zero theorem theorem failing. So as you can see, Reach is protecting us from a wide variety of errors. And at this point we have a working Reach program.
00:27:35.758 - 00:28:15.374, Speaker A: Well, we have part of a working Reach program because we can compile it. But what did compiling do and how do we actually use it? So that's what I want to talk about next. So because we've just compiled this, let me exit the editor. We have this new directory here called Build. So what's in build? Well, Build has this file right here, index main MJS. So let's see what's in that file. So this right here is a JavaScript backend for our application that was automatically generated for us.
00:28:15.374 - 00:28:48.354, Speaker A: So here it provides a function named Alice, which is all the behavior that Alice does. And we can look inside here. And if you see through the compiler, you can see things that are happening. So for example, there's going to be in here a little call that says, I'm going to check to see that variable two is less than 100. See variable two is less than 100. And then there's going to be an assertion that says that variable seven must be true. And notice that it says that this is at line 19.
00:28:48.354 - 00:29:23.650, Speaker A: So let's look at what was on line 18. Was it line 1816? Yeah. So that's this line right here that checks that amount is less than 100. So each part of this program that we wrote got turned into a piece of that JavaScript program. Also embedded inside of. There were calls to this function that's called send receive. And what sendreceive does is it actually sends out a message on the blockchain, waits for the result, and so on.
00:29:23.650 - 00:30:07.106, Speaker A: So all of the details of actually interacting with Ethereum are totally abstracted from this program. So what I want to do now is show how to actually use this. And the way that we're going to do this is we're going to go and we're going to make another thing that's going to be index MJS. So we're going to write an actual JavaScript program that's going to actually take this back end that we just generated and run it in a testing scenario. So what we'll do is we're going to import something that's going to load the standard library. This right here is an amazing program. It's called anti RSI x.
00:30:07.106 - 00:30:48.366, Speaker A: So it keeps your wonderful wrists from being used too much and from getting hurt. Reminds me to stretch a little bit. All right, now we're back to work. So we're going to import the Standard library from Reach and we're also going to import as, what we're going to call the back end that code that we just generated. It's in build, and it's named index main MJS. We're going to write an Asynchronous function that is going to have all the behavior of our code. And then we're just going to call that function right away.
00:30:48.366 - 00:31:33.470, Speaker A: This is going to make it so it's convenient so we can have the body of our code do all the things that we need. We're going to do is we're going to load the standard library. What this load thing does right here is when we're connecting to Ethereum, it's going to look at our environment variables, figure out what our local node is, make sure that the connection to that node is available, and then provide that to us. It's just kind of abstract all of those details. This works within fura. It works with a local Geth instance that you make all of those things. What we'll then do is I'm going to use a test scenario where I have like a test version of Geth.
00:31:33.470 - 00:32:04.722, Speaker A: If you're not familiar. Geth is the name of the Go implementation of Ethereum. It's a really convenient way to start up a local private Ethereum network where you can draw funds from it and create accounts that just have an arbitrary amount of Ethereum. It's a very convenient development tool. So I can write account. Alice and this will be calling our standard Library new test account. Standard library.
00:32:04.722 - 00:32:41.970, Speaker A: And I'm going to call Parse Currency, and I'm going to have her start off with five units of Ethereum. Parse Currency is a helper function that takes in a normal number and turns that into whatever the currency of the network is. So in this case, it's going to take five, the number five, interpret that as Ethereum and convert it into Way, which is. Like the micro unit of Ethereum. We're going to make another account for Bob standardlib new test account, standardlib parse currency, ten. And we'll start him off with Ten. He's got more because he's got to pay Alice.
00:32:41.970 - 00:33:44.870, Speaker A: Then what we'll do is we will say that there is the contract version of Alice which is going to take the Alice account and deploy our decentralized application. So remember, Backend right here is what came from the code that the Reach compiler automatically generated for us. So when we call deploy on that value, this is going to take that, upload it to Ethereum, make sure that it's set up and then return a handle to it. Alice is going to take the job of doing that because she's the first person that does something. We're going to make another one for Bob. And what Bob is going to do is he is going to attach to the thing that Alice created. Now this value right here, contract at Alice, it doesn't have any secret information, it just has the address that the contract is deployed at and some other metadata to make sure that we have the right instance.
00:33:44.870 - 00:34:18.734, Speaker A: When Bob attaches, he's going to look at that and make sure that it actually has the correct bytecode that he thinks it has. Okay, so we got our accounts that we made in our test scenario. We have our contract versions. Now what we're going to do is we're going to actually call the program. So the way that we're going to call the program is we're going to await on a bunch of promises. When you write a Reach program, you are writing a real JavaScript program. When you're writing the front end, like when you're using the Reach syntax, you're using something that's like JavaScript.
00:34:18.734 - 00:34:53.450, Speaker A: It has very similar ideas to JavaScript, but there's enough differences. But when you're writing this, you're really writing a JavaScript program. And it's very useful to be familiar with modern JavaScript where you have Async await. You're thinking about promises because you're really writing an Asynchronous program, right? Because when we make this test account, we've got to go contact the network, make the account, contact the faucet, send things into it and so on. When we do this deploying, we've got to upload that, make sure that it's available. When we attach, we have to make sure that the bytecode is available. So all these are Asynchronous actions.
00:34:53.450 - 00:35:30.742, Speaker A: And of course, the program itself is an Asynchronous action because we know that behind the scenes it goes off and it sends messages and Bob may come back and be asked something. So we're going to wait on some promises. These promises are generated by the functions that are provided by the Reach code. So we're going to write backend Alice. So remember, Backend is the Reach code that is the result of the compilation. And Alice is the name of the participant. And we're going to pride her with the standard library, her contract.
00:35:30.742 - 00:36:25.066, Speaker A: And then we're going to provide her with her interaction object. This is Alice's Interaction object. And then we're also going to call Bob with the standard library, the contract Bob, and then his interaction. Okay, now, what were their interaction objects? Let's remind ourselves. I think I'll actually open it the other way. That's nicer. So up here, we can see that the interaction object for Alice was that she had a request and the information she wanted to share.
00:36:25.066 - 00:37:11.110, Speaker A: And Bob had the want function and the got function. So let's rate these in here. So she has to provide a request, which is how much she wants. And let's say that she wants five units, the same amount that Bob has more than her. And let's say what is her info? Let's say that she knows the secret. That what's a good secret? Um, we'll say that she knows the secret, that if you wear these, you can see through evil illusions. She just has some arbitrary bytes.
00:37:11.110 - 00:37:48.734, Speaker A: Now, Bob, on the other hand, what he needs to do is he needs to provide a want function. And this want function is going to take in the amount, and it's going to do something. What I'm going to do is I want to make it so that all it does is just going to print out a message. It's going to print out the message console log that Alice is asking me, Bob, for some amount of currency. And so we'll write standardlib format currency. Format currency is kind of like the opposite of parse currency. Parse currency takes in a number and turns it into the underlying unit of the network.
00:37:48.734 - 00:38:20.362, Speaker A: And what format currency does is it takes an underlying unit of the network and turns it into something that users want to see. And so she is asking for this amount. Okay? And then he also has the got function. And this is the secret. And she's going to say console log. And Alice's secret, alice's secret is and then he'll print it out. And because it's raw bytes, that's what this says, raw bytes.
00:38:20.362 - 00:39:11.120, Speaker A: That's not really a string. We have a converter that turns this string into bytes, but there's no automatic conversion in the other direction because there's no guarantee that you're getting something that is utf eight encoded all those things. So we're going to explicitly call a function that's called hex to string, and he's going to look at the secret. Okay, so here we've written the program, and now we want to test it. So how you would test this in a normal scenario, if you're writing a decentralized application, is you now have to load up Ganache or you have to start your ethereum node, and you got to deal all with those things. But what we need to do is it's actually quite simple. We just write reach run.
00:39:11.120 - 00:39:50.458, Speaker A: And what reach run is going to do is it's going to download a docker image for us that's called the Runner. And what the Runner does is it has a version of our standard library pre installed. So it's going to create a node package for our code, start it up. Then what it's going to do is it's going to create behind the scenes. It's going to create behind the scenes. What's the right way to say this? A special instance of the Ethereum DevNet. And then when it creates a special instance of the Ethereum DevNet, it's then going to attach our program to that and run it.
00:39:50.458 - 00:40:21.782, Speaker A: So we don't actually have to worry about any of the details of creating a we don't have to worry about any of the details of actually creating a network and managing it. That's all taken care of behind the scenes. But unfortunately, when we ran this program, it errored. And notice that it errored. And it said that it errored on line 17 of our code. So what was line 17 of our code again? And notice that it says on line 17 of the Reach file. So 17 was this line right here.
00:40:21.782 - 00:41:08.354, Speaker A: So this assumption failed. And remember, this assumption was that the amount had to be less than 100. But remember, on Ethereum, the units of money are always in way, and way is like, I think it's like one to the it's like ten to the 18th or something like that. So we asked for five Ethereum, which is like ridiculously large, so we could change this to be a really big number. But I'm actually just going to comment it out for now because we don't really care. That was just kind of a demonstration of showing how Reach works, how it can double check that you have these requirements. But for the perspective of our program, we don't really need that.
00:41:08.354 - 00:41:25.146, Speaker A: So we'll go back and we'll run Reach Run again. And Reach Run is going to compile for us. So see it first. It compiles. Oh, it's going to yell at us that we forgot a trailing comma. That's too bad. Then it's going to finish running.
00:41:25.146 - 00:41:56.626, Speaker A: It's going to go off and create the docker instance. It's going to start it up, then it's going to run that's Bob. Alice, if you were watching behind the scenes, you looked at my horrible grammar. Alice asks me Bob for five. And Alice secret is, if you wear these, you can see through evil illusions. So notice that what happened in this program when we ran it was that these things got printed. So let me just fix this.
00:41:56.626 - 00:43:01.830, Speaker A: Alice asked me for this. Now, it's a little bit unsatisfying because this program, we don't really see what happens behind the scenes. One thing that might be convenient is to also see what people's balances are like, how things change as we run the program. So what we can do is let's add an additional thing to our JavaScript code where we can see what the participants balances are. So what I'm going to do is I'm going to have a little call down here where I'm going to write down I'm going to call Show Balance and I'll do it for Alice. Alice and I'll do it again for Bob. And we'll do that before and after so we can see how things change.
00:43:01.830 - 00:43:29.540, Speaker A: Now. What is this? Show balance function. Let's just write it ourselves. So Show Balance is going to take in a particular identity. So it's going to take in somebody who. And what we'll do is we'll call console log on standardlib format currency. This is the who and this is the account.
00:43:29.540 - 00:44:25.202, Speaker A: And what do we want to give them? We want to give await standardlib balance of and we'll say the account name and we'll say make a little string here that says whose balance is and we'll print that out it. And then I think this is good. Did I forget anything? Yeah, I forget there's a misplaced parentheses there. Okay, so let's run the program and see how that goes. So we'll run Reach run notice that it doesn't recompile the Reach program, it just updates the docker container. Ah, it says that Alice's balance is 4.9 and then a bunch of decimals and then Bob's balance is ten.
00:44:25.202 - 00:45:07.706, Speaker A: But then afterwards Alice's is nine and Bob's is ten. Now you ethereum hackers know that of course the number here is much smaller is not exactly even because there's the gas costs involved. So this is what it's like to write a Reach program. We get to focus on the high level details of our program. We get to think about who the participants are, what information do they start off knowing what interactions are they going to have with the running application after it's deployed. Then what we do is we write down what each individual step of the program is. And these steps are not the transitions in a state machine.
00:45:07.706 - 00:45:41.180, Speaker A: We don't have to think about the low level details about how the consensus network is going to deal with our contract. Instead, we don't really think about the smart contract. What we do is we think about the decentralized application, which is a distributed computation involving a whole bunch of participants. We write down what they do individually. We write down what information they share. We write down what has to be true about the things that they share. We write down how they take turns doing things and how information gets shared throughout the course of the application.
00:45:41.180 - 00:46:20.118, Speaker A: Behind the scenes, Reach guarantees many properties for us automatically. It guarantees that the balance is always zero at the end of the program. It guarantees that we don't try to overspend. It guarantees that every time we make a requirement, the honest participants actually check those things. So what this does is it guarantees that when we have honest people playing, running our program, there won't accidentally be spurious errors. So this reach program. It is only 42 lines of code with very generous white space.
00:46:20.118 - 00:47:22.060, Speaker A: When we look at the JavaScript code that we also wrote, it's a little bit more dense, but it's also only 34 lines of code. And notice that there's not a single place in it, there's not a single part of it that is actually sensitive to being Ethereum. So notice that right here we said that we're just going to load the standard library. So it turns out that the way that Reach works, we can give configuration arguments to that Reach run function where we can say, well, don't actually start up a local geth node, instead connect to my inferior account, or maybe don't start a geth node and don't actually use Ethereum at all. Instead use another network. Because Reach is actually a blockchain agnostic programming language where one computation can be written, one computation can be compiled to many different platforms. Now, what Reach does for us then is it generates for us a backend program.
00:47:22.060 - 00:48:28.100, Speaker A: And this backend program includes versions of our smart contract for each of the backends that we support. So for instance, we're working on Algorand support. So there's algorithm contracts that get generated inside here you'll also see the Ethereum API that gets generated as well as the Ethereum bytecode. If you want to see the not bytecode version, there's a flag where you can see that. If this is interesting to you, what I suggest that you do is go to our documentation it so our documentation is at docs reach sh. You can see the overview, which is roughly what we've done today. So we've seen this example program where each line has talked about what it does and how we use it and you can see all of the details of that.
00:48:28.100 - 00:49:21.538, Speaker A: And then after you've gone through that, if you'd like, you can go through our tutorial, which takes quite a bit longer to do, and you can see a more involved program. Please join our sponsored discord channel. We're going to have hackathon prizes for people using Reach. And if you would like, we are going to offer a long form version of this where know, help people type in things themselves, go through the tutorial and so on. Now at this time, it's a great time to answer questions. I see that there's been a few questions from YouTube. So the first question someone asks is does Reach restrict the types of smart contracts that can be written versus solidity? Yes.
00:49:21.538 - 00:50:04.106, Speaker A: So Reach right now has quite a few limitations. On our documentation page we have a discussion of those limitations and our plans for dealing with them. Some of those limitations are sweat limitations. Like just as a little tiny example, right now the Reach compiler only supports unsigned integers. It's fairly obvious how we can extend that. But right now we're focusing on the big picture of what Reach can do as opposed to filling in all of those little gaps, there are some bigger ones that we have to think more about, and I suggest talking to us about those checking out our Limitations page. In general, I think of Reach as not being a replacement for Solidity.
00:50:04.106 - 00:50:34.534, Speaker A: Instead, the way that I want to think about it is that we all know that there are many interesting programs out there in the world. Like, I'm using Google Chrome right now. It's amazing. And would it have been possible for us to implement Google Chrome in assembly? Technically, it is possible, right? Because it just gets compiled to assembly. So someone could have written that by hand. But we don't seriously think that anyone is going to really write programs like Google Chrome in assembly. And Reach's Vision, this is Reach, the company that is not Reach, the programming language.
00:50:34.534 - 00:51:24.822, Speaker A: Reach's Vision for the future of Web 3.0 is not a world where there are thousands or tens of thousands of decentralized application programmers. We imagine a world where there are millions of centralized application programmers. We want a world where there are so many applications that we don't need a few brilliant minds like Vitalik to come up with what people will use the blockchain for. We want there to be a huge flood of ideas. And the best way that there can be a huge flood of ideas is there's a really easy language to use where you're not scared of writing a program incorrectly and losing $15 million overnight. That's not the kind of world that's going to a language where it's so dangerous to program is not one that encourages creativity like I think we have observed in other markets, like the smartphone market and whatnot.
00:51:24.822 - 00:52:47.934, Speaker A: So with that in mind, reach is not designed to be able to handle every single program the same way that when you're writing an operating system, you need to drop down to see an assembly sometimes. Or if you are going to write a machine learning algorithm, you might write the architecture in Python, but then behind the scenes, you're going to use TensorFlow, which is, of course, a very advanced C plus plus math kernel library. So our kind of model for Reach is that we want to be able to handle 80% of all smart contracts. And the remaining ones, people might use low level tools like Ethereum or Yule or other tools sorry, not Ethereum, Solidity or Yule or other tools like that. Now, the next question someone asks team what's the Reach team's guidance on production readiness of Reach? And are general thoughts to recommend the use of Reach versatility being an industry standard? I think that I kind of answered that a little bit about the way that we see the future of Web 3.0. I will say that some of the limitations that we talk about on our documentation for Reach do inhibit it from being wise to launch things in production. In particular, we haven't enabled the feature in the theorem prover to guarantee bounds checking on arithmetic operations.
00:52:47.934 - 00:53:54.138, Speaker A: Again, this is kind of a sweat thing, not a thought thing. We want to work out the broad details before doing that. We use, by the way, the Z three theorem prover, which is also something that Silly can use, and it's kind of an industrial standard for automated reasoning about programs. Now, someone else asks, so can we use the generated JavaScript code in a browser context as well injecting accounts with MetaMask or alike? We don't have a tutorial that walks through how to do that, but we use Ethers as our Ethereum transport library, which can attach to MetaMask. Right now, we're really focusing on designing the language, getting the developer experience for testing smooth, and we haven't invested very much in deploying browser applications, but that's on the roadmap. If you have other questions, like I said, you can go to our community Discord Discord Reach Sh, which is linked all over the documentation. So you can click on the Discord community.
00:53:54.138 - 00:54:23.700, Speaker A: And you can also go to our sponsored discord channel hash sponsored on the Ethereum hackers server. Awesome. Thank you so much, Jay. Thanks so much for having me. It's a real pleasure to talk with all the other Ethereum hackers in the world, and I hope to see you all on our channels and interact with you more. Thanks so much. Right on.
00:54:23.700 - 00:54:38.020, Speaker A: Thanks so much. Reminder, everyone, to stake if you haven't yet, and participate on ETH Online. Cheers. Yeah. Great presentation. Thanks, Rob. Bye, everyone.
00:54:38.020 - 00:54:42.280, Speaker A: That was a good presentation. Thank you.
