00:00:13.120 - 00:00:27.428, Speaker A: Hey, everyone. We'll get started in just a SEC. Awesome. Okay, got everyone in. Sweet. Hey, everyone, welcome. Super excited to have you here today.
00:00:27.428 - 00:00:59.010, Speaker A: So we have our Superfluid Workshop with Sam. He is going to be talking to us about building DeFi applications on Superfluid. So we'll have Sam do his thing, and then at the end, or I guess as he's talking, feel free to put any questions in the chat. And then we'll have a little Q A session at the end where Sam can go over your questions. But, yeah, Sam, feel free to take it away, and I'll go off video.
00:00:59.700 - 00:01:26.750, Speaker B: Thank you so much. Well, guys, thank you for joining us. These are always fun to do. Today we're going to walk through Superfluid from a high level a little bit, right? How Superfluid works, what it is, for those of you that don't know. And then we'll go through a specific application that I built not too long ago. That's a cool example of plugging money streams that are tied to salaries into the rest of DeFi. So I'll share my screen, and we will get into it.
00:01:26.750 - 00:01:57.604, Speaker B: All right, so I'm assuming we can see my screen here. I will present in just a second. Feel free to put in the chat if you can't see my screen if you have any issues, and I'll try to review it and make sure we're all good technically. But let's talk through building DeFi applications on Superfluid. Right? And as you might recall, I just said we're going to walk through what Superfluid is from a high level first, so I'll go through it. Superfluid is a protocol which enables something we call real time finance. Let me check the chat here real quick.
00:01:57.604 - 00:02:23.880, Speaker B: All right. Krie can see it. We're good. And what real time finance does is it enables things like digital native programmable cash flows, right? So when you hear about Superfluid, you'll often hear about us and money streaming together. And the main thing that Superfluid lets you do is stream money with no capital lockups, where everything is 100% programmable and on chain. So asset streaming, let's think about this idea of asset streaming a little bit more. So these are continuous payments.
00:02:23.880 - 00:03:09.132, Speaker B: Any recurring payment you might want to make instead of sending it all in discrete lump sums, once a month or once every period you want to send the money, you can divide the amount you're going to send into tiny little increments, essentially. And money is sent every single second in real time without having to hit transfer every time on an ERC 20 contract to send over and over and over again. So I'll get into how that's working in a second. But we think this is cool because it doesn't separate. It actually brings back together this link between value transfer and payment, right? So if I'm providing a service to you, a lot of times what's happening is I'm providing the service and I'm getting paid later. If I'm working for you, you're paying me once every two weeks. I'm providing a service to you right now, but I'm being paid later with things like money.
00:03:09.132 - 00:04:06.492, Speaker B: Streaming enable is this link between the service I'm providing right now and the payment I'm getting. So maybe every time I clock into work, I'm just getting paid in a stream for every single hour that I'm on the clock, right? So real time transfer of value as the service is being provided. Another cool thing about this is that this embeds native payment terms into digital services as well, right? So if I'm providing the service, maybe I'm giving you access to an API or I'm letting you watch a video or stream a piece of content. It allows me to encode the payment terms on chain and lets you engage in an agreement that you can then just always query the blockchain and see that the agreement is still in place. Right? So this removes delays because of the way the value is transferred. It removes unpayment risk because there's proof that this is happening on Chain and the money is being sent in real time for every second that I provide value. And there are no intermediaries because it's all on Chain and we all like decentralization here.
00:04:06.492 - 00:04:52.620, Speaker B: So that's asset streaming. And one of the key innovations here that's enabling this is this idea of a super token, right? So, again, I mentioned earlier, you don't have to call transfer over and over and over again on an ERC 20 contract because we built an extension under the ERC 20 contract that we call a super token contract. So it's compatible with ERC 20 and ERC seven. Seven. So all these things you're used to, right, like approve transfer from balance of these things are all still there. But there's something on this contract that's unique and it's this function called real time balance of right? So this real time balance is tied into the rest of the protocol and it allows us to calculate what your balance is, taking into consideration all of the money streams that are coming in and out of your account. And I'll get into that in a second.
00:04:52.620 - 00:05:21.192, Speaker B: But there are two types of super tokens. One of them are native super tokens, which are just deployed directly as super tokens. They're not wrappers or anything else, they're just through and through super tokens. So they have this functionality directly. And we also have wrapper tokens. So interoperability, we all know is important. What you can do with an ERC 20 token is wrap it as a super token and stream things like Dai, things like we, things that you're used to streaming as ERC 20s, not used to streaming, used to transferring as ERC twenty S.
00:05:21.192 - 00:06:12.560, Speaker B: You can then use them in superfluid. So the thing that ties these super tokens into the rest of the protocol are these things called agreements. So an agreement is this financial relationship between two parties where if I want to send a money stream, I'm going to use an agreement called the constant flow agreement that lets me create a flow by passing in something like the Token address I want to use the receiver and number of Tokens I'm going to send per second. So this gives me an on chain linkage between two accounts. You can have one to many streams, so it's not like a state channel where you're tied to two individual accounts only. You can have many streams open at the same time. And this allows us to build in this real time balance function into the super token contract, right? So there's a linkage between the super token balance of and what's happening in these agreements.
00:06:12.560 - 00:08:08.670, Speaker B: So we can always have your agreement data to get how much money you're either sending or receiving at any given point in time, right? And that brings us to this concept of the real time balance, right? So if we can figure out using the protocol how many tokens you're sending per second and receiving per second, we can get this idea of a net flow, right? So are you on net receiving more money or sending more money so your net flow can be positive or negative? And if we know what that net flow value is, we always also have the block timestamp value. So we can use the block timestamp plus this net flow to calculate how many tokens you've sent over a given period of time. And we can only call that function when we need to, right. If you're going to perform another state changing operation, we can just always call real time balance of first in that operation to make sure that you're only sending tokens that you actually have, right? So that's the idea of real time balance, it might take a second to get your head around that, but it is quite important concept when dealing with superfluid because it enables this whole thing, right? It's not, like I said, calling transfer over and over again in the ERC 20 contract. So another cool thing about this is that everything is programmable. There's this concept of a super app that we're going to go through later today in an actual smart contract example, where you can build a contract that can react to specific events that are happening related to superfluid, right? So you can have a contract that can receive funds and then whenever a stream is either created, updated or deleted into that contract, you can have the contract automatically do things and run callbacks with whatever logic you want in those callbacks when one of those events happen. So this can be very useful for building really advanced DeFi applications or applications that just take in cash flows and send cash flows out, maybe split payments and do interesting things like that again within some kind of DeFi application.
00:08:08.670 - 00:08:48.420, Speaker B: So if you have things like all these money streams flying around. You have these super apps that are cash flow aware. They're receiving money and then doing things whenever they receive money. We have this really cool network of automated cash flows that can start getting really cool when you take into consideration that there are lots and lots of applications being built on top of Superfluid right now. So you might have somebody receiving a salary stream and then redirecting it into a dollar cost average investment into something like Rap Bitcoin. You might have people sending funds into an LP pool and all this money starts just flowing around, maybe being paid for subscriptions. And we're really excited about this idea of network cash flows.
00:08:48.420 - 00:09:30.630, Speaker B: So this is the kind of thing that you can help contribute to. So shifting gears a little bit, that's an overview of what Superfluid is, how it works. If you have any questions, please feel free to reach out to me or just put a question in the chat and I'll see if I can get to it before this workshop ends. But in terms of this particular event, I did just want to call out the fact we have $16,000 available in prizes. We have a long list here. I won't go through them, but they range anywhere from $1,000 you can win if you qualify, meaning if you use Superfluid in some way and build on top of us. So we encourage you to build on Superfluid, obviously, and I'm excited to see what you all build.
00:09:30.630 - 00:10:01.410, Speaker B: So let's think through the basics here of actually building on top of Superfluid, right? So there's a couple of things you might want to either bookmark in your browser or be prepared to go check out. One of them is the Superfluid Developer Console. We'll use this today. It's a really useful tool for writing subgraph queries that relate to Superfluid and just maintaining and managing all of your streams. The other is the Superfluid dashboard. This is like a no code way to manage streams. If you want to create streams to new people, it's a useful open source tool.
00:10:01.410 - 00:10:30.200, Speaker B: And you'll also probably want to use the Superfluid SDK core, right? So we use this to write some scripts in a second. But yeah, this is very useful. If you're just a front end developer and you want to just integrate Superfluid on the front end. Highly recommend using the SDK core. And when it comes to interacting with Superfluid, we went through some of these concepts earlier. I'm not going to go too deeply into these right now because we'll actually interactively go through them. But again, you need to remember you have to use super tokens when you're working with the protocol.
00:10:30.200 - 00:11:01.696, Speaker B: And if you're using super tokens that are wrapper tokens, you'll need to remember that you'll have to wrap them. And the function to wrap is called upgrade. So if you have die and you want to upgrade it to die x, which is how we denote super token die. You just have to call upgrade. What happens is you're just minted a corresponding amount of super token die. And if you want to unwrap, you just call downgrade and the super token die is burned and you receive back the underlying asset interacting with agreements. So this is how you actually would open up a flow.
00:11:01.696 - 00:12:05.668, Speaker B: This is what's happening behind the scenes. In your case, all you're going to have to do, because we've built some helper libraries, is just call create flow and pass in the token. You want to use the receiver and the flow rate, which is the number of tokens you want to send per second. And behind the scenes, what's happening is you're making a call to the host contract, which is like the brain of the superfluid protocol. And that host contract is then calling a function on the constant flow agreement contract, which is the agreement contract that's going to mediate all the streams and then that's going to open up a flow between you as the sender and the receiver, right? So fairly straightforward there. And if you want to actually see how this works, we're actually going to build something interesting, I think, on superfluid in this short little remainder of time we have. So the example I want to go through is this idea of what happens when salaries go on chain and salaries are plugged into the rest of DeFi.
00:12:05.668 - 00:12:53.530, Speaker B: So we enable this idea of network cash flows and when salaries go on chain, you can do interesting things like maybe borrowing against this future cash flow, right? If you're receiving a salary and it's on chain, you have proof that you're receiving the salary. Why not be able to plug that into the rest of DeFi? Right? So we're going to go through an example I call the Employment based Loan, right? And this is just a smart contract framework for allowing Dow contributors or employees being paid in a stream. So people on our team are being paid in a stream. It's an option we have as a perk. It superfluid. We're going to allow people like that to borrow money against the stream, right? And we'll also go through, like in our particular example, the borrower is going to put up some collateral just to make it extra secure for the lender. But you can remove that if you want to, if you want to fork this example.
00:12:53.530 - 00:13:59.276, Speaker B: So why is this example interesting? Well, I believe, and I think lots of lenders would also be partial to this belief that you'll probably be able to get lower interest rates if you're willing to tie your loan directly to your salary, right? If you can have a salary that is effectively just you have proof that it's coming into your wallet and you can borrow money against it, using it as a kind of collateral mechanism, you can effectively just siphon off a small bit of that salary every month and have that just pay off the loan in real time and ideally be able to get access to better credit. If you're just starting your career and have proof that you're receiving a salary, Right. So then from there, the salary itself, you can turn it into maybe some kind of NFT contract that's plugged into the rest of DeFi. I'm very bullish on this sector. And there are a couple of companies even within the superfluid ecosystem that are attacking this problem as well. So recall this chart here of what a super app is. We showed the programmability slide earlier where you're receiving streams and sending streams out.
00:13:59.276 - 00:15:08.130, Speaker B: The employment based loan contract we're going to use is going to be a super app, right? So it's going to receive streams and then based on things that happen with those streams, it's going to create streams out to both the employee who should be receiving a salary and the lender who just invested money and needs to be receiving interest payments for that loan. So what we'll do is we'll build a factory contract which the borrower, aka the employee, will call to deploy a loan contract that has the terms of the loan they'd like to take out encoded into it. From there, the borrower is going to send a bit of collateral into the loan contract. Then they're going to have their employer send their salary into the loan contract. And at first, the loan contract is just going to send 100% of the salary coming into the contract straight to the borrower employee. So nothing really changes for the borrower, it's just a different address that their salary is coming from. And you'll see here we have the lender in the bottom right corner not doing anything yet, but the lender will do something in just a second.
00:15:08.130 - 00:16:07.780, Speaker B: But what the lender is going to do is once all of this is set up, once there's collateral into the loan contract and the employer is sending funds into the contract, the lender can then call a function on the contract to lend money, which will then transfer the borrower amount. So how much money the employee or the borrower wants to borrow directly to them. And in exchange, what it will do is start splitting. It will split the stream coming into the contract from the employer such that a small portion of the salary stream is actually just sent directly to the lender, right? So they're being paid off for the loan in real time and the employee just receives a little bit less in their salary. So their salary stream will decrease a little bit. And then what happens in the positive case is if the employee finishes paying the loan, they can call a function on the contract to say, hey, let's close this loan. The contract will look and see, all right, was enough money paid off to the lender if so fantastic.
00:16:07.780 - 00:17:14.452, Speaker B: Let's close out the loan and 100% of the salary will be sent back to the employee. All is good. We have lots of smiley faces on this screen, but in the bad case, let's say the employee is fired or the employer just decides to be fraudulent and maybe the employee and employer decide to collude to try to skirt around the system and not get the lender their money. The benefit of having some kind of collateral mechanism here is that the contract can just start streaming out the collateral to the lender directly, right? So what we do is we get an updated price in stablecoin terms, so just in USD terms of what the collateral value is and we start streaming out an equivalent amount of the collateral token to the lender to make sure that they're getting something to pay off their loan in the event that something happens. That's unexpected. So extra security here for the lender, but I'll stop here, right? I might take a brief look at the chat and then we'll go into the code example itself. So it looks like we have one question here in the chat from earlier in the call.
00:17:14.452 - 00:18:07.084, Speaker B: What happens when a wallet that has a streaming agreement has no funds? Is it up to the super app to decide? I think what you're asking here is what happens if a wallet is streaming money and then that wallet either runs out of funds or just doesn't have any funds at all. Well, if the wallet doesn't have any funds at all, the flow will not even be able to be started, right? So there's a check that the contract will run to make sure that there's some kind of balance in the first place. If there's not, it will revert. But in the case that it does have funds and it just runs out of tokens, the stream will be closed as soon as the balance hits zero. Right? So when you create a stream, you have to put up a small buffer amount that's only 4 hours worth of the stream. But that is effectively used as an incentive mechanism for what we call sentinels, which are participants in the superfluid protocol who close out streams and are rewarded for doing so. Right.
00:18:07.084 - 00:19:13.856, Speaker B: So the four hour effectively lockup is temporary and it's usually very small, but it still serves as an incentive mechanism. From Ben M. I'm a bit confused on how you update the balance of value without doing on chain transactions. Can you help me understand that? I think you use agreements instead of transactions. So Canal, you're essentially right. The agreements have data in them on how many tokens a given account is either sending or receiving every second, right? So if we have that, if that's written, not written, if a transaction is written that has that update the value of how many tokens a person is either sending or receiving every month, right? Let's say I create a new flow or I start receiving a new flow, we can see, okay, this person's flow rate, this person's net flow rate, it's a positive 100 tokens per month. If nothing changes throughout the course of that month, and that person that's receiving 100 tokens decides to transfer 50 tokens at the end of the month, what we do in that transfer call is check.
00:19:13.856 - 00:19:44.568, Speaker B: Okay, what's the real time balance of this user? We can see that. Okay, this many seconds have passed by getting the block timestamp value of right now as compared to when that last date change happened. We can see that a month's worth of seconds has passed and that the flow rate didn't change that whole period of time. So they did receive 100 tokens over the course of that month. So if you have any other questions about that, please feel free to just either reach out to me directly or keep putting them in the chat. But for right now, I'm going to go through the code example. Okay, you got it.
00:19:44.568 - 00:20:09.344, Speaker B: Thanks. Wonderful. All right, so if you want to fork this example, by the way, you can go to the superfluid GitHub. Let me pull this up here. Hang on just 1 second. You can go to our GitHub and go to examples. And this is the employment based loan example.
00:20:09.344 - 00:20:29.732, Speaker B: This is where we're going to work through. If you want to fork it more than welcome to. We like you guys to make this better. I'm sure some of you gas optimizers are better than me at gas optimization and things like that or doing interesting things. So please feel free to fork it. Let me resume share. I might have to just stop share and restart sharing.
00:20:29.732 - 00:20:50.864, Speaker B: Give me 1 second. All right, here we go. So here we are. We're inside of the example. We have this employment loan contract, which is effectively the contract we're going to be interacting with. We also have a factory. So what I'm going to do is I'm going to deploy the factory and we'll deploy a loan contract which has certain parameters on it.
00:20:50.864 - 00:21:12.728, Speaker B: Okay? So let me go to my terminal here. I have a couple of scripts written. So one of them is just going to be deploy the factory. We're going to run this script. This will get us some addresses we need to work with. Deploy factory. All right, so this will run here for us.
00:21:12.728 - 00:21:53.716, Speaker B: I have some local variables here which represent private keys and things. So we'll just wait for this to run for us. We're running our deploy factory script. We've got our loan contract and then we also need basically just a mock chain link price feed contract as well, which we're going to get there. And we need that because we need to pass that into the constructor as a variable which creates a new price feed contract which will run. It will be called if we ever need to start streaming out collateral, right? So again, it's just a mock. We just preset the value that we're going to get back from it.
00:21:53.716 - 00:22:26.268, Speaker B: But in real life, we would just deploy it. We would get the real address from the chain link price feed. So let me grab this address. We're going to deploy the loan using this script. All right, have these here. So I have in this section the parameters we're going to use. So we're going to just pass in a borrower amount, an interest rate number of months we're going to take to pay it back, the amount of collateral we want to send, the address of the employer, address of the borrower, the tokens we're going to use.
00:22:26.268 - 00:23:29.124, Speaker B: So the token that's going to be serving as the borrow token, which we're going to be borrowing in, it's going to be Dai super token, dai. And then we have a fake token I deployed called a Friends token that's going to serve as our collateral token. And then we also have to pass in the host address, which is the address of the host contract that's again, the brain of the superfluid protocol, the address of that price feed contract. And then because of some of the idiosyncrasies of the chainlink protocol, like price feed contracts, we have to pass in the number of decimals that we expect to be returned on the value of the price coming back from our price feed. Okay? So I'm going to save this and we're going to run the deploy loan script. So what this is going to do is this is going to give us an address that we'll use to deploy the loan. So again, because of I guess I just need to get better at my promise chains here.
00:23:29.124 - 00:24:10.024, Speaker B: But I'm going to run this again with this commented out just so I get the correct address it. So again, I called basically this view function to try to get the address of the contract right after this ran. So there just wasn't enough time for this to actually be deployed. But we have a contract. It's deployed right here. This is going to be our loan contract address that we'll interact with. And so the first thing I need to do here is create a flow from our employer into this contract, right? So if you can recall back here, step one, we just did this, we deployed the loan factory.
00:24:10.024 - 00:25:01.960, Speaker B: Step two, I guess we can send the collateral. But before we send the collateral, I'm actually going to do this step where I send money from the employer into the contract, right? So this is like you as the borrower telling the employer to send funds into the contract. Okay? So I'm going to run this create employer flow function, make sure I have the right address in there. Move this around a bit so I can see. Okay, so what this is going to do at first is it's going to send the salary into the super app, and then the super app is going to send 100% of the value of that salary to the employee, right? So this was successful. Okay. And what I'm also going to do is run an approval script for sending collateral.
00:25:01.960 - 00:25:45.300, Speaker B: And we're going to go look at the stream itself while this waits to run. So I'm going to approve our contract to take our collateral when we call our Send collateral function. So I'm going to call this borrower approval. I'm in this right here loan address. And what we're going to do is go look in the superfluid console, which is quite useful as a tool you can use. So I'm going to search the address of the loan and we can see that we are now in this contract. Here we have some streams.
00:25:45.300 - 00:26:10.190, Speaker B: Make sure I got the right address. Here the loan address. Make sure it's correct. I think I just used a different one. So we have one stream coming in and one stream going out, right? So 100% of the value that's coming in is also being sent out, which is what we want. I'm going to rerun this borrower approval. I think I used the wrong address for that.
00:26:10.190 - 00:26:57.560, Speaker B: All right, so we're going to approve the spend here. So when we call the Send collateral function, what will happen? We're just going to check to see if the message Sender is in fact a borrower. And we're just going to call transfer from on the collateral token, which is going to be this fake friends token that I have. So we're going to then call Send collateral. This example here, you run this again. All that's happening inside this sign collateral is I'm just getting the borrower as our signer. I'm creating a contract object for the employment loan.
00:26:57.560 - 00:27:48.024, Speaker B: And then we're calling the Send collateral function from our borrower. Okay. So that looked like it was successful as well. If I go to our contract address, I can see that we have 100 of our collateral tokens here. These were just sent, which is what we wanted. I'm also going to send it a little bit of super token diet first as well. So if you can recall, I mentioned a little bit earlier that there's a small buffer amount that the sender of a stream needs to have up front, right? And I just want to make sure that our contract has just enough of the token to open up a couple of new streams when the lender calls lend, right? So the lender is going to call lend, and there's going to be another stream that's open to the lender.
00:27:48.024 - 00:28:11.404, Speaker B: I want to make sure that our contract has just enough tokens to be able to support that, right? So ideally, if the salary was streaming into the contract for a bit longer, this might not be as much of an issue. But I do just. Want to seed it with a little bit more funds. Okay, let's make sure that worked. I'll refresh here. All right, getting our balances here. Yes.
00:28:11.404 - 00:29:07.020, Speaker B: We got some super token die now in the contract. So now all I have to do is run an approval from the lender and then call Lend. And the whole process where our lender starts receiving a small bit of the stream will begin. So let me approve from the lender price. So we're going to run the lender approval. And all that's happening here is we're just calling Approve on the fake die token. So I'm using the superfluid SDK here where we're getting the superfluid framework object and then getting the super token using this load super token method, which is pretty helpful, and calling Approve down here by creating this operation and running exec.
00:29:07.020 - 00:29:41.160, Speaker B: All right, I believe that just worked. Then finally we're going to call Lend. Okay. So let me just paste in our address, call Lend JS. If I go into the lend function, I'll show you what happens. What we're going to do is make sure what this check does is just make sure that there's actually money coming into the contract from the employer. We're going to check to make sure that there's collateral, if there's supposed to be collateral inside of the contract.
00:29:41.160 - 00:30:23.860, Speaker B: We then transfer the borrowed token from the caller, which is our lender, to the borrower. So the borrower gets their money and then we update the flow to the borrower such that they're receiving less money, a little bit of their salary is taken out, it'siphoned off. And we're going to create a flow to the message sender here, which is going to be our lender. Right. And we're going to set that. The value of lender on the contract is not the message sender and we're going to get the start time of the loan just so we can always track to make sure that how long has this loan been paid off for and we can see how much the lender has received over time. Okay, so if I go back one more time to our console, I go into streams.
00:30:23.860 - 00:30:48.364, Speaker B: We should see something different here. And we do. Right. So we're still receiving a single flow from the employer and the stream has now been split. Right. So this is now slightly less and we have a stream going to our lender to pay off the loan. So what would happen next is if I decide and this will be the last thing we do.
00:30:48.364 - 00:31:20.856, Speaker B: So thanks to the global team, I know I'm going a couple of minutes over here. What I'll do is I'm just going to delete the flow from the employer. So we're going to assume here that in this case our employee gets fired or the employer just decides to close the stream for some reason. I just want to verify that this works so that we need to make sure that if the flow is deleted. Right. So if there's no cash flow coming in anymore, we need to make sure that the collateral token is being streamed out instead. Right.
00:31:20.856 - 00:31:50.964, Speaker B: We need to make sure everything stays solvent here. All right, so we just cut the stream. All right, hang on. I got to refresh one more time. All right, let's make sure this ran to the right contract might take one more refresh. All right. Yes.
00:31:50.964 - 00:32:08.680, Speaker B: There we go. So the flow rate going into the contract was indeed deleted. You can see this is now zero. There's now zero flows in terms of Dai going out of the contract. And now we're streaming out our collateral token. Right. So if under the circumstances that the stream stops coming in, we now just stream the collateral token out.
00:32:08.680 - 00:32:37.172, Speaker B: So that's the workflow there. Again, it's a bit of a primitive for borrowing against your salary. And, yeah, that's the full walkthrough. You guys can be superfluid masters now. So what I'll do is I'll go into the chat, we'll answer some questions, and we'll see if you guys have anything confusing here. Okay, so let me stop sharing, and I'll answer some questions in our chat. All right.
00:32:37.172 - 00:33:06.764, Speaker B: Looks like I had an issue with GitHub earlier. Thanks, Soleil, aka Yao, for letting me know. And thank you for omnipiant for putting the link in there. That was very nice. Is zapping possible with these wrap tokens? I e. If the employer pays in USDC and the lender wants die, can we do Usdcx to die in the ICA contract? Natively and gaslessly. So you're talking about just swapping from one super token to another.
00:33:06.764 - 00:33:30.452, Speaker B: You can't do that because somebody needs to be on the other side. It's just like any other token swap. Right. And what's happening with the wrap tokens is we're making sure that the value of tokens that have been wrapped is equal to the number of tokens that's in circulation. So if we started zapping across tokens, it would mess with that accounting. So we unfortunately can't do that. Okay.
00:33:30.452 - 00:34:09.868, Speaker B: I think one of the ideas on the idealist for the hackathon is to stream AMM in which you could exchange a stream for another, which would maybe correspond to what you were asking you're talking about specifically probably with the zapping right. Of the tokens. So part of the reason why that's on the idea list is because we want to see someone build that. Right. We think that someone can use these super app contracts to facilitate the automation here. And honestly, there are some protocols that have already done it and got pretty close. So there's a protocol out there called Ricochet Exchange that is a dollar cost average investing protocol.
00:34:09.868 - 00:34:58.604, Speaker B: And what Ricochet does, it allows you to stream, I don't know, USDC or some token into their protocol, and they'll send you back wrap bitcoin or maker or another stablecoin or ether in return. Right. So we know that this method of streaming is possible. We just want to see additional ideas and innovation on it. Right. So if you want to build a stablecoin exchange, like a curve sort of thing using streams, that's the kind of thing we'd like to see people experiment with at this hackathon. Given that this whole event is all about DeFi, right? Is this an ERC? So we don't have if you're referring to do we have like an EIP out for a new actually, we don't right now, but we've thought about making one just to make it official.
00:34:58.604 - 00:35:24.180, Speaker B: And instead of calling it a super token, call it an ERC, something token. We've opted not to do that. I'm not really 100% sure why, but we've just called them super tokens. And part of the way we explain it is just saying it's an extension on the ERC 20 standard. What's the quickest way to get up to speed with the protocol? Looks great. Ben M. Thank you for the comment.
00:35:24.180 - 00:35:49.650, Speaker B: We're glad you think it looks great. We think it looks great too. I'd suggest going to our Docs. Right? So Docs superfluid finance would be the place to start. Thank you. Yeah, beat me to it. And I would suggest, depending on your level of skill and what you're used to, if you're a front end developer, we have lots of sandbox examples using code sandbox you can just take and use on the front end.
00:35:49.650 - 00:36:17.770, Speaker B: But I would recommend looking at the solidity examples first. And I can even if you want, I can send you some additional content as well. So, Ben M, if you want to hit me up in Discord, my Discord name is right here. And this goes for anybody else as well. Send me a friend request or just message me and I'm happy to go as deep as you want. I have lots of resources I can send you above and beyond the Docs if you'd like it. It just might take some context on what you're trying to build first.
00:36:17.770 - 00:37:08.644, Speaker B: How does Superfluid generate revenue? Does this cost to use so we don't generate any revenue? Actually, our philosophy here is that we just want to build infrastructure, right? And we believe, and people that have invested in Superfluid believe, that if we build really high quality infrastructure for real time finance, then it's going to work out for us in the end. Financially, I wish I could give more of a complete answer than that, but that's the best answer I can give you. Our product is really the products that are built on top of Superfluid, right? So if you want to build something in this event, I'm more than happy to help you because this is our game, right? We love ETH Global. We love sponsoring these events because they always bring good hackers here. And yeah, if you want to build something cool, I'm happy to help. Yeah, Creed. We love you, Creed.
00:37:08.644 - 00:37:13.448, Speaker B: Thank you. All right, cool.
00:37:13.534 - 00:37:22.880, Speaker A: Awesome. Thanks so much, Sam. That was super informative. I learned a lot. I'm sure everyone did. Thanks, everyone, for the some questions. Love the engagement.
00:37:22.880 - 00:37:36.930, Speaker A: And, yeah, shout out Sam and the superfluid team. So, yeah, as he said, he's got the docs link there, but also hit them up in the discord if you have any questions. And, yeah, thanks for staying late, everyone. We'll see you soon.
00:37:37.780 - 00:37:38.750, Speaker B: Thank you all. This was.
