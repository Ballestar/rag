00:00:17.770 - 00:00:22.350, Speaker A: Okay, periscope is up. Standby for YouTube.
00:00:27.310 - 00:00:29.980, Speaker B: Okay, YouTube is up. We are go.
00:00:32.430 - 00:01:10.930, Speaker A: Awesome. We're going to give maybe one more minute for people that are just joining and then we'll get started. And like always, please put your local time in the chat. We've got people from everywhere. I think even more countries than we had for our last event have applied to Hackafest, so it's always cool. Let's see, local time for me, 11:00 A.m.. Let's see who gets the latest local time.
00:01:10.930 - 00:01:21.844, Speaker A: That's what I'm seeing.
00:01:22.042 - 00:01:23.220, Speaker B: It's latest.
00:01:24.600 - 00:01:51.412, Speaker A: All right, we are going to get started. Thank you everybody for showing up. Like I said, this is a Hackafest event leading up to the kickoff. Next week kickoff is Monday at twelve noon Eastern. Hopefully we can all see you there before we get started. Just a reminder that if you want to take part in Hackafest, you do need to stake. If there are any issues with that, reach out to any ETH Global team member.
00:01:51.412 - 00:01:59.970, Speaker A: If you don't stake, we will be kind of trimming out the slack just so we have only hackers that are participating over the next few days.
00:02:00.900 - 00:02:01.650, Speaker B: Yeah.
00:02:02.180 - 00:02:41.068, Speaker A: So today we are starting off with the Solidity and Biddler workshop. If you're not familiar, this is the right place to be. You're going to learn a ton from Patricio. He's the CTO and co founder of Nomic Labs and they've been doing a ton of great work specifically with Biddler, and we're really excited to have him here and sharing some of his expertise. So without that, without further ado, I'll let Patricio take it away and he needs to be unmuted.
00:02:41.084 - 00:03:20.590, Speaker B: Okay, that's it. I had a problem with Zoom where I couldn't unmute myself, but hi everyone. Thanks for being here. As Trent said, I'm Patricio from Buenos Aires, Argentina, and this workshop is going to be mostly around how to set up an Ethereum smart contracts developer environment. This is not going to be like solidity class. We are not going to go through the different aspects of the language. That will be pretty boring for me.
00:03:20.590 - 00:04:43.668, Speaker B: Just here for an hour talking about solidity syntax. So instead of that, we are going to follow a tutorial that is going to leave you with a ready to work environment so you can continue your learning by actually writing some smart contracts, test them and play a bit with the language. For this tutorial, we are going to assume basic knowledge about Ethereum so where a transaction is and very basic knowledge about how the network works, like miners and waiting for transactions to be mined. What's the blockchain? But if you are not super confident with those concepts, I think this workshop is still worth it. It won't go very deep into the technicalities of Ethereum, so I guess you can still enjoy most of it. So everything that we are going to do is actually already on the Vidler site. Its site is Vidler, the typo is intentional devtutorial.
00:04:43.668 - 00:05:28.660, Speaker B: So if you get lost or if you want to go over this again after this workshop, you just come here and everything is written down. I'm going to be using this as a cheat sheet myself probably. So we are going to be following this tutorial very closely. So first I hope that you received a notification or message asking you to set up your environment. So in Bidler is based on node JS. It's a node JS command line application. It's common in Ethereum to test your contracts using JavaScript.
00:05:28.660 - 00:06:30.156, Speaker B: The reason is that both Ethereum and Solidity are very domain specific things like you can do lots of things with them, but some of them you can't. So testing your contracts or interacting with them directly with Solidity can be pretty cumbersome and some things are impossible like I don't know, accessing the file system. So that's the reason that we normally develop smart contracts in Solidity but test them using other languages and in this case it's JavaScript. So we use node JS. But we do require some specific setup for Node JS because some of the dependencies use C or C and you will need a C compiler setup and it takes time. So I hope you did follow this part of the tutorial. But if you don't, you can do it now.
00:06:30.156 - 00:07:12.680, Speaker B: But as it takes time, we just going to advance as if you were already as if your environment was already set up. Sorry, I forgot to share my screen. I just noticed that this is the tutorial I was talking about. So there is first general overview, just like an introduction. But this section is this one setting up your environment. It's going to tell you how to install Node and it has a few extra steps. It's not just like a plain installation of node.
00:07:12.680 - 00:07:51.488, Speaker B: If you use Linux you are probably good to go. But if you are using Windows, you should check that. But apart from that, once you install everything, this is just a Node JS project. It's like a common JavaScript project. So what we are going to do is set up the Builder project and the first thing that you need to do that is just setting up an NPM project. So you can install builder. We are going to start with an empty folder.
00:07:51.488 - 00:08:20.168, Speaker B: You can name it whatever you want. I just name it Hackface. And in that folder you need to initialize an NPM project. That's very straightforward. You just have to run NPM in it. I'm going to be writing everything myself and doing everything myself. So if you want you can follow whatever I do and you are going to experience this firsthand.
00:08:20.168 - 00:09:01.784, Speaker B: So to initialize the project, you just run NPM in it and then it's going to ask you a bunch of questions. We are going to press Enter until it's ready. And after that we are going to install Biddler. So you just do it with Npmr. And this is going to take some time because it has lots of dependencies. But in the meantime, let me tell you more about what Vidler is. So Vidler is an ethereum development environment.
00:09:01.784 - 00:09:52.620, Speaker B: It comes with a bunch of things. The main of it or one of the main things is task runner. So Builder automates all your smart contract development needs like compiling, testing and a bunch of extra ones like deploying your smart context to the theorem network. But apart from that, Biddler comes with what we call Bidler EVM. It's a development Ethereum network. It's just like the Ethereum network, just like mainnet, but focus on development. And what does this mean? This development network is not like an actual blockchain where money and valuable things are handled.
00:09:52.620 - 00:10:34.468, Speaker B: Here, we just initialized like a virtual blockchain where you can run your test and then that gets discarded. So every time you run Bibbler, a new blockchain, like almost an empty one, is going to be initialized for you. You are going to be able to run your test with a bunch of fake Ethereum like biddler's EVM money. You are going to use that to pay for gas and things like that. So you don't have to worry about getting it to test your context. But apart from that, it's also super fast. Testing things on Mainet would be quite slow because you have to wait for transactions to be mined.
00:10:34.468 - 00:11:39.212, Speaker B: Here, things are automatically mined, like instantly mined. So that makes everything much faster. But also, Builder ABM is developed specifically to create and debug smart contracts. So it has extra functionality to help you debug your smart contracts and understand what's going on when you are executing or deploying a contract. Vidley VM doesn't just execute your smart contracts, but understands part of Solidity so it can give you more contextual data whenever things go wrong. So now that we have already installed video well, does all of you actually install it? Like, does anyone need more time? Let me check the chat. Okay, I guess we can continue now.
00:11:39.212 - 00:11:44.610, Speaker B: Otherwise, if someone needs more time, feel free to ask for it.
00:11:47.060 - 00:11:55.430, Speaker A: Is everybody good? Just give a thumbs up or a confirmation in the chat. All right, we got a couple of people.
00:11:56.120 - 00:12:31.900, Speaker B: Yeah, cool. Okay, so let's keep going. By the way, these things that I'm currently explaining are in part three of the tutorial. So if you get lost or maybe you have just joined, you can come here, follow these things, and you are going to get to the same point. So now let's run Biddler for the first time. To do it, you have to run NPX Biddler. NPX is nothing Biddler related.
00:12:31.900 - 00:13:19.710, Speaker B: It's just node JS utility that it's similar to Sudo. But instead of telling the system, run this as a super user or root, it means run my local version of Biddler, the one that we just installed. Because if we were just doing Biddler like this. It would be a global installation, but that's not what we want. So if we run NPX Biddler, you are going to see this welcome screen. It's going to have a bunch of options but we are going to use the second one, creating an empty builder config because we are going to show how to set up the entire thing. We don't want to use the sample project here.
00:13:19.710 - 00:14:02.990, Speaker B: So that's it. We have an empty builder config now and it's actually empty. It's just like a JavaScript file. It exports an object but it's empty. Bid layer works without any specific configuration but it does have a plugin based architecture. So if you just install bidlair you are going to get a few things. But those things are just like the very basic functionality that plugins use to offer more advanced or more useful things.
00:14:02.990 - 00:14:40.148, Speaker B: Video by default has this task runner and bitlebm. But if we weren't to use anything else, using Ethereum would be pretty cumbersome. So we are going to use a library to connect to Ethereum that is called Etherjs. It's very popular and it's what we recommend to use Ethereum. To use JavaScript and ethereum. And apart from that, we are also going to be using Waffle. There is a testing library that is very handy to test your smart context.
00:14:40.148 - 00:15:50.380, Speaker B: So we need to install those plugins and again we can come to the tutorial and by following it you are going to arrive to the same part where you have to install your plugins. So we are just going to copy and paste this install NPM, install from here and run it. This is also going to take some time. It's going to install the plugins and the libraries that they use. So let's wait for it. So Waffle is we are going to be using Waffle mostly to add extra functionality that is useful for testing and Ethers, it's like the thing that we are going to use to interact with Ethereum. Okay, this is going to take maybe a minute.
00:15:50.380 - 00:16:05.750, Speaker B: I'm going to wait for it to finish before continue, I guess. Does anyone have any question right now?
00:16:17.400 - 00:16:26.680, Speaker A: Have you talked a little bit about the background of Biddler and how you guys came on the idea or what it's typically used for while we're waiting?
00:16:27.980 - 00:17:37.420, Speaker B: Yeah, sure. So Biddler currently is being used pretty much. It's getting a lot of traction around the DeFi ecosystem. Many DeFi projects use bidlair to test to build their smart contracts specifically or mostly for testing them. Like the most, like I know the most useful features of Fiddler are around debugging smart contracts because the issue is that as you run your tests in Ethereum while you write them with JavaScript, you are like executing two different VMs at the same time. And it can be very hard to understand what's going on in Ethereum. Like on JavaScript you have lots of functionality of things and infrastructure built around it to aid programmers during their development.
00:17:37.420 - 00:18:24.450, Speaker B: But Ethereum is a much newer platform and it's a special platform in this way that things get to run on the blockchain. There's the EVM, it's pretty new. It's quite different compared to other VMs. And there's not lots of development tools. I mean there's a bunch of them like Builder, but everything is new in this environment. Like Ethereum didn't exist five years ago. So what we mostly work on on Builder is closing that gap between the JavaScript development experience and the theorem one.
00:18:24.450 - 00:19:13.440, Speaker B: Like adding functionality to Ethereum that people are used to use on JavaScript like console log or solidity stack prices. Like before Bit there you weren't able to print messages from your smart context and with Bidler you just import the library and use console log just like in JavaScript. We are going to see this in a few minutes. So does anyone need more time to install the plugins? This is probably the last thing that we need to install. So this is going to be the last big post. Then we can actually start. I think there's someone something in the chat.
00:19:13.440 - 00:20:11.090, Speaker B: Okay, someone is asking what's the advantage of using Builder over web based Ides such as Remix. I think the main advantage is that you can use the tools that you normally use for other languages. Like if you're used to use Visa Studio code, you can use it. But if you are a Vim fan or BIM, maybe you can also use that. It's like a normal environment, whereas a web based one, it's like kind of preheat and limited and you lose access to most of your tools. Okay, so let's continue. Now we are going to create our first contact.
00:20:11.090 - 00:20:57.676, Speaker B: To do that we need to create a contracts directory. This is where we are going to place our Solidity files. I forgot about this part. So we already installed the plugin, but we have to tell Bitler that it has to use it. And we do this by calling this Use plugin function that it's already available and the name of the plugin. Here we are telling Biddler in its config file that it has to use the plugin. Nomiclabs Biddler waffle.
00:20:57.676 - 00:21:53.496, Speaker B: Apart from that, we are just going to set the version of Solidity that is the one that we are going to be working with. This is not strictly necessary, but we recommend doing that to be sure about which version of Solidity you are using. Okay, so now we have our config ready, that's all we need. And we can create our first Solidity file. So in this tutorial we are going to be creating a simple token. It's not going to be a standard compliant token, but just like a very simple one for educational purposes, we have to create a Solidify to place our token. So let's do that and let's call it token soil.
00:21:53.496 - 00:22:34.240, Speaker B: We can use whichever name we want. But I think keeping the same name for files and contacts is useful. It's easier to find things if you do that. And every Solidity file has to start with this Pragma thing. It's just Pragma space Solidity and like a version identifier of Solidity, like which versions of Solidity can compile this file. Here we are telling the compiler that every 0.6 point something version is fine.
00:22:34.240 - 00:23:09.832, Speaker B: This is also pretty common on Node, on NPM, so I guess most of you can recognize this and then we are ready to create our contact. So to do that we use this contact keyword and it just takes the name of the contract. It's pretty much like a class in JavaScript, C, Java or everywhere. And that's it. This is our first contact. We can compile it, we can deploy it and it won't do anything. So it's pretty boring.
00:23:09.832 - 00:24:19.040, Speaker B: So let's add the name to this contract and that would be just like a public variable that other contracts and applications can access. So we do it by declaring it just like in any language public name. Let's call this my token. That's it. So here what we are doing is declaring a storage variable. So in Solidity or in Ethereum, you have both memory based variables and storage based ones like memory based are normal variables like the ones you use in any programming language. But storage ones get saved in the storage so you can access them through different transactions.
00:24:19.040 - 00:25:07.120, Speaker B: It's similar to the file system in a normal computing environment, these values don't get lost and you can access them whenever you want and modify them. So that's what we are going to be working with. But first let's deploy this Token contract and test that our name is actually My Token. So we can do that by creating a folder called Test. That's a common name of JavaScript to play your test files. And test files are actually just JavaScript files. They don't necessarily have to do anything with Ethereum.
00:25:07.120 - 00:26:41.232, Speaker B: Something weird is going on and Builder will just find these JavaScript files placed on the test folder and run them. It's going to run them with Mocha, which is a super popular test runner for JavaScript. I guess many of you already know about Mocha, but because it's not Ethereum related, it's common to use Mocha for anything JavaScript related. And the way you use it, it's by declaring blocks of functionality of related tests that are going to test like a part of the functionality of your program. So here for example, we are going to test the My Token contract and we do that by telling Mocha with this script function that you are going to declare a bunch of tests that are related to My contract. This is just the title, it doesn't mean anything special. And then inside this callback that you pass to the describe function, you can define your test and you do that by calling it, which is a function to declare test.
00:26:41.232 - 00:27:46.808, Speaker B: And the idea is to do things like it should have the correct name and then pass it a callback that actually verifies that assumption. So here we can test our things, but for now let's just print something. So does anyone have a question? Sorry if this is kind of oriental for now, because this is just plain JavaScript things, but we need to explain a bit of it. And is there any question on the chat? Just one small question. Why do we need Async keyword in front of the function Async? Okay, that's a good question. So in JavaScript there are two kinds of functions. The common ones or I don't know, no namesync.
00:27:46.808 - 00:28:52.440, Speaker B: Ones are just functions, like in any language. But you sometimes have to do things that can be restored immediately, like doing an Http request or connecting to the Ethereum network and sending a transaction. Those things take some time and JavaScript doesn't block and wait for them to complete, it just continues executing. And you do that with Async functions, an Async function instead of returning a value. Like if I do return one Q three here, it's going to return an object called a promise. This promise encapsulates these Asynchronous operations in a simple interface that JavaScript knows how to handle. So if I were to call an Async function and I do want to wait for it to complete, I just do await funk.
00:28:52.440 - 00:29:46.890, Speaker B: So if this function were Async, the await keyword forces JavaScript to wait for its promise to complete. And as Ethereum is like a network that you are going to connect and send requests to. Most of the things are Async. So we are going to be using this await keyword and Async functions a lot. So thanks for asking that. So let's keep going and run this test. So how do you do that? You just run NPX Bidler test and as I mentioned before, it's going to run all your JavaScript test files one by one.
00:29:46.890 - 00:30:31.496, Speaker B: And first it's going to compile your smart contract. It will only compile it the first time you run it and of course whenever you modify it. So this is a new sleepy thing. So the first thing that you have to do is declare your license. We don't have a license right now, so let's just copy and paste that thing from the warning. It's unlicensed, that's what it means. But here after the compilation, the tests are run.
00:30:31.496 - 00:31:39.670, Speaker B: So it's going to first run our describe block, my token contract, so you can see it here and then the different tests that belong to that describe block. Here we only have this one should have the correct name and it displays high. And this is what is going on here, just displays high. So is everyone following? Like. Should I continue? Does anyone need more time or does anyone have a question? Now let me check the chat. So Keshab asked about how is Bidler different from Traffil? Biddler and traffic are very similar. The main difference is that Biddler has a plugin based architecture that lets you combine different tools.
00:31:39.670 - 00:32:22.034, Speaker B: So for example, Fafil doesn't use Ethers, the library that I mentioned before. And you can't use it with Fafil easily. It uses another library that is called Web Three CS. But in Bidlair you just get to choose what to use. You can use Ethers or you can use Web Three or both of them at the same time. You just install the plugin and those libraries get it automatically set up for you and they are ready to be used. And this is pretty nice because that way you can choose whichever environment you feel comfortable with.
00:32:22.034 - 00:33:06.570, Speaker B: And it also encourages people to build their own plugins to customize their own things or even publish plugins for other users to use. Okay, so now let's actually test our token. So to do that, we first have to somehow get the token contact. Here we are going to be using Ethers for that. And Ethers have this concept of contact factory. It's pretty similar to a class. So you do have contact factories and you have instances of the contact.
00:33:06.570 - 00:33:42.430, Speaker B: Like you have a class and you have objects. So the first thing that we are going to do is use Ethers to get the contact factory of Token. So here we pass the class name. The contact name. It's the same as the file as the contact file name and the test file name. I think that's easier. So you don't have to be thinking all the time which name to use.
00:33:42.430 - 00:34:25.398, Speaker B: And as I mentioned, most things are Async. So here we are going to be using this await keyword to wait for that Async operation to finish. And we are going to store this on a token variable. Okay, so now we get this contact function. What we can do is deploy our token and to do that we just have to call deploy function that contact factory have. And this is also an Async operation. You have to send a request to the network.
00:34:25.398 - 00:35:21.790, Speaker B: So we have to await for it. Oops okay, so what this deploy function does is creating a transaction and signing it and sending it to the Ethereum network. In this case, the Ethereum network is Bid LIBM and it's going to be mined instantly. But that's not always the case. So you have to wait for transactions to be mined. And you do this by awaiting for this deployed function. That's going to return the promise which will be resolved already right after the transaction gets mined.
00:35:21.790 - 00:35:58.690, Speaker B: Something weird is going on with Zoom. So after it gets deployed, we can check, for example, its address by doing a console log here. Let's do that. Let's see ethers get contract factory. It's not a function. Let's check in the tutorial. Maybe I have a typo or something like that.
00:35:58.690 - 00:36:27.820, Speaker B: I guess it would be this section. Section Five. So it's ethers. Get contact factory. That's weird. I have the same name. Hmm, let's see.
00:36:27.820 - 00:37:07.318, Speaker B: Nami gloves. Let's check this. Sorry about this. I followed this tutorial, like, minutes before starting it. Oh, no, it didn't. Let's see here. I'm just printing the Ether subset to check if that function.
00:37:07.484 - 00:37:21.070, Speaker A: That means it's a toy. So I do have a question about the wallet. When you get a chance, like, where it's getting that, is it included as part of the internal builder EVM that it stands up? Is that where it's like a magic wallet?
00:37:23.570 - 00:37:25.534, Speaker B: Can you repeat? Yeah.
00:37:25.572 - 00:37:33.358, Speaker A: Where's it getting a wallet from? Right. Where's it getting a wallet in the transaction? Is it just built into the framework that it just magically does it behind the scenes?
00:37:33.534 - 00:37:58.722, Speaker B: Yeah. So Bdbm has a bunch of accounts by default. I think it's like 20 accounts or something like that. Those are unlocked and you are free to use them. It will sign your transactions by default with the first account. And those also have a lot of fees. It's fakey.
00:37:58.722 - 00:38:31.438, Speaker B: It's just like, bitribme. And you use it to pay gas. So in a normal network, like in Mainnet, you should make sure that you have funds to pay for your gas for the transaction. So this token that deploy may be spending, I don't know, 100K gas. And that may cost money. I mean, that does cost money. I don't know how much, but you need to fund your account before deploying a contract.
00:38:31.438 - 00:39:03.520, Speaker B: But here in Be, there as it's designed for testing and development. You don't need to do that. It's already set up for you. So that's why it's nice to have these plugins that let you integrate tools automatically. Because those kind of things are already taken care for. You don't have to be worrying about, okay, I have to set up my environment like this or like that. You just install a bunch of plugins and you're good to go.
00:39:03.520 - 00:39:17.406, Speaker B: Okay, let's check this. Nomi glass waffle. This is super strange. I think you need to require explicitly.
00:39:17.598 - 00:39:24.520, Speaker A: It'S the API of Ethersjs. The tutorial uses ethersjs before.
00:39:27.050 - 00:40:07.102, Speaker B: Really? In your test file, if you scroll up. Yeah. Something that I didn't mention is that here, when I use Ethers from the global environment, that's just for convenience, like Bidler injects a bunch of things to the global environment. But I can import it explicitly. I can do that. Like, this require numiclab speedler Ethers. And that's the same as using it globally.
00:40:07.102 - 00:40:46.622, Speaker B: Like, I get the same instance of Ethers. But yeah, as Franco said, I probably have an issue with my version of Ethers. With respect. I mean, it might have changed a bit from the time we published that tutorial. It's weird because I followed it. Let's try again. Oops okay.
00:40:46.622 - 00:41:18.490, Speaker B: I know what's going on. So Visa Studio code inserted this import directly, automatically, and I haven't noticed that. So yeah, I was importing another version of Ethers that doesn't have this function because it's a helper added by Bibler and it couldn't find it. So my test was crashing. It should work now. Okay, that's it. Sorry about that.
00:41:18.490 - 00:42:19.660, Speaker B: I should have scrolled my file, my file. So let's just use it from the global environment just to keep things as close as the tutorial as possible. So to recap what we've done so far, we created a token that it's a contract that only has a public variable called Name with a constant value. And what we are doing here is getting the contact factory token deploying it, waiting for the transaction to be mined. In this case this is instantly and then console login its address. But what we actually want to do here is to check that the name is correct and the name is a public function. In solidity public means that other contacts can call it, but also that programs outside of the blockchain can access that function.
00:42:19.660 - 00:43:11.486, Speaker B: And in Ethers you do that by just treating like your token here, which is a JavaScript object, as if it were your actual contact. So if there is a public function here, you are going to have it also in JavaScript here. So you call Name and you are going to get the name. It's just a ghetto. The only difference is that this is also an async operation because it has to call the EBM. It has to not send a transaction but do a call like telling the network, okay, give me the value of this getter and we can also print this and it should say my token. Okay, so that's fine.
00:43:11.486 - 00:44:13.618, Speaker B: The contract is doing what we expected, but testing like this, checking all the time, the values manually, it's going to be very error prone. So as in any programming language, we are going to use assertions here to test that the values we get actually match what we expect and do that programmatically. In this case we are going to use Child. There is a super popular library, especially when using Mocha that has a bunch of assertion functions that they assess like handy functions to test things. So we are going to import chai by doing this required chai. Chi has like a bunch of different APIs. We are going to be using one that is called Expect.
00:44:13.618 - 00:44:59.214, Speaker B: And expect works like this. You just call it with a value and it's going to wrap it and it's going to return an object that has lots of functions that let you test what you want. So here we are going to be calling Expect, passing the name that we get from the network and calling to be equal. And here you're going to put my token and let's try this out. Okay, so the test passed, there's nothing to show. Mockai is only going to show things if your test failed. But we.
00:44:59.214 - 00:45:26.486, Speaker B: Are fine. But let's first try how failing tests are displayed. So here I change the expected name. So as I'm getting my token, my token too, it's going to fail. Okay, so this is it. You can see your test in red. That means that it failed.
00:45:26.486 - 00:46:16.410, Speaker B: Here you have a summary of the amount of test that failed and the amount of past test. And here there is a further explanation on how it failed. In this case it says that you were expecting my token to equal my token two. The expected one is in green, my token two, but you got my token and that's it. So let's continue. So now that we know how to write very simple smart contact tests, let's add some functionality to our token. For example, we can add a symbol that it can be empty and it's just another variable.
00:46:16.410 - 00:47:18.850, Speaker B: We are not going to be testing this because it's kind of boring, but I guess you get it. Does anyone have any questions so far? Let me check the chat. Okay, so let's keep going with building this token. So the main thing that the token does is just keeping track of balances, like how much money or tokens does any account or person has. So to do that, we are going to use a mapping. There is a data structure that it's already built in into solidity. A mapping is just like a hash table.
00:47:18.850 - 00:48:14.130, Speaker B: It stores values associated to a key and you declare it like this mapping and the type of the key and the type of the value. And in this case, our value is going to be uint and our keys are going to be addresses because an address is like an identifier of an ethereum account and then its name balances. Okay? So this is not going to be a public variable. It's going to be private. We don't have to define add like a private keyword that's automatic. And this is going to be stored also on storage. So we are not going to be losing the values between transactions.
00:48:14.130 - 00:49:13.846, Speaker B: We want that to be recorded on the blockchain like forever. And to access a public private variable, you need to define some kind of getter. So let's do that. We are going to define a function called balance off, which receives an address, I don't know, owner and returns uint. Here, first you have to define its visibility and then we are going to declare this function as a view function. View here means that it can read the state like the storage, but it can't modify it. And the cool thing about view functions is that you don't need to send a transaction to execute it.
00:49:13.846 - 00:50:03.830, Speaker B: You just can tell your node to run a certain view function and give you the return value. And this is nice because first it's automatic as you don't need to send it instant. I mean, as you don't need to send a transaction you don't have to await for anything to be mined. You can get the return value almost immediately. And also it's free because you don't have to pay gas as there's no transaction. Now we have to declare its return type and you do it like that. So then implementing this is pretty easy.
00:50:03.830 - 00:50:35.970, Speaker B: It's just like returning the balance of the owner and that's it. That's our balance of function. So let's test this. So let's create another test. It should return the right balance. This is also an async function. Tests are normally async, while describes are not async.
00:50:35.970 - 00:51:17.998, Speaker B: Here we have to do the same thing, right? Like we are going to deploy a token. We are then going to call Balance Off and compare the result of calling it. So here, instead of name, we are going to use Balance Off and pass it an address. Let's use the address zero. It has like 40 characters or something like that. Let's do this. There's a constant on ethers that I never remember its name.
00:51:17.998 - 00:52:03.450, Speaker B: So I always do this. How many? That's? 28. Oops, sorry. Zoom is doing something weird. Okay, so here I have the other zero and let's compare its value to zero because that's what we should be getting. Okay, it passed. So by default, mappings are always initialized in zero.
00:52:03.450 - 00:52:47.588, Speaker B: So that's fine because everything should have zero balance until someone sends them money. But before we continue, let's refactor this a bit. Like this. Token deploy Method it's getting a bit repetitive. So there is a way to do this in Mocha so you can declare something similar to it that it's called before each and pass. It a NASIC function. This function is going to be executed before running each test.
00:52:47.588 - 00:53:46.680, Speaker B: So if something gets repetitive, you can do it here's. But what we do need to do is instead of using a local variable here for token, we need to declare it outside that function so other functions can access it. Okay, let's run this again. Okay, cool. So now let's have a function to transfer tokens that's also very straightforward. It should look something like this. Transfer the receiver and the amount of tokens.
00:53:46.680 - 00:54:26.150, Speaker B: It should also be public. In this case, this is not a view function because it's going to modify the state of the contract and it doesn't return anything. So that's it. We don't pass the sender of tokens here because that's going to be the one who sends the transaction. You can access that account by doing message sender. So we don't need that param. But there is a problem.
00:54:26.150 - 00:55:28.010, Speaker B: So the way I would test this thing is by actually doing a transfer and seeing that it was successful. But if we don't have any token, I mean everyone has zero tokens. Who is going to be the one that transferred this value? So what we need to do is to initialize this contract with an initial supply of tokens. There's a bunch of ways of doing things, of doing this thing, but we are going to go for the simplest possibility. So what we are going to do is implement a constructor function that's going to be executed when we deploy our contract. And in that constructor function, we are just going to assign a bunch of tokens to whoever deploys this contract. And we do it this way.
00:55:28.010 - 00:56:22.530, Speaker B: Constructors have always this name. It has to be public, otherwise we won't be able to deploy this contract. And we are just going to initialize the balances mapping and add some value here. I know it's alpha. Does anyone have any questions so far? Let's check the chat. Okay. So before testing transfer let's actually test that the constructor is initializing this correctly.
00:56:22.530 - 00:57:44.206, Speaker B: Otherwise we are going to have a hard time. So should initialize the balance. And here what we need to do is just call balance off and test that it's one K. But the problem is that we need to know who sent the deployment transaction here. Otherwise we won't have access to its address and we need it to check its balance. So what we can do is use Ethers again to get those Bidlar VM accounts that I talked about like a few minutes ago. But as Vidley VM has a bunch of accounts automatically initialized and funded for you and transactions by default are sent with the first of those accounts.
00:57:44.206 - 00:58:35.170, Speaker B: So what we are going to do is get those accounts and store the first one in a variable and use it to complete this test. So let's do it here in the before each because I suspect that we are going to be using this thing a bunch of times. So let's do this. Let's get the account. We can also use an Ethers helper here. Okay, this is going to happen all the time I guess. So here I have the counts but I am only interested in the first one and I want to store it somewhere.
00:58:35.170 - 01:00:14.060, Speaker B: Okay, so now that I have the account that it's deploying the contract, I can use its address. This is also async I guess this test should be completed now. We are checking that the balance of the account that actually deployed the contract is initialized correctly. Let's try it out okay cool. So now that we have that account and that we have an initial supply of tokens, we can actually test the transfer function. Is transfer some tokens? Let's use the same account like zero. I clear a construct, not repeat those zeros.
01:00:14.800 - 01:00:15.550, Speaker A: It.
01:00:18.520 - 01:01:31.310, Speaker B: So okay, let's transfer some tokens from the Sender account that it's the same one that deployed the contract to the zero account. And let's check the balance. First you need to pass the receiver and then the amount zero and one. This is going to send the transaction so it's async and once we await it, we can check the balance of the account zero and also check the balance of the Sender because it should have been decreased by one. So let's do this and the one off sender should be 999. Okay, let's try this out. Oops expected zero to be equal to one.
01:01:31.310 - 01:02:44.210, Speaker B: Yeah, so I never implemented it, so it's fine that it was failing. Okay, what we are going to do is subtract some balance from the sender and add it to the receiver balances amount and then we add it to the receiver and that's it. Now I guess the test should pass. It's going to recompile everything. Okay, now it's passing. So this is like a very basic implementation but it does have some problems. So let's try a few things like I don't know, let's transfer two something tokens, like more than we actually have and let's see what happens.
01:02:44.210 - 01:03:16.190, Speaker B: I'm not going to change this because I'm not even sure what it should say. Like 2000. What south end maybe here zero, I don't know. Let's try it. Okay, expected 2000 to equal 1000. Okay, that's already pretty weird because we never created 2000 tokens. But the balance of here it's 2000.
01:03:16.190 - 01:04:17.168, Speaker B: So here is where build layer comes very handy. If you were to debug this by just calling getters here or sending transactions, you are not going to have a very good time. You are only going to be able to debug the contract from an outside perspective and going to the internal execution. It's not very easy without Biddler. But here we can use a console log library that we created. You do that by just importing nomiclabs console. It's nomiclabsbizlerconsol sol.
01:04:17.168 - 01:05:14.224, Speaker B: That's a solidity library. It's implemented in a very non intuitive way. But you don't need to read its source code. But it's just a bunch of solidity that declares a console and you can call it like if it were JavaScript, like transferring from something to something and let's do this. And now when I run my test it's going to print that console log whenever that function executes. Just like if it were console log from JavaScript. This is very handy to debug your things.
01:05:14.224 - 01:06:17.088, Speaker B: So here we get to know that we are transferring from the sender account. It happens to be this one to zero. But the problem is that we are transferring more tokens that we have. So maybe we can do things like transferring some amount of tokens and we have amount. So here it's something like balances message, sender amount and let's see what happens. Okay, so transferring 1000 tokens and we have 2000. Okay, that's weird.
01:06:17.088 - 01:07:48.800, Speaker B: I mean that shouldn't be happening but we can prevent people from actually trying to do things like that. I mean if it works, you are creating money out of nothing. So there's always going to be someone trying to do that. So the actual thing that we want is for the amount to be less than or equal the balance and we can verify if this is true. Here by doing a console load here it should probably print false, right? So this is the problem. So this requirement of this function is being violated by the call that we are trying to run and of course it's going to ask for our code. So what we want to do is to protect our smart contract from these kind of things and we can do this with a solidity function called require that it receives a Boolean expression and a message that it's going to be printed, that it's going to be used if this Boolean expression is false.
01:07:48.800 - 01:09:33.138, Speaker B: So in this case what we want to require is that the amount is less or equal to the balance and we can add a message here like not enough funds and this message is going to be used to make the transaction fail but fail with a specific message. This is optional, you can do just this but I don't recommend that because then debugging is a mess if you don't know why your transactions are failing. So here if we rerun our test this will evaluate to false and this require will make the transaction fail. Okay, so here it failed, it failed with a message telling you that the transaction reverted and here is the message that we added to the required here. And the cool thing about bidder is that it's going to see that your transaction failed and recreate a solidity stack price. So instead of just getting the message of the requirement that failed, you are going to also have a stack price of solidity of the contract that you are executing. In this case the stack price is very tiny because you are failing on the same function that you are calling.
01:09:33.138 - 01:10:39.160, Speaker B: But if you were to fail on other functions it will be present here like in any stack phrase from any other language. So this is very handy to debug your transaction. So having console log and stack phrases you have debugging experience very similar to any other language. So finally what we are going to test is that this require actually does what we want it to do. So what we can do is use Waffle here. As I mentioned, Waffle is testing library for smart context that adds some functionality to chi that it's very useful to test smart contexts especially when they fail. There is a helper that it adds to chai that I don't remember its name so I'm trying to find it here.
01:10:39.160 - 01:11:40.778, Speaker B: Okay, yeah. So instead of using to equal here we are going to be using reverted with and passing it the message. Note that we expect the transaction to fail with and instead of awaiting here we have to await for the expect to be resolved. I think I modified the wrong test, sorry about this. Okay, it's here. Expect the token transfer to be reverted with not enough funds and let's try if this actually works. Okay, cool.
01:11:40.778 - 01:12:49.154, Speaker B: So that's it the good thing about testing for revered reasons or revere messages is that you actually get to know that your transaction is failing for the reasons that you think that it's failing. Because you can also do this and test without the message. But maybe your transaction is failing because of something else and in that case your test will be kind of lying to you and maybe you modify your contact a bit and your require stops working. So we strongly recommend using revere messages in your test. So I think that's pretty much it about how to develop test and debug contracts using biddear. You can get to the tutorial, complete your token. Like here we actually implement much more functionality, I think.
01:12:49.154 - 01:13:06.678, Speaker B: Or for sure we do implement like a complete test suit for this contract. There's a bunch more things maybe I don't know how much time left we have. Maybe Trent yeah, if you've got a.
01:13:06.684 - 01:13:14.780, Speaker A: Little bit more content, I think we're going to cut off in maybe ten or so minutes. So if you want to keep going for that much time, that should be okay.
01:13:15.470 - 01:14:22.330, Speaker B: So let's first see if someone has any question. You can use the raise your hand functionality if you want to ask anything or you can also ask in the chat. Okay, so let me show you how to send transactions from other accounts. This is also very useful for testing. For example, here we are always deploying and sending transactions from the first account that we call sender here. But there's also other accounts and we should probably test doing things with them. Like, let's call this other, I don't know.
01:14:22.330 - 01:16:01.300, Speaker B: So account other. What we are going to do is transferring some tokens instead of from the sender from this other account. It's pretty straightforward to do that with Ethers, you just have to call the function on the token on the contract that you are going to be using that is called connect and passing the account here. So in this case, we are transferring one token from the account other to the zero account and it's going to fail in the same way because we don't have any token in the other account and that's fine, the same test pass, but let's see if it actually works. And to do that, let's transfer some money to the account other from the sender. I know 100 tokens and we are just going to be calling the contact functions to do this. Like in this kind of test you do use JavaScript but you have to think you were actually executing the token that is written in Solidity.
01:16:01.300 - 01:17:07.970, Speaker B: So if you want to add some balance to an account in order to test something with it, you just transfer it some tokens. There's nothing special of it being in solidity or a contract, it's just like an object. And let's call transfer to other but not from other. So let's delete this here in this case this expect should fail because now that we have 100 tokens in the other account, this transfer from other to zero should pass. Okay, that failed but from another reason. It's good that we were checking the reason why it failed. So it says argument name.
01:17:07.970 - 01:18:01.516, Speaker B: Okay, I think the problem is that here we are passing the account object and not its address like in everywhere else. Everywhere else we are going to use the get address function to get the address. So let me explain a bit about what's going on here. Addresses in Ethereum are just like 20 bytes of data and there's a bunch of ways to represent it, to represent them. Normally we use hex encoding strings like this address. This is like the most common representation of an account with a string of its address. But in Ethers there's an object that represents accounts.
01:18:01.516 - 01:19:01.370, Speaker B: It's called signer. And signer does have in a list but has a bunch of other things like, I don't know, get balance. And this is going to return the amount of if that this account has. So when we call transfer here passing the other object instead of the address, it failed because it wasn't expected that type. Okay, cool. So now the test failed but for the reasons that we were expecting, this transaction is not being reverted, it's actually working correctly. And what we should do is probably remove this and just maybe check that the account co does actually have a token after this.
01:19:01.370 - 01:20:22.880, Speaker B: Okay, cool. So it's passing and I think that's pretty much it what you are going to be using to debug and test your smart contracts. There's also something else that you want to do when developing smart contacts that is deploying them to a live network. We don't have enough time to cover this here but there is a section on the tutorial explaining how you can do that. Basically you have to create a script that is going to be run with buildler and it's going to do pretty much the same than we were doing here like getting a contact factory deploying it awaiting for the token to be deployed and then it prints its service. But apart from that, there is a bunch of other plans that you may want to take a look at and there's one that is specifically for deploying contracts. It's called build their deploy.
01:20:22.880 - 01:21:03.484, Speaker B: It is built by one of our community members and you can learn how to use it here if you want to automate your deployments a bit further. There's a lot to tell about this plugin and we don't have enough time but you can find it if you go to Bidlear Dev and go to the plugin section here. I think that's pretty much everything. Does anyone have a question? Thanks.
01:21:03.682 - 01:21:16.832, Speaker A: Yeah, that was really great. Glad we had a little bit of extra time to go over a little bit more content. I think we're going to wrap here. We went a little bit over time. I hope that's all right. Some really good stuff. Again.
01:21:16.832 - 01:21:41.108, Speaker A: Thank you, Patricio. And Franco was sending a little behind the scenes chat support, so that's always good. If you missed anything, remember, this is recorded and will be available on the ETH Global YouTube channel just after this end. A few logistical things. Again, remember, we have three more events. One tonight at 04:00 P.m. Eastern.
01:21:41.108 - 01:22:10.592, Speaker A: That's a File coin getting started with Filecoin, we already have, like, I think, around 67 people registered. So it's going to be a good event with Andrew Hill of Textile. And then tomorrow there's a Lib P to P session and decentralized messaging with Jacob Hewn of Filecoin. And then another brainstorm session in the evening, eastern time, 08:00 P.m. With Juan. That one's going to be a little bit more open ended. You can show up.
01:22:10.592 - 01:22:35.556, Speaker A: We're going to chat about ideas. We're going to be pulling from the 100 hackathon ideas sheet that you may have seen floating around. So, yeah, that one's going to be a lot of fun. And then the other two sessions tonight and tomorrow morning will also be I'm assuming they're going to be as high quality as the ones we've already had. So those are the three that are happening tonight. And tomorrow there is the kickoff. As I mentioned at the beginning of the session.
01:22:35.556 - 01:22:53.580, Speaker A: That's Monday, twelve noon eastern. Again, it's going to be sort of setting the stage for the next 30 days. I hope everybody attends. We'll be sending out invitations for that as well. Thank you so much, Patricio. Again, it's a huge help. We appreciate you sharing.
01:22:53.580 - 01:23:19.636, Speaker A: Yeah, give him a little class. This is super. Yeah, I think that's it. I don't think I missed anything. Oh, make sure to stake. I mentioned this at the beginning as well, but you have to stake you get it back at the end of the event. But we want to make sure that people that we're supporting are committed to participating fully.
01:23:19.636 - 01:23:28.980, Speaker A: I think that's it. I'll let everybody have a good rest of the day. Thank you again and we'll see you. Bye.
