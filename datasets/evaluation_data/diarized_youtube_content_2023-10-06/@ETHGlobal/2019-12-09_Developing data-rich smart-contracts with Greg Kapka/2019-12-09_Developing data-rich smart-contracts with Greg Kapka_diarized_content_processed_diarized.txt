00:00:00.330 - 00:00:36.758, Speaker A: Hello, everybody. I'm Greg from Provable Things and we are an Oracle for smart contracts. So who here has ever needed the results of a Web API on a smart contract? Does anyone need it for this hack? In fact, that's a shame. Dennis is going to nod. I'm going to use him. He's a colleague of mine, so but that's what we're ideal for. We are, as this says, a security oriented data transport layer for decentralized applications to connect with Web APIs, which is quite a mouthful, but it is exactly what we do.
00:00:36.758 - 00:01:08.546, Speaker A: We connect smart contracts with Web APIs in a secure fashion and a provable fashion, which is where our name comes from. We used to be known as Oracleize. We are now known as Provable. And it kind of fits better because everything we do is provable cryptographically for security reasons and for you guys to be able to trust what you're getting into your smart contract. We have been on the main net for nearly five years now, which is crazy. This slide is definitely old because we're way over a million queries. We're probably nearer two these days.
00:01:08.546 - 00:01:43.866, Speaker A: We've been adopted by tons of projects. We're on all sorts of blockchains, including private ones, which is cool, and we're also in books now, which is excellent. Our CEO, Thomas Batani, is in that book right there, which is a good book if you haven't already got it. So we are easy to use, which is probably our key feature when it comes to solidity. And even this sort of slide makes it look more difficult than it is because that import line at the bottom is pretty much all you need hello. To get your contract working with our service. And it is literally as simple as importing that API.
00:01:43.866 - 00:02:21.418, Speaker A: And it's so simple, in fact, that I can actually show you super easily on the next slide in a single slide, which is cool. Try that with other known Oracles out there. We are integrated with various of the frameworks you guys need and have used to make your solidity projects with Truffle, Remix, Open Zeppelin. These are all great people and we've tried our best to make everything work super well with them. So that it's quick and easy for you guys to get working with the same environments you're used to using. So who uses Truffle? Yeah, most super easy. So, again, we actually have a starter kit, actually, with Truffle nowadays, which makes it super easy.
00:02:21.418 - 00:02:41.630, Speaker A: Where has anyone used a Truffle box? Yeah, used it. I was nearly going to be a friend then. It's really easy. You definitely should use it. It's over here at our GitHub. But you don't actually need that because you can just unbox it via Truffle, which you guys will know if you've used Truffle before. Unbox it, go into it, install stuff.
00:02:41.630 - 00:03:40.174, Speaker A: The reason we've stuck it in a box is for this step, which is the way that our oracle service can work on your test network because when you're running locally, you're running a version like Test RPC or Ganache as it's now called, and that's local. How on earth can we interact with that? Well, we do that via the Ethereum Bridge, which is a great piece of software and works well, but we don't want you guys to have to learn about it if you don't want to. So the Truffle box does all this for you and bootstraps it up super easy. So don't worry about this too much yet. If you're going to use a Truffle box, this is all done for you. And once you've pulled the Truffle box, it is as simple as going into Truffles development console, running the bridge in a separate terminal next to it, and then you can run tests. The Truffle Starter Kit has a small contract in it with some tests written so that you guys can have a look through as to how you'd arrange that yourselves and how you'd organize tests in a sort of Truffle environment with our Ethereum Bridge running and our Oracle making actual calls.
00:03:40.174 - 00:04:30.242, Speaker A: And if you run this test, you'll be able to see in the console where you've got the bridge running, you'll see the service running and you get to see all your results as they come in live, which is great fun and super easy for Debugging. So dead easy. Now, this is the main bit of this talk, obviously, because it's a hackathon and you're going to want to see how to use it. And the reason that we claim where the easiest Oracle is, because the next slide proves it. This is a fully working, fully compiling contract that is getting an external temperature, in fact, which here is kind of pointless because we all know it's freezing, so we don't need to know the temperature any other than that. But this whole contract is going to ask an external web API for the temperature at a particular longitude and latitude, as you can see on there. And when it does so, it's going to return it to your smart contract and that's baked in and dead easy.
00:04:30.242 - 00:05:05.530, Speaker A: And it is that big or small, sorry, I should say small. So, if you have a look through this example, you'll see the basic format for how our Oracle works. We can see you tend to have two functions. One of them which calls for your query, and one of them which we call the Callback, with the double underscores at the bottom there, which is how you get the result back into your smart contract. And if you look at the Get temperature function, you'll see the query is super simple. There are various other cases for this, but this is the simplest URL data source query you can get. And you can see we're asking for a URL via the URL bit and then we're passing in the URL.
00:05:05.530 - 00:05:58.874, Speaker A: There is indeed a wrapped bit of JSON around it, which is just to alert that you want the JSON that that API returns, passing down to just the main and temp fields but tiny bit of extra complication. But the point being when you ask for a web API you're going to get a huge JSON back most of the time and you're probably not going to want all of that data. So we make it as easy as possible for you to get just the piece of data you want. All of you who's worked in Solidity know how expensive it is to store and have anything in Solidity. So this way means you can get just the tiny bit of data you need without having to store anything else and thus cheapest gas possible once you've made the query. In this case you'll see a callback function gets called which you can see the parameters are a query ID and the result the query ID is a unique string given to every query. This allows you to be able to track them in your own smart contract.
00:05:58.874 - 00:06:53.886, Speaker A: It also allows you to do other cool stuff outside of the smart contract whereby other people can view your query and verify your query, which is super useful in terms of decentralization. And the result obviously is the result you're after, which you'll notice is a string in the callback functions. We first check that it is indeed the Oracle service calling this contract so that you can't have anybody calling it with results which would put your contract in a bad state. And in this example I was checking whether we need a jacket in ETH Waterloo but we need a jacket and a coat and extra layers because it's freezing here. So this is not so much fun for this one but you get the idea. If we go on though, we're going to see more examples that get slightly more complicated via the use of authenticity proofs. These proofs are how we as a service allow you to be trusting that the result you get is what you asked for.
00:06:53.886 - 00:07:38.810, Speaker A: So we don't want you to trust us because this is ethereum, you shouldn't be trusting anybody, you should be verifying stuff. And so we provide cryptographic proofs that what we do is exactly what you asked for. And in those proofs you can take those and you can verify them yourselves. And there are various different types of proofs and whatnot which I won't go too in depth to, but the point being via the proofs you get to decide whom your trust line ends with. So for example, if you use a Tlsn, notary you're trusting Amazon now and so on, rather than us, which is the way the proofs work. The previous example I showed you that had no proof is what you'd probably do for like a hack today. If you just need some quick data in your smart contract, something in production, we would recommend using authenticity proofs, and we say plural, because you can use multiple.
00:07:38.810 - 00:08:15.274, Speaker A: You can decide to decentralize further and further and rely on various different data sources quickly and easily and in a verifiable way. So here's one using a proof. I've made it orange, so it's super easy. This one's using the Android proof, which is using the Tee on an Android device. A Tee, sorry, as a trusted execution environment. And what it does is we make your query happen via this trusted execution environment and then provide a proof that that did indeed happen via that trusted execution environment. Meaning you can check that and have all the data you need to know that what query we made on your behalf was made exactly how you required it, in this case.
00:08:15.274 - 00:08:27.790, Speaker A: The rest of the contract, which again, notice fits on one slide, is super tiny. We've got a function and a callback. Our function this time is an update function. It's the URL data source. Again. It's another JSON. So we're going to pass this result down.
00:08:27.790 - 00:08:57.654, Speaker A: And this is from the Kraken API. So we're obviously getting a price and it's the ETH in bitcoin price, I think. So, same again. We make the query and then the query comes back as a callback. We require that the message sender is indeed the Oracle, and then we set the result. The only difference this time is that your result, if you look the callback function has three parameters, the third of which is the proof, which comes straight as bytes, which you can do with as you wish in your smart contract. As you can see in this contract, we've done precisely nothing with it.
00:08:57.654 - 00:09:25.422, Speaker A: So I don't recommend that it would be pointless. But you can be storing it in a contract, you can be verifying in a contract, you can do as you wish. The point being, at this point, with a proof, you can verify that what you get is what you wanted. Hello, do you have a question? Yeah. When you select which type of proof you're going to do, do you require the client to have that? No, that's all done on the back end side for you. We provide those services for you so you don't have to worry about that whatsoever and we provide ways for you to verify them as well. So it's all good.
00:09:25.422 - 00:10:05.422, Speaker A: The next example is another proof type, which this time it's Tlsn, notary, which, as I said earlier, is so Amazon based and we're trusting all that. But the key to this slide, again, one contract fits entirely on one slide for a query, is that we're actually storing the proof now via IPFS, which you can see up there. And the reason this is good is that some of the proofs, depending on the proof type, can be large. These are cryptographic proofs and they're not a fixed size. And it depends also on your query. If these are huge, you don't want to be storing all those bytes in your smart contract because it costs a lot of gas. So instead you can actually store them in IPFS and then what you get returned in your callback function.
00:10:05.422 - 00:10:48.902, Speaker A: Here is the hash instead, which I've written that terribly because I forgot to put the proof on that one, which if I had to put the proof in the callback, you would get a hash, an IPFS hash of where your proof lives. And then again, all you've got to do that's decentralized, you've got your hash, you can then verify the proof that way or the user can or whomever it is that needs to rely on this result. Same story, it's a URL query. In fact it's exactly the same as the other examples and you can see two lines got it done. So that is another proof type. The final example is a really useful one for any sort of hacks to do with stuff like this and that's randomness because randomness as you know, is very difficult on a deterministic chain, as it ought to be. So what do we do? We go offline for randomness? How do we go offline for randomness? You need an oracle.
00:10:48.902 - 00:11:22.406, Speaker A: How do we provide that? We use a ledger, which anyone got a ledger? Anyone use a ledger? You've had up for everything. That's one, one at least another device that has a trusted execution environment inside it. So we leveraged that and we've written a program, put it in there and said hey, get us some randomness using the actual on chip randomness. So it's true source of randomness, none of the problems you'll get of blockchain randomness. And this time we're going to use the ledger proof which unsurprisingly it's the proof type for the ledger that we're using. So same thing. Unfortunately this one can't fit on one slide, but there's a good reason for that.
00:11:22.406 - 00:12:13.970, Speaker A: So I can't show off the size of it. This is a fraction bigger, but the reason it's bigger is because with the ledger proof you can verify that proof on chain. Not all of our proof types are verifiable on chain due to size and various other issues, but the ledger proof is one that is verifiable on chain. And when it comes to randomness, you'll know, if you're doing anything sort of gambly that the randomness is critical and for example, you couldn't have randomness into your contract and then have that randomness not be verified cryptographically at a later point, by which time you may have already paid out a prize that would be a disaster. So the ledger proof allows you to verify it on chain, which means before where you would in your callback function probably pay out a prize. For example, if it was a lottery, let's say. Now you can actually switch logic based on whether it's verified or not, which is super critical and super important, especially when it comes to randomness.
00:12:13.970 - 00:12:51.086, Speaker A: So the same story. We have a function that calls the data source. In this case it's a little bit more complicated because we're asking specifically for our random data source and we've got to give it and say how many bytes of randomness do we want? You've got a couple of other parameters, one's called delay, we've got it as zero, so there's no delay. But the point being there, which is useful for other contracts as well, is that you can have a delay, which means that you can say hey, here's a query, but I want the answer tomorrow. Now that's super useful because it's impossible to defer a query in that sort of way, any other way you can't do it yourself other than by manually doing it, whereas this way you can ask the Oracle to defer it for you and it will come back a day later. Super useful. The bytes.
00:12:51.086 - 00:13:23.846, Speaker A: You can ask for as many number of bytes as you need based on the way it works. You can cast those bytes to an int for random numbers and obviously seven bytes will be a huge number, so there's plenty of entropy there if you need. And finally, in the callback is where we're going to check first. Is it the Oracle calling me? Yes. And then we're going to try and verify the proof at which point there's some maths going on there which you don't need to be familiar with if you don't need. But it's basically turning our bytes into a number in a safe way without any bias. And if it's verified, we will do that maths and then you can go on for the contract's logic to do something with your randomness.
00:13:23.846 - 00:13:47.122, Speaker A: Otherwise if it's failed, proof verification has failed, handle it, which is however you need to do it. But the point is now you can handle that inside your smart contract. So that's really cool. This is basically what I've just said, the top half of the slide, so it's not much use. I'll let you have a quick read. The bottom half is more interesting though, because it shows that we have more data sources. You can ask Wolf from Alpha for stuff.
00:13:47.122 - 00:14:26.702, Speaker A: Fire hour, Oracle. You can do Nested queries, which is super cool, where you can make a query that makes a query to do other stuff. So you can start combining data sources and getting really powerful stuff going on. You can use encryption in your queries. So if you're calling an API that has an API key and you don't want your API key falling into the public hands, how do you have that on chain? Well, encrypt it, we can deal with that too. So super useful. And then finally, which is one bullet point, but you could expound on it for hours, is the computation data source, which if you're used to solidity is really useful because with a computation data source you can run any computation you like and have the Oracle call to that computation.
00:14:26.702 - 00:15:12.590, Speaker A: So you can defer computation off chain, which means you're no longer bound by the EVM and Solidity and all the various gas type situations there in terms of size, length of time, time amount to compute stuff, so on and so block, gas limit, et cetera. So the computation data source, you could write a computation, let's say in Python, stick it in a docker and then have the Oracle call to that computation with params from your contract and then get the result back to your contract which, as you can see, outsources a ton of expensive work if you want it to. So that's mega useful. There's no example here because it's probably a bit more complicated, but if any of you want something like that, and especially for a hack today, I'll be hanging around and you can just come and ask. It's dead simple, it just doesn't fit on one slide, so it doesn't look quite as neat as the rest. That's why it's not there. So that's cool.
00:15:12.590 - 00:15:59.210, Speaker A: Some of the other stuff we have are verification tools for those various proofs. As you've seen, some of them are verifiable online, so the tool is useless for those, but the ones that aren't, these open source tools allowing you or your customers to verify proofs so that they know the data they're relying on is reliable. So that's cool. And we have two other quite handy tools which are on our website, which are the test query and the check query tools, which means if you're at a hackathon, for example, making Provable queries, you can use these tools to very quickly iterate over your query to check you're getting the right answer. So this saves you having to go into Solidity, having to write your query, having to debug a whole bunch of other issues. This way you can just write your query and see the result in real time. What would you get? And once you've got it working on the check on the test query tool, you can stick that straight into Solidity and you'll get the right results.
00:15:59.210 - 00:16:25.750, Speaker A: So that's super cool and congrats you are. Now this, more importantly on this slide is the number at the bottom. So we have tons of credits for you available for anyone who uses the Provable Oracle in your contracts. There are so prizes like everyone else is doing and basically these are main net credits because there is a cost to the service, but not if you win this. So that's cool. So get using it. If you need any help, I'm around and you can just ask me.
00:16:25.750 - 00:17:30.118, Speaker A: And there is one final cool new thing that I've got to point out, which was announced, I think DevCon, which is something else we're doing, which is this, which is using much of the same technologies. But it is the P token, which I've been working on personally, which is actually a sort of the same te stuff that we use and the same Oracle service. But if you twist it around and act as if a wallet on another chain is the source of the data for your Oracle, and then the te is the Oracle, what you end up with is a decentralized and provable peg between two different chains, which allows for all sorts of cool stuff. So DeFi on steroids, as is written here, which I quite like. And it's a way that we're using our own Oracle to bring all sorts of liquidity from other chains onto Ethereum. So we have a proof of concept of this, which there's a lot of text, I'll let you read that. I'm not sure on my time for that since I have like two minutes, but basically, as you can see, we're taking two blockchains and smashing them together inside one trusted execution Environment.
00:17:30.118 - 00:18:15.690, Speaker A: Which Trusted Execution Environment holds both sets of keys and thus can sign cross chain transactions in a way that is completely unseeable by humans and totally decentralized and can be run on anyone who has the same tee hardware, which makes it super cool for a peg like this. Our proof of concept currently is using EOS. So on this side you can see there's two chains talking to each other via a trusted execution environment. The non ETH blockchain our proof of concept is using is EOS. And the ETH blockchain then has what we're calling Provable EOS or PS on it, which is cool. And that describes that this is the front for when it looks like it. So if you've got some EOS, you can just go on our dashboard and you can deposit EOS to the EOS side smart contract and it will mint PS on the ETH side.
00:18:15.690 - 00:18:45.780, Speaker A: This is just showing you some of the mintings. You can see the circulating supply and the underlying asset, which should be in Parity, except for if you deposit and then look before it's mined on one or two of the other sides. But they're in Parity most of the time. It's decentralized in the sense that people can submit their own blocks to an enclave to do it as well. So it doesn't rely on anybody running this stuff. It relies it's totally decentralized. Anyone could submit ETH blocks or EOS blocks to an enclave and it will process any transactions it finds pertaining to either side's wallet, which is super cool.
00:18:45.780 - 00:19:22.782, Speaker A: So, yeah, as you can see, this is the one direction where you would deposit, say, EOS for our proof of concept. Trusted Execution Environment will see that and will sign a equal and opposite transaction on Ethereum and then boom, you have PIOs on Ethereum and vice versa, where you would go to this PIOs smart contract and burn that token. The Enclave will see that transaction happen. It will sign the equal and opposite one and thus release your EOS to whatever account you so. It's super cool. And like I said, all you have to do is look at it as if the wallet on one side is the data source, and then the execution environment is the Oracle. And you see how it's all the same cool tools that we're using just in a new DeFi sort of way.
00:19:22.782 - 00:19:52.954, Speaker A: So here's some I'll let you have a look at these. These slides have been made available to all of you guys via the I can't remember where I'll figure it out. But this is why it's great and there's tons of info on there. I'm not going to go through it all in my -1 minute of time left but that is just a little example of one of the applications that is cool for Oracles. That's quite an advanced one. But hopefully we're going to see you guys do something with an Oracle that's also as cool. Any questions? I don't mind an applause either.
00:19:52.954 - 00:20:22.734, Speaker A: That was cool. Thank you. Are you allowed to ask for one is that right any questions? Sorry, go ahead. You guys are Oracle and then chain link is another Oracle, correct? Yeah, we're similar, we do the same thing but we're very different in execution. So we've been sorry, do they have well that's what's funny, we could be an Oracle on their network. There'd be no problem with that. What they don't have is the authenticity proof.
00:20:22.734 - 00:20:57.760, Speaker A: So when you go on chainlink, you would ask for a chainlink Oracle. You would pick one to choose or multiple. But the problem each one of those you're then trusting each one of those whether they want to provide authenticity proofs. I don't think any of them do, but you don't have any guarantee that what they're doing is correct. If you use more than one, you're going to get some sort of Byzantine fault tolerance thing going on where you're going to trust X out of Y maybe, but most of the times you're going to be using a single Oracle because of the costs. And at that point you're just stuck trusting that Oracle even though their network is decentralized. So it's a totally different trust model which is really interesting and they work well for different.
00:20:57.760 - 00:21:53.854, Speaker A: Have you don't do the many Oracles? No, we do single Oracle with many trust lines. So that's the difference. So because you can use multiple proofs, you can trust these different big name servers like Qualcomm, Amazon and so on and Google for the tees that we use like the Android Te and you're trusting those guys so you can put like a monetary value on how much you can trust to them. So one Oracle with multiple trust lines versus multiple Oracles with no trust lines except where you decide see the difference multiple trust lines, google or the both on the scale of decentralization just in totally different ways, which is quite interesting. We've also been around a lot longer because we've been in the space for ages but anyway, you had a question. Yeah, I guess my question is cool. Yeah, feel free to ask later.
00:21:53.854 - 00:22:14.070, Speaker A: Anyone else? Go ahead. We are Oracle's, so it's really confusing. We've rebranded it's super confusing. I'm really sorry about that, but yeah, it we are. There we go. So that's it. Anyone else? Thanks for all paying attention and occasional laughing at my jokes.
