00:00:01.210 - 00:00:17.882, Speaker A: Hey, guys. Faku from Urine Finance here. I'm going to give the workshop about the Urine vaults today. I hope you enjoy it. Let's go to the presentation. Now let's talk about how to build on top of Urine vaults. Urine vaults are simple token containers.
00:00:17.882 - 00:00:57.402, Speaker A: It's like transparent box where you deposit your tokens and then those tokens are taken by investment strategy that are going to do all the heavy lifting from the vault. The cool thing is that we don't have to worry about the complexity of the protocols. We only have to worry about how to interact with the vault. So the vault is kind of like the front end, like the smart contract front end for all those investment strategies. So the vault is written in Viper because we didn't have all the mathematical functions that we needed in solidity. So back then, we decided to do it in Viper. Don't worry, it's like using any other smart contract on chain.
00:00:57.402 - 00:01:15.882, Speaker A: It's just the same. You can use solidity anyways. And the vault tokens are ERC, 20. So that's super standard, we all know it. You can transfer vault tokens to a friend, to a colleague or whatever. You can swap the vault tokens for other tokens. You can use them as collateral in other protocols that accept vault tokens as collateral.
00:01:15.882 - 00:02:04.510, Speaker A: That's a cool thing because it's an investment that has utility and do everything else you do with tokens, like getting the balance of it, et cetera. The vaults are going to keep the accounting, that is to say, they are going to have the amount using balance off and also the price per share. The price per share is the value that will be used to adjust the amount of YV tokens to know how much underlying you have. The underlying tokens is the token you deposit. Another cool thing that we are super keen, it's immutable code. So it cannot be changed, or at least most of it cannot be changed. And the parts that can be changed are managed by Urine governance.
00:02:04.510 - 00:02:26.502, Speaker A: That is to say YT holders and the seek for execution. Also, the vaults are going to be able to handle multiple strategies. So that's obstructing difficulty to us. And keepers. Keepers, it's another value function. But those little bots allows us to sleep well at night. They automate the debt strategies.
00:02:26.502 - 00:02:47.266, Speaker A: Handling like the safe ratio when it's a collateralized position. And also handling the harvest. Harvest is what we use to collect the rewards and invest the money. So let's talk about interactions. We know that the only important thing is to interact with vault. First thing important, how to deposit. Super easy.
00:02:47.266 - 00:03:16.454, Speaker A: It's just calling the deposit function. So on the right you will see a flow. The user calls the deposit function. The user sends the tokens and is going to receive YD tokens. So if you deposit die, you're going to receive YV die. That's your receipt to call it some way. Then those funds are going to sit in the vault until the harvest function is called and those token will go to the strategy, to any strategy, many strategies.
00:03:16.454 - 00:03:56.626, Speaker A: That depends how it's set up at that moment in time. We're not going to go too deep into that right now. Then the withdrawal functions, the withdrawal flow, it's similar. The user will call the withdraw function and it's going to burn those YV tokens we talked about, YV, die, for example. So then the vault has to search, where do I get those tokens from those dai? So it's going to search in what we call the withdrawal queue. That is a queue with all the strategies that the vault is managing. When the vault finds the one it's going to call withdrawal, it's going to get the tokens and send the tokens to the user.
00:03:56.626 - 00:04:42.838, Speaker A: This is not a complete one, it's a high level one because sometimes the vault is going to have tokens uninvested sitting there because the harvest function, for example, has not been called. So the withdrawal is not going to be a deep withdrawal. That is how we call it when it goes to the strategy to get the funds. But it's going to be a cheap withdrawal because it doesn't have to go to the strategy to withdraw the fund. Now, what's the withdrawal queue? The withdrawal queue is super important because it's the order in which the strategies are called to withdraw funds in case of a strategy is depleted or the buffer sitting in the vault is depleted. Okay, so this is the order. It has a sense.
00:04:42.838 - 00:05:34.710, Speaker A: So we order them from the cheaper to the most expensive in gas cost because we want users to withdraw as cheap as possible. And also if, for example, some protocol has some withdrawal fee or something and for that reason we want it to be the last one, we just put it at the last place. But let's say that you want to withdraw no matter what. Yeah, I know no one wants to lose money, but we need max loss because for us it's super important that our users are always able to withdraw no matter what. If you want to withdraw and lose 50%, okay, put 50% in max lot and you're going to be able to withdraw. This only happens when the vault has to do a deep withdrawal. So it has to reach to the strategy and withdraw the funds.
00:05:34.710 - 00:06:29.270, Speaker A: What you have to take into account is that if a strategy has a loss that has not been accounted to the vault, when you withdraw, you are going to get hit with all the loss. It's not socialized. So that's something to take into account when withdrawing. Now, the price per share super important view function. Super important because when you're going to deposit or withdraw, this is the right ratio we're going to use to convert underlying, in our example, die to vault tokens YV die. So for example, while the vault is deployed and the price per share is one, you deposit 100 die and you're going to get 100 YV die. After some time with yield accruing, let's say that price per share is two and you deposit 100 die, you're going to receive 50 YV die.
00:06:29.270 - 00:06:49.674, Speaker A: That doesn't mean that you have less money or you lost money. Because those YV die. You got to multiply it for the price per share. In this case, two. So it's 50 times two is going to be 100. That's the underlying amount of tokens that you have invested. Another great thing we don't want to be sandwiched.
00:06:49.674 - 00:07:17.026, Speaker A: No, nobody wants to be sandwiched. Mev is super popular right now. So we implemented what we call profit lock. So when we have profit, we're going to lock it for 6 hours and release it little by little, linearly. So although profit is not going to hit all at once, you will see a slow increase in the price per share. We don't have only one vault. We have many vaults.
00:07:17.026 - 00:07:53.342, Speaker A: And we started with the vault P two. We saw that we needed to migrate from one version to another. Because we found a bug, because we found an optimization, because we needed to implement a new feature to make things better, cheaper, everything. So that's why we have the registry. It's just a smart contract that we use to keep record of the deployed vaults. So when a new vault version is released, we're going to call new release. That is going to deploy a new vault and it's going to have a new release, a new release version.
00:07:53.342 - 00:08:25.098, Speaker A: Then the new experimental vault is what we use to deploy vaults that are not production ready yet. So strategists use this to deploy vaults and test on APTAC for example. Then when the vault is ready, test it battle, test it. Governance can call endorse vault. And that vault is going to show on the main website. And new vault, it's the same one. It's the same thing as experimental, but it can be used to create a new production vault.
00:08:25.098 - 00:08:59.798, Speaker A: The difference between the two of them is that new experimental vault is permissionless. Anyone can call it new vault can only be called by Governance because that is going to show the users that the vault has been tested. And latest vault, it's an important thing because it's what allows us to know which one is the latest vault. The latest version of the vault. For a token. For a particular token. So if we vault latest vault die, it's going to give us the address of the latest vault that we deployed for the Dai Token.
00:08:59.798 - 00:09:26.934, Speaker A: Of course, always production vaults. Now, yeah, all this thing is good, theory is good. But let's do some integration work. Okay, let's go. How can we integrate? Okay, we have the router and the wrapper. The router is going to send the user vanilla tokens that is to say YV tokens, urine tokens. It's super simple, it's noncustodial.
00:09:26.934 - 00:09:57.222, Speaker A: That is to say it's not going to hold funds, user funds. And users will be able to withdraw using urine website or urine smart contracts. I don't know if that's a good thing, a bad thing. That depends on the use case. The wrapper, it's similar to it, but the user will receive a custom token. So they can receive the fakuyb token, for example, or whatever they want to call it. You can program more custom logic because this contract is going to hold funds.
00:09:57.222 - 00:10:25.518, Speaker A: That's how it's able to mint new custom tokens. But it also is going to help you with migrations and it's going to automate some registry usage. So let's take a look at the flow. Here the router. You see, the user again calls the deposit function. This time it's going to use the integrator router. It's the contract that sits in the middle between the vault and the user.
00:10:25.518 - 00:11:06.814, Speaker A: It's going to send the tokens to the integrator. And then the integrator is going to call the deposit function of the vault. But it's going to use the third parameter that is called the recipient that is going to tell the vault that you're deposited for a friend, in this case for a user. So the integrator contract is going to send the tokens and the vault contract is going to send the YB tokens directly to the user. Then the user will be allowed, as you can see in the flow, to withdraw using the yarn smart contract or urine website. Okay, that's the main difference, not holding tokens and being able to withdraw from urine. So now let's go to wrapper.
00:11:06.814 - 00:11:43.530, Speaker A: This is a longer flow, you can see it. And the main difference is it's going to hold funds. So the user is going to call a custom function that you can call it whatever you want. It's going to send the tokens to the integrated contract that now is using the wrapper. That contract is going to call the deposit function to the vault to deposit the tokens. But this time the wrapper the integrator contract is going to receive the YB tokens and then it's going to do whatever it wants with those tokens and then send the user the integrator YB tokens. So it's a different token.
00:11:43.530 - 00:12:29.210, Speaker A: That user is not going to be able to withdraw from the yarn vault. Yeah, okay, so those tokens, those YB tokens, those funds are held inside the wrapper contract that the integrator is using. So when the user wants to withdraw in the step eight is going to have to call the withdraw function. Again, you can call it whatever you want of the integrator contract, which is going to have to call the withdraw function on the vault, receive tokens and send the tokens to users. You can have custom logic all over the place, like the withdrawal function maybe doesn't have to go to the vault all the time. It can have a buffer in the wrapper or whatever you want. So this is more flexible, but it's also more risky because you're going to hold funds.
00:12:29.210 - 00:13:22.060, Speaker A: So what are the wrapper and the router doing to help you with automation? First, they're using the best vault function. The best vault function. The code you can see it on the right is really cool because it's going to return the latest version of the vault for a certain token. Nice thing about this, you can override it. Maybe the best vault for you is not the latest version, but the one that is performing the better or the one, I don't know, whatever condition it's best for you, you can change it. But for us, this is what we use, the latest version of the vault. So when you see the withdraw function from either the router or the wrapper, it's going to loop through the vault to withdraw always from the older one.
00:13:22.060 - 00:13:37.214, Speaker A: So that's cool because you don't have to migrate. For example, you have vault versions 0.2.00, .3 and 0.4. So when you withdraw, it's going to withdraw first from the 0.2 version. So there's no need to migrate.
00:13:37.214 - 00:14:08.938, Speaker A: Users are going to migrate little by little, all by themselves, without knowing, and you are abstracting all that custom logic from them. And that's great. Same thing for the deposit function. The users always call the same contract the same deposit function and they're going to deposit to the latest version even if they have tokens from other versions of other vaults. So that's a great thing. Also, you are always helping users, you are always abstracting difficulty from users. And that's amazing.
00:14:08.938 - 00:14:52.550, Speaker A: For us, the latest one and this one only, we've only implemented it for the wrapper because the wrapper is the one holding funds. So if you want to migrate to force funds migration, we have implemented the migrate function. This is going to withdraw from older versions and deposit to newer ones. This is good because at some point in time, very old vault versions are going to be deprecated and we're not going to be harvesting them anymore. So the funds are going to be sitting there. So it's cheap to withdraw and you can migrate all the funds. This is only possible right now with the wrapper because it's the contract holding funds.
00:14:52.550 - 00:15:22.514, Speaker A: The router is not holding funds. So you could need a lot of approvals, but you could do it if you want. Of course, you're now the technical expert and that's great. But sometimes you can need ideas. So we are here to help you. We created what we call a pool of ideas. The pool of ideas is just a web page where we allow community to submit their ideas and say they are looking for a team.
00:15:22.514 - 00:15:39.890, Speaker A: So if you don't have ideas and you have a team, go there, pick an idea, contact the person and let's build the future of finance together. You can always reach us on Discord. We're in the Oyef online discord and we're willing to answer all the questions. Thanks a lot for watching. Bye.
