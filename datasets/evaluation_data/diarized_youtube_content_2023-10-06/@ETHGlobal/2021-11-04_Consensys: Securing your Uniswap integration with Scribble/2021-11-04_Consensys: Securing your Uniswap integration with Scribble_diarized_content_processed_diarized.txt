00:00:00.890 - 00:00:14.960, Speaker A: And we have Joan as our speaker for today, and he'll be taking you through the session. And with that being said, I'm going to pass it over to Joan to introduce himself and get the session started.
00:00:17.250 - 00:00:46.278, Speaker B: Perfect. Thanks. Let me hop over and share my screen with my slideshow. Yes. All right. So hello, everyone, and thanks for the introduction. So, I'm Joan, and during my day to day job, I'm the product lead at Consensus Diligence.
00:00:46.278 - 00:02:03.310, Speaker B: And so at Consensus Diligence, what we do is on the one end, we do audits, and this is probably what we're most well known for. But we also have a product site. So we've built Mythx as a vulnerability scanning tool. And right now, we're actually working on a new product called Diligence Fuzzing, which has some relation to the workshop that I'm going to be giving today, and I'm going to show some sneak peeks as well. But the workshop today is really going to be all about Scribble, which is a super nice tool that I'm going to explain in a second and how you might apply it to your integration with uniswap contracts. So, let's see. I'm first going to give a brief introduction into what Scribble actually is, what specification languages are, what property based testing is, before diving into deep into the subject matter, which is going to be me, Scribbling ERC 20 token.
00:02:03.310 - 00:03:18.550, Speaker B: So what I'm going to do is I'm going to walk through a smart contract that implements the ERC 20 interface, and I'm going to add specifications along the way so that you kind of see what the workflow is like and what kind of properties you might specify. And then I have four examples set up of how a smart contract might interact with uniswap and what kind of properties you can write to make sure that your integration is doing what it's supposed to be doing with uniswap and not something else. And I'll finish with a small wrap up. I'm going to try to do the workshop part for about 40 minutes so that we have enough time for questions to dive deep into custom topics. All right, so before I go into what Scribble is, I want to talk about what properties are. And properties what they are is, or how we can define them is a logical statement that you expect to be true. Well, there's two examples on the slide.
00:03:18.550 - 00:04:14.560, Speaker B: The bottom one is the most relevant one because usually we're talking about code when we're talking about properties. So, for example, a function might only be allowed to return positive numbers. The key of this sentence is that it's something that you expect to be true. So whenever you are writing code that interacts with other code, you're basically making assumptions about how you think that other code will work when you call into it. And this is also where a lot of bugs come from when you think something is supposed to be doing something, but it is actually doing something else. So your assumption is invalid and that's why you want to test those properties, those things that you expect to be true. And that's where Scribble comes into play and what it helps you do.
00:04:14.560 - 00:05:03.274, Speaker B: So Scribble is a tool that we built. It's been released for, I think about a year now. We released it around this time last year and it's basically two things combined. On the one hand, it's a specification language, like a programming language essentially. And on the other hand, it's a runtime verification tool. So a specification language is essentially something or a language, a programming language, a formal language that you use to write properties in scribble is based on solidity wherever we can, so that it's easy to use. And you write these properties as annotations, or what we call annotations.
00:05:03.274 - 00:06:02.874, Speaker B: This basically means you write code comments in this language next to the code that you're describing, which looks like this. So here I have a really short example with a really trivial property, but it does highlight how it works. So we have a function, this cannot be hacked, that's doing something. And we have a property that says that this function is only allowed to return numbers higher than zero, not zero. And you see that the property is like right next to the function that it's describing. Now this is great. You can write properties about your code and it will define what it's supposed to do, but we kind of want to have something that we can actually run, that we can test with.
00:06:02.874 - 00:07:04.370, Speaker B: So that's where the runtime verification comes into play. So we take these properties and we translate them into solidity code that checks the properties so that afterwards we can run the test suite or we can run fuzzing or symbolic execution. And it will look for different ways to trigger these assertion failures and it will be able to tell you when there is a way to trigger a property violation. So this slide shows kind of a rough example of what instrumentation could look like. On the left we have the original property, and on the right you see how we instrumented the code by adding an assert at the end saying that the result is bigger than zero. Now, this is a trivial property. There's lots of things that you can do with Scribble that I'll show later that produce more complex instrumentation.
00:07:04.370 - 00:07:50.900, Speaker B: This instrumentation is used for testing only and won't show up in your production deployment for various reasons. For example, gas usage, but also security. You don't want to add unnecessary code because it increases your text service. So here's one way to think about testing with these properties. Or also this is also called property based testing. And essentially you can think of it as an extension to parametric unit test. So in a parametric unit test, what you do is you essentially separate the test case from the check that you're doing.
00:07:50.900 - 00:08:36.610, Speaker B: So here in the slide, I have a Python example of this. On the top we have a function that performs the test based on a particular test case. So what it does, it calls the add function and then it checks that. The add function returns the sum of the two numbers. And then on line six and seven we have something that puts in the parameters and runs essentially all the edge cases. Scribble essentially replaces this top part where you write your checks as Scribble properties. And then all that's left is to do to find the edge cases.
00:08:36.610 - 00:09:28.260, Speaker B: And we've replaced that with Fuzzing, which will automatically try different things. So Fuzzing will automatically come up with all these inputs like one and two, eight and 30 and one. And in the end you get this comprehensive and extensive test suite. All right, so that's really the summary of the whole tool. And now I'm going to go into my IDE and show you how everything works or how you can go about Scribbling. If you want to follow along, there is essentially two tools that you need to install. And I'll show you the command for that in my terminal right now.
00:09:28.260 - 00:10:16.450, Speaker B: So sharing my IDE now and you are going to need the Scribble tool installed, that's the main one. So you can install that using NPM like this. It's really easy. That's all you'll need to follow along. There's a second thing. There's an extension for Vs code called Vs code cribble, which adds syntax highlighting, which makes life a lot easier. All right, but let me jump into this first example and I'll share the links for these after the presentation.
00:10:16.450 - 00:11:21.990, Speaker B: So here I have a smart contract, a vulnerable token that implements the ERC 20 interface. In specific, there's a bug in the transfer function which allows you to create tokens by sending tokens to yourself. What happens if you send tokens to yourself is that you compute your balance after subtracting the value that you're trying to send. You compute your balance adding the value you're trying to send, but you're using the balance from before the transaction. So without the removed value and then you're writing it. So essentially this will be moved and not used and you end up with this code which will create tokens. And there's various properties about this smart contract system that if we would define and test them, that would catch this bug.
00:11:21.990 - 00:12:08.534, Speaker B: The first one is one that I'm going to describe about the whole contract, which is usually called an invariant. So you can write those like this. And the invariant that I'm thinking about is the one that says that the total supply must be in sync with the balances mapping. And you can write that like this. We take the unchecked sum. This removes overflow checks which we won't need in this case of the balances mapping. This is the values and say that it must be equal to the total supply and that's it, this will catch the bug already.
00:12:08.534 - 00:13:16.970, Speaker B: But there's a lot more things that we can do. We can also define an if succeed statement. This is kind of like an invariant, but instead of stating something generically that must hold all the time, we say something about how things are allowed to change. So what we can say here is we can say that the old total supply is equal to the new total supply. And you can see I used a non solidity feature here, namely the old keyword. And what happens is what I'm essentially saying here is that I'm taking the value of the total supply variable at the beginning of a transaction and comparing it to the value of the same variable at the end. In summary, this properties essentially says that the total supply won't change, which means that this token isn't deflationary or inflationary, it's the constant supply.
00:13:16.970 - 00:14:09.340, Speaker B: So that's an interesting one. Now we can dive into the different functions like lower level elements of the code and describe properties about that, that are more fine grained and describe something about the particular behavior of that function. So for example, here, let's dive into the transfer function. We want to say something about successful termination. We want to describe what should happen if the function actually succeeds. And in particular if I want to probably say that if I send ten tokens to you or any amount of tokens to you, that you receive that amount of tokens. So let's write that down.
00:14:09.340 - 00:15:41.338, Speaker B: If I send tokens to someone who's not myself, then I'm using an implication here. Again, this is a feature that we added to make property writing easier and more expressive. Then I want to check that the old balance that I had, which we can query like this. And here again, we use the old keyword minus the value, which is an argument to the function, is equal to the balance I have after executing this function. And we can do something similar here for the recipient. So what we can say is the old balance of the recipient plus the value is equal to the balance afterwards. Let's see, we could also say something like this function can only succeed if the old balance of myself is larger than the amount, right? This kind of duplicate or larger than or equal to this duplicates, this check.
00:15:41.338 - 00:17:22.060, Speaker B: But it makes sense to write the property anyway, because this way we get to essentially double check our work and make sure that the code underlying is actually testing this property. Let's write one more property here which says something about the case, the error case that I was just describing about when you send tokens to yourself. So if that's the case, if the sender is the two address, then I want to say that the balance before is equal to the balance afterwards, right? And now if we check these properties, we expect this to fail, but we also expect this property to fill. And I'm actually not in the right directory here, so let me go into Scribble exercise one. Now I can use the Scribble command line interface to take these properties and translate them into code that checks it. So let me do that real quick. You can do that by running this command arm files, contracts and then our vulnerable ERC 20.
00:17:22.060 - 00:18:17.252, Speaker B: Now it will find that I had a typo and there's actually multiple typos. So I usually make small mistakes like this when I do a demo, which is great to highlight the error reporting that tool has. And you can see here how you get a neat little error description that describe that balance doesn't exist. And I know it doesn't exist because it's actually called balances. Let's try that again. Where I forgot it somewhere all over here, fixed. Let's see.
00:18:17.252 - 00:19:14.580, Speaker B: What am I? Yeah, it's not called amount, it's called value. So you get this iterative approach to fixing your bug, similar to how you would maybe write some invalid solidity syntax, run the compiler and it will tell you how to fix things. And now if we dive into our property, we see, or our code, we see that a lot has changed, it's not really readable anymore. And this is also not our purpose, but I'm showing it right now so that you can see what the actual instrumentation looks like. So there's a lot of code added that will check our properties. So for example, here you see that we measure the value of total supply. Then we call into the original allowance function.
00:19:14.580 - 00:20:13.400, Speaker B: And then here's a check with a total supply value and we're comparing it to the total supply after the call. So this is our if succeeds property that ensures that the token isn't deflationary or inflationary. Let's see, there is also a call to check state invariance and if we go over there, we see here that we're comparing this value called underscore balances sum to the total supply. This is our invariant that would be violated if we exploit the bug that's in the transfer function. And this is really all there is to it. Now, you can see that we add two statements here. One is an emission of a log event and one is an assertion.
00:20:13.400 - 00:22:07.794, Speaker B: The log event here is used by our tooling in the back end to figure out which assertion failure matches with which property. And this is to improve reporting to you so that it's easy to figure out what properties are correct and which aren't. But there's also an assert false here and we added this because it's pretty much universal. All your unit tests will fail if they trigger a property violation which raises an assert false. Which means that if you now have a test suite, and I believe we actually do, let me see if we have a test suite and we run it, then it will encounter this problem, which triggers the property failure, which triggers the assert, and the test will fail. So if I clean up and quickly compile everything, I think this will actually not work because I made a mistake in this property truffle test. We see here that a property was violated, which caused the whole test suite to fill, which is great.
00:22:07.794 - 00:23:04.262, Speaker B: I would usually recommend, though, to use something like Fuzzing, because Fuzzing is great as it finds all these little edge cases on its own without requiring you to provide them. So I actually ran a Fuzzing campaign on a smart contract such as this with instrumentation just last week. And I'll walk you guys through that. Yes. So there's a lot of data here, and I realized that I should have done the easy mode that doesn't overload you right away and just has the necessary data. So there's a few fields here. We have test cases per second.
00:23:04.262 - 00:23:55.602, Speaker B: This gives you kind of the speed of the Fuzzer. In this case, it's zero because the Fuzzer stopped. We have the total code coverage achieved during Fuzzing. We have the amount of time that we Fuzzed. We have a neat little metric here that describes the chance that we missed something, or it really describes the chance that we'll find something else, like more coverage in the next hour or so. And we see that there's some errors that the buzer found, and we can go into the code and actually look at those properties or those errors that got raised and see what's up. So we have a property here that checks whether the balance sum is equal to the total supply.
00:23:55.602 - 00:24:53.580, Speaker B: And so, if you remember, this is kind of like the invariant that we wrote. There's also a nice window here that gives you the counterexample that the Fuzzer used to figure out that this property is actually not valid or that it's violated. This is a test case, essentially, that exploits the smart contract. And here, if we inspect the trace, it's folding for some reason. All right, you can see that the origin this is a little bit this never happened to me before. The origin here is the same address that we're sending to. So the Fuzzer found a trace where it from its own account called Transfer to transfer tokens to itself.
00:24:53.580 - 00:25:52.700, Speaker B: And it will mint this amount of tokens essentially to their own address, which raises the problem, raises the emission and triggers the alert. In this framework that we have on the left here, you have a bunch of green bars, and these are exactly what you expect them to be. These indicate the coverage that the Fuzzer was able to achieve. So we see here that we were able to cover all the transfer function except for this little bit, which makes sense. This is what would be covered if the property is violated, which we can see here. But since this property is valid, the property that's being checked here, this code is unreachable and we don't expect there to be coverage here. That's also one of the reasons why we won't reach 100% coverage here.
00:25:52.700 - 00:27:17.590, Speaker B: All right, so that is really the basic workflow that we have when Fuzzing or when doing property based testing. We first write scribble properties, then we take the Smart Contract and instrument it and give that to a diffuzzer to automatically try tons of input and to be sure that the code is doing what it's supposed to be doing. Now, I have a few examples set up that kind of show you how you could use this if you were working or interfacing with a Smart Contract or with a uniswap Smart Contract. And I am using uniswap V Two for a lot of these examples because it's just a little bit easier to reason about in the amount of time that we have. Right, so let me open up this again and yes, so I didn't really bother with the implementation of the function. This is just to highlight the idea. So here we have a contract that has some functions that this should be payable.
00:27:17.590 - 00:28:18.140, Speaker B: It has a function where you send ETH into it, you give it an amount and a token and you have it take care of the rest. In this case, I'm expecting this function to call into a uniswap pair to make the trades. Maybe it has some custom routing implementation, I don't know. But from the perspective of the property, I also don't really care because all I want to check is that the effect that I want there to be is actually taking place. So the first thing, like the effect that I want this function to implement is that after the transaction I get amount more of tokens. So I can write that in this property here, which says old. So we take the value of this expression at the beginning of the transaction of the balance of return value.
00:28:18.140 - 00:29:02.680, Speaker B: We add amount to it and we say that the new value must be higher. So this is kind of like a slippage check. The second property says that we don't leave ETH in this contract accidentally, which you want to make sure because otherwise it might get stuck. And now we can instrument this and run our Fuzzing. And what's great about this is that this property doesn't need to concern itself about how the function works and what the underlying logic is. It just needs to say what the function is supposed to be doing in the end. So you get to reason on this simpler, higher level.
00:29:02.680 - 00:30:18.338, Speaker B: Another example is this where we have a contract which has some liquidation function. So people have positions. I've used this amount value to indicate the size of their position and they have their position in a particular token. Usually you have some way of liquidating positions when maybe for example, the price goes out of a particular range but you want to make sure that you get enough back when you liquidate such a position. So here what I'm doing in this property is saying that if the liquidate position function succeeds, so if it runs successfully, then I get at least this amount back, this amount of tokens back. So first I compute the size of the position. I assume there's some oracle price that gives me the value of that position and then I say I want 95% of that back.
00:30:18.338 - 00:31:24.440, Speaker B: And then we have this second line which then describes, well, I take my balance before at the minimum amount that I want back and I say well after the function my balance is bigger than that. So here we make sure that we get at least $0.95 on the dollar back. A third example which applies more to unison v three is when you want to do some metric math and you want to make sure that it does what it's supposed to be doing. And I am saying it applies more to unisoft v three because there is a little bit more math going in there. And here I took a function without implementation. Again, that's also in the Uniswap code base, which I believe in the bitmath library which takes a input and returns the most significant bit.
00:31:24.440 - 00:32:56.020, Speaker B: And now there's these properties that the Uniswap guys are testing themselves but that you also want to be sure that your custom implementation of that logic satisfies. So in this case, there's these two very complex statements that I took from the code base from Uniswap which says that this must be true and I encoded them as properties. So we can then instrument this, give it to the fuzzer and let the fuzzer figure out whether the code actually implements these or has an implementation that satisfies these property or whether it doesn't. And let me go back in because I have one more example that I want to show and that is something that really only is super specific to uniswap v two where if you remember the way that you used to do a swap is you transferred tokens into the contract and then called the swap function separately. So you could even do three transfers into a pair and then call the swap function or do it all at once. It was up to you. But a key thing that you want to make sure of is that you don't leave any tokens in the pair after you're done.
00:32:56.020 - 00:33:55.398, Speaker B: So that's what this property checks. It checks that after this function succeeds or if the function succeeds, then the reserves, so this is the internal bookkeeping of the pair, are equal to the actual balances of the tokens that the pair holds. So now again, regardless of the super complex implementation that you might have that performs several trades, maybe it does routing, maybe it goes to multiple exchanges it doesn't really matter. We just want to say that at least this property holds, which says that the pairs doesn't have any extraneous amounts left after we're done. And then we can trust the fuzzer to check that this is actually the case. Awesome. All right, we have a bit more time.
00:33:55.398 - 00:34:46.310, Speaker B: So there's one more property type that I want to show, which is in here. So, in all of the examples before, I've kind of highlighted a few different types of properties. We had invariant and global if succeeds, which describes something about the whole smart contract. And we had these if succeed statements which describe what a function is supposed to be doing. There's a third type which is called if updated. And this is a great type of property when you want to say something about how a variable is allowed to be changed. So maybe you want to say something like this variable is only increasing.
00:34:46.310 - 00:36:21.922, Speaker B: In this case, we want to say something about access control. In specific, we have an ownable contract where we want to make sure that it's really only the owner that's allowed to update the owner variable. So we say that if the owner is updated, then the owner, well before the update must be equal to the sender of that transaction. Or and this allows the constructor to write to it the message signature is zero. And this is only the case whenever you are running the constructor which doesn't have a message signature or it has a zero message signature. And if we now go into this exercise and run Scribble unownable, you can see how Scrobble went into the code, looked for the place where we're updating the owner variable, we record it, and we add a check that makes sure that well, in fact, the message sender before is the one that's sending this transaction and performing the update. And the great thing about this is that it works with inheritance.
00:36:21.922 - 00:38:01.800, Speaker B: So if you have this contract, this ownerable contract, and you inherit it, and it has this property in there and you instrument or run Scribble on this higher level contract, it will take this property into account and add checks wherever your higher level contract writes to the owner variable. And this ensures that even if your higher level implementation which inherits from this, even if that violates this property, will know because this check got added. All right? So really, the way that you can get started easily with scribble is, well, first of all, you install the tool and the plugin, but then you write just one or two properties to see if you can get a feel for what kind of properties are true for your smart contract and how you can write these properties. And then what you do is you just run this instrumentation and then you run your unit test suite, which will cover various edge cases throughout your program or smart contracts. And maybe already trigger something and it might find bugs already. That's the first step. The second step would be to go into fuzzing a little bit more.
00:38:01.800 - 00:39:12.646, Speaker B: So there's the Diligence Fuzzing platform, which I really like, but I'm biased, of course, but there's other tools as well. And go and try one of these tools. Reach out to us. For example, I'd love to set up a trial fuzzing campaign. If you set up a few properties yourself, and then you get this tool that will automatically try and figure out whether any of your properties can be violated and you can fix those problems. The next level, or the final level, really, is to set this up in continuous integration to make sure that you're always checking and always fuzzing and always making sure that the code that you have deployed or that you have in your repository is all doing what it's supposed to be doing. You can think of it essentially as running your unit test suite, but much, much stronger.
00:39:12.646 - 00:39:50.582, Speaker B: Like a unit test suite with millions of test cases. All right, so that kind of summarizes or that's kind of the body of the workshop. Let me share this slide for a second with that. I'd like to open it up for questions. Well, first of all, thanks everyone for hanging out here. You can find us on the Internet, consensus audits on Twitter. We also have a nice website.
00:39:50.582 - 00:40:56.080, Speaker B: We have tons of articles explaining how you can go about scribbling, how you can do fuzzing, how you can think about properties. And we have lots of great resources there, so I really recommend checking that so we have some time for questions now. I'm also going to be in the discord, and you can also reach out to me anywhere, maybe Twitter. I'm happy to help with anything scribble and any scribble related questions. All right, so now I have time for questions. Let's see if there are any in the chat. The workshop was quite satisfying then, that it didn't raise any open questions or it answered any questions.
00:41:04.050 - 00:41:32.200, Speaker A: Feel free to unmute yourself to ask any questions as well. Great. I guess your workshop was so thorough, there are no questions. Well, we'll just end it off here then, unless you want you have anything else that you want to be presenting to everyone?
00:41:33.550 - 00:41:54.142, Speaker B: No. I guess if people just try this workshop exit themselves, they'll maybe run into some questions. And so, yeah, the invitation stands as me, and I'll try to help you as best I can. Awesome.
00:41:54.276 - 00:42:07.200, Speaker A: Well, thank you so much for joining us today, Yarn. And thank you for such a great presentation. And for the rest of you, feel free to connect with Yaron on Discord. Have a great rest of your day, everyone.
00:42:09.010 - 00:42:09.940, Speaker B: Thank you. Price.
