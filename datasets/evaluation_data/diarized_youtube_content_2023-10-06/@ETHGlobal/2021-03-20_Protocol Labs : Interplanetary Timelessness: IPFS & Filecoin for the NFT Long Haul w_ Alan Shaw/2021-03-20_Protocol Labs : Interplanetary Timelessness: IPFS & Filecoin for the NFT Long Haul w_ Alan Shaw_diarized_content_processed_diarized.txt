00:00:00.250 - 00:00:26.920, Speaker A: Great. Cool. Thanks for your patience, everyone, and thanks for joining us on Saturday for this session. Alan from Protocol Labs has joined us today to introduce the interplanetary timelessness IPFS and filecoin for the NFT long haul. And, yeah, I'm going to pass it over to Alan to introduce himself and, yeah, get the session started.
00:00:29.850 - 00:01:01.342, Speaker B: Okay. Hello, everyone. Let me just share the hi. Okay, so I am Alan, as you just learned. This is IPFS and filecoin for the NFT long haul. I'm an engineer at Labs, and I'm pretty new to NFTs, as I guess we kind of all are, really. But when I found out about them and I started getting interested, I was super stoked to see that IPFS was being used to store loads of them.
00:01:01.342 - 00:01:37.820, Speaker B: So, for example, if I just head on over to this NFT site here, and I look at pretty much any NFT, I can do a little bit of spelunking in the ethereum blockchain like this. There we go. Head on over to the contract, query it, and look, it's an IPFS hash. Wow, that's awesome. So I can just bring that up and then that's cool. That's super rad. That's really awesome.
00:01:37.820 - 00:02:32.702, Speaker B: So I was super excited to see that. And yeah, very happy. So as I was learning about NFTs, I kind of came to realize or we talked to a few different NFT application builders and things, but I came to realize that the developers that are actually enabling NFT creators so, like, apps, like foundation, like Super Rare, like Zora, they really cared about users being able to access their data. Like, if they were ever to just disappear from the planet. So if they were to go away, they don't want all of that stuff to go away because it's important. It's NFTs, it's things that people have bought, and they don't want that data to just disappear. So IPFS really fits this bill and can solve that particular problem.
00:02:32.702 - 00:03:20.746, Speaker B: So it's not really surprising that it's being used. But in case you're new to IPFS, let me just explain, okay? I chose this particular NFT at complete random. I think it's a picture of some mountains or something generated. But if you put some data on an IPFS node, first of all you get a CID, a content Identifier, and that's that Basque string there, and that's a hash of the content. And content, when you put it in IPFS, is Immutable, so it can never be changed. So that CID will always refer to that content. So that's super useful if you're going to put that data on a blockchain, because it means that when you next request that cod, you're kind of guaranteed that the content is exactly what was put there by the creator.
00:03:20.746 - 00:04:08.106, Speaker B: So that's really good. As opposed to, like, a URL where things happen with URLs, like domains expire, people update content behind the URL to be something different. So you might have a picture of a cat and it might become a picture of a dog later. People might have like a Google Drive that they've set up and they're paying for and they don't pay for it anymore, and then the link goes dead. So then you have to get that updated somehow. And you don't have to worry about that with CIDs because they are addressing content, they're not addressing a location on the internet. That's, that how does that work? Well, if someone else requests that data, so they ask for that particular CID, then they'll receive it.
00:04:08.106 - 00:04:42.198, Speaker B: And now two nodes on the IPFS network can serve that particular content and that's super cool. So it would happen like this, someone else comes along and it requests that CID and then both of those nodes are able to process that request. So that's cool. So it gets it as well. And so the awesome thing about this is that this original node that had the content, it can go away, it can just leave the network and it's gone. And data will still be retrievable from the other two nodes. So someone else new comes along and they are asking for the same CID, other people still have it.
00:04:42.198 - 00:05:25.910, Speaker B: So that is awesome. There's two caveats to that caveat. Number one is if all of the nodes that have that content go away, then that content will no longer be available on the network. So people come and go. If it's a node running on a laptop, then that laptop could be closed, people could leave the coffee shop, go home, and then reopen that laptop later. But the interim period between leaving the coffee shop and coming home, if no one else on the network has that content and someone else wants it, then they're not going to be able to retrieve it. So that's how IPFS goes in that respect.
00:05:25.910 - 00:06:13.662, Speaker B: And so the second caveat is garbage collection. And so depending on your garbage collection configuration, that might run on an ITFs node at like a particular time when your configured repo storage limit is hit. So if you retrieve or put too much stuff in it and it reaches that limit, then it will start to garbage collect and reclaim that space. Or it can be run manually. So you can run it from the command line or you can run it, it's like an API call as well if you want. So really you need to tell IPFS that the content you have is not actually garbage. So the idea that this super rare NFT is not trash, it should be kept.
00:06:13.662 - 00:07:11.378, Speaker B: And so in IPFS that's referred to as pinning, which is kind of a weird thing to kind of come across and understand if you're new to IPFS. But that's what we've got. So that's what we have. And if you don't pin the data, then it will eventually be garbage collected. So it means that even if content is super popular on the network, loads of nodes have it, then it can still eventually leave the network if all of those nodes happen to garbage collect or leave the network. So there's this permanence problem that we have. And so these two caveats are why developers generally use a kind of third party storage like Pinata, like textile, like fleek to store their content, because they deal with these two caveats by having nodes that stay online, and they also pin content so that it doesn't get garbage collected from their nodes.
00:07:11.378 - 00:07:35.690, Speaker B: So they deal with that for you. There's always going to be a node, or at least one node with that content. So there we go. So, NFT Storage, so this is a new thing. It's a kind of private beta. It's a present to all of you NFT hack participants. And it's a place where you can store your NFT data safe in the knowledge that it'll be there tomorrow.
00:07:35.690 - 00:08:14.886, Speaker B: And it hopefully goes some way to addressing that permanence problem. And so, yes, it's free and for some gigabytes as long as we can keep it. And the whole idea about this is it should be easy. We have a kind of simple JS API client. We have a simple http API We've got API schema that you could generate clients from potentially, so we're not restricted to JS. We could use it in other languages as well. And eventually we're hoping to maybe add remote pinning service API.
00:08:14.886 - 00:08:57.238, Speaker B: If you're familiar with IPFS, you might be familiar with that as well, so that you can use it. If you're using IPFS in your apps, then you will be able to put stuff in IPFS and have it sent to NFT Storage without using A. So there we go. So how does NFT storage work? Well, you upload your NFT data to NFT Storage like that, and NFT Storage will store that data on IPFS nodes that it knows about, and it will obviously pin them there so it stays available. And these nodes are publicly available nodes data is pinned, so it won't be garbage collected. Yada, yada, yada. Okay, so far so good.
00:08:57.238 - 00:09:42.200, Speaker B: But what is different from your kind of regular pinging service like Pinata? Well, behind the scenes, NFT Storage is negotiating deals to store your data with miners on the filecoin network. And the filecoin network incentivizes miners to store data, and they get paid to store data, and they also typically get paid when data is retrieved as well. So ideally, this is kind of a really profitable experience for them. So they have strong incentives to store data and continue storing data as well. If they fail to continue to store data, then there's heavy penalties. So they're really incentivized to not lose the data. So that's file calling.
00:09:42.200 - 00:10:36.360, Speaker B: But why is that good? Well, if NST Storage goes away and every IPFS peer who ever fetched the content went away, then these miners will still have the content. And so you can think of miners as just another set of peers with really strong incentives to continue storing the data, addressing this whole permanent problem and the fact that we don't want this expensive NFT thing that I bought to just disappear forever, which would suck. So this is NFT storage. All right, now let's do some demoing. Here comes some live coding. I'm going to stop my share here and try and share my whole screen instead of just one, just one thing. Here we go.
00:10:36.360 - 00:11:08.740, Speaker B: Okay, let's go over here. I need a new terminal window. So this is a demo of the JS client for you guys. Just going to create a directory. I'm going to call it X, for example. And the first thing we need to do is do a I'm just going to NPM in it in here? Yes, looks good. Okay, let's open this up in code.
00:11:08.740 - 00:11:49.434, Speaker B: Whoops. No, go away. Just one. What's happened there? Oh, I'm already in that directory. Okay, here we go. Okay, so first up, I'm going to show the NFT storage client and we're going to try just running it in node JS and we're going to try and upload some content to NFT Storage. And then we'll have a look and inspect it on IPFS.
00:11:49.434 - 00:12:16.322, Speaker B: So let's quickly do that. So I need to install the client. Is that big enough for everyone? Storage? Here it comes. Create a new file. I'm kind of showing you this because it should be really easy. It is pretty easy to do. I'm just going to import the NFT storage.
00:12:16.322 - 00:12:51.902, Speaker B: So this is a class from the NFT storage package that I just installed. One thing I need to do is just tell node that this is an Es modules project module. There we go. I'm just going to create a function, a main function, and we'll just call that immediately. But in here, what we're going to do is create a new instance of the client. There we go. And all I need to do is provide it with a token.
00:12:51.902 - 00:13:21.606, Speaker B: So this is an API key that we get from the website. So what I'm going to do is head on over to the browser. Here we go. Let's just close up these other windows. So this is the website, but once you've logged in I'm already logged in. You should see a manage API keys and files here in my API keys. I have no API keys.
00:13:21.606 - 00:13:38.100, Speaker B: I'm going to create a new one quickly. I'm going to call this X so it matches up with my example. Here we go. So what I'll do is after this demo, I'm going to delete this key. So don't even try to steal it. But you know what? It's free. So you can create your own account anyway, so you don't even need to steal it.
00:13:38.100 - 00:14:15.680, Speaker B: So I've got my API key. What I do is I just head back over to my project and add that in there. There we are. And to store data on NFT storage, we need some content first, don't we? So let's create some content. I'm just going to put if this will work. Sometimes my Emoji keyboard doesn't appear, which is really annoying. And so I'm going to use a okay, Star Eyes emoji because this is going to be super rad.
00:14:15.680 - 00:14:58.438, Speaker B: And so what we do is we use the client store blob method. Oh, one thing I didn't say is that this module also exports Blob for use in node JS because it doesn't support it natively. So we'll import that here and we've got our content. And if I want to store a Blob, then I just need to give it a Blob. So this is how you create a Blob from a string. And what that does is that will store the blob and it will give me back a CID, a content Identifier for that content. So I need to await this because it's an async thing, and all I do is I will log out that CID.
00:14:58.438 - 00:16:08.062, Speaker B: But what I'm going to do is actually I'm going to put in a gateway URL here, so I can just click on this from the console and see it in the browser. There we go. So, gateways protocol run a couple of IPFS gateways. IPFS gateways are for extracting data out of the IPFS network from the old world. And to IPFS the old world is the current internet that you use, the HTP internet that you are using every day. And so these gateways allow you access to the peer to peer IPFS world via a particular centralized point, which is not great for the decentralized future that we live in, but in terms of seeing things in browsers, this is super useful. So this is one of many public IPFS gateways, and any public IPFS gateway that is providing access to the IPFS network, you should be able to use any one of them to extract the CID.
00:16:08.062 - 00:16:34.166, Speaker B: So there's no need to tie it to a particular gateway necessarily because you should be able to access it from any of them. And so if I have a look over here, there's a list of public IPFS. Oh yeah, gateway checker. That's it. Glad that came up. I completely forgotten the URL. This is a list of loads of different IPFS gateways that exist.
00:16:34.166 - 00:17:17.494, Speaker B: It's just doing some status checks on them to show you. But there's the DWeb link one and the IPFS IO one, which is so these are the ones that PL run. There's like a cloudflare one, I think somewhere there's a pinata one there. There's lots of public gateways that you could use and they all provide access to the IPFS network. All right, enough talking, let's run the code. So if I've written this right, then I should be able to just node index. I need to save it first, of course.
00:17:17.494 - 00:17:41.566, Speaker B: Hooray. All right. And then, so I get this link. So it's given me back a CID for the content that I stored. I should be able to click on this link and then that should load up the so this has retrieved that data from the what's going on here? Yeah, this has retrieved the data from cool. I've changed my search engine somehow. Okay, never mind, it's fine.
00:17:41.566 - 00:17:58.566, Speaker B: And we can see the emoji. Let's make it bigger. Hooray. We've got star eyes. Awesome. Yeah, it should be super easy. And the other or cool thing about this, about this client is that you can use it in the browser as well.
00:17:58.566 - 00:18:45.058, Speaker B: So if I create an index HTML file, give it a doc type so we don't get any quirks modes or anything like that, I'm going to use a module script. I should just be able to copy and paste this code directly in the browser. Sorry. In this HTML file we don't need blob because browsers have blob already. What we can't do is use NPM modules, but we can use like a CDN that provides access to Http because I'm typing HTP to access to NPM modules. So we can use, for instance, Skypack dev NFT storage. Cool.
00:18:45.058 - 00:19:22.478, Speaker B: And really that should be all I need to do. Let's try and open it in the default browser. I should see nothing in the browser, but if I open up the console, then I should see this link link logged out. And this is the same as before. So let's just to prove that this kind of is working, let's use never works when I need it to. I'm going to use a sun. Use a sun instead because where's my thing gone? Here we go.
00:19:22.478 - 00:19:37.240, Speaker B: So let's try again. Here we go. Okay, so this is a different CID. When I click on it, the gateway should load it up and there's a sun. Hooray. Okay, sunshine. Okay, cool.
00:19:37.240 - 00:20:16.126, Speaker B: What else can we do? We can store multiple files. So this is called like store directory. And so I'm going to get rid of this store directory here. I'm going to get rid of the blob. I'm just going to put that down there, store directory. And we'll add a file input here, multiple attribute. Because we're going to select multiple files, we need a button upload, do the upload.
00:20:16.126 - 00:21:07.200, Speaker B: And instead of a main function here, what we're going to have is a query selector. We're going to get hold of the button and when it's clicked, what we're going to do click async you get an event and then stuff goes in here. We don't need that anymore. So when the button is clicked, what we're going to do is, first of all, let's make this a bit bigger. First of all, we're going to get hold of the file input. So equals input. Sorry.
00:21:07.200 - 00:21:38.620, Speaker B: Cool. So the file input has a files property. This is a file list. The store directory API call takes an iterable of files. So you can pass it like an array file list, is iterable? There are files in it. So we're just going to take whatever files that we've selected here, store them in a directory, we're going to log out the CID. So let's try it out.
00:21:38.620 - 00:22:06.846, Speaker B: Okay, so this is my GIF folder, where I keep all of my awesome gifs. I'm going to use this room guardian. And hello, this is Dog. Picture here. Upload those two, I should see nothing here, but in my console I should see a new CD. If I click on this, then when IPFS loads it at the gateway, we've got a directory. This is a directory listing that IPFS is generating for us.
00:22:06.846 - 00:22:45.682, Speaker B: And it has these two pictures in it. So, hello, yes, this is Dog. We've got these two pictures. And this is really useful even if you've got just one file that you want to upload to, put it in a directory because you then retain the file name in the URL. And that's useful for when people want to right click and save image as because they get a file name with the extension, then their computer can open that particular file with the correct application, et cetera, et cetera. So, yeah, that's super useful. Okay, there we are.
00:22:45.682 - 00:23:34.126, Speaker B: So what else would we want to do? Well, we might want to get the status of our particular CID so we can use the pass. It the CID. Wait, I've realized I'm just writing this completely backwards and I wouldn't normally write code like that, but we use the client status. It's just because of the way I'm explaining it. We're going to log it out as well. We might want to query the status of a CID because we want to inspect how big that file is. It tells us the size of all of the files that we've uploaded, but it also tells us information about the deals that are being made in filecoin.
00:23:34.126 - 00:24:30.446, Speaker B: So we can have a look and see if anyone, any filecoin miners are currently storing our CID. But it also has information about the pinned status, which means that has it been pinned on IPFS nodes yet? And for all of all uploads? It should already have. When we implement the remote pinning service API, then it's Async. So you'll submit something and then later it will be pinned and you'd want to check the status in that case. So let's just have a look, see how that works. This one, have you seen the dog? That's a good one. One from the bottom, couple of uploads.
00:24:30.446 - 00:24:52.922, Speaker B: There we go. Let's have a look. Yeah, here we are. Okay, cool. So then we've just logged out the uploaded stuff, got a CID, we've got a created date, we've got the file sizes, size and bytes of all the stuff. We've got a pin object here, which is the interesting part. Here is the status pinned, which should be pinned for uploading using the client already.
00:24:52.922 - 00:25:17.362, Speaker B: So you don't really have to worry about that. This one deals. This is the filecoin deal status. And this will take a while because making deals with filecoin minus takes a while. They have to receive the data. They have to then do a process called sealing, then record it on chain. So it takes a little bit of time, but also it will take a bit of time because what we're doing behind the scenes is batching up data.
00:25:17.362 - 00:26:07.618, Speaker B: And when we've got enough, that's when we submit a deal to filecoin miners. And there might be more than one deal that we try and make so that we have it on multiple miners, but also because we've got some experimental code, we're running some experiments behind the scenes for fun, but also for research. And so there might be deals made with miners that are running on testnets, which is super cool. So let's have a quick look at what you might expect to see if I just open up this sample JSON that I prepared earlier. Where are we? Did it open up anywhere? Oh, cool. Xcode? No, thank you. Let's just open that with something that might not take a year to load up.
00:26:07.618 - 00:26:54.186, Speaker B: Okay, so it's going to be an array of deals and the order of the array is important. They are the most recent ones. The order is the order in which they were created. So this is one that has literally just been created and it's queued, it's getting ready to be put into a deal for a miner that is being batched together. And so this batch root CID, like I said, we're batching all these together and then that will become its own Dag and it will have a CID associated as well. What else we got here? So we've got minor. This is the address, the address of Minor.
00:26:54.186 - 00:27:16.374, Speaker B: Here we've got, like I said, this is not main net. Like this one just below, this is Nerpet net. So this is a testnet and this is why the address begins with T and not F because it's test PCID here for this one. So this one status. The status is the interesting stuff. This is being proposed. This is like being batched together and we're talking to the miner about a deal.
00:27:16.374 - 00:27:39.818, Speaker B: We're negotiating it right now. PCID is. So this is when data has been uploaded. There's this process that miners go through called ceiling. And the data becomes a piece, which is a car. It's not a motorized vehicle. It is a content archive and that's what gets stored.
00:27:39.818 - 00:28:05.782, Speaker B: So this is the CID of that piece. This one. The deal has been accepted. So we are uploading data. It is being sealed and it hasn't yet been recorded on chain. This last one has failed. So this is like in between being active and accepted, it could fail for whatever reason.
00:28:05.782 - 00:28:35.602, Speaker B: So there we go. We've got another one here which is active. So this is one that has succeeded and finished. This is the ID of the deal which has been recorded on chain, the deal activation. So this is actually an epoch, but it's been transformed into a date time. You can obviously anyway, deal expiration is when that deal will end. And obviously last change, I don't know if I talked about that, but that's just a date stamp of when things last change.
00:28:35.602 - 00:29:11.422, Speaker B: The miner, the network, the piece and the status. So that's deals in the response for NFT Storage. And I think that's all I needed to cover with you all. Yeah. Go and check out NFT Storage. If you are minting NFTs in your hacks, then please feel free to make use of it. It will help us because actually, like I alluded to, there are experiments going on.
00:29:11.422 - 00:30:04.334, Speaker B: It's helping us realize what kind of deal flows look like and how we can streamline them and make it better for the NFT community. So we're trying to figure that stuff out. We're also trying to figure out the stories of how to retrieve from filecoin, how to retrieve data from filecoin via IPFS and things like that. So if you use this service, then you're really helping us to make IPFS and Filecoin a lot better in the future. But also in particular for NFT community and the types of data that are being stored here, the metadata, the storage size and all things like that are good information that we can use going forward. So thank you very much for listening and go and use NFT Storage. Go and have fun.
00:30:04.334 - 00:30:15.570, Speaker B: Let me know what you think. I'll be hanging out in the Desert sponsored Protocol Labs channel. So if you have any problems or whatever, thanks for listening.
00:30:17.910 - 00:30:38.230, Speaker A: Great. Thanks, Alan. Yeah, that was a really interesting session that you took us through. There's just two questions. One of them from YouTube, so I'll just read it out to you real quick, is I guess it is planned, but could you give us a hint on how it follows until it is sold in Zora?
00:30:41.870 - 00:30:43.180, Speaker B: Can you repeat that?
00:30:44.750 - 00:30:51.550, Speaker A: I guess it is planned, but could you give us a hint on how it follows until it is sold in Zora?
00:30:53.010 - 00:31:31.850, Speaker B: Okay. I'm not super familiar with the process of minting NFTs. I've read some tutorials and things like that, so I kind of get what's going on in general. Let me show you on the here we go, the NFT storage site. Let me share my screen again. Okay. We tried to put together can you see that? Did I do any sharing? No, I didn't.
00:31:31.850 - 00:31:33.306, Speaker B: Yeah, here we go.
00:31:33.328 - 00:31:34.090, Speaker A: You're sharing your screen.
00:31:34.160 - 00:32:37.642, Speaker B: Okay. We tried to put together like a kind of typical sort of flow thing where as someone who is minting NFTs in some way, this is kind of NFT. Storage is just a small part of that minting process where you've got this problem of like, I've got an NFT, like typically artwork or something that needs to be minted and it needs to be stored somewhere. Normally it's exorbitantly expensive to store data on chain, so there's this whole off chain storage and this is what NFT storage is trying to solve. And so you'd have your artwork, you need it stored somewhere. And this is where NFT storage comes in, is that you upload it here. And then when you get back the hash, that's the thing that you can use in your minting process that you will put in the data that will be stored on chain.
00:32:37.642 - 00:33:22.620, Speaker B: So exactly, there are ways and means of doing that and it really changes depending on provider, especially if you're doing your own hack where you're minting NFTs. It's kind of up to you how you want to store the data. There are certain standards that are not global at the moment, I think, for storing for metadata formats and things. But yeah, this is exactly how it works way. But this is a small part of it. You get your CID and then you can use that in your metadata in your Minted NFT that makes it on chain. Hopefully that answers it a little bit.
00:33:23.390 - 00:33:32.080, Speaker A: Cool. I think we've just got time for one more question and then we'll close up. And that is, is it possible to have the hash of what we store to?
00:33:35.110 - 00:34:19.600, Speaker B: So I guess a CID is essentially a hash. It's not quite the same as your usual hash because the CID from IPFS is a CID of the root of a tree. It's called a dag directed acyclic graph. And so the CID is the CID of a root node of a bigger tree. So it's not the hash of all of it, but it's as good as a hash. Yeah, I guess if you wanted a hash of the data, then you could do that yourself before you upload it to NFT storage, you can get the hash of that data because you'll have it already.
00:34:23.410 - 00:34:49.190, Speaker A: Cool, thanks. Thanks so much, Alan. That was a really great session and thanks for sharing some of your Saturday with us. There is one or two questions in the Zoom chat that I'm going to copy paste over into Protocol Labs channel. And yeah, Alan will answer those questions in the Discord channel. So just keep eyes there if your question hasn't been answered during the session. Yeah, cool.
00:34:49.190 - 00:34:54.020, Speaker A: Thanks Alan. Have a nice afternoon. Or morning everybody, and we'll see you.
