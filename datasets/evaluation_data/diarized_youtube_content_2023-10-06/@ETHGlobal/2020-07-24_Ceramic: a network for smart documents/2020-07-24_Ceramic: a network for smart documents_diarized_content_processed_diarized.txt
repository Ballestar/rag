00:00:03.370 - 00:00:22.290, Speaker A: Cool. Yeah, I see that tweet came through. Let me just repost it just to confirm. We're scheduled here for like an hour, right?
00:00:22.820 - 00:00:58.368, Speaker B: Yeah, I think we had scheduled an hour and a half, but if Andrew we're good, I'll kick it off and get going. All right, cool. So today is the last day of week three, which seems pretty crazy. It feels like we were just starting. It was only a few weeks ago, but it feels like it's been both a really long time and going faster than I expected, for sure. So the end of week three, we have one more event after this, which is the filecoin office hours. But this session is focused on learning about Ceramic and how you can specifically use it in your hack offs project.
00:00:58.368 - 00:01:19.160, Speaker B: So hopefully this is useful to the hackers that have shown up. And today we have Michael with us. He is a builder at Threebox, which works on user IDs and user data profiles, all sorts of things like that. He's going to walk us through what Ceramic is and some of its features.
00:01:20.540 - 00:01:21.000, Speaker A: Awesome.
00:01:21.070 - 00:01:21.924, Speaker B: Go ahead, Michael.
00:01:22.052 - 00:02:16.840, Speaker A: Yep, take it away. Cool. So we have an hour. I want to keep this pretty informal because it's more just about helping you grock what Ceramic is and answering any questions that might pop up. Ceramic is pretty new, so for some context, yeah, I've been working on three box for the last two plus years, and along the way, we've always had the goal of sort of creating a more general decentralized protocol for some of the things we were doing, and in the process created this new protocol called Ceramic. It's a protocol and decentralized network, and it's not currently in production. It's not live on main net yet, so it's still in an early alpha, which we're calling the slip DevNet.
00:02:16.840 - 00:03:15.230, Speaker A: But in a couple of weeks we'll be on the beta DevNet, which we're calling Clay. And so just for some context as to where things are in the development process, so you might have some questions about how do I do something or where is this library? And sometimes the answers might be it's being developed. But there are some hackers from hackfs already working on some cool things, some of the folks on the call now. And so I can also point to them to share the ways that they're using Ceramic because I think there are some really interesting use cases popping. So for the first bit of time, I'll just give a high level overview of what Ceramic is, how it works, some of the use cases and things people are building with it, and then it will just be open questions. So I'll go ahead and share my screen and you can see my ceramic GitHub. Right.
00:03:15.230 - 00:03:57.284, Speaker A: Let me move the participants. And it's kind of hard to see chat while this is going on. So how do I keep that open? Okay, great. So just to quickly orient you. The GitHub is GitHub.com Ceramicnetwork and Ceramic is a permissionless protocol for creating what we're calling smart documents. They're basically documents that are stored on IPFS but where they're linked append only logs where each update can be anchored on a blockchain.
00:03:57.284 - 00:05:43.992, Speaker A: So basically what you really have is the ability to create these mutable documents where you have guarantees about the order in which the updates occurred. And this has a lot of really interesting use cases ranging from decentralized identity to permissionless content publishing to publishing schemas and other metadata about resources that may live scattered across the web publishing verifiable claims any sort of information where you want it to be permissionless censorship resistant exist in a cross platform way and but be updatable. And so unlike some of the other platforms where they handle sort of decentralized file storage, either the raw file storage like Filecoin or Rweave or platforms like that ceramic sort of sits at a layer above those. And it provides the document structures, rules, state transition functions that enable you to make better use and interpret that content in certain ways. One unique property about Ceramic is that it completely uses DIDs. So decentralized Identifiers which means that a did is obviously the W three C standard for interoperable cross platform identities. But every bit of information published and authored and updated on Ceramic is signed and controlled by a did and DIDs can in turn be controlled by any number of wallet keys that may live on any network.
00:05:43.992 - 00:07:15.530, Speaker A: So really what you create is the system where content exists sort of on its own right cross platform and users can interact with the content that they own from any of the platforms or any of the wallets. So you can use a filecoin key, an Ethereum key, a bitcoin key, a Cosmos key, whatever times 1000 to control the same content. So the content you're publishing isn't locked into any particular key or platform which provides a lot of interesting use cases and properties for building more user centric applications and platforms where data is interoperable. And so to quickly scroll through, I mean, I've just covered some of this but in the GitHub repo if you go to Ceramic Network Ceramic, you'll just see a quick overview and this kind of points you to a lot of the resources that you might need to get started. Right here you'll see a Ceramic introduction which is a really detailed description of what the protocol does, both the needs for a system like this and how it works but I'll kind of jump into how it works quickly. Where are we here? Cool. So now what you're looking at is the Ceramic Network Specs repo and this kind of defines the rules of what the core protocol does.
00:07:15.530 - 00:09:06.030, Speaker A: And so, as I mentioned, really it enables you to create these tamper resistant but updatable documents owned by DIDs, not owned by any particular private key and the way that it works is basically each document consists of a series of what we're calling records and a record is just an object. And to quickly back up why would you use Ceramic versus using Filecoin directly or using IPFS directly or any other publishing platform directly? And that's because by sort of using Ceramic as a way to publish content to those platforms you get all the benefits of what smart documents can do which are version control, state management, blockchain anchoring and even the ability to do things like add logic to it. So you can say only mutate the state of a document to a new version if this thing happens, if this script executes and returns a property. So you can really start to program content in a way that you can't do if you were just using the file system directly itself. And so a document, as I said, is a series of records and each of these records is a state transition. So each document is effectively a mini doc chain where you can query a node and say what's the latest state of this document? And the node will fetch all the updates and construct the state transition logic and only return to you what the valid current state of the document is. And so each document begins with a Genesis record and that's like I said, an IPLD object.
00:09:06.030 - 00:10:15.108, Speaker A: It contains some header properties and I'll scroll down to that, it contains some header properties which are basically a set of owners. It could be one did or an array of DIDs. It has a schema which is optional but it basically defines the content in the documents. You can say I want to create a document and I want it to conform to this schema and that schema is also published as a ceramic document and you can also add tags to a document which enables others to make sense of that information. You can imagine publishing your app's name as a tag or the type of document that it is, which might use a generic schema for just like a string map, but you might say, I'm using this string map for this use. And so tags are really interesting. When index services such as the Graph or others begin to index content on ceramic, you can just search by tags and unique is a string that basically says this new document is unique because the doc ID.
00:10:15.108 - 00:11:03.584, Speaker A: So the persistent permalink for a document is how you identify it within the network and that permalink that ceramic ID is generated which is effectively just the CID of the Genesis content. So if you create a Genesis record that has the same header content and the same body content, you'll get the same CID. And so you can add an optional string which adds randomness to that which obviously will generate a new unique CID. And so that's the header metadata for the Genesis record. And then in the Genesis record. You specify which something I'll dive into which our doc type, the dock type it is and then any data. And that data is sort of defined by the doc type, which I can jump into.
00:11:03.584 - 00:11:50.604, Speaker A: So the Genesis record is really just the CID object that creates a new unique document and it's owned by set of DIDs. And then when you want to update the document, the owners. So if it's one owner, just that owner. If it's a set of owners, then all the owners but they sign this update record which is effectively just a JSON patch to the Genesis record. And then that update record, so called a signature record has to get anchored in a blockchain to be valid because you're saying the Genesis record is there. We're adding a signature record which mutates the state of a document. And in order for that to be finalized you submit it for anchoring on a blockchain which gets appended as Anchor record and that creates a version.
00:11:50.604 - 00:12:42.610, Speaker A: So now once you have Anchor record there's an explicit version of a document. So let's say that's version now two, and then you make another update as a signature record and that gets submitted to a blockchain for anchoring. Then you have version three. And so you can refer to documents just by their doc ID, which is the CID of the Genesis record, which will always return from the protocol the current state of the document. Or you can specify explicit version. So I want to query ceramic, bafy whatever query parameter the version and then the protocol will only return to that explicit version of the document. And again, there's a lot of nuance into what content could be stored in documents and how these state transition mutations are enforced by the protocol, which I can jump into next.
00:12:42.610 - 00:13:35.764, Speaker A: But I see a question came in, so I'll pause there for a second. How does ceramic differ from three box spaces? Is one more ideal for certain use cases than others? Or is spaces using ceramic? Good question. So we're in the process of reorganizing information in some of these repos to make that more transparent. But spaces and three box broadly are not dependent on ceramic at all. So they're kind of two separate concepts. Ceramic is this protocol for dynamic information management on the decentralized web and threebox will use some of the things and standards built on ceramic to do the identity management piece internal to it. But threebox will really be used to let people create orbitdb instances that are managed and have a simple interface to do that.
00:13:35.764 - 00:14:16.044, Speaker A: But Ceramic is kind of separate. So ceramic has its own set of use cases, its own set of design that is in no way dependent on threebox. Hopefully that makes sense. There's a bit that I'll jump into when I go more into use cases about how you can see where some of the spaces created with three box might plug into Ceramic, but the concepts are kind of entirely different. Makes sense. Jonathan cool. And so that's generally the structure of documents.
00:14:16.044 - 00:15:16.580, Speaker A: And obviously, as I mentioned, these doc IDs are really how you query a document. So this is just an example of a doc ID that if you query a node, it will return the valid verified state, or you can query a version and it will only return the version. The cool thing is about Ceramic is it's really modular. So the ceramic node really enforces these document transition rules and gives documents these permalinks, but the persistence all content is stored in IPLD and pinned locally in the node. But then that node can choose a persistence option so that node can persist the contents to filecoin if that node is configured that way. But alternatively, that node could configure a persistence option to like S Three or a SQL Server. And it just depends on your trust guarantees for the documents that your node is managing.
00:15:16.580 - 00:15:57.250, Speaker A: And similarly, it doesn't need to anchor on any particular blockchain. So you can configure your node to anchor to Ethereum, you can configure it to anchor to filecoin, you can configure it to anchor on Cosmos or anywhere. And so really it's plugging. Ceramic in a way is a meta system on top of these various decentralized protocols that makes creating and managing information better. Okay, Jonathan, not exactly sure still. All right, hopefully in maybe like ten minutes this might become a bit more clear. I'll jump into where throughbox might plug in.
00:15:57.250 - 00:17:00.260, Speaker A: So now I'll jump to how ceramic works. So we went through general the structure of the protocol, what it does if you want to start building, there's JS Ceramic. So JS Ceramic is a TypeScript implementation TypeScript client for the Ceramic protocol and it has two interfaces. There's sort of Ceramic Core, which is a local node that you're directly interacting with, it's a standard JavaScript interface. Or you can interact with Ceramic over an Http API and both work. So Ceramic can run in browser in an app directly and do the full networking. Or you can in some ways run like a light client where you just have JS Ceramic configured with the Http API and it's communicating with a remote ceramic node that might run on a server.
00:17:00.260 - 00:17:58.068, Speaker A: And so obviously things like that enable Ceramic to work on different sorts of devices, more resource constrained environments like mobile apps and things like that, or running right in your browser. And you can see there's a couple of packages that comprise this. I won't go into too many details. If you really want to learn, you can dig in. But when you're setting up a ceramic node, there's a bunch of configurations that you might want to set, as I talked about before. So you can pass in a persistence option to filecoin, you can pass in a blockchain anchoring service which may anchor your updates on a given blockchain but you also need to import what are called doc types. So I gave a hint towards it before in the protocol but each document that's created on Ceramic conforms to a DOCTYPE and a DOCTYPE is really the rule set.
00:17:58.068 - 00:18:43.888, Speaker A: Both the content rule set and the mutation rule set that's applied to the document you create. You can think of them as like they're the smart logic for the document. And so doc types are really these engines and we've created a few. And so when you're spinning up a node you have to pass in the dock types that you want your node to support. And I'll go here. One of the most generic doct types is called a tile, and it basically describes a JSON document that's like a JSON object store. And it's really flexible in that there's no specific rules for what content can be stored as long as it's JSON and the owners have to be one or more DIDs.
00:18:43.888 - 00:19:34.164, Speaker A: And those DIDs have to sign the updates for the document to be mutated. And that's really like a pretty simple primitive. We actually include the tile DOCTYPE in the JS ceramic monorepo and in your instance out of the box. So you don't actually have to manually import it. It's kind of there by default but the manual importing is there for people that may, for example, want to write custom doc types and they want to use it in their nodes. There's no predefined restricted set of rules, but rather it's flexible for you to write documents and doc types that do things to documents that are aligned with your use case. One more doc type is called Preid and this is actually a W three C compliant did method built entirely on ceramic documents as a doct type.
00:19:34.164 - 00:20:50.264, Speaker A: And so this is different than the tile in that there's different considerations for what content can be stored in it. And so you basically need to there's specific things that make a did what a did. A did is basically a document that has a management key and that management key needs to sign all updates to the Didcument, including public signing keys and encryption keys and other content that a did might need to include in the did document. And quickly for those unfamiliar DIDs are sort of the core piece to interoperability that we've been working with the W three C community and the Decentralized Identity Foundation with for quite a long time, since early 2016. The standard is finally getting the attention and traction that deserves. But they're really globally unique identifiers that can be respected by any interface and you can control with any number of keys and so they actually serve as the foundation for a more user centric interoperable web. And the three ID did method is implemented as a DOCTYPE in ceramic natively.
00:20:50.264 - 00:21:13.216, Speaker A: So again, if you install JS Ceramic, you'll get the three ID doctrine out of the box. You can create did. So you can start interacting with other documents. But ceramic is did agnostic. So let's say you have a did method that's anchored on Microsoft's Ion or Ether did on Ethereum or anywhere else. Those DIDs are still supported in ceramic. So ceramic is did agnostic.
00:21:13.216 - 00:22:08.500, Speaker A: But because it is a did based platform, we do have a did that you can use to just get up and going if you don't have one. And now this brings me where is it? Here. Cool CIPS. So as we talked about, there's the core protocol and then there are things that are optional or sort of configurations and those include doc types but those may also include standards that are built with doct types. So standards for schemas or standards for identity indexes or various things. And so we have the CIP process where the community can propose standards for things. So in this list you'll find the Tile DOCTYPE, you'll find the three ID DOCTYPE.
00:22:08.500 - 00:23:01.370, Speaker A: And so doctypes you can use are all in here as well as things like schemas. So we've specified some things like a simple string map. So a string map is how you would define a schema on Ceramic which is actually using the Tile doc type. So if you create a new document that you want to be a schema, you create the Genesis record, you say it's a tile and then you can just publish your schema to this document which then once it's a document on ceramic you can reference it with a Doc ID when creating other documents. So you can say I want to create, for example, a basic it's right there, a basic profile. Like how would that work? I just saw it. Here we go.
00:23:01.370 - 00:24:00.408, Speaker A: So a basic profile, let's say you want to create a profile for a did and publish it on Ceramic. You would basically just create a new document that is a tile. You would specify in the schema property the schema of this basic profile which will be deployed as a document once the network is more live and on beta testnet. So you just pull in the Doc ID of this schema, you'd specify tile and then you could go ahead and in the content, just publish data according to this schema. And lastly, you'll need to add the basic profile tag to the document tag and then anyone can query your did and see it's an owner of this basic profile document and have a basic profile. Obviously a really simple use case, but one that can kind of get to some of the properties. And let's say you wanted to update a profile with a new name.
00:24:00.408 - 00:25:27.004, Speaker A: The did would publish a signed record which updates the basic profile document to a new name and then that would get anchored on the chain. And then the next time I query this document ID, I would get the new profile sort of automatically and how this all ties together so when we were creating ceramic, what we really had in mind was we obviously drew on requirements from Threebox. So with three box it was, how can we create a decentralized identity protocol that allows a user centric web where a did is controlled by many keys and that did maps to and controls many resources which may be profiles, but it may be account links, so links to Twitter, GitHub, domain names, et cetera. Also data stores which may live on three boxes infrastructure, but which may live on the textile hub, for example, and textile threads, or it may map to just a bit of raw data published on filecoin or on Rweed. And so how do you basically look up a did and find all of its related resources, which is sort of the heart of the user centric web. And this brings us to one of the main standards we're working on. So again, we have ceramic core, then we have ceramic dock types, and we have standards and schemas built on top that are use case implementations.
00:25:27.004 - 00:26:16.224, Speaker A: And so the identity index protocol, we're going to be sharing more about this really publicly to start engaging people on it next week. But it's a way to build an identity centric index of resources built around a did. And I'll skip through the beginning because this is sort of conceptualizes how documents can be linked to provide really powerful use cases. And so you have a did, which might be a ceramic Three ID. You can create a root index document which is just mapping properties to other doc IDs. So it serves as a routing table for Categorical directories. So you look up a did, you get its root index document, then you say, I want to query its profiles.
00:26:16.224 - 00:27:03.620, Speaker A: So you follow this doc ID and you query the network for the profiles index, which contains an index of various profile documents. So basic what you see here would map to the doc ID of that basic profile document I just showed you. It can map to an authentication keychain, which actually is where you would add a bunch of different wallet keys from filecoin wallets to Ethereum wallets and everything else to actually control the did. So now you can authenticate and manage did with any key. Similarly, you can link a whole bunch of accounts, like domain names, crypto accounts, publicly. So you could look up these accounts and resolve a did and then resolve the rest of its resources. Portable social graphs are mapped from the connections index.
00:27:03.620 - 00:27:52.500, Speaker A: And there was a question about how Threebox maps to ceramic. And so Threebox has its own identity system internally, which we're fully migrating to this identity index protocol and sort of allowing threeBox's little library to consume these identity indexes built on ceramic. And Three box spaces are just basically personal data stores that are app specific. So you can create any number of spaces per user. And here those would be mapped in a collections index. So basically, if you want to associate some external data source, whether it's app data or any sort of data to a did, you add it as a collection. And these can be Orbit Stores, textile threads, even other ceramic documents.
00:27:52.500 - 00:28:49.120, Speaker A: But in order to add it, what you would do is you create a definition. And a definition basically specifies the data model of your app. So it can say, my app uses one Orbit Store, one Textile Thread, and those conform to these two schemas, let's say, for a very simple example. So my app uses two data stores that use these schemas, and that is published by the app's did. And then it points to what here, it says Manager, but it's actually called Reference. So then each collection, that's the definition, the definition maps to a reference, and that reference is a document that contains user specifics about that definition. So every Textile Thread or every Orbit Store has unique ID, and each user gets a unique instance, right? So in this reference, you would have a pointer to the Textile DB located in the definition.
00:28:49.120 - 00:29:33.140, Speaker A: So I know it's a Textile DB and it has this schema, and then the reference would say, and it has this address, and it lives at this location. So now I can look up a did, find the root index, find the Collections index, and then find the data stores that I need, which may live. Maybe the Textile DB for this app lives on the Textile Hub, and maybe the Orbit DB for this app lives on the three box cloud. And so you can route to those. And because they're mapped and controlled by DIDs, the user can always encrypt and decrypt and authenticate those data stores. So it solves on the distributed Web. In order to make identities and resources truly portable across platforms, you have a discoverability problem.
00:29:33.140 - 00:30:30.264, Speaker A: How do you associate these resources to a user in a standardized but flexible way that enables anyone to query a did, find its resources, and route to them in the appropriate way. And so this is sort of the core of the user centric web and how we imagine a lot of use cases for ceramic will be built. Like, even if you're just publishing documents such as blog posts or data about something, in order to make it discoverable and consumable by other apps, you'll want to associate it as a collection to a did. Hopefully, that clarifies the three box question a bit. Like if you have three box spaces, once they migrate, they'll just be collections within this IP and a bit about where we're going. So, as I mentioned, we have the Slip testnet that's live. You can play with it.
00:30:30.264 - 00:31:00.000, Speaker A: People at Hackfs are already building things on it. We just refactored our JS API, so that's already released. We basically pulled Docktypes out of the core protocol and made them optional. So anyone can write their own doctypes and use them. We added schema support as of like yesterday. So now when you're making updates to documents that have schemas, the protocol is actually validating that update and making sure that it conforms to the schema. Otherwise it's an invalid entry.
00:31:00.000 - 00:32:01.364, Speaker A: We are making the interactions between wallets and the network really easy. So you can use Ceramic with any crypto wallet you want. And we got approved by Filecoin and Ethereum Foundation to create this library called Dag Jose, which standardizes? It's a multi codec for IPLD or codec for IPLD, which standardizes the way information is signed and encrypted as IPLD objects. So data that's, for example encrypted data that's put there by Ceramic DIDs will be consumable and decryptable by anyone else on the IPFS ecosystem. It doesn't lock anyone into an encryption standard and we've already added that to the protocol. So we're really just testing and finalizing a bit of this. But within the next few weeks we hope the beta clay testnet will be out and that's sort of like we'll use all the data formats and standards that you would need to sort of build real apps and try it.
00:32:01.364 - 00:33:06.916, Speaker A: And then after that we have a bunch of nice things that we want to add to make the protocol more powerful, more performant that we'll do before we actually go live. And we're hoping to go live by the end of fall, early winter, and that will sort of be the full thing and it'll be ready to go to production. But if you want to follow along, the roadmap can be found as just an issue in the Ceramic Network Ceramic repo. So I'll stop there for a second and there's obviously a bunch more I could talk about. I could go through a ton of use cases that people have maybe that'll be helpful before a bunch of questions. So for Hackaths, there's already people building a new doc type for Verifiable claims and some of them are on the call, but basically I'll let them share more about their use case. But in summary, it's a doc type that enforces the Verifiable claims format and schema to create W three C compliant claims.
00:33:06.916 - 00:34:07.036, Speaker A: So things that are maybe like an education degree or a proof that you own this social media profile or username or a claim about anything really. And it's like a signed bit of data where you can trust the author with that institution and it's really kind of one of the big pieces for decentralized identity. So someone's building a Verifiable claim DOCTYPE, someone else is building the Geoweb, which is sort of an on chain registry of properties in the physical world and they're mapping those to Ceramic documents. So only the owner of that physical piece of property can create this dynamic document on Ceramic and update the content and do whatever. And again, the way that documents are structured, how they're updated, is to be determined. If they're going to write their own doc type or not. So those are two Hackett Best projects we know are working on things.
00:34:07.036 - 00:35:41.740, Speaker A: Others are using Ceramic, this identity index protocol I discussed to provide to upgrade the identity systems or lack of on the filecoin ecosystem and Textile and others. So basically they want to host Textile, DBS or Textile threads for users, but they want to associate them to their IP and let the did access control those data stores that they're managing in such a way as to make the data portable and interoperable. So they would be publishing schemas of the data stores to Ceramic. They're mapping those data stores to the DIDs using the collections index, and they're doing all sorts of cool things to build on this stack of DIDs, like ceramic network DIDs, filecoin textile to really make Web three a reality. Because it's kind of hard to build a truly portable Web three app that's controlled by users when each of these technologies have their own implementation for keys and identities and routing is sort of implicit and hosted on a service. But if you can decentralize schemas and routing and identities all to this public network that works across chain, you can tie all these technologies together to build really powerful applications. So I'll stop sharing and I'll pull back up the people in the group and say, Questions? Thoughts? Sort of.
00:35:41.740 - 00:36:32.392, Speaker A: The floor is yours. So I see one coming in from Thomas. Does the node automatically anchor the state changes to whatever blockchain it's configured? Well, it doesn't automatically. There's a method where the node gets a record and then it applies the record. So the apply function is separate, so the node can collect signature updates from any participants before it actually applies the record. And when it applies, we have this concept of anchoring services. So for throughput and low cost, the nodes can submit the record to an anchor service, which basically takes a whole bunch of anchors from a whole bunch of nodes and puts them in a merkel tree and then only publishes that merkel tree to the chain, along with the metadata for things like Bloom filters.
00:36:32.392 - 00:37:09.160, Speaker A: So you can parse the tree and know if a document you care about was updated. And then once that anchor goes in, it gets reapplied as an anchor record. After that, proof is returned. But in the meantime, you don't have to wait for the anchor service to actually anchor your update to assume it's valid. The anchor service emits a message in the Pub sub room which says Anchor pending. And so you can kind of work optimistically that that anchor is pending and use it as ordering in the meantime, so you're not held by the frequency with which the anchor service is updating. You can actually get a message back that allows you to proceed.
00:37:09.160 - 00:37:35.376, Speaker A: Does that make sense? Cool. Any other questions? If not, we can know. I think Stefan and Maul, you guys are working on Verifiable claims. Feel free to share sort of how you're using Ceramic, why you thought it was interesting.
00:37:35.558 - 00:37:39.170, Speaker B: If anybody wants to unmute, feel free, just go ahead to do that.
00:37:42.100 - 00:38:07.352, Speaker C: So, yes, thanks a lot for this extreme explanation. It's always great to hear what you guys are up to. And we're actually just struggling to get it work. So we are actually doing two things. We are trying to build these Verifiable claims document type on top of the mono repo. This is what Anmold is doing. I think he's still here.
00:38:07.352 - 00:38:34.204, Speaker C: Hello, Anmold. And what I'm trying to achieve is actually get everything running in a browser scope, and I mean in the plain browser. And I'm not exactly sure if this anchoring service is meant to be run in a browser, at least. I have quite a hard time running it here. But from a concept point of view, I think you just could use MetaMask or some injected signer to sign these anchoring transactions.
00:38:34.252 - 00:38:36.080, Speaker A: Right? Yeah.
00:38:36.230 - 00:38:36.832, Speaker C: Okay.
00:38:36.966 - 00:38:45.190, Speaker A: Yeah, of course. So an anchor service isn't actually meant to be run in the browser. It's like an external service that you submit to because that would be quite a lot.
00:38:45.560 - 00:39:21.852, Speaker C: Yeah, of course. But I think you could actually also just anchor every document change you do on your local thing on your own on the Ethereum blockchain. The main thing we were struggling with was also like binding the three box identity or the identity wallet to that ceramic clients. And then we had some little discussion on the discord of ceramic. And I think we are pretty sure that you cannot just use a three box identity to identify with this one against the current ceramic implementation.
00:39:21.916 - 00:39:45.320, Speaker A: Right? Yeah. Basically, we haven't done the three box migration yet, so it's not meant you're sort of very early in the sauce on that. And so basically you can create new DIDs on ceramic using the instance, and you can interact with the protocol that way. But it's a bit hard until we actually do the migration to use three box identities within ceramic.
00:39:47.980 - 00:40:27.504, Speaker C: Yeah, the main thing we had to figure out is how to create Verifiable claims representations, because putting a Verifiable claim in a ceramic document is a no brainer. You just put some document in there, it just works. But of course, we wanted to conform to more or less the standard. And Anmal, if you don't mind, I can just share my screen and show just very quickly how it looks like in our case, if I find the right window. Here it is, I guess. Do you see a window or do you see lots of blue? I think you see a window.
00:40:27.552 - 00:40:28.150, Speaker A: Okay.
00:40:29.240 - 00:41:14.544, Speaker C: The project has been called Iridanus because this is the area in Greece where lots of ceramic comes from. At least this is what we found on Wikipedia. So what we're doing, we are authenticating our Ethereum address against three box. And now we got a three box identity. And what we're doing, because this is not compatible yet, we're creating a seed that we're storing inside a private space on threebox, and then we're using that seed to identify to create a three box sorry, ceramic identity that as a document, actually looks like that. And if you just want to see how this looks in the browser, I just created a tile document and scale that up. This is the idea of that document.
00:41:14.544 - 00:41:32.308, Speaker C: You could look that up on IPFS and you can update the document and you see that the head is changing and you get all the changes here. And now here comes a problem. If this runs in browser, there is no anchoring service. So every time I reload that one, it doesn't know about the updates because it never anchored anything. And yeah, this is something I would.
00:41:32.334 - 00:41:33.052, Speaker A: Like to get around.
00:41:33.106 - 00:42:13.764, Speaker C: But coming back to the very foul claims so this is just a demo. We just created a very foul claim document. When I click the button and this is the contents. And Anwar was using the Did VC project, the library, to create a signed Jot out of the claim. And as you know, or might not know, there is, of course, this. Very nice. Oh, this was the wrong one, right? Where's the right one? Hope I didn't break anything here, because actually, this Jot should contain a claim, but it doesn't.
00:42:13.764 - 00:42:45.330, Speaker C: I'm sorry, I think I broke it on the way. But what we're actually doing, we're just creating a Verifiable Credential that says this did has taken part in the hackerfs hackathon, and we're creating a job proof. It's actually self issued verified Credential in that sense. And this is what we're storing as a ceramic document. Anmal, if you got any additions to that one, I'd be happy to hear.
00:42:47.480 - 00:43:36.000, Speaker D: Yeah, I think I explained most of the idea, but claims can be anything. It can be educational degree, it can be a driver license, it can be your Koc documents. And the idea is, how do you link them to your decentralized Identifiers and store them somewhere else so that you can share them with any Verifiers on any organization? And that's where the idea comes. Like, you create a doc type, we store those claims, and we're also planning to add that Schema support so that you can store them in a more structured way. And then you can also present them as a ceramic documents itself and also verify them. Since ceramic documents already have that signing thing, you can digitally prove that you own that Verifiable. So that's the idea, and I think statement already shared.
00:43:36.440 - 00:44:02.232, Speaker A: Awesome. Yeah. Thank you. Appreciate that. A question from Thomas. Can a document be mean? You basically the current owner can change it's specified in the doctrine, what updates can happen. But the tile doctrine, for example, you can update the owners, I believe, to nothing and then in that case it's not owned by anyone and it can't be updated.
00:44:02.232 - 00:44:45.080, Speaker A: In that sense that definitely works. And the reason why we need blockchain anchoring is really for this ownership, right? And especially with decentralized identities, if you're adding keys and then you're removing keys or changing keys, you want strict ordering about updates and you need a linear logical clock or a linear explicit clock about when things happen. Because if I remove a key, I don't want that key to try to make a malicious update to any of my documents at any time. And so same thing is true with certain documents that you might have. And so in that case, blockchain anchoring is really good for proving verifiability of the owners at any point in time who's authorized to make updates.
00:44:46.940 - 00:44:48.584, Speaker C: So if I wanted to sort of.
00:44:48.622 - 00:45:41.080, Speaker A: Promise that I will never change the document, I could remove the owner or something, I imagine. Yeah, and there's really interesting things that we're exploring too. So for example, a document could be owned by the Geoweb project, for example, they really want it to be where a landowner, only the current landowner can update the document. And so if you just specify the present landowner's did as the owner, that present owner can make two signed records. One saying, like, I'm removing myself. But before they do that, or I'm changing the owner to the new owner, but before they do that, they say, I'm the owner. And they withhold that first signature, and then they only submit the second, which changes ownership.
00:45:41.080 - 00:46:29.524, Speaker A: Then at a later point in time they could publish the previous update and say oh no, actually this one is precedent because it came before, I'm still the owner, take it back. And so how you get around that? Like for decentralized identities, that's not really a problem because it's all my documents and I'm not transferring mine. But what you can do is you can make an NFT the owner of a document. So you're actually like delegating the double spend problem to a blockchain and so you say only the so an address owns an NFT. The did of that address is the only one authorized to make updates to a document. And so then if I transfer that NFT to you Thomas, now only your did can make updates and mine can't either. So that's really good for supply chain, really good for NFT owner guest books.
00:46:29.524 - 00:46:46.144, Speaker A: Everyone that owns an NFT is the only one that can write to this log. You can do really cool things and that can all be enforced by ceramic. So there's really a lot of flexibility in how these documents can be made smart, just depending on what your use case is.
00:46:46.342 - 00:46:48.050, Speaker B: It's excellent, thanks.
00:46:51.460 - 00:47:46.930, Speaker A: You can also do things like dow votes where a new record type can be created, where the dow votes on chain for something, if it passes, it creates a record on chain, which is already anchored in a way. So you don't even need an anchor record, you can just add that to the document. And so that would be like a new record type. So depending on the use case, you can really add all these things in as modules between the combination of records, doc types, ownership things, schemas, it's really configurable. So we still have ten minutes. Any other questions or any ways that I can be helpful? Cool. If not, Trent.
00:47:48.870 - 00:47:58.898, Speaker B: Don'T be shy if you have questions. Yeah, we still got a few minutes. Hugo asks a question in the chat.
00:47:59.074 - 00:49:35.346, Speaker A: What kind of network is this going to be? How's it going to work? Sure. Hugo, can you share a bit more context about the question? Yeah, so maybe I didn't completely understood this part of it, but who is it going to be running like ceramic node? And how is this all networking part going to be working? At least on a high level? How's that going to work? Yeah, like the IPFS journey, we're not adding a token immediately because we want to ensure that everything is working properly before we introduce something that's going to lock the network into a certain model. It eventually likely will have a token, but in the beginning, everyone that's running the ceramic core instance in their browser is running a node right in the browser. Also there will be partners that are running more nodes that you can connect to from Http API and then actually serve to pin content when that local node is offline, for example. And so like IPFS worked until the introduction of filecoin is really how ceramic will work until the introduction of some sort of a more incentivized node operation scheme. But basically any app that's running things on ceramic will probably run a node. Users themselves will have a node if the app is using the full library in the browser, threebox will run some nodes.
00:49:35.346 - 00:50:19.598, Speaker A: We have a bunch of partners already lined up to run nodes, so even without a token, we're seeing sort of the network have enough support to manage the initial use cases. And not every node needs to pin every document. Which is the nice thing about ceramic, where you don't have a concept of a full node, where you have the full set of all documents on it. Nodes can just pin the documents they care about and then they use Lib, PDP, Pub sub to request the current state from nodes that have it. And so nodes are actually a lot lighter. There's not the same amount of overhead needed to run a full node because the concept of full nodes doesn't really exist in ceramic. Since each document is its own state chain, you don't need the full state tree of all documents to verify the state of any one document.
00:50:19.598 - 00:50:35.180, Speaker A: You can just verify the state of each document independently, so it makes the network a lot lighter, meaning you don't need a server farm to run a full node, you can just run it in the browser. That's awesome. Thank you.
00:50:37.070 - 00:50:47.742, Speaker C: But the main idea of these nodes is anchoring and pops up notifications if they get requested. The current head of a document ID.
00:50:47.796 - 00:51:42.894, Speaker A: Right? Really, the functions of a nodes are version control, right? Like the document management logic anchoring is not really the job of a node. Nodes can add an anchor service where they just externally submit to, or the user itself can publish that to the chain however they want. The node is really just running the logic engines for the documents it's managing. So the node in the protocol will say, does this update conform to the schema defined? Are the parameters true that require the state transition to happen? Querying a node, it will return the current state of a document. So it's really like document management, but not like the core job of a node is not really persistence or anchoring. It's applying the rules to each document on the network, which is like really a rules engine.
00:51:43.092 - 00:51:46.414, Speaker C: That's basically something that you can do in a browser, right?
00:51:46.532 - 00:52:37.542, Speaker A: Yeah, you can do that in the browser because you're just like running that small logic on each document you're querying. How would you enforce that? A given node has not tempered with the logic of how to change that document because it can only run the DOCTYPE code. It's like running the packages and all documents can be verified. So because they're linked lists of records, the receiver can actually parse the records and actually check that it's true. And so you can always do the verification. The node just does it for you. Cool.
00:52:37.542 - 00:53:23.910, Speaker A: Some other questions. What are some possible new dock types for the prize? So again, this is really flexible. Doc types are use case specific in some way. There's some general ones, like tiles, three IDs verifiable claims there are other really cool things you could do. Like we've been toying with internally this concept of a script doc type where it basically is just some code that you can think of like a script doc type as being an aggregator. So let's say there are 20 documents created by 20 users, all with the same tags, all with the same tag. So maybe that tag is like a unique topic ID somehow like the hash of some combination of things.
00:53:23.910 - 00:54:36.270, Speaker A: And then you can have a DOCTYPE that just has a script that takes the latest state of all the documents with this tag, for example, and creates a new document. So you can build like commenting systems like that, right? Like if each user is just having an append only log and you have a script doc type which aggregates those into one document, that document isn't responsible for getting content by a did directly published to it, but its content is just the output of the script that it's running. And so there's really cool things you can do that way, which I think could allow us to run solidity. Yeah, there's a lot of possibilities here because documents, sure, they're really like dynamic objects where you can't build a cryptocurrency system in a document, for example. I wouldn't advise that because you do have the double spend problem in some ways about withholding records. But if you have things like information and various things like that, you just need to sandbox the amount of resources it can consume in some secure environment, like secure ECMAScript or whatever. And then you can just run these computations.
00:54:36.270 - 00:55:14.220, Speaker A: It's like this VM. So what you can build with doc types is really flexible and I hope people come up with some cool things. Verifiable Claims is immediately useful because when we're migrating $3 to Ceramic, we have these Twitter verifications and GitHub verifications that we want to associate to a did via its accounts index. And so the accounts index will point to these Verifiable Claims documents which say like this did owns this Twitter account and other things like that. So those are immediately useful. The other ones enable people to build other cool things. I want to build that aggregator script, please share the link.
00:55:14.220 - 00:55:53.010, Speaker A: Cool. I don't have it up on this computer, but let me share a link to our Discord where one of our engineers has started building a prototype. So you can share the latest with that. Let me pull up. Think that should work. I'm on a computer where I don't have my Discord on it for this call, but there's a link to our Discord. If you jump in and ping us, we can definitely share that with you.
00:55:53.010 - 00:57:02.004, Speaker A: Not sure. For general app state storage for a new app, should I look to Spaces or Ceramic? It depends on your guarantees. So distributed databases still have a purpose, right? They are for really dynamic data that you might want to host on a server that you kind of trust that in a way and it's less critical. Ceramic documents do have anchoring, so they're a bit slower than what you would put in a Textile thread, less frequently updated, but you can do interesting things. So there's a chance that we migrate some of what are currently spaces directly to ceramic documents because what people are using it for to store app state every now and then or store, like, a pending transaction that could be stored in a ceramic document where people are dumping, like, 10,000 entries into a thing that should probably be a database. So it really depends on your use case. It could be either for the question about spaces or documents, and I think that's most of them we're running up on time.
00:57:02.004 - 00:57:05.160, Speaker A: So any last thoughts or questions before we all hop?
00:57:09.510 - 00:57:10.850, Speaker B: Perfect timing.
00:57:11.750 - 00:57:12.500, Speaker A: Yes.
00:57:13.430 - 00:57:29.240, Speaker B: Thank you very much for presenting about Ceramic and giving us details about three box and the plans for the future. I'm sure a bunch of these people building here will continue following and building on what you guys are working on. It seems pretty awesome.
00:57:30.890 - 00:57:45.550, Speaker A: Cool. Yeah. Thanks for having me, Trent. And please, everyone in here, feel free to jump in, ask us questions. We're always available on chat, both in the file coin slack and in the ceramic discord which I shared.
00:57:47.250 - 00:58:02.062, Speaker B: All right, thank you, everybody, for coming out. And if you need to go back through anything, this recording is available on the ETH Global YouTube channel, so be sure to check it out, share it around, show some people. Thanks, Michael. We'll see everybody.
00:58:02.196 - 00:58:03.850, Speaker A: Yep. Take care, all. Good luck hacking.
