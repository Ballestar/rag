00:00:00.250 - 00:00:26.950, Speaker A: Analytics we have, eric Hare is going to give about a half hour workshop and demo. You should feel free to put questions in the zoom chat, and we'll try to fit them in during the presentation. And then as we get to the end of the half hour, we can also try to do some questions then. But with that, I will let Eric share his screen and we will start the workshop.
00:00:28.810 - 00:00:39.100, Speaker B: Okay, hopefully you guys can see my screen okay here. And if you can, we'll go ahead and get started.
00:00:40.590 - 00:00:42.554, Speaker A: Okay, we're good.
00:00:42.672 - 00:01:10.660, Speaker B: Cool. Perfect. So this is a little workshop. We wanted to do like a hands on demo of Uniswapper, which is our package for interacting with the Uniswap platform. Those of you who are familiar with R, you may know it's like a pretty commonly used statistical and data science type programming language. We do a lot of our work in R. I just want to talk really briefly about us, actually.
00:01:10.660 - 00:01:56.226, Speaker B: So I'm the chief data scientist at Omni Analytics Group, and we're basically a boutique data science consultancy, and we specialize in machine learning, data vis, statistical analysis, AI, all kinds of statistics related stuff. And we've been really involved in helping crypto projects utilize their data, optimize their DApps, increase adoption. And we've already collaborated and partnered with a lot of top crypto projects the Ethereum Foundation, Ave, Gitcoin, Numerai, et cetera. And, of course, uniswap. That's what this is about. This is basically going to be a workshop. There's not that many slides for it.
00:01:56.226 - 00:02:47.442, Speaker B: I'm going to go through some code where basically you're going to see how you can use the package that we've built in order to make trades. Do a little analysis of the data on uniswap and check out some of your own metrics as far as the swaps that you've done and the performance of the swaps over time. So I just wanted to call out two links because those of you who want to follow along and kind of try this, especially if you have R already installed, even if you don't, you can kind of reference these links just to get some information. So the first one is our GitHub. If you go to our Omni Analytics Group GitHub, you'll see Uniswapper is available as a package there so you can install it. It has the instructions. Actually, the workshop that I'm going to do that I'm going to show you is largely based on the README, so you'll notice a lot of the same code.
00:02:47.442 - 00:03:28.330, Speaker B: And that was done quite intentionally because I wanted this to be as accessible to people as possible. So you can refer to that README to see a lot of the code that we're going through in this workshop. If you want a little bit more detail, if you're interested in it, we've also published a blog on our crypto Omnianlytics IO page. Basically, we cover the material of this workshop, and we also have some videos that we recorded. So if you want to refer back to some of these, you're more than welcome to do so. Okay? All right, so let's go ahead and get started. So I'm going to exit out of here, and we're going to work in RStudio.
00:03:28.330 - 00:04:06.950, Speaker B: So I'm going to kind of go through what we need to go through here. So basically, this is an R script that I have created, and hopefully you can see the code. Okay? If anyone has trouble seeing it, please just post in the chat, and I can increase the size, et cetera. But what we're going to do basically is we're going to go through loading unitswapper, setting up a virtual environment, and then basically making some trades. And you can see here's the script we're going to try to get through as much as possible here. So I want to call out because we had this question from some people who use R. Right now, uniswapper is not on Cran.
00:04:06.950 - 00:04:49.426, Speaker B: So if you're used to installing R packages from Cran, where you'd use install packages, keep in mind you have to use DevTools or a similar package to install directly from our GitHub. So you can do that with this line of code right here. I've already installed it, so I'm just going to go ahead and load it. Now. One intentional way that we kind of set up Uniswapper is that we actually depend on the uniswap Python package underneath. And so what's kind of nice is this reticulate package. It allows us effectively to integrate with the Python code that underlies uniswap Python.
00:04:49.426 - 00:05:38.230, Speaker B: And so we can reutilize a lot of those functions, but expose them into our R script and our R code. So basically what I'm going to do is I'm installing a particular version of Python. It doesn't have to be three, eight, seven, but I'm installing that version, and we're creating a virtual environment for Uniswapper, and then we're installing that package into that virtual environment. So that might take a little longer. Some of my installs are cache. And then we're just going to say we're going to use that virtual environment, and then we're going to pull the Web three function effectively from that package. So what we've basically done here is we bootstrapped the Python environment that's necessary sort of to underline the code and the functions in Uniswapper.
00:05:38.230 - 00:06:27.190, Speaker B: Okay, I'm going to tell the R session that I want to use that virtual environment. So you'll want to do that basically every time you interact with the package. You obviously only have to install the virtual environment once, but once you actually get it installed, you want to tell your R session to use that environment for the Python calls underneath. Then what you can do is basically, just like you can in Uniswap Python, you can set, like, your infura node or your other provider. In this case, I'm using this one for testing just to show you some of the trading that we can do using the package. And then finally this is sort of the last bootstrap setup step that we need to do. What we need to do is we basically need to initialize a new uniswap session with this function.
00:06:27.190 - 00:07:08.574, Speaker B: And you just basically need to pass in your infura node which gets passed in by default, so I'm not providing that. And then you need to pass in your address and your private key and basically once you do that, that will initialize the session. And now I'm connected and basically I'm now ready to start interacting with the platform. That's kind of the boring infrastructure stuff that we need to get out of the way up front. But that's how I now initialize my new session and how we continue. Okay, so let's move on to what can we actually do with this package. So basically the first thing I'm going to show you are kind of the lowest level functions.
00:07:08.574 - 00:07:49.060, Speaker B: So one of the lowest level things we can do is we can do things like check an Ethereum balance for a wallet address. We can check a token balance for specific tokens. So for instance, I'm going to just pull I think, uni and die. And I'm just hard coding here the number of decimals basically to make the computations all scale by that factor. And once I've done that, basically I'm checking this wallet address and I can see, okay, it's got a balance of eleven point 26 E. Over here I have in the interface you can see I have that pulled up on uniswap that does check out. That's what my current balance is.
00:07:49.060 - 00:08:30.350, Speaker B: So let's go ahead and continue. We can also say let's check the specific balance for particular token on that. So in this case we're basically saying for that particular token, what's our balance on the platform. And so in Ethereum and in the token that you select based on the address that you pass in. Okay, so that's just like the really lowest level stuff. But now let's actually do some stuff that might be useful for trading. So there's a bunch of functions that kind of fit, I guess a similar type of mnemonic you could say, which is like check ETH to token ETH fix.
00:08:30.350 - 00:09:30.850, Speaker B: And it's a lot to parse at first, but we try to break it down in the README because there's a lot of ways you might want to go with this. So basically this first function would say how much uni would you get for 0.5 E when you swapped ETH for uni. So I'm saying like, let's fix a value of 0.5. How much uni would you get for that when you swap uni for ETH and you get that value and then how much ETH would you need to get two uni tokens when you swap ETH for uni, that's kind of the reverse operation there and it gives you a value. So these utility functions are sort of like if you want to get a number for what you want to do to make your trade. So this one you could say like how much ETH would you get for two uni tokens when you swap uni for ETH? So these are all sort of like reverse, kind of in parallel to one another, but they're all computations that you might want to do with specific tokens in order to assess what you can do when you're about to make your trades.
00:09:30.850 - 00:10:05.710, Speaker B: Okay, so now let's actually make a trade. So I'm going to fix a value of 0.5 Ethereum and I'm going to say I want to swap that for uni token. So once again, remember that I was defining the addresses up here. So that's how we're kind of reusing these variables a bit. So we're basically saying we're swapping one for another this much and it's under this unit swap session, effectively the wallet address that I already defined. So when you do that, you get your transaction hash.
00:10:05.710 - 00:10:47.254, Speaker B: You're not going to see it immediately, but I'll show you like momentarily that trade will take place on the platform and it's already done. So you see, I just have 0.5 lower than I had before. That trade already took place just from basically being in the R session and letting it run like that. That's probably like the most basic trading function that's available. But there's some other ones that might be useful to you. Like for instance, instead of fixing the value of Ethereum that you might want to swap, maybe you want to specifically get a certain number of tokens so as much ETH required to get a certain number of tokens.
00:10:47.254 - 00:11:25.794, Speaker B: And if you do that, then that trade will work too. Eventually we'll see that balance update over here. You can do something like swap as many uni tokens required to get 0.5 E. So in this case, that trade in a way is sort of like the inverse of the first trade that we made, right? And I think, yeah, that trade hasn't gone through, but you can queue them up so that one goes through. There's my transaction hash, no problems. And basically if there's any unexpected behavior, for some reason the trade doesn't go through or some parameter of the trade is incorrect, you'll get that message in the console.
00:11:25.794 - 00:12:25.066, Speaker B: But effectively those should end up going through. You can see the balance has changed and they'll take effect pretty much right away. Okay, so those are a little bit like I would call them the lowest level functionality that the package provides. I mean, it lets you sort of check balances, make trades but you can imagine that's pretty useful if you have a routine as far as if you're working in R and you have some sort of routine and maybe some thresholds or some sort of heuristic that you might want to use to make a trade. Because these are all really simple calls and derivatives of these are all pretty simple to make as function calls. You could kind of encode this into your script, into your routines, maybe like when a condition is met in the market, whatever that condition might be, you initialize the trade and you can do that with our package to make it all pretty seamless and automatic. Okay, cool.
00:12:25.066 - 00:13:30.058, Speaker B: So now I want to get into some of the slightly higher level stuff that the package provides. And this, I think, goes a little bit to the data science world that we come from. Because even though the ability to make trades and to do some of these utility functions that we're providing are useful, one of the big motivations for us in producing this package was both to kind of allow you to pull data both on a user level, like, how are you performing when you make these swaps? How has your performance changed over time? Allow you to correlate it to market conditions, and also looking at Uniswap as a platform and how their growth is evident sort of in this data. So we provide several utility functions, actually, and I wanted to just highlight a few of them for you. So the first one, we call it Factory Stats. V two. Effectively what that is, is it's stats on all pairs generated by the Uniswap factory.
00:13:30.058 - 00:14:17.134, Speaker B: And it gets completely aggregated. So this is like raw data, but we've aggregated it down. So it tells you immediately, like 54,000 pairs. It tells you the total liquidity in Ethereum, the total volume in Ethereum, the total number of transactions. And you can think of that that's the most aggregate view of how much volume and basically the engagement with the platform. So that could be useful just from a user of Uniswap or maybe the governance people involved in the governance and the administration of Uniswap. As far as how are these growth metrics changing as a function of time, that's kind of like an aggregate view, but we wanted to also break it down a little bit for you.
00:14:17.134 - 00:14:54.490, Speaker B: So we made it really easy to just get basically a historical view of it. So this is a little hard to see in my console, and I'll show you how to export data momentarily, so it's a little easier to see, but basically you can see there's like, volume. And what this is basically broken down to is by day, and I think this is in Unix time. So just a little bit of date parsing needed. We could certainly do that within the function as well. But basically it's the same statistics that we just saw for the most part, but broken down by day. So it's like a historical view of how these metrics are changing as a function of time.
00:14:54.490 - 00:16:01.802, Speaker B: So really easy one function call to get that and then you can produce all kinds of visualizations and kind of summaries of that data to assess the changing basically the growth of the platform. By the way, not to bury the lead, but we do a little bit about of that later. In this script you'll see that we actually have kind of turned some of these into like visualization. So you don't have to just parse the raw data if you don't want to, but we wanted to make sure it's easy and accessible for everyone to do it. Okay, so you notice those functions took no parameters. That's intentional because we also have a version of these functions where effectively you can do the statistics or the historical statistics for a specific token across all the pairs that token is included in. So in this case, like passing in the uni token, now you get Trade Volume Derived E, total Liquidity Trade Volume, Transaction Count, all these statistics that are pertaining specifically to that token and you can pass in any of the other tokens.
00:16:01.802 - 00:16:51.774, Speaker B: Same kind of deal there. So basically like an aggregate metric and then specific tokens if you want to. And likewise you'll notice that throughout this there's kind of a common theme that if we provide the aggregate version, we also provide the historical data. So this version basically it'll fetch the data and give you like a daily breakdown of all those metrics for your specific token that you're interested in. Same thing as up here, but at the per token level. Okay, we also provide basically what we call token pair map, which is basically like for a specific token, get the stats for all pairs where the token is either base or a quote. So if you look at that, you can see the statistics are just a little bit different here.
00:16:51.774 - 00:17:54.242, Speaker B: But basically what we have, I'll go kind of the beginning of this data frame, you basically have like an ID, the block number when this pair was created and then you get a bunch of pair level statistics. So reserve zero, reserve one for the pair, the Ethereum reserve, the USD reserve, and then basically the token that you're interested in. So token zero, the first token in the pair. These are all uniswap because I passed in right here, the Uniswap address. But then here for token one, you can see these are all the ones that uniswap has a pair with and then the statistics for those different pairs. So you can see we're sort of going from a really aggregate view to a more broken down view depending on which of the data and the statistics are most relevant to you in that regard. And just to kind of emphasize on that, you can actually also take one of these pairs, take one of the addresses for it and then get some more broken down pair stats here.
00:17:54.242 - 00:18:47.010, Speaker B: So in this case, this is the Union Dai pair and you can see it's like an aggregate view of the statistics for that pair. So quite a lot going on here, but you see the prices of the token, the total supply, the volume of each, the USD volume, liquidity provider count, all kinds of statistics specifically for that pair. And I mentioned moments ago, when you start to see pair stats and when you start to see like an aggregate view of the statistics, you can expect that. We've also provided you with a more broken down view. So this one takes, I think, a little bit longer because we actually allow you to get hourly statistics for the pair. And you see it doesn't take too long, but there is some data to fetch there. And now basically, this is basically all the stats you saw previously, but broken down by hour.
00:18:47.010 - 00:19:30.222, Speaker B: And so quite a lot of data in there. But you can imagine because we're breaking it down so heavily. If you're interested in training some kind of machine learning model, perhaps a time series, the data is here, really easy to access for any specific pair and you can do that. And the world of R is pretty broad in terms of the capabilities of it. And we wanted to make sure it's as easy as possible for people in the community, both in the Uniswap community and the R community, to operate on this data. This is just a slightly aggregated version of the above kind of to prove that we have sort of some options for what we do here. But we can also get daily statistics for a specific pair.
00:19:30.222 - 00:20:12.866, Speaker B: If you want to go kind of in between that level of granularity that we were just saying. Okay, just really quick to show a couple more. We have functions where you can easily get the mints, the Burns, and the swaps, the transactions of those type for a specific pair. So mints and burns, those ones are pretty quick. I think swaps is, I believe, going to be pretty large, right? But it doesn't take too long. It'll just fetch it in batches of 1000 and then once it's done, it'll return a data frame. So you see pretty much all of the functions that we're witnessing here are returning our data frame so we can do what we want with it.
00:20:12.866 - 00:20:59.066, Speaker B: And I think probably something like 15,000 rows here, it'll fetch, returns that data frame and then we get our results back. Okay, so that was kind of a quick overview. These were all just specific examples of tokens and pairs, but it's totally general so you can pass in the address that you're interested in. But I want to show you one other kind of cool thing here, which is that we provided like a data export function that makes it really easy just to get a CSV export out of it. So let's say you generate the historical data for, in this case, the Uni token. We've stored it as a variable. So it's 411 observations of nine variables.
00:20:59.066 - 00:21:34.540, Speaker B: You can just specify a path and you can say export data. And just to illustrate, like, if I go over here on my desktop, there's my Uniswapper export that was just created so available for me. If you want to open it in Excel sheet, you want to share it with someone else. Really easy to export any of these data sets outside of the R environment. Okay, cool. So we've got about looks like about eight minutes left. Let me check the chat, just see if anyone has any questions.
00:21:34.540 - 00:22:29.750, Speaker B: Okay, so I see. Someone said, how can I use this library with react JS? So that's a really good question. So the way you would want to tend to do it, if we're building some kind of front end, like a JavaScript front end to an application, we would tend to use what's called Shiny, which is an R specific tool, kind of for building a framework where you can turn this into an application. If you want to use something like React JS, the key is that R makes it really easy to expose any of these functions as, like, Rest endpoints. So what I would say is it's a little outside the scope of the package. But if you look at an R package called Plumber, plumber basically allows you to take any of these functions and make them like Rest compatible, endpoints. And then I'm assuming the React JS application that you build can interface with those endpoints with Get requests, post requests.
00:22:29.750 - 00:23:21.290, Speaker B: And basically you could then deploy this as some kind of React JS application with R underlying the analysis. That's what I'd recommend. And if someone else has another suggestion, definitely feel free to post it in the chat. So we're using the backend, basically that the Python package, the Pip package for Uniswap is using. So basically we deliberately did that because we want to make sure that it's entirely compatible and also because there was so much good work done there that you don't want to reinvent the wheel exactly to compute this. So we're kind of making the calls directly to the Python package that is already available in order to do this. Okay, we've got a few more minutes.
00:23:21.290 - 00:24:11.738, Speaker B: So I just want to show you kind of this last part here, and then I'll look if there's any more questions. So the previous functionality was a little bit about pulling data and exporting data, but we also provided some utilities for exploring data, which think of it like we produced some visualizations and statistics on top of the raw data. Let me just give you some examples here we have this function called Viz uniswap stats. Historically, we prefixed with vis. If you're expected to get a visualization out of it, you can see this is in this case, basically what we're seeing here is for a particular token, we're seeing the daily volume, the liquidity, and the transaction count plotted as time series. And you can kind of see basically the growth over time really easily. All the raw data is available.
00:24:11.738 - 00:24:57.114, Speaker B: So you could produce these plots yourself with the code and the data we provide. But we figured why not make it even easier just to quickly assess the growth. So that's like the growth in a particular token, we also have the growth for a particular pair. So it's a pretty simple little view here, but let me bring it up here. I don't know why that's kind of so small there, but basically it's the number of pairs with your selected token as token zero and token one. So you can see for a particular token, how often is it being used in a particular pair as a function of time really easily. And then we also have statistics on the pairs themselves.
00:24:57.114 - 00:25:31.362, Speaker B: So in this case, and maybe I'll just make this a little bigger here, let it rerender. In this case, it's like the number of daily transactions, the daily volume of the particular tokens in your pair union die. In this case, volume liquidity and liquidity for each of the two tokens in the pair. Time series graphs function at time just like before. And then we also have the liquidity token distribution for a particular pair. So it fetches that data. What it'll do is it'll rerender and should produce us a histogram.
00:25:31.362 - 00:26:23.430, Speaker B: So you can effectively see how many holders, the count of holders for each of the different values of the liquidity, the token distribution effectively so gives you a quick look at that. Okay, there's a couple more. Actually, it's really just one more, but it has several features of the visualization. So another feature we added was like, what if you want to a little bit assess the performance of your own swaps. And so what we did is you can pass in certain addresses and you can basically fetch the swap records of those addresses. And then that data, it tells you basically how much was swapped for what, when was that done, details of that transaction. And then what you can do is there's these visualizations you can produce.
00:26:23.430 - 00:27:18.134, Speaker B: And let me go ahead and do that and let me make it a little bigger here. Just expand that window a little bit and let this plot rerender. So basically what you can see the cumulative number of swaps over time that were made, the cumulative USD amount swapped over time, the total number of swaps of each pair. And you can see there's a lot of pairs, in this case the count of each, and basically for each token, the total number of swaps where that token was involved in the swap. So it's like sort of a global view of a particular person and their trading patterns and how that's changed over time and how successful those swaps have been. Cool. So that about wraps up.
00:27:18.134 - 00:27:54.178, Speaker B: There's actually like several more functions I'm not covering. There's just a lot of features. The README kind of covers all of them. So if you're interested in more, please check out the GitHub README. But that kind of gives you an overview. Pretty quick setup using the Python Reticulate backend utility and trading functions for actually making the trades data, pulling functions for pulling data on token statistics, pair statistics, and then some visualization functions for actually exploring that data. So we really hope it's a valuable contribution to the community.
00:27:54.178 - 00:28:42.930, Speaker B: We want Uniswap to be accessible to people who have our experience, and likewise, we want people who have our experience to have a little bit of, I guess, confidence that they can pick up a new platform. And if they want to integrate some of these functionalities and trading functions into their scripts and routines, this just should make it a lot easier for them to do so and more accessible to the community as a whole. So that's about all I had. Let me check in the chat. Good question. So this question says, where is the actual raw data stored on your servers or local to my machine? And the answer is, local to your machine. So basically, if you're familiar with R, what happens is you have the notion of a global environment.
00:28:42.930 - 00:29:09.882, Speaker B: This is my global environment. So, for example, when I pulled that swap data just now, I have in memory a storage of, like, 92 observations of 17 variables. That data is living in memory on my machine. And so everything's local to your machine, nothing stored on a server once you pull the data into the session. Cool. Okay. Yeah.
00:29:09.882 - 00:29:24.660, Speaker B: If there's any other questions, happy to take them. You're welcome. Otherwise yeah, I hope you enjoyed, and please do let me know if you have any questions or feedback on the package as a whole. Cool.
00:29:27.270 - 00:29:38.850, Speaker A: All right. I don't know, Eric, if you got the one question, I might have missed it. Do you use the graph as backend?
00:29:40.890 - 00:30:25.170, Speaker B: I'm deflecting a bit because I need to double check what Python package uses as the back end. I believe the answer is that it does, but I can't say with 100% certainty. So what we're basically doing is we're going to the Uniswap Python package with Reticulate to basically use the same routines they're doing. And so I want to just double check what exactly they're using as the back end there. I tried to motivate why we did that a little bit, which is mostly because we wanted them to be really consistent with one another if features that are being done there are effectively available to Uniswapper and R by nature of the dependencies.
00:30:28.810 - 00:30:57.994, Speaker A: Awesome. Any other questions, now's your chance. Or you can probably reach Eric in the Unicode Omni Analytics discord channel. But if that's it. All right. Thank you, Eric. That was awesome reminding everyone this is recorded so you can refer back to it on the East Global YouTube.
00:30:57.994 - 00:31:10.160, Speaker A: Probably be up in about a half hour. And with that, I'd. Like to thank Eric from Omni Analytics and wish everyone a good rest of your day.
00:31:11.490 - 00:31:14.330, Speaker B: Thank you so much. Bye.
