00:00:12.270 - 00:01:35.390, Speaker A: Thank you. Yeah, so I'll be talking about this work with joint work with David Parks. So in this work we ask about, very similar to what Tyrone was talking about is how we can think about designing decentralized exchanges or DeFi protocols that can be audited by users, where they have guaranteed that they're not being manipulated by or MEP has been extracted from them. And that's the concept of being verifiable. So a little bit of the motivation we need to go back and understand, okay, why do we care about decentralized exchanges? And the traditional way we think about it is, well, with a centralized exchange you have to have give custody to your assets to some centralized entity where the decentralized exchange doesn't require that. So you have limitations like FTX where you rely on that centralized entity to provide security for your transactions. But the main limitation of the decentralized alternatives that we have, as we've been talking about today, is the problem of mev extraction or market manipulation that happens on these decentralized exchanges.
00:01:35.390 - 00:03:10.506, Speaker A: I think here what's interesting question is how we can solve the problem without breaking. The main thing that you want is that we should not rely on solutions that rely us should trust in a centralized entity, because otherwise why you bother here? How is it designing works? I often give this talk to people who don't even know what bitcoin is. So the high level ideas that the user expects from this interaction with exchanges, that they think they're going to be sending that transaction to the blockchain and to this contract. But in fact, there is many entities in between and that's even getting more complicated, right? We have flash bots or we have relays, and the interactions are just getting more complicated over time. For the users though, they think they're just going to get their transaction executed in the exchange. But in practice you have builders, the builders, they are promising they're going to sequence transactions in a fair and honest way and these transactions are going to execute in this particular order in the exchange. And here in this particular talk, I'm going to be focused on unuswap like exchanges, but it also works for our solution for removing mev, works for order books on other types of exchanges.
00:03:10.506 - 00:04:15.170, Speaker A: But just keep in mind that the solution I'll be thinking about is for uniswap like exchanges. And what goes wrong here is that the problem with uniswap is that the builder, if they're being strategic, what they can do is that once they see, for example, that transaction B two wants to buy ethereum, they're going to buy ethereum before the user, which makes the price of go up and they immediately sell. So that's what we call the mev. It's the profit that's being extracted by these strategic builders. And here is just a picture of that, where I'm often going to be using these pictures, where I'm going to use blue arrows no transactions for users, red arrows transactions from strategic builders. But in practice the users don't see, they can't see what's a blue edge and what's a red one and edge is. Moving to the left is just buying some token and Ads moving to the right is selling tokens.
00:04:15.170 - 00:05:08.770, Speaker A: And the mev that's being extracted from these exchanges here have a graph showing how much has been extracted from uniswap in the ethereum blockchain. This is just not only uniswap, but most of the mev is currently on that. So what can be done? How can we have been approaching this problem? So there's a few solutions. One of them is this idea of batching auctions like call swap, where the idea is that we are just going to settle transactions at the same price for everyone. And intuitively that means that everyone is going to pay the same price, then you're not going to have mev. And there's a few challenges of that. There's often higher costs, higher latency, and you're essentially designing a new exchange if you're implementing a batch auction.
00:05:08.770 - 00:06:14.006, Speaker A: Something that's also very common probably in this conference is what we could encrypt transactions. If transactions are encrypted and people don't know what your transaction is, then that remove mev. But we still have challenges in actually implementing these solutions in practice. One, for example, if you're encrypting a transaction, you have to eventually decrypt it and then you have to figure out what should you do if someone doesn't decrypt that transaction. It's nice in theory, but there is a lot of challenge to make this work. And I think the main solution that we really have is we could use a relay service bots, but that's not auditable, right? You really have to trust decentralized entity now to really not be manipulating the execution ordering of transactions. And that solution is very efficient, right? We really require this entity to do all the computation off chain and if you can trust it, then that'll be great.
00:06:14.006 - 00:07:30.634, Speaker A: So that's really what inspired us to think about this problem of the mev extraction is how could we build something like a relay that can be trusted without relying on complicated cryptographic tools? So our solution is essentially going to be a game theoretical solution and a mathematical and game theoretical solution that doesn't rely on advanced crypto like NPC. I'm not against that, it's just that I think there's a lot of challenge on how to implement that. And again, I think all the solutions that can be combined, there's no reason why we can combine the solutions in practice. And I'm going to give you a solution. How can you in particular focus on building relays that can be trusted by users? So the solution is as before, what we're going to have is a sequencer which is this entity that's really promising. He's not going to manipulate your execution ordering of transactions, so he's going to make a promise that's not going to do it. But importantly, he's going to give you a way for you to verify that promise that he's giving you in the sequencer.
00:07:30.634 - 00:08:42.638, Speaker A: He's still going to be able to include transactions in the input because the sequencer is just algorithm that picks a set of transactions, he can still add his own transactions there. And you want to ensure that you can design a sequencer that even if he can manipulate the input, he cannot be profiting by picking a particular execution origin from the output. So our main result here was that we proved that there is a nice sequencer that ensures that for every transaction that is executed, that transaction is going to get an execution price. That's at least as good is that that transaction was the only one executing, right? So the setting where the transaction is the only one in the block. So this is what it's saying. You either get the price you'd be getting if you're the only transaction executing or you might be getting a worse price than that price. But provably, no one is gaining mev from your transaction.
00:08:42.638 - 00:09:31.362, Speaker A: That's the provable guarantee or equivalent statement. Here to take the converse of this statement is that if someone is extracting mev from your transaction, then the price you're going to be getting is at least as good as your transaction was the only one executing. So it's a very strong guarantee that minimum execution price guarantee for the users that we are providing. Okay, so a little bit of background what we mean by a verifiable rule. First, the model. So the model we are only going to rely on, our algorithm can only rely on the particular information. It only rely on the fact if a transaction is either buying or selling token one or token two.
00:09:31.362 - 00:10:15.760, Speaker A: So we have two tokens one or two. So every transaction is either buying or selling and we are not going to rely on timestamps at all. And the rule can also rely on the volume of trade. But the rule I'm going to give you actually doesn't even rely on the volume. It's just going to rely on the fact if you're either buying or selling a token and not going to rely on timestamps. So a formal model, what we mean by a sequence row, a sequence row is just a function that's mapping the state on the exchange. So X is the state on, for example, in swap exchange, which is the liquidity that's stored in the contract.
00:10:15.760 - 00:11:20.884, Speaker A: And then we are going to have all the inputs are going to be the set of transactions that go into the function. And sequencing rule is just mapping this estate and the set of transactions to what we call a valid set of orderings. So it's an abstract mathematical construct sequencing with just a function mapping a state and a collection of transactions to valid orderings in the sequencer. The person who's going to be running this function, he can add or censor transactions. He can modify this particular set t one to TN. And some things you want to have for practical reasons, it should be efficient to find if I give you a function, you should be efficient to actually compute some ordering, right? If you want someone to run your sequencer, they should be able to compute it efficiently and it should be verifiable. And that's very important here.
00:11:20.884 - 00:12:36.360, Speaker A: That's really the catch. What you want is that if someone later he posts on, for example, in the blockchain that the execution ordering is this particular ordering t, and the initial state on the exchange was X, someone should be able to check if this execution ordering you're seeing really belongs to that valid collection of ordering. And that's really important here because otherwise someone could if it's not verifiable, there is really no point in polynomial time because again, we care about being practical. So, okay, one what would be a dream sequencing rule would be a sequence rule that's mev proof, which means that no matter what so given a set of transactions, no matter how the person running the sequencer modifies the input, there is no way they can obtain some risk free profit. So that would be a definition of mev. You should not have any mev. So, unfortunately, we first show in this work that is impossible.
00:12:36.360 - 00:13:16.424, Speaker A: You cannot have a sequence probe that's mev proof. Although I show you that we can give a very strong guarantee, the guarantee we give doesn't mean that there is no mev, because what we do is that we remove bad mev, we remove sandwich attacks, things like that. We don't remove things like arbitrage between transactions. So that's what we mean by being impossible to have mev approved. It means that any sequence row is at least vulnerable to our arbitrage mev. Here a quick approve. I'm not going to go in details, but for those interested, my drawings are not working.
00:13:16.424 - 00:14:18.230, Speaker A: But in a high level idea. What we do is that we pick a particular example with this example with free identical buy orders, where you're buying two units of token one and free identical sell orders where you're buying one unit of token one. And essentially what you do is you show that for any particular ordering that you pick, there was a way to assign some of those transactions to the sequencer, the person running the algorithm, and you showed that if he owned those transactions, he would be getting a risk free profit. So that's essentially the impossibility result. So you just check all possible permutations and show that there is a way to extract mev. So now I'm concrete to give you the rule that gives the positive result that I mentioned. What we do is that, okay, initially we're going to have the initial state on, for example, UNSWAP.
00:14:18.230 - 00:15:36.486, Speaker A: It could be other exchanges, but UNSWAP is easier to describe and we are going to have the set of transactions that we want the sequencer to sequence, which we call the set of buy orders and the set of outstanding sell orders. And the output of the algorithm is execution ordering of transactions. The order transactions are going to go to the exchange. And what the algorithm is going to do is that while you still have buy orders and sell orders that you still have to sequence, then you simulate what the state of the exchange is going to be after you sequence. So you look on the transaction, you have a red sequence and you simulate what the state of the exchange would be at that point and you look on the amount of token for them, token one that was at this particular state relative to the state on the beginning of the block. And if that's true, that means that if you execute a buy order at this particular point in time, that buy order is going to actually be happy. He's going to get a better price than he would be getting if he was executing in the beginning of the block.
00:15:36.486 - 00:16:36.090, Speaker A: So what you do, you add a constraint that the next transaction to execute must be a buy order. Otherwise you add a constraint that the next order to execute should be a sell order. Eventually you reach a point where you don't have more outstanding buys and sells, which means that you only have buys or sells left. And we say that you can let the sequencer do whatever he wants at that point here. So an example. So if you have a set of free buys and free sells from the impossibility results so what you do in the beginning you can sequence a buy, then you are forced to sequence a sell, then you're forced to sequence a sell. Then you can either sequence a buy or sell and then you're forced to sequence a sell.
00:16:36.090 - 00:17:34.270, Speaker A: And in this point though, you don't have more cells left, which means a sequencer can do whatever he wants, but you only have a buy order anyway. So you sequence a buying. So another example of why does this remove mev from for example, a traditional sandwich trade? So what's a sandwich trade? You have the users buying a token, what the adversary is doing, he buys before the user and then he immediately sells. So what do you do? So this particular ordering is not valid. So why is that? Because once the sequencer buys a token one, the rule says that the next order to execute must be a sell. It cannot be a buy because you still have outstanding buys and sells. So this would be an invalid ordering that anyone can check and verify is violating the rule.
00:17:34.270 - 00:18:46.440, Speaker A: What the sequencer would force, the sequencer would do is force the sandwich trader to immediately sell if they try to sandwich a transaction. And by that he really doesn't get any profit from that. So the only valid orderings are the ones on the right and you can just check that any of those are you can't extract any mev from those trades. So a high level idea of how you prove the guarantee. So recall the guarantees that for any transaction that executes, if AMEV is extracted, then that transaction is getting a good price. The high level idea is that we divide the ordering that you see into groups we call one, we call the core. The core are the transactions that are being sequenced when you still have buys and sells to sequence after and for those transactions, almost by definition that they are happy for the transactions where you only have buys or sell left.
00:18:46.440 - 00:20:16.552, Speaker A: And here essentially what you argue is that the sequencer, he can only lose money if he tries to extract mev from transactions. And the tail, for example, if the malicious sequencer has buy buy, he actually would rather have his buy order be the first one of any user transaction and then you only have transactions from the user after any transaction from the adversary. But that essentially means that you're not extracting mev, right? Because you're not executing any transaction after the user. And the sequencer is also efficient to compute. It's essentially just a grid algorithm and it's verifiable because you can check, you look almost by definition that it's verifiable and the impossibility. So it's the same example as before. So why is this sequencer issue vulnerable to mev? Well, it gets mev from arbitrage from the user trades because for example, here if the sequencer owns transaction B one and this choose sell orders in red, on average he's getting some profit by doing this.
00:20:16.552 - 00:21:22.334, Speaker A: But every transaction is actually but what we do, okay, look, on the point of view of the user, the user is actually happy, right? So this user is getting a good price, this is getting even better price that he would be getting out of your eyes. The last transaction is actually getting a worse price. But the sequencer really doesn't profit any he's not really profiting anything from that transaction. He really doesn't care if that transaction was even there. So to summarize in this research agenda, we've really been thinking how we can modify these interactions on this protocol so that they become more robust to these manipulations that happens on blockchain contracts and we can prove a strong guarantee on this particular framework. There's some interesting questions. For example, the impossibility result only apply for deterministic rules.
00:21:22.334 - 00:22:22.120, Speaker A: Again, I think there's an interesting direction here how you can combine other tools like randomness or you have timestamping I think those could be ways to go get red possibility. Our rules also apply for two token exchanges like uniswap but not more and the sequencer can still get some profit. It's still interesting to potentially if you want to that's still mev, but it's not bad mev. But you still might be interested on how you can quantify this work. Again, we've joined with David Parks and be presenting at Stock next month. I heard was the first blockchain paper at stock. So I think there's definitely a lot of interest in the research community on these questions that come out of this community.
00:22:22.120 - 00:22:29.320, Speaker A: I think there's a lot of potential, like to collaboration. So thank you very much. If you have any questions, I'll be here.
