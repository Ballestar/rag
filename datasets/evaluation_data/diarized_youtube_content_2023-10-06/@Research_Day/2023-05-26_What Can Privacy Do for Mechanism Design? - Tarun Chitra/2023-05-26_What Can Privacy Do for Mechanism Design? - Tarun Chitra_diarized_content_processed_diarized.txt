00:00:10.740 - 00:00:59.530, Speaker A: Thank you. Also, you know, I think this is the first time Robot has ever co hosted an event. So thanks a lot to MJ for making it very easy to do this. But yeah. So today I'm going to talk a little bit about, um, privacy and mechanism design. There's sort of some theoretical questions and some practical questions. And I think the long story short is that there's a bunch of things related to the topics de jour today of intents and other stuff that you kind of change how particular mechanisms operate, their guarantees, their economic guarantees, if you have particular privacy preserving mechanisms or not.
00:00:59.530 - 00:01:52.200, Speaker A: All right, well, the number one thing to start with is ZK and Fhe promise a lot. In theory, they're supposed to give you this privacy preserving machine learning. I would segment it into the middle. Part of this kind of pipeline is the part that ZK helps with. Fhe sort of helps with the full input and output privacy. They're supposed to give you incremental verifiable computation, like classical IVC to the left, folding type of things to the right. These are kind of the best ways we know of for people to do large, complex calculations, but also be able to give you concise, succinct verifiable proofs that they actually ran stuff on your data.
00:01:52.200 - 00:02:47.100, Speaker A: So, for instance, if I give you a language model, and I wanted to generate a proof that the language model actually was trained on a particular data set and actually has real query knowledge from that, you would need to do something like this. And of course, succinctness, which is the key benefit, is that your little tiny cell phone device can verify stuff. Your big juicy solana validator produced the proof. But there's a big difference between the two of those energy consumption noise. But these are all pretty abstract benefits if you think about it. None of them are like, hey, I saved you this much money, or hey, your voting system was harder to manipulate. And in fact, I think it's always good to be aware of what the critics say.
00:02:47.100 - 00:04:21.208, Speaker A: But the critics this is actually Molly White commenting about the A 16 Z state of state of crypto thing and pointing out basically what I was saying before is none of these benefits so far are particularly concrete, right? It's like, I can't really tell my grandparents, like, hey, this is a reason you want ZK stuff and you should invest hundreds of millions of dollars into it. So there's sort of this very natural question to ask next, which is, are you stuck with a technology whose benefits definitely apply to everyone in a lot of different ways, but the verifiability aspect is only really useful to the sort of technical cognicenti as opposed to kind of the general populist. And so this brings us to this next point, which is verifiable mechanism design. So mechanisms that take advantage of these verifiable guarantees can provide better provably better economic outcomes, and those economic outcomes are much easier to describe. I saved you x dollars. This type of transaction took a lot less time this type of transaction took a lot fewer capital sources to execute. But Verifiable mechanism design is actually quite hard, and some of the hardness comes from computational complexity issues.
00:04:21.208 - 00:05:19.528, Speaker A: Like a lot of the stuff we saw in Chris's Talk, the last section, a lot of those problems are tfnp complete. So that's not exactly great and fun to work on. So what we'll do here is go through some examples of things where people were like, hey, we really want to make these mechanisms have X, Y, or Z benefit. And people are like, okay, we'll just add some ZK and hopefully everything works. And we'll talk through some examples of why that doesn't work and why Verifiable mechanism design is a bit harder. So, constant function, market makers, automated market makers, just adding ZK doesn't just generically help you. And so the simplest explanation of this is everything in finance has to have some public information, right? What do I mean by that? There's a price, there's an interest rate, there's a fee, there's a collateral requirement.
00:05:19.528 - 00:06:09.468, Speaker A: Those are all concrete public Desiderada that must be satisfied somehow, right? No one is going to trade with something where it's a black box and they can't see the price or the interest rate. On the other hand, you want some of the data to be private. But the problem is, in most DeFi systems, the public data is computed from aggregations of the private data. And so you can oftentimes invert that relationship by taking the public data and inferring something that's private data. So Cfmms, like uniswap curve balancer, et cetera, they all have this problem that the simplicity of them, which makes them very favorable in a blockchain environment. They don't require a lot of compute. Also is the reason that you can invert them and kind of figure out what people's trades were.
00:06:09.468 - 00:07:05.180, Speaker A: So the public data, the prices can be used to reveal the private data. So that's not good. So even if I put this in ZK and I hit blinded the reserves, it doesn't actually help you get full privacy for the swaps. So the second thing is, you know, I think Constitution Dao is perhaps people's most favorite example of why DAOs need privacy when entering auctions online. I mean, I think obviously the insult to injury is that Ken Griffin, I guess, was the one who frontrun you, but whatever. But the idea of auctions needing privacy and auctions being able to give people privacy are really important and there's been a lot of work on this. So, for instance, there is a ZK sealed bid second price auction on ethereum called Vikri.
00:07:05.180 - 00:07:55.256, Speaker A: But the thing is, all it does is really blind the bids. It doesn't actually have any mechanism for enforcing any of these kind of constraints that you might I'm hopefully whatever time I spend on this is helping the next speaker mateus because then he won't have to reintroduce this. But there's sort of an idea that there's three properties you want out of an auction. One property is seller incentive compatibility, which means that the seller can't add bids and increase their revenue so they can't add fake bids and cause themselves to earn more money. They can't censor people's bids and cause themselves to earn more money. The second is buyer incentive compatibility, which is people are incentivized to bid what they think the thing is actually worth. And the third is bounded communication complexity.
00:07:55.256 - 00:08:29.450, Speaker A: The bidders and the auctioneers only have to communicate with each other a fixed number of rounds. That doesn't depend on the number of bidders participating nor the number of items being sold. And you might say, okay, these all seem like some classical things. Someone in the 1970s, milgram in the 80s should have like, solved this, but actually in 2019, people showed you can't get all three. And it took a long time for the auction theory literature to get this kind of trilemma. It was the first time I've ever seen non crypto people use the word trilemma non ironically. So that was amazing.
00:08:29.450 - 00:09:24.996, Speaker A: So one interesting thing is these ZK steel bid, second price auctions, they don't actually satisfy seller incentive accountability. The seller can still add fake bids and increase their revenue. And so there's a sense in which just adding ZK did not solve the problem. And finally something I love whipping on a lot because I think it was one of the most broken mechanisms in all of crypto in spite of the fact that lots of people spent money working on it, is fair ordering. And so there have been a lot of these protocols that try to say something akin to I have a bunch of validators each validator gets transactions. Validator A gets transaction A before transaction B, validator two gets transaction B before transaction A. Can we kind of force them to pick one ordering where they can't choose the leader can't choose the ordering on their own, creating mev.
00:09:24.996 - 00:10:40.636, Speaker A: These fair ordering schemes, of course, run into classical social choice theory problems like errors impossibility theorem, which they usually try to claim that they get around most of the time, which turns out not to be true. And the crux of this is that fair ordering is this thing where it's a very nice concept, right? It's like I send a transaction before you, everyone agrees that I sent it before you, and no one can cheat. The problem with that is you have these sort of nontransitive dice problems where we have a bunch of people voting in an election and on average you have A beats B, B beats C and C beats A. So you get this kind of impossible staircase when you look through that. And one thing you might say is, well, okay, well, can we reduce the probability of those things happening and that's what most fair ordering protocols do. Now, one problem and one thing you can show is that while they do lower those probabilities, they distort certain economic payoffs. So particular types of DeFi protocols actually have worse price behavior when you use a fair ordering protocol.
00:10:40.636 - 00:12:34.600, Speaker A: So there's sort of this trade off between how much you restrict the orderings that the validators are allowed to choose versus how much you're restricting the set of payoffs that developers are allowed to make. And there's sort of this uncertainty principle type of thing that's there and sort of I think people kind of didn't appreciate that when they wrote the original papers. But this is another example of something where the mechanism design actually changes when you have certain types of private commitments. So now we get to this next question of well, okay, can we design mechanisms that do actually have these properties? I've mainly given you a bunch of negative answers, right? So those negative answers might make you think. Okay, well, I guess we're back to the Molly White thing of well, I can't convince my grandma to use ZK Uniswap to buy chocolate enu 100, but lo and behold, the last six months have had a bunch of research by people who have found ways to get actually good mechanisms that you get guarantees on. So this paper by Kineti, Fiat and Yunai, I'm not going to try to pronounce the last name, and this is the same Fiat from Fiat Shamir wrote this paper on ZK mechanisms, where what you do is you have people who take public randomness. So public randomness that could come from a blockchain, you force the seller to commit to a mechanism publicly and then from those commitments the bidders can send their pricing also committed and put up some collateral for not cheating.
00:12:34.600 - 00:13:40.110, Speaker A: And then basically what happens is the seller proves a bunch of assertions, so they prove a bunch of statements that are like certain inequalities that represent incentive compatibility. So I could prove to you that something is a Nash Equilibria without actually revealing the Nash Equilibria. It's a little bit weaker than that, of course, complexity theory wise, but these mechanisms actually provide good pricing guarantees on what such things can do. So an example of this is an auction where you take some public randomness. The public randomness is used to commit to a private reserve price. The private reserve price is sort of the auctioneer's action space, like what the minimum price the auction starts at Is, and then people commit their bids and then the auctioneer has to prove that certain properties hold for those and then they reveal the bidder and so the winner. And this type of system actually has much better guarantees than just the vicary XYZ type thing.
00:13:40.110 - 00:15:21.740, Speaker A: And this is a part, this is sort of this paper with me mateus, who's speaking next and shithaj, that's sort of relevant to some extent to this conference is I have this notion of preference expression or intents. Hopefully you saw Uma's talk earlier, because I think she did a better job of covering it than me or Flashbots or anyone else has done. But a simple way of thinking about this is like, I have these kind of multi chain expressions of something I want to do, and I want someone else to go fulfill it for me. So one question you might say is, what is the space of these intents? And do certain types of auctions allow or disallow these intents? And this paper, we sort of prove this fact that the set of intents you can represent actually grows when you use sort of ZK commitments and have collateral games. And so there's sort of this interesting thing where by mixing the right types of ZK commitments with particular types of collateral staking, you can actually achieve sort of all these properties you might want out of an auction. Another thing that I think people here are kind of into is order flow auctions and user surplus redistribution. And this is another example where these redistributions, actually ensuring that they make it to the user, relies on doing the right types of commitment schemes.
00:15:21.740 - 00:16:37.860, Speaker A: And the final thing I want to talk about is the notion of an auditable mechanism. And so I think we've talked a lot about Verifiability, right? Like everyone in Zkland will tell you about IBC, they'll give you a notion that a proof can be constructed, but what happens when the proof fails? How do I know which part was malformed or misgenerated? So a very interesting way of viewing this is one way of measuring how auditable a mechanism is, is how many users have to cooperate to detect cheating. So what I mean by that is, let's say there's 100 bidders in an auction, and the auctioneer does some action where they cheat and increase the revenue against the will of the bidders. How many of those hundred bidders have to communicate and what's the amount of communication they have to do. And so a very interesting thing that exists is the first price auction. It turns out you only need a constant amount of communication between the bidders to detect cheating. In the second price auction, you need a linear number of communication, linear amount of communication between the bidders.
00:16:37.860 - 00:17:29.136, Speaker A: But there exists audible ZK mechanisms that can only need a much smaller number of users to communicate to detect cheating. So a lot of the stuff you've heard today had mechanisms for detecting cheating, whether directly or indirectly. For instance, in Chris's talk about how to slash people. And so this notion of auditability is actually one step further than just Verifiability. It's this idea that when something goes wrong, I can actually figure out who cheated and how the cheating happened. So the last thing is like, well, how do you make products that take advantage of these that communicate to the end user these benefits. And a little bit like, uma, I think if you thought the maze for bridge transactions was bad, just imagine sending a shielded transaction in a mobile wallet.
00:17:29.136 - 00:18:18.036, Speaker A: The Zcash mobile wallet experience is one of the worst UX experiences in the history of this industry. It's like not even clear what's happening at all. And one interesting thing that can come from these kind of Verifiable mechanisms is you can give these types of guarantees like confidence percentages, like proving that there's a confidence interval. You will receive this rebate at the end of an intent being executed. Auditability, again, like showing that, hey, when something goes wrong, here's what happened, and being able to present that to the user. So I think the applications that sort of benefit will benefit the most. Order flow auctions, of course, which there's a lot of.
00:18:18.036 - 00:19:05.252, Speaker A: I put matching markets here and this is sort of a bit of a joke to some extent. So matching markets, of course, are how kidneys are matched to donors. But the more interesting thing is that the NFT marketplace, especially on the lending side, has moved to matching markets and is way less pooled markets. So we're going to start seeing people want some of these Verifiable guarantees there. And of course, the last thing is auditing some of these things. And again, auditability is a strictly stronger standard than Verifiability. So I think I didn't go into some of the details in these research, but some of the interesting things you find are sort of almost computational complexity type of things that happen.
00:19:05.252 - 00:20:19.980, Speaker A: So in our auction result, in this intent result, there's sort of this idea of I have an auction that satisfies all three of these properties, seller incentive compatibility, buyer incentive compatibility, and boundary communication. And one question you might say is like, what is the set of utility functions that users participating in the auction can have to get all three of those properties? And what we show is there's sort of an exponential separation between the set of those that you get when you use ZK commitments versus the set without CK. The other two are sort of more engineering things. And of course, I don't think there's any Zkml talks here, but there have been a bunch of those recently and these are sort of, I think, the natural next steps. So the final conclusion, I think ZK and Fhe, if you smartly with economic incentives, not just toss ZK in and hope it works, can improve theoretical and practical guarantees. There's sort of some weird new complexity class communication complexity thing going on that is not totally clear. So if you're a theoretical person, I think that that's one of the most interesting pieces of this.
00:20:19.980 - 00:21:03.300, Speaker A: Almost the way Papa Dimitru found Peepad by accident. I think this is sort of going to end up being that there's some type of class that gets found. These improvements definitely can make their way into practical applications. I think Mev is clearly the laboratory for testing these out, but I think for the AI type of stuff and ML stuff, there's definitely a lot that this is good for. And it's sort of our job to not just be in the Verifiable future, but the auditable future. Because I think the auditability is the type of thing that you can actually convince a user is worth paying for. That's it's.
