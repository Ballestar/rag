00:00:10.160 - 00:00:27.128, Speaker A: Cool. Okay, this is way too tall. I'm not that tall. Cool. So everyone, my name is Scott, founder and chief intern. And today I'm going to talk about something we haven't really quite talked about for quite some time now. Now that kind of goal loses.
00:00:27.128 - 00:00:55.564, Speaker A: And the Zeitgeist, we don't really talk about execution sharding as much. We talk about data sharding and so on and so forth. We kind of forget this kind of troubled child that is execution sharding that people just forget. So yeah, here's a calming sand slide to just kind of set the tone for the talk. This is going to be a very chill talk. Everyone has been spending the entire day listening to gigabrain stuff. I'm just going to say I'm pretty dumb.
00:00:55.564 - 00:01:23.724, Speaker A: And so this is not going to be super complicated in constructions and it's just going to be as practical as I tried it to be. So yeah, I rugged you guys. I actually have a proper slide design. Here it is. Quick introduction about myself for those of you who don't know me. Fun fact, it's like I'm an anime girl on Twitter and I also miss my college graduation to be here. My parents are very angry and they're calling me even 2 hours ago.
00:01:23.724 - 00:01:55.988, Speaker A: And why? I'm not in Berkeley. But yeah, I'm currently a founder at Arguslapse. We identify as a gaming company. We don't identify as an infrastructure company. We don't identify as a pick and shovel company. This is actually one of my biggest gripe is that everyone in crypto games wants to build these pick and shovels but no one wants to build the content or applications and that we just have no application that the user can use. And so we very much identify as a game company.
00:01:55.988 - 00:02:43.040, Speaker A: We build infrastructures to means to an end that we want to kind of build awesome games on chain. Previously I was the co creator of Dark Forest with my very galaxy brain friends Brian Gu and Alan Lowe. Brian is right now running zurich spark and many, many times smarter than me and, like, kind of the dumbest person in the room back then. As like, yeah. For today's talk, we're going to be talking about execution sharding, obviously, but we're going to be talking about execution sharding in a context that is unfamiliar to most of the discourse that we have about execution sharding in the past. In the past we would talk about execution sharding in the context of a layer one. We would be talking in context of okay, ethereum sharding or maybe neo sharding.
00:02:43.040 - 00:03:24.852, Speaker A: But today I want to kind of shift the context a little. Let's kind of think how would sharding look like in a roll up environment. And that's really kind of like today's kind of main topic. But I think most importantly, I think what underlies the question here is why is the game company architecting their own roll up? And what can we learn from World of Warcraft in designing roll ups. And last but not least, which I think is really interesting, is the fact that the design space for roll ups can expand way beyond an ha ha op stack for Gobert, which seems to be kind of like the reality right now. And to answer these questions, I want to kind of take you back in time. Back in time.
00:03:24.852 - 00:04:12.000, Speaker A: Just close your eyes and then we'll go back to 2020, right? This is like when Dark Forest, the idea was first concepted, we kind of asked ourselves, what if we created a game where every single game action is an onchain transaction? It was an absolutely absurd premise back in the day. Still an absurd premise to a lot of people today. But it was an interesting kind of like hypothesis that we had and so we sought on to build it. And this is like how Dark First was born. So Dark First is a fully on chain space exploration mr of TS game on Ethereum powered by ZK Snarks. ZK is like the coolest thing that everyone wants to do these days. But trust me, in 2020, no one really wants to be in ZK because documentation is pretty much nonexistent.
00:04:12.000 - 00:04:47.550, Speaker A: I remember when we were building dark forests, the only documentation for circum that is available is Jordy Belina. And Jordy Belina is Google Docs. And so that is like an amazing experience and we learn a lot from that process. And Dark Forest is the manifestation of that. And so with Dark Forest, it's an experiment gone bigger than we thought it's going to be. We had like ten K plus players, trillions of gas spend, and tons of onchain chaos with people backstabbing each other on chain. And it's all publicly traceable, so people know who's backstabbing who.
00:04:47.550 - 00:05:36.888, Speaker A: But the most fascinating thing about Dark Forest and what we learn or why on chain games are interesting is this nature of platformization. Like in a traditional game, you would see kind of like if you build a game, the developers tell you that this is a gameplay you're going to have. We're pretty much stuck with that, right? But by having an onchain game, you open up the design space for emergent behavior and you allow people to build smart contracts and that compose with the game. So for instance, people would create player corporations, information marketplaces and so on and so forth, all without having to ask for the permissions of a game developer. This is kind of one of the benefits of building a fully on chain game. And people would also build things like alternate clients. People would fork our kind of code base or smart contracts to build alternate game modes.
00:05:36.888 - 00:06:26.872, Speaker A: One of them being a Dark Force arena, which is like a more like a mobile style game instead of like Mmrts. And even people wrote GPU Miners to kind of play the game, which is absolutely insane. And just kind of completely overwhelms us in terms of demand and excitement. And with great power comes great responsibility. When we launched Dark Forest in Exodi, which is now known as Gnosis chain, which is like an EVM side chain which is supposed to be high throughput, we ended up filling the entire block space of the chain. And of course shit starts happening like a bunch of protocols that want to do things like liquidations. The DeFi protocols, they can't liquidate stuff because there's a bunch of these in game transactions flooding the chain.
00:06:26.872 - 00:07:11.464, Speaker A: And that essentially for every week that Dark Forest round was running. The Exodus chain is pretty much unusable for anything else, including DeFi, NFTs or even the bunch of dai stuff that they have there. And so the question is like what now? Are we on a dead end that on chain games will just never be a reality? Is it just like too crazy of an experiment? And yeah, the answer is we just give up. We go back to making games where the only thing on chain is JPEGs and convince people that money grew on trees. Disclaimer this game asset is not ours. If you're an investor, it is your portfolio company. I'm sorry, but yeah, I think TLR.
00:07:11.464 - 00:07:51.284, Speaker A: JK the solution here. We make software do things. I think a lot of us really think about blockchains and roll ups in a very like, okay, this is how blockchains have always been designed. It's like how roll ups have always work and therefore there's not really much room for improvements. But I just disagree and we just fucked around and find out. And we kind of create this postmortem of Dark Forest, right? We ask ourselves the question of if you were to design a blockchain from the bottom up for gaming and gaming only, how would it look like? Right there is kind of like a very kind of high level requirements that we have. First and foremost is that we need high throughput.
00:07:51.284 - 00:08:33.670, Speaker A: So things needs to scale both reads and writes. So one non obvious thing is here is that most blockchains are designed to do a lot of rights. Transaction per second is the metric that people tout. But the reality here writes are not the only thing. You also need reads for people to build blockchains. How would you know where the player locations are if you can't read from a blockchain node? And this is actually the first bottleneck that we found with current blockchain constructions. Like Dark Forest had a problem with just get full nodes being kind of absolutely hammered and disio exploding because we just need to read data from the onchain state.
00:08:33.670 - 00:09:04.272, Speaker A: And this ended up racking thousands of dollars of server costs that the Xdai team gladly fronted for us. But of course it's non ideal for long term. So we need high throughput not only for writes transaction per second, but also for reads. Like getting data from the blockchain itself. We also need to have a horizontal and scalable blockchain. We want to avoid noisy neighbor problem. We don't want to have a game that is becoming popular and suddenly just starts flooding the blockchain and stopping everything from working.
00:09:04.272 - 00:10:04.640, Speaker A: We also want a flexibility and customizability so we can modify the state machine to be designed for games. So things like having a game loop making itself executing and so on and so forth. And last but not least, and this is maybe kind of somewhat of a vague requirement for most people who are unfamiliar with online game architecture and it's high tick rate, right? And so what is high tick rate? So with tick rates, the key thing is to think about it is like ticks are the atomic unit of time in a game world, right? In a blockchain context we have blocks as the atomic unit of time. In games we have ticks. And this is pretty much analogous when you are building a fully on chain game where how fast your blockchain is ticking or how fast blocks are produced is equal the tick of the game itself. And so if you have a higher tick or you have a higher block, like kind of like block per second, the game feels more responsive. And on the contrary, if you have lower tick, the games feels more sluggish.
00:10:04.640 - 00:10:47.628, Speaker A: And there's also one key thing here to keep in mind. If a block production is late, you will visually feel a lack in the game. And this is terrible experience. And if you have ever dealt with an angry gamer screaming on a computer because they lost a game, it's an absolutely terrible market kind of crowd to deal with. So right now we know that current roll ups have like one block per second which is equal to basically one tick rate. And if we want to have cooler games, we need higher tick rates for give you an example like Minecraft, which is like a shitty cube pixel art game, have 20 tick per second. And so we have a long way to go to be able to kind of build games that are responsive like Minecraft.
00:10:47.628 - 00:11:30.396, Speaker A: And this is what we sought to solve with kind of our construction as well. And it's clear to us that one of the possible solution is maybe deploying your roll up, right? Like why don't we just fork op, stack and move on and just be there. The reality here is it looks like it solves the problem on the service level, but it doesn't actually solve the underlying root cause of the problem. So for instance, you would have higher throughput and writes but not quite at the level what the game needs. Sure, if your games have 100 players, it will be enough. But if you want to build games that are much higher throughput, there is very strict limitations there because of how this I O is done. In current Get constructions reads, you don't really get the performance boost.
00:11:30.396 - 00:12:11.288, Speaker A: You still need to rely on indexers, let alone game moves. Even NFTs we need indexers for. And you don't really have horizontal scalability. If you try to spin up a new roll up to quote unquote, horizontally scale your blockchain, you're fragmenting your existing smart contract ecosystem like marketplaces that the player deploy wouldn't work with the other kind of chain where that is spin up to horizontally scale your game. So this opens up a lot of problem. And so last but not least is high tick rate and block per second is just not a thing. We can try and push it as hard as can.
00:12:11.288 - 00:13:06.572, Speaker A: We can get like a two block per second, maybe like three. But that's really kind of as far as how these blockchains are going to go because there are a bunch of overheads like remarkableization and stuff like that, that is very taxing on just like compute cycles. And so the way that we kind of try to fix this is like we go back to the past, back to the early 2000s, back to the late 1990s, where online games were just first coming up with games like MMOs, like Ultimate Online where they have this concept of sharding. This is not like a novel concept. These are things that have existed in the past. And so the funny thing actually here is that the name sharding itself that we use in database architectures would have actually come from Ultimate Online references. They were kind of like one of the first people who came up with the word sharding to kind of really explain this different servers that they have.
00:13:06.572 - 00:13:50.340, Speaker A: And so the question now is how does sharding even work in games? Right? Some people I don't want to assume that everyone in the audience play online games. So just kind of give you an example of how sharding works. And the key thing here to note is that sharding is not a one size fits all solution. It's a tool in the toolbox. And the way that you fit it in your game differs from context to context. So for instance, in the first sharding construction is like what I like to call the location based sharding. A good mental model of a way to think about it is imagine if you have a cartesian diagram and then you split it into four quadrants and then each quadrant has its own game shards.
00:13:50.340 - 00:14:44.536, Speaker A: And every time you want to cross a shard, you basically kind of make a communication to the other shard like, hey, I want to move there. And then you basically get teleported to the other shard and you leave your kind of previous player body behind and you kind of essentially get teleported to different sharks. So this is the first construction that is possible. By doing this, you are essentially distributing the workload of the server into multiple kind of physical instances instead of forcing a single server to do all the computations for the entire game worlds. The second construction is what is more popular these days. It's called the multiverse sharding where basically you would have multiple instances of the game that is mirrored with each other, but you can basically choose whichever shard that you want to go to. And it's like load balance by default and so on and so forth, such that each server is not getting too congested and so on and so forth.
00:14:44.536 - 00:15:50.432, Speaker A: And again, with these charts, these are kind of separate instances instead of like a location charts where it's like an example in the previous slide. And so now kind of like the key question here, right? There's a lot of these theorizing, a lot of ideas, squatting. I don't know if you have people familiar with the term, but how do we bring this concept to roll up? And this is why we created the World Engine. The World Engine is our kind of like flagship infrastructure which is basically an opinionated shared sequencer design for sharding. And in contrast to a lot of the shared sequencer design that we've seen in the past few talks, we are not optimizing for atomic bundles, we are not optimizing for synchronous composability. What we are optimizing for is a trueput and B we want to make sure that there's no locks that is blocking the runtime to make sure that the tick rate and the block time is as efficient as possible. And so again, it's default asynchronous and the way that we design a sequencer is such that it's partial ordered instead of forced total ordering where each transaction needs to happen after the other.
00:15:50.432 - 00:16:44.620, Speaker A: And the key component here is that we have two main things. We have the EVM base shard where it's like a shared EVM chain where players can deploy smart contracts to compose with a game, create Marketplaces, DEXes, what have you. And it's going to be like a normal chain, right? Like one block per second or one take per second, just enough for you to go do all your kind of typical DeFi and marketplace stuff. And the key kind of like secret ingredient here is that we use a game Shards, which is essentially a mini blockchain designed to serve as a high performance game server. We have a bring your own implementation interface such that you can customize the shard to your liking. You can build your own shards to inject to the base shard. You just need to implement a standard set of interfaces the same way that if you're familiar with Cosmos, cosmos have an ABCI interface, you can just basically kind of conform this similar spec to kind of bring your own shards to the World Engine stack.
00:16:44.620 - 00:17:18.696, Speaker A: And the key thing here is that we have a high tick rate that we currently can't achieve with current blockchain constructions. And so this is where I want to introduce Cardinal. So, Cardinal is the world engine's first game Shard implementations. It uses the Nd component system which have this data oriented architecture which allows us to paralyze the game and have higher throughput for the game computations. It has a configurable tick rate to up to 20 ticks per second. So for the blockchain people here, that's 20 blocks per second. We can also geolocize this to reduce latency.
00:17:18.696 - 00:18:04.968, Speaker A: Right now you have sequencers that maybe is based in the US and then people in Asia, every time they want to submit a block, they will have to wait, I don't know, like 300 millisecond latency before that transaction hits the sequencer. This is a huge problem in games because 300 millisecond is a long long time. If you try to play an FPS game with 200 millisecond, that is essentially forever and you're already dead. And the key thing here that is also important for us is that it's self indexing. We don't need to have an external indexer anymore. We don't need these frameworks to basically cache us the game state. And this also allows us to build more real time games that doesn't have this latency issues because the indexer is still trying to catch up with the sequencer blocks.
00:18:04.968 - 00:18:49.620, Speaker A: We also have a plugin system that allows people to have an in protocol, paralyzed ZK verification and so on and so forth. And the best of all, at least for me, is that you can write your code and go. So no more wrangling with Solidity trying to kind of make your game work which I don't know if you've tried to build an onchain game in Solidity before, it's an absolute nightmare. But yeah, the key thing here with our Shards construction is that you can build anything as Shards. There's basically an infinite design space of what a Shard can be. It can be like, let's say you hate writing your game code in Go. Again, we're working on a Solidity game Shard that allows you to write your game implementation in Solidity while preserving a lot of the benefits of Cardinal.
00:18:49.620 - 00:19:32.376, Speaker A: And you can also maybe create an NFT Minting Shard with a unique mempool and ordering construction that will solve things like the basic Minting noisy neighbor problem. Or you can even have things like Game Identity chart where you can use NFT to represent your game identity and allows you to trade your game identity easily using NFTs instead of having to, I don't know, give your private key which is not advisable more or less. This is kind of the high level construction. I will not dive too deep. Just kind of the concern of time here. But the key thing here, we kind of basically allowed EVM smart contracts to compose with the gamesharts by using custom precompulse. And so this basically kind of create a wrapper around get to allow this to communicate with each other.
00:19:32.376 - 00:20:21.396, Speaker A: And that's really kind of like the way that we are able to access this different game shard data. And this opens up a lot of the design space as well, bi directionally. And again, to reiterate, we're asynchronous by default we have seamless composable interoperably across shard without locks. And again, this is kind of like the key thing of how our shared sequencer is different is that instead of using a shared sequence construction that prioritize total ordering atomic bundles which requires blocking mechanism and which leads to a lot of issues for us. For instance, it blocks the main thread which leads to unreliable tick rate and block time, which leads to game lags. It also imposed restrictions on block time for each shard and require various crypto economics in construction to prevent the analysis of service. And there's also one big elephant in the room that I haven't really seen mentioned with a lot of ECR sequencer construction.
00:20:21.396 - 00:21:23.800, Speaker A: It's like how do you resolve deadlocks? If you have kind of these different shards that are dependent on each other and causes a deadlock, how do you resolve those deadlocks? With asynchronous design, none of this is a problem because everyone is just like doing whatever they want to do and fire and forget. The reality is, atomic bundles across charts and roll ups are often not necessary for our use cases. We don't need anything that requires atomic bundles at all and we just don't think it's something that we should engineer our roll ups around to just kind of for just the sake of use case purity and all of that. And so it also leads to a lot of other interesting properties. So for instance, each gameshart can have a separate dealer for the base chain. So for example, you can use the base shard to push data to ethereum and then the gameshots can push data to slash or like a data availability committee. And you can also ease the hardware requirements for running full nodes because you can run base shard, get full nodes separately without having to run the gameshart node which kind of makes it easier for you to integrate with things like Alchemy and so on and so forth.
00:21:23.800 - 00:22:36.576, Speaker A: And so I think to just kind of wrap things up, I just want to be intellectually honest here because I think a lot of people really kind of want to claim that their construction solves all life's problem which is just not the case for us, right? We tick the boxes that is useful for us, but maybe it's not for your use case. It's just not realistic, at least for how we approach things, to assume that our construction will work for every other people's use cases here. So it ticks the boxes for us, gives us the high throughput, gives us the horizontal scalability, gives us the flexibility and high trick rates, but it doesn't cure cancer. If you need a DeFi protocol that requires synchronous composability then this construction might not be the right one for you. And so I guess to kind of conclude all of this is that I really believe in this concept of a human centric blockchain architecture. This is kind of like a word cell, kind of like slide. But the key thing here is that by designing around a specific user persona and use case in mind, you can reason to architectural trade off space better instead of trying to solve for everyone's problem, right? The roll up renaissance is here and everyone can design their own roll ups to their specific needs instead of relying on generalized solutions.
00:22:36.576 - 00:23:12.730, Speaker A: And what I believe we should do is embrace the Cambrian Explosion, right? Don't build roll ups like one size fits all, layer one, because it's just like simply not designed to solve the same problem. And I'm personally excited to kind of see more people explore more roll up design spaces that is kind of like use case or sector specific. So instance, what does a roll up design for axe Exchange and nothing else look like? Is it going to be intent based? And what does a roll up design for on chain clubs going to look like? And so with that being said, I'll kind of just give the mic back to MJ and thanks for having me.
