00:00:00.470 - 00:01:11.882, Speaker A: You. Okay, so the talk will be in three parts. First, I'll describe just the basics of what is an encrypted mempool and the design space. I'll talk about the motivation in part two, and then kind of the fun part, part three, the more technical part, where we talk about metadata, because it's all well and good to encrypt the payload of a transaction, but really all the metadata that comes with it also needs to be encrypted. Okay, so what is the simple framework of an encrypted mempool? Really, the key idea is that you want to encrypt your transaction off chain before it goes on chain, and you want to have some sort of commitment to the inclusion, to the ordering of that encrypted transaction before you decrypt. So you have encrypt, commit, decrypt, and then execute. And one of the questions you might ask is, does this kind of add latency to the whole user experience? And the answer is not necessarily.
00:01:11.882 - 00:02:11.970, Speaker A: You can do all these three steps in one slot, all in one go, behind the scenes. So one of the important things that you need for the encrypted mempool is some sort of encryption scheme that guarantees that the ciphertext will eventually be decrypted. Like commit, reveal doesn't work as quintus alluded to. And there's basically five different families of encryption that I've identified with this property. So you can have basically private, end to end encryption where you have a centralized entity that's maintaining this encrypted mempool. So that would be flashboard protect. You can have enclaved based encryption where you're trusting the integrity of SGX.
00:02:11.970 - 00:03:02.382, Speaker A: There's threshold based encryption, which seems to be the most popular approach with Arbitrum, Shutter and various others. There's delay encryption that Starquare is looking into. And then there's witness encryption. Witness encryption, if you're not familiar with it, it's a very, very powerful primitive which allows you to have Arbitrarily complex and flexible decryption predicates. So you could say decrypt if something happens. Like, for example, you can have a snock of an arbitrary statement be a decryption. So one example could be if the chain has finalized, the chain that includes the encrypted transaction has finalized, then decrypt.
00:03:02.382 - 00:03:55.060, Speaker A: And so you can think of witness encryption as being a generalization of all these other decryption mechanisms. Now, in terms of readiness, we already have things like Flashbot protect, and I believe that the technology is fundamentally ready. SGX is there to have things like enclave based encrypted mem pools. And threshold encryption is also pretty much there delay encryption. One of the hard bits there is that you need a VDF ASIC. We actually by we, I mean, the FM Foundation and Protocol Labs actually went through the effort of designing an ASIC. And we have samples, so we've manufactured samples, and they're going through the process of being packaged right now, and they'll be tested in a few weeks.
00:03:55.060 - 00:05:09.782, Speaker A: And witness encryption is basically this Moon map piece of cryptography, which is not at all. Ready right now. Now, one of the important things that I want to highlight here, and this is where I kind of disagree a little bit with Phil and Quintus, is that you can have perfect encryption. Basically as a user, you can leak no information, but you can still be not blind to user outcomes. So basically the encryption system itself can be aware of the transactions that it's manipulating and it doesn't have to randomly include these ciphertexts or blindly include them on chain. It can actually kind of look under the COVID of the encryption in such a way that the user doesn't have to leak any information. So that's called homomorphism, where basically you're given ciphertexts encryptions of messages m one and M two, and you can compute functions on these functions on these encryption ciphertexts and it's actually trivial to do homomorphisms in the trusted context.
00:05:09.782 - 00:06:24.162, Speaker A: Right? So if you have an encrypted mem pool like Flashbot Protect, they get to decrypt privately the transactions and they can run the functions on that. And it's the same thing for SGX, right? SGX, you have the in flight encryption between the user and the enclave, but then the enclave will have plain text access to the message. But then as you become more and more sophisticated in your encryption mechanism, the homomorphisms become more and more complicated. Okay, so motivation on why do we want encrypted mempools? I think there's basically two reasons. One is front running and the other one is censorship. So front running is easy is this idea that if you can't see the payload of a transaction and you can't see the metadata, then you can't kind of meaningfully front run transactions. So for example, a sandwich, if you want to sandwich a transaction, you need to know which pair is being hit.
00:06:24.162 - 00:07:23.746, Speaker A: You need to know that it is a trade in the first place. You need to know the size of the transaction, et cetera, et cetera. But kind of a related aspect is centralization. So one of the bad things of mev is the centralization force. And we can ask ourselves why is there centralization? And basically there's centralization because some sophisticated entities can have an edge in producing blocks and being part of this mev pipeline. And if we can remove sandwiches as an edge, then basically we reduce the surface area to be sophisticated and we reduce the surface area for centralization. So in this slide, basically I distinguish multiple types of mev.
00:07:23.746 - 00:09:23.594, Speaker A: There's kind of the positive mev, which arbitrage and liquidations, basically things that the designers of the applications actually want mev extraction to happen because it leads to outcomes for the decentralized application, like prices being arbitraged, but there's the bad stuff which is moving. So it's kind of a great coincidence that encryption kind of removes the bad stuff and keeps the good stuff and also helps with centralization. Now the other thing I want to highlight is around censorship. So one of the kind of counterarguments that you might have around encrypted mempools helping with censorship is you could say that some entities in this Mev pipeline will say I will just not include any encrypted transactions or at least I won't include them unless you tell me that they don't touch certain addresses. So you could imagine for example, a block builder saying I will only include your encrypted transaction if there's an accompanying SNOC saying that it's OFAC compliant. And one of the things that we want to try and do is basically make encryption the default in such a way that if you want to have this very naive strategy of saying I will not include a certain type of transactions, then you need to not include all the encrypted transactions. And the reason here is that if you include an encrypted transaction, you don't know whether or not it passes your filters.
00:09:23.594 - 00:10:28.238, Speaker A: So you have to remove everything. And so you have a massive handicap as a censoring builder. The only thing that you can see in the clear and you can really have an edge on is these arbitrage transactions, but you lose basically the tips for transactions. Okay, so now the final part on the metadata. So one of the things to realize is that when you make a transaction, there's all sorts of metadata that is being leaked. So there's IP address of the sender, there's the size of the transaction, there's who the sender is the tip, the amount that's being paid, there's the gas price for the tip, there's the gas limit, there's the nonce, there's the signature. And there's even more subtle things like the timestamp, the moment in time at which you post a transaction.
00:10:28.238 - 00:11:45.370, Speaker A: And my claim, which is maybe a rather strong claim, is that you can prevent all leakage, you can basically have no privacy leakage whatsoever for any of these things. And really it's a matter of going through them one by one and for each trying to find an appropriate solution to not leak the piece of metadata. So for IP address we have Tor, that's kind of an easy one for the signature. Well, one of the complications here is that usually signatures don't really leak information. There are some schemes that do leak information, but here it's more about transaction validity. So you want to somehow convince that your transaction is valid, your encrypted transaction is valid to the builder who will include it in the block. And one of the things that we can do here is basically use uses a snark, and a Snark has several parts to it.
00:11:45.370 - 00:13:08.658, Speaker A: So it has a public input, it has a private witness, and it has a statement that's being proved in zero knowledge. And so for the signature, what is the public input? Basically the user is saying here's my transaction ciphertext, that's part of the public input. And here is the state route of the ethereum blockchain which is also public and then what the user wants to do is try and convince them that the encrypted ciphertext has a valid signature. And so what they'll do is that what does it mean to verify a signature? It means that you go fetch the associated pub key, you validate it against the state route with a merkel proof and then you prove in zero knowledge within your Snark that your merkel proof is valid and that the signature is valid. And then basically you can do the same thing for every single piece of metadata. So for the gas payment it's a very similar thing. Every account on Ethereum has a balance and you want to go authenticate this balance against the state route and prove that the merkel proof is valid.
00:13:08.658 - 00:14:16.326, Speaker A: And then what's specific to the balance is basically you want to prove an inequality. You want to show that the sender balance is sufficient to pay for the gas cost, for example, the full gas limit given the base gas price. Again, same thing for the nonce, right? Like every account not only has a pub key associated and the balance, but it also has a nonce. Same story here and there's a little subtlety here around the replay tag. So one of the reasons that we have Dosys is basically as an anti Dos mechanism we basically don't want one address to be spamming millions of transactions. We only want basically one address to be able to broadcast only one transaction. And the way we do that is with the nonce.
00:14:16.326 - 00:15:30.450, Speaker A: We basically will only broadcast in the peer to peer network a single transaction for a given address and a given nonce per unit of time, for example. So you can only increase your gas price, for example, once every second. And that provides an anti DDoS mechanism and you can get the exact same anti DDoS mechanism with a so called replay tag. And one way to do it is to basically have an encrypted nonce in a way where basically you hash the nonsense and the private key. And so that's going to be a unique piece of information, a tag for your, for your address and nonce tuple in such a way that if you were to try and spam the peer to peer network then people would realize that the same replay tag is coming over and over again. Great. Now one of the kind of the cool things is thinking about obfuscating the size of the transaction.
00:15:30.450 - 00:16:20.930, Speaker A: So one idea here is to pad to the closest power of two. You have transactions of various sizes and just by looking at the size you might think, okay, this is a uniswap transaction and this is a transfer, for example, because it's smaller. And so what if we just pad to the closest power of two? And I think this is a great solution that gets you 80% of the way there. But there's a couple kind of deficiencies of this solution the first one is that you get imperfect packing. And the reason is that you have to pay for these padding bytes, these zero bytes that you have. You have to put them on chain and you have to pay for the data availability. So there's these little white squares that you have to pay for, which is a bit suboptimal.
00:16:20.930 - 00:17:30.890, Speaker A: And the other thing is that you have imperfect privacy because even though you're padding to the closest power of two, there's still going to be different transaction sizes. And so one of the suggested solutions is basically to use homomorphism, something which is trivial to do with SGX and harder to do with other types of encrypted mempools. But let's see how homomorphism can help us. Well, basically what we're going to do is we're going to apply a function which is the tight packing function. The function just takes the plain text and just packs them as close as possible and then outputs a full block of the maximum size. So if the maximum size of your block is, let's say, 100 KB, which corresponds to, I don't know, a gas limit of 30 minutes, well, you're just going to pack everything within that. And one of the nice things here is that you get both the optimal packing and the optimal privacy.
00:17:30.890 - 00:18:29.820, Speaker A: Now, I don't have much time so I'm just going to skip ahead. But basically you can do the same thing when you're packing. You can also take into account the gas price and you can do prioritization based on that or based on access lists. And I guess one of the things that I only realized recently is that we might actually be able to even hide something a little counterintuitive, which is the timestamp of the transaction. One might think that when you broadcast a transaction it's kind of fundamental to leak the timestamp, but maybe it's not. And basically the idea here is that the peer to peer gossip network can handle a maximum number of transactions. Let's say it can handle 1000 transactions per second being gossiped around.
00:18:29.820 - 00:19:20.700, Speaker A: And so what we can do is that if at any point in time we're under this maximum capacity for the peer to peer network, we can broadcast dummy transactions that look exactly like real transactions because they're encrypted. You can't distinguish them, but you have this kind of this magic homomorphic function that operates on the plain text that is able to filter out the dummy transactions. So as an observer of the mempool, you're just observing a constantly saturated mempool that's processing 1000 transactions a second. But at the end of the day, when you produce a block, all these dummy transactions are filtered out so you don't have to leak information on when users are broadcasting their transactions and that's it. Happy to take questions.
00:19:21.310 - 00:19:35.870, Speaker B: Hey, could I jump in and ask you to say more about the homomorphic encryption plan you had in mind there? The main question I had is who is it that has the secret key for the homomorphic encryption in your setup?
00:19:36.370 - 00:20:36.142, Speaker A: Okay, great question. So here one thing you could do, for example, is you could give every validator, and there's about half a million of those, but let's say there's a million validators, which I expect will happen. Each validator is allowed to make one dummy transaction every epoch, let's say. And so the validators would be observing the mempool, and they would be signing with the validator private key, and they would be able to set the flag, the dummy flag to true. And basically the SNOC that they would publish along with the encrypted ciphertext would say, I'm a validator, and so I'm allowed to produce these dummy transactions. And I know that they will get filtered out because the function that operates on the plain text can just read the flag, see that it's a dummy transaction, and then filter it out. So basically we're making use of the validator honest kind of majority.
00:20:36.142 - 00:20:45.910, Speaker A: Like if we have sufficiently many honest validators producing these dummy transactions, then the mempool just looks like white noise.
00:20:46.410 - 00:21:15.520, Speaker B: Okay? So it's a threshold homomorphic encryption that you have in mind where the secret key for the encryption is like a quorum threshold thing held by the validator nodes. And then that means that the majority of the validator nodes have the ability to decrypt every transaction. But if they follow the rules, then they will only decrypt the added up homomorphic operation transaction after the fact. Is that the right way to think of it?
00:21:18.950 - 00:22:03.866, Speaker A: Not quite. I guess there's two separate questions that you can ask. So I guess the question that you're really asking is what is the flavor of homomorphism? And it turns out the answer is that it doesn't matter. It could be anything. It could be enclave SGX based, it could be threshold based, it could be delay encryption, it could be witness. So each of these five flavors of encryption comes in the vanilla plane mode, or it comes in the advanced kind of homomorphic mode. So you can think of it as a five by two matrix where you have well, this is exactly it a five by two matrix where basically some of these are ready and some of these are not ready for homophobic encryption.
00:22:03.866 - 00:22:52.266, Speaker A: So my claim, for example, is that let's say you have an SGX based solution. You can trivially do these homomorphisms. Now, the question that I was answering previously was around kind of who's feeding these dummy transactions to the encrypted mempool? And here is the validators. But yeah, the validators don't have to participate in the decryption process at all. And if you take something like delay encryption, then really there's no party to trust. You're just trusting physics here, you're trusting intel with the enclave here. You're trusting flashbots, maybe for flashbots protect here, trusting a committee.
00:22:52.266 - 00:23:29.210, Speaker A: But here with delay encryption, you don't have to trust anyone. So just to make it a little bit more concrete, you have 1000 transactions a second that are coming in and they have the property that in 10 seconds they are all automatically decrypt. So that's the delay part. But they also have in addition, a homomorphism property where you can take these transactions and kind of do operations on them in such a way that you go actually build the block while you're going through the process of decrypting them with the sequential computation.
00:23:29.870 - 00:24:13.080, Speaker C: Sorry, I raised my ask. I've been wanting to ask this since I saw your slides from the Columbia presentation. So on which dimension or which dimensions do you think are actually meaningful when we evaluate privacy solutions in the context of MEB mitigation or mev solutions? You labeled, I think, one of the axes of Sophistication and multiple other dimensions. But I guess can you sum it up for us? Technical properties economics? How do you think about this?
00:24:14.730 - 00:24:48.418, Speaker A: Right, I would take a Pragmatic approach and basically, exactly as you said, just follow the Sophistication frontier. So just do whatever we can do. Today. We've started with flashbot protect. I think it's an interesting start, but it has obvious downsides because it's controlled by one entity. I think the next obvious thing is actually SGX, and we have a whole panel to discuss that. I think SGX is ready to be deployed in production.
00:24:48.418 - 00:26:12.250, Speaker A: I think the next move after that is threshold encryption. Now, one of the reasons why I kind of put soon for homomorphic threshold encryption is because of basically Fhe. So you can take an Fhe scheme and you can just thresholdize it by splitting the private key, basically. Now one might say, okay, Fhe is just still years away and that might be true, but it turns out that for very specific use cases, fhe might be perfectly fine. And the one thing that I'm especially kind of excited about is this idea of looking at access lists. So I have a little where is it? Yeah, so here I have this optional access list comment which basically says each transaction can come with an encrypted access list which will be readable in plain text by the homomorphic decryption mechanism. And what you can do is you can try and just pack your transactions in such a way that you have disjoint access lists.
00:26:12.250 - 00:26:57.600, Speaker A: And it might turn out that this is kind of good enough. In practice, you don't have to run the whole EVM within Fhe, you only have to compare access lists. And it turns out that comparing access lists is a so called low depth circuit. So when you're designing these circuits, a little bit like SNOX, you want to make sure that they're small. But for Fhe specifically, you want them to be low depth. And you can do that for access list comparison. Which might mean that Fhe will be ready for the purpose of building optimal enough blocks sooner than people might expect.
00:26:57.600 - 00:27:37.270, Speaker A: And then if we talk about the long term, are we going to have an encrypted mempool within the layer one Ethereum? And I think this will only happen if we have delay encryption, because that's the one thing that's, like, really trustless. You're not relying on the committee. We've been trying to get rid of committees. Obviously, the first two are not applicable for layer one Ethereum because you're trusting companies. But, yeah, delay encryption is the thing that could be enshrined in layer one. But I think that's we're talking maybe half a decade away before things are fully mature.
