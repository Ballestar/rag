00:00:03.050 - 00:00:46.314, Speaker A: All right, so I'm going to talk about a couple of use cases that are what kind of motivated me to think that using SGX and other tes is kind of worth all the downsides and extra work you have to do around them. The kind of basic path of all of my research, if you've followed some bits of it, like various honey badgers work has been moving all the way up the stack of complexity, starting with just consensus and plain text, then smart contract programming is really like, the main thing that I care about. It's so cool. People learn about, commit and reveal smart contracts. Like in the first Smart Contracts tutorial, like Ethereum Name system, everyone clearly is interested in zero knowledge proofs. That's like the number one word of the year, even in Ethereum, which just kind of came as a surprise, but to me, at least like two years past due. So that's great.
00:00:46.314 - 00:01:39.834, Speaker A: But what I've been interested in now for a while is all of the things that you can't do as zero knowledge proofs. Like, yes, zero knowledge proofs don't solve every application. There's plenty of applications that you need one of the more powerful tools to solve. There's only two tools that can be used to solve the applications where zero knowledge proofs kind of hit the wall, and they are multiparty computation and trusted hardware enclaves. And if you ask about like, fully homomorphic encryption, that either means Threshold fully homomorphic encryption, which is a kind of MPC, or it means fully homomorphic encryption where the decryption key is inside a trusted hardware enclave either. So there's really no avoiding one of those two. And I've been kind of duking it out with a secure MPC for a while and I'm kind of more excited about, you know, one nutshell reason of how you can tell if your application doesn't work with ZK proofs is you can't prove what you don't know.
00:01:39.834 - 00:02:11.666, Speaker A: Like there has to be a prover making the proofs. You can only make a proof about data that you have unless you're using one of these other tools. So for anything like an auction where you don't reveal, is that going to be my next slide? No, not yet. Even like an auction where you don't reveal everything after the fact, you can't do that with zero knowledge proofs. You have to give all the bids to someone to make the zero knowledge proofs about. There's really no way around it except to use one of those too. But for the sake of this intro talk, I want to describe the first interaction that kind of led me down this path.
00:02:11.666 - 00:02:54.238, Speaker A: And this started from a conversation that I had with Ari talking about where to go next after the town crier project. So if you know the town crier project, this was where we said, well, there's Oracles, but they can't do everything and they're not very private. So if you add oracles into a trusted hardware enclave, then you can get some privacy guarantee for Oracles. That's great. That's the town crier project. And I'm not interested in just having one application of them. What I really want is to see the full power of privacy rules at the complete disposal at the hands of smart contract developers, so they can come up with whatever they want to be able to be completely unconstrained.
00:02:54.238 - 00:03:37.674, Speaker A: So the conversation that I want to talk about is what led to the delegate paper. This is, I think, one of the lesser well known papers that I've worked on. We had this conversation in 2019 in Shudenic, Croatia, at the Real World Crypto Summit. Real World Crypto Summer School. This was like right before the Zcash conference in the same place. And so having this conversation, phil can probably relate to this, but a lot of my best conversations are like, trying to troll Ari with a weird idea just to see how he reacts to it. And so, you know, what else would we use SGX for? And I'd say, Well, I am so bored by now by the idea that you just take here's an application and now here's the same application on SGX.
00:03:37.674 - 00:04:28.034, Speaker A: That's like so boring. And it usually just takes the fun out of it because it's now kind of too simple. I say, Is there something that you could do if you have this really powerful tool? Let's not just do it by taking existing things and just making them on SGX. Like, if this is a really powerful tool, we should be able to do some things that no one's ever seen before really thought of doing. And the idea that we came up with is, what if you could store your passwords to services inside of an SGX? And the idea would be that you would be able to get more functionality for your existing ordinary Web two account based services than you currently have. The example that we had is like, Netflix sharing. So normally when you want to share your Netflix, you share it by sharing the password, right? But that's kind of like all or nothing.
00:04:28.034 - 00:05:14.958, Speaker A: You either have the password or you don't. There's a thing called delegation, which is something that OAuth often supports. Like you can give read only access to your Twitter feed, but not the ability to write on an application by an application basis. That's because Twitter has a delegation mechanism and we'll carry that out and have a separate token for just read only access versus not. But what if you wanted to give a more fine grained control over that? Like, say, I will give an app the option to post like one tweet per day, but not more than that. Or they can post a tweet, but it has to begin with, Hello, I'm a bot, and then they can only program what comes after that. If Twitter wanted to provide that, obviously they'd be able, you know, what if you wanted to do that? And that wasn't one of the options that Twitter had.
00:05:14.958 - 00:05:59.534, Speaker A: They said, well, if you just put your password in the te and let the te do the logging in for you, you can then sell access to the Tee that is going to log into your account and you could write the programs for the fine grained delegation that you want in the Tee. And so it'll be like a little intermediary holding your password for you, but providing this extra kind of programmable control on top of that ability. And so I think Ari called Surgeon Chapkun from ETH over and kind of talked about this idea. We kind of went through it. And I remember he said something like off the wall like me, likey I just burst into laughter at that and conversation kind of ended. I went away. And then I didn't hear anything about it until like two months later.
00:05:59.534 - 00:06:34.570, Speaker A: I kind of dropped the idea and went to somewhere else. But then Surgeon and his student Shanisha just emailed us and we're like, oh yeah, over the last two months we've built that whole thing and already written it down. And what they came up with was a whole implementation in SGX of a thing where that you have your Netflix as the service. There you are the owner of an account. You go escrow your account by sending it to the delegate service. Or if it can be peer to peer, you send it to a delegate node. And the idea is that this now stores all of your credentials to be able to log into whichever service they made a demo of.
00:06:34.570 - 00:07:14.434, Speaker A: I don't think they got it to work on Netflix, but there was a demo of it working on email when working on PayPal. There's lots of variations of this. In the case of mail, it's like maybe you want to give kind of partial write access to a secretary to like you can respond to invites and you can read any message that comes in if it has the filter hackathon event. But you don't get to read all the email and you don't get to send arbitrary messages. You only get to reply based on this pattern. So the owner sends the program that they want to have be in control of their password. They send the password to the delegate unit and then the executable rules basically have like a marketplace kind of rule.
00:07:14.434 - 00:08:04.920, Speaker A: So this is like, do they have a thing there? The idea is that you can build like a secondary market for partial sharing on top of any service, whether they intend to support it or not. Even if they don't want to support it, then you can do this to block them from being able to stop to you. So again, with the Netflix example, you can give your Netflix password, but it's all or nothing. What if you wanted to be your own Blockbuster and rent out your Netflix to watch one movie for a night and sell that on ebay for some money. That'd be like a secondary market for the use of your account. You can do this by the magic is that you put your password in the te and just trust that it's secure there. But what it lets you do is this functionality that's like super subversive because it's like building an extra market in a place that didn't already have it against the entire wishes of even the service that doesn't want you to be able to resell a portion of your account.
00:08:04.920 - 00:08:49.010, Speaker A: That's the gist of it. I can go on to some other applications, but if you've seen my panel talk or something, they're not like more than that. Let me pause there and see if there's any questions. Actually, this is the only fun new slide that y'all might not have seen. Yeah, I'll give you the short version and I think Kevin's going to give more of like an actual description of kind of like remote attestation things, so maybe we come back to the more details of it there. This kind of interface probably could work with Amdsev. The main thing with Amdsev is that it is meant for use in clouds.
00:08:49.010 - 00:09:19.790, Speaker A: So there's a notion of the host that's like the cloud. There's also the guest owner that's like the person whose account it is that's creating it. And the attestation is between that guest owner and the cloud. But it's only meaningful to the guest owner and in fact, it's based on a diffie hellman key exchange. So you end up with a shared key that the Enclave also has. And so you know that if you get a message from that shared key, it didn't come from you, it had to come from the only other person that has it, which is the Enclave. And that's good.
00:09:19.790 - 00:10:05.680, Speaker A: But if you want to now share this to your users to prove that, oh, I'm not looking at your secret data, I could spoof the same thing that the server told me. So that's great. In an enterprise setting where there's a trusted company and they don't want to trust the cloud, but you're just a company that's not what we want, which is the ability to have blockchains where you're saying, I'm the app developer and I'm in cahoots with the cloud and neither of us can peek at your data. So to me that's the fundamental difference between what SGX lets you do and what AMD lets you do. This version actually probably is okay because you could do this with Amdsev, the guest owner would be the owner of the Credential and then you could do that on the cloud and that might be okay. Any other reactions to this application? Is it surprising or like.
00:10:08.450 - 00:11:03.358, Speaker B: This morning, but this random person asked me through my friend's account on Twitter asking me to search for and if he said, Go back. I was like, is. And then the search work they asked me to do also is when Telegram sent you a reset password. So that showed up. So I started sending the password, and immediately I saw the notification from Telegram, somebody is trying to reset your account. I was like, oh, my God. I was thinking, like, whether there could be, like, every time the password got sent, it sent to a totally different not like the app much easier to attack you to send into your account.
00:11:03.444 - 00:11:30.230, Speaker A: Into the actual app, saying you might not even want to keep your passwords on your own device. Like, not only might you want to share it with another thing, maybe you would want to put it there off phone anyway, and then only like, yeah, that's kind of a good idea. Normally, your device has your password in it. You might want to have read only access to your email account just on your own device. Yeah. So even besides being other people, this kind of same story about having fine grained delegation. Like, I'll have a read only device, a limited device.
00:11:30.230 - 00:12:45.006, Speaker A: This whole thing is saying, if you have the power of tees, you can build that even if the host that the service provider didn't think of providing that. So it's good for backward compatibility with legacy services that aren't doing, like, up to date, OAuth, two kind of delegation. It's maybe not as subversive as saying, oh, you can do this, even if they really don't want you to be able to do that. So that was the idea of building a secondary market on top of services that don't want you to have a market is, to me, just a really exciting thing and that there's not any other way of doing this. So I find that the inspirational kind of quality of trying to do programming with T's. My hope out of advocating for private smart contracts is that smart contract developers get used to kind of a more powerful way of thinking that includes secret information and fine grained control. What else do I have to talk about? I'll skip talking about what do I want to do? You can either hear, like, four minutes about a zero knowledge credit graph application I can give a tutorial, know the high level view of how te based smart contracts work that's applicable to Oasis and Secret Network, as well as Obscuro and Fala, which I think are less well known.
00:12:45.006 - 00:13:18.522, Speaker A: Waiting for feedback on that. All right, so the basic idea of smart contracts is that the smart contracts are going to be private, because the smart contracts are going to run inside the enclave. That's really all there is to it at the first high level. Like, you had smart contracts, now you have smart contracts running inside the enclave, so now they're secure and private. So to get to the details, you have to go a little bit further. So the first kind of key idea is that the enclaves have a secret key that never leaves the enclave. It's generated within the enclave and never leaves it.
00:13:18.522 - 00:14:08.218, Speaker A: But there's a public key associated with that, and that's public. It's associated with the blockchain. And so if you want to send a transaction that only the enclave can compute on to send a message to a private smart contract, you just encrypt your message payload to the public key associated with the enclave. So that's already kind of the basics of the idea there. There's a really critical thing which is Replay Prevention, which is a really well established thing in kind of enterprise uses of SGX, but not as clearly talked about in blockchain applications of it. But the enclave should only be processing the transactions in the order that they actually appear on chain. And so roughly the way that you need to do that is whatever your consensus mechanism is that defines your blockchain committing transactions in order, that's what blockchains do.
00:14:08.218 - 00:15:14.222, Speaker A: You want your enclave to be like a light client that can tell here's a block with an ordered set of transactions and it'll go execute that set of transactions in that order. And it's really important to only execute them in the order that they appear as otherwise, by replaying the same transaction kind of under different contexts, you'd be able to leak more information out of the transaction. That way, there's a really critical issue which is about or a really challenging thing, which is how to do software upgrades. Software upgrades is tough in every blockchain, it doesn't get any easier when you have the tees and private state with it just becomes much, much harder. There's a couple of ways of doing upgrades the first one and kind of the most important one is the idea of doing an interactive exchange between the enclave running the old software and the new enclaves running the new software. So this enclave is the old software, it has the master secret key within it. Here's the enclave running the new software what it does is it generates a new private key and secret key just for this key exchange sends the do I have any animation here? No, I don't.
00:15:14.222 - 00:16:03.626, Speaker A: It sends the public key to the old enclave, along with Attestation Certificate, saying, okay, I'm running the new software, and here's like my, I don't know, proof that the validators approved it and the developers approved it, whatever the rule is. And if that passes, then it encrypts the master secret to the public key of the new enclave. Now, the new enclave also has the secret key under the new rules and it can keep running like that. There's another way of doing secret, of doing software upgrades, which is the way that Secret does it right now, but hopefully that's not the way that they do it in the future, which is that you have a sealed file. A sealed file is SGX technology for the same CPU that wrote the file can read the file, but no other CPUs can do that. There's two options, though. There's Mr Enclave, which says only the same CPU in the exact same program that wrote the file can read the file.
00:16:03.626 - 00:16:53.902, Speaker A: There's Mr signer, which says that only the same CPU in any program signed by the core developers can read the file. So this version is really bad because it means the developer's signing key is also a master decryption key. It can decrypt all the transactions just by code signing a program that outputs the master secret and running that on their own node. So you should only ever use Mr Enclave. But if you only ever use Mr Enclave, then to upgrade to a new piece of software, you need to do this interactive key exchange process. The other detail worth zooming in on is the idea of storage. And this is kind of fun to talk about in the context of what Suave does also, because it loads the whole state into memory all at once, and that's why the current version of Suave has the four and a half hour startup time.
00:16:53.902 - 00:17:42.686, Speaker A: But anyway, the general way that these work is that there's, and this is true of Secret Network and Oasis equally, is that every smart contract system, you've got your EVM and you've got your key value storage in the back end every time you have will this be an animation? Yeah, this will be an animation. So you're going to access the current balance to see if it's enough. The Enclave says out to the untrusted operating system, access this piece of storage, and it encrypts the key that you're asking for. All right, so if it's the balance at this address, it encrypts that address and asks for it. The balance is stored in this untrusted database, also in an encrypted format. So it sends back the encrypted value, but the Enclave can decrypt it. And now it sees the plain text value, and now you'll subtract the value and then write it back.
00:17:42.686 - 00:18:25.518, Speaker A: So you'll send set again, you'll send set with also the encrypted key and the new encrypted balance, and it writes it back. So that's how you have the secure Enclave and an untrusted storage, and it's encrypted. Now, the problem is that the get and the set are using the same encrypted key. So every time you do this, you're using the same key. So the access pattern, which you can just add printfs to, like the untrusted storage, could print out the access trace of which records the smart contract, is accessing. If you just do this in secret, which is what Snip 20 tokens do, or in Oasis, which is what the ERC 20 demo in Oasis does, but it's not recommended that you do it that way. But it's just what the example code does.
00:18:25.518 - 00:19:08.822, Speaker A: It leaks, the sender is already leaked for paying gas, but it leaks the receiver as well, which isn't great, and it's not what it's supposed to do. Monero and Zcash are designed so that you don't reveal who's receiving the tokens, but if you just do the direct thing with Secret and Oasis without doing something extra like the oram that we'll be talking about later, that leaks the receiver. So that's the big issue with that. In general, oblivious Ram is needed because your enclave is just a processor. It only has like, a little bit of memory on it. I mean, they've got pretty big caches. I think you have many megabytes of data of memory on the intel chip, but it's not like your gigabytes of Ram.
00:19:08.822 - 00:20:01.070, Speaker A: So the interaction between the CPU, which is the enclave, and your Ram, which is part of the Untrusted world, goes over the memory bus and the Untrusted operating system is actually in control of the page table. So there's a tool called SGX step, which is not a bug in SGX, it's not an attack on SGX, but it is a library that all the attacks on SGX make use of. And what SGX step lets you do is set the interrupt to like, infinitely small jump into the enclave to let it run for a bit. We're going to get a more lamp. Look guys, already the overcast iron the one thing they don't work with, and what Dave brought up the other day is you can't use them with ceramic.
00:20:02.210 - 00:20:06.638, Speaker B: There you go. That was a hacker right there.
00:20:06.804 - 00:20:33.506, Speaker A: Thank him. All right, where were we? SGX step. So SGX Step set the timer to interrupt zero step into the enclave. The enclave runs one instruction that gets interrupted. Now control goes back to the Untrusted operating system. The other thing SGX step does is it kills all the page tables, so all of the memory is unpinned. So now it ran one instruction, and now the operating system gets a page fault.
00:20:33.506 - 00:21:10.626, Speaker A: So without modifying the enclave, you just have to modify your kernel module. You can output which page of memory is being accessed by each instruction run by the enclave. So it's not leaking the exact record in memory, like, to the byte, but it is leaking which is being accessed to the 40 96 bit page. Like Suave right now is loading. I think that's the right name for it. I don't know. Geth Builder, SGX, whatever, it loads the whole state into virtual memory and then runs transactions on it instead of going to disk for the storage, it is going to memory, but that's going to leave an access pattern at least.
00:21:10.626 - 00:21:44.030, Speaker A: If you try to do like, the interrupty thing and try to read the page faults there, it's going to be leaking to the access pattern that you can print which part of memory is being accessed. Whether that's enough to do mev or not on Suave, I don't really know, but that's just the thing you should be aware of. So, I mean, my message for now is that there's a need for oblivious ram. Oblivious ram is like hand in hand with Design of SGX. This is true on all the old research papers on stuff to do with SGX. They just go hand in hand. But apparently people haven't heard so much about Oram yet, so that's kind of one of the goals, to correct things by this.
00:21:44.030 - 00:21:46.620, Speaker A: All right, now I've definitely used up all the time, so I'll probably stop there.
