00:00:08.970 - 00:01:02.640, Speaker A: My name is James Preswich. I'm currently the CTO at Nomad, which works on arbitrary cross chain messaging. We build governance protocols, token bridges, that sort of thing, that touch multiple different chains. We're live on a bunch of different networks and just adding new network works all the time. I've been working in the crosschain space for about five years now. I started off working on atomic swaps back in 2017, before we had all of these nice things like IBCs and relays, and before the whole crosschain space devolved into multisigs. So my talk today is called Over Committed, and it's about why Mev is so shitty in crosschain environments and why we can't really do anything about that, practically speaking.
00:01:02.640 - 00:01:41.774, Speaker A: So I want to talk about the crosschain message lifecycle real quick. Anytime you're communicating between two blockchains, it goes in three phases. You have to commit on the first chain, on the origin or the sending chain. Some off chain actor needs to see that message, decide to relay it, sign a transaction on the destination chain, and submit that for processing over there. So throughout this, there are two different transactions on different blockchains with an off chain section in the middle. Obviously, this all takes a bunch of time and a little bit of blockchain Rube Goldberg to work. This is how all bridges work.
00:01:41.774 - 00:02:22.354, Speaker A: Every time there's a token bridge, this is how it works. So this talk is called Overcommitted because it's about commitment. I have overcommitted and given too many talks this week. And when you go through a cross chain message cycle, you are over committing to what you want to do. So we have in this process a bunch of different commitments. What's a commitment? It's when you make an irrevocable statement about what you want or what you're going to do or what the message is. So on the origin chain, we kind of neglected a step.
00:02:22.354 - 00:02:47.358, Speaker A: It's like the chain has to run the transaction for it to be sent to the application and to be dispatched to the other chain. And in order for the chain to run sorry, one SEC. Let me move this. There we go. In order for the chain to run the transaction, the user has to send it in the first place. The user has to sign and send an Ethereum transaction before Ethereum does anything. So the user has to commit to their intention.
00:02:47.358 - 00:03:24.154, Speaker A: They're signing this transaction, it calls a specific contract with some data, and the contract is going to do stuff after the transaction is executed. But that doesn't happen until after the user commits to their action and broadcasts it to the network. So the user commits first, and then the chain commits that transaction. The chain actually puts that transaction into the blockchain, includes it in a block, miner runs the whole thing, outputs the new state route, and that transaction includes a commitment to the cross chain message. So the user is committed and now the chain has committed. So we have two commitments here. Now, off chain.
00:03:24.154 - 00:04:21.680, Speaker A: What's going to happen is that some relayer, some third party is going to see that commitment on chain and say, oh, I need to dispatch a message to the other chain. I need to sign a transaction on Avalanche or on Moonbeam or wherever. So the offchain actor sees it, decides to forward it and signs a new commitment containing that message, signs a transaction on the other chain that commits to the message that's supposed to be processed. So we're up to three commitments in this process so far. And then the other chain needs to finally commit the transaction containing the commitment to the commitment to the user's original commitment. So you have to go like four deep here. When you are processing cross chain transactions, you're making multiple commitments over a long period of time, usually minutes or hours.
00:04:21.680 - 00:04:55.530, Speaker A: So finally, after four commitments, the user's intent to send tokens to Moonbeam has been realized. They've gone through the Ethereum process. They signed their Ethereum transaction, they submitted it to Ethereum. It was included in the chain, it was seen by the off chain actor, it was dispatched to the other chain and then it was included in the other chain. It's actually a lot of work and these things fall apart quite often. So that's a lot, right? Like, we go through a lot of steps. There's a lot of commitments, there's a lot of signatures, there's a lot of people involved.
00:04:55.530 - 00:05:24.020, Speaker A: So this is what it looks like for a cross chain message. What do you think it looks like for a single chain message? You see how we just like cross chain, single chain, cross chain, single chain. It's completely different. We go from this to this. It's just like five times easier to process a message on a single chain. We don't even think about it. That's how much we do.
00:05:24.020 - 00:06:05.918, Speaker A: I don't remember how many loops I did on that slide. Okay, so in a single chain transaction, where are the commitments? There's two, like the user signs, like we talked about earlier, and then the transaction submitted to the chain and is committed by the chain when it's included in a block. And then you're done. That's all you have to do. The user's intent was realized after just two commitments and one transaction. So how does this compare to the cross chain thing? It's half as many commitments and it takes significantly less time. And just look at this.
00:06:05.918 - 00:06:55.460, Speaker A: Look at the difference here. It's ridiculous. So you might be thinking, what does all of this have to do with mev? This is mev day, right? Why are we just talking about commitment issues and how many talks I'm giving this week? Excuse me? Mev happens here. Like, between the time the user has signed the transaction and between the time the chain runs the transaction, that's when miners or block producers can insert reorder censor do whatever it is they do to extract mev. It happens because there is a gap between signing and processing. So wait a second. Like signing and processing? Haven't we been talking about that the whole time? Yeah.
00:06:55.460 - 00:07:35.550, Speaker A: If you choose one thing from this talk to remember, this should be it is. Mev is what happens when there is a time gap between commitments. Anytime you have two commitments and there's a gap between them of any sort, mev is what happens because you have committed to your intent, irrevocably committed to what you're going to do, but you haven't done it yet. Your intent hasn't been realized. So let's go back and look for a second. Let's look at our crosschain message again. So there's mev between the time the user signs the initial transaction and the time it's included.
00:07:35.550 - 00:08:39.778, Speaker A: And then there's mev after the transaction has been committed to Ethereum and committed the cross chain message that's supposed to go off to Polygon and the time that that message is actually dispatched to Polygon. And then there's mev between the time that the relayer dispatches that message to Polygon and the time that it's committed. So you might expect that there would be two mev like opportunities in crosschain messaging because there's two transactions, but there's actually three. So crosschain mev is worse than anybody expects when they start getting into this. So mev is created for each transaction in this process, two transactions on two chains, and for the gap between those transactions after Ethereum has committed the message to its state and before that message has been dispatched to Polygon. So technically, this wouldn't be mev, it would be like relayer extracted value, but making up new acronyms just kind of sucks. And mev works great and everyone knows what you mean.
00:08:39.778 - 00:09:41.560, Speaker A: So mev in cross chain messaging is three times as bad at least as mev in single chain transacting. And this is the spicy part of my talk. And then I'm going to end for questions. That's why crosschain DEXes won't work. Because when you submit your crosschain Dex transaction, there are three different parties who can interfere with it, as opposed to just one on a single chain Dex and three different opportunities for them to do so. And because all of these commitments happen sequentially, there is more than three times as much time gap in which these parties can interfere with you, and more than three times as much time gap in which the market can move against you. If you say, I want to swap my USDC on Ethereum for matic on Polygon, there is three times as much mev as if you just swapped that USDC for Matic on Ethereum using uniswap or whatever.
00:09:41.560 - 00:10:14.340, Speaker A: And so that's why crosschain DEXes aren't going to be a thing people are going to bridge and then Dex or vice versa. They're not going to do them both at once. And if you're doing silly things like hop where you dex and then bridge and then Dex again. Well, that's just five times as bad because now you're generating extra mev on each end of the bridge. So that's my talk. I would love to open it up for discussion or questions. I think I have a bit more time because I like rushing through my slides and talking really quickly.
00:10:19.780 - 00:10:20.816, Speaker B: Hi man.
00:10:20.998 - 00:10:21.730, Speaker A: So.
00:10:25.860 - 00:10:30.980, Speaker B: Why don't can we just use atomic swaps? Is there some hidden constraint to this approach?
00:10:31.400 - 00:10:34.352, Speaker A: Have you ever done an atomic swap?
00:10:34.496 - 00:10:50.010, Speaker B: No. Can you just explain it? Okay, well, I get the fundamentals, it's basically a trusted system to swap like assets. But what are the fundamental limits to that and why do we do this?
00:10:53.520 - 00:11:57.920, Speaker A: Right, so an atomic swap is actually a four phase protocol. It requires four transactions, two on each chain for the simplest version, the easiest to implement, it requires two confirmation cycles on each chain before it's committed, before it's fully over and the user has to be online for that entire process. So the user has to be online and personally observing two different chains for the entire usually like hour plus period to execute an atomic swap. If you're going through Bitcoin, which does support atomic swaps and is the origin of the construction, you actually end up spending like 6 hours with a safety margin because of the high variance of Bitcoin's proof of work block time. For further discussion of this, I would look up Dan Robinson's talk at Stanford in 2018. Maybe it's called HTLCs, considered harmful. HTLC stands for hash timelock Contract which is the primitive used to build atomic swaps in most cases.
00:11:57.920 - 00:12:36.510, Speaker A: We did propose and implement an alternative to the atomic swap called the SPV swap which used a bitcoin header relay to verify bitcoin proof of work. In order to execute swaps between Bitcoin and Ethereum, we used it for about ten ETH and could never get anyone interested in it. But it's generally speaking like faster and a bit safer than an atomic swap because there's no user synchrony requirement but nobody likes doing Bespoke cross chain protocols because wallets don't support it and everything's terrible about the user experience.
00:12:37.040 - 00:12:44.448, Speaker B: Do you think the fundamental limit to atomic swap is that nobody wants to fund it because you can't make money from it?
00:12:44.614 - 00:13:34.220, Speaker A: Well, you do have the free option. Problem is the first funder is writing a free option for the second funder in atomic swaps. So you're always incentivized to be the second funder and then to, after seeing the first person's transaction confirmed, decide whether to complete the trade. This also leads to a denial of money, I guess attack, denial of service attack where the second funder can costlessly cause the first funder to lose access to their funds for the duration of the time lock on the atomic swap. Essentially when we built all of the atomic swap stuff back in 2017, 2018, we decided that the UX issues were the main blocker and the financial issues were secondary but also significant.
00:13:36.820 - 00:13:37.730, Speaker B: Thank you.
00:13:39.780 - 00:13:55.190, Speaker A: Sorry, I know that was a big information dump. I can explain more of it if you find me afterwards. This is one of the downsides of being in a specific niche for so long. Like you just pick up all of the useless information and want to talk about it.
00:14:03.980 - 00:14:21.230, Speaker C: Hi, thank you for the talk. So you just described multiple problems with the mev in Bridging and I was wondering if there are any existing solutions or any in progress ones.
00:14:22.800 - 00:15:41.050, Speaker A: So there's two general approaches to mev resistance or to fixing mev for an application. The first is what protocols like Anoma are doing where you actually conceal the contents of the commitment until certain events have happened. So you conceal the contents of the transaction until it's confirmed on chain and then you conceal the contents of the cross chain message until it reaches the other chain and then you conceal what it's doing until it's included in the other chain. So those are in relatively early stages of development but are very interesting and Anoma is doing most of the research and development work in the space on that right now. The other approach that I would recommend for bridges like cross chain messaging specifically is just don't swap assets, don't do things that generate mev on a single chain. Instead of swapping assets, bridge first, then swap or swap first, then bridge. If you are just moving something and you're not trying to get a profit from it there's much much less mev and much less likelihood that someone will interfere with what you're trying to do.
00:15:51.640 - 00:16:27.616, Speaker D: Hi there, thanks for the presentation was great. I'm curious about something because I see a general pattern to try to improve the UX for users, especially in cross chain domains that is just integrating more functionality in a single transaction so that the user doesn't need to reason about the flow. That goes very much into contrast with what you're saying right. That is the user should themselves actually separate these units of interaction to minimize mev or both the preferable UX right. At least I prefer that UX in which I trigger once something and then the chain of things that I want to happen actually happen. It's a bit abstract but I think you get what I mean right?
00:16:27.718 - 00:17:38.436, Speaker A: Yeah is you would love to be able to issue the Bridging instruction and the swap instruction for when it reaches the eventual domain at the same time and then as the user walk away and close your laptop and go outside. I think that is a very important use case and we do work to enable it. What we think is important is that these actions are sequential and not concurrent in any time when we're doing an Asynchronous operation across different blockchains, any component of that can fail. So the Bridging can fail where you don't end up crossing the bridge at all. And the Dex can fail where you end up with the wrong asset, where you end up with what you started with instead of what you wanted. We prefer not to tightly couple those so that they fail independently, and we feel that that gives the user more ability to express what they want. So we support use cases like couple a Dex transaction with a bridge transaction or couple a bridge transaction with a subsequent Dex transaction.
00:17:38.436 - 00:17:51.870, Speaker A: We don't support or believe in use cases like the bridge transaction and the Dex transaction are the same transaction. I said the word transaction an awful lot there, but I hope makes sense.
00:17:57.860 - 00:18:17.320, Speaker E: Just one quick question, as you mentioned. I mean, getting more well gaps between commits, of course, creates more mev opportunities. But is this more a matter of opportunities or is it a matter of magnitude? That is, do actually the individual MUV opportunities actually compete for MUV to be extractable?
00:18:17.980 - 00:19:11.570, Speaker A: That's not necessarily true because they are happening sequentially and there is a time lag when you are doing something like a cross chain Dex. You can actually give me V away to all three of those opportunities because the asset's fair price will move potentially multiple directions while your trade is occurring. So there's usually not a huge increase in magnitude, but there's an increase in opportunities, and there is some increase in magnitude caused by the additional time taken for your trade to fully complete. Thank you. Clipping close.
