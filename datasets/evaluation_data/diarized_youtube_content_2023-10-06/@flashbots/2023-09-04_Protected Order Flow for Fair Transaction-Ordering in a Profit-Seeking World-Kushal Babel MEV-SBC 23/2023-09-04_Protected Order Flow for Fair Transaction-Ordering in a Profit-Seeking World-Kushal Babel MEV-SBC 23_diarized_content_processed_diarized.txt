00:00:02.650 - 00:00:45.766, Speaker A: Thank you for coming out. In the morning after a three day conference, I'm going to talk about our work on prof, which is a system for doing fair transaction ordering in a profit seeking world. This is joint work with collaborators at UIUC, Berkeley, Cornell and Flashbots. Now, a disclaimer before the talk. This, this is very much a work in progress and so you won't see a lot of formal proofs or math, but a bunch of ideas here. And so I also welcome discussion after the talk. All right, so if I had to summarize prof in one slide, it would be this the block that is currently meant for validator.
00:00:45.766 - 00:01:50.560, Speaker A: Using prof you can append a fairly ordered transaction bundle at the end of it and then supply it to the validator while maintaining the current assumptions of the system. So the system is kind of designed in a way that it works with the current system, it's backward compatible and it's designed in a way that the incentives of all the parties should work out. Now, this might give you some flashbacks of the old days of Flashbots protect, but there are some important changes here, namely the trust model and also some ways in which the block is structured. All right, so how do we do this? Well, we first of all leverage Tes. So let me talk a little bit about the te model before actually talking more about the design. So in the Te model you have a program X that's running in the enclave. And the nice properties that you get from these trusted execution environments is that you have integrity in the sense that any person who's controlling the OS or some other processes cannot tamper with the execution of your program.
00:01:50.560 - 00:02:36.590, Speaker A: So you can run this enclave on an untrusted host. And the second property that you get is confidentiality, where nobody can snoop in on your program. So you can actually store secrets on your program. There are some concerns here about side channel attacks and so on. I'll discuss those as well towards the end of the presentation. Now, what makes these tes very useful in practice is they have a capability of doing attestations in the sense that to a remote user these programs can actually prove that yes, the enclave is running this program and it has not been tampered with. So if you trust the platform, the platform generates a signature on the build of the program and so a user can be assured that the program is indeed the correct one that's running inside the enclave.
00:02:36.590 - 00:03:10.042, Speaker A: And as a result, the program can also store secrets, which helps in forming encrypted channels with the users. There are various examples of tees in practice. You have tees from AWS. The most famous is Intel SGX, which also has Attestations. You have AMD and also Arm trust zone. The mental model that I like to think about tes is basically they are really trusted. Third parties, except for a minor caveat that they are not always available, whereas a trusted third party might always be available.
00:03:10.042 - 00:04:12.554, Speaker A: But you can get around availability by having a quorum of Tes. Tes are capable of arbitrary, inexpensive computation in the sense that they execute natively almost at the speed of native CPU. And so you don't incur the massive overheads of complex cryptographic primitives like zero knowledge proofs MPC, fully homophobic encryption or whatnot. But all these nice properties come with some serious provisos and I'll discuss those as well towards the end of the presentation. So, as I said, the system is designed in a way that it fits nicely with the current system of Flashbots and the whole mev supply chain and also uses the technology that is already being embraced by the community, namely Tes. So let's recap the mev supply chain as it exists today. You have the public mem pool and you have some searchers who supply bundles of transactions to different block builders.
00:04:12.554 - 00:05:20.180, Speaker A: Block builders give their full blocks to the relays and the relays are these trusted parties that ideally conduct the auction in a fair manner and give the most profitable block to this plugin mev boost, which makes sure that this block is only released after the Validator has committed to including this block in the consensus. This is sort of an early version of the eventual proposal builder separation that might be enshrined in the protocol. And so, as I mentioned, Tes have already been embraced in the supply chain. Flashbots is already running a builder inside Te and there are plans of using Tes in Suave as well, if I'm not wrong. So now let's look at the design of prof in a little bit of detail and also the incentives therein. So suppose you have these two blocks, B and B Star. B Star differs from B only in the fact that there is an extra bundle of transactions at the end, otherwise B Star is completely identical to B.
00:05:20.180 - 00:06:16.308, Speaker A: Now, you offer these two blocks to the Validator where B pays reward R and B Star pays slightly higher reward because it has additional transactions in it. Now, which one does the Validator choose? Well, the validator would, of course, choose B Star. And where is this extra revenue coming from? This extra revenue is coming from the epsilon transaction fees that these protected transactions might pay. And these transactions through the design of prof are kept completely confidential throughout the supply chain and so they remain protected from any mev extraction. Now, prof, as I mentioned, uses tes. So the idea is the prof program runs inside an enclave and it ingests private transaction flow or even the mempool. And these transactions need to be private because if they were in mempool, there's no point in protecting them anymore.
00:06:16.308 - 00:07:33.072, Speaker A: So you have private transaction flow and you form a transaction bundle out of these transactions. We'll talk a little bit more about what's the policy for forming these transaction bundles you could have fair ordering policies or other policies for that matter and so why do tes help us here? Well, because of their confidentiality properties, you can ensure that the transactions are encrypted and therefore no leakage happens and no MEB extraction happens from these transactions. And because of the integrity properties of Tes, you can make sure that the transaction bundle, even if this entire program is running on site, say at relayer or even at builders, you can be sure that this transaction bundle would be actually formed according to the policy that is encoded in the program. And you can be sure that it's running with high integrity even if you don't trust the host. All right, so this is the design summary slide that I showed. Now, the important thing to note here is after you append the transaction bundle to the block, you don't just yet release the block B star. Just like mevboost, you actually withhold the block B star, you first supply the header to the validator and only after the validator commits to including this header.
00:07:33.072 - 00:08:10.750, Speaker A: By signing this header, you actually release the block. So this is the logical design of prof. Let me go into a little bit of the actual physical design. So we separated this prof entity into two separate entities. One is the prof sequencer that you see on the top left, and the other is the prof bundle merger. Prof sequencer basically abstracts out the part of forming the transaction bundle from the transactions. And we do this so that you can actually enforce different different policies on these transactions.
00:08:10.750 - 00:08:38.854, Speaker A: There can be multiple prof sequencers, each enforcing their own policy, so you don't have to stick to one policy. And so the prof sequencer supplies a protected transaction flow. As you can see, the prof bundle has this shadow around it, which denotes that this prof bundle is encrypted. It supplies this encrypted transaction bundle to the prof bundle merger. The prof bundle merger runs at the relayer. And what the relayer does is it does its usual thing. It conducts the auction for the blocks that are coming from the builders.
00:08:38.854 - 00:09:21.818, Speaker A: But after the winning block from the auction, it supplies the winning block to the prof bundle merger. And the prof bundle merger inside the enclave appends the transaction bundle to the winning block. So again, the relayer is conducting its auction as usual, it supplies the winning block to encrypted to the bundle merger. The bundle merger takes this block and appends the transaction bundle coming from the prof sequencer to this block. And then it makes sure that it does not release the entire thing before actually getting a commitment from the validator. All right, let's talk a little bit about the incentives of parties involved here. Well, for validators, it's quite simple.
00:09:21.818 - 00:10:03.430, Speaker A: If you don't use prof validators, see the block B. And if you have some added transactions at the end, it's only going to incur more profits to the validator. So the validator has an obvious choice in choosing between these two scenarios. Now, why would relayers or builders, why should they adopt prof rather? So as for relays, relays really compete to have their blocks accepted by the validators. You have multiple relays right now, probably nine or ten of them. And all of them are really competing for how many blocks are getting accepted by validators. And so validators are choosing blocks that have additional revenue in them.
00:10:03.430 - 00:10:32.918, Speaker A: And so relays have really incentives to also run the prof bundle merger on site and use prof. And as for builders, the workflow of builder is not really affected. Builders are doing their usual thing. They are extracting mev from the transactions that they can. But at the end of their block, some transactions are getting appended. So their profit calculations, the state changes inside their original block are not affected. So the builders are really not affected by this.
00:10:32.918 - 00:11:33.920, Speaker A: Now, there are alternate designs where we can potentially run prof at the builder level itself, in which case builders can just run two separate instances. One where they pretend that prof doesn't exist, do their usual thing, the other where they actually do the bundle merging and everything and supply both of these blocks to the relayer. And so it's no worse than the current status quo anyways. So for the user, who arguably is the most important part of the system, the user has two options. Either send their transactions to the public mempool and potentially expose themselves to extraction, or include slight epsilon revenue in their transaction through transaction fees and supply it to prof which will keep their transactions confidential until the transaction lands on chain. So we think that the system is designed in a way that all the parties should be happy with the incentives of prof. So there are still some things to be figured out here.
00:11:33.920 - 00:12:20.190, Speaker A: One is, should we implement the bundle merger at the builder or at the relayer? Because there are various considerations there pros and cons of latency, pros and cons of security, trust model and so on. How do we do payment in an efficient manner in the sense that there is only one payment transaction right now from the builders to the validators. Now there might be two payment transactions to the validators if you have to aggregate the payment from the prof bundles. But that's a minor concern. One of the more interesting cases in my opinion is you could also run multiple instances of prof sequencer. So you saw one prof sequencer supplying to the bundle merger. Potentially there can be multiple sequencers having their own policies, all of them supplying protected transaction flows to the bundle merger.
00:12:20.190 - 00:13:05.834, Speaker A: And we also need to do formal study of the mechanism design here, as well as formal comparison to other schemes like mev share, where users do get some money back from their transactions. If you want to read more about the design and various considerations. I would encourage you to have a look at the blog post on the IC Three website. It's a fairly short, very readable blog post so I would highly encourage taking a look at it. Now, I'm going to just discuss two concerns briefly here. One is this concern of some of you might be thinking here we go again, fair ordering and so on. So as I mentioned, you can choose either the fair ordering options that have been proposed by Calcar et al.
00:13:05.834 - 00:13:51.450, Speaker A: Where you have first come, first serve ordering. You could also slap on other things on this ordering which is say secure causal ordering where transactions are not at all revealed before they are committed on chain. You could use a combination of these or maybe neither of these really. You can pick your favorite. Now, as I mentioned about Teas, there is some serious caveats to using Teas, namely that there have been a lot of security vulnerabilities in Teas, especially with respect to confidentiality. Routinely these attacks make it to the news and off late. As you can see, there was a big attack just this month in August.
00:13:51.450 - 00:14:27.074, Speaker A: So why bother with Tes when you have so many vulnerabilities? Well, one argument is defense in depth in the sense that often Tees only add to the security of your application. If Tees were not there, you would just fall back to the status quo. And this is pertinent to prof as well. So if you don't have the Tees, well, users transactions are anyways public without prof. So might as well just use prof, might as well just use Tes to protect users transactions. And there are also ways to bolster Te security. We are actually actively working on ways for that.
00:14:27.074 - 00:14:45.580, Speaker A: We have released a blog post called the Sting Framework. You can also have a look at the Sting Framework on the IC Three website. It talks about how you can protect from the vulnerabilities inside Te and many other scenarios. With that I want to conclude and very happy to answer any questions.
00:14:52.990 - 00:15:10.020, Speaker B: Thank you so much for the talk. Quick question around the biding process. So right now the relay would need to construct a full block and participate as one of the bidders. So how do you think that will add the complexity for a relay and the decision whether they should be implementing the builder side or on the relay side?
00:15:11.190 - 00:15:16.038, Speaker A: Could you provide more details about that? I really didn't understand. Follow the question.
00:15:16.204 - 00:15:26.630, Speaker B: So in the diagram, like way before, where the builder is taking a lot of block and add some private transactions from the Tes, does that change the final bid?
00:15:27.930 - 00:15:46.570, Speaker A: Well, so first of all, the bundle merging is happening at the relayer. So for the builder nothing changes. The builder is whatever payment it was supposed to make, it does make that payment to the validator at the end of it, the transaction bundle is appended and so the bid actually gets changed and the validator sees a higher bid for the same block.
00:15:46.650 - 00:15:51.262, Speaker B: So the relay is not taking any profit and just bids entire delta between B star.
00:15:51.316 - 00:15:51.774, Speaker C: Right.
00:15:51.892 - 00:16:09.762, Speaker A: There are various scenarios there where you could tweak the design to also have some sharing of profits between the validator, the relayer, the builder. And the nice thing here is with Tes you can actually enforce some policies around how that profit is shared. But the idea is, yes, there is some profit to be shared among all the entities.
00:16:09.906 - 00:16:11.160, Speaker B: All right, thank you.
00:16:16.330 - 00:17:02.710, Speaker D: Hi, I had a question about the incentives you were discussing earlier. I think the description we had was that there was sort of the original block with some certain value and then the prof block with an epsilon more. But I think in practice what we see is that a lot of the sort of value of a block is very latency sensitive and so just a couple of milliseconds or tens or hundreds of milliseconds can actually significantly impact the value of the block and higher latency generally means lower value. So presumably this kind of construction would impose latency costs. And if we only expect these epsilon fees from users, is it actually going to be the case? Or have we thought about the scenario where that's not the case where the prof block is necessarily more valuable?
00:17:03.050 - 00:17:36.506, Speaker A: Right. So latency is an important consideration. So for example, if you do this bundle merging at the relayer, then the relayer that's actually running the prof would have to end the auction a little bit earlier and then have time to append the prof bundle. Right. And so the auction kind of lasts for shorter duration than it would have otherwise. The argument there would basically be you could just run two instances of it. In the cases where you do actually receive valuable blocks towards the very end, fine, just submit those to the validator.
00:17:36.506 - 00:17:47.166, Speaker A: But in the cases where that difference is not that much, you could actually submit this prof block to the validator. So it's really just combining these two things and taking the max of the two.
00:17:47.288 - 00:17:53.080, Speaker D: I see, so the prof users would have to wait in the case where there's high latency value.
00:17:55.130 - 00:17:55.638, Speaker C: Yeah.
00:17:55.724 - 00:18:17.086, Speaker A: Where basically towards the end you don't receive very high value blocks. If that is the case. There are some very nice visualizations actually on some website where you can actually see how the winning bid is actually moving over time. Right. And so in some cases the winning bid doesn't move very much towards the last half a second. Right. In those cases the prof block might actually win.
00:18:17.086 - 00:18:23.566, Speaker A: So the relay could just run these two things and supply to the validator. So yeah, it's just the max of the two.
00:18:23.588 - 00:18:24.082, Speaker D: That makes sense.
00:18:24.136 - 00:18:24.900, Speaker C: Thank you.
00:18:29.750 - 00:18:55.100, Speaker E: So, since this is private order flow that's going through, do you think that people would use this as a way to minimize tips, just to not essentially battle it out with others, to not what do you see as a way for people to reduce tips? So if they have the option, just submitting private order flow versus publishing it on the mempool. Do you see this as a way of reducing the actual MEB tip amount?
00:18:56.670 - 00:19:10.030, Speaker A: Well, there's one important difference here in the sense that if you do publish to public mempool, you will have mev extracted from your transactions. Possibly. So if you do go through prof, you do pay that tip, but you don't have mev extracted.
00:19:10.370 - 00:19:11.022, Speaker C: Okay.
00:19:11.156 - 00:19:22.398, Speaker E: So since this will be like bottom of the block, right. So you're also, I guess, like having deprioritization or you lose, that optionality, right? That's like one of the other downsides.
00:19:22.494 - 00:19:55.582, Speaker A: Yeah, that's fine for the users who don't want to be at the top of the block. So for example, if you're a user that wants to kind of have the priority to do any centralized exchange to DeFi Arbitrage, then probably you don't want to be at the end of the block. So that's fine. It's not for those very sophisticated users, but for users who really are not looking for that priority, but who are okay with having their trades at the bottom of the block. This works. Again, as I said, this is very much a work in progress. We are also exploring some designs where you can possibly insert these bundles at the top or maybe somewhere in the middle.
00:19:55.582 - 00:20:00.618, Speaker A: But this design is very clean and does not disrupt the existing supply chain.
00:20:00.714 - 00:20:01.360, Speaker E: Thanks.
00:20:03.410 - 00:20:27.510, Speaker C: First off, great talk. Thank you. Kind of building off that last question, is there a potential design where you could submit private bundles that included transactions from the public mempool? Like, I could submit like a sandwich transaction that sandwiched a public mempool swap. But my sandwich is private, so the validator doesn't know that I'm sandwiching a user.
00:20:28.090 - 00:20:31.990, Speaker A: Right, so you could do that. There's nothing preventing you from doing that.
00:20:32.060 - 00:20:32.486, Speaker C: Okay.
00:20:32.588 - 00:20:50.398, Speaker A: The only caveat is I did not mention this detail during bundle merging, but if there are any duplicate transactions in the bundle right. So you have the transactions from the builder block and then you have some transactions in the bundle. If the bundle has some duplicate transactions, they would automatically be dropped by the bundle merging process.
00:20:50.484 - 00:20:50.766, Speaker C: Got it.
00:20:50.788 - 00:20:58.270, Speaker A: So in that case, if you are including some public transactions which have some sandwiching opportunities that will likely get dropped, your sandwich won't succeed.
00:20:58.350 - 00:21:00.420, Speaker C: Got it. Makes sense. Thank you.
00:21:02.630 - 00:21:25.530, Speaker F: So you're running the merging in the te. So it seems like you're treating the relay as an untrusted entity. But shouldn't you be worried about the relay colluding with a validator if you treat them as untrusted and to basically extract the block without actually making the commitment public? Like essentially if the proposer just gives them a signature, they can get the block out of the Te and they don't need to publish it.
00:21:25.680 - 00:21:39.774, Speaker A: Yeah I mean if you do not trust the Validators either, then you can't do anything about it in the sense that if all the entities collude in the system then of course you don't have protection from mean you could trust.
00:21:39.812 - 00:21:42.266, Speaker F: A validator set but you might not trust specific proposals.
00:21:42.298 - 00:21:42.446, Speaker C: Yeah.
00:21:42.468 - 00:22:06.230, Speaker A: So if you have enough quorum of validators that actually don't do this like collude with the relayers actively, then in those cases yes. But in cases where the Validator is Byzantine yes, you will have collusion and you will have leakage, you can't do anything about it because the validator ultimately has to have that block for publishing and if the Validator colludes does not provide signatures, authentic signature and so on, you can't do anything about it.
00:22:06.380 - 00:22:12.070, Speaker F: And another kind of more practical question is how does the Te determine.
00:22:14.810 - 00:22:15.138, Speaker C: Who.
00:22:15.164 - 00:22:21.194, Speaker F: Is the proposer essentially who is the Validator, whose signature they should release the block to? Are you running a full node inside.
00:22:21.232 - 00:22:26.746, Speaker A: The Te, a light client that basically would have the beacon chain headers and can determine the validators?
00:22:26.778 - 00:22:27.310, Speaker C: Yes. Okay.
00:22:27.380 - 00:22:38.530, Speaker F: And you kind of control the network around it if you're the relay I guess you just shut down if you don't get sufficient signatures or something.
00:22:38.680 - 00:22:38.994, Speaker C: Yeah.
00:22:39.032 - 00:23:11.910, Speaker A: So there are various things there that you can do with checkpointing. Like you can every soft and checkpoint there are various design considerations there like you should also have rollback protection because otherwise things can be rolled back. You might be led to believe that the BCON chain state is something different than it otherwise is. So yes, you will have to have some protections around rollback prevention, around checkpointing every so often for having some root of trust just like in certificate transparency. Yes.
00:23:11.980 - 00:23:12.760, Speaker C: Thank you.
